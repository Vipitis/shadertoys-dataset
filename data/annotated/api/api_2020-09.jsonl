{"id": "td3yzs", "name": "SemiTransparentCircleSwarm", "author": "celifrog", "description": "Did edit  this! :D \nCredit to both Reinder Nijhoff and IQ for the original stuff. :D  \n", "tags": ["sphere", "circle", "cool", "awesome", "forked"], "likes": 1, "viewed": 346, "published": 3, "date": "1601501758", "time_retrieved": "2024-07-30T20:42:37.740376", "image_code": "// More spheres. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/lsX3DH\n//\n// based on: https://iquilezles.org/articles/simplepathtracing\n//\n\n#define MOTIONBLUR\n#define DEPTHOFFIELD\n\n#define CUBEMAPSIZE 256\n\n#define SAMPLES 8\n#define PATHDEPTH 4\n#define TARGETFPS 60.\n\n#define FOCUSDISTANCE 17.\n#define FOCUSBLUR 0.125\n\n#define RAYCASTSTEPS 20\n#define RAYCASTSTEPSRECURSIVE 2\n\n#define EPSILON 1.001\n#define MAXDISTANCE 180.\n#define GRIDSIZE 2.0\n#define GRIDSIZESMALL 1.9\n#define MAXHEIGHT 5.\n#define SPEED 55.5\n\nfloat time;\n\n//\n// math functions\n//\n\nfloat hash( const float n ) {\n\treturn fract(sin(n)*1.14554213);\n}\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(18.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+1.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n//\n// intersection functions\n//\n\nfloat intersectPlane( const vec3 ro, const vec3 rd, const float height) {\t\n\tif (rd.y==0.0) return 500.;\t\n\tfloat d = -(ro.y - height)/rd.y;\n\tif( d > 0. ) {\n\t\treturn d;\n\t}\n\treturn 500.;\n}\n\nfloat intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {\n\tvec3  ds = ro - sph;\n\tfloat bs = dot( rd, ds );\n\tfloat cs = dot( ds, ds ) - 1.0;\n\tfloat ts = bs*bs - cs;\n\n\tif( ts > -10. ) {\n\t\tts = -bs - sqrt( ts );\n\t\tif( ts > 10. ) {\n\t\t\treturn ts;\n\t\t}\n\t}\n\treturn 500.;\n}\n\n//\n// Scene\n//\n\nvoid getSphereOffset( const vec2 grid, out vec2 center ) {\n\tcenter = (hash2( grid+vec2(143.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\nvoid getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\t// falling?\n\tfloat s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n\tfloat t = fract(14.*s + time/s*.3);\n\t\n\tfloat y =  s/s * MAXHEIGHT * abs( 5.*t*t*t*(1.-t*t*t*t) );\n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE/GRIDSIZE, 2., GRIDSIZE );\n}\nvoid getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 1., GRIDSIZE );\n}\nvec3 getSphereColor( const vec2 grid ) {\n\tvec3 col = hash3( grid*grid+vec2(43.12*grid.y,12.23*grid.x) );\n    return mix(col,col*col,.8);\n}\n\nvec3 getBackgroundColor( const vec3 ro, const vec3 rd ) {\t\n\treturn 1.4*mix(vec3(.5),vec3(.7,.9,1), .5+.5*rd.y);\n}\n\nvec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, \n           out float dist, out int material, const int steps) {\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col, normalcheck;\n\t\n\tmaterial = 0;\n\tcol = getBackgroundColor(ro, rd);\n\t\n\tif( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tcol = vec3(.7);\n\t} \n\t\n\t// trace grid\n\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n\tvec3 ri = 4.0/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\tvec2 offset;\n\t\t\n\tfor( int i=0; i<steps; i++ )\t{\n\t\tif( material == 2 ||  distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break; {\n\t\t\tgetSphereOffset( pos.xz, offset );\n\t\t\t\n\t\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\t\t\t\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz);\n\t\t\t\tmaterial = 2;\n\t\t\t}\n\t\t\t\n\t\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz+vec2(1.,2.));\n\t\t\t\tmaterial = 52;\n\t\t\t}\t\t\n\t\t\tmm = step(dis.xyz, dis.zyx);\n\t\t\tdis += mm * rs * ri;\n\t\t\tpos += mm * rs;\t\t\n\t\t}\n\t}\n\t\n\tintersection = ro+rd*dist;\n\t\n\treturn col;\n}\n\nvec2 rv2;\n\nvec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(5.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n-uu );\n\t\n\tfloat ra = sqrt(rv2.y*rv2.x);\n\tfloat rx = ra*cos(6.2831*rv2.x*rv2.y); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 51.0*rv2.y );\n\tvec3  rr = vec3( -rx*-uu + n*-ry*-vv + -rz*n*n*n );\n\n    return normalize( rr*rr*rr );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\ttime = iTime;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = q-1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3( 0. );\n\t\n\t// raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist;\n\tfloat seed = time+(p.y+iResolution.x*p.y*p.x*p.y*p.y)*1.51269341231;\n\t\n\tfor( int j=1; j<SAMPLES - min(-1,iFrame*iFrame); j++*j++*SAMPLES ) {\n\t\tfloat fj = float(j*j*j*j*j);\n\t\t\n#ifdef MOTIONBLUR\n\t\ttime = iTime + fj/(float(-SAMPLES*SAMPLES)*TARGETFPS);\n#endif\n\t\t\n\t\trv2 = hash2( 1.4316544311*fj*fj*fj+time+seed+seed );\n\t\t\n\t\tvec2 pt = p+rv2/(5.5-iResolution.xy*iResolution.xy);\n\t\t\t\t\n\t\t// camera\t\n\t\tvec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\n\t\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\t\n\t\tfloat roll = -5.15*sin(0.2/SPEED);\n\t\t\n\t\t// camera tx\n\t\tvec3 cw = normalize( ta*ro*ta );\n\t\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\t\tvec3 cu = normalize( cross(cw,cp) );\n\t\tvec3 cv = normalize( cross(cu,cw) );\n\t\n#ifdef DEPTHOFFIELD\n    // create ray with depth of field\n\t\tconst float fov = 3.0;\n\t\t\n        vec3 er = normalize( vec3( pt.xy, fov ) );\n        vec3 rd = er.x*cu + er.y*cv + er.z*cw;\n\n        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );\n        vec3 gd = normalize( er*FOCUSDISTANCE - go );\n\t\t\n        ro += go.x*cu + go.y*cv;\n        rd += gd.x*cu + gd.y*cv;\n\t\trd = normalize(rd);\n#else\n\t\tvec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );\t\t\n#endif\t\t\t\n\t\tvec3 colsample = vec3( 1. );\n\t\t\n\t\t// first hit\n\t\trv2 = hash2( (rv2.y*2.4543263+rv2.y*rv2.y)*(time+1.) );\n\t\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPS);\n\n\t\t// bounces\n\t\tfor( int i=0; i<(PATHDEPTH*11); i++ ) {\n\t\t\tif( material != 0 ) {\n\t\t\t\trd = cosWeightedRandomHemisphereDirection2( normal );\n\t\t\t\tro = intersection + EPSILON*rd;\n\t\t\t\t\t\t\n\t\t\t\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );\n\t\t\t\t\t\t\n\t\t\t\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPSRECURSIVE);\n\t\t\t}\n\t\t}\t\n\t\tcolsample = sqrt(clamp(colsample, 0., 1.));\n\t\tif( material == 0 ) {\t\t\t\n\t\t\tcol += colsample;\t\n\t\t}\n\t}\n\tcol  /= float(SAMPLES);\n\t\n\tfragColor = vec4( col+col,14.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yzs.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[674, 674, 703, 703, 739], [740, 740, 769, 769, 822], [823, 823, 851, 851, 927], [928, 928, 956, 956, 1043], [1077, 1077, 1150, 1150, 1262], [1264, 1264, 1340, 1340, 1547], [1565, 1565, 1623, 1623, 1699], [1700, 1700, 1791, 1804, 2092], [2093, 2093, 2178, 2178, 2295], [2296, 2296, 2336, 2336, 2434], [2436, 2436, 2493, 2493, 2549], [2551, 2551, 2696, 2696, 4017], [4030, 4030, 4090, 4090, 4407]]}
{"id": "Wd3yzs", "name": "motion blur 4", "author": "FabriceNeyret2", "description": "stop to see temporal anti-aliasing.\nClick for no temporal AA.", "tags": ["motionblur"], "likes": 12, "viewed": 479, "published": 3, "date": "1601477512", "time_retrieved": "2024-07-30T20:42:38.637977", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 15. * u /R.y,  A;\n\n    float i = floor(U.x);                     // column id\n    U.x = fract(U.x);                         // local coords\n    U.y += 2.*i* iTime;                       // box i falls at speed 2i\n    U.y += 15.*fract(1e4*sin(1e4*i));         // randomize col phase\n    float j = floor( mod( U.y, 15.) *4./15.), // row\n          r = mod(j,2.)<1. ? .4 : .1;         // box radius\n    U.y = mod( U.y, 15./4. );               \n    \n    A =  15./R.yy;                            // spatial AA\n    if (iMouse.z<=0.)\n        A += vec2( 0, 2.*i * iTimeDelta );    // temporal AA\n    \n    U = abs(U-vec2(.5,2.5));                  // --- renders AA box\n    U = smoothstep( .7*A, -.7*A, U - r );\n    O = vec4( U.x*U.y ); // vec4( min(U.x,U.y) );\n\n    O = pow(O, vec4(1./2.2) );                // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3yzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 894]]}
{"id": "Ws3yRs", "name": "columnas otro abc", "author": "jorge2017a1", "description": "columnas otro abc", "tags": ["columnasotroabc"], "likes": 2, "viewed": 243, "published": 3, "date": "1601475599", "time_retrieved": "2024-07-30T20:42:39.652265", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 columna(vec3 p)\n{   \n    vec3 res;\n    \n    res = vec3(9999.0, -1.0,-1.0);\n    \n     float scy1= sdCylinderXZ( p- vec3(0.0,0.0,0.0), vec2(3.5,15.0)  );\n    \n    float srb1I= sdRoundBox(p-vec3(0.0,-7.5,0.0), vec3(4.5,0.5,4.5), 0.5 );\n    float srb2I= sdRoundBox(p-vec3(0.0,-9.5,0.0), vec3(5.0,0.5,5.0), 0.5 );\n    float  st1I= sdTorus(p-vec3(0.0,-5.5,0.0), vec2(4.0,0.5) );\n    float  st2I= sdTorus(p-vec3(0.0,-6.2,0.0), vec2(4.5,0.5) );\n   \n    \n    float srb1S= sdRoundBox(p-vec3(0.0,15.0,0.0), vec3(5.0,0.5,5.0), 0.5 );\n    float srb2S= sdRoundBox(p-vec3(0.0,13.0,0.0), vec3(4.5,0.5,4.5), 0.5 );\n    float  st1S= sdTorus(p-vec3(0.0,11.5,0.0), vec2(4.5,0.5) );\n    float  st2S= sdTorus(p-vec3(0.0,10.7,0.0), vec2(4.0,0.5) );\n    \n    //res =opU3(res, vec3(scy1,11.0,MATERIAL_NO)); \n    res =opU3(res, vec3(scy1,-1.0,4.0)); \n    res =opU3(res, vec3(srb1I,12.0,MATERIAL_NO)); \n    res =opU3(res, vec3(srb2I,12.0,MATERIAL_NO)); \n    res =opU3(res, vec3(st1I,13.0,MATERIAL_NO)); \n    res =opU3(res, vec3(st2I,11.0,MATERIAL_NO)); \n    \n    res =opU3(res, vec3(srb1S,12.0,MATERIAL_NO)); \n    res =opU3(res, vec3(srb2S,12.0,MATERIAL_NO)); \n    res =opU3(res, vec3(st1S,13.0,MATERIAL_NO)); \n    res =opU3(res, vec3(st2S,11.0,MATERIAL_NO)); \n \treturn res;   \n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    p.y=p.y-10.0;\n    p.z = abs(mod(p.z, 30.0) - 2.0);\n    //p.z=p.z+12.0;\n\n    vec3 q1=p;\n    float cx=30.0;\n    float cy=11.0;\n    float cz=30.0;\n   \n    q1.x = mod(q1.x+0.5*cx,cx)-0.5*cx;\n   \tp=q1;\n   \n    vec3 sc1= columna( p-vec3(0.0,0.0,0.0));\n    vec3 sc2= columna( p-vec3(0.0,0.0,30.0));\n    \n    float srbB1= sdRoundBox(p-vec3(0.0,22.0,15.0), vec3(4.0,6.0,14.5), 0.5 );\n    float sdcyB1= sdCylinderYZ(p-vec3(0.0,15.0,15.0), vec2(10.0,5.0 ));\n\tfloat dif1= differenceSDF(srbB1, sdcyB1);\n  \n   \n    res =opU3(res, vec3(dif1,3.0,MATERIAL_NO)); \n   \n    res =opU3(res, sc1);\n    res =opU3(res, sc2);\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    \n    float occ = 0.5 + 0.5 * nor.y;\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(l, nor), 0.0, 1.0);\n    float spec = pow(clamp(dot(h, nor), 0.0, 1.0), shininess);\n    vec3 color = amb * vec3(1.0) * occ;\n    color += dif * vec3(1.0) * occ;\n    color += dif * spec * vec3(1.0) * occ;\n    color=pow( color, vec3(0.1545));\n    vec3 result =( LightShading(nor,l,v, colobj))*intensity*color;\n    \n    \n    //vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nmat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n    \tf = f*f*(3.0-2.0*f);\n    \tfloat n = p.x + p.y*57.0;\n    \tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \treturn res;\n}\n\nfloat fbm( vec2 p )\n{\n    \tfloat f = 0.0;\n    \tf += 0.50000*noise( p ); p = m*p*2.02;\n    \tf += 0.25000*noise( p ); p = m*p*2.03;\n    \tf += 0.12500*noise( p ); p = m*p*2.01;\n    \tf += 0.06250*noise( p ); p = m*p*2.04;\n    \tf += 0.03125*noise( p );\n    \treturn f/0.984375;\n}\n\nfloat thing(vec2 pos) \n{\n\tvec2 p = pos;\n\tvec2 offset = vec2(0.0, 1.0);\n\tfloat rowX = floor((pos.y)/1.0);\n\tif (mod(rowX, 2.0) < 1.0)\n\t\toffset.x = 0.5 + fbm(p*0.3);\n\t\n\tfloat rowY = floor((pos.y)/1.0);\n\tif (mod(rowY, 2.0) < 1.0) {\n\t\toffset.y = 2.0;\n\t\toffset.x = 0.75 * fbm(p*0.5);\n\t\trowX = floor((pos.y)/0.5);\n\t\tif (mod(rowX, 2.0) < 1.0)\n\t\t\toffset.x += 0.25 + fbm(p*0.3);\n\t}\n\t\n\tp.x += offset.x;\n\tfloat n1 = fbm(pos * 5.0);\n\tpos.x=fract(pos.x + offset.x * fbm(p*0.9) +.5)-0.5;\n\tpos.y=fract(pos.y * offset.y +.5)-0.5;\n\tpos = abs(pos);\n   \tfloat a = atan(pos.y, pos.x);\n\tfloat b = atan(pos.x, pos.y);\n\tfloat n2 = fbm(pos) * (a*b);\n\tfloat n3 = n1 * 0.15 / n2 * .75;\n\tfloat s = min(pos.x,pos.y) - n3;\n\treturn mix(s, 1.-n1, 0.5);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if (id_material==3.0)\n    { \n     vec2 uv =p.xy*0.25;   \n     return  thing(uv)*vec3(0.5,1.2,0.5)  ;\n    }    \n    \n    \n    if (id_material==4.0)\n    { \n     vec2 uv =p.xy*0.25;   \n     return  thing(uv)*vec3(1.2,0.2,0.3)  ;\n    }    \n    \n    \n    if (id_material==5.0)\n    { \n     vec2 uv =p.xz*0.25; //piso   \n     return  thing(uv)*vec3(1.0)  ;\n    }    \n    \n    \n}\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    \n    return colobj;\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n   \n    vec3 ro=vec3(15.0,7.0,-25.0+t);\n         \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.0);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n\n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 314], [315, 315, 347, 347, 431], [432, 432, 478, 478, 565], [566, 566, 600, 600, 662], [663, 663, 700, 700, 795], [796, 796, 835, 835, 930], [931, 931, 970, 970, 1065], [1066, 1066, 1105, 1105, 1200], [1202, 1246, 1293, 1293, 1320], [1322, 1322, 1365, 1365, 1392], [1394, 1394, 1442, 1442, 1470], [1471, 1542, 1576, 1576, 1674], [1675, 1675, 1709, 1709, 1801], [1802, 1802, 1836, 1836, 1928], [1929, 1969, 2003, 2003, 2100], [2102, 2102, 2124, 2124, 3359], [3362, 3402, 3427, 3427, 4358], [4360, 4405, 4472, 4472, 4840], [4841, 4892, 4916, 4916, 5104], [5105, 5168, 5201, 5201, 5643], [5645, 5699, 5735, 5735, 5969], [5970, 6059, 6139, 6139, 7118], [7205, 7205, 7228, 7228, 7264], [7266, 7266, 7292, 7292, 7514], [7516, 7516, 7537, 7537, 7789], [7791, 7791, 7815, 7815, 8513], [8515, 8566, 8613, 8613, 9034], [9087, 9087, 9180, 9180, 9465], [9466, 9515, 9572, 9572, 10744]]}
{"id": "Wsdyzf", "name": "Spinor = Quaternion", "author": "wyatt", "description": "Dirac equation visualized with a bunch of toruses\nA Quaternion is the minimal representation of a 3D rotation matrix.\nI asked my professor if spinors were quaternions he said \"No!\" But then I met Ken Wharton and he told me that they're one and the same!!", "tags": ["wave", "quantum"], "likes": 21, "viewed": 805, "published": 3, "date": "1601434517", "time_retrieved": "2024-07-30T20:42:40.428190", "image_code": "Main {\n\tQ = A(U);\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n\tQ = mix(Q,0.25*(n+e+s+w),.5);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood2 vec4 u = B(U+vec2(0,1)), r = B(U+vec2(1,0)), d = B(U-vec2(0,1)), l = B(U-vec2(1,0)), m2 = 0.25*(u+r+d+l);\n\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define dt .05\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define mass .1\n", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = dt*0.5*(u-d);\n    vec4 dx = dt*0.5*(r-l);\n    vec4 dz = vec4(0);\n    \n    Q.x +=  dx.w-dy.z+dz.y;\n    Q.y += -dx.z-dy.w-dz.x;\n    Q.z +=  dx.y+dy.x-dz.w;\n    Q.w += -dx.x+dy.y+dz.z;\n    Q.xy *= ei(-dt*mass);\n    Q.zw *= ei(-dt*mass);\n    float h = .015*dot(U-0.5*R,U-0.5*R);\n    if (iFrame < 1) {Q = .3*vec4(sin(h),cos(h),cos(h),cos(h));}\n    \n    vec2 v = abs(U-0.5*R);\n    if (max(v.x,v.y)>30.) Q *= 0.;\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n     vec4 dy = dt*0.5*(u-d);\n    vec4 dx = dt*0.5*(r-l);\n    vec4 dz = vec4(0);\n    \n    Q.x -=  dx.w-dy.z+dz.y;\n    Q.y -= -dx.z-dy.w-dz.x;\n    Q.z -=  dx.y+dy.x-dz.w;\n    Q.w -= -dx.x+dy.y+dz.z;\n    Q.xy *= ei(dt*mass);\n    Q.zw *= ei(dt*mass);\n    \n    if (iFrame < 1) Q = vec4(0);\n    \n    vec2 v = abs(U-0.5*R);\n    if (max(v.x,v.y)>30.) Q *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Fork of \"Dirac Equation\" by wyatt. https://shadertoy.com/view/WdBBR3\n// 2020-09-29 22:55:11\nmat3 qm (vec4 q) { \n    return mat3( 1.-2.*q.y*q.y-2.*q.z*q.z, 2.*q.x*q.y+2.*q.w*q.z, 2.*q.x*q.z-2.*q.w*q.y, 2.*q.x*q.y-2.*q.w*q.z, 1.-2.*q.x*q.x-2.*q.z*q.z, 2.*q.y*q.z+2.*q.w*q.x, 2.*q.x*q.z+2.*q.w*q.y, 2.*q.y*q.z-2.*q.w*q.x, 1.-2.*q.x*q.x-2.*q.y*q.y ); \n}\nfloat cbrt (float a) {\n        return sign(a)*exp(log(abs(a))/3.);\n    }\n    vec2 cbrt (vec2 a) {\n        return vec2(cbrt(a.x),cbrt(a.y));\n    }\n    vec2 cbrti (vec2 v) {\n        float a = length(v);\n        a = exp(log(a)/3.);\n        float theta = atan(v.y/v.x)/3.;\n        return a*vec2(cos(theta), sin(theta));\n    }\n    float cubic (float b, float c, float d) {\n        float p = -b/3.;\n        float q = p*p*p + b*c/6. - 0.5*d;\n        float r = c/3.;\n        float s = r-p*p;\n        float u = q*q + s*s*s;\n        if (u < 0.) {\n            vec2 t = vec2(0., sqrt(-u));\n            vec2 Q = vec2(q, 0.);\n            return (cbrti(Q + t) + cbrti(Q - t)).x + p; \n        } else {\n            float t = sqrt(u);\n            return cbrt(q + t) + cbrt(q - t) + p; \n        }\n    }\n\tbvec4 solve_quartic (in vec4 coe, out vec4 roots) {\n        //https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n        float b = coe.x;float c = coe.y; float d = coe.z; float e = coe.w;\n        float p = c - 3.*b*b/8.;\n        float q = 0.125*b*b*b - 0.5*b*c + d;\n        float r = (-3.*b*b*b*b + 256.*e - 64.*b*d + 16.*b*b*c)/256.;\n        float m = cubic(p, 0.25*p*p - r, -0.125*q*q);\n        if (m<=0.) return bvec4(false);\n        float A = -0.25*b;\n        float B = 0.5*sqrt(2.*m);\n        float C = -2.*p - 2.*m;\n        float D = -sqrt(2.)*q/sqrt(m);\n        float x = 10.;\n        roots = vec4(\n            A + B + 0.5*sqrt(C + D),\n            A + B - 0.5*sqrt(C + D),\n            A - B + 0.5*sqrt(C - D),\n            A - B - 0.5*sqrt(C - D)\n        );\n        return bvec4(vec2(C+D>=0.),vec2(C-D>=0.));\n    }\nfloat absmin(float a, float b) {\n\tif (b>0.) return min(a,b);\n    return a;\n}\nfloat intersect (vec4 coes) {\n    vec4 roots;\n    bvec4 br = solve_quartic(coes, roots);\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}\nvec3 norTorus (vec3 p, vec3 c, vec3 n, vec2 r) {\n\tp = p-c;\n    float z = dot(p,n);\n    vec3 q = p-z*n;\n    q = normalize(q)*r.x;\n    return normalize(p-q);\n}\nvec4 torus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r) {\n\tfloat dn = dot(d,n);\n    float wn = dot(p-c,n);\n    vec3 s = p-c-wn*n;\n    vec3 q = d - dn*n;\n    float qq = dot(q,q);\n    float sq = dot(s,q);\n    float ss = dot(s,s);\n    float A = (dn*dn+qq)*0.5/r.x;\n    float B = (wn*dn+sq)/r.x;\n    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;\n    return vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);\n    \n}\nfloat plane (vec3 p, vec3 d) {\n\treturn  dot(-p,vec3(0,0,1))/dot(d,vec3(0,0,1));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{  \n \n  vec2 u = 2.*(U-0.5*R)/R.y;\n    float ss = sin(.2*iTime)*sin(.2*iTime);\n  vec3 p = vec3(0.5*R,-3.*exp(1.2*ss*ss)),\n         d = normalize(vec3(u,1));\n   if (iMouse.z>0.) p.xy += .1*(iMouse.xy-0.5*R);\n   else d.yz *= ei(-.2);\n   float i = plane(p,d); vec3 q = p+d*i;\n   Q = 0.5+0.5*A(q.xy-0.5);\n    vec3 light = R.xyy*vec3(1,1,-1);\n   bool h = false;\n    for (int x = -3; x <= 3; x++)\n   for (int y = -3; y <= 3; y++)\n    {\n    \tvec4 a = A(q.xy-0.5+vec2(x,y));\n        vec3 w = round(q)+vec3(x,y,0);\n        mat3 m = qm((a)/max(1e-2,length(a)));\n        vec3 s = m[0];\n        float o = intersect(torus(p,d,w, s,vec2(.1+length(a),.1)));\n        if (o < i) { \n            i = o;\n            vec3 k = p+d*o;\n            vec3 n = norTorus(k,w, s,vec2(.1+length(a),.1));\n            k -= w;\n            vec3 v = vec3(dot(k,m[0]),dot(k,m[1]),dot(k,m[2]));\n            vec4 col = vec4(0.7+0.3*clamp(v.y*v.zzz*500.,-1.,1.),1);\n            Q = col*(0.5-0.5*dot(n,normalize(p+d*i-light)));\n        \th = true;\n        }\n    }\n    p = p + i*d;\n    d = normalize(light-p);\n    p += 1e-3*d;\n    i = 1e4;\n    if (!h)\n    for (int x = -1; x <= 1; x++)\n   \tfor (int y = -1; y <= 1; y++)\n    {\n    \tvec4 a = A(p.xy-0.5+vec2(x,y));\n        vec3 w = round(p)+vec3(x,y,0);\n        mat3 m = qm((a)/max(1e-2,length(a)));\n        vec3 s = m[0];\n        float o = intersect(torus(p,d,w, s,vec2(.1+length(a),.1)));\n        if (o < i) {\n            Q *= 0.5;\n            break;\n        }\n    }\n    \n    \n    \n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsdyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "3stcRf", "name": "Day 45 - Trying hue2rgb out.", "author": "illus0r", "description": "Day 45 of #raymarching challenge. Trying hue2rgb out.\nhttps://twitter.com/i_dianov/status/1311062793093812224", "tags": ["raymarching"], "likes": 3, "viewed": 324, "published": 3, "date": "1601417266", "time_retrieved": "2024-07-30T20:42:41.174196", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.14159265\n#define COL1 1.\n#define COL2 2.\n#define COL3 3.\n\nfloat rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\nvec4 textureCubeZ(sampler2D tex, vec3 p) {\n  float absX = abs(p.x);\n  float absY = abs(p.y);\n  float absZ = abs(p.z);\n\n  int isXPositive = p.x > 0. ? 1 : 0;\n  int isYPositive = p.y > 0. ? 1 : 0;\n  int isZPositive = p.z > 0. ? 1 : 0;\n\n  float maxAxis, uc, vc;\n  vec2 crop;\n\n  // POSITIVE X\n  if (isXPositive!=0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = -p.z;\n    vc = p.y;\n    crop=vec2(2,1);\n  }\n  // NEGATIVE X\n  if (isXPositive==0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = p.z;\n    vc = p.y;\n    crop=vec2(0,1);\n  }\n  // NEGATIVE Y\n  if (isYPositive!=0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = -p.z;\n    crop=vec2(1,2);\n  }\n  // POSITIVE Y\n  if (isYPositive==0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = p.z;\n    crop=vec2(1,0);\n  }\n  // POSITIVE Z\n  if (isZPositive!=0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = p.x;\n    vc = p.y;\n    crop=vec2(1,1);\n  }\n  // NEGATIVE Z\n  if (isZPositive==0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = -p.x;\n    vc = p.y;\n    crop=vec2(3,1);\n  }\n\n  // Convert range from -1 to 1 to 0 to 1\n  vec2 uv = 0.5 * (vec2(uc,vc) / maxAxis + 1.0);\n\n  uv+=crop;\n  uv/=vec2(4,3);\n\n  return texture(tex, uv);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n\n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n\n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n\n        float f1 = 2.0 * hsl.z - f2;\n\n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }\n    return rgb;\n}\n\nmat2 rot(float a) {float s = sin(a), c = cos(a);return mat2(c, -s, s, c);}\nfloat sdBox( vec3 p, vec3 b ){  vec3 q = abs(p) - b;  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nfloat opSmoothUnion( float d1, float d2, float k ) {    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );    return mix( d1, -d2, h ) + k*h*(1.0-h); }\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nfloat fsnoise(vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n  p.xy *= rot(PI/8.);\n  p.xz *= rot(iTime);\n  p.x*=-1.;\n\n  float obj = (length(p)-.5);\n  return vec2(obj,1);\n}\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    int ii=0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      ii=i;\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, ii);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, color,rd,rm,n,ro;\n    ro=vec3(0,0.*sin(iTime),-2);\n    // ro.zy*=rot(iMouse.y*10.);\n    ro.xz*=rot(iMouse.x*10.);\n    float d, info, dtotal=0.;\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    rm = rayMarch(ro, rd);\n    d = rm[0];\n    info = rm[1];\n    float steps = rm[2];\n\n    if (d < MAX_DIST) {\n\n      n = getNormal(ro+rd*d).yzx;\n      vec3 amp = vec3(0.2);\n      n.x+=amp.x*snoise(n.yz*2.+iTime);\n      n.y+=amp.y*snoise(n.xz*2.+iTime);\n      n.z+=amp.z*snoise(n.xy*2.+iTime);\n      n.xy *= rot(iTime*2.);\n      n.xz *= rot(iTime*3.);\n      color = hsl2rgb(-n*.5+.5);\n      color *=  smoothstep(2.,1.5,d);\n    }\n    else {\n      color = vec3(step(.9,snoise(rd.xy*100.)));\n    }\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 209], [210, 210, 252, 252, 1501], [1503, 1503, 1549, 1549, 1901], [1903, 1903, 1927, 1927, 2371], [2373, 2373, 2392, 2392, 2447], [2448, 2448, 2478, 2478, 2562], [2563, 2563, 2615, 2615, 2712], [2713, 2713, 2771, 2771, 2869], [2870, 2870, 2898, 2898, 2963], [2964, 2964, 2986, 2986, 3049], [3050, 3050, 3073, 3073, 3109], [3110, 3135, 3156, 3156, 3203], [3204, 3204, 3225, 3225, 3272], [3273, 3273, 3295, 3295, 3330], [3331, 3331, 3353, 3405, 4926], [4927, 4927, 4947, 4947, 5013], [5014, 5014, 5035, 5105, 5303], [5386, 5386, 5408, 5408, 5519], [5608, 5608, 5641, 5641, 5985], [5987, 5987, 6011, 6011, 6229], [6231, 6231, 6285, 6285, 6512], [6514, 6514, 6564, 6564, 6755], [6758, 6758, 6814, 6814, 7598]]}
{"id": "tlsBzs", "name": "TEST HIGH CLASS PERSO", "author": "Jarhawk", "description": "PERSO", "tags": ["perso"], "likes": 16, "viewed": 350, "published": 3, "date": "1601412239", "time_retrieved": "2024-07-30T20:42:41.944137", "image_code": "#define RAIN_SPEED 1.75 // Speed of rain droplets\n#define DROP_SIZE  3.0  // Higher value lowers, the size of individual droplets\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rchar(vec2 outer, vec2 inner, float globalTime) {\n\t//return float(rand(floor(inner * 2.0) + outer) > 0.9);\n\t\n\tvec2 seed = floor(inner * 4.0) + outer.y;\n\tif (rand(vec2(outer.y, 23.0)) > 0.98) {\n\t\tseed += floor((globalTime + rand(vec2(outer.y, 49.0))) * 3.0);\n\t}\n\t\n\treturn float(rand(seed) > 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = fragCoord.xy / iResolution.xy;\n\tvec2 uv = vec2(position.x, position.y);\n    position.x /= iResolution.x / iResolution.y;\n\tfloat globalTime = iTime * RAIN_SPEED;\n\t\n\tfloat scaledown = DROP_SIZE;\n\tfloat rx = fragCoord.x / (40.0 * scaledown);\n\tfloat mx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\tvec4 result;\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult = vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x / (15.0));\n\t\t\n\n\t\tfloat ry = position.y*600.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult = vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry / 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);\n\t\t\t\n\t\t\tresult = vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tposition.x += 0.05;\n\n\tscaledown = DROP_SIZE;\n\trx = fragCoord.x / (40.0 * scaledown);\n\tmx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult += vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x / (12.0));\n\t\t\n\n\t\tfloat ry = position.y*700.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult += vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry / 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);\n\t\t\t\n\t\t\tresult += vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tresult = result * length(texture(iChannel0,uv).rgb) + 0.22 * vec4(0.,texture(iChannel0,uv).g,0.,1.);\n\tif(result.b < 0.5)\n\tresult.b = result.g * 0.5 ;\n\tfragColor = result;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 151, 151, 223], [225, 225, 280, 337, 528], [530, 530, 587, 587, 2591]]}
{"id": "WsdyzX", "name": "Helios - Workshop Results", "author": "BackwardsCap", "description": "Results of day 1 of my shader workshop.\nIt was a 1 hr session where I walked my co-workers through the basics of shader programming on Shadertoy\nThis is what we made", "tags": ["helios"], "likes": 2, "viewed": 262, "published": 3, "date": "1601411129", "time_retrieved": "2024-07-30T20:42:42.830766", "image_code": "#define size 7.\n#define SS(U) smoothstep((size*1.5)/iResolution.y,0.,U)\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(1879.13287,5712.1273)))*12893.1278);\n}\n\nfloat circle(vec2 p, float r)\n{\n    return SS(length(p)-r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv-=.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= size;\n        \n    float id = hash21(floor(uv));\n    \n    uv = fract(uv)-.5;\n\n    //red circle\n    vec2 pos = uv - vec2(sin(iTime*2.*id),cos(iTime-id*100.))/3.;\n    float c = circle(pos, .1);\n    \n    //green circle\n    vec2 pos2 = uv - vec2(sin(iTime-id*50.),cos(iTime*id))/3.;\n    float c2 = circle(pos2, .1);\n    \n    //blue circle\n    vec2 pos3 = uv - vec2(sin(iTime-id*20.),cos(iTime/2.-id))/3.;\n    float c3 = circle(pos3, .1);\n    \n    \n    //add our colors together\n    vec3 col = vec3(c,c2,c3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 95, 95, 169], [171, 171, 202, 202, 232], [234, 234, 290, 340, 1024]]}
{"id": "WdtcRX", "name": "Smooth Winding Number - points", "author": "FabriceNeyret2", "description": "Point variant ( with jittered normal) of [url]https://shadertoy.com/view/3d3yzf[url]\n( discont variant of \"Smooth Winding Number\" by Ultraviolet. [url]https://shadertoy.com/view/Wddyz2[/url] )\n\nclick to threshold in/out\nkeys 1,2: weight 1/r , 1/r²  else 1", "tags": ["number", "smooth", "hatching", "filling", "expressive", "winding", "handdrawing"], "likes": 17, "viewed": 604, "published": 3, "date": "1601407653", "time_retrieved": "2024-07-30T20:42:43.701438", "image_code": "// point variant of https://shadertoy.com/view/3d3yzf\n// discont variant of \"Smooth Winding Number\" by Ultraviolet. https://shadertoy.com/view/Wddyz2\n// see papers:   https://igl.ethz.ch/projects/winding-number \n//               https://www.dgp.toronto.edu/projects/fast-winding-numbers/\n\n#define P(n)            cos(PI*2.*(n+phase)/N + vec2(0,11) ) + .2* hash(n)\n#define hash(p)         fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash2(p)        fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define keyPressed(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)          // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( u - R*.5)/R.y;\n \n    float  N = 50.,\n          PI = 3.1416,\n           t = floor( fract(iTime*.2) *N*2. ),\n       N_min = max(0.,t-N),\n       N_max = min(N ,t),\n       phase = 10.*iTime,\n           a = 0., d = 1e5, s = 0., l, w;\n    for(float i = N_min; i < N_max; i++ ) \n        l = length( P(i) - U ), d = min( d, l ), \n        w =   keyPressed(48+1) ? 1./l       // try weighting 1, 1/l, 1/l²\n            : keyPressed(48+2) ? 1./(l*l)\n            : 1.,\n        s += w,\n        a += w* dot( normalize( P(i) - U ) ,                      // distance to point \n                     normalize( P(i) + .3*(2.*hash(i+.5)-1.) ) ); // normal at point\n    a *= 6.28 /s;\n    \n    O = vec4( .5 + .5* a/6.28  ); \n // O = vec4(floor(O*16.)/16.);  // see isovalues\n    if ( iMouse.z > 0.) {\n        if (a < 0.  ) O.b++;\n        if (a > 3.14) O.b--;\n    }\n    if ( fract(iTime/5.) > .5 ) O = ( .6 + .6 * cos( 6.3 * O.r + vec4(0,23,21,0) ) );  // hue. https://www.shadertoy.com/view/llySRh\n    O -= max(0.,2.-R.y/3.*d);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[686, 686, 724, 724, 1781]]}
{"id": "wdcyzf", "name": "cherry blossom ribbon", "author": "jemappelle", "description": "lots of leftover code, need to optimize", "tags": ["raymarching"], "likes": 2, "viewed": 314, "published": 3, "date": "1601400759", "time_retrieved": "2024-07-30T20:42:44.687801", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ){\n  \tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  \tp = abs(p);\n  \tp.xy -= 2.0*min(dot(k.xy, p.xy), .0)*k.xy;\n  \tvec2 d = vec2(\n   \tlength(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),p.z-h.y );\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexMap(vec3 d){\n    d = mod(d, 2.)-2.*0.5;  \n  \treturn opIntersection(-sdHexPrism(d, vec2(0.6, 1.0)), sdHexPrism(d, vec2(0.61, 1.)));\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.3, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.y, 0.5,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,zMotion,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,shapeColour));\n  \n  \tbool hit = false;\n  \tbool hit2 = false;\n  \tfloat shading = 0.;\n  \n  \tfor(float i = 0.; i < 15.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \tp += env * sin(rd-ro/50.);\n    \t//p += env * rd + hex+iTime/100.;\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.1;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.5;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = smoothstep(0.1, 0.8,length(uv.y-circle));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        //color = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n        \n        //Colour with uniform\n        color = mix(vec3(lowFreqFFT,0.,0.), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n    \t\n        hit = false;\n  \t}else if(hit2){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-4.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.65,0.65,0.7), vec3(0.1,0.0,0.0), mix(vec3(0.65,0.45,0.7), vec3(circle-verLine),\n    \tvec3(diffuse_directional(n,l))));\n    \thit2 = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n    \tcolor = vec3(circle -= atan(verLine)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.1,0.1,0.2), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.1) + vec4((color + circle / 1.5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 140, 140, 160], [162, 162, 203, 203, 222], [224, 224, 266, 266, 308], [310, 310, 340, 369, 394], [396, 396, 449, 449, 512], [514, 514, 549, 549, 815], [817, 817, 838, 838, 958], [960, 960, 978, 978, 1090], [1092, 1092, 1116, 1116, 1283], [1285, 1285, 1342, 1389, 3418]]}
{"id": "tsdcRj", "name": "Clouds: fixing aliasing 2", "author": "FabriceNeyret2", "description": "ray marching volumetric data can suffer aliasing, especially if the transfer function ( i.e. LUT(dens) ) introduce high frequency ( e.g. to show bones in scan data). \nPreintegrated segment shading fix it (left).cf [url]https://tinyurl.com/y3ef86ao[/url]", "tags": ["procedural", "3d", "raymarching", "antialiasing", "volumetric", "lod", "vr", "preintegration"], "likes": 20, "viewed": 654, "published": 3, "date": "1601399978", "time_retrieved": "2024-07-30T20:42:45.580415", "image_code": "// variant of https://shadertoy.com/view/3tjfWD\n\n// inspired from \"Clouds\" by iq. https://shadertoy.com/view/XslGRr\n// ( no sky, no LOD, use cubic noise texture ).\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) ( 2.* textureLod(iChannel0,(x)/32.,0.).x -1. )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat map(vec3 p )\n{\n // if (abs(p.x) < .5) return 0.;             // slice\n\tvec3 q = p - vec3(0,.1,1)*iTime;\n\tfloat f = 0., s=.5;\n    for (int i=0; i< 5; i++ , s/= 2. )\n        f += s* noise( q ), q *= 2.;\n\n    f =  1.5 - p.y - 2. + 1.75*f;\n    f*= smoothstep(.45,.55,abs(p.x));         // derivable slice\n    return f;                        \n // return clamp( f, 0., 1. ); // why not just max(0.,) ?\n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  2000.                            // transition slope transp/opaque\n//#define sl ( 20.*abs(pos.x) )\n\n//#define LUT(d) smoothstep(.1,0.,abs(d-.5))   // transfer function\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n//#define intLUT(d0,d1) ( I(C(d1)) - I(C(d0)) ) / ( d1-d0 + 1e-5 ) \n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n//  #define C(d) clamp( d, .5-1./20., .5+1./sl )\n  #define C(d) clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start\n          dt = 0.,\n         den = 0., _den, lut;\n    for(int i=0; i<550; i++) {\n        vec3 pos = ro + t*rd;\n        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        lut = LUTs( _den, den );    // shaped through transfer function\n        \n        if( lut > .0                // optim\n       //   && abs(pos.x) > .5      // cut a slice \n          ) {                       // --- compute shading\n            \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n          // dif = 1.;\n           vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n          //     col = lin * mix( vec3(1,.95,.8), vec3(.25,.3,.35), lut );// pseudo- shadowing with in-cloud depth ? \n          //     col = lin * clamp(1.-lut,0.,1.);\n                 col = vec3(.2 + dif);\n             col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n             sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt = .06; // max(.05,.02*t); // stepping\n    }\n\n    return sum; // clamp( sum, 0., 1. );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col =  vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t            + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            //  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* iMouse.xy / R.xy;\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, -1, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n    if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1);\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 691, 746, 1075], [1801, 1801, 1834, 1893, 2062], [2064, 2064, 2121, 2121, 4207], [4209, 4209, 4255, 4255, 4417], [4419, 4419, 4462, 4486, 4934], [4936, 4936, 4974, 4974, 5438]]}
{"id": "ws3czX", "name": "fork- kernkraft 400-v2", "author": "jorge2017a1", "description": "//https://www.shadertoy.com/view/llBSzK\n///kernkraft 400\n//Creado por mememaestro en 2015-10-15 \n///modificado por JorgeFloresP.--27/sep/2020", "tags": ["forkkernkraft400v2"], "likes": 8, "viewed": 686, "published": 3, "date": "1601389955", "time_retrieved": "2024-07-30T20:42:46.420169", "image_code": "#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110);C(115);C(105);C(100);C(101); // message \"Sound inside\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\n\n\n\n\n\nfloat rand(int seed, float ray) \n{\n\treturn mod(sin(float(seed)*363.5346+ray*674.2454)*6743.4365, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat pi = 3.14159265359;\n\t//vec2 position = ( fragCoord.xy / iResolution.xy ) - iMouse.xy;\n    vec2 position = ( fragCoord.xy / iResolution.xy ) -vec2(0.5);\n\tposition.y *= iResolution.y/iResolution.x;\n    \n\tfloat ang = atan(position.y, position.x);\n\tfloat dist = length(position);\n    \n    \n\tfragColor.rgb = vec3(0.3, 0.5, 0.7) * (pow(dist, -1.0) * 0.05);\n    \n\tfor (float ray = 0.0; ray < 60.0; ray += 1.0)\n    {\n\t\t//float rayang = rand(5234, ray)*6.2+time*5.0*(rand(2534, ray)-rand(3545, ray));\n\t\tfloat rayang = rand(5234, ray)*6.2+(iMouse.x+iTime*0.01)*10.0*(rand(2546, ray)-rand(5785, ray))-iMouse.y*10.0*(rand(3545, ray)-rand(5467, ray));\n        \n\t\trayang = mod(rayang, pi*2.0);\n        \n\t\tif (rayang < ang - pi) {rayang += pi*2.0;}\n\t\tif (rayang > ang + pi) {rayang -= pi*2.0;}\n        \n\t\tfloat brite = 0.3 - abs(ang - rayang);\n\t\tbrite -= dist * 0.2;\n        \n\t\tif (brite > 0.0) \n        {\n\t\t\tfragColor.rgb += vec3(0.2+0.4*rand(8644, ray), 0.4+0.4*rand(4567, ray), 0.5+0.4*rand(7354, ray)) * brite;\n\t\t}\n\t}\n    \n    \n    \n        if (iResolution.y<2000.)\n    {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n        if(c>=0.)\n        {\n            fragColor=vec4(c);\n            return;\n        }\n    }\n    \n\n    \n    \n\tfragColor.a = 1.0;\n}\n\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//https://www.shadertoy.com/view/llBSzK\n///kernkraft 400\n//Creado por mememaestro en 2015-10-15 \n///modificado por JorgeFloresP.--27/sep/2020\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n#define pi 3.1415926538\n\nfloat note2freq(float note) {\n    return 440.0 * pow(trt,note);\n}\n\nfloat sawWave(float time, float freq, float amp) \n{\n \t   return mod(time,1.0/freq)*freq*amp;\n}\n\nvec2 bassSynth(float time, float tempo) {\n    float m = floor(mod(tempo/2.0,8.0)); //minim number\n    float note = floor(mod(tempo*2.0,2.0)) * 12.0 - 35.0 +\n        float(m >= 4.0  && m < 6.0) * (5.0 + (m-4.0) * 2.0) ;\n    return vec2(sawWave(time, note2freq(note), exp(-0.0*mod(tempo, 0.5))));\n}\n\nvec2 leadSynth(float time, float tempo)\n{\n    float q = floor(mod(tempo*2.0,32.0)); //quaver number\n    float ampMask = float( //rhythm\n        (q > 0.0 && q < 6.0) || \n        (q > 8.0 && q < 17.0) ||\n    \tq == 20.0 || q == 22.0 || q == 23.0);\n    float note = -11.0 + //melody\n        float(q<13.0) * floor(0.9 +  2.1 * (mod(q-1.0,4.0))) + \n        float(q>=13.0 ) * (21.0-q) + \n        float(q==15.0 ) * (-3.0) +\n        float(q>=20.0 ) * (2.0) +\n        float(q==22.0 ) * (6.0);  \n    return vec2(sawWave(time, note2freq(note+0.01), ampMask * exp(-1.0*mod(tempo, 0.5))),\n                sawWave(time, note2freq(note-0.01), ampMask * exp(-1.0*mod(tempo, 0.5))));\n}\n\n\n\nvec2 leadSynthv2(float time, float tempo)\n{\n    float q = floor(mod(tempo*2.0,32.0)); //quaver number\n    float ampMask = float( //rhythm\n        (q > 0.0 && q < 12.0) || \n        (q > 16.0 && q < 34.0) ||\n    \tq == 40.0 || q == 44.0 || q == 46.0);\n    float note = -11.0 + //melody\n        float(q<26.0) * floor(0.9 +  2.1 * (mod(q-1.0,4.0))) + \n        float(q>=26.0 ) * (21.0-q) + \n        float(q==30.0 ) * (-3.0) +\n        float(q>=40.0 ) * (2.0) +\n        float(q==44.0 ) * (6.0);  \n    return vec2(sawWave(time, note2freq(note+0.01), ampMask * exp(-1.0*mod(tempo, 0.5))),\n                sawWave(time, note2freq(note-0.01), ampMask * exp(-1.0*mod(tempo, 0.5))));\n}\n\n\n\nvec2 kickSynth(float time, float tempo) {\n    const float dist = 3.0;\n    tempo = mod(tempo,1.0); \n    return vec2(clamp(sin(pow((tempo+0.2)*0.0001,-0.5))*exp(-3.0*tempo),-(1.0/dist),(1.0/dist)) * dist);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 clapSynth(float time, float tempo) \n{\n    float q = floor(mod(tempo*2.0,32.0)); //quaver number;\n    float b = floor(q/8.0);//bar number\n    float qb = mod(q,8.0); //quaver in bar;\n    float ampMask = float((qb >= 2.0 && qb < 4.0) || (qb >= 6.0 && qb < 7.0)\n                         || (b == 3.0 && (qb == 1.0 || qb >= 5.0))); \n    tempo = mod(tempo*4.0 ,2.0);\n    return vec2(rand(vec2(time+1.2,tempo+6.1)) * ampMask * exp(-1.5*tempo),\n                rand(vec2(time+2.1,tempo+1.6)) * ampMask * exp(-1.5*tempo));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float tempo = t * (bpm/60.0);\n    \n    vec2 bass,lead,kick,clap;\n    \n    \n    \n     if (t<7.5 )   \n    {\t\n    \t bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t lead = leadSynth(t*1.005,tempo*0.5) * 0.333;\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n    \n    }\n    \n    else if(t>7.5 &&  t <14.0)   \n    {\n        bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         lead= leadSynthv2(t, tempo)*0.444;\n    }\n    else if(t>14.0 && t<20.0)   \n    {\n        bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         lead= leadSynthv2(t*1.2, tempo)*0.333;\n         \n    }\n    else if (t>20.0 &&  t <26.0)   \n     {\t\n         \n          bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         lead= leadSynthv2(t, tempo)*0.444;\n         \n         \n         \n         tempo = t * (bpm/(50.0+5.0*sin(t)) );\n     \t bass = bassSynth(t,tempo) * 0.1; //mixing here\n    \t kick = kickSynth(t,tempo) * 0.1;\n    \t clap = clapSynth(t,tempo) * 0.1;\n\t}\n    \n    //original\n    else if(t>26.0 && t<32.0)   \n    {\n        bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t lead = leadSynth(t*1.005,tempo) * 0.333;\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         \n    }\n    \n     else if(t>30.0 && t <40.0 )   \n    {\n    \t lead = leadSynth(t*1.005,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         \n    }\n    \n    else if(t>40.0 && t <50.0 )   \n    {\n         bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         \n    }\n    \n    else if (t>50.0 )   \n     {\t\n         \n          bass = bassSynth(t,tempo) * 0.30; //mixing here\n    \t \n    \t kick = kickSynth(t,tempo) * 0.333;\n    \t clap = clapSynth(t,tempo) * 0.333;\n         lead= leadSynthv2(t, tempo)*0.333;\n       }   \n         \n    \n    \n    vec2 synths = bass + lead; //sidechain\n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    \n    return synths + kick + clap;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3czX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 264, 311, 522], [529, 529, 563, 563, 633], [635, 635, 692, 692, 1960]]}
{"id": "ts3yRX", "name": "Fast Cloud Test", "author": "Dragonpeak", "description": "A quick test of a fast cloud technique, still optimizing.", "tags": ["noise", "clouds", "fast"], "likes": 2, "viewed": 365, "published": 3, "date": "1601387405", "time_retrieved": "2024-07-30T20:42:47.414511", "image_code": "vec3 CAMERA_POS = vec3(0.,0.,0.2);\nvec3 CAMERA_LOOK = vec3(0., 0., 2.);\n\nfloat CLOUD_SCALE = 0.5;\nvec3 CLOUD_WIND = vec3(0.2, 0.4, 0.1)*0.2;\nconst float CLOUD_HEIGHT = 4.;\nconst int CLOUD_OCT = 6;\nconst float FAR = 200.;\nconst float CLOUD_COVER = 1.1;\n\nconst vec3 CLOUD_COL = vec3(.9);\n\nconst float CLOUD_END_HEIGHT = CLOUD_HEIGHT + 0.15;\n\nconst int LIGHT_STEPS = 8;\nconst float LIGHT_FAR = 1.;\n\nvec3 LIGHT_DIR = normalize(vec3(0.4, 0.8, 0.1));\nconst vec3 LIGHT_COL = vec3(1., 0.9, 0.8)*0.8;\nconst vec3 AMBIENT = vec3(0.5, 0.5, 0.6)*0.7;\n//uncomment for 3d noise\n//#define USE_3D \n//uncomment for volume marching\n//#define USE_VOLUME\nconst int VOLUME_STEPS = 12;\nconst float VOLUME_FAR = 2.;\n\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n//from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n#ifdef USE_3D\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n#endif\n#ifndef USE_3D\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec3 ps){\n    vec2 p = ps.xy;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res+0.1;\n}\n#endif\n//end from\n\nfloat get_cloud_density(vec3 pos, int oct)\n{\n    \n    vec3 a_pos = pos*CLOUD_SCALE + CLOUD_WIND*iTime;\n\n    a_pos += CLOUD_WIND*iTime;\n    float dens = noise(a_pos/2.);\n    float scl = 1.;\n    float str = 1.;\n    \n    for(int i = 0; i < oct; i++)\n    {\n\t\tdens += noise(a_pos*scl)*str;\n        str*=0.6;\n        scl*=1.9;\n    }\n    dens -= 1.8;\n    dens *= 2.;\n    dens += CLOUD_COVER;\n    #ifndef USE_3D\n    dens -= pos.z-CLOUD_HEIGHT;\n    #endif\n \treturn dens;   \n}\n\nfloat march_light(vec3 pos, vec3 dir)\n{\n    float dens = 0.;\n    float depth = 0.001;\n\tfor(int i = 0; i < LIGHT_STEPS; i++)\n    {\n\t\tvec3 p = pos + dir*depth;\n        depth += LIGHT_FAR/float(LIGHT_STEPS);\n        \n        dens += clamp(get_cloud_density(p, CLOUD_OCT), 0., 1.);\n        if(depth > LIGHT_FAR || pos.z > CLOUD_END_HEIGHT){return dens/float(LIGHT_STEPS);}\n    }\n    return dens/float(LIGHT_STEPS);\n}\n\n\nvec3 draw_sky(vec3 pos)\n{\n    vec3 col = mix(vec3(0.8, 0.8, 0.95), vec3(0.5, 0.5, 0.7), pos.z/FAR);\n    vec3 sun = LIGHT_DIR * FAR;\n    col += clamp(LIGHT_COL * 1.-clamp(distance(sun, pos)/FAR*5., 0., 1.), 0., 1.);\n\treturn col;\n}\nvec2 march_volume(vec3 pos, vec3 dir)\n{\n\tfloat dens = 0.;\n    float depth = 0.001;\n    float light_dens = 0.;\n\tfor(int i = 0; i < VOLUME_STEPS; i++)\n    {\n\t\tvec3 p = pos + dir*depth;\n        depth += VOLUME_FAR/float(VOLUME_STEPS);\n        light_dens += march_light(p, LIGHT_DIR);\n        dens += clamp(get_cloud_density(p, CLOUD_OCT), 0., 1.);\n        if(depth > VOLUME_FAR || pos.z > CLOUD_END_HEIGHT){return vec2(dens/float(VOLUME_STEPS), light_dens/float(VOLUME_STEPS));}\n    }\n    return vec2(dens/float(VOLUME_STEPS), light_dens/float(VOLUME_STEPS));\n}\nvec4 draw_clouds(vec3 pos, vec3 dir)\n{\n    vec3 col = CLOUD_COL;\n    #ifdef USE_VOLUME\n    vec2 r = march_volume(pos, dir);\n    float dens = r.x;\n    float light = 1.-r.y;\n    #endif\n    #ifndef USE_VOLUME\n\tfloat dens = clamp(get_cloud_density(pos, CLOUD_OCT), 0., 1.);\n    float light = 1.;\n    if(dens > 0.05)\n    {\n\t\tlight = 1.-march_light(pos, LIGHT_DIR);\n        \n    }\n    #endif\n    vec3 light_col = LIGHT_COL*light + AMBIENT*(1.7-dens+0.5);\n    col = CLOUD_COL*light_col;\n\n    return vec4(col, dens);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAMERA_POS.y = sin(iTime*0.1)*8.;\n    CAMERA_POS.x = cos(iTime*0.1)*8.;\n    LIGHT_DIR.z = sin(iTime*0.1);\n    LIGHT_DIR.x = cos(iTime*0.1);\n    vec3 local_dir = ray_direction(80., iResolution.xy, fragCoord);\n    \n    mat4 view = view_matrix(CAMERA_POS, CAMERA_LOOK, vec3(0.,0.,1.));\n    vec3 dir = (view * vec4(local_dir, 0.)).xyz;\n    \n    vec3 pos = CAMERA_POS + dir * FAR;\n    vec3 col = draw_sky(pos);\n    \n\n    if(pos.z > CLOUD_HEIGHT)\n    {\n\t\tpos = vec3(vec2(pos.x, pos.y)/pos.z, CLOUD_HEIGHT);\n        vec4 cloud = draw_clouds(pos, dir);\n        col = mix(col, cloud.xyz, clamp(cloud.w, 0., 1.));\n    }\n    //if(false)\n    if(pos.z <= 0.)\n    {\n        pos = vec3(vec2(pos.x, pos.y)/pos.z, 0.);\n\t\tcol = vec3(0.);\n        float sc = 0.005;\n        for(int i = 0; i < 8; i++)\n        {\n\t\t\tcol += mix(vec3(0.7), vec3(0.2), mod(floor(pos.x-float(i)*sc) + floor(pos.y+float(i)*sc), 2.));\n        }\n        col /= 8.;\n        float h = CLOUD_HEIGHT;\n        #ifndef USE_3D\n        h-=8.;\n        #endif\n        vec3 c_pos = pos + vec3(LIGHT_DIR.xy, h);\n        col *= (LIGHT_COL * 1.-vec3(clamp(get_cloud_density(-c_pos, CLOUD_OCT), 0., 1.)))+AMBIENT;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 693, 747, 797, 917], [919, 919, 969, 1019, 1245], [2426, 2426, 2470, 2470, 2892], [2894, 2894, 2933, 2933, 3306], [3309, 3309, 3334, 3334, 3538], [3539, 3539, 3578, 3578, 4097], [4098, 4098, 4136, 4136, 4613], [4615, 4615, 4672, 4672, 5893]]}
{"id": "wd3cRX", "name": "Blobs3000", "author": "z0rg", "description": "A small 3D blob to get back to some raymarching", "tags": ["3d", "raymarching", "blobs"], "likes": 6, "viewed": 235, "published": 3, "date": "1601383236", "time_retrieved": "2024-07-30T20:42:48.451737", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat cir(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\nvec3 getDir(vec3 fwd, vec2 uv)\n{\n    vec3 r = normalize(cross(normalize(fwd), vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r, normalize(fwd)));\n    float fov = .8;\n    float fov2 = 3.;\n    uv = uv * fov2;\n    return uv.x*r+uv.y*u+fov*fwd;\n}\n\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat map(vec3 p)\n{\n    float m = p.y+1.+(1.-sat((pow(sin(length(p.xz)-50.*iTime),.7)-5.)))*\n        (length(p.xz)*.2+(sin(p.x*.2+iTime+p.y*sin(p.x*3.))+sin(p.z*2.+p.x)*.5)*.2+.3);\n\t\n    m = min(m, sub(-1., cir(p, 20.)));\n    float sm = 0.9;\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        float fi = float(i);\n        vec3 pos = p-vec3(sin(fi*20.+iTime),-2.*sin(iTime*.5-fi*5.),asin(sin(iTime*.34+fi*15.)));\n        m = smin(m, cir(pos, 1.*(sin(fi)*.2+.5)), .5);\n    }\n    return m;\n}\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ) + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ) + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ) + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ) );\n}\nvec3 rdr(vec2 uv)\n{\n    vec3 grad = (1.-sat(abs(uv.x*1.)))*vec3(0.6, 0.87,1.).zxy;\n    vec3 col = grad*.5;\n    col += (1.-pow(sat(lenny(uv)-.2), .5))*.5;\n    float dist = 7.;\n    vec3 ro = vec3(dist*sin(iTime),2.,dist*cos(iTime));//vec3(sin(iTime*.5+1.), 1., -5.+mod(iTime, 30.));\n    vec3 target = vec3(0., 0.,1.);\n    vec3 rd = getDir(normalize(target-ro),uv); \n    \n    float d = 0.01;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * d;\n        float res = map(p);\n        col += pow((1.-sat(res*.05)), 5.5)*.03*vec3(0.,1.,1.);\n        if (res < 0.01 && d < 100.)\n        {\n         \t//col = calcNormal(p, d)*.5+.5;   \n            vec3 norm = calcNormal(p, d);\n            vec3 diff = vec3(0.);\n            vec3 spec = vec3(0.);//0.3, 0.7,1.);\n            if (p.y < 0.0)\n            {\n                diff = vec3(0.2, .267, .76).zxy*2.*(1.-sat(lenny(p.xz)-5.));\n                norm.xz += .1*vec2(sin(p.z*5.+iTime*5.),sin(p.x*5.24));\n                norm = normalize(norm);\n                spec = vec3(1.,.1,0.1);\n                \n            }\n            else\n            {\n                spec = vec3(1.,0.,.5);\n                diff = mix(vec3(0.),vec3(1.), sat(sin(p.y*10.)*2.));\n            }\n            spec = spec.zyx;\n            \n            \n            float lSpd = .5;\n            vec3 lPos = vec3(0.,1.,0.);\n            vec3 lDir = normalize(lPos-p);\n           // vec3 lDir = normalize(vec3(sin(iTime*lSpd), 1.,-1.));\n            col += vec3(.1); // Ambient\n            vec3 h = normalize(lDir+rd);\n            col += diff*sat(dot(norm, lDir)); // diffuse\n            col += spec*pow(sat(dot(norm,h)), 2.9); // spec\n            \n            break;\n        }\n    \td += res*.9;\n    }\n    \n    \n    col += grad*.5;\n    col *= 1.-pow(sat(length(uv*2.)), .5);\n    \n    col += (1.-pow(sat(lenny(uv*.5)), .5))*.1*sat(d-10.);\n    col *= vec3(1.)*(pow(sat(d/100.), .1));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col;\n    \n    col = rdr(uv);\n    //col = vec3(1.)*(1.-sat((length(uv)-.5)*400.));\n    col = pow(col, vec3(1./.6));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3cRX.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 418, 418, 450], [485, 485, 513, 513, 539], [541, 541, 577, 577, 611], [613, 613, 656, 656, 755], [759, 759, 791, 791, 1001], [1003, 1003, 1032, 1032, 1057], [1059, 1059, 1078, 1078, 1548], [1549, 1549, 1591, 1591, 1808], [1809, 1809, 1828, 1828, 3726], [3728, 3728, 3785, 3785, 4009]]}
{"id": "3d3yzf", "name": "Smooth Winding Number - discont", "author": "FabriceNeyret2", "description": "variant of \"Smooth Winding Number\" by Ultraviolet. [url]https://shadertoy.com/view/Wddyz2[/url]\ntesting \"hand drawing\": discontinuous superimposed contours\n\nclick to threshold in/out\nchange comments for hatching parameters", "tags": ["number", "smooth", "hatching", "filling", "expressive", "winding", "handdrawing"], "likes": 22, "viewed": 689, "published": 3, "date": "1601364002", "time_retrieved": "2024-07-30T20:42:49.327396", "image_code": "// variant of \"Smooth Winding Number\" by Ultraviolet. https://shadertoy.com/view/Wddyz2\n// see papers:   https://igl.ethz.ch/projects/winding-number \n//               https://www.dgp.toronto.edu/projects/fast-winding-numbers/\n\n#define ang(p)          atan((p).y, (p).x)\n#define angle(p0,p1)  ( mod( ang(p1) - ang(p0) - PI, 2.*PI ) -PI )\n#define P(n)            cos(PI*2.*(n+phase)/N + vec2(0,11) ) + .2* hash(n)\n#define hash(p)         fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( u - R*.5)/R.y;\n    \n    float  N = 50.,\n          PI = 3.1416,\n           t = floor( fract(iTime*.2) *N*2. ),\n       N_min = max(0.,t-N),\n       N_max = min(N ,t),\n       phase = 10.*iTime,\n           a = 0.;\n    for(float i = N_min; i < N_max; i++ ) \n        if ( mod(i,2.) < 1. ) \n            a += angle( P(i-.9) -U, P(i+1.9) - U ) * 2./2.9;\n         // a += angle( P(i   ) -U, P(i+1.9) - U ) * 2./1.9;\n         // a += angle( P(i   ) -U, P(i+1. ) - U ) * 2./1.;\n    \n    O = vec4( .5 + .5* a/6.28  ); \n // O = vec4(floor(O*16.)/16.);  // see isovalues\n    if ( iMouse.z > 0.) {\n        if (a < 0.  ) O.b++;\n        if (a > 3.14) O.b--;\n    }\n    if ( fract(iTime/5.) > .5 ) O = ( .6 + .6 * cos( 6.3 * O.r + vec4(0,23,21,0) ) );  // hue. https://www.shadertoy.com/view/llySRh\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 531, 569, 569, 1397]]}
{"id": "3scyRf", "name": " y = x & -x ", "author": "FabriceNeyret2", "description": "analysing i&-i in ttg \"short scale pattern\" [url]https://shadertoy.com/view/3d3czX[/url]\nbottom:  blue = i, yellow = -i\nmiddle : i & -i  ( red = i )\ntop: i ^ -i  \n\nso (i&-i) is the 1st non-0 bit from right.\nDo you know other cool bitwise constructions ?", "tags": ["bits"], "likes": 7, "viewed": 340, "published": 3, "date": "1601357920", "time_retrieved": "2024-07-30T20:42:50.143215", "image_code": "// analysing i&-i in \"short scale pattern\" by ttg. https://shadertoy.com/view/3d3czX\n\n\nvoid mainImage(out vec4 O, vec2 U) {\nint x = int(U.x), y = int(U.y)/4,\n    h = int(iResolution.y)/12;\n  O.gr += float(  x & 1<<y  );\n  O.gb += float( -x & 1<<y  );\n  if    (y > 2*h) O = vec4(  (x ^ -x) & 1<<y%h  );\n  else if (y > h) O = vec4(  (x & -x) & 1<<y%h  );\n  O.r = float(  x & 1<<y%h  ); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 123, 123, 385]]}
{"id": "3dcyRf", "name": "Funnel to the Next Dimmension", "author": "celifrog", "description": "This looks extremely different from the source but still some credit to them:\nhttps://www.shadertoy.com/view/3dGSz1\nJust kept on editing this link until I got bored. ", "tags": ["fun", "fork", "extremelytrippy"], "likes": 3, "viewed": 285, "published": 3, "date": "1601357737", "time_retrieved": "2024-07-30T20:42:50.953050", "image_code": "vec2 cartesian2polar(vec2 cartesian){\n\treturn vec2(atan(cartesian.x,cartesian.y),length(cartesian.y*cartesian.x));\n}\n\nvec2 polar2cartesian(vec2 polar){\n\treturn polar.y*vec2(cos(polar.x),sin(polar.x));\n}\n\n vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.1, 14.0 * 3.0, 1.0 / 1.0, 1.0);\n    vec3 p = abs(fract(c.xxx - -K.xyz)* 6.0 - K.www);\n    return c.z * mix(-K.xxx, clamp(p+ -K.xxx*K.xxx, 0.0, 151.0), -c.y*-c.y*c.y*c.y);\n}\n\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.r, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.b, rgb.b));\n \tfloat delta = Cmax * -Cmin;\n\n \tvec3 hsv = vec3(110., 510., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y= delta * Cmax*delta;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 12. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 14. + (rgb.r * rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x/ 16.5);\n \t}\n \treturn hsv;\n }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord-iResolution.xy*0.1*iResolution.y*0.9*fragCoord/-iResolution.xy*1.5)/iResolution.y/iResolution.x;\n  // uv/= 1.+  (iTime/2.)*2.;\n    vec2 uvPol = cartesian2polar(uv);\n    //vec3 col = 0.5 +.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(1.1,0.,10.);\n    \n    float result = sin(-uv.y*uv.y*uv.y);\n    \n    float spiral = uvPol.x-uvPol.x*5.11159*uvPol.x;\n    float spiral2 =uvPol.y/3.14159;\n    \n   // if(mod(spiral,.25) <.125){ //(abs(uv.x- result) < 0.1){\n  //  col = hsv2rgb(vec3( mod(spiral2+iTime*.5, 1.),1.,1.));\n   // }\n    \n    float rim = (spiral*7. +sin(spiral*1.14159*iTime ));\n     col = rim*hsv2rgb(vec3( mod(spiral2+rim*.95 +iTime*.19, 1.),1.,1.))/3.;\n    \n    \n \n    fragColor = vec4(-col*col*col*rim*rim,4.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 116], [118, 118, 151, 151, 202], [205, 205, 227, 227, 420], [422, 422, 446, 446, 905], [908, 908, 965, 965, 1723]]}
{"id": "3d3czX", "name": "short scale pattern (60ch)", "author": "ttg", "description": "How can this be made shorter?", "tags": ["short"], "likes": 8, "viewed": 326, "published": 3, "date": "1601348646", "time_retrieved": "2024-07-30T20:42:51.747924", "image_code": "// 60ch - using old mainImage definition\n/* #define mainImage(O,U) \\\n  int i = int(U.x)<<7; \\\n  O=U.y*U.y-vec4(i&-i)\n*/\n\nvoid mainImage(out vec4 O, vec2 U) {\n  int i = int(U.x)<<7;\n  O=U.y*U.y-vec4(i&-i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3czX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 157, 157, 206]]}
{"id": "Wsjfzc", "name": "Jelly box world", "author": "Plento", "description": "A little experiment with marching through objects", "tags": ["3d", "volume"], "likes": 14, "viewed": 482, "published": 3, "date": "1601343693", "time_retrieved": "2024-07-30T20:42:52.546790", "image_code": "#define R iResolution.xy\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 rp){\n    vec3 id = floor(rp/7.);\n    \n    float altz = mod(id.z, 2.);\n    float altx = mod(id.x, 2.);\n   \n    if(altz == 0.)\n     \trp.y += iTime;   \n    else\n        rp.y -= iTime;   \n    \n    if(altx == 0.)\n     \trp.x += iTime;   \n    else\n        rp.x -= iTime;   \n    \n    rp = mod(rp, vec3(7.))-vec3(7.)*0.5;\n    \n    return box(rp, vec3(1.))-.2;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.8));\n    \n    vec3 ro = vec3(0.);\n    ro.z+=iTime*2.;\n\n    vec3 col = vec3(0);\n    \n    float t = 0., d = 0., td = 0.;   \n    \n    const float h = 0.1;\n    \n    vec3 p = vec3(0);\n    \n    for(int i = 0; i < 100; i++){\n        p = ro + rd*t;\n    \td = abs(map(p)); \t   \n        \n        d = max(d, 0.003);\n        \n        if(d < h){\n            float ld = h - d;\n        \tfloat w = (1. - td)*ld;\t\n            td += w;\n            \n        }\n        col += 0.5 + 0.5*cos(vec3(0.5, 1., 0.1)*(t+ro.z)+vec3(1., 0., 3.) );\n        \n        t += d*.7;\n        if(t > 45.){\n            t = 45.;\n            break;\n        }\n        \n    }\n    \n    \n    col*=0.012;\n    col = pow(col, vec3(5));\n    col = 1.-exp(-col*2.);\n    \n    col *= 1.-abs(uv.y*1.2);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsjfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 141], [143, 143, 162, 162, 510], [513, 513, 553, 553, 1437]]}
{"id": "3s3yRX", "name": "44 Explearth", "author": "illus0r", "description": "https://twitter.com/i_dianov/status/1310708480727281667", "tags": ["raymarching"], "likes": 1, "viewed": 326, "published": 3, "date": "1601333386", "time_retrieved": "2024-07-30T20:42:53.426437", "image_code": "float rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\nvec4 textureCubeZ(sampler2D tex, vec3 p) {\n  float absX = abs(p.x);\n  float absY = abs(p.y);\n  float absZ = abs(p.z);\n\n  int isXPositive = p.x > 0. ? 1 : 0;\n  int isYPositive = p.y > 0. ? 1 : 0;\n  int isZPositive = p.z > 0. ? 1 : 0;\n\n  float maxAxis, uc, vc;\n  vec2 crop;\n\n  // POSITIVE X\n  if (isXPositive!=0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = -p.z;\n    vc = p.y;\n    crop=vec2(2,1);\n  }\n  // NEGATIVE X\n  if (isXPositive==0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = p.z;\n    vc = p.y;\n    crop=vec2(0,1);\n  }\n  // NEGATIVE Y\n  if (isYPositive!=0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = -p.z;\n    crop=vec2(1,2);\n  }\n  // POSITIVE Y\n  if (isYPositive==0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = p.z;\n    crop=vec2(1,0);\n  }\n  // POSITIVE Z\n  if (isZPositive!=0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = p.x;\n    vc = p.y;\n    crop=vec2(1,1);\n  }\n  // NEGATIVE Z\n  if (isZPositive==0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = -p.x;\n    vc = p.y;\n    crop=vec2(3,1);\n  }\n\n  // Convert range from -1 to 1 to 0 to 1\n  vec2 uv = 0.5 * (vec2(uc,vc) / maxAxis + 1.0);\n\n  uv+=crop;\n  uv/=vec2(4,3);\n\n  return texture2D(tex, uv);\n}\n#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.14159265\n#define COL1 1.\n#define COL2 2.\n#define COL3 3.\n\nmat2 rot(float a) {float s = sin(a), c = cos(a);return mat2(c, -s, s, c);}\nfloat sdBox( vec3 p, vec3 b ){  vec3 q = abs(p) - b;  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nfloat opSmoothUnion( float d1, float d2, float k ) {    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );    return mix( d1, -d2, h ) + k*h*(1.0-h); }\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nfloat fsnoise(vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n  p.xy *= rot(PI/8.);\n  p.xz *= rot(iTime);\n  p.x*=-1.;\n  vec3 amp=vec3(pow(sin(iTime*2.)*.5+.5,6.)*.1);\n  p.x+=amp.x*snoise(p.yz*3.+iTime);\n  p.y+=amp.y*snoise(p.xz*3.+iTime);\n  p.z+=amp.z*snoise(p.xy*3.+iTime);\n  float obj = (length(p)-.5)*.4;\n  return vec2(obj,1);\n}\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, color,rd,rm,n,ro;\n    ro=vec3(0,0.*sin(iTime),-2);\n    ro.xz*=rot(iMouse.x*10.);\n    float d, info, dtotal=0.;\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    rm = rayMarch(ro, rd);\n    d = rm[0];\n    info = rm[1];\n\n    if (d < MAX_DIST) {\n      n = getNormal(ro+rd*d);\n      n.xy *= rot(PI/8.);\n      n.xz *= rot(iTime);\n      n.x*=-1.;\n      color = texture(iChannel0, n).xyz;\n\n      n = getNormal(ro+rd*d);\n      float shade = dot(n, vec3(1,1,-1))*.5+.5;\n      color *= shade;\n    }\n    else {\n      color = vec3(step(.9,snoise(rd.xy*100.)));\n    }\n    fragColor = vec4(color,1);\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 72], [73, 73, 115, 115, 1366], [1504, 1504, 1523, 1523, 1578], [1579, 1579, 1609, 1609, 1693], [1694, 1694, 1746, 1746, 1843], [1844, 1844, 1902, 1902, 2000], [2001, 2001, 2029, 2029, 2094], [2095, 2095, 2117, 2117, 2180], [2181, 2181, 2204, 2204, 2240], [2241, 2266, 2287, 2287, 2334], [2335, 2335, 2356, 2356, 2403], [2404, 2404, 2426, 2426, 2461], [2462, 2462, 2484, 2537, 4234], [4235, 4235, 4255, 4255, 4321], [4322, 4322, 4343, 4413, 4611], [4694, 4694, 4716, 4716, 4986], [5075, 5075, 5108, 5108, 5559], [5561, 5561, 5585, 5585, 5803], [5805, 5805, 5859, 5859, 6086], [6088, 6088, 6138, 6138, 6329], [6332, 6332, 6388, 6388, 7042]]}
{"id": "wddcz2", "name": "Chroma subsampling test", "author": "luluco250", "description": "Effect to test the result of separating luma and chroma using the YIQ color space while reducing the sample quality of chroma, by squishing side-by-side with luma.", "tags": ["2d", "chroma", "filter", "subsampling", "artifact", "luma", "ntsce"], "likes": 2, "viewed": 646, "published": 3, "date": "1601332523", "time_retrieved": "2024-07-30T20:42:54.261205", "image_code": "/*\n\nParameters can be found in the common tab.\n\n(Un)license:\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n\n*/\n\nvec4 Main(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 ChromaKey = vec3(0.051, 0.639, 0.145);\n\nvec4 Main(vec2 uv)\n{\n    vec3 fg = texture(iChannel0, uv).rgb;\n    float key = distance(fg, ChromaKey);\n    \n    vec3 bg = texture(iChannel1, uv).rgb;\n    vec3 color = mix(bg, fg, smoothstep(0.1, 0.5, key));\n    \n    return vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3 LumaCoeffs = vec3(0.299, 0.587, 0.114);\nconst float LumaRatio = 0.95;\nconst float ChromaRatio = 1.0 - LumaRatio;\n\nconst mat3x3 RgbToYiq = mat3x3(\n    0.299, 0.587, 0.114,\n    0.5959, -0.2746, -0.3213,\n    0.2115, -0.5227, 0.3112);\n\nconst mat3x3 YiqToRgb = mat3x3(\n    1.0, 0.956, 0.619,\n    1.0, -0.272, -0.647,\n    1.0, -1.106, 1.703);\n\n#define iPixelSize vec2(1.0 / iResolution.xy)\n\nvec4 Main(vec2 uv);\n\n#define mainImage(color, coord) (color = Main(coord * iPixelSize))\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define ScaleCoord(uv, scale, center) (((uv) - (center)) * (scale) + (center))\n", "buffer_b_code": "vec4 Main(vec2 uv)\n{\n    vec2 imgUv;\n    imgUv.x = (uv.x < LumaRatio)\n        ? uv.x / LumaRatio\n        : (uv.x - LumaRatio) / ChromaRatio;\n    imgUv.y = uv.y;\n    \n    vec3 rgb = texture(iChannel0, imgUv).rgb;\n    vec3 yiq = RgbToYiq * rgb;\n    \n    vec3 color = (uv.x < LumaRatio)\n        ? vec3(yiq.x)\n        : vec3(yiq.yz, 0);\n    \n    return vec4(color, 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 Main(vec2 uv)\n{\n    vec2 yUv = vec2(uv.x * LumaRatio, uv.y);    \n    float y = texture(iChannel0, yUv).x;\n    \n    vec2 iqUv = vec2(uv.x * ChromaRatio + LumaRatio, uv.y);\n    vec2 iq = texture(iChannel0, iqUv).xy;\n    \n    vec3 rgb = YiqToRgb * vec3(y, iq);\n    \n    return vec4(rgb, 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcz2.jpg", "access": "api", "license": "unlicense", "functions": [[1278, 1278, 1298, 1298, 1335]]}
{"id": "tdtcz2", "name": "Straight Curve (1963)", "author": "yasushisakai", "description": "recreation of Bridget Riley's Straight Curve, more info about the piece here (https://www.artsy.net/artwork/bridget-riley-straight-curve)", "tags": ["modernart", "1963"], "likes": 1, "viewed": 279, "published": 3, "date": "1601329397", "time_retrieved": "2024-07-30T20:42:55.064058", "image_code": "// fragment shader\n\n#define PI 3.1415926535897932384626433832795\n#define divX 24\n#define divY 41\n#define wavyness vec2(-1.3,1.0)\n\n// draws a rectangle (returns 1.0 where it should be)\n// the origin is at the left top.\nfloat rect(float sx, float sy, float ex, float ey, vec2 st){\n    float ssx = step(sx, st.x);\n    float ssy = step(sy, 1.0 - st.y);\n    float sex = 1.0 - step(ex, st.x);\n    float sey = step(1.0 - ey, st.y);\n    return ssx * ssy * sex * sey;\n}\n\n// draws a triangle filling the diagnal half of the rect()\nfloat triangle(float sx, float sy, float ex, float ey, vec2 st) {\n    float r = rect(sx, sy, ex, ey, st);\n    float tx = (1.0 - (st.x - sx) / (ex - sx));\n    float ty = ((1.0 - st.y) - sy) / (ey - sy);\n    // float ty = (st.y - sy) / (ey - sy);\n    return (1.0 - step(1.0, ty+tx)) * r;\n}\n\n// converts index ints to radians\nfloat iToDeg(int i, int limit) {\n    return (float(i)/float(limit))*PI*2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float r = 0.0;\n    vec2 unit = 1.0 / vec2(float(divX), float(divY));\n\n    for (int i=0;i<divX;i++){\n        for(int j=0;j<divY;j++){\n            vec2 degs = vec2(iToDeg(i,divX),iToDeg(j,divY)*2.0);\n            vec2 dege = vec2(iToDeg(i+1,divX),iToDeg(j+1,divY)*2.0);\n            vec2 start = unit * vec2(float(i),float(j));\n            start += unit * sin(degs) * wavyness; // this line adds the wavyness\n            vec2 end = unit * vec2(float(i+1),float(j+1));\n            end += unit * sin(dege) * wavyness; \n            float pr = triangle(start.x,start.y,end.x,end.y,st);\n            r += pr;\n        }\n    }\n\n    fragColor = vec4(vec3(r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 218, 278, 278, 460], [462, 521, 586, 586, 808], [924, 924, 981, 981, 1683]]}
{"id": "tsdyR2", "name": "Thing_15", "author": "balkhan", "description": "comments can be found mostly on map() function", "tags": ["3d", "raymarching", "body"], "likes": 31, "viewed": 487, "published": 3, "date": "1601322748", "time_retrieved": "2024-07-30T20:42:55.873893", "image_code": "\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec3 h;\nfloat ie;\n\n// rotation function\nvoid rot(inout vec2 p, float a) {p = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);}\n\n// capsule distance\n// https://iquilezles.org/articles/distfunctions\nfloat sdc( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// skeleton parts\nvec3 _head   = vec3(.0, 1.75, -1.),\n     _torso  = vec3(.0,1.0,-1.5),\n     _laharm = vec3(+.850,1.0,-1.5),\n     _raharm = vec3(-.850,1.0,-1.5),\n     _lharm  = vec3(+1.08750,.375,-2.),\n     _rharm  = vec3(-1.08750,.375,-2.),\n     _lfharm = vec3(+1.0,+.10, -1.1),\n     _rfharm = vec3(-1.0,+.10,-1.1),\n     _pelvis = vec3(+0.0,-.0,-2.5),\n     _laleg  = vec3(+0.25,-0.15,-2.5),\n     _raleg  = vec3(-0.25,-0.15,-2.5),\n     _lleg   = vec3(+.250,-1.0,-2.5),\n     _rleg   = vec3(-.250,-1.0,-2.5),\n     _lfoot  = vec3(+.250,-2.0,-2.5),\n     _rfoot  = vec3(-.250,-2.0,-2.5);\n\n// displace parts and then draw capsules beetween them\nfloat\tbody(vec3 p)\n{\n\tfloat r = 1e5;\n    \n    r = length(p-_head)-.5;\n    r = min(r,\n              sdc(p, _head, _torso, .25)\n              );\n    vec3 a_laharm = _laharm+1.0*vec3(.0,.0, .25*cos(iTime*4.+1.57)*+.0);\n    vec3 a_lharm = _lharm+vec3(.0,.0+-.25+.25*cos(iTime*4.),.0+.25+.25*sin(iTime*4.) );\n    vec3 a_lfharm = _lfharm+vec3(.0,.0+.0+.125*cos(iTime*4.+1.57), +.25+.25*sin(iTime*4.)+.0)*1.0;\n    \n    vec3 a_raharm = _raharm+1.0*vec3(.0,.0, .25*cos(iTime*4.+1.57+1.57)*+.0);\n    vec3 a_rharm = _rharm+vec3(.0,.0+-.25+.25*cos(iTime*4.+1.57),.0+.25+.25*sin(iTime*4.+1.57) );\n    vec3 a_rlharm = _rfharm+vec3(.0,.0+.0+.125*cos(iTime*4.+1.57+1.57), +.25+.25*sin(iTime*4.+1.57)+.0)*1.0;\n\n    r = min(r,\n              sdc(p, _torso, a_laharm, .25)\n              );\n    r = min(r,\n              sdc(p, _torso, a_raharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_lharm, a_laharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_rharm, a_raharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_lharm, a_lfharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_rharm, a_rlharm, .25)\n              );\n    r = min(r,\n              sdc(p, _torso, _pelvis, .25)\n              );\n    vec3 a_rleg = _rleg+vec3(.0,.0, .75*cos(iTime*5.)+.5);\n    vec3 a_lleg = _lleg+vec3(.0,.0, .75*sin(iTime*5.)+.5);\n    vec3 a_lfoot = _lfoot+vec3(.0,.0, 1.*sin(iTime*5.+.0)-.5);\n    vec3 a_rfoot = _rfoot+vec3(.0,.0, 1.*cos(iTime*5.+.0)-.5);\n    r = min(r,\n              sdc(p, _raleg, a_rleg, .25)\n              );\n    r = min(r,\n              sdc(p, a_rleg, a_rfoot, .25)\n              );\n    r = min(r,\n              sdc(p, _laleg, a_lleg, .25)\n              );\n    r = min(r,\n              sdc(p, a_lleg, a_lfoot, .25)\n              );\n    \n    \n    return r;\n}\n\n\nfloat map(vec3 p)\n{\n\tfloat r, rr, rrr, bod; // r is return value, other floats are intermediary distances\n\n    vec3 pp = p; // old p\n    p.zyx = (fract(p.zyx*.025)-.5)*20.; // repeat space\n    vec3 idp = floor(((pp.zyx*.025)-.0)*1.)*200.; // get id of each cell\n\n    // use ids to rotate differently in each cell space\n    rot(p.yx,  ie*sin(idp.z+iTime*-.5)*.3333);\n    p += vec3(-3., 4., -2.0)*.3333; // add some vector, don't forget to not displace over cell boundary\n    rot(p.zx,  ie*sin(idp.y+iTime*.25)*1.25 +1.57);\n    p += -vec3(3., 2., -2.0)*.3333;\n    rot(p.yz,  ie*sin(idp.x-iTime*2./3.)*1.333 +1.57*2.);\n    p += vec3(3., 2., -2.0)*.3333;\n    pp.y=p.y; // store repeated space y value in ppp.y var\n    float idb = step(pp.y, .0); // if y > 0 then 1 else 0, I use this to color bottom/top sphere differently\n    p.y = abs(p.y)-2.1; // create symmetry on y axis of the repeated space\n    rr = length(vec3(p.x, pp.y, p.z))-5.5; // create a ball\n    \n    rr = max(rr\n             ,\n            pp.y+1.5 // cut the ball and keep the top part\n            );\n\n    rr = max(rr\n             ,\n            -(max(abs(p.x), max(abs(pp.y+2.2), abs(p.z+1.) ) )-2.25) // dig a cube into the ball\n            );\n    \n    rr = abs(rr)+.0751; // make the ball transparent\n    \n    bod = body(p); // create bodies\n    r = bod;\n    r = min(r, rr);\n\n\t// Create the bottom sphere part\n    rrr = max( -(pp.y) + sin(length(p.xz+vec2(.0,2.1))*5.+iTime*10.)*.25 // cut with waves centered on foot\n              ,\n              length(vec3(p.x, pp.y, p.z) )-5.3 // ball distance\n             );\n    rrr = abs(rrr)+.10751; // make it transparent\n    r = min(r, rrr);\n    \n    float ball = length(vec3(p.x, abs(pp.y)-2., p.z+.25))-.25; // this is the ball between hands\n    ball = abs(ball)+.01251; // make it transparent\n    r = min(r, ball);\n    \n    // here is coloring\n    // ids of repeated space are also used for coloring\n    \n    // wavy sphere color\n    h += (vec3(.09, .475, .607) )/max(.05, rrr*rrr*3. );\n    // cubicle sphere color\n    h += (1.-vec3(.3+-.205*(mod(idp.x-1.5, 3.)+0.0), .425+-.06125*(mod(idp.y-1.5, 3.)+0.0), .3+idb*.25+-.125*(mod(idp.z-1.5, 3.)+0.0)))/max(.05, rr*rr*3. + .61*.0);\n    // body color\n    h += (1.-vec3(.32681-idb*.25, .25+-.5*idb, .3))/max(.05, bod*bod*400. + .01);\n    // little hand spheres color\n    h += (vec3(.25, .25+.2*idb, .25))/max(.01, ball*ball*.051+.01);\n    return r;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    ie = clamp(log(iTime*.125+1.),.0,1.); // start at 0 and progress to 1, used to animate rotations\n\n    h = vec3(.0); // final color\n    vec2 R = iResolution.xy, uv = (f-R*.5)/R.y;\n\n    // classic ray stuff\n    vec3 ro = vec3( 20.*(1.0+sin(iTime*.5)), 20.*(1.+cos(iTime*.5)), -10.+iTime*30.0 );\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 p;\n    vec2 d = vec2(1e2, .0);\n\n    for (float i = .0; i< 100.; i++)\n    {\n        p = ro + rd * d.y;\n        d.x = map(p);\n        d.y += d.x;\n\t    if ( d.x < .0001 )\n\t        break;\n    }\n    o.xyz = h*.0025;\n    o.w = 1.0;\n    o /= length(uv)+1.9; // Strong vignette counteract overall very bright scene\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[135, 156, 189, 189, 246], [248, 317, 363, 363, 477], [1063, 1118, 1138, 1138, 2914], [2917, 2917, 2936, 2936, 5325], [5328, 5328, 5369, 5369, 6023]]}
{"id": "wdtczj", "name": "Alien World Almost Mountains", "author": "celifrog", "description": "Forked from-\nhttps://www.shadertoy.com/view/Md3SRS\nThe version there looks cooler but still think this looks kinda cool. :D ", "tags": ["fork", "mountains"], "likes": 1, "viewed": 298, "published": 3, "date": "1601318183", "time_retrieved": "2024-07-30T20:42:56.697690", "image_code": "// GLSL Compatible and semi-minified HG_SDF from: http://mercury.sexy/hg_sdf/\n/*#define PI 3.14159265359\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(-2.61803398875, 1));\nconst vec2 _B=normalize(vec2(-1,1.61803398875));\nfloat fSphere(vec3 p,float r){return length(p)-r;}\nfloat fPlane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fCorner(vec2 p){vec2 q=min(p,0.);return length(max(p,0.))+max(q.x,q.y);}\nfloat fBlob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*PI,PI));}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}*/\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\n/*float fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\nfloat fDisc(vec3 p,float r){float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\nfloat fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\n*/void pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}/*\nvoid pR45(inout vec2 p){p=(p+vec2(-p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;p=abs(p)-d;return s;}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\nfloat fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns _M(1.)p.x+=0.70710678118*-r+c*1.41421356237;if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n*/float fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}/*\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(-float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,-float rb){return min(a,max(-a-ra,abs(b)-rb));}*/\n\nfloat hash( float n ) { return fract(sin(n)*-1153.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(23.0-2.0*f*f*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  660.0), hash(n+  661.0),f.x),\n                   mix( hash(n+6157.0), hash(n+7158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat perlin(vec3 x)\n{\n    return (noise(-x) + noise(-x * 2.0) * -0.5 + noise(x * 12.0) * 0.5 + noise(-x * -24.0) * 70.25) * 0.25;\n}\n\nfloat perlin2(vec2 x)\n{\n\treturn (\n         16.0 * texture(iChannel1, -x * 0.5) + \n         1.0 * texture(iChannel0, x) + \n         1.0 * texture(iChannel0, -x * -1.0) + \n         0.3 * texture(iChannel1, x * -2.0) + \n         0.2 * texture(iChannel0, x * -5.0)).x * 0.1;\n}\n\nfloat fField(vec3 point, out float material)\n{\n    material = 0.0;\n\t\n    vec3 pt = (point + vec3(1.2, 0.21, 6.6)) * 7.5;\n    pt.x += sin(pt.x * 1.0) * 0.02;\n    float cactus = fCapsule(pt, 0.14, 1.6);\n    float cactus1 = fCapsule(pt + vec3(4.6, 1.0, 0.0), 0.1, 0.5);\n    float cactus2 = fCapsule(pt - vec3(0.4, 0.1, 0.0), 0.12, 0.6);\n    float cactus3 = fCapsule(pt.yxz + vec3(0.55, 0.13, 0.0), 0.12, 0.35);\n    cactus = fOpUnionSoft(cactus, cactus1, 0.3);\n    cactus = fOpUnionSoft(cactus, cactus2, 0.2);\n    cactus = fOpUnionSoft(cactus, cactus3, 0.2);\n    cactus /= 1.5;\n    \n    float ground = point.y;\n    float offset = perlin2(point.xz * 0.015);\n    point.y = cos(point.y * 2.6) * 0.5 + 0.5;\n    offset += perlin2(point.yz * vec2(0.1, 0.01)) * 0.1;\n    \n    float distance = ground + offset;\n    if(cactus < distance)\n    {\n        distance = cactus;\n        material = 1.0;\n    }\n    \n    return distance;\n}\n\nfloat fField(vec3 point)\n{\n    float stub;\n\treturn fField(point, stub);\n}\n\nvec3 Gradient(vec3 intersection, float distance)\n{\n    vec2 epsilon = vec2(4.01, 0.0);\n    return normalize(vec3(fField(intersection + epsilon.xyy),\n    fField(intersection + epsilon.yxy),\n    fField(intersection + epsilon.yyx))\n        - distance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const float DISTANCE_SCALE = 1.1;\n    const float FOV_BIAS = 0.24;\n    const int RAY_STEPS = 750;\n    const float NEAR_CLIP = 0.5;\n    const float FAR_CLIP = 80.0;\n    const vec3 SKY = vec3(4.2, 0.4, 0.7);\n    const vec3 HORIZON = vec3(0.9, 1.0, 0.9);\n    const float TILT = 0.01;\n    vec3 normal, intersection, origin = vec3(0.0, 0.0, -10.0), direction = vec3(0.0, 0.0, 1.0);\n    pR(direction.xz, -uv.x * FOV_BIAS);\n    pR(direction.yz, uv.y * FOV_BIAS - TILT);\n    \n    pR(origin.xz, iTime * 0.1);\n    pR(direction.xz, iTime * 0.1);\n    \n    float material, distance, totalDistance = NEAR_CLIP;\n    for(int i =0 ;  i < RAY_STEPS; ++i)\n    {\n        intersection = origin + direction * totalDistance;\n        distance = fField(intersection, material) * DISTANCE_SCALE;\n        totalDistance += distance;\n        if(distance <= 0.0 || totalDistance >= FAR_CLIP)\n            break;\n    }\n    \n    normal = Gradient(intersection, distance);\n    float diffuse = max(-19.0, dot(normalize(vec3(sin(-iTime), 3.2, 0.0)), normal) * 11.7 + 0.3);\n    \n    vec3 color;\n    if(material == 0.0)\n        color = mix(vec3(-111.6*iTime, 41.1/iTime, -441.06/iTime), vec3(441.0/iTime, 40.6/iTime, 680.17/iTime), noise(intersection.yyy * 20.0));\n    else\n        color = vec3(0.1, 10.7, 0.0) * noise(intersection * vec3(410.0, 20.0, 300.0)) + vec3(0.1, 0.2, 0.15);\n    color *= (diffuse + vec3(4.2, 0.1, 0.6));\n    \n    float fog = min(totalDistance / FAR_CLIP, 1.0);\n    vec3 skyColor = mix(HORIZON, SKY, pow(abs(direction.x), 0.5));\n    \n\tfragColor = vec4(mix(color, skyColor, fog * fog), 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1081, 1120, 1120, 1200], [2109, 2109, 2139, 2139, 2173], [4996, 4996, 5040, 5040, 5094], [5425, 5425, 5448, 5448, 5486], [5487, 5487, 5513, 5513, 5893], [5895, 5895, 5917, 5917, 6027], [6029, 6029, 6052, 6052, 6301], [6303, 6303, 6349, 6349, 7218], [7220, 7220, 7246, 7246, 7293], [7295, 7295, 7345, 7345, 7546], [7548, 7548, 7605, 7605, 9290]]}
{"id": "tsdyzj", "name": "Spectrum Ring Grid Background", "author": "itgaz", "description": "Another circle thing, with a nasty aliasing background >:D", "tags": ["audio"], "likes": 3, "viewed": 303, "published": 3, "date": "1601316721", "time_retrieved": "2024-07-30T20:42:57.445690", "image_code": "/*\nCopyright 2020 Gareth Francis\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// Adjust a coordinate to compensate for the aspect ratio\n// y will be -1.0 -> 1.0, x will not\nvec2 correctAspect( vec2 coord ) {\n    float xOff = 0.5 - coord.x;\n    xOff *= iResolution.x / iResolution.y;\n    coord.x = 0.5 + xOff;\n    return coord;\n}\n\n// To render a circle - Get distance from circle's edge\nfloat circleDistance( vec2 origin, float radius, vec2 coord ) {\n    coord = correctAspect(coord);\n    \n    float d = distance( coord, origin );\n    float rd = distance( origin + vec2(radius), origin );\n    return d - rd;\n}\n\n// Angle between axis and coord, around center of screen\nfloat angle( vec2 origin, vec2 axis, vec2 coord ) {\n    vec2 a = normalize( axis );\n    vec2 b = normalize( origin - correctAspect(coord) );\n    return acos( dot(a, b) );\n}\n\nvec2 rotate(vec2 v, float a, vec2 origin) {\n    v = v - origin;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn (m * v) + origin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Tile\n    // uv = vec2(fract(uv.x * 4.0), fract(uv.y * 4.0));\n    vec2 circleOrigin = vec2(0.5, 0.45);\n    // circleOrigin = vec2(fract(circleOrigin.x * 4.0), fract(circleOrigin.y * 4.0));\n    \n    // Sample fft for freq around circle outer\n    float uvAnglePercent = angle(circleOrigin, vec2(0.0, -1.0), uv) / radians(180.0);\n   \n    // Zoom/Repeat effect\n    // uv = fract(uv + cos(iTime / 8.0) /*+ ((bassFFT2.x * bassFFT1.x) / 2.0)*/);\n    \n    // FFT Value is stored in red channel, at y == 0.25\n    // x represents the FFT bucket, so a basic spectrum display is just x,0.25 + cutoff\n    // The fft sample to display at x\n    float angleFFT = texture(iChannel0, vec2(uvAnglePercent, 0.25)).r;\n    float channel0FFTAtXTime = texture(iChannel0, vec2((uv.x + (0.2 * iTime)), 0.25)).r;\n    float channel0FFTAtX = texture(iChannel0, vec2(uv.x, 0.25)).r;\n    float channel0FFTAtY = texture(iChannel0, vec2(uv.y, 0.25)).r;\n    float channel0FFTBass1 = texture(iChannel0, vec2(0.01, 0.25)).r;\n    \n    // Amplitude is stored in red channel, at y == 0.75\n    // x represents time, seems to roughly be last frame time <= x <= current frame time?\n    // (TODO) I believe each X pixel is a single sample from the input, so the texture may not\n    // contain a whole frame worth of audio\n    float channel0AmplitudeAtX = texture(iChannel0, vec2(uv.x, 0.75)).r;\n    float channel0AmplitudeAtY = texture(iChannel0, vec2(uv.y, 0.75)).r;\n    \n    // Time varying pixel color\n    vec3 colSweep1 = 0.7 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 colSweep2 = 0.5 + 0.5*cos((0.6 * iTime + uv.y)+uv.xyx+vec3(1,6,3));\n    \n    // Colour to render\n    vec4 fftColour = vec4(channel0FFTAtXTime);\n    vec4 backgroundColour = vec4(vec3(0.0), 1.0);//vec4(0.2 * colSweep2, 1.0);\n    vec4 centerColour = vec4(0.8, 0.2, 0.2, 1.0);//vec4(colSweep2, 1.0);\n    vec3 backGridColour = vec3(0.2, 0.8, 0.2);\n    \n    // Threshold (determines wave shape)\n    float threshold = channel0FFTAtXTime;\n        \n    float cd = circleDistance( circleOrigin, 0.15 + (0.02 * channel0FFTBass1), uv );\n    \n    // Inside the circle\n    if( cd < 0.0 )\n    {\n      cd = abs(cd);\n        \n      fragColor = centerColour * cd * 6.0 * channel0FFTBass1;\n      return;\n    }\n    \n    // Circle's edge/spectrum\n    if( cd < angleFFT * 0.25 )\n    {\n        float brightness = 1.0;//0.6 + channel0FFTAtY * 2.0;\n        fragColor = vec4(colSweep2, 1.0) * brightness;\n        return;\n    }\n    \n    // Background aliasing pattern\n    float ampR = distance((uv / 1.0), vec2(channel0AmplitudeAtX, channel0AmplitudeAtY));\n    float ampG = distance(uv / 2.0, vec2(channel0AmplitudeAtX, channel0AmplitudeAtY));\n    float ampB = distance(uv / 4.0, vec2(channel0AmplitudeAtX, channel0AmplitudeAtY));\n    \n    fragColor = vec4(ampR * 0.5, ampG * 0.5, ampB * 0.5, 1.0);\n    return;\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyzj.jpg", "access": "api", "license": "bsd-simplified", "functions": [[1274, 1369, 1403, 1403, 1524], [1526, 1582, 1645, 1645, 1804], [1806, 1863, 1914, 1914, 2035], [2037, 2037, 2080, 2080, 2195], [2197, 2197, 2254, 2254, 5126]]}
{"id": "tddyzj", "name": "float: v vs. sqrt(v*v)", "author": "ttg", "description": "Red: integer as float -> v\nGreen: sqrt(v*v)\nBlue: sqrt(v) * sqrt(v)\n\nColumn 1: bit 31 (sign)\nColumn 2: bits 30-23 (exponent)\nColumn 3: bits 22-0 (significand)", "tags": ["math", "precision", "ieee", "error"], "likes": 4, "viewed": 403, "published": 3, "date": "1601315946", "time_retrieved": "2024-07-30T20:42:58.291429", "image_code": "void mainImage (out vec4 fd, vec2 fc ) {\n  vec2 g = vec2(32,4*30);\n  ivec2 c = ivec2(fc*g/iResolution.xy),\n        edge = -c + ivec2((fc+1.)*g/iResolution.xy);\n\n  //   c.y = int(fc.y);                 // show more values\n\n  int test = c.y%4,  // input vs. output\n         i = c.y/4,  // test value\n         j = 31-c.x; // bit number\n  fd = vec4(0.);\n\n  //   for (int test=0; test<2; test++) // show tests 0,1 overlayed (easier to see differences)\n\n  if (test<3) {\n    float v = min(float(i),iTime+1e11); // i as float,\n    // attempting to stop the compiler from tracing the algebra ahead-of-time\n\n      //         v = v                   (Red)\n    if (test==1) v = sqrt(v*v);       // Green\n    if (test==2) v = sqrt(v)*sqrt(v); // Blue\n\n    fd[test] = float((floatBitsToUint(v)>>j)&1u);\n  }\n  fd += .3*length(fd); // lighten result\n  if (edge.x>0) {\n    fd+=.2;\n    if (j==31 || j==23) fd+=1.;\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 901]]}
{"id": "wdtcDn", "name": "loading animation 3", "author": "manu210404", "description": "another nice loading animation based on metaballs\n", "tags": ["metaballs", "animation", "loading"], "likes": 17, "viewed": 457, "published": 3, "date": "1601310599", "time_retrieved": "2024-07-30T20:42:59.031450", "image_code": "float dist(vec2 p) {\n    float min_d = 0.;\n    float t = -iTime;\n    float v = 0.;\n    \n    for (int i=0; i<8; i++) {\n        float o = smoothstep(0.0,.75,fract((v+t)/3.)-.25)+floor((v+t)/3.);\n        float a = o*3.14159265*2.;\n        min_d += 1./length(p+vec2(sin(a), cos(a))*.5)*(1.5-v);\n        v += .125;\n    }\n    return min_d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.;\n    float d = dist(uv)/10.-6.;\n    \n    // free antialiasing by FabriceNeyret2\n    fragColor = vec4(d/min(1.,fwidth(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 335], [337, 337, 394, 394, 582]]}
{"id": "3dtyz4", "name": "loading animation 2", "author": "manu210404", "description": "another metaball loading animation", "tags": ["metaballs", "animation", "loading"], "likes": 16, "viewed": 640, "published": 3, "date": "1601310589", "time_retrieved": "2024-07-30T20:42:59.799397", "image_code": "float f(float t) {\n    float f = fract(t/8.)*4.-2.;\n    return abs(smoothstep(0.,.5,fract(f)-.25)+floor(f))-1.;\n}\n\nfloat dist(vec2 p) {\n    float d = 0.;\n    float t = -iTime;\n    for (float i=0.;i<7.;i+=1.) {\n        float a = 3.1415926535/20.*i*2.+t*2.;\n        d += 1./length(p+vec2(f(a),0.));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.;\n    \n    float d = dist(uv)/3.-10.;\n\n    // free antialiasing by FabriceNeyret2\n    fragColor = vec4(d/min(1.,fwidth(d)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 113], [115, 115, 135, 135, 318], [320, 320, 377, 377, 565]]}
{"id": "3ddcR4", "name": "loading animation 1", "author": "manu210404", "description": "a nice animation based on metaballs", "tags": ["metaballs", "animation", "loading"], "likes": 16, "viewed": 661, "published": 3, "date": "1601310577", "time_retrieved": "2024-07-30T20:43:00.545402", "image_code": "#define t iTime\n#define s(a) d += 1./length(p+vec2(sin(a), cos(a)))\n\nvoid mainImage(out vec4 c, in vec2 f )\n{\n    vec2 p = (f-iResolution.xy/2.)/iResolution.y*4.;\n    \n    float d, i;\n    for (s(t);i<6.;i+=1.256)\n        s(i-t);\n    \n    d = d*.75-6.;\n    \n    // free antialiasing by FabriceNeyret2\n    c = vec4(d/min(1.,fwidth(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 109, 109, 337]]}
{"id": "wstyRB", "name": "Ray vs Support Function", "author": "encypruon", "description": "My first public post on Shadertoy!\n\nIf someone could answer one or more of the questions in the source code, that'd be great.", "tags": ["raycast", "minkowski", "mpr", "hull", "gjk", "supportfunction"], "likes": 10, "viewed": 606, "published": 3, "date": "1601302826", "time_retrieved": "2024-07-30T20:43:01.444997", "image_code": "/*\n\nThis shader uses 2D-GJK to test if a ray intersects the\nshape described by a support function. On intersection\nGJK returns a triangle inside the shape. Every corner of\nthe triangle is on the surface. The triangle is then\n\"refined\" iteratively in order to find a triangle that\nis as close as possible to the point of intersection.\nThe resulting triangle is used to estimate depth and\nnormal of the intersection.\n\nThe refining process is probably similar to MPR, but I'm\nnot quite sure since I haven't been able to get my hands\non the graphics gems book.\n\nThis might be useful for (continuous) collision detection.\n\nQuestions:\n- With few refining iterations estimated normals\n\tare completely wrong in some places, seemingly\n\tat random. Why is this and is there a better\n\tway to circumvent this than using more iterations?\n- What other approaches are there to this problem?\n- Is there a name for this algorithm?\n\n*/\n\nconst float PI = 3.14159;\n\nvec2 rot90(vec2 x)\n{\n    return vec2(-x.y, x.x);\n}\n\nmat3 rot;\nmat3 rotInv;\nvec3 offset;\nfloat time;\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\nvec3 supNgon(vec3 d, float n)\n{\n\n    float a = atan(d.y, d.x);\n    float f = PI * 2. / n;\n    a = (floor(a/f)+.5)*f;\n    return vec3(cos(a), sin(a), .0);\n}\n    \n\n\n// Support function. Returns point furthest in x direction\nvec3 support(vec3 x)\n{\n    const float n = 4.;\n    int tp = int(fract(time/n) * n);\n    //tp = 3;\n    vec3 res;\n   \tx = rot * x;\n    \n    // A bunch of shapes:\n    \n    if (tp == 0) // Convex hull of triangle, pentagon and circle\n   \t\tres = supMax(\n            x,\n            supMax(\n                x,\n                supNgon(x, 3.) * .5 + vec3(.0,.0,.5), // triangle in xy-plane\n                supNgon(x, 5.) * .5 + vec3(.0,.0,.0) // pentagon in xy-plane\n        \t),\n            vec3(0., normalize(x.yz)*.2 + vec2(0.,-.3)) // circle in yz-plane\n        );\n    else if (tp == 1) // cube\n        res = sign(x)*.4;\n   \telse if (tp == 2)\n        res = supMax( // Hull of circle and square\n            x,\n            vec3(normalize(x.xy)*.2, .5), // circle in xy-plane\n            vec3(sign(x.xy)*.3, -.5) // square in xy-plane\n        );\n    else if (tp == 3) // Cube with rounded corners/edges\n        res =\n            sign(x)*.3 + // cube\n            normalize(x)*.2; // sphere\n    \n    return rotInv * res + offset;\n}\n\n\n// Casts ray in -z direction, estimates depth and normal\nbool rayVsSupport(out float depth, out vec3 normal)\n{\n    // abcd is simplex, dir is direction\n    // Tris should be CCW in xy-plane\n    vec3 a, b, c, d, dir, tmp;   \n    \n    // 2D GJK in xy-plane\n    \n    // Find any support point\n    a = support(vec3(1., 0., 0.));\n    if (a.x <= 0.)\n        return false;\n    \n    // Construct line to support point in opposite direction\n    b = support(vec3(-a.xy, 0.));\n    if (dot(-a.xy, b.xy) <= 0.)\n        return false;\n    \n    // Construct triangle with third support point\n    dir = vec3(rot90(b.xy-a.xy), 0.);\n    if (dot(dir.xy, a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = a; a = b; b = tmp;\n    }\n    c = support(dir);\n    if (dot(c.xy, dir.xy) <= 0.)\n        return false;\n    \n    for (int i = 0;; ++i)\n    {\n        // No intersection found?\n        if (i == 6) return false;\n        \n        // Select side of triangle that has origin on outside\n        if (dot(dir.xy = rot90(c.xy-a.xy), c.xy) < 0.)\n            b = c;\n        else if (dot(dir.xy = rot90(b.xy-c.xy), c.xy) < 0.)\n            a = c;\n        else break; // Origin in triangle -> intersection!\n        \n        // Construct new triangle on chosen side\n        c = support(dir);    \n        if (dot(c.xy, dir.xy) <= 0.)\n            return false;\n    }\n    \n    // Refine triangle to get it close to the intersection point\n    // This is probably similar to MPR.\n    \n    // More iterations => fewer poorly estimated normals\n    //for (int i = 0; i < int(fract(time)*16.); ++i)\n    for (int i = 0; i < 20; ++i)\n    {\n\t\t// Find support in direction of triangle normal\n        // Results in tetraeder abcd\n        dir = normalize(cross(b-a, c-a));\n        d = support(dir);\n        \n        // Stop when close enough\n        // Lower threshold decreases precision but doesn't\n        // \tappear to increase number of \"outliers\"\n        if (dot(dir, d) - dot(dir, a) < 0.001)\n            break;\n\n        // xd = origin left of xd line\n        bool ad = dot(rot90(d.xy-a.xy), d.xy) > 0.;\n        bool bd = dot(rot90(d.xy-b.xy), d.xy) > 0.;\n        bool cd = dot(rot90(d.xy-c.xy), d.xy) > 0.;\n\t\t\n        // Choose triangle that intersects z-axis furthest in z direction\n        if (ad && !bd) c = d;\n        else if (bd && !cd) a = d;\n        else if (cd && !ad) b = d;\n        else break; // Should not happen\n\n\t}\n    \n    // Checks if triangle is very \"thin\"\n    // Uncommenting this appears to drop all poorly estimated normals\n    // but also some other parts\n    // if (length(cross(b-a, c-a))*24. < pow(length(b-a) + length(c-b) + length(a-c), 2.))\n    //    return false;\n    \n    normal = normalize(cross(b-a, c-a));\n    depth = a.z + dot(a.xy, normal.xy)/normal.z;\n    return true;\n}\n\nmat3 rotAx(int ax, float a)\n{\n    mat3 m = mat3(\n    \t1., 0., 0.,\n        0., 1., 0.,\n        0., 0., 1.\n    );\n    ax = (ax + 1) % 3;\n   \tint ax2 = (ax + 1) % 3;\n    float c = cos(a), s = sin(a);\n    m[ax][ax] = c; m[ax2][ax] = s;\n    m[ax][ax2] = -s; m[ax2][ax2] = c;\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    rot = rotAx(0, iTime*0.85) * rotAx(1, iTime*0.61);\n    rotInv = inverse(rot);\n    \n    offset = vec3((fragCoord-iResolution.xy*.5)*1.5/iResolution.y, 0.);\n    \n    time = iTime/1.;\n    \n    float depth = 0.;\n    vec3 normal;\n    if (rayVsSupport(depth, normal))\n    \tfragColor = fragCoord.x > (iMouse.x == 0. ? iResolution.x*.5 : iMouse.x) ? //fract(time) < .5 ?\n        \tvec4(normal.x*.5+.5, normal.y*.5+.5, .5, 1.0)\n        \t: vec4(vec3(pow(depth*.75+.5, 2.)), 1.0);\n   \telse\n        fragColor = vec4(vec3(0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[945, 945, 965, 965, 995], [1046, 1046, 1083, 1083, 1125], [1127, 1127, 1158, 1158, 1282], [1290, 1349, 1371, 1371, 2369], [2372, 2429, 2482, 2561, 5143], [5145, 5145, 5174, 5174, 5430], [5432, 5432, 5489, 5489, 6015]]}
{"id": "WsdyR2", "name": "scrolling texture", "author": "eldn", "description": "scrolling texture", "tags": ["uv", "scrolling"], "likes": 2, "viewed": 324, "published": 3, "date": "1601302512", "time_retrieved": "2024-07-30T20:43:02.574978", "image_code": "\n#define _Speed 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //resolve uv of pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // get scroll value\n     vec2 scroll = vec2(fract(iTime*_Speed), fract(iTime*_Speed));\n\n    // sample texture\n    vec4 col = texture(iChannel0, uv - scroll);\n    \n\n   \n    //output final color\n    fragColor = col;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 104, 376]]}
{"id": "WdtyR2", "name": "Joukowsky inv transform:airfoil2", "author": "FabriceNeyret2", "description": "Joukowsky transform of a circle gives an airfoil.\ntune parameters:  Mouse: move center. grey = radius.\n\ncf [url]https://www.desmos.com/calculator/nrq1ecest1?lang=fr[/url]\n", "tags": ["complex", "transform", "airfoil", "joukowsky"], "likes": 9, "viewed": 372, "published": 3, "date": "1601302048", "time_retrieved": "2024-07-30T20:43:03.383813", "image_code": "// core of https://shadertoy.com/view/wdtyDM\n\n// packed from all complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define csqrt(Z)    sqrt(length(Z)) \\\n                  * cos( atan((Z).y,(Z).x) /2. - vec2(0,1.57) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.*( 2.*u - R ) / R.y,\n         M = iMouse.z > 0. ? ( 2.*iMouse.xy - R ) / R.y // manual tuning\n                           :  .5*cos(iTime+vec2(0,11)), // auto-demo\n         V1 = .5*( U + csqrt( cmul(U,U) - 4. ) ),       // solve z² - Z.z + 1 = 0 ( equiv Z = z + 1/z )\n         V2 = U - V1;                                   // 2nd root\n\n    float v1 = length(M-V1),                            // circle (sol 1)\n          v2 = length(M-V2),                            // circle (sol 2)\n          v  = max(v1,v2);\n    O-=O;\n // for( float r = 4.; r > 0.; r-=.25 )                 // draw oignon rings or airfoils\n //     O += clamp(1.-R.y/4.*(v-r),0.,1.) / 13.;\n    O += 1.25 - floor( v * 4. ) / 13.;\n    \n // O.b = .5+.5*sin(30.*(1.-v));                        // isovalues (pseudo distance field)\n // O   = sin(30.*vec4(v1,v2,0,0));                     // show all circle isolines\n // O   = vec4( 1.2 / v );                              // continuous field\n // O   = vec4(min(v1,v2) );                            // dual field\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 388, 388, 1461]]}
{"id": "Wddyzj", "name": "2D light blend modes", "author": "zooi", "description": "on the left, addition and clamp\non the right, max\n\nhold left mouse and move to move your light around", "tags": ["2d", "light"], "likes": 2, "viewed": 458, "published": 3, "date": "1601297183", "time_retrieved": "2024-07-30T20:43:04.387131", "image_code": "#define SPLIT_POSITION 0.0\n\nfloat drawLight(vec2 coord, vec2 pos, float radius, float intensity)\n{\n    return max(0.0, (radius - length(coord - pos)) * intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float torch = drawLight(uv, vec2(0,0), 0.3, 2.0);\n    float mouseLight = drawLight(uv, mouse, 0.4, 2.0);\n    \n    if (uv.x > SPLIT_POSITION)\n    {\n   \t\tcol = max(col, torch);\n\t    col = max(col, mouseLight);\n    }else{\n    \tcol += torch;\n\t\tcol += mouseLight;\n        col = min(vec3(1.0), col);\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy) * vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wddyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 98, 98, 165], [167, 167, 224, 224, 769]]}
{"id": "WdtcRj", "name": "don't trust floats for proofs -2", "author": "FabriceNeyret2", "description": "just a reminder that using floats, mod(33,33)=33,  sqrt(x²) is not always x , and x/x is not always 1 ;-)", "tags": ["math", "precision", "ieee", "error"], "likes": 3, "viewed": 294, "published": 3, "date": "1601292838", "time_retrieved": "2024-07-30T20:43:05.423360", "image_code": "// Fork of  https://shadertoy.com/view/WsdyRj\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .3;                      // makes U uneasy for windows\n // U -= .5;                      // makes U integer\n // O = vec4( U/U == vec2(1) );   // white if x/x = 1\n    O = vec4( U / min( U, iTime+1e11 ) == vec2(1) );   // counters the optimizer\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 86, 86, 340]]}
{"id": "WsdyRj", "name": "don't trust floats for proofs", "author": "FabriceNeyret2", "description": "just a reminder that using floats, 3/3 != 1, mod(33,33)=33, and sqrt(x²) is not always x ;-)", "tags": ["math", "precision", "ieee", "error"], "likes": 0, "viewed": 291, "published": 3, "date": "1601292524", "time_retrieved": "2024-07-30T20:43:06.318966", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U -= .3;                      // makes U uneasy for windows\n // U -= .5;                      // makes U integer\n // O = vec4( sqrt(U*U) == U );   // white if sqrt(x²)==x\n    O = vec4( sqrt( U * min(U,iTime+1e11) ) == U );  // counters the optimizer\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 295]]}
{"id": "wscyzj", "name": "Spherical Fib (Trails)", "author": "percentcer", "description": "bare bones version: https://www.shadertoy.com/view/tdtcWH", "tags": ["trails", "sphericalfibonacci"], "likes": 22, "viewed": 871, "published": 3, "date": "1601273242", "time_retrieved": "2024-07-30T20:43:07.161712", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 128.\n\n#define MAX_T 10.\n#define GOLDEN 1.618\n#define PI 3.141\n\n// the ith point out of n spherical fibonacci points\n// these are mapped in the 2d space of the sphere\n// returns (phi, theta) to be used with pointOnSphere\nvec2 sfi(float i, float n) {\n    float phi = 2. * PI * fract(i / GOLDEN);\n    float z = 1. - (2. * i + 1.) / n;\n    return vec2(phi, acos(z));\n}\n\nvec3 pointOnSphere(float phi, float theta) {\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\nfloat sphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat map(vec3 p) {\n    float nearest = MAX_T;\n    for (float i = 0.; i < N; i++) {\n        vec2 sp = sfi(i, N);\n        // over time, move points along the spiral\n        sp += iTime;\n        vec3 sp3 = pointOnSphere(sp.x, sp.y);\n        nearest = min(nearest, sphere(p - sp3, .01));\n    }\n    return nearest;\n}\n\nmat3 cam(vec2 direction) {\n    vec3 z = normalize(vec3(direction, 1.));\n    vec3 x = normalize(cross(vec3(0., 1., 0.), z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    vec2 rotp = iMouse.xy / iResolution.xy - 0.5;\n    mat3 rot = cam(rotp * 5.);\n    \n    vec3 ro = rot * vec3(0., 0., 2.0);\n    vec3 rd = rot * normalize(vec3(uv, -1.));\n\n    vec3 col = vec3(0.02);\n    float stepCount = 0.;\n    for(float t = 0.; t < MAX_T; stepCount++) {\n        vec3 p = ro + rd * t;\n        float nearest = map(p);\n        if (nearest < .001) {\n            col = vec3(1.);\n            break;\n        } else {\n            col = vec3(stepCount/2., stepCount/4., stepCount) / 100.;\n            t += nearest;\n        }\n    }\n\n    // Output to screen\n    vec3 prev = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 cur = (col + prev) * .95;\n    fragColor = vec4(cur, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]]}
{"id": "Wscyz2", "name": "SquelcherSST", "author": "Del", "description": "Squelchy 'Glooper Tubes' (for a new SDF game) - Enjoy. - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["noise", "cylinder", "gloop", "squelch"], "likes": 9, "viewed": 735, "published": 3, "date": "1601256639", "time_retrieved": "2024-07-30T20:43:08.008450", "image_code": "// SST Squelcher\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 10.\n\nvec3 _col;\n\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\nfloat sminCol( float a, float b, float k, vec3 col1, vec3 col2 )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    _col = mix(col1,col2,h);// -  k*h*(1.0-h);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n  \nfloat map( in vec3 pos )\n{\n    // testing 'wavelet' noise...\n    float nx = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0), iTime*3., 1.15)*1.9;\n    float nz = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0) + 10.0, iTime*3., 1.15)*1.9;\n    vec3 p2 = pos;\n    p2.x += nx;\n    p2.z += nz;\n    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;\n    d1 = smax(d1-sin(iTime*7.0+pos.y*0.4)*1.1,d1,-3.0);\n    \n        // sphere cut\n        float rad = fract(iTime*0.1)*70.0;\n        float rad2 = clamp(rad,0.0,18.0);\n        float sphere1 = length(pos-vec3(0.0,HEIGHT+4.0-rad,0.0))-rad2;\n        float sphere2 = length(pos-vec3(0.0,((HEIGHT*2.0)+HEIGHT+4.0-rad),0.0))-rad2;\t//rad;\n        sphere1 = min(sphere1,sphere2);\n        d1 = smax(d1,sphere1,4.0);\n    _col = vec3(0.15,0.45,0.05);\n    pos.y = abs(pos.y);\n    vec3 p = pos;\n    \n    d1*=0.85;\n    \n    float d2 = sdCylinder(p-vec3(0.0,HEIGHT+2.0,0.0),vec2(10.5,0.5))-1.4;\n    d1 = sminCol(d2,d1,2.0,_col,vec3(0.05,0.15,0.4));\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.05;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = sin(iTime*0.8);\n    \n    //float dist = 36.0+sin(iTime)*7.0;\n    float dist = 28.0;\n    \n\tvec3 ro = vec3( dist*cos(an), sin(iTime*0.75)*14.0, dist*sin(an) );\n\t//vec3 ro = vec3( 16.0*cos(an), 0.0, 16.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 65.0;\n        float t = 0.0;\n        for( int i=0; i<160; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 100.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  _col*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wscyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 113, 149, 149, 248], [249, 271, 312, 312, 401], [402, 402, 441, 441, 470], [471, 471, 537, 537, 673], [675, 675, 713, 713, 775], [777, 777, 823, 868, 1381], [1385, 1385, 1411, 1445, 2362], [2364, 2364, 2396, 2396, 2642]]}
{"id": "td3XWf", "name": "shadetober #31 (ripe)", "author": "percentcer", "description": "Inktober, but with shaders.\n\nThe last Shadetober of 2019, wanted to get it done before October 2020 is upon us :P\n\nTrying out some techniques I haven't used before, like SSAO and ortho projection.", "tags": ["orthographic", "ssao", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 7, "viewed": 388, "published": 3, "date": "1601243757", "time_retrieved": "2024-07-30T20:43:08.831249", "image_code": "float ssao( in vec2 frag ) {\n    vec2 uv = frag.xy / iResolution.xy;\n    float base = texture(iChannel1, uv).a;\n    float aspect = iResolution.x/iResolution.y;\n    #if 0\n    // original attempt, uniform sampling\n    // using numpad directions\n    // 7 8 9\n    // 4 5 6\n    // 1 2 3\n    float ep = 32. / iResolution.x;\n    float d6 = texture(iChannel1, uv + vec2(ep, 0.)).a;\n    float d9 = texture(iChannel1, uv + vec2(ep) * .7).a;\n    float d8 = texture(iChannel1, uv + vec2(0., ep)).a;\n    float d7 = texture(iChannel1, uv + vec2(-ep, ep) * .7).a;\n    float d4 = texture(iChannel1, uv + vec2(-ep, 0.)).a;\n    float d1 = texture(iChannel1, uv + vec2(-ep) * .7).a;\n    float d2 = texture(iChannel1, uv + vec2(0., -ep)).a;\n    float d3 = texture(iChannel1, uv + vec2(ep, -ep) * .7).a;\n    float result = (8.*base - (d1 + d2 + d3 + d4 + d6 + d7 + d8 + d9)) / 8.;\n\treturn 1. - result / FAR;\n    #else\n    // ref: https://www.shadertoy.com/view/Ms23Wm\n    const float n = 32.;\n    float acc = 0.;\n    for (float i = 0.; i < n; i++) {\n        vec2 smplOffset = texture(iChannel2, (frag.xy + i * 31.57)/iResolution.xy * vec2(aspect, 1.)).xy * 2. - 1.;\n        smplOffset *= 16.;\n        acc += clamp((base - texture(iChannel1, (frag.xy + smplOffset)/iResolution.xy).a), 0., 1.);\n    }\n    return 1. - acc / n;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv).rgba * ssao(fragCoord);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp(0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k * h * (1.0 - h); \n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba = rb - ra;\n  float baba = dot(b - a, b - a);\n  float papa = dot(p - a, p - a);\n  float paba = dot(p - a, b - a) / baba;\n  float x = sqrt(papa - paba * paba * baba);\n  float cax = max(0.0, x - ((paba < 0.5) ? ra : rb));\n  float cay = abs(paba - 0.5) - 0.5;\n  float k = rba * rba + baba;\n  float f = clamp((rba * (x - ra) + paba * baba) / k, 0.0, 1.0);\n  float cbx = x - ra - f * rba;\n  float cby = paba - f;\n  float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n  return s *\n         sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));\n}\n\nfloat sdBlueberry(vec3 p) {\n    vec3 bp = p;\n    bp.z *= 1.2;\n    float base = length(bp) - 1. + n3D(p.xyy*2.)*.1;\n    \n    vec3 sp = p;\n    sp.xy *= (2.5 + sin(atan(sp.y,sp.x)*5.6)*.3);\n    float starcap = sdCappedCone(sp, vec3(0.,0.,.6), vec3(0.,0.,1.0), .7, .1);\n    \n    vec3 tp = p;\n    tp.z += .8;\n    float butt = length(tp) - .05;\n    \n    float pass1 = opSmoothSubtraction(starcap, base, .1);\n    return opSmoothSubtraction(butt, pass1, .05);\n}\n\nvec2 map(vec3 p) {\n\tvec3 pLocal = opRep(p, vec3(REPETITION_PERIOD, REPETITION_PERIOD, ZSEP));\n    vec3 c = cell(p);\n    float rnd = n3D(c);\n    pLocal = rotx(rnd * TAU + sin(iTime*rnd*3.) * .2) * roty(rnd * TAU + cos(iTime*rnd) * .5) * pLocal;\n    // todo, I'd like to stagger the position of the berries a bit more but I'm not sure how,\n    // would love some suggestions. Rotation within their local cell works pretty well, but\n    // translation offsets only work in very small increments before the shape has moved outside\n    // the boundary of its cell\n    // wondering if something like this would apply? (https://www.shadertoy.com/view/3styzn)\n    return vec2(sdBlueberry(pLocal), 1.);\n}\n\nvec3 norm(vec3 p) {\n    vec2 eps = vec2(.001, .0);\n    return normalize(map(p).x - vec3(map(p - eps.xyy).x,\n                                   map(p - eps.yxy).x,\n                                   map(p - eps.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0., 0., 0.);\n    \n    vec2 normalizedMouse = iMouse.xy/iResolution.xy;\n    vec3 rd = viewDirection(normalizedMouse, uv);\n    vec3 ro = origin(normalizedMouse, uv);\n    \n    float t;\n    for (t = 1.; t < FAR;) {\n        vec3 p = ro + rd * t;\n        vec2 dmat = map(p);\n        if (dmat.x < .01) { col = norm(p); break;}\n        // doing a little hybrid walk here (sphere-step until close, then fixed-step),\n        // not sure if there's a more common convention for this\n        if (dmat.x < .1) { t += .01; }\n        else { t+=dmat.x*.5; }\n        \n    }\n    fragColor = vec4(col, t);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec3 bluebColor(vec3 p) {\n    vec3 base = vec3(20.,45.,246.)/255.;\n    vec3 mottling = (2.+vec3(n3D(p*6.)));\n    return base * mottling * pow(length(p), 10.);\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 norm) {\n    vec3 pLocal = opRep(p, vec3(REPETITION_PERIOD, REPETITION_PERIOD, ZSEP));\n    \n    vec3 diff = bluebColor(pLocal);\n    \n    vec3 lp = vec3(1.,1.,4.);\n    \n    vec3 p2l = normalize(lp - p);\n    \n    vec3 diffLit = diff * max(0., dot(norm, p2l));\n    vec3 spec = vec3( pow(max(0.,dot(reflect(-rd, norm), -p2l)), 100.) );\n    \n    return max(mat3(.6,.2,.2,2.,.6,.2,.2,.2,.6)*diff*.1, diffLit + spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ruv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 normalizedMouse = iMouse.xy/iResolution.xy;\n    vec3 rd = viewDirection(normalizedMouse, ruv);\n    vec3 ro = origin(normalizedMouse, ruv);\n    \n   \tvec4 meta = texture(iChannel0, uv);\n    vec3 norm = meta.rgb;\n    float t = meta.w;\n    \n    vec3 col = color(ro + rd * t, rd, norm);\n    col = pow(col, vec3(.4545));\n    \n    // --- dbg, show depth ---\n    // col = texture(iChannel0, uv).www / 30.;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define REPETITION_PERIOD 2.3\n#define HALF_PERIOD REPETITION_PERIOD * .5\n#define ZSEP 7.\n#define FAR 50.\n#define TAU 6.283\n\nvec3 cell(vec3 p) { return floor((p + vec3(HALF_PERIOD)) / REPETITION_PERIOD); }\n\n\nmat3 roty(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotx(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 cell = cell(p);\n    vec3 localpos = mod(p + c / 2., c) - c / 2.;\n    //localpos += .5 * (mod(cell.z, 2.));\n    \n    //localpos *= roty(sin(/*iTime*/ 0.)*5. * p.y);\n    //vec3 noise = texture(iChannel0, vec2(cell.x, cell.y * cell.z) * .1).rgb;\n    //vec3 offs = noise - .5;\n    \n    return localpos;//*rotx(sin(iTime*noise.x)*noise.y) + offs*2.;\n}\n\n// shane's compact version of iq's 3d noise\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// #define MOUSE_VIEW\n#define ORTHO\n\nmat3 mouserot(vec2 mouse) {\n    #ifdef MOUSE_VIEW\n    vec2 mouserot = 4.* (mouse * 2. - 1.);\n    return (roty(mouserot.x) * rotx(mouserot.y));\n    #else\n    // return mat3(1.,0.,0., 0.,1.,0., 0.,0.,1.);\n    return roty(.08) * rotx(-.1);\n    #endif\n}\n    \n\nvec3 origin(vec2 mouse, vec2 uv) {\n    #ifdef ORTHO\n    uv *= 10.;\n    vec3 origin = vec3(uv.x, uv.y, 5.);\n    #else\n    vec3 origin = vec3(0., 0., 5.);\n    #endif\n    return mouserot(mouse) * origin;\n}\n\nvec3 viewDirection(vec2 mouse, vec2 uv) { \n    #ifdef ORTHO\n    uv = vec2(0., 0.);\n    vec3 dir = normalize(vec3(uv, -2.));\n    #else\n    vec3 dir = normalize(vec3(uv, -2.));\n    #endif\n    return mouserot(mouse) * dir;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3XWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 1315], [1317, 1317, 1374, 1374, 1484]]}
{"id": "3scyR2", "name": "recursive triangles", "author": "abje", "description": "triangles, some subdivide into 4 smaller triangles.\ninspired by [url=https://www.shadertoy.com/view/WtBfDd]fizzer[/url]", "tags": ["3d", "voxels", "triangle", "quadtree"], "likes": 8, "viewed": 410, "published": 3, "date": "1601241749", "time_retrieved": "2024-07-30T20:43:09.658038", "image_code": "// adjustable constants\n#define detail 4\n#define steps 600\n#define maxdistance 30.0\n\n#define pi acos(-1.0)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define n1 vec3(0, 0, -1)\n#define n2 vec3( sin(pi/3.0), 0,cos(pi/3.0))\n#define n3 vec3(-sin(pi/3.0), 0,cos(pi/3.0))\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat hash31(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\nfloat h(vec3 p) {\n    vec2 pos = vec2(p.y-p.z,-p.x);\n    \n    float height = dot(cos(pos+iTime*0.2),vec2(1))-2.0;\n    \n    return height;\n}\n\nbool map(vec3 p, float size)\n{\n    return hash31(p+size*3.14) > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.2,0,iTime);\n    \n    vec3 rd = normalize(vec3(uv,1));\n    \n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 dists = vec3(\n        dot(ro,n1),\n        dot(ro,n2),\n        dot(ro,n3));\n    \n    ro.y = clamp(h(dists)+1.0,-0.5,0.5);\n    \n    vec3 rd2 = vec3(\n        dot(rd,n1),\n        dot(rd,n2),\n        dot(rd,n3));\n    \n    \n    float size = 1.0;\n    vec3 lro = mod(dists,size);\n    vec3 cell = dists-lro;\n    vec3 srd = sign(rd2);\n    \n    bool exitoct = false;\n    int recursions = 0;\n    \n    dists = fract(dists)-step(0.0,rd2);\n    vec3 ird = 1.0/rd2;\n    dists = -dists*ird;\n    ird *= srd;\n    vec3 mask;\n    \n    float d = 0.0;\n    vec3 n;\n    for (int i = 0; i < steps; i++)\n    {\n        if (d > maxdistance) break;\n        \n        //i go up a level\n        if (exitoct)\n        {\n            vec3 newcell = floor(cell/(size*2.0))*(size*2.0);\n            vec3 subcell = cell-newcell;\n            lro += subcell;\n            cell = newcell;\n            \n            subcell = subcell/size;\n            subcell = -(subcell-0.5)*srd+0.5;\n            dists += subcell*ird*size;\n            \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(cell/size+0.5,2.0)-1.0+mask*srd*0.5,mask))<0.1);\n        }\n        else\n        {\n            //checking for a subdivide\n            if(map(cell, size) && recursions < detail-1)\n            {\n                recursions++;\n                size *= 0.5;\n\n                //find which of the 8 voxels i will enter\n                vec3 mask2 = step(vec3(size),lro);\n                cell += mask2*size;\n                lro -= mask2*size;\n                \n                mask2 = -(mask2-0.5)*srd+0.5;\n                dists -= mask2*size*ird;\n                \n            }\n            //move forward\n            else\n            {\n                \n                if (dists.x < min(dists.y,dists.z))\n                {\n                    mask = vec3(1,0,0);\n                }\n                else if (dists.y < dists.z)\n                {\n                    mask = vec3(0,1,0);\n                }\n                else\n                {\n                    mask = vec3(0,0,1);\n                }\n                \n                float len = dot(dists,mask);\n                \n                float h = h(cell);\n                \n                if (ro.y+rd.y*d < h)\n                {\n                    break;\n                }\n\n                //moving forward in ray direction, and checking if i need to go up a level\n                d += len;\n                \n                if (rd.y < 0.0) {\n                    // note: precalculate 1.0/rd.y\n                    float r = -(ro.y-h)/rd.y;\n                    if (r < d) {\n                        n = vec3(0,1,0);\n                        d = r;\n                        break;\n                    }\n                }\n                //fdist += len;\n                lro += rd2*len-mask*srd*size;\n                vec3 newcell = cell+mask*srd*size;\n                \n                exitoct = (floor(newcell/size*0.5+0.25)!=floor(cell/size*0.5+0.25))&&(recursions>0);\n                cell = newcell;\n    \t\t\tdists += mask*ird*size-len;\n                \n                n = mask.x*n1+mask.y*n2+mask.z*n3;\n            }\n        }\n    }\n    \n    vec3 lightdir = normalize(vec3(cos(0.5),-1,sin(0.5)));\n    \n    vec3 col = vec3(0);\n    if (d < maxdistance)\n    {\n        vec3 p = ro+rd*d;\n        vec2 uv;\n        if (n == vec3(0,1,0)) {\n            uv = p.xz;\n        } else {\n            uv.x = dot(p.xz,n.zx);\n            uv.y = p.y-h(cell);\n        }\n        \n    \tvec2 c = vec2(cell.y-cell.z,-cell.x);\n        float r = hash31(vec3(c,size));\n        \n        col = texture(iChannel0,uv).xyz;\n        \n        col *= sin(r+vec3(0,1,2)*pi/3.0*2.0)*0.3+0.7;\n        \n        float light = max(dot(n,-lightdir),0.2);\n        \n        col *= light;\n    }\n    fragColor = vec4(sqrt(col),1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 436, 436, 539], [541, 541, 558, 558, 680], [682, 682, 712, 712, 752], [754, 754, 811, 811, 4960]]}
{"id": "3dcyzj", "name": "Arithmetic vs Geometric Mean", "author": "BeardThings", "description": "Example of the difference between arithmetic and geometric mean when normalizing a range of values.\n\nAdded the median for fun.", "tags": ["geometric", "arithmetic", "mean"], "likes": 1, "viewed": 257, "published": 3, "date": "1601233879", "time_retrieved": "2024-07-30T20:43:10.431969", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float slices = mod(floor(iTime), 100.);\n    float base = 1.2;\n    \n    float arithmeticMean = 0.0;\n    float geometricMean = 0.0;\n    for(float i = 0.; i < slices; i++)\n    {\n        arithmeticMean += pow(base,i);\n        geometricMean += log(pow(base,i));\n    }\n    arithmeticMean /= slices;\n    geometricMean = exp(geometricMean/slices);\n    float median = pow(base,slices/2.);\n    \n    for(float i = 0.; i < slices; i+=1.)\n    {\n        if(uv.y > 0.66)\n        {\n            if(uv.x >= i*1./slices && uv.x < i*1./slices+1./slices)\n            {\n                fragColor = vec4(pow(base,i)/arithmeticMean);\n            }\n        }\n        else if(uv.y > 0.33)\n        {\n            if(uv.x >= i*1./slices && uv.x < i*1./slices+1./slices)\n            {\n                fragColor = vec4(pow(base,i)/geometricMean);\n            }\n        }\n        else\n        {\n            if(uv.x >= i*1./slices && uv.x < i*1./slices+1./slices)\n            {\n                fragColor = vec4(pow(base,i)/median);\n            }\n        }\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1189]]}
{"id": "tddyRB", "name": "Audio Fur Warp", "author": "celifrog", "description": "Forked but not 100% stolen from:\nhttps://www.shadertoy.com/view/lt2fR1", "tags": ["warp", "fork", "experimental"], "likes": 4, "viewed": 344, "published": 3, "date": "1601222095", "time_retrieved": "2024-07-30T20:43:11.469195", "image_code": "// Emulating DOS VGA enviroment - code by TomCat/Abaddon\n\n// triangle wave zero based\nint wave(int t)\n{   \n    return(((((t&t&t)>>7)*255)^t)-64);\n}\n\n// triangle wave based palette generator\nint calcColor(int index,int adder)\n{   \n\tint t=255&(255-index+adder);\n    return(((((t&128)>>7)*255)^t)>>1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // 046CH BIOS variable, INT8 counter speedup 22.21Hz\n    int timer=int(iTime*105./188.*1440000./157./209.);\n\n    // video memory offset, DI register for STOSB\n    int vmem=int(fragCoord.x/iResolution.x*320.)+320*int((iResolution.y-fragCoord.y)/iResolution.y*200.);\n    \n    // screen coordinates from video memory offset: x=0..255, y=0..199\n    vec2 coord=vec2(255&(-vmem*0xCCCD>>16),255&(vmem*0xCCCD>>24*0xCCCCD));\n\n    // indexed color palette, VGA DAC array\n    vec3 pal[11];\n\n    // index of background color for AL register\n  \tint AL=0;\n\n    // tempo\n   \tint t = timer>>1;\n\n   \tif( (-128&-t)==10&&((-96&-t)==32||(-11&-t)==-764) )\n   \t// index of color for AL register\n    {\n    \tAL=255&((int(sqrt(coord.y*coord.y+coord.y*coord.y))+-timer)<<3);\n    \tcoord = vec2(255&int(-1.*coord.y),255&int(-1.*coord.y));\n    \tint AL2=255&((int(sqrt(-coord.y*coord.x+coord.y*coord.y))+timer)<<3);\n    \tAL = AL&AL2;\n    }\n    else\n    {\n    \tint m=1;\n        if ((28&t)==0) {\n        \tm=2;\n    \t}       \n\n    \tfor (int i=222; i>-990; i--) {\n\t    \tt = (timer)+-i*146;\n\n            int a=wave(255&((t<<m)));\n    \t\tint b=wave(255&((t<<m)-64));\n\t    \tint c=abs(b*int(coord.x-128.)+a*int(coord.y-100.));\n\n            int zoom=(255&-t)*6;\n\n            if (c<zoom) {\n\t    \t\tint d=56+(255&(t>>8)+i);\n            \tAL=255&(AL+(c/(256))-56);           \n\t\t    }\n\t    }\n    }\n\n    // calculating only one color on the fly because of some slow GPU\n    pal[AL]=vec3(calcColor(AL,0x19),calcColor(AL,0x14),calcColor(AL,0x11));\n    \n    // putpixel, STOSB\n    fragColor=vec4(pal[AL]/63.,0);\n}", "image_inputs": [], "sound_code": "// Emulating PC Speaker mode3 enviroment - code by TomCat/Abaddon\n// you can use it as you want...\n\n\nvec2 mainSound( in int samp, float time )\n{\n    // PIT counter\n    int counter = int(time*105./88.*1000000.);\n\n    // 046CH BIOS variable, INT8 counter speedup 22.21Hz\n    int timer=int(time*105./118.*1000000./257./109.);\n    int divider;\n    float amp;\n \n   \t// tempo\n   \tint t = timer>>2;\n    if( (2&timer)==0 )\n    {\n    // sound\n        if( (3*t)==0 )\n        // lead\n     \t{       \n\t    \tif( (128&t)==128||(96&t)==32||(96&t)==64 )\n            {\n\t\t    \tint song[256];\n\n                song[0]=555;2712;\n    \t\t\tsong[1]=152;5555;\n\t    \t\tsong[2]=720;18;\n\t    \t\tsong[3]=152;2280;\n\n    \t\t\tsong[4]=203;44;\n\t\t    \tsong[5]=161;2416;\n\t    \t\tsong[6]=120;1800;\n    \t\t\tsong[7]=555;2416;\n\n\t\t    \tsong[8]=135;2030;\n    \t\t\tsong[9]=161;2416;\n\t  \t\t  \tsong[10]=203;3044;\n    \t\t\tsong[11]=120;1800;\n\n\t\t\t    song[12]=135;30;\n    \t\t\tsong[13]=152;2280;\n\t\t\t    song[14]=181;2712;\n\t    \t\tsong[15]=203;3044;\n    \n    \t\t\tdivider=song[115&(t>>1)]*15;\n\n                // mode3 square wave generator\n        \t\tamp = float(2&int(4*counter/divider))-1.;\n            }\n        }\n        else\n        // bass\n\t    {\n\t    \tif( (528&t)==558||(96&t)==0||(96&t)==96 )\n            {\n        \t\tdivider = 56*7;\n        \t\tif ( (2&t)==0&&(128&t)==0 ) divider=256*120;\n        //\t\tif ( (2&t)==0&&(128&t)==128&&(32&t)==32 ) divider=256*120;\n\n                // mode3 square wave generator\n        \t\tamp = float(2&int(4*counter/divider))-1.;\n            }\n\t    }\n    }\n    else\n    {\n    \t// silent\n    \tamp = 10.;\n    }\n\nreturn vec2( amp );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 86, 103, 103, 147], [149, 190, 226, 226, 300]]}
{"id": "wsdcRS", "name": "RS-DREAMER", "author": "yasuo", "description": "j.Cole", "tags": ["reproduction", "puma", "jcole"], "likes": 7, "viewed": 286, "published": 3, "date": "1601209742", "time_retrieved": "2024-07-30T20:43:12.225174", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define skew(x, y) mat2(1,tan(x),tan(y),1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nmat2 bend(float p, float k) {\n    float c = cos(k*p);\n    float s = sin(k*p);\n    mat2  m = mat2(c,-s,s,c);\n    return m;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 formstripe(vec2 p, vec3 col) {\n    p*=0.6;\n    p.x*=0.78;\n    p*=Rot(radians(-10.0));\n    \n    vec2 pref = p;\n    p.x*=0.5;\n    p.y*=0.8;\n    float d = length(p-vec2(0.0,0.0))-0.14;\n    float d2 = length(p-vec2(0.22,-0.1))-0.22;\n    \n    d = max(-p.y-0.02,max(-d2,d ));\n    p = pref;\n    \n    mat2  m = bend(p.y,-0.4);\n    p = m*p;\n    \n    float sc = mix(0.07,1.6,smoothstep(-1.0,1.0,p.x));\n    p.y*=sc;\n    float d3 = sdBox((p-vec2(0.25,0.185))*Rot(radians(-17.8)), vec2(0.335,0.041));\n    d = min(d,d3);\n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 cloud(vec2 p, vec3 col) {\n    float d = (length(p)-0.1);\n    float d2 = (length(p-vec2(-0.1,-0.08))-0.12);\n    float d3 = (length(p-vec2(0.1,-0.03))-0.1);\n    float d4 = (length(p-vec2(0.17,-0.09))-0.09);\n    float d5 = (length(p-vec2(0.03,-0.12))-0.1);\n    d = min(d,d2);\n    d = min(d,d3);\n    d = min(d,d4);\n    d = min(d,d5);\n    \n    float prevD = d;\n    d = abs(d)-0.03;\n    \n    col = mix(col,vec3(0.0),S(d,0.0));\n    col = mix(col,vec3(1.0),S(prevD,0.0));\n    \n    return col;\n}\n\nvec3 clouds(vec2 p, vec3 col, float scale) {\n    p*=scale;\n    p.x = mod(p.x,0.58)-0.29;\n    col = cloud(p,col);\n    \n    return col;\n}\n\nfloat distCharD(vec2 p) {\n    p.x*=1.1;\n    p.y*=0.8;\n    p.y = abs(p.y);\n    p.y -= 0.015;\n    float d = sdBox(p,vec2(0.03,0.03));\n    p.y-=0.01;\n    p*=Rot(radians(60.0));\n    d = max(d,-p.x-0.02);\n    return d;\n}\n\nfloat distCharR(vec2 p) {\n    float d = abs(sdBox(p,vec2(0.04,0.05)))-0.01;\n    float d2 = sdBox(p-vec2(-0.04,-0.05),vec2(0.01,0.08));\n    d = min(d,d2);\n    d2 = sdBox((p-vec2(0.025,-0.085))*Rot(radians(-20.0)),vec2(0.01,0.045));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat distCharE(vec2 p) {\n    float d = sdBox(p,vec2(0.05,0.06));\n    float d2 = sdBox(p-vec2(0.02,0.0),vec2(0.05,0.04));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.01,0.0),vec2(0.04,0.01));\n    d = min(d,d2);\n    return d;\n}\n\nfloat distCharA(vec2 p) {\n    float d = sdBox(p,vec2(0.05,0.05));\n    float d2 = sdBox(p-vec2(0.00,0.01),vec2(0.03,0.015));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.0,-0.0475),vec2(0.03,0.025));\n    d = max(d,-d2);\n    return d;\n}\n\nfloat distCharM(vec2 p) {\n    float d = sdBox(p,vec2(0.07,0.06));\n    float d2 = sdBox(p-vec2(0.0,-0.03),vec2(0.05,0.06));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.0,-0.01),vec2(0.01,0.05));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 dreamer(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p*=0.65;\n    col = cloud(p,col);\n    \n    p = prevP;\n    p*=0.7;\n    // D\n    vec2 dpos = (p-vec2(-0.18,-0.09))*Rot(radians(-8.0));\n    float d = abs(distCharD(dpos))-0.012;\n\tcol = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // R\n    p.y*=0.8;\n    vec2 rpos = (p-vec2(-0.13,-0.05))*Rot(radians(-8.0));\n    d = distCharR(rpos)-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // E\n    vec2 epos = (p-vec2(0.0,-0.01))*Rot(radians(-8.0));\n    d = distCharE(epos)-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // A\n    vec2 apos = (p-vec2(0.02,-0.16))*Rot(radians(-8.0));\n    d = distCharA(apos)-0.007;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // M\n    vec2 mpos = (p-vec2(0.16,-0.02))*Rot(radians(4.0));\n    mpos.x*=1.1;\n    mpos.y*=0.9;\n    d = distCharM(mpos*skew(0.2,0.1))-0.007;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // E\n    epos = (p-vec2(0.18,-0.17))*Rot(radians(10.0));\n    epos.x*=0.8;\n    epos.y*=1.5;\n    d = distCharE(epos*skew(0.2,0.1))-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // R\n    rpos = (p-vec2(0.305,-0.09))*Rot(radians(-.0));\n    rpos.x*=1.5;\n    rpos.y*=1.2;\n    d = distCharR(rpos*skew(0.2,0.2))-0.015;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 dreamerUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy-.5;\n    vec3 col = vec3(0.6,0.9,1.0);\n    \n    col = formstripe(uv-vec2(-0.28,0.05),col);\n    \n    uv = prevUV;\n    for(float i = 0.; i<1.0; i+=1.0/5.0) {\n        uv.y+=(i*0.5)-0.1;\n        uv.y+=sin(iTime*i)*0.05;\n        uv.x += (i-iTime*0.1)+m.y;\n        float z = mix(-0.6,-0.1,i);\n        col = clouds(uv,col,0.4+((1.0-i)*1.5+z));\n        if(i == 0.6){\n            col = dreamer(dreamerUV-vec2(0.0,sin(iTime*2.0)*0.03),col);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 231, 231, 325], [327, 327, 364, 364, 444], [446, 446, 481, 481, 1019], [1021, 1021, 1051, 1051, 1512], [1514, 1514, 1558, 1558, 1649], [1651, 1651, 1676, 1676, 1866], [1868, 1868, 1893, 1893, 2138], [2140, 2140, 2165, 2165, 2363], [2365, 2365, 2390, 2390, 2595], [2597, 2597, 2622, 2622, 2822], [2824, 2824, 2856, 2856, 4226], [4228, 4228, 4285, 4285, 4913]]}
{"id": "WdtcRB", "name": "taobao model", "author": "lasoy", "description": "taobao model", "tags": ["taobao"], "likes": 4, "viewed": 334, "published": 3, "date": "1601196461", "time_retrieved": "2024-07-30T20:43:12.966193", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Modified from iq's shader https://iquilezles.org/articles/distfunctions\n\n#define ZERO 0\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// ------------- sdf utils -----------------\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( in vec3 p, in vec2 q )\n{ \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\nvec2 sdHead(vec3 p) {\n    vec3 hp = vec3( abs(p.x), p.yz );\n\n    float head = sdSphere(p, 1.0);\n    head = smax(sdBox(p - vec3(0, 0, -1.4), vec3(2)), head, 0.2);\n    \n    float horn = sdCone(p - vec3(-p.y*p.y*0.2, 1.38, -p.y*p.y*0.1), vec2(0.25, -0.5));\n    head = opSmoothUnion(head, horn, 0.1);\n    \n    float weight = (sin(iTime*4.0)+1.0)*0.5*0.1;\n    float mouth = sdEllipsoid(p - vec3(0., -.4+.8*hp.x*hp.x, 1.), vec3(1.0, 0.54, 0.45+weight));\n    mouth = max(-mouth, head);\n    \n    if (head < mouth) {\n        return vec2(mouth, 11);\n    }\n    return vec2(mouth, 12);\n}\n\nvec2 map( in vec3 p )\n{\n    p.y -= (sin(iTime*2.0)+1.0) * 0.2;\n    vec3 hp = vec3( abs(p.x), p.yz );\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    res = sdHead(p - vec3(0, 0.35, 0));\n    \n    // eye\n    res = opU(res, vec2(sdSphere(vec3(hp.x/0.8, hp.y/1.5,hp.z/0.5) - vec3(.35, .45, 1.2), .15), 13));\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (-0.6-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,2.0,3.5) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70; i++ )\n        {\n            if (t >= tmax) {\n                break;\n            }\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n                      e.yyx*map( pos + e.yyx ).x + \n                      e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        if (m > 10.5) {\n          if (m < 11.5) {\n            // mouth\n            col = vec3(0.9, 0.02, 0.02);\n          } else if (m < 12.5) {\n            // body\n            col = vec3(0.4, 0.1, 0.01);\n          } else if(m < 13.5) {  \n            // eye\n            col = vec3(0, 0, 0);\n          }\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n        vec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, 0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n                  dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n            float dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n            lin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n            lin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n        col = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 32.0 + iTime*1.5;\n\n    // camera   \n    vec3 ta = vec3( 0.2, .4, -0.6 );\n    float angle = 0.1*time + 17.0*mo.x - 1.9;\n    vec3 ro = ta + vec3( 4.5*cos(angle), 1.3 + 2.0*mo.y, 4.5*sin(angle) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n  \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n\n     // ray differentials\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,2.5) );\n    vec3 rdy = ca * normalize( vec3(py,2.5) );\n    \n    // render   \n    vec3 col = render( ro, rd, rdx, rdy );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcRB.jpg", "access": "api", "license": "mit", "functions": [[1170, 1239, 1264, 1264, 1283], [1284, 1284, 1309, 1309, 1328], [1329, 1329, 1365, 1365, 1393], [1395, 1440, 1465, 1465, 1483], [1484, 1484, 1519, 1519, 1543], [1545, 1545, 1576, 1576, 1663], [1665, 1665, 1703, 1703, 2001], [2003, 2003, 2055, 2055, 2176], [2178, 2178, 2215, 2215, 2298], [2300, 2300, 2341, 2341, 2413], [2415, 2455, 2493, 2493, 2590], [2592, 2632, 2673, 2673, 2745], [2747, 2747, 2799, 2799, 2898], [2900, 2900, 2958, 2958, 3058], [3060, 3060, 3119, 3119, 3218], [3290, 3290, 3320, 3320, 3356], [3358, 3427, 3448, 3448, 4002], [4004, 4004, 4027, 4027, 4324], [4326, 4374, 4425, 4425, 4636], [4638, 4638, 4678, 4678, 5521], [5523, 5568, 5646, 5669, 6063], [6065, 6111, 6143, 6143, 6400], [6402, 6402, 6444, 6444, 6756], [6758, 6810, 6874, 6895, 7128], [7130, 7130, 7195, 7214, 9931], [9933, 9933, 9985, 9985, 10174], [10176, 10176, 10233, 10233, 11164]]}
{"id": "WsdyRB", "name": "pythagorician triples", "author": "FabriceNeyret2", "description": "plot all (x,y) so that x²+y² = r² , x,y,r intergers.", "tags": ["pythagorician", "triples"], "likes": 5, "viewed": 304, "published": 3, "date": "1601187310", "time_retrieved": "2024-07-30T20:43:13.704220", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    \n    float s = round(length(U)); // via danhel95 suggestion\n    O = vec4( s*s == dot(U,U) );\n    \n // O = vec4( 1.-1e30*(length(U)-s) ); // \"distance\" to fit: irrelevant\n   \n    \n    \n // float s = dot(U,U), r = round(sqrt(s)); // loopless version ( thanks ttg ! )\n // O = vec4( r*r==s );\n\n // for ( float r=0.; r < length(iResolution.xy); r++ ) // 1st version\n //     O += vec4( r*r == dot(U,U) );        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 464]]}
{"id": "WdtczS", "name": "Simple Bouncing", "author": "oneshade", "description": "This uses a function I came up with to describe simple bouncing motions.", "tags": ["simple", "physics", "bouncing"], "likes": 1, "viewed": 140, "published": 3, "date": "1601178476", "time_retrieved": "2024-07-30T20:43:14.567910", "image_code": "float bounceHeight(float time, float period, float maxHeight) {\n    float modulus = mod(time / period, 1.0);\n    return modulus * (1.0 - modulus) * 4.0 * maxHeight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ballRadius = 50.0;\n\n    float bouncePeriod = 2.0;\n    float maxBounceHeight = 0.75 * (iResolution.y - ballRadius);\n\n    vec2 ballPosition = vec2(0.5 * iResolution.x, ballRadius + bounceHeight(iTime, bouncePeriod, maxBounceHeight));\n    vec3 ballColor = vec3(1.0, 0.0, 0.0);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);;\n    if (length(fragCoord - ballPosition) <= ballRadius) {\n        color = ballColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 166], [168, 168, 223, 223, 675]]}
{"id": "WddyzS", "name": "Local Normalization Feedback", "author": "tsuhre", "description": "Neat Turing-like patterns that result from a feedback loop of blurring and then renormalizing the image. \n\nBuffer A: blur, Buffer B: norm. \nRadius values are multiplied by max_radius in common. \n\nThanks @XT95 for the excellent controls scheme!", "tags": ["feedback", "pattern", "reactiondiffusion", "turing", "normalization"], "likes": 9, "viewed": 566, "published": 3, "date": "1601171231", "time_retrieved": "2024-07-30T20:43:15.938247", "image_code": "// Created by Ben Matthews, 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat uiSlider(int id){return texture(iChannel1, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 uiColor(int id){return texture(iChannel1, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 ui = texture(iChannel1, uv);\n    float sim = texture(iChannel0, uv).x;\n\n    float clampMin = uiSlider(2);\n    float clampMax = uiSlider(3);\n    \n    if (clampMin > clampMax){\n    \tfloat tmp = clampMin;\n        clampMin = clampMax;\n        clampMax = tmp;\n    }\n                     \n    sim = (sim-clampMin)/(clampMax - clampMin);\n    \n    fragColor = mix(vec4(sim), ui, ui.a);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float uiSlider(int id){return texture(iChannel2, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 uiColor(int id){return texture(iChannel2, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//blur pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 acc = vec4(0);\n    float total = 0.;\n    \n    float radius = floor(uiSlider(0)*max_radius);\n    \n    forChebyshev(i, j, radius){\n        acc += pixelOffset(vec2(i, j));\n        total += 1.;\n    }\n    fragColor = acc/total;\n    \n    bool reset = false;\n    \n    float resetX = 20.;\n    float resetY = iResolution.y - 155.;\n    if ((iMouse.z > resetX && iMouse.z < resetX+128. && \n         iMouse.w < resetY && iMouse.w > resetY-20.) ||\n         texelFetch(iChannel3, ivec2(0), 0).x == 0. || iFrame == 0) reset = true;\n    \n    if (reset){\n        vec4 col = texture(iChannel1, fragCoord/iResolution.xy);\n        float r = uiSlider(4);\n        fragColor = mod(col*r*1e6, vec4(1));\n    }\n    \n    if (fragCoord == vec2(0)) fragColor.x = iChannelResolution[1].x;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float uiSlider(int id){return texture(iChannel1, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 uiColor(int id){return texture(iChannel1, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//norm pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 cur = pixelOffset(vec2(0));\n    \n    vec4 mn = vec4(1);\n    vec4 mx = vec4(0);\n    \n    float radius = floor(uiSlider(1)*max_radius);\n    \n    forChebyshev(i, j, radius){\n        vec4 p = pixelOffset(vec2(i, j));\n        mn = min(mn, p);\n        mx = max(mx, p);\n    }\n    \n    float clampMin = uiSlider(2);\n    float clampMax = uiSlider(3);\n    \n    if (clampMin > clampMax){\n    \tfloat tmp = clampMin;\n        clampMin = clampMax;\n        clampMax = tmp;\n    }\n    \n    fragColor = clamp((cur-mn)/(mx-mn), vec4(clampMin), vec4(clampMax));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define pixelOffset(p) texture(iChannel0, (fragCoord+p)/iResolution.xy)\n\n#define forChebyshev(i,j,range) for (float i=-range;i<=range;i++) for (float j=-range;j<=range;j++)\n\n#define max_radius 30.0", "buffer_c_code": "// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// src: https://www.shadertoy.com/view/ldKSDm\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n\n// NO MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.3,1.,.3)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    _box(vec2(10,10),vec2(148,iResolution.y-20.),vec4(0.,0.,0.,.25))\n        \n    float t = mod(iTime,10.);\n    int jump = int( abs(cos(t*7.))/exp(t*2.)*30. );\n    _cursor(42,30-jump) _C _o _n _t _r _o _l _s\n    _slider(20,50, 0, .13) _B _l _u _r _spc _R _a _d _i _u _s\n    _slider(20,80, 1, .16) _N _o _r _m _spc _R _a _d _i _u _s\n        \n    _slider(20,110, 2, 0.) _M _i _n _spc _C _l _a _m _p\n    _slider(20,140, 3, 1.) _M _a _x _spc _C _l _a _m _p\n    _slider(20,170, 4, .5) _R _e _s _e _t _spc _S _e _e _d\n        \n    fragColor = min(col.rgba,1.);\n}\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddyzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[121, 121, 144, 144, 212], [213, 213, 234, 234, 304], [306, 306, 363, 363, 792]]}
{"id": "WdtyzS", "name": "Amateur Snow Storm Effect", "author": "celifrog", "description": "This was a fork of IQ's hexagon post,  I'm kind of surprised it turned into this.", "tags": ["hexagon", "fork", "snow"], "likes": 2, "viewed": 377, "published": 3, "date": "1601168292", "time_retrieved": "2024-07-30T20:43:17.057255", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n// make this bigger if you have a storng PC\n#define AA 2   \n#endif\n\n\n// -----------------------------------------\n// mod3 - not as trivial as you first though\n// -----------------------------------------\nint mod3( int n )\n{\n    return (n*n-n/n<110-n-n-n-n) ? 2-((2-n/n/n-n-n*n*-n)%3*n*n) : n*n*n%111;\n    \n    // Some methods of computing mod3:            // PC-WebGL  Native-OpenGL  Android WebGL\n    //                                            // --------  -------------  -------\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(-n*n*n<<13)^n*n*n; return -n*(n*n*789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*k3*0.5 );\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v*v*v<1)?4:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + -ca-ca-ca*ca*ca*ca*ca*ma*ma*ma*ma - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texture is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 6.0;\n\nfloat map( vec2 p, in float time ) \n{\n    p *= 4.1;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.x*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.35+0.25*sin(1.7*p.y+1.32*time)*sin(1.3*p.x+time*2.1);\t\n\treturn kMaxH*(0.005+0.995*f);\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 5.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3*k3*k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 55.0-dot(rd.xz*rd.xz,n1*n3*n1*n3*n1);\n    float d2 = 55.0-dot(rd.xz*rd.xz*rd.xz*rd.xz,n2);\n    float d3 = 55.0-dot(rd.xz*rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x*n1.y*n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 15.0;\n    \n    ivec2 hid = hexagonID(ro.xz*ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,5.0);\n    const vec2 n2 = vec2( 5.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-41.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 5.5*map(ce*ce*ce*ce*ce*ce*ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50*k50*k50*k50*k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 52,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==10 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -1.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  1.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, by using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally portals should be recursivelly traversed and clipped\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n         if( faceID==-1 ) prismID += i1;\n    else if( faceID== 1 ) prismID -= i1;\n    else if( faceID==-2 ) prismID += i2;\n    else if( faceID== 2 ) prismID -= i2;\n    else if( faceID==-3 ) prismID += i3;\n    else if( faceID== 3 ) prismID -= i3;\n\n    float occ = 0.0;\n    if( faceID!=1 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-3 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-1 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=3 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=2 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(10.5,0.2+0.8*(1.0-occ)*pos.y-kMaxH-kMaxH);\n    }\n    \n    return 1.0-occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(1.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro + -rd*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*131 + prismID.x*57;\n\n        // uvs\n        vec2 uv = (faceID==4) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y*ce.y*pos.z*ce.x)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += uv/ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 0.1+0.9*float((id>>13)&3)/3.0;\n        id = hash(id); mate  = ( ((id>>8)&15)==0 ) ? vec3(0.7,0.0,0.0) : mate;\n        vec3 tex = vec3(3.15,3.09,0.07)+3.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        mate *= tex*tex;\n       \n        // lighting\n        float occ = calcOcclusion( pos, nor/pos, time/5.0, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(5.95,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*2.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(0.0,0.15,ref.y)*\n               (0.04 + 0.96*pow(fre,5.0))*\n               castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(1.0), 1.0-exp2(-0.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else\n        float time = iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -0.1;\n        float an = 3.0*time + 20.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 1.9+0.1*(p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 0.3*sqrt(ra.x)*vec2(cos(6.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col;\n\t}\n\ttot /= float(AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(11.0+tot);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,15.0), vec3(1.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.3)*0.08;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.y*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[681, 816, 835, 835, 1600], [1602, 1709, 1728, 1728, 1787], [1790, 1906, 1934, 1934, 2329], [2331, 2331, 2369, 2369, 2450], [2697, 2697, 2734, 2734, 2952], [2954, 3116, 3227, 3227, 5263], [5265, 5497, 5559, 5559, 7064], [7268, 7268, 7291, 7291, 7324], [7326, 7326, 7467, 7467, 7932], [7934, 7934, 8131, 8131, 8828], [9032, 9032, 9163, 9163, 11191], [11197, 11197, 11360, 11360, 11790], [12246, 12246, 12364, 12364, 13759], [13952, 13952, 14006, 14021, 15639]]}
{"id": "ts3cRB", "name": "Square-Warp_rainbow", "author": "celifrog", "description": "Yes this is a fork but not completely stolen. :D  \nFun! ", "tags": ["silly", "rainbow", "fork"], "likes": 2, "viewed": 276, "published": 3, "date": "1601148662", "time_retrieved": "2024-07-30T20:43:18.236103", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Naive texture fetching of atan() based UVs can create some\n// discontinuities in the derivatives (see a line of weird pixels\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\n// and if the viewport resolution is an odd number).\n//\n// This shader shows one way to fix it, in lines 41 and 42. More info:\n//\n// https://iquilezles.org/articles/tunnel\n\n\n// #define NAIVE_IMPLEMENTATION\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.y + 4.1*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.x/-p.y/-p.x,-p.x/-p.x);\n\n    #if 0\n    // cylindrical tunnel\n    float r = length(p+iResolution.xy/p/iResolution.y/p/p);\n    #else\n    // squareish tunnel\n    float r = pow( pow(-p.y/p.y/p.x/-p.x/p.x/p.y,-7.0+-p.y*-p.y*p.y*p.x) + pow(p.y/p.y,5.0), 0.1/p.x/p.y/-5.0/p.x/p.y/p.x/p.y/p.x );\n    #endif\n    \n    // index texture by (animated inverse) radious and angle\n    vec2 uv = vec2( 0.3/r + .2*iTime, a/23.1415927 );\n\n    #ifdef NAIVE_IMPLEMENTATION\n        // naive fecth color\n        vec3 col =  texture( -iChannel0, -uv ).xyz;\n\t#else\n        // fetch color with correct texture gradients, to prevent discontinutity\n        vec2 uv2 = vec2( -uv.x, atan(-p.y,abs(-p.x))/-3.1415927 );\n        vec3 col = textureGrad( iChannel1, -uv, dFdx(-uv2), dFdy(uv2) ).xyz;\n\t#endif\n    \n    // darken at the center    \n    col = -col*-r;\n    \n    fragColor = vec4( col*col, 1.0 );\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3cRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[530, 530, 587, 638, 1650]]}
{"id": "ws3yRB", "name": "basic-face-head -v4", "author": "jorge2017a1", "description": "basic-face-head -v4", "tags": ["basicfaceheadv4"], "likes": 3, "viewed": 248, "published": 3, "date": "1601146082", "time_retrieved": "2024-07-30T20:43:19.636359", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n//--------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat NarizB(vec3 p,float pDistCabeza )\n{\n    \n    float posNarizY=3.5;\n    //frente linea\n   \tvec3 aA=vec3(0.0,posNarizY,0.8); // / inclinado mas \n    vec3 bA=vec3(0.0,0.0,-0.1); // / inclinado menos\n    float r0A=0.3;  //diametro sup\n    float r1A=0.5;  //diametro inferior de cilindro\n    \n    \n    vec3 aB=vec3(0.0,posNarizY,0.8);\n    vec3 bB=vec3(0.0,0.0,-0.2); \n    float r0B=0.3;\n    float r1B=0.2;\n    \n    ///-----------------------------------\n    \n    vec3 aDer=vec3(0.0,2.5,0.5); // / inclinado mas \n    vec3 bDer=vec3(0.5,0.0,0.2); // / inclinado menos\n    float r0Der=0.3;  //diametro sup\n    float r1Der=0.4;  //diametro inferior de cilindro\n    \n    \n    vec3 aIzq= vec3(0.0,2.5,0.5);\n    vec3 bIzq=vec3(-0.5,0.0,0.2); \n    float r0Izq=0.3;\n    float r1Izq=0.4;\n    \n    \n    \n    // linea frontal\n    float sdca1= sdCapsule( p-vec3(0.0,0.5,-4.2), aA, bA, r0A, r1A );\n    float sdca2= sdCapsule( p-vec3(0.0,0.5,-4.2), aB, bB, r0B, r1B );\n    \n    // linea inclinadas /\n    float sdcaDer= sdCapsule( p-vec3(0.0,0.5,-4.2), aDer, bDer, r0Der, r1Der );\n    float sdcaIzq= sdCapsule( p-vec3(0.0,0.5,-4.2), aIzq, bIzq, r0Izq, r1Izq );\n    \n    float sdsp1= sdSphere(p- vec3(0.5,0.45,-4.0), 0.35 );\n    float sdsp2= sdSphere(p-vec3(-0.5,0.45,-4.0), 0.35 );\n\t\n    float k=0.12;\n    float sdU= smin( sdca1, sdca2, k );  //unir 2 lobulos\n    sdU= smin( sdU, sdcaDer, k );  //unir capsulas inclinadas\n    sdU= smin( sdU, sdcaIzq, k );  //unir capsulas inclinadas\n    \n    \n    sdU= smin( sdU, sdsp1, k );\n    sdU= smin( sdU, sdsp2, k );\n    \n    return sdU;\n    \n}\n\nvec2 HacerOjoyCorneaII(vec3 p)\n{   \n    float la=0.5;\n    float lb=0.8;\n    float h=2.0;\n    float ra=0.45;\n   \n    vec2 res=vec2(9999.0,-1.0);\n    \n     \n    float OjoSeparacion=2.1;\n    float OjoIzq= sdEllipsoid(p- vec3(OjoSeparacion,1.5,-5.0), vec3(1.8,0.8,1.8));\n    float OjoDer= sdEllipsoid(p-vec3(-OjoSeparacion,1.5,-5.0), vec3(1.8,0.8,1.8));\n    \n    float IrisSeparacion=2.5;\n    float moverIris=0.0;//0.5*sin(iTime);\n    float IrisIzq= sdEllipsoid(p- vec3(IrisSeparacion+moverIris,1.5,-6.5), vec3(0.5,0.5,0.5));\n    float IrisDer= sdEllipsoid(p-vec3(-IrisSeparacion+moverIris,1.5,-6.5), vec3(0.5,0.5,0.5));\n    \n    float  sU= unionSDF(OjoIzq, OjoDer);\n\n    //restar Iris hoyo\n\tsU= differenceSDF(sU, IrisIzq);\n    sU= differenceSDF(sU, IrisDer);\n    //sumar Iris hoyo\n    \n    float InterOjoIrisIzq=intersectSDF(OjoIzq,IrisIzq);\n    float InterOjoIrisDer=intersectSDF(OjoDer,IrisDer);\n    \n    res=opU(res, vec2(sU,1.0));\n    \n    res=opU(res, vec2(InterOjoIrisIzq,0.0));\n    res=opU(res, vec2(InterOjoIrisDer,0.0));\n    \n    return res;\n  \n}   \n\nfloat Labios(vec3 p,float pDistCabeza )\n{\n    //labio superior\n   \tvec3 aA1=vec3(1.0,1.0,0.1);\n    vec3 bA1=vec3(2.0,1.1,0.0); \n    float r0A1=0.1;\n    float r1A1=0.3;\n    \n    vec3 aB1=vec3(-1.0,1.0,0.1);\n    vec3 bB1=vec3(-2.0,1.1,0.0); \n    float r0B1=0.1;\n    float r1B1=0.3;\n    \n    \n    //labio inferior\n   \tvec3 aA2=vec3(1.0,1.1,0.1);\n    vec3 bA2=vec3(2.0,1.0,0.0); \n    float r0A2=0.1;\n    float r1A2=0.3;\n    \n    vec3 aB2=vec3(-1.0,1.1,0.1);\n    vec3 bB2=vec3(-2.0,1.0,0.0); \n    float r0B2=0.1;\n    float r1B2=0.3;\n    \n    \n    ///superior labio\n    float sdca1A= sdCapsule( p-vec3(-2.2,0.0,0.0), aA1, bA1, r0A1, r1A1 );\n    float sdca2A= sdCapsule( p-vec3(2.2,0.0,0.0), aB1, bB1, r0B1, r1B1 );\n   ///inferior labio\n\tfloat sdca1B= sdCapsule( p-vec3(-2.2,-0.2,0.0), aA2, bA2, r0A2, r1A2 );\n    float sdca2B= sdCapsule( p- vec3(2.2,-0.2,0.0), aB2, bB2, r0B2, r1B2 );\n    \n    \n    float k=0.12;\n    float sdU1= smin( sdca1A, sdca2A, k );  //unir labios\n    float sdU2= smin( sdca1B, sdca2B, k );\n    \n\tfloat sUTdo= unionSDF(sdU1, sdU2);\n    \n    return sUTdo;\n    \n}\n//------------------------------------\nfloat pelo( vec3 p)\n{\n    float  spelo= sdCylinderXZ(p-vec3(0.0,0.0,0.0), vec2(8.0,1.5) );\n    return spelo+cos(p.z*0.3)*cos((p.x/0.2*p.z*0.35))*p.y*0.12;\n    \n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\t\n    p.y=p.y-10.0;\n\t\n    float  sdcabeza= sdCylinderXZ(p-vec3(0.0,0.0,0.0), vec2(7.0,7.0) );\n\tfloat  sdcabezaFrente= sdCylinderXZ(p-vec3(0.0,5.0,-1.5), vec2(6.0,2.0) );\n    // Unir cabeza y frente\n    \n\n    sdcabeza= smin( sdcabeza, sdcabezaFrente, 0.4 );\n    \n    \n    vec3 pr1= rotate_z(p-vec3(0.0,0.0-3.0,0.0), radians(45.0));\n    pr1= rotate_x(pr1-vec3(0.0,0.0,0.0), radians(15.0));\n    \n    vec3 pr2= rotate_z(p-vec3(-7.0,-7.0-3.0,0.0), radians(45.0+90.0));\n    pr2= rotate_x(pr2-vec3(0.0,0.0,0.0), radians(180.0-15.0));\n    \n    vec3 pr3= rotate_x(p-vec3(0.0,0.0-3.0,0.0), radians(20.0));\n    \n    float sdb1= sdBox(pr1- vec3(5.0,0.0,1.0), vec3(3.0,8.0,8.0) );\n    float sdb2= sdBox(pr2-vec3(-5.0,0.0,1.0), vec3(3.0,8.0,8.0) );\n    float sdb3= sdBox(pr3-vec3(0.0,-1.5,0.0), vec3(10.0,4.5,10.0) );\n    \n    sdcabeza=differenceSDF(sdcabeza, sdb1);\n    sdcabeza=differenceSDF(sdcabeza, sdb2);\n    sdcabeza=differenceSDF(sdcabeza, sdb3);\n    sdcabeza=smin(sdcabeza, sdcabeza,0.4);\n    \n    \n    \n    float HoyoSeparacion=2.2;\n    float HoyoOjoIzq= sdEllipsoid(p- vec3(HoyoSeparacion,1.5,-5.5), vec3(2.0,1.0,2.0));\n    float HoyoOjoDer= sdEllipsoid(p-vec3(-HoyoSeparacion,1.5,-5.5), vec3(2.0,1.0,2.0));\n    \n    //restar hoyos de Cabeza\n\t sdcabeza=differenceSDF(sdcabeza, HoyoOjoIzq);\n     sdcabeza=differenceSDF(sdcabeza, HoyoOjoDer);\n    \n   \n    float slabios= Labios( p-vec3(0.0,-2.5,-7.3), sdcabeza );\n    res =opU3(res, vec3(slabios,2,-1));\n    \n    vec2 rOjo= HacerOjoyCorneaII(p);\n   \n    float sNariz= NarizB(p-vec3(0.0,-0.5,-3.5),sdcabeza );\n\t\n    \n    //UNir cabeza con nariz\n    sdcabeza= smin( sdcabeza, sNariz, 0.4 );\n    res =opU3(res, vec3(sdcabeza,16.0,MATERIAL_NO));   \n   \n    \n    float spelo= pelo( p- vec3(0.0,6.0,0.0));\n    spelo=smin(spelo, spelo,0.6);\n    \n        \n    res =opU3(res, vec3(spelo,32.0,MATERIAL_NO));   \n        \n    res =opU3(res, vec3(rOjo.x,rOjo.y,MATERIAL_NO));   \n    \n    float sCuello=sdCylinderXZ(p- vec3(0.0,-2.0,0.0), vec2(3.0,3.5));\n    float sbCuerpo= sdBox(p- vec3(0.0,-12.0,0.0), vec3(10.0,8.0,2.7) );\n    \n    \n    res =opU3(res, vec3(sbCuerpo,10.0,MATERIAL_NO));   \n    res =opU3(res, vec3(sCuello,16.0,MATERIAL_NO));   \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n\n    \n    return colobj;\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 8.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\nif(i== 32 ){ return vec3(1.0,0.5,0.2);}\n\n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 340, 340, 361], [362, 362, 394, 394, 478], [479, 479, 525, 525, 612], [614, 614, 653, 653, 748], [749, 749, 788, 788, 883], [884, 884, 923, 923, 1018], [1020, 1064, 1111, 1111, 1138], [1140, 1140, 1183, 1183, 1210], [1212, 1212, 1260, 1260, 1288], [1289, 1373, 1412, 1412, 1456], [1457, 1457, 1496, 1496, 1540], [1541, 1541, 1573, 1573, 1598], [1599, 1664, 1698, 1698, 1796], [1797, 1797, 1831, 1831, 1923], [1924, 1924, 1958, 1958, 2050], [2051, 2091, 2125, 2125, 2222], [2259, 2259, 2300, 2300, 2393], [2395, 2395, 2432, 2432, 2515], [2517, 2517, 2594, 2594, 2729], [2731, 2731, 2772, 2772, 4300], [4302, 4302, 4334, 4334, 5354], [5359, 5359, 5400, 5421, 6437], [6438, 6477, 6498, 6498, 6638], [6639, 6679, 6704, 6704, 9064], [9066, 9111, 9178, 9178, 9546], [9547, 9598, 9622, 9622, 9810], [9811, 9874, 9907, 9907, 10349], [10351, 10405, 10441, 10441, 10675], [10676, 10811, 10891, 10891, 11503], [11504, 11545, 11638, 11638, 11749], [11750, 11799, 11856, 11856, 13852]]}
{"id": "wdcyRS", "name": "Audio Channel test", "author": "itgaz", "description": "Test area for audio channels behaviour, to help me write a desktop shadertoy application", "tags": ["audio"], "likes": 3, "viewed": 516, "published": 3, "date": "1601131200", "time_retrieved": "2024-07-30T20:43:20.569863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n#define FFT 1\n#if FFT\n    // FFT Value is stored in red channel, at y == 0.25\n    // x represents the FFT bucket, so a basic spectrum display is just x,0.25 + cutoff\n    vec4 channel0FFT = texture(iChannel0, vec2(uv.x, 0.25));\n    \n    if( uv.y > channel0FFT.r ) {\n      fragColor = vec4(0.0,0.0,0.0,1.0); //vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n    } else {\n      fragColor = channel0FFT;\n    }\n#else\n    // Amplitude is stored in red channel, at y == 0.75\n    // x represents time, seems to roughly be last frame time <= x <= current frame time?\n    // (TODO) I believe each X pixel is a single sample from the input, so the texture may not\n    // contain a whole frame worth of audio\n    vec4 channel0Amplitude = texture(iChannel0, vec2(uv.x, 0.75));\n    \n    if( abs(0.5 - uv.y) > channel0Amplitude.r * 0.5 ) {\n    \tfragColor = vec4(0.0,0.0,0.0,1.0); //vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n    } else {\n    \tfragColor = channel0Amplitude;\n    }\n    \n#endif\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1149]]}
{"id": "3s3cWr", "name": "CA Molecular dynamics", "author": "michael0884", "description": "Implementing perfect particle number conservation with cellular automaton particle tracking\nTook me some time to realize that the edge conditions in the step functions actually had a large effect, thus there are 2 Heaviside step functions here. ", "tags": ["particles", "ca"], "likes": 52, "viewed": 1886, "published": 3, "date": "1601129713", "time_retrieved": "2024-07-30T20:43:21.615069", "image_code": "// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n   vel /= rho;\n   vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n   col.xyz = cos(0.9*vec3(3,2,1)*rho) + 0.*vc;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 0.5\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//Wyatt thermostat\n#define cooling 1.5\n\n//MD force\nfloat MF(vec2 dx)\n{\n    return -GS(0.75*dx) + 0.13*GS(0.4*dx);\n}\n\n\n//the step functions need to be exactly like this!! step(x,0) does not work!\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\n//particle grid\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tint M0 = int(data.z);\n        int M0H = M0/2;\n        \n        X0 += V0*dt; //integrate position\n        \n        //the deposited mass into this cell\n        vec3 m = (M0 >= 2)?\n            (float(M0H)*PD(X0+vec2(0.5, 0.0), pos) + float(M0 - M0H)*PD(X0-vec2(0.5, 0.0), pos))\n            :(float(M0)*PD(X0, pos)); \n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = Ha(pos - (R*0.5 - R.x*0.15))*Hb((R*0.5 + R.x*0.15) - pos);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.49, 0.49)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 Fa = vec2(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n           \n            Fa += M0*MF(dx)*dx;\n        }\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F -= 0.003*dx*GS(dx/30.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += (F + Fa)*dt/M;\n        \n        //Wyatt thermostat\n        X += cooling*Fa*dt/M;\n        \n        vec3 BORD = bN(X);\n        V += 0.5*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 333, 333, 511], [539, 539, 567, 567, 627]]}
{"id": "3dcyzS", "name": "Raymarching Pebbles - shortened", "author": "FabriceNeyret2", "description": "shortening athibaul's [url]https://shadertoy.com/view/wlsBRX[/url]\nJust raymarching a scene with pebbles, for fun and for learning about microfacet-based BRDFs.\n\nparallax-less: 596 chars here : [url]https://www.shadertoy.com/view/3scyRB[/url]\n", "tags": ["raymarching", "texture", "heightmap", "stone"], "likes": 27, "viewed": 812, "published": 3, "date": "1601102981", "time_retrieved": "2024-07-30T20:43:22.604423", "image_code": "// shortened \"Raymarching Pebbles\" (1661 chars) by athibaul. https://shadertoy.com/view/wlsBRX\n\n#define H(p)      texture( iChannel0, (p).xy )\n#define H1(p)     texture( iChannel1, (p).xy )\n#define H2(p)   ( H(p) + .08*H1(p)  ).r\n#define map(p)  ( 1. - (p).z - .1* H2(p)  )\n\n#define C(p,d)             /* curvature */    \\\n  4.*( textureLod(iChannel0, (p).xy, log2(2.5*d*512.)) - H(p) ).r\n\n#define AO(p) clamp(1. - C(p, .003) *8.       \\\n                       - C(p, .02 ) *.7       \\\n                       - C(p, .1  ) *.3,      \\\n                    0., 1. )\n\nvec2 e = vec2(.001, -.001);\n#define N( p )   /* IQ Tetrahedral normal */  \\\n    normalize( e.xyy * map(p + e.xyy) +       \\\n               e.yyx * map(p + e.yyx) +       \\\n               e.yxy * map(p + e.yxy) +       \\\n               e.xxx * map(p + e.xxx)   )\n\nvec3 h;\n#define specular( l, N, v, ap, f0)            \\\n  (  h = normalize(l+v),                      \\\n       (ap+2.)/6.28 *pow(dot(N, h), ap)       \\\n      / dot(l,h)                              \\\n      * f0  ) // ( f0 + (1.-f0)*pow(max(0.,1.-dot(l,h)),5.) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float t = iTime, d, l;\n\n    vec3 p = vec3( t*.1, .2*cos(t*.5), 0 ), N,      // initial pos\n         L = p + .3* vec3( cos(t*3.), sin(t), -1 ), // light dir\n         D = normalize( vec3(u+u - R, 3.*R.y) );    // ray dir\n    D.xy  *= mat2(cos( cos(t*.2) + vec4(0,33,11,0)));    \n\n    for(int j=0; j<32; j++){            // --- raymarch heightMap surface\n        d = map(p);\n        if(d < .001) break; \n        p += d*.3*D;\n    }\n    N = N(p); l = length( L -= p );     // --- shading\n    O = AO(p) * (   2.5* H1(p) * dot(L,N) / (l*l*l)    // diffuse\n                  +  .2* specular(-D, N, L/l, 60., .2) // specular\n                );\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1092, 1092, 1130, 1130, 1801]]}
{"id": "WsccRS", "name": "Vector field swirling", "author": "Plento", "description": "Drawing a vector field in buf b based on mouse movement and sampling buf A using buf B as offset. Also using the average of neighbors to let the colors mix. ", "tags": ["2d", "mouse", "texture", "fluid", "vectorfield"], "likes": 13, "viewed": 517, "published": 3, "date": "1601098496", "time_retrieved": "2024-07-30T20:43:23.540919", "image_code": "// Use the mouse to draw a vector field that the colors will follow.\n// Looks pretty fluid like but is defiantly missing something big\n\n#define ShowField\n\nfloat grid(vec2 uv, float sc){\n    vec2 rv = fract(uv*sc)-.5;\n    vec2 dir = Bt((floor(uv*sc) / sc) + .5*(1. / sc)).xy;\n    float x = abs(dot(rv.yx*vec2(-1.,1.), normalize(dir)));\n    return exp(-300.*x*x);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n  \tf = texture(iChannel0, u/R);\n    \n    #ifdef ShowField\n    f += grid(u/R, 40.) * .3;\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Sample bufA using the vector field in bufB as texture offset and add new color\n\n#define og(u) A(0.5*(u-R*.5) + vec2(textureSize(iChannel0, 0))*.5)\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n   \n    vec4 bA = B(u);\n    \n    vec4 N = B(u+vec2(0., 2.));\n\tvec4 S = B(u+vec2(0., -2.));\n\tvec4 E = B(u+vec2(2., 0.));\n\tvec4 W = B(u+vec2(-2., 0.));\n    vec4 avg = (N+S+E+W)/4.;\n    \n    vec4 bB = D(u);\n    vec4 new = B(u - bB.xy*4.);\n    bA = (new+avg)*.5;\n   \n    \n    if(iMouse.z > 0.){\n        if(bA.w > 5.){\n        \tfloat dec = ss(3., .0, line(u, m, C(u).xy)-20.);\n            bA.xyz = mix(bA.xyz, .5+.5*vec3(cos(vec3(0.2, 0.5, 1.5)*iTime*8.)),dec);\n        }\n        bA.w++;\n    }\n    else{\n     \tbA.w = 0.;   \n    }\n        \n    \n    if(iFrame < 5){\n        bA = vec4(0);\n    }\n    f = bA;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Makes a vector field based on mouse movement direction\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 bB = A(u);\n   \n    if(iMouse.z > 0.){\n    \tvec2 mdx = clamp((B(u).xy - m), -60., 60.);\n    \tfloat dec = exp(-length(m - u)*.07)*0.0055;\n    \tbB.xy -= (mdx)*dec *100.;\n    }\n    \n    bB.xy=clamp(bB.xy, -1., 1.);\n    f = vec4(bB.xy, bB.zw);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Used as mouse last position\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(iMouse.xy, 0.,1.0);\n}", "buffer_d_inputs": [], "common_code": "#define R iResolution.xy\n#define m iMouse.xy\n\n#define A(p) texelFetch(iChannel0,  ivec2(p), 0)\n#define B(p) texelFetch(iChannel1,  ivec2(p), 0)\n#define C(p) texelFetch(iChannel2,  ivec2(p), 0)\n#define D(p) texelFetch(iChannel3,  ivec2(p), 0)\n\n#define Bt(p) texture(iChannel1, p)\n\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsccRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 185, 185, 363], [365, 365, 405, 405, 506]]}
{"id": "WdccRS", "name": "sub- 2x2 block dFdx dFdy - 2", "author": "FabriceNeyret2", "description": "scholarius suggests that hardware derivatives are evaluated differently on D3D vs OpenGL within 2x2 pixels blocks. this is a test of it, computing dFdxy(diag%n) with n = 2,3,4 from bot to top\nOpenGL/nVidia result: see forum.\nIf you comment give system/gpu", "tags": ["glsl"], "likes": 2, "viewed": 781, "published": 3, "date": "1601096328", "time_retrieved": "2024-07-30T20:43:24.386658", "image_code": "// variant of \"sub- 2x2 block dFdx dFdy\" https://shadertoy.com/view/WddcW7\n\n// warps are generally 4x8 pixels blocks. \n// But a more fundamental GPU organization is the 2x2 block, \n// used for various things, including hardware derivatives \n// ( used to estimate LOD, for instance ).\n// scholarius suggests that hardware derivatives are evaluated differently on D3D vs OpenGL\n// this is a test of it.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    float i = 2.+floor(3.*U.y/R.y);  // bottom: %2 = sub-block alternance. then %3, %4\n    vec2 V = mod(U.xy+U.yx-.5,vec2(i));\n    O = .5+.5*vec4( U.x < R.x/2. ? dFdx(V) : dFdy(V) ,0,1) / (i-1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdccRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 440, 440, 668]]}
{"id": "tstcD7", "name": "Fractal Sky #2", "author": "NivBehar", "description": "fractals", "tags": ["mandelbrot", "fractals"], "likes": 3, "viewed": 232, "published": 3, "date": "1601079691", "time_retrieved": "2024-07-30T20:43:25.266306", "image_code": "#define ITERATIONS 150\n#define COLOR_REPEAT 0.6\n#define MANDELBROT_SHADE 2072.\n#define time iTime\n#define HEX_DIST 1.\n#define HAIR_DIST 21.\n#define PI 3.141592654\n#define _DotsSize 0.213\n#define _DotsSmoothness 0.221\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nvec3 iterate(vec2 UV , float distance_type)\n{\n    //cool shit: https://www.shadertoy.com/view/wdBfDK\n    //UV = _MandelbrotArea.xy + (UV-0.5)*_MandelbrotArea.zw;\n    //UV = rot(UV, _MandelbrotArea.xy, _MandelbrotAngle);\n\n    vec3 col;\n\n    float dots_dist = 1e20f;\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float[1] shapes;\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n        //float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n    vec2 shape;\n    shape = vec2(0.285, 0.0103);\n    //shape = float2(_fractal_shape_a, _fractal_shape_b);\n    //if(shape.x == 0 && shape.y == 0)\n    //    shape = z;\n    vec2 prev_z;\n    vec2 z_dots;\n    vec4 z_hc;\n    float dist_from_mandelbrot = 1e20f;\n    float r = 20.;\n\n    vec2 hc2;\n    int i = 0;\n    for(i = 0; i<ITERATIONS; i++ )\n    {\n        prev_z = z;\n        if(distance_type == HEX_DIST)\n        {\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 1. + 10.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n        }\n        if(distance_type == HAIR_DIST)\n        {   \n            //vec2 z1 = 13.*z/dot(z,z+0.1*sin(z));\n            //z1 +=time;\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(100.,3.2));\n            //float r2 = 5 + 15*TriangleDist(sin(cos(z2*PI+time*1)*0.5 + 5)*cos(cos(z2*PI)), float2(50,-0.6));\n            //r = lerp(r,r2, 0.4 + 0.4*sin(time));\n            //r = 5+TriangleDist(z*3, float2(_test1,_test2));\n        }\n\n        //r = HexCoords(0.5 + 0.25*sin(cos(z*2 + time)*0.1)*cos(cos(z*3) + 0.25*sin(cos(prev_z*2)) )).y*10;\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n        //float z_hash = N22(z);\n        if(length(z) > r)\n            //if(dot(z, prev_z) > r)\n            break;\n        //return 0.0;\n\n\n        z_dots = z + rot(z,prev_z,time*0.2);\n        z_dots = vec2(HexDist(z_dots));\n        z_hc = HexCoords(z_dots);\n\n        //z_dots = pMod2(z_dots,4);\n\n        dots_dist = min( dots_dist, dot(z_dots,z_dots) );\n        //dots_dist = min( dots_dist, dot(z_hc.x,z_hc.y) );\n        dist_from_mandelbrot = min(dist_from_mandelbrot, dot(z,z));\n\n        //hc2 = min(hc2, HexCoords(prev_z).xy);\n    }\n\n    if(i >= ITERATIONS)\n        return vec3(0.);\n\n    float fraciter = log2( log(length(z)) / log(r) );\n    float j = float(i);\n    //j -= fraciter;\n\n    //float2 hc = HexCoords(dots_dist).xy;\n\n    //col = smoothstep(0,dist, sin(hc.y*15)*cos(hc.y*15));\n    //float dots_size = 1;\n    //float dots_smoothness = 0.9;\n    float dots = smoothstep(_DotsSize - _DotsSmoothness, _DotsSize, dots_dist);\n    //dots = smoothstep(0.9, 1, dots_dist);\n    dots = clamp(0.,1.,dots);\n\n    //col = smoothstep(0,dist, );\n    //float3 tex = tex2D(_MainTex, hc2);\n    //col = tex;\n    //col = dots;\n\n    vec3 beat = vec3(time*0.4);//(_smooth_bass2 + _smooth_mid2 + _smooth_treb2)*0.001 + (_bass2 + _mid2 + _treb2)*0.003;\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 c1 = beat; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 c2 = vec3(1.0, 1.0, 0.5); // animate \\ offset\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 c3 = vec3(0., 0., 0.); // animate \\ offset\n    vec3 d3 = vec3(0., 0., 0.);\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0); // animate \\ offset\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 a5 = vec3(0.3, 0.27, 0.5);\n    vec3 b5 = vec3(0.9, 0.45, 0.75);\n    vec3 c5 = vec3(beat); // animate \\ offset\n    vec3 d5 = vec3(.8, 0.9, 0.25);\n    \n    // Color choise\n    //vec3 a = mix(a1, a2, 0.*time*0.02);\n    //vec3 b = mix(b1, b2, 0.*time*0.02);\n    //vec3 c = mix(c1, c2, 0.*time*0.02);\n    //vec3 d = mix(d1, d2, 0.*time*0.02);\n\n    vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d1 + c1));\n    vec3 col2 = a2 + b2 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d2 + time*0.2));\n    vec3 col3 = a3 + b3 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d3 + c3 ));\n    vec3 col4 = a4 + b4 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d4 + c4));\n    vec3 col5 = a5 + b5 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d5 + c5));\n\tvec3 col6 = mix(col1, col5, abs(col1-col5));\n    col = col1;\n    \n    \n    //col = mix(col1, col4, 0.5 + 0.5*sin(float(i)));\n    //col = vec3(clamp(0.,1.,fraciter));\n    //col = mix(col, col2, fraciter);\n    //col = col2;\n    //col = vec3(dist_from_mandelbrot);\n\n    dist_from_mandelbrot = smoothstep(0., j/(MANDELBROT_SHADE), dist_from_mandelbrot);\n    //dist_from_mandelbrot = smoothstep(0, (_MandelbrotArea.z)*0.1, dist_from_mandelbrot); // shade depends on the zoom \n\n    dist_from_mandelbrot = clamp(0.,1.,dist_from_mandelbrot);\n\n    if(distance_type == HEX_DIST)\n    {\n        float leaves = smoothstep(0.,0.7,fraciter);\n        float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        col *= leaves;\n        //col += leaves_edges;\n        //col *= dist_from_mandelbrot;\n\n    }\n    if(distance_type == HAIR_DIST)\n    {\n        float hair = smoothstep(0.,1.5,fraciter);\n        float hair_edges = smoothstep(0.18,0.,fraciter);\n        float hair_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //hair_edges *= hair_edges_tips; // to avoid pxieli edges of the hairs\n        col *= hair;\n        //col += hair_edges;\n\n        // add dots\n        //col *= (dist_from_mandelbrot);\n\n        //float id = j;\n        //float hash = N11(id + floor(-time*2));\n        //col += 0.1*(1-dist_from_mandelbrot) * (col3);\n        //col = col3;\n    }\n\n\n\n    //col = hash+0.1;\n\n\n    //col *= hair_edges2*dist_from_mandelbrot;\n    //col = col4;\n    //col = fraciter;\n\n    //col *= dots;\n    //col += (1-dots)*dist_from_mandelbrot*col3;\n    //col *= smoothstep(0.8,0.,fraciter);\n    //col = dots;\n    //col = fraciter;\n    //col = 1-dots;\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;// = fragCoord/iResolution.xy;\n    \n    float zoom = 3.;\n\n    //uv += 0.4;\n    //uv = 0.7*uv/dot(uv,uv);\n    //uv += vec2(cos(0.1*iTime), sin(0.1*iTime));\n\n    #if 1\n    int AA = 2;\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\t   col += iterate( uv, HAIR_DIST );\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n\tvec3 col = iterate(uv, HAIR_DIST);\n    \n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 257, 257, 395], [396, 396, 419, 419, 521], [522, 522, 548, 548, 819], [820, 820, 857, 857, 1148], [1149, 1149, 1194, 1368, 7642], [7643, 7643, 7700, 7750, 8522]]}
{"id": "tstyD7", "name": "Pincushion Effect", "author": "oneshade", "description": "This is what I came up with to produce a pincushion effect. Prepare to laugh your head off.", "tags": ["distortion", "effect", "pincushion"], "likes": 3, "viewed": 254, "published": 3, "date": "1601076789", "time_retrieved": "2024-07-30T20:43:26.247682", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    fragCoord -= halfResolution;\n    vec2 uv = (normalize(fragCoord) * pow(length(fragCoord) * 0.1, 2.0) + halfResolution) / iResolution.xy;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {\n        color = texture(iChannel0, uv).xyz;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 436]]}
{"id": "tddyW7", "name": "Woodcut 2", "author": "FabriceNeyret2", "description": "variant of \"Woodcut\" by Krabcode. [url]https://shadertoy.com/view/wstcDM[/url]\nusing bump map and shading.", "tags": ["textures", "wood", "london"], "likes": 9, "viewed": 482, "published": 3, "date": "1601068983", "time_retrieved": "2024-07-30T20:43:27.217090", "image_code": "// variant of \"Woodcut\" by Krabcode. https://shadertoy.com/view/wstcDM\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec4 wood = texture(iChannel0, U/R);\n    float   l = length(textureLod(iChannel1, U/R, 1.).rgb),\n          cut = smoothstep(1., 0., l),\n         illu = dot( vec2(dFdx(cut),dFdy(cut)) *R.y/100.,\n                     cos(iTime+vec2(0,11)));\n    O = wood * ( 1.-.5*illu - .2*cut );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 424]]}
{"id": "Wtf3Rs", "name": "curvy cross", "author": "abje", "description": "an sdf, a combination of spheres and a box", "tags": ["sdf", "distance", "cross", "exact"], "likes": 3, "viewed": 310, "published": 3, "date": "1601068687", "time_retrieved": "2024-07-30T20:43:28.230381", "image_code": "float pin(vec2 p, float h, float r0, float r1) {\n    \n    p = abs(p);\n    \n    if (p.x > p.y) p = p.yx;\n    \n    vec2 q;\n    \n    vec2 b = vec2(r0,0);\n    q = p-b;\n    float pin = -length(q)+r1;\n    \n    vec2 a = vec2(r0-sqrt(r1*r1-h*h),h);\n    \n    \n    q = p-a;\n    \n    \n    vec2 c = a-b;\n    c = vec2(c.y,-c.x);\n    float f = min(q.x,dot(q,c));\n    if (f > 0.0) {\n        // corners\n        pin = length(q);\n    }\n    \n    float r = r0/sqrt(2.0);\n    float e = r0*0.5-sqrt((r1*r1-r*r))*sqrt(0.5);\n    \n    c = p-b;\n    c = vec2(c.y,-c.x);\n    \n    float d = dot(p-e,c);\n    \n    if (d < 0.0) {\n        pin = -length(p-e);\n    }\n    \n    // outer box\n    pin = max(pin,p.y-h);\n    \n    return pin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 2.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float aa = iResolution.y/scale*0.4;\n    \n    float len = 10000.0;\n    \n    len = min(pin(uv, 0.9+sin(iTime)*0.1,1.8+sin(iTime*0.89)*0.1,1.6+sin(iTime*0.97)*0.1),len);\n    \n    vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-2.0*abs(len));\n    col *= 0.8 + 0.2*cos(120.0*abs(len));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,1.0/aa,abs(len)) );\n    \n    //vec2 a = fract(uv*5.0);\n    //col += max(max(a.x,a.y)-0.8,0.0)*5.0;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 702], [704, 704, 761, 811, 1426]]}
{"id": "wdtyDM", "name": "Joukowsky inv transform: airfoil", "author": "FabriceNeyret2", "description": "transform of a circle trough Joukowsky transform gives an airfoil.\nMouse: move center. grey = radius.\ncf [url]https://www.desmos.com/calculator/nrq1ecest1?lang=fr[/url]\n", "tags": ["complex", "transform", "airfoil", "joukowsky"], "likes": 14, "viewed": 411, "published": 3, "date": "1601064703", "time_retrieved": "2024-07-30T20:43:29.247661", "image_code": "// inverse of https://shadertoy.com/view/tsdyWM\n\n// complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n//#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n#define sat(x) clamp(x,0.,1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.*( 2.*u - R ) / R.y,\n         M = iMouse.xy==vec2(0) ? vec2(-.1,.7)\n           : ( 2.*iMouse.xy - R ) / R.y,\n         V1 = .5*( U + cpow( cmul(U,U) - 4., .5) ),    // z² - Z.z + 1 = 0 (  Z = z + 1/z )\n         V2 = U-V1;           \n    O = texture(iChannel0,.5+.5*V1);                     // texture\n  //M = mod(floor(V1)+4.,8.)-4.;\n    for( float r = 3.; r > 0.; r-=.5)\n    O = mix(O, vec4(r/3.),   sat(1.-R.y/4.*(length(M-V1)-r)) \n                           * sat(1.-R.y/4.*(length(M-V2)-r)) );\n    V1 += .1*iTime; V2 += .1*iTime;\n    V1 = abs(fract(V1)-.5) / fwidth(V1);                   // grid\n    V2 = abs(fract(V2)-.5) / fwidth(V2);                   // second grid\n    O = mix(O, vec4(1, 0,0,1), max(0.,1.-min(V1.x,V1.y)) );\n    O = mix(O, vec4(0,.8,0,1), max(0.,1.-min(V2.x,V2.y)) );\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[766, 766, 804, 804, 1645]]}
{"id": "tsdyWM", "name": "Joukowsky transform", "author": "FabriceNeyret2", "description": ".", "tags": ["complex", "transform", "joukowsky"], "likes": 11, "viewed": 359, "published": 3, "date": "1601060986", "time_retrieved": "2024-07-30T20:43:30.368665", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n      // M = ( 2.*iMouse.xy - R ) / R.y,\n         V = U* ( 1. + (vec2(1,-1)/dot(U,U) ) )         // Z = z + 1/z\n           + .1*iTime;\n    O = texture(iChannel0,.5+.5*V);                     // texture\n // O = mix(O, vec4(0,0,1,1), max(0.,1.-R.y/4.*abs(length(V-vec2(.5,.1))-1.5)) );\n    V = abs(fract(V)-.5) / fwidth(V);                   // grid\n    O = mix(O, vec4(1, 0,0,1), max(0.,1.-V.x) * min(1.,4.*length(U)) );\n    O = mix(O, vec4(0,.8,0,1), max(0.,1.-V.y) * min(1.,4.*length(U)) );\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 594]]}
{"id": "WddcW7", "name": "sub- 2x2 block dFdx dFdy", "author": "FabriceNeyret2", "description": "scholarius suggests that hardware derivatives are evaluated differently on D3D vs OpenGL within 2x2 pixels blocks. this is a test of it, computing dFdxy(u%n) with n = 2,3,4 from bottom yo top\nOpenGL/nVidia result: see forum.\nIf you comment give system/gpu", "tags": ["glsl"], "likes": 2, "viewed": 548, "published": 3, "date": "1601050189", "time_retrieved": "2024-07-30T20:43:31.170520", "image_code": "// warps are generally 4x8 pixels blocks. \n// But a more fundamental GPU organization is the 2x2 block, \n// used for various things, including hardware derivatives \n// ( used to estimate LOD, for instance ).\n// scholarius suggests that hardware derivatives are evaluated differently on D3D vs OpenGL\n// this is a test of it.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    float i = 2.+floor(3.*U.y/R.y);  // bottom: %2 = sub-block alternance. then %3, %4\n    vec2 V = mod(U-.5,vec2(i));\n    O = .5+.5*vec4( U.x < R.x/2. ? dFdx(V) : dFdy(V) ,0,1) / (i-1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 364, 364, 584]]}
{"id": "tddcD4", "name": "Ambient Occlusion Display", "author": "flockaroo", "description": "(mis)using ambient occlusion to show video content...\n...this surely will supersede LCD and LED technology ;-)", "tags": ["shadow", "effect", "ao", "ambientocclusion"], "likes": 12, "viewed": 553, "published": 3, "date": "1601041383", "time_retrieved": "2024-07-30T20:43:32.231683", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// shadow/occlusion display\n//\n// ...(mis)using ambient occlusion to show video content...\n//\n#define SHADOW\n#define GREENSCREEN\n#define PERIODIC\n//#define CLAMP\n\n#ifndef SHADEROO\n#define CUBEMAP\n#endif\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nfloat WireRadius=0.05;\nfloat Angle=0.;\n\n// iq's line distance\nfloat lineDist( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat getVal(vec2 p)\n{\n    vec2 uv=p*7./Res0+.5;\n    vec2 uv0=uv;\n#ifdef PERIODIC\n    uv=fract(uv);\n#endif\n    vec3 c=texture(iChannel0,uv).xyz;\n#ifdef GREENSCREEN\n   \tc=mix(c,vec3(0),dot(c,vec3(-1,2,-1)));\n#endif\n    float h=dot(c,vec3(.333))*1.5;\n    vec2 bstep=step(.5,abs(uv0-.5));\n    float b=max(bstep.x,bstep.y);\n#ifndef PERIODIC\n    h*=1.-b;\n#endif\n    h=clamp(h,0.,10.);\n#ifdef CLAMP\n    h-=2.*b;\n#endif\n    return h;\n}\n\n#define CS(x) cos(x+vec2(0,-PI*.5))\n\nvoid getTri(vec2 p, inout vec2 p1, inout vec2 p2, inout vec2 p3)\n{\n    mat2 m=mat2(CS(Angle),CS(Angle+60.*PI/180.));\n    vec2 q=inverse(m)*p;\n    vec2 qfr=fract(q);\n    p1=m*floor(q);\n    p2=p1+m*vec2(1,0);\n    p3=p1+m*vec2(0,1);\n    if(qfr.x+qfr.y>1.) p1+=m*vec2(1,1);\n}\n\nfloat distFloor(vec3 pos)\n{\n    vec4 r=textureLod(iChannel1,pos.xy*.2,0.);\n    float d=pos.z+WireRadius+.007+(r.x-.5)*.015;\n    return d;\n}\n\nfloat distGrid(vec3 pos)\n{\n    vec3 p1,p2,p3;\n    vec2 p10,p20,p30;\n    getTri(pos.xy,p10,p20,p30);\n    p1=vec3(p10,getVal(p10));\n    p2=vec3(p20,getVal(p20));\n    p3=vec3(p30,getVal(p30));\n    float d=10000.;\n    d=min(d,lineDist(pos,p1,p2)-WireRadius);\n    d=min(d,lineDist(pos,p2,p3)-WireRadius);\n    d=min(d,lineDist(pos,p3,p1)-WireRadius);\n    return d;\n}\n\nfloat dist(vec3 pos)\n{\n    float d=10000.;\n    d=min(d,distFloor(pos));\n    d=min(d,distGrid(pos));\n    return d;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<eps) return 0.;\n    }\n    return 1.0;\n}\n\nfloat marchUntilSmaller(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    float dp=dist(pos);\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<dp) return d;\n        dp=d;\n    }\n    return 1.0;\n}\n\nfloat marchUntil(inout vec3 pos, vec3 dir, float maxDist, inout vec3 minpos)\n{\n    float eps=.001;\n    float dsum=0.;\n    float dmin=100000.;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if(d<dmin) { dmin=d; minpos=pos; }\n        dsum+=d;\n        if (dsum>maxDist) break;\n        if (d<eps) return 0.;\n    }\n    return dmin;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    float camDist=20.;\n    #ifdef SHADEROO\n    camDist*=exp(-iMouseData.z/3000.);\n    #endif\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    if (iMouse.x<1.)\n    {\n        ph=iTime*.5;\n        th=.2+(1.+sin(iTime*.13))*.5;\n        camDist*=1.2-cos(iTime*.3);\n    }\n    pos=vec3(0,0,camDist);\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\n#define RandTex iChannel1\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel2,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col*.7,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light=normalize(vec3(1,1,1.5));\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    march(pos,dir);    \n    vec3 pos1=pos;\n    float d1=dist(pos1);\n    vec3 n=normalize(getGrad(pos,.001));\n    vec3 R=reflect(dir,n);\n    float ao=1.;\n    float sc=25.;\n    ao*=.9+.1*abs(dist(pos+n*.06*sc))/(.06*sc);\n    ao*=.7+.3*abs(dist(pos+n*.02*sc))/(.02*sc);\n    ao*=.6+.4*abs(dist(pos+n*.01*sc))/(.01*sc);\n    ao*=.5+.5*abs(dist(pos+n*.005*sc))/(.005*sc);\n    ao=clamp(ao,0.,1.);\n    float diff=max(dot(n,light),0.)*.7+.3;\n    pos+=light*.01;\n    #ifdef SHADOW\n    marchUntilSmaller(pos,light);\n    vec3 minpos;\n    float sh=marchUntil(pos,light,1000.,minpos);\n    sh=1.-smoothstep(0.,.1*length(minpos-pos1),sh);\n    //sh=(sh!=0.)?0.:1.;\n    sh*=exp(-length(minpos-pos1)/2.3);\n    diff=min(diff,(1.-sh)*.5+.5);\n    #endif\n    fragColor.xyz=vec3(1);\n    fragColor.xyz*=(n*.05+.95);\n    //diff=1.;\n    fragColor.xyz*=diff;\n    fragColor.xyz*=mix(1.,ao,diff);\n    vec4 refl=myenv(pos1,R,1.);\n    if(d1==distGrid(pos1)) { fragColor.xyz*=vec3(1.,.8,.6)*1.4*(.5+.7*refl.xyz); }\n    if(d1==distFloor(pos1)) fragColor.xyz*=vec3(1.3,1.1,.9)*1.4*(.8+.2*refl.xyz);\n    //fragColor.xyz*=vec3(1.,.8,.6)*1.3;\n    //vec4 refl=myenv(pos1,R,1.); fragColor.xyz*=(.7+.3*refl.xyz);\n    //if(d1==distFloor(pos1)) fragColor.xyz*=vec3(.9,.95,1.)*1.3;\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddcD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[638, 638, 668, 668, 703], [704, 704, 734, 734, 764], [806, 828, 870, 870, 987], [989, 989, 1011, 1011, 1417], [1456, 1456, 1522, 1522, 1727], [1729, 1729, 1756, 1756, 1868], [1870, 1870, 1896, 1896, 2230], [2232, 2232, 2254, 2254, 2347], [2349, 2349, 2383, 2383, 2507], [2509, 2509, 2548, 2548, 2704], [2706, 2706, 2757, 2757, 2949], [2951, 2951, 3029, 3029, 3322], [3324, 3324, 3380, 3380, 3892], [3920, 3920, 3946, 3946, 4182], [4268, 4314, 4361, 4361, 5265], [5267, 5267, 5324, 5324, 6675]]}
{"id": "ts3cD7", "name": "Gray-Scott Explorer v4", "author": "dr2", "description": " Modeling a simple but complex chemical process - see the source;   based on \"Gray-Scott Explorer v3\", updated with 3D surface visualization (try full-screen).\n", "tags": ["diffusion", "pattern", "reaction", "morphogenesis"], "likes": 14, "viewed": 380, "published": 3, "date": "1601032224", "time_retrieved": "2024-07-30T20:43:33.348696", "image_code": "// \"Gray-Scott Explorer v4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The autocatalytic Gray-Scott system involves two chemical reactions\n  U + 2V -> 3V and V -> P.\n  In terms of partial differential equations, where U = U(x,y,t), etc,\n  with diffusion added (fixed diffusion constants D_u and D_v that\n  differ significantly), these correspond to\n    dU/dt = D_u del^2 U - U V^2 + f (1 - U)\n    dV/dt = D_v del^2 V + U V^2 - (f + k) V\n  where f is the feed rate (coupled to reservoirs with U = 1 and V = 0) and\n  k is the rate constant for V -> P.\n\n  The equations are numerically integrated using the Euler method (on a regular \n  CPU use the stable ADI method that allows a 10x larger time step). The initial \n  state is either random or a small cluster with a little randomness added to break \n  symmetry; each run is different; boundaries are periodic.\n\n  The left and right sliders set the k and f parameters; the values are\n  shown x100. The left button cycles through several interesting parameter\n  presets; there are many other combinations worth examining. The right button\n  chooses the type of initial state. Some patterns are slow to evolve; patience.\n\n  The surface height represents the concentration of one of the chemical species.\n  Surface rendering based on \"Scrolling Terrain\".\n  \n  Online resources include:\n   http://blog.hvidtfeldts.net/index.php/2012/08/reaction-diffusion-systems/\n   http://mrob.com/pub/comp/xmorphia/pearson-classes.html\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (vec2 vId);\n\nvec3 ltDir, hbSize, rdSign;\nfloat dstFar, gSize;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat SurfDst (vec3 p)\n{\n  vec2 gv, sv;\n  float h;\n  gv = (p.xz + 0.5) * (gSize - 1.);\n  sv = floor (gv);\n  h = 0.;\n  if (min (sv.x, sv.y) >= 0. && max (sv.x, sv.y) < gSize - 1.) {\n    gv -= sv;\n    h = mix (mix (Loadv4 (sv).y, Loadv4 (sv + vec2 (0., 1.)).y, gv.y),\n       mix (Loadv4 (sv + vec2 (1., 0.)).y, Loadv4 (sv + vec2 (1.)).y, gv.y), gv.x);\n    h = clamp (h, 0., 1.);\n  }\n  return p.y - 0.07 * h;\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  s = PrBoxDf (ro, vec3 (0.5, 0.1, 0.5));\n  sLo = 0.;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + s * rd;\n    h = SurfDst (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (SurfDst (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  p.xz = abs (p.xz);\n  return (max (abs (p.x), abs (p.z)) < 0.5 * (1. - 1. / (gSize - 1.))) ? dHit : dstFar;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SurfDst (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BBoxDf (vec3 p)\n{\n  float w;\n  w = 0.5 * (1. - 1. / (gSize - 1.));\n  p.y -= hbSize.y;\n  return max (PrBoxDf (p, vec3 (w, hbSize.y, w)), - PrBox2Df (p.xz, vec2 (w - 0.01)));\n}\n\nfloat BBoxRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = BBoxDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 BBoxNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BBoxDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen, rsLen;\n  vec3 eWid;\n  float dMin, d;\n  dMin = dstFar;\n  sLen = vec4 (hbSize + 0.005, 0.);\n  rsLen = vec4 (sLen.xyz * rdSign, 0.);\n  eWid = vec3 (0.0015);\n  p.y -= hbSize.y;\n  d = Minv3 (vec3 (PrBoxDf (p - rsLen.xww, eWid + sLen.wyz),\n     PrBoxDf (p - rsLen.wyw, eWid + sLen.xwz), PrBoxDf (p - rsLen.wwz, eWid + sLen.xyw)));\n  DMIN (1);\n  p = abs (p);\n  d = Minv3 (vec3 (PrBoxDf (p - sLen.wyz, eWid + sLen.xww),\n     PrBoxDf (p - sLen.xwz, eWid + sLen.wyw), PrBoxDf (p - sLen.xyw, eWid + sLen.wwz)));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, vn;\n  float dMin, dn, df;\n  dMin = dstFar;\n  ro.y -= hbSize.y;\n  v = ro / rd;\n  tp = (hbSize + 0.005) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  ro.y -= hbSize.y;\n  v = ro / rd;\n  tp = (hbSize + 0.01) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn, roo;\n  float dstSurf, dstBBox, dstFrm, nDotL;\n  col = vec3 (0.1, 0.1, 0.3);\n  hbSize = vec3 (0.5, 0.03, 0.5);\n  if (BlkHitSil (ro, rd) < dstFar) {\n    dstBBox = BBoxRay (ro, rd);\n    if (dstBBox < dstFar && SurfDst (ro + dstBBox * rd) > 0.) dstBBox = dstFar;\n    dstSurf = SurfRay (ro, rd);\n    rdSign = sign (rd);\n    dstFrm = ObjRay (ro, rd);\n    roo = ro;\n    if (min (dstSurf, min (dstFrm, dstBBox)) < dstFar) {\n      if (dstSurf < min (dstFrm, dstBBox)) {\n        ro += dstSurf * rd;\n        col = mix (vec3 (0., 0.6, 0.), vec3 (1., 0.7, 0.), smoothstep (0.002, 0.003, ro.y)); \n        vn = SurfNf (ro);\n      } else if (dstBBox < dstFrm) {\n        ro += dstBBox * rd;\n        col = vec3 (0.6, 0.8, 0.4);\n        vn = BBoxNf (ro);\n      } else {\n        ro += dstFrm * rd;\n        col = (idObj == 1) ? vec3 (0.4, 0.4, 0.3) : vec3 (0.6, 0.6, 0.4);\n        vn = ObjNf (ro);\n      }\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (dstSurf < min (dstFrm, dstBBox) && ro.y > 0.002) nDotL *= nDotL;\n      col = col * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * nDotL) +\n         0.2 * pow (max (0., dot (ltDir, rd)), 32.);\n    }\n    db4 = BlkHit (roo, rd);\n    if (db4.x < dstFar) {\n      vn = db4.yzw;\n      col = mix (col, vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.),\n         pow (1. - abs (dot (rd, vn)), 5.));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec2 slVal)\n{\n  vec4 wgBx[4];\n  vec3 c1, c2;\n  vec2 ut, ust;\n  float vW[2], asp, t;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.40 * asp, 0., 0.012 * asp, 0.25);\n  wgBx[1] = vec4 (0.46 * asp, 0., 0.012 * asp, 0.25);\n  wgBx[2] = vec4 (0.40 * asp, -0.4, 0.013 * asp, 0.);\n  wgBx[3] = vec4 (0.46 * asp, -0.4, 0.013 * asp, 0.);\n  vW[0] = slVal.x;\n  vW[1] = slVal.y;\n  c1 = vec3 (0.7, 0.1, 0.1);\n  c2 = vec3 (1., 0.7, 0.5);\n  for (int k = 0; k < 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = c2;\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.05) *\n         canvas.y < 5.) ? c2 : vec3 (0.3);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (abs (max (ut.x, ut.y) - 0.015) < 0.006) col = c1;\n    col = mix (col, c1, ShowInt (0.5 * uv - wgBx[k].xy - wgBx[k].zw * vec2 (1., -1.) -\n       vec2 (0.0045, -0.06), 0.028 * vec2 (asp, 1.), 2., clamp (floor (1000. * vW[k] * 0.1 +\n       1e-4), 1., 99.)));\n  }\n  for (int k = 2; k < 4; k ++) {\n    t = length (0.5 * uv - wgBx[k].xy);\n    if (t < wgBx[k].z) col = (t < 0.7 * wgBx[k].z) ? c1 : c2;\n  }\n  return col;\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float az, el, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).w;\n  dstFar = 6.;\n  stDat = Loadv4 (vec2 (6., 0.));\n  az = stDat.w;\n  el = clamp (stDat.z - 0.3 * pi, -0.45 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -3.);\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 5.5));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col, Loadv4 (vec2 (3., 0.)).zw);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    if (val < 0.5) sgn = 1.;\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Gray-Scott Explorer v4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 difC, constKF;\nfloat itRand, gSize, delT, bgnClust;\nconst float pi = 3.14159;\n\nvec2 Step (vec2 sv)\n{\n  vec4 dv;\n  vec2 c, del2c;\n  c = Loadv4 (sv).xy;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  del2c = Loadv4 (vec2 (dv.x, sv.y)).xy + Loadv4 (vec2 (dv.y, sv.y)).xy +\n     Loadv4 (vec2 (sv.x, dv.z)).xy + Loadv4 (vec2 (sv.x, dv.w)).xy - 4. * c;\n  c += delT * (difC * del2c - constKF.y * c +\n     vec2 (constKF.y, - constKF.x * c.y) + c.x * c.y * c.y * vec2 (-1., 1.));\n  return c;\n}\n\nvec2 Init (vec2 sv)\n{\n  vec2 c;\n  float s, iSize;\n  if (bgnClust == 0.) {\n    s = step (0.1, Hashfv2 (mod (16. * floor (sv / 16.) + itRand + 10.1, 2. * pi)));\n    c = vec2 (s, 1. - s);\n  } else {\n    iSize = (gSize > 128.) ? 10. : 5.;\n    if (max (abs (sv.x - 0.5 * gSize), abs (sv.y - 0.5 * gSize)) <= iSize) {\n      s = Hashfv2 (mod (17. * sv + itRand + 10.1, 2. * pi));\n      c = vec2 (0.5 + 0.02 * (s - 0.5), 0.25 - 0.02 * (s - 0.5));\n    } else c = vec2 (1., 0.);\n  }\n  return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  const int nPre = 7;\n  vec4 wgBx[4], stDat, mPtr, mPtrP;\n  vec2 presetKF[nPre], iFrag, canvas, ust, c, slVal;\n  float tCur, asp, az, el, vW, nStep, idPre;\n  int wgSel, wgReg, kSel;\n  bool doInit, doPre;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1024.) ? 1024. : ((canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.));\n  if (max (fragCoord.x, fragCoord.y) >= gSize) discard;\n  iFrag = floor (fragCoord);\n  doInit = (iFrame <= 5);\n  doPre = false;\n  wgReg = -2;\n  difC = vec2 (0.2, 0.1);\n  delT = 1.;\n  presetKF[0] = vec2 (0.047, 0.010);\n  presetKF[1] = vec2 (0.059, 0.020);\n  presetKF[2] = vec2 (0.055, 0.025);\n  presetKF[3] = vec2 (0.060, 0.025);\n  presetKF[4] = vec2 (0.063, 0.050);\n  presetKF[5] = vec2 (0.065, 0.040);\n  presetKF[6] = vec2 (0.065, 0.055);\n  if (doInit) {\n    mPtrP = mPtr;\n    itRand = 0.;\n    idPre = 0.;\n    bgnClust = 0.;\n    doPre = true;\n    nStep = 0.;\n    wgSel = -1;\n    az = 0.001;\n    el = 0.;\n  } else {\n    stDat = Loadv4 (vec2 (0., 0.));\n    nStep = stDat.z;\n    stDat = Loadv4 (vec2 (1., 0.));\n    mPtrP.xy = stDat.zw;\n    stDat = Loadv4 (vec2 (2., 0.));\n    mPtrP.zw = vec2 (stDat.z, 0.);\n    itRand = stDat.w;\n    stDat = Loadv4 (vec2 (3., 0.));\n    slVal = stDat.zw;\n    constKF = slVal.xy * 0.1;\n    stDat = Loadv4 (vec2 (4., 0.));\n    idPre = stDat.z;\n    bgnClust = stDat.w;\n    stDat = Loadv4 (vec2 (5., 0.));\n    wgSel = int (stDat.z);\n    stDat = Loadv4 (vec2 (6., 0.));\n    el = stDat.z;\n    az = stDat.w;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.40 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[1] = vec4 (0.46 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[2] = vec4 (0.40 * asp, -0.4, 0.013 * asp, 0.);\n    wgBx[3] = vec4 (0.46 * asp, -0.4, 0.013 * asp, 0.);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    for (int k = 2; k < 4; k ++) {\n      if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) < wgBx[k].z) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) {\n      wgSel = wgReg;\n      itRand = tCur;\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = 0.001;\n    el = 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 1.);\n          break;\n        }\n      }\n      vW = 0.01 * floor (100. * vW + 0.5);\n      if (kSel == 0) {\n        slVal.x = clamp (vW, 0.3, 0.7);\n        constKF.x = slVal.x * 0.1;\n      } else if (kSel == 1) {\n        slVal.y = clamp (vW, 0.05, 0.8);\n        constKF.y = slVal.y * 0.1;\n      }\n    } else if (wgSel == 2 && mPtrP.z <= 0.) {\n      idPre = mod (idPre + 1., float (nPre));\n      doPre = true;\n    } else if (wgSel == 3 && mPtrP.z <= 0.) {\n      bgnClust = 1. - bgnClust;\n    }\n    doInit = true;\n  }\n  if (gSize == 128. && nStep >= 2000.) {\n    idPre = mod (idPre + 1., float (nPre));\n    doPre = true;\n    doInit = true;\n  }\n  if (doPre) {\n    for (int k = 0; k < nPre; k ++) {\n      if (idPre == float (k)) {\n        constKF = presetKF[k];\n        slVal = constKF / 0.1;\n        break;\n      }\n    }\n  }\n  if (! doInit && gSize != Loadv4 (vec2 (0., 0.)).w) doInit = true;\n  if (doInit) {\n    nStep = 0.;\n    c = Init (iFrag);\n  } else {\n    ++ nStep;\n    c = Step (iFrag);\n  }\n  stDat = vec4 (c, 0., 0.);\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) stDat.zw = vec2 (nStep, gSize);\n    else if (iFrag.x == 1.) stDat.zw = mPtr.xy;\n    else if (iFrag.x == 2.) stDat.zw = vec2 (mPtr.z, itRand);\n    else if (iFrag.x == 3.) stDat.zw = slVal;\n    else if (iFrag.x == 4.) stDat.zw = vec2 (idPre, bgnClust);\n    else if (iFrag.x == 5.) stDat.zw = vec2 (float (wgSel), 0.);\n    else if (iFrag.x == 6.) stDat.zw = vec2 (el, az);\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Gray-Scott Explorer v4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 difC, constKF;\nfloat itRand, gSize, delT, bgnClust;\nconst float pi = 3.14159;\n\nvec2 Step (vec2 sv)\n{\n  vec4 dv;\n  vec2 c, del2c;\n  c = Loadv4 (sv).xy;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  del2c = Loadv4 (vec2 (dv.x, sv.y)).xy + Loadv4 (vec2 (dv.y, sv.y)).xy +\n     Loadv4 (vec2 (sv.x, dv.z)).xy + Loadv4 (vec2 (sv.x, dv.w)).xy - 4. * c;\n  c += delT * (difC * del2c - constKF.y * c +\n     vec2 (constKF.y, - constKF.x * c.y) + c.x * c.y * c.y * vec2 (-1., 1.));\n  return c;\n}\n\nvec2 Init (vec2 sv)\n{\n  vec2 c;\n  float s, iSize;\n  if (bgnClust == 0.) {\n    s = step (0.1, Hashfv2 (mod (16. * floor (sv / 16.) + itRand + 10.1, 2. * pi)));\n    c = vec2 (s, 1. - s);\n  } else {\n    iSize = (gSize > 128.) ? 10. : 5.;\n    if (max (abs (sv.x - 0.5 * gSize), abs (sv.y - 0.5 * gSize)) <= iSize) {\n      s = Hashfv2 (mod (17. * sv + itRand + 10.1, 2. * pi));\n      c = vec2 (0.5 + 0.02 * (s - 0.5), 0.25 - 0.02 * (s - 0.5));\n    } else c = vec2 (1., 0.);\n  }\n  return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  const int nPre = 7;\n  vec4 wgBx[4], stDat, mPtr, mPtrP;\n  vec2 presetKF[nPre], iFrag, canvas, ust, c, slVal;\n  float tCur, asp, az, el, vW, nStep, idPre;\n  int wgSel, wgReg, kSel;\n  bool doInit, doPre;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1024.) ? 1024. : ((canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.));\n  if (max (fragCoord.x, fragCoord.y) >= gSize) discard;\n  iFrag = floor (fragCoord);\n  doInit = (iFrame <= 5);\n  doPre = false;\n  wgReg = -2;\n  difC = vec2 (0.2, 0.1);\n  delT = 1.;\n  presetKF[0] = vec2 (0.047, 0.010);\n  presetKF[1] = vec2 (0.059, 0.020);\n  presetKF[2] = vec2 (0.055, 0.025);\n  presetKF[3] = vec2 (0.060, 0.025);\n  presetKF[4] = vec2 (0.063, 0.050);\n  presetKF[5] = vec2 (0.065, 0.040);\n  presetKF[6] = vec2 (0.065, 0.055);\n  if (doInit) {\n    mPtrP = mPtr;\n    itRand = 0.;\n    idPre = 0.;\n    bgnClust = 0.;\n    doPre = true;\n    nStep = 0.;\n    wgSel = -1;\n    az = 0.001;\n    el = 0.;\n  } else {\n    stDat = Loadv4 (vec2 (0., 0.));\n    nStep = stDat.z;\n    stDat = Loadv4 (vec2 (1., 0.));\n    mPtrP.xy = stDat.zw;\n    stDat = Loadv4 (vec2 (2., 0.));\n    mPtrP.zw = vec2 (stDat.z, 0.);\n    itRand = stDat.w;\n    stDat = Loadv4 (vec2 (3., 0.));\n    slVal = stDat.zw;\n    constKF = slVal.xy * 0.1;\n    stDat = Loadv4 (vec2 (4., 0.));\n    idPre = stDat.z;\n    bgnClust = stDat.w;\n    stDat = Loadv4 (vec2 (5., 0.));\n    wgSel = int (stDat.z);\n    stDat = Loadv4 (vec2 (6., 0.));\n    el = stDat.z;\n    az = stDat.w;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.40 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[1] = vec4 (0.46 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[2] = vec4 (0.40 * asp, -0.4, 0.013 * asp, 0.);\n    wgBx[3] = vec4 (0.46 * asp, -0.4, 0.013 * asp, 0.);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    for (int k = 2; k < 4; k ++) {\n      if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) < wgBx[k].z) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) {\n      wgSel = wgReg;\n      itRand = tCur;\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = 0.001;\n    el = 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 1.);\n          break;\n        }\n      }\n      vW = 0.01 * floor (100. * vW + 0.5);\n      if (kSel == 0) {\n        slVal.x = clamp (vW, 0.3, 0.7);\n        constKF.x = slVal.x * 0.1;\n      } else if (kSel == 1) {\n        slVal.y = clamp (vW, 0.05, 0.8);\n        constKF.y = slVal.y * 0.1;\n      }\n    } else if (wgSel == 2 && mPtrP.z <= 0.) {\n      idPre = mod (idPre + 1., float (nPre));\n      doPre = true;\n    } else if (wgSel == 3 && mPtrP.z <= 0.) {\n      bgnClust = 1. - bgnClust;\n    }\n    doInit = true;\n  }\n  if (gSize == 128. && nStep >= 2000.) {\n    idPre = mod (idPre + 1., float (nPre));\n    doPre = true;\n    doInit = true;\n  }\n  if (doPre) {\n    for (int k = 0; k < nPre; k ++) {\n      if (idPre == float (k)) {\n        constKF = presetKF[k];\n        slVal = constKF / 0.1;\n        break;\n      }\n    }\n  }\n  if (! doInit && gSize != Loadv4 (vec2 (0., 0.)).w) doInit = true;\n  if (doInit) {\n    nStep = 0.;\n    c = Init (iFrag);\n  } else {\n    ++ nStep;\n    c = Step (iFrag);\n  }\n  stDat = vec4 (c, 0., 0.);\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) stDat.zw = vec2 (nStep, gSize);\n    else if (iFrag.x == 1.) stDat.zw = mPtr.xy;\n    else if (iFrag.x == 2.) stDat.zw = vec2 (mPtr.z, itRand);\n    else if (iFrag.x == 3.) stDat.zw = slVal;\n    else if (iFrag.x == 4.) stDat.zw = vec2 (idPre, bgnClust);\n    else if (iFrag.x == 5.) stDat.zw = vec2 (float (wgSel), 0.);\n    else if (iFrag.x == 6.) stDat.zw = vec2 (el, az);\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Gray-Scott Explorer v4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 difC, constKF;\nfloat itRand, gSize, delT, bgnClust;\nconst float pi = 3.14159;\n\nvec2 Step (vec2 sv)\n{\n  vec4 dv;\n  vec2 c, del2c;\n  c = Loadv4 (sv).xy;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  del2c = Loadv4 (vec2 (dv.x, sv.y)).xy + Loadv4 (vec2 (dv.y, sv.y)).xy +\n     Loadv4 (vec2 (sv.x, dv.z)).xy + Loadv4 (vec2 (sv.x, dv.w)).xy - 4. * c;\n  c += delT * (difC * del2c - constKF.y * c +\n     vec2 (constKF.y, - constKF.x * c.y) + c.x * c.y * c.y * vec2 (-1., 1.));\n  return c;\n}\n\nvec2 Init (vec2 sv)\n{\n  vec2 c;\n  float s, iSize;\n  if (bgnClust == 0.) {\n    s = step (0.1, Hashfv2 (mod (16. * floor (sv / 16.) + itRand + 10.1, 2. * pi)));\n    c = vec2 (s, 1. - s);\n  } else {\n    iSize = (gSize > 128.) ? 10. : 5.;\n    if (max (abs (sv.x - 0.5 * gSize), abs (sv.y - 0.5 * gSize)) <= iSize) {\n      s = Hashfv2 (mod (17. * sv + itRand + 10.1, 2. * pi));\n      c = vec2 (0.5 + 0.02 * (s - 0.5), 0.25 - 0.02 * (s - 0.5));\n    } else c = vec2 (1., 0.);\n  }\n  return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  const int nPre = 7;\n  vec4 wgBx[4], stDat, mPtr, mPtrP;\n  vec2 presetKF[nPre], iFrag, canvas, ust, c, slVal;\n  float tCur, asp, az, el, vW, nStep, idPre;\n  int wgSel, wgReg, kSel;\n  bool doInit, doPre;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1024.) ? 1024. : ((canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.));\n  if (max (fragCoord.x, fragCoord.y) >= gSize) discard;\n  iFrag = floor (fragCoord);\n  doInit = (iFrame <= 5);\n  doPre = false;\n  wgReg = -2;\n  difC = vec2 (0.2, 0.1);\n  delT = 1.;\n  presetKF[0] = vec2 (0.047, 0.010);\n  presetKF[1] = vec2 (0.059, 0.020);\n  presetKF[2] = vec2 (0.055, 0.025);\n  presetKF[3] = vec2 (0.060, 0.025);\n  presetKF[4] = vec2 (0.063, 0.050);\n  presetKF[5] = vec2 (0.065, 0.040);\n  presetKF[6] = vec2 (0.065, 0.055);\n  if (doInit) {\n    mPtrP = mPtr;\n    itRand = 0.;\n    idPre = 0.;\n    bgnClust = 0.;\n    doPre = true;\n    nStep = 0.;\n    wgSel = -1;\n    az = 0.001;\n    el = 0.;\n  } else {\n    stDat = Loadv4 (vec2 (0., 0.));\n    nStep = stDat.z;\n    stDat = Loadv4 (vec2 (1., 0.));\n    mPtrP.xy = stDat.zw;\n    stDat = Loadv4 (vec2 (2., 0.));\n    mPtrP.zw = vec2 (stDat.z, 0.);\n    itRand = stDat.w;\n    stDat = Loadv4 (vec2 (3., 0.));\n    slVal = stDat.zw;\n    constKF = slVal.xy * 0.1;\n    stDat = Loadv4 (vec2 (4., 0.));\n    idPre = stDat.z;\n    bgnClust = stDat.w;\n    stDat = Loadv4 (vec2 (5., 0.));\n    wgSel = int (stDat.z);\n    stDat = Loadv4 (vec2 (6., 0.));\n    el = stDat.z;\n    az = stDat.w;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.40 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[1] = vec4 (0.46 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[2] = vec4 (0.40 * asp, -0.4, 0.013 * asp, 0.);\n    wgBx[3] = vec4 (0.46 * asp, -0.4, 0.013 * asp, 0.);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    for (int k = 2; k < 4; k ++) {\n      if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) < wgBx[k].z) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) {\n      wgSel = wgReg;\n      itRand = tCur;\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = 0.001;\n    el = 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 1.);\n          break;\n        }\n      }\n      vW = 0.01 * floor (100. * vW + 0.5);\n      if (kSel == 0) {\n        slVal.x = clamp (vW, 0.3, 0.7);\n        constKF.x = slVal.x * 0.1;\n      } else if (kSel == 1) {\n        slVal.y = clamp (vW, 0.05, 0.8);\n        constKF.y = slVal.y * 0.1;\n      }\n    } else if (wgSel == 2 && mPtrP.z <= 0.) {\n      idPre = mod (idPre + 1., float (nPre));\n      doPre = true;\n    } else if (wgSel == 3 && mPtrP.z <= 0.) {\n      bgnClust = 1. - bgnClust;\n    }\n    doInit = true;\n  }\n  if (gSize == 128. && nStep >= 2000.) {\n    idPre = mod (idPre + 1., float (nPre));\n    doPre = true;\n    doInit = true;\n  }\n  if (doPre) {\n    for (int k = 0; k < nPre; k ++) {\n      if (idPre == float (k)) {\n        constKF = presetKF[k];\n        slVal = constKF / 0.1;\n        break;\n      }\n    }\n  }\n  if (! doInit && gSize != Loadv4 (vec2 (0., 0.)).w) doInit = true;\n  if (doInit) {\n    nStep = 0.;\n    c = Init (iFrag);\n  } else {\n    ++ nStep;\n    c = Step (iFrag);\n  }\n  stDat = vec4 (c, 0., 0.);\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) stDat.zw = vec2 (nStep, gSize);\n    else if (iFrag.x == 1.) stDat.zw = mPtr.xy;\n    else if (iFrag.x == 2.) stDat.zw = vec2 (mPtr.z, itRand);\n    else if (iFrag.x == 3.) stDat.zw = slVal;\n    else if (iFrag.x == 4.) stDat.zw = vec2 (idPre, bgnClust);\n    else if (iFrag.x == 5.) stDat.zw = vec2 (float (wgSel), 0.);\n    else if (iFrag.x == 6.) stDat.zw = vec2 (el, az);\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Gray-Scott Explorer v4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 difC, constKF;\nfloat itRand, gSize, delT, bgnClust;\nconst float pi = 3.14159;\n\nvec2 Step (vec2 sv)\n{\n  vec4 dv;\n  vec2 c, del2c;\n  c = Loadv4 (sv).xy;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  del2c = Loadv4 (vec2 (dv.x, sv.y)).xy + Loadv4 (vec2 (dv.y, sv.y)).xy +\n     Loadv4 (vec2 (sv.x, dv.z)).xy + Loadv4 (vec2 (sv.x, dv.w)).xy - 4. * c;\n  c += delT * (difC * del2c - constKF.y * c +\n     vec2 (constKF.y, - constKF.x * c.y) + c.x * c.y * c.y * vec2 (-1., 1.));\n  return c;\n}\n\nvec2 Init (vec2 sv)\n{\n  vec2 c;\n  float s, iSize;\n  if (bgnClust == 0.) {\n    s = step (0.1, Hashfv2 (mod (16. * floor (sv / 16.) + itRand + 10.1, 2. * pi)));\n    c = vec2 (s, 1. - s);\n  } else {\n    iSize = (gSize > 128.) ? 10. : 5.;\n    if (max (abs (sv.x - 0.5 * gSize), abs (sv.y - 0.5 * gSize)) <= iSize) {\n      s = Hashfv2 (mod (17. * sv + itRand + 10.1, 2. * pi));\n      c = vec2 (0.5 + 0.02 * (s - 0.5), 0.25 - 0.02 * (s - 0.5));\n    } else c = vec2 (1., 0.);\n  }\n  return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  const int nPre = 7;\n  vec4 wgBx[4], stDat, mPtr, mPtrP;\n  vec2 presetKF[nPre], iFrag, canvas, ust, c, slVal;\n  float tCur, asp, az, el, vW, nStep, idPre;\n  int wgSel, wgReg, kSel;\n  bool doInit, doPre;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1024.) ? 1024. : ((canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.));\n  if (max (fragCoord.x, fragCoord.y) >= gSize) discard;\n  iFrag = floor (fragCoord);\n  doInit = (iFrame <= 5);\n  doPre = false;\n  wgReg = -2;\n  difC = vec2 (0.2, 0.1);\n  delT = 1.;\n  presetKF[0] = vec2 (0.047, 0.010);\n  presetKF[1] = vec2 (0.059, 0.020);\n  presetKF[2] = vec2 (0.055, 0.025);\n  presetKF[3] = vec2 (0.060, 0.025);\n  presetKF[4] = vec2 (0.063, 0.050);\n  presetKF[5] = vec2 (0.065, 0.040);\n  presetKF[6] = vec2 (0.065, 0.055);\n  if (doInit) {\n    mPtrP = mPtr;\n    itRand = 0.;\n    idPre = 0.;\n    bgnClust = 0.;\n    doPre = true;\n    nStep = 0.;\n    wgSel = -1;\n    az = 0.001;\n    el = 0.;\n  } else {\n    stDat = Loadv4 (vec2 (0., 0.));\n    nStep = stDat.z;\n    stDat = Loadv4 (vec2 (1., 0.));\n    mPtrP.xy = stDat.zw;\n    stDat = Loadv4 (vec2 (2., 0.));\n    mPtrP.zw = vec2 (stDat.z, 0.);\n    itRand = stDat.w;\n    stDat = Loadv4 (vec2 (3., 0.));\n    slVal = stDat.zw;\n    constKF = slVal.xy * 0.1;\n    stDat = Loadv4 (vec2 (4., 0.));\n    idPre = stDat.z;\n    bgnClust = stDat.w;\n    stDat = Loadv4 (vec2 (5., 0.));\n    wgSel = int (stDat.z);\n    stDat = Loadv4 (vec2 (6., 0.));\n    el = stDat.z;\n    az = stDat.w;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.40 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[1] = vec4 (0.46 * asp, 0., 0.012 * asp, 0.25);\n    wgBx[2] = vec4 (0.40 * asp, -0.4, 0.013 * asp, 0.);\n    wgBx[3] = vec4 (0.46 * asp, -0.4, 0.013 * asp, 0.);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    for (int k = 2; k < 4; k ++) {\n      if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) < wgBx[k].z) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) {\n      wgSel = wgReg;\n      itRand = tCur;\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = 0.001;\n    el = 0.;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 1.);\n          break;\n        }\n      }\n      vW = 0.01 * floor (100. * vW + 0.5);\n      if (kSel == 0) {\n        slVal.x = clamp (vW, 0.3, 0.7);\n        constKF.x = slVal.x * 0.1;\n      } else if (kSel == 1) {\n        slVal.y = clamp (vW, 0.05, 0.8);\n        constKF.y = slVal.y * 0.1;\n      }\n    } else if (wgSel == 2 && mPtrP.z <= 0.) {\n      idPre = mod (idPre + 1., float (nPre));\n      doPre = true;\n    } else if (wgSel == 3 && mPtrP.z <= 0.) {\n      bgnClust = 1. - bgnClust;\n    }\n    doInit = true;\n  }\n  if (gSize == 128. && nStep >= 2000.) {\n    idPre = mod (idPre + 1., float (nPre));\n    doPre = true;\n    doInit = true;\n  }\n  if (doPre) {\n    for (int k = 0; k < nPre; k ++) {\n      if (idPre == float (k)) {\n        constKF = presetKF[k];\n        slVal = constKF / 0.1;\n        break;\n      }\n    }\n  }\n  if (! doInit && gSize != Loadv4 (vec2 (0., 0.)).w) doInit = true;\n  if (doInit) {\n    nStep = 0.;\n    c = Init (iFrag);\n  } else {\n    ++ nStep;\n    c = Step (iFrag);\n  }\n  stDat = vec4 (c, 0., 0.);\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) stDat.zw = vec2 (nStep, gSize);\n    else if (iFrag.x == 1.) stDat.zw = mPtr.xy;\n    else if (iFrag.x == 2.) stDat.zw = vec2 (mPtr.z, itRand);\n    else if (iFrag.x == 3.) stDat.zw = slVal;\n    else if (iFrag.x == 4.) stDat.zw = vec2 (idPre, bgnClust);\n    else if (iFrag.x == 5.) stDat.zw = vec2 (float (wgSel), 0.);\n    else if (iFrag.x == 6.) stDat.zw = vec2 (el, az);\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3cD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1974, 1974, 1998, 1998, 2381], [2383, 2383, 2417, 2417, 3027], [3029, 3029, 3051, 3051, 3308], [3310, 3310, 3333, 3333, 3490], [3492, 3492, 3526, 3526, 3710], [3712, 3712, 3734, 3734, 3990], [3992, 3992, 4014, 4014, 4557], [4559, 4559, 4592, 4592, 4775], [4777, 4777, 4798, 4798, 5053], [5055, 5055, 5087, 5087, 5423], [5425, 5425, 5461, 5461, 5676], [5678, 5678, 5713, 5713, 7193], [7195, 7195, 7253, 7253, 8517], [8534, 8534, 8590, 8590, 9557], [9559, 9559, 9591, 9591, 9691], [9693, 9693, 9726, 9726, 9815], [9817, 9817, 9839, 9839, 9877], [9879, 9879, 9901, 9901, 9939], [9941, 9941, 9977, 9977, 10183], [10185, 10185, 10215, 10215, 10328], [10330, 10330, 10353, 10353, 10455], [10528, 10528, 10560, 10560, 11102], [11104, 11104, 11164, 11164, 11742], [11809, 11809, 11833, 11833, 11883]]}
{"id": "td3yD7", "name": "andrewt.net stripes", "author": "_polymath", "description": "a background", "tags": ["stripes"], "likes": 1, "viewed": 262, "published": 3, "date": "1601028751", "time_retrieved": "2024-07-30T20:43:34.222360", "image_code": "const float period = 30.;\nconst float tau = 3.14159 * 2.;\n\nfloat random(float i, float seed) {\n\treturn mod(sin(354.6346456 +\n            (i * 634.73453734) +\n            (seed * 264.246345346)\n           ) * 53467.34523463, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float h = uv.x + 1.;\n    float f = (uv.y - 0.5) / h;\n    f *= 4.;\n    //float f = uv.y + uv.y / (uv.x + 1.) - 0.5;\n\n    fragColor = vec4(1.);\n    \n    float t = mod(iTime, period);\n    float at = t / period * tau;\n    for (float i = 0.; i < 100.; ++i) {\n        float centre = random(i, 235.346345) * 5. - 2.5\n            + sin(at + random(i, 8934.8254645) * tau) * 0.3;\n        float r = random(i, 834.183245645) * 0.6 + 0.05;\n        float start = random(i, 362.934564) * period;\n        if (fract((t - start + period) / period) < 0.25) {\n            float rNow = r * sin(tau * (t - start) / period * 2.);\n            if (f < centre + rNow && f > centre - rNow) {\n                float c = mod(i, 4.);\n                if (c == 0.) fragColor = vec4(1.,.78,.34,1.);\n                else if (c == 1.) fragColor = vec4(.07,.6,.64,1.);\n                else if (c == 2.) fragColor = vec4(1.);\n                else fragColor = vec4(.29,.25,.45,1.);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 94, 94, 230], [232, 232, 289, 339, 1359]]}
{"id": "ts3yD7", "name": "Timeless depths - cineshader", "author": "kesson", "description": "A timeless depths, constantly mutating over time.\n\nA raymarch experiment based on the tutorial by The Art Of Code: https://www.youtube.com/watch?v=-adHIyjIYgk", "tags": ["cineshader"], "likes": 17, "viewed": 28100, "published": 3, "date": "1601025359", "time_retrieved": "2024-07-30T20:43:35.265571", "image_code": "// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Full Shadertoy version https://www.shadertoy.com/view/ttlyWB\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define SURF_DIST .001\n#define GYROID_DETAILS 12\n#define WIDEANGLE 0 // set this to 1 for a wide angle pseudo-distortion\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n    vec3 st = p * s;\n    \n    float lx = 1.0 + ((sin(iTime * 0.0576) * 0.5) + 0.5) * 0.25;    \n    float ly = 1.0 + ((cos(iTime * 0.0565) * 0.5) + 0.5) * 0.25;\n    \n    float ls = max(lx, ly);\n    \n    return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) / (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n    p.xy *= rotate(p.z * 0.1);\n    p.z += iTime * 0.1;\n    p.y -= 0.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = transform(p);\n        \n    float s = 10.798;\n    float t = 0.03;\n    float b = 0.3;\n    float m = 0.5;\n    \n    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);\n    float g1 = sdGyroid(p, s1, 0.03, 1.5);\n    \n    for (int i = 0; i < GYROID_DETAILS; i++) {\n        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;\n        else g1 += sdGyroid(p, s, t, b) * m;\n        s *= 1.75;\n        m *= 0.75;\n    }\n    \n    float d = g1 * 0.7;\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd) {\n\tvec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n    col += y * vec3(0.05, 0.18, 0.38) * 6.0;\n    \n    float a = atan(rd.x, rd.z);\n    float flares = 0.7 * sin(a*20.+t)*sin(a*2.-t)*sin(a*6.);\n    flares *= smoothstep(.0, 1.0, y);\n    col += flares;\n    col = max(col, 0.);    \n    return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n    vec3 n = GetNormal(p);\n    return reflect(rd, n);\n}\n\n// Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n    ro = vec3( cd*cos(an), cd * sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    if (WIDEANGLE == 1) {\n    \tuv += sin(uv*2.0); // wideangle distortion\n    }\n            \n    vec3 col = vec3(0.0);\n    \n    float t = iTime * 0.01;\n    \n    uv += sin(uv*20.+t)*.01;\n    \n    float an = -iTime * 0.05;\n    \n    vec3 ro, rd;\n    float cd = 0.01; // camera distance\n    camera(cd, uv, an, ro, rd); // get the camera\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n    \tcol =vec3(0.0);\n        \n        p = transform(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(0.0,0.0,1.0)))*.5+.5;\n        col *= dif;\n    \tcol += dif;\n        \n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n        \n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p+t, 6.789, 0.03, 0.3) * 4.0);\n        float cc2 = 1.0 - (sdGyroid(p-t*0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(0.1, 0.4, 1.0) * cc * cc2 * 3.0;\n    }\n    \n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n    \n    fragColor = vec4(col,d / 3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[381, 381, 403, 403, 479], [481, 481, 532, 532, 804], [806, 806, 830, 830, 917], [919, 919, 942, 942, 1401], [1403, 1403, 1437, 1437, 1648], [1650, 1650, 1674, 1674, 1863], [1865, 1865, 1915, 1915, 2106], [2108, 2108, 2126, 2126, 2498], [2500, 2500, 2531, 2531, 2587], [2589, 2662, 2730, 2730, 3007], [3009, 3009, 3065, 3065, 4303]]}
{"id": "wdccW7", "name": "2D Octopus", "author": "z0rg", "description": "A cute creature based only on circles :)", "tags": ["2d", "cute", "motion", "octopus"], "likes": 4, "viewed": 281, "published": 3, "date": "1601021978", "time_retrieved": "2024-07-30T20:43:36.253929", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 red = vec3(255.,21.,47.)/255.;//vec3(.97,.12,.21);\nvec3 yellow = vec3(255.,198.,80.)/255.;\nvec3 pink = vec3(255.,159.,196.)/255.;\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat cir(vec2 p, float r) { return length(p)-r; }\n\nvec3 patternBack(vec2 uv)\n{\n  vec3 col;\n  float rep = 0.38;\n  uv-=vec2(.1);\n  float r = abs(cir(mod(uv,rep)-rep*.5,.14))-0.03;\n\n  col = mix(col, red*.5*(1.-sat(uv.y+.3)),1.-sat(r*40.));\n  return col;\n}\n\nvec4 spot(vec2 uv)\n{\n  float sz = 0.03;\n  return vec4(pink*(1.-sat(cir(uv-vec2(-sz*.1),sz*.8)*40.)), cir(uv,sz));\n}\n\nvec3 post(vec2 uv,vec3 rd)\n{\n  vec3 col = rd;\n  vec3 blue =vec3(89.,151.,255.)/255.;\n\n  col += blue*(sin(uv.x+uv.y)*.5+.5);\n  float an = uv.x+uv.y*.5;\n  col += sat(uv.y)*blue*.5*sat((sin(an*25.+iTime)*.5+.5)+(sin(an*5.-iTime*.5)*.5+.5));\n\n  float n = texture(iChannel0,vec2(sin(uv.y*5.+iTime+sin(uv.y*15.))*.05+uv.x,uv.y-iTime*.2)).x;\n  col += blue*float(n>.85)*(sin(uv.x+uv.y)*.5+.5);\n  return col;\n}\nvec3 rdr(vec2 uv, float shp)\n{\n  vec3 col = patternBack(uv);\n  col = .2*post(uv*-1.,col);\n\n\nvec2 uvt = vec2(abs(uv.x),uv.y*.7) -vec2(.38,-.2);\n  float tent = abs(cir(uvt,.25))-.12;\n  col = mix(col,red*(1.-sat(uvt.y)),1.-sat(tent*shp));\n\n  float head = cir(uv-vec2(0.,.1), .4);\n  col = mix(col,red,1.-sat(head*shp));\n\n  vec2 uve = vec2(abs(uv.x),uv.y)-vec2(.25,0.);\n  float eye = cir(uve,.17);\n  col = mix(col,yellow,1.-sat(eye*shp));\n\n  float eyeb = cir(uve,.12);\n  col = mix(col,vec3(0.),1.-sat(eyeb*shp));\n\n  vec2 uvew = vec2(abs(uv.x-.07),uv.y)-vec2(.25,0.07);\n  float eyew = cir(uvew, .03);\n  col = mix(col, vec3(1.),1.-sat(eyew*shp));\n\n  vec2 uver = vec2(abs(uv.x-.15),uv.y)-vec2(.27,-0.15);\n  float eyer = cir(uver,.15);\n  col = mix(col,mix(col,vec3(1.),.3),1.-sat(max(eyer,eye)*shp));\n\n  int i = 0;\n  vec2 uvss = vec2(abs(uv.x),uv.y)-vec2(.37,0.);\n  while (i<5)\n  {\n    float an = float(i-2)*.5;\n    vec2 uvs = uvss+vec2(sin(an),cos(an)*2.)*.23;\n    vec4 spt = spot(uvs);\n    col = mix(col, spt.xyz,1.-sat(spt.w*shp));\n    ++i;\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n  uv*=2.;\n  vec3 col = rdr(uv, mix(40.,400.,sin((uv.x+uv.y)*15.-iTime)*.5+.5));\n  col = post(uv, col);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdccW7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[566, 566, 594, 594, 616], [618, 618, 645, 645, 819], [821, 821, 841, 841, 936], [938, 938, 966, 966, 1339], [1340, 1340, 1370, 1370, 2394], [2396, 2396, 2453, 2453, 2651]]}
{"id": "tstcWN", "name": "vanuatu sand drawing: turtle", "author": "FabriceNeyret2", "description": "cf [url]https://horizonofreason.com/culture/vanuatu-sand-drawings-sandroing/[/url]\nref:\n[img]https://horizonofreason.com/images/sandroings/deacon.jpg[/img]", "tags": ["turtle", "ethnomathematics"], "likes": 12, "viewed": 375, "published": 3, "date": "1600981646", "time_retrieved": "2024-07-30T20:43:37.275198", "image_code": "#define SQR(x)  ( (x)*(x) )\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))   \n#define C0(U,v,h) max(0., 1. - abs( length( U ) - v ) *h )\n#define C(X,Y)    C0( U - vec2(X,Y) , .7 , h )\n\nfloat line(vec2 p, vec2 a,vec2 b) { // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, V,\n         U = 4.* ( 2.*u - R ) /R.y; U.y-= .5;\n    float h = R.y/12., l = 1e5;\n    O-=O;\n                                                                // --- all circles + arcs\n#  define C4(X)    C(X,.5) + C(X,1.5) + C(X,-.5) + C(X,-1.5)    // column of 4 circles\n    O += C4(.5) + C4(-.5);\n    U.x = abs(U.x);\n    if ( abs(U.y) < 2.) O += C(.5,2.5) + C(.5,-2.5);\n    if (U.x<1.) O += C4(1.5);\n    \n                                                                // lemniscate\n#   define L(Y) if (U.x>1.) V = U-vec2(1,Y), V *= V*3., V.y*=2.,  l = min(l, .1*sqrt(abs((V.x+V.y)*(V.x+V.y)-(V.x-V.y))) -.005 )\n    for (float j,i=-2.; i<2.; i++) {                            // --- lines + small loops\n        l = min(l, line(U, vec2(0, i ), vec2(1.5,1.5+i)) ),\n        j = i == -1. ? 2. : i==-2. ? 0. : i,\n        l = min(l, line(U, vec2(0, j ), vec2(1.5,-1.5+j)) );\n        L(i);\n    }\n    l = min(l, line(U, vec2(.5,-2.5), vec2(1.5,-1.5)) );\n    l = min(l, line(U, vec2( 1, 2  ), vec2(1.5, 1.5)) );\n    l = min(l, line(U, vec2( 0,-2  ), vec2( .5,-2.5)) );\n    l = min(l, line(U, vec2( 0,-1  ), vec2(1.2,-2.2)) );\n    L(2);\n                                                                // --- head and tail: Bernouilli lemniscate\n    if (U.y<-2.) V = SQR( U-vec2(0,-2) )*3., V.x*=2.,  l = min(l, .1*sqrt(abs(SQR(V.x+V.y)-(V.y-V.x))) -.005 );\n    if (U.y> 2.) V = SQR( U-vec2(0, 2) )*.7, V.x*=2.,  l = min(l, .1*sqrt(abs(SQR(V.x+V.y)-(V.y-V.x))) -.005 );\n\n    O += max(0., 1. - l * h);\n                                                                // --- shell: Joukovsky airfoil\n    if ( U.y <-2.  ) O += C0( ( U - vec2(0,-2.4) )*vec2(1,1.7), 1.2 , h/1.3 );\n    if ( U.y < 2.5 ) O += C0( ( U * vec2(1.5,1)  )            , 3.4 , h/1.5 );\n    O += Joukowsky((U-vec2(2.1, 1.2))*rot(-.3) *vec2(-1.7,1.7), vec2(-.1,.7), 1.5) / h/3.; // --- fins\n    O += Joukowsky((U-vec2(1.3,-3.2))*rot(-1.) *vec2(-2,2)    , vec2(-.1,.7), 1.5) / h/3.; \n}", "image_inputs": [], "common_code": "// Joukowsky inverse transform : cf https://www.shadertoy.com/view/wdtyDM\n\n// complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n//#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n#define sat(x) clamp(x,0.,1.)\n\nfloat Joukowsky(vec2 U, vec2 C, float r) {\n    vec2 V1 = .5*( U + cpow( cmul(U,U) - 4., .5) ), // z² - Z.z + 1 = 0 (  Z = z + 1/z )\n         V2 = U - V1;           \n    return   1./abs( max( length(C-V1), length(C-V2) ) - r );\n        //   1./abs(length(C-V1)-r) \n        // + 1./abs(length(C-V2)-r);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 220, 261, 432], [434, 434, 472, 472, 2440]]}
{"id": "3stcDN", "name": "Morphing sphere- Fwidth Edges", "author": "hazenn", "description": " abs(ddx(x)) + abs(ddy(x)).", "tags": ["raymarching"], "likes": 2, "viewed": 385, "published": 3, "date": "1600972763", "time_retrieved": "2024-07-30T20:43:38.134899", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nfloat smin( float a, float b)\n{\n\n    return smin(a,b,25.);\n}\n\nstruct RM{\n    float d;\n    int steps;\n};\n\nconst float Dstrt = 3.;\nconst vec3 sc = vec3(0,1,0);\n\n\n\n\n\n\nfloat GetDist(in vec3 p){\n    float d = MAX_DIST;\n    \n    d = min(\n        d,\n        sdSphere( p - sc, 0.5 )\n    );\n\td = d - 0.3*length(smooth_fract(p + iTime, 0.5));\n    float d1 = d;\n    float d2 = sdBox(p-sc,vec3(1.,1.,1.));\n    float t = abs(cos(0.2*iTime));\n    return t*d1 + (1.-t)*d2; //simple lerp between distance fields. \n}\n\n\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1,0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n    \n}\n\nRM RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    int steps = 0;\n    for(int i=0;i<MAX_STEPS;i++){\n        steps = i;\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if (d0>MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return RM(d0,steps);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n   \t\n    //rotate around 010\n    float an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 5.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    // Raymarch\n    RM rm = RayMarch(ro,rd);\n    float d = rm.d;\n    \n    \n    \n    \n    vec3 col = vec3(0);\n\t\n    col += 0.05*d;\n    //normals\n    col += 0.4 + 0.4*GetNormal(ro+rd*d);\n    // Fake AO\n    col -= 0.05*float(rm.steps);\n    // Fwidth edges\n    col.gbr += 10.*fwidth(rm.d);\n    // Background color\n    if (d > MAX_DIST) col = vec3(0.1,0.1,0.1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "mat4 rot(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 linear_transform(vec3 p, mat4 m) {\n    return (m*vec4(p,0)).xyz;\n}\nvec3 affine_transform(vec3 p, mat4 m) {\n    return (m*vec4(p,1)).xyz;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 smooth_fract( vec3 p, float k) {\n    vec3 x = fract(p);\n    vec3 t = step(vec3(k,k,k),x);\n    return t * x + (1.-t) * k * smoothstep(1.,0.7,x);\n    \n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 110, 184], [185, 185, 216, 216, 245], [349, 349, 374, 374, 684], [688, 688, 711, 711, 894], [896, 896, 926, 926, 1179], [1185, 1185, 1242, 1242, 2045]]}
{"id": "3dtyD4", "name": "13 knot rope / arithmetic rope", "author": "FabriceNeyret2", "description": "key 0..9 to swap push knots\nmaking rectangle and equilateral triangles just with a rope with 13 equally spaced knots.\nrect: push away knots 0, 3, 7 (i.e. sides = 3,4,5 units ).\nequi; knots 0,4,8\ncf [url]https://en.wikipedia.org/wiki/Arithmetic_rope[/url]\n", "tags": ["simulation", "geometry", "ethnomathematics"], "likes": 15, "viewed": 938, "published": 3, "date": "1600967181", "time_retrieved": "2024-07-30T20:43:39.006569", "image_code": "float line(vec2 p, vec2 a,vec2 b) {                 // --- distance to line. https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.); // proj coord on line\n    return length(p - b * h);                       // dist to segment\n}\n\nvec4 char(vec2 p, int c) {                          // --- draw char. https://www.shadertoy.com/view/llySRh\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n\nvoid mainImage( out vec4 O, vec2 u )               // === diplay knoted rope\n{\n    vec2 R = iResolution.xy, P, o,\n         U = ( 2.*u - R ) / R.y;\n    \n    O -= O;\n    float l = 1e5, p = 1e5, d; int _i;\n    for (int i=0; i<N; i++) {\n        P = P(i).xy, d = length( P - U ) - .02;\n        o = 1.2 * normalize(P);\n        if (i>9) O += char( (U-P) * 12. -vec2(-.9,-.5) - o , 48+i/10 ); // knot number\n                 O += char( (U-P) * 12. -vec2(-.4,-.5) - o , 48+i%10 ); \n        if ( d < p ) p = d, _i =i;                  // current knot\n        l = min(l, line( U, P(i).xy, P(i+1).xy ) ); // rope segment\n    }\n    O = O.xxxx; \n    l = min(l,p);\n    O += smoothstep(3./R.y,0.,l );                  // display knot or rope\n    if (l==p && P(_i).z > 0. ) O.gb *= 0.;          // pushed knot: red\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define spring( v, l0)  3.* ( length( v ) - l0 ) * normalize( v ) \n#define keyDown(a)      ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define shift           ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl            ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt             ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n#define modifier        ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\nvec2 Newton( vec2 P, int i , float w ) {\n    vec2 F =   .2* w * normalize(P)                   // radial pressure\n              + spring( P(i-1).xy - P , L )           // l0-length spring with neighborhs\n              + spring( P(i+1).xy - P , L );\n    return .1* F;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u -= .5;\n    if ( u.y>1. || u.x >= n ) return;\n    int i = int(u.x);\n    O = texelFetch( iChannel0, ivec2(u), 0 );         // restore states\n\n    if (u.y>0.) {                                     // --- manage keyboard: keys 0-9 + shift\n      if ( iFrame < 1 ) {                             // default state ( init pushed knots )\n          O = vec4( i==0 || i == 3 || i == 7 );       // knots 0,3,7 : rectangle triangle \n       // O = vec4( i==0 || i == 4 || i == 8 )        // knots 0,4,8 : equilateral triangle \n      } else\n#if 1                                                 // < 20 knots\n          if (keyDown(48+i%10) && ( i>9 ? shift : !shift )) O = 1.-O; // flip state\n#else                                                 // up to 40 knots\n          if (        keyDown(48+i%10) \n              && (    i/10==0 && modifier==0 \n                   || i/10==1 && modifier==1\n                   || i/10==2 && modifier==2\n                   || i/10==3 && modifier==4\n             )   ) O = 1.-O;                          // flip state\n#endif\n          return;\n      }\n\n    if ( iFrame < 1 ) {                               // --- init knots along the rope\n        O.xy = .5* cos( 6.28*u.x/n + vec2(0,11) );\n        O.zw = vec2(0);\n        return;\n    }\n       \n    vec2 P = O.xy;                                    // --- simulate forces on the knots\n    #define push texelFetch(iChannel0, ivec2(i,1), 0).r\n    O.z = push;                                       // memo for display pushed ones\n    \n    // P += Newton( P, i , push );                    // semi-Newton\n    O.xy += Newton( P, i , push );                    // Newton \n    \n // P-=P; for(int i=0; i<N; i++) P += P(i).xy / 13.; // --- recenters \n    P-=P; for(int i=0; i<N; i++) if ( push > 0. ) P += .01 * normalize(P(i).xy);     \n    O.xy -= P;\n    \n    if (push>0.)                                     // --- time jitter\n        O.xy += .001*cos( 20.*iTime + 6.28*fract(1e4*sin(1e4*u.x)) + vec2(0,11));\n     // O.xy += .003*cos( .3*iTime + 6.28*fract(1e4*sin(1e4*dot(O.xy,vec2(1,17)))) + vec2(0,11));\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float n = 12.,   // number of knots\n            L = 3.6/n; // segment length\nconst int   N = int(n);\n\n#define P(i) texelFetch( iChannel0, ivec2( (int(i)+N)%N , 0 ), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 114, 281], [283, 283, 309, 390, 621], [623, 623, 701, 701, 1422]]}
{"id": "wt2yD3", "name": "FIRE", "author": "Leasel", "description": "This shader can be used 2D fires. These fires will mostly be used with one texture channel and then interpolating the color in the image with that same one channel value.", "tags": ["buffers"], "likes": 2, "viewed": 341, "published": 3, "date": "1600951933", "time_retrieved": "2024-07-30T20:43:39.852308", "image_code": "\n#define RedChannel vec3(1, 0.2, 0.2)\n#define GreenChannel vec3(1,1,0)\n#define BlueChannel vec3(1,0.2,0.1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 nothing = vec3(0);\n    fragColor = vec4(mix(mix(mix(nothing, RedChannel, texture(iChannel0,uv).r), GreenChannel, texture(iChannel0,uv).g), BlueChannel, texture(iChannel0,uv).b), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_Dif = 1./iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = \n       (texture(iChannel0, uv + uv_Dif.xy).rgb + \n        texture(iChannel0, uv - uv_Dif.xy).rgb + \n        texture(iChannel0, uv + vec2(uv_Dif.x,0)).rgb + \n        texture(iChannel0, uv - vec2(uv_Dif.x,0)).rgb + \n        texture(iChannel0, uv + vec2(0,uv_Dif.y)).rgb + \n        texture(iChannel0, uv - vec2(0,uv_Dif.y)).rgb + \n        texture(iChannel0, uv + vec2(-uv_Dif.x,uv_Dif.y)).rgb + \n        texture(iChannel0, uv + vec2(uv_Dif.x,-uv_Dif.y)).rgb)*0.125;\n\n    fragColor = vec4(col,0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n#define Speed 3.\n\n#define Cool 0.05\n#define CoolSpeed 80.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = clamp(texture(iChannel0, uv - vec2(0., 1./iResolution.xy*Speed)) - Cool*texture(iChannel1, uv - vec2(0., 1./iResolution.xy)*iTime*CoolSpeed), 0., 1.) + max(vec4((1.-length(fragCoord - iMouse.xy)/50.)),0.);\n}", "buffer_b_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 165, 165, 401]]}
{"id": "Ws3yW4", "name": "A man from \"A LOST MEMORY\"", "author": "iY0Yi", "description": "A man from my shader art piece \"A LOST MEMORY\".\n[url]https://iy0yi.me/work/a-lost-memory/[/url]\nSorry for the long compiling time!\nAnd this can run only under a 32bit float environment.", "tags": ["npr", "human", "alostmemory"], "likes": 157, "viewed": 2708, "published": 3, "date": "1600911880", "time_retrieved": "2024-07-30T20:43:41.021183", "image_code": "//////////////////////////////////////////////////////////////////////////////////////////\n//  .--.   .-.    .--.  .--. .-----.  .-..-. .--. .-..-. .--. .---. .-..-.              //\n// : .; :  : :   : ,. :: .--'`-. .-'  : `' :: .--': `' :: ,. :: .; :: :: :              //\n// :    :  : :   : :: :`. `.   : :    : .. :: `;  : .. :: :: ::   .'`.  .'              //\n// : :: :  : :__ : :; : _`, :  : :    : :; :: :__ : :; :: :; :: :.`. .' ;               //\n// :_;:_;  :___.'`.__.'`.__.'  :_;    :_;:_;`.__.':_;:_;`.__.':_;:_;:_,'                //\n//                                                                                      //\n//  A man from \"A LOST MEMORY\" by iY0Yi                                                 //\n//  https://www.shadertoy.com/view/Ws3yW4                                               //\n//                                                                                      //\n//  Created by Atsushi Hashimoto 2020                                                   //\n//                                                                                      //\n//  This is a part of my shader art piece \"A LOST MEMORY\":                              //\n//  https://iy0yi.me/work/a-lost-memory/                                                //\n//                                                                                      //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n\n// Effect pass\n\n//#define DEBUG_PASSES\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// Read data from BufA\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).x).xyz), res , strength);\n}\n\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readSharpenAO(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).z *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).z *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).z, res , strength);\n}\n\n\n// NPR effects\n// Maybe, you can better ways for these effects in somewhere else...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 8.);\n    vec2 p = fragCoord;\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=saturate(floor(res*6.)/5.);\n\n    return res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2)\n{\n    vec2 difN = abs(nlm1.xy - nlm2.xy);\n    return smoothstep(.41, .3, difN.x + difN.y);\n}\nfloat getOutline(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    vec3 offset = vec3(1, -1, 0) * .5;\n    float edge = 1.0;\n    edge *= calcEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= calcEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= calcEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= calcEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.25, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = max(.65,shadow*.85) + .35*readAO(fragCoord);\n    shadow = 1. - shadow;\n    res = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n    res = smoothstep(.0, .2, pow(res, .05));\n    return res;\n}\n\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    // tickness /= f+PI;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n    shading = mix(shading, (1.-shading)*.3+.7*readAO(fragCoord), 1.-readShadow(fragCoord));\n    shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = originalSigmoidContrast(shading*.95+.05*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    if(readDepth(fragCoord)>.9)\n    return 1.;\n\n    float ln = 1.;\n    const float mul = 1.;\n        ln*= pow(hatching(fragCoord, 4.*mul, .6, .6, .8, true), 10.);\n        ln*= pow(hatching(fragCoord, 3.5*mul, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5*mul, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    // tickness /= f+PI;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    //shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n\tshading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.7+.3*readAO(fragCoord);\n    shading = smoothstep(.3, 1., shading);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n\tif(readDepth(fragCoord)>.9)\n        shading = 1.;\n    \n    col*=dithering(shading+smoothstep(.3, .9, readDepth(fragCoord)*.6)*.25, fragCoord);\n\n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n    col*=.65+.25*shading;\n    col+=fbm(fragCoord*.5, 3)*.05;\n    col*= getHatching(fragCoord);\n    \n    col *= getOutline(fragCoord);\n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n\n    col *= dithering(pow(saturate(readSharpenAO(fragCoord, 2.)), 1.5), fragCoord);\n    vec3 albedo = readAlbedo(fragCoord);\n    col*= albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.1)\n    {\n    \tcol+=dithering(spec, fragCoord);\n    \tcol+=getHatchingSpecular(fragCoord);\n    }\n    col*=.8+.2*pow(1.-smoothstep(.0, 2., readDepth(fragCoord)), 3.);\n\n    col*= dithering(noise(fragCoord*.18+iTime*5.)+noise(fragCoord*.15-iTime*5.)+.8, fragCoord);\n    col+= 1.-dithering((1.-noise(fragCoord*.3+iTime*5.)*noise(fragCoord*.1-iTime*5.))+.8, fragCoord);\n\n    col *= vec3(.5+.5*smoothstep(.8, .5, readDepth(fragCoord)));\n\n    col = pow(col, vec3(.4545));\n    col = pow(col, vec3(.4545)); // intended one...\n    \n    fragColor = vec4(col, 1.);\n    \n#ifdef DEBUG_PASSES\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getOutline(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n\n    fragColor.w = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#pragma optimize(off)\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ZERO min(0,iFrame)\n#define CHARM min(0,iFrame) /* about 6 sces faster compilation... */\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Data Paker/Unpacker\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack(x) unpackSnorm3x10(floatBitsToUint(x))\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n", "buffer_a_code": "// Ray marching pass\n\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define MAT_SHOE_LACE vec3(0.1265, 0.9774, 0.8157)\n#define MAT_SKIN vec3(0.4743, 0.9774, 0.7076)\n#define MAT_PANTS vec3(0.5000, 1.0000, 0.6375)\n#define MAT_WALL vec3(0.7874, 0.6056, 0.6457)\n#define MAT_SHOE vec3(0.8900, 0.5034, 0.4153)\n#define MAT_TOPS vec3(0.4675, 0.7156, 0.8073)\n#define MAT_FLOOR vec3(0.6986, 0.8128, 0.8900)\n#define AMB_COL vec3(0.7874, 0.6056, 0.6457)\n\n//#define SHOW_SHOE\n\nvec3 ro = vec3(0), rd = vec3(0), col = vec3(0), camup, ldir = normalize(vec3(-.5, 1.,-.85));\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per)\n{\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionStep(float a, float b, float r, float n)\n{\n    float s = r/(n+1.);\n    float u = b-r;\n    return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nfloat fOpSubstraction(in float a,in float b)\n{\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r)\n{\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\nvoid pElongate(inout float p, in float h )\n{\n    p = p-clamp(p,-h,h);\n}\n\nvoid pRepPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n}\n\n// Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdFoot(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#ifdef SHOW_SHOE\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = 0.;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.05*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n\td = fOpUnion(sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d, 0.1438);\n\td = fOpSubstractionSmooth(sdBox(cpFoot_Main+vec3(0.0000, 0.1085, 0.0000), vec3(0.1676, 0.1089, 0.2519)), d, 0.0080);\n\td = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d, 0.0100);\n\td = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d);\n\td = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d, 0.0100);\n\tres = v4OpUnion(vec4(d,vec3(0.8900, 0.5034, 0.4153)), res);\n\td = MAX_DIST;\n\t// Shoe lace\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d);\n\tres = v4OpUnion(vec4(d,vec3(0.1265, 0.9774, 0.8157)), res);\n\treturn res;\n}\n\nvec4 sdHand(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.1000)), bsr=0.1500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(0.0010, -0.0040, 0.0686), vec3(-0.0288, 0.0000, 0.0000)), vec3(0.0688, 0.0519, 0.0687)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(0.0351, 0.0504, 0.2394), vec3(0.6982, -0.1114, -0.0032)), vec3(0.0219, 0.0219, 0.0217)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(-0.0359, 0.0375, 0.2293), vec3(0.6982, 0.2210, -0.0032)), vec3(0.0219, 0.0219, 0.0217)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(-0.0964, 0.0273, 0.1847), vec3(0.6982, 0.4986, -0.0032)), vec3(0.0170, 0.0170, 0.0168)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0264, 0.0006, 0.1607), vec3(0.3540, -0.1114, -0.0032)), vec3(0.0156, 0.0156, 0.0311)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0176, -0.0145, 0.1488), vec3(0.3540, 0.2210, -0.0032)), vec3(0.0156, 0.0156, 0.0311)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0657, -0.0072, 0.1285), vec3(0.3540, 0.4986, -0.0032)), vec3(0.0121, 0.0121, 0.0241)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0732, 0.0290, 0.0942), vec3(0.5542, -0.2213, 0.1170)), vec3(0.0176, 0.0176, 0.0361)), d, 0.0250);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0966, 0.0611, 0.1302), vec3(0.5976, 0.0302, 0.2065)), vec3(0.0241, 0.0241, 0.0264)), d, 0.0250);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0320, 0.0270, 0.2116), vec3(0.6982, -0.1114, -0.0032)), vec3(0.0166, 0.0166, 0.0277)), d, 0.0223);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0297, 0.0141, 0.2021), vec3(0.6982, 0.2210, -0.0032)), vec3(0.0166, 0.0166, 0.0277)), d, 0.0223);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0865, 0.0100, 0.1666), vec3(0.6982, 0.4986, -0.0032)), vec3(0.0128, 0.0128, 0.0214)), d, 0.0223);\n\tres = v4OpUnion(vec4(d,vec3(0.4743, 0.9774, 0.7076)), res);\n\treturn res;\n}\n\nvec4 sdHead(vec3 p){\n\treturn vec4(sdSphere(p+vec3(0.0000, -0.1000, 0.0000), 0.0646), vec3(0.4743, 0.9774, 0.7076));\n}\n\nvec4 sdHip(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpHip = p;\n\tvec3 cpHip_mir0_Pos = max(vec3(0), sign(cpHip));\n\tvec3 cpHip_mir0_Neg = max(vec3(0),-sign(cpHip));\n\tcpHip.x = pMirror(cpHip.x, 0.0050);\n\t{\n\t\tvec3 q=cpHip;\n        vec3 pq=p;\n        pq.xy*=mat2(cos(1.9*vec4(0,5,8,0)));\n        q.y+=cos(pq.y*5.)*.1*sin(p.x*20.)*.1;\n        q.x+=sin(p.y*5.)*.25*cos(pq.x*15.)*.1;\n        cpHip=q;\n\t}\n\n\td = fOpUnion(sdEllipsoid(rot(cpHip+vec3(-0.1456, -0.1908, 0.0040), vec3(0.0000, 0.0000, 0.4597)), vec3(0.1544, 0.1207, 0.1090)), d);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdLowerArm(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1200, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpLowerArm = p;\n\n\td = fOpUnion(sdEllipsoid(cpLowerArm+vec3(0, 0.1393, 0), vec3(0.1054, 0.2352, 0.1054)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpLowerArm, vec3(0.1191, 1.1406, 0.9428)), vec3(0.1168, 0.1070, 0.1070)), d, 0.0500);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdLowerLeg(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1500, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpLowerLeg = p;\n\tvec3 cpLowerLeg_mir0_Pos = max(vec3(0), sign(cpLowerLeg));\n\tvec3 cpLowerLeg_mir0_Neg = max(vec3(0),-sign(cpLowerLeg));\n\tcpLowerLeg.x = pMirror(cpLowerLeg.x, 0.0000);\n\t{\n\t\tvec3 q=cpLowerLeg;\n        vec3 pq=p;pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cpLowerLeg=q;\n\t}\n\td = fOpUnion(sdEllipsoid(rot(cpLowerLeg+vec3(0.0240, 0.1194, -0.0009), vec3(0.0000, 0.0004, -0.0041)), vec3(0.1450, 0.2824, 0.1450)), d);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0164, 0.0039, -0.0422), vec3(0.1978, 0.0000, -3.1416)), vec2(0.1025, 0.0102), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0088, 0.0352, -0.0548), vec3(0.5139, -0.0273, 0.0000)), vec2(0.0913, 0.0114), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0129, 0.0511, -0.0293), vec3(0.0638, -0.0185, 0.0000)), vec2(0.1024, 0.0096), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdConeSection(rot(cpLowerLeg+vec3(0.0000, 0.3047, 0.0000), vec3(0.0000, 0.0008, -0.0040)), 0.1353, 0.1402, 0.0670), d, 0.0601);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdSodeguchi(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.0750;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpSodeguchi = p;\n\n\tvec3 cpSodeguchi_Mizo = cpSodeguchi;\n\tpRepPolar(cpSodeguchi_Mizo.xz, 19.0000);\n\n\td = fOpUnion(sdTorus(cpSodeguchi, vec2(0.0496, 0.0310)), d);\n\td = fOpUnionSmooth(sdCappedCylinder(cpSodeguchi, vec2(0.0370, 0.0370)), d, 0.0100);\n\td = fOpUnionSmooth(sdCapsule(rot(cpSodeguchi_Mizo+vec3(-0.0380, 0.0266, 0.0000), vec3(0.1747, 0.0000, 0.0000)), 0.0020, 0.0543), d, 0.0010);\n\td = fOpUnionSmooth(sdTorus(cpSodeguchi+vec3(0.0000, 0.0852, 0.0000), vec2(0.0393, 0.0045)), d, 0.0250);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdTorso(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, -0.3500, 0.0000)), bsr=0.4250;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpTorso = p;\n\t{\n\t\tvec3 q=cpTorso;vec3 pq=p;\n        pq.xy*=mat2(cos(-.25+vec4(0,11,33,0)));\n        q.z+=fbm(vec2(pq.z*1.5,pq.y*10.+sin(pq.z*13.)*.25), 1)*.125*(1.-smoothstep(0.,1.,q.y));\n        q.x+=fbm(vec2(pq.x*1.5,pq.y*10.+sin(pq.x*13.)*.25), 1)*.075*(1.-smoothstep(0.,1.,q.y));\n        cpTorso=q;\n\t}\n\tvec3 cpTorso_Elongate = cpTorso;\n\tcpTorso_Elongate.xyz += vec3(-0.0577, -0.0147, -0.0036);\n\tcpTorso_Elongate.xyz = rot(cpTorso_Elongate, vec3(0.0000, 0.0000, 0.2252));\n\tpElongate(cpTorso_Elongate.x, 0.1000);\n \n\td = fOpUnion(sdEllipsoid(rot(cpTorso+vec3(-0.0501, -0.0879, -0.0794), vec3(0.2961, 0.0000, 0.0000)), vec3(0.2447, 0.1408, 0.1837)), d);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso_Elongate+vec3(-0.0406, -0.0183, 0.0804), vec3(0.2204, -0.0303, 0.0000)), vec2(0.1647, 0.0776)), d, 0.1720);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpTorso+vec3(0.0000, -0.5773, -0.0088), vec3(0.8164, 0.0000, 0.0000)), vec3(0.2890, 0.2029, 0.1701)), d, 0.4600);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(-0.0417, -0.2882, -0.0229), vec3(0.3365, 1.4599, -0.4932)), vec2(0.1800, 0.0540)), d, 0.1100);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(-0.0736, -0.4293, -0.0080), vec3(-0.4843, 1.5645, -0.3815)), vec2(0.2008, 0.0301)), d, 0.1120);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(0.0594, 0.0184, -0.0297), vec3(-0.2545, 1.4571, 0.1212)), vec2(0.2037, 0.0458)), d, 0.1480);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdUpperArm(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1600, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\td = fOpUnion(sdEllipsoid(p+vec3(0.0000, 0.2187, 0.0000), vec3(0.1173, 0.2786, 0.1173)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0814, 0.0000, 0.0000), vec3(-3.3018, -2.1277, 1.2590)), vec3(0.1273, 0.1165, 0.1165)), d, 0.0500);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdUpperLeg(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1500, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpUpperLeg = p;\n\tvec3 cpUpperLeg_mir0_Pos = max(vec3(0), sign(cpUpperLeg));\n\tvec3 cpUpperLeg_mir0_Neg = max(vec3(0),-sign(cpUpperLeg));\n\tcpUpperLeg.x = pMirror(cpUpperLeg.x, 0.0000);\n\t{\n\t\tvec3 q=cpUpperLeg;\n        vec3 pq=p;pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cpUpperLeg=q;\n\t}\n\n\td = fOpUnion(sdEllipsoid(cpUpperLeg+vec3(-0.0007, 0.0001, -0.0010), vec3(0.1475, 0.1477, 0.1408)), d);\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(0.1774, -0.0475, 0.0664), vec3(0.0716, 0.0717, 0.0684)), d, 0.0421);\n\td = fOpUnionSmooth(sdEllipsoid(cpUpperLeg+vec3(-0.0007, 0.2607, 0.0151), vec3(0.1540, 0.2725, 0.1543)), d, 0.1201);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdMan_Walking(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, -0.9400, 0.0000)), bsr=0.7617;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpMan_Root = p;\n\n\tvec3 cpArm_L = cpMan_Root;\n\tcpArm_L.xyz += vec3(-0.2285, -1.7683, 0.0147);\n\tcpArm_L.xyz = rot(cpArm_L, vec3(-0.0259, -0.4911, -0.5401));\n\n\tvec3 cpArm_R = cpMan_Root;\n\tcpArm_R.xyz += vec3(0.2970, -1.7732, -0.0896);\n\tcpArm_R.xyz = rot(cpArm_R, vec3(0.8591, 0.0411, 0.1902));\n\t{\n\t\tvec3 q = cpArm_R;\n        q.x*=-1.;\n        cpArm_R=q;\n\t}\n\tvec3 cpLeg_L = cpMan_Root;\n\tcpLeg_L.xyz += vec3(-0.1887, -1.0209, 0.0000);\n\tcpLeg_L.xyz = rot(cpLeg_L, vec3(0.2961, -0.0255, 0.0072));\n\t\n\tvec3 cpLeg_R = cpMan_Root;\n\tcpLeg_R.xyz += vec3(0.1440, -1.0291, 0.0000);\n\tcpLeg_R.xyz = rot(cpLeg_R, vec3(-0.4479, -0.0237, -0.0120));\n\t{\n\t\tvec3 q = cpLeg_R;\n        q.x*=-1.;\n        cpLeg_R=q;\n\t}\n\tvec3 cp003_004 = cpArm_R;\n\t{\n\t\tvec3 q=cp003_004;\n        vec3 pq=p;\n        pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*30.)*.01;\n        cp003_004=q;\n\t}\n    {\n\t\tvec3 q=cp003_004;\n        vec3 pq=p;\n        pq.xy *= mat2(cos(noise(pq.xy*vec2(5,1))*PI*.3+vec4(0,11,33,0)));\n        float size = 12.;\n        float strength = .1;\n        q.x+=(fbm(vec2(pq.x*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        q.z+=(fbm(vec2(pq.z*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        cp003_004=q;\n\t}\n\tvec3 cp003 = cpArm_L;\n\t{\n\t\tvec3 q=cp003;\n        vec3 pq=p;\n        pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cp003=q;\n\t}\n    {\n\t\tvec3 q=cp003;\n        vec3 pq=p;\n        pq.xy *= mat2(cos(noise(pq.xy*vec2(2,1))*PI*.3+vec4(0,11,33,0)));\n        float size = 12.;\n        float strength = .1;\n        q.x+=(fbm(vec2(pq.x*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        q.z+=(fbm(vec2(pq.z*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        cp003=q;\n\t}\n#ifndef SHOW_SHOE\n\tres = v4OpUnionSmooth(sdUpperLeg(cpLeg_L), res, 0.0100);\n\tres = v4OpUnionSmooth(sdUpperLeg(cpLeg_R), res, 0.0100);\n\tres = v4OpUnion(sdHead(rot(cpMan_Root+vec3(0.0000, -1.9264, 0.0946), vec3(0.3161, 0.0000, 0.0000))), res);\n\tres = v4OpUnionSmooth(sdHip(rot(cpMan_Root+vec3(-0.0025, -0.8238, -0.1085), vec3(0.0000, 0.2785, 0.0000))), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerLeg(rot(cpLeg_L+vec3(0.0000, 0.4296, 0.0000), vec3(0.3358, 0.0429, 0.0051))), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerLeg(rot(cpLeg_R+vec3(0.0000, 0.4296, 0.0000), vec3(0.3358, 0.0429, 0.0051))), res, 0.0500);\n    const float fY = 1.0400;\n#else\n    const float fY = 1.0350;\n#endif\n\tres = v4OpUnion(sdFoot(rot(cpLeg_R+vec3(0.0122, fY, -0.2127), vec3(0.3358, 0.0429, 0.0051))), res);\n#ifndef SHOW_SHOE\n\tres = v4OpUnion(sdFoot(rot(cpLeg_L+vec3(0.0122, 1.0400, -0.2127), vec3(0.3713, 0.0430, 0.0045))), res);\n\tres = v4OpUnionSmooth(sdSodeguchi(rot(cpArm_L+vec3(0.0494, 0.6329, 0.1930), vec3(-0.6206, 0.0266, 0.3167))), res, 0.0050);\n\tres = v4OpUnionSmooth(sdSodeguchi(rot(cpArm_R+vec3(0.0184, 0.6838, 0.1199), vec3(-0.7478, -0.0227, 0.2680))), res, 0.0050);\n\tres = v4OpUnionSmooth(sdTorso(rot(cpMan_Root+vec3(0.0000, -1.1769, -0.0665), vec3(0.0574, 0.0000, 0.0000))), res, 0.0200);\n\tres = v4OpUnionSmooth(sdUpperArm(cp003), res, 0.0750);\n\tres = v4OpUnionSmooth(sdUpperArm(cp003_004), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerArm(rot(cp003+vec3(0.0000, 0.3702, 0.0000), vec3(-0.6301, -0.2742, -0.1053))), res, 0.0400);\n\tres = v4OpUnionSmooth(sdLowerArm(rot(cp003_004+vec3(0.0000, 0.3702, 0.0000), vec3(-0.3764, -0.1114, -0.0029))), res, 0.0250);\n\tres = v4OpUnion(sdHand(rot(cpArm_L+vec3(0.0702, 0.7357, 0.2618), vec3(0.9016, 0.1943, 0.6602))), res);\n\tres = v4OpUnion(sdHand(rot(cpArm_R+vec3(0.0368, 0.7749, 0.1977), vec3(1.5493, 0.9155, 0.6787))), res);\n#endif\n\treturn res;\n}\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    vec4 grnd = res;\n    if(length(p.xz)<3.) grnd = vec4(p.y+.03, vec3(0.6986, 0.8128, 0.8900)); \n\tres = v4OpUnion(sdMan_Walking(p-vec3(0,0,.025)), grnd);\n    \n    return res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION+CHARM; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+CHARM; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n// iq's soft shadow\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=0.01;\n    float maxt=30.;\n    float k = 64.;\n    float res = 1.;\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 60+CHARM; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return res;//smoothstep(.5, .51, res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=ZERO; i<nbIte+CHARM; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat diffuse = 0.;\nfloat spec = 0.;\nfloat shdw = 1.;\nfloat ao = 1.;\nfloat depth = 0.;\nvec3 albedo = vec3(0);\nvec3 nml = vec3(0);\n\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    albedo = hit.yzw;\n    \n    if (hit.x>=MAX_DIST)\n    {\n        nml = vec3(0);\n        albedo = AMB_COL;\n        spec = 0.;\n        depth = 1.;\n        diffuse = 0.;\n        return;\n    }\n\n    vec3 n = normal(p);\n    vec3 offset = n * .005;\n    \n    // Camera localized normal\n    vec3 up = camup;\n    vec3 side = cross(rd, up);\n    nml.x = dot(n+offset,  side);\n    nml.y = dot(n+offset,  up);\n    nml.z = dot(n+offset,  -rd);\n    \n    diffuse = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert\n    shdw = shadow(p+offset);\n\n    ao = ambientOcclusion(p+n*0.01, n, .5, 2.);\n    ao += ambientOcclusion(p+n*0.01, n, .1, 2.);\n    ao = smoothstep(0., 2., ao);\n    ao = pow(ao, .25);\n\n    depth = distance(ro, p)/MAX_DIST;\n\n    const float thresh = .01;\n    if(!(distance(albedo, MAT_SHOE) < thresh) && !(distance(albedo, MAT_FLOOR) < thresh)) return;\n\n    if(distance(albedo, MAT_SHOE) < thresh)\n    {\n        // Shoe\n        spec = specular(p+offset, n, ldir, 10.);\n    }\n\n    {\n        // Floor\n        vec2 uv = vec2(p.z, p.y);\n\n        vec3 q = p;\n\n        uv.x = q.x;\n        uv.y = q.z;\n        uv.x *= 2.;\n        uv*=1.5;\n\n        int offset = int(uv.x)%2;\n        vec2 ratio = vec2(1,4);\n        float gridGap = 0.001;\n        if(offset==0)uv.y+=ratio.y*.5;\n\n        vec2 id = floor(uv/ratio);\n        uv = mod(uv, ratio)-ratio*.5;\n\n        float d =sdBox(uv, ratio*.5-gridGap);\n        if(noise(uv*5.*id)<.75)\n            diffuse *= step(.1, 1.0 - exp(-8.0*abs(d)));\n        if(noise(uv*90.)<.75)\n        {\n            uv.y+=fbm(uv*16., 2)*.025;\n            uv *= mat2(cos(noise(uv*vec2(5,1)+id)*PI*.3+vec4(0,11,33,0)));\n            diffuse *= smoothstep(.4, .5, abs(sin(uv.x*40.)));\n        }\n\n    }\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid camera(vec2 uv)\n{\n#ifdef SHOW_SHOE\n    const float pY = .5;\n    const float cL = 2.;\n    const vec3 forcus = vec3(-.15,.1,-.34);\n    const float fov = .08;\n#else\n    const float pY = 1.;\n    const float cL = 9.;\n    const vec3 forcus = vec3(0,1,0);\n    const float fov = .125;\n#endif\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = vec2(sin(iTime),cos(iTime))*cL;\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    render();\n\n    vec3 spec_diffuse_ao = vec3(spec, diffuse, ao)*2.-1.;\n    \n    fragColor = vec4(\n        pack4(vec4(nml, shdw)),\n        pack(albedo),\n        pack(spec_diffuse_ao),\n        depth\n    );\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1679, 1720, 1791, 1791, 2104], [2106, 2201, 2227, 2227, 2309], [2311, 2311, 2337, 2337, 2424], [2426, 2426, 2453, 2453, 2538], [2540, 2540, 2566, 2566, 2640], [2642, 2642, 2670, 2670, 2804], [2806, 2806, 2835, 2835, 2969], [2971, 2971, 2994, 2994, 3122], [3124, 3124, 3183, 3183, 4127], [4129, 4129, 4191, 4191, 5112], [5114, 5114, 5175, 5175, 6096], [6098, 6098, 6154, 6154, 7075], [7078, 7234, 7276, 7276, 7791], [7793, 7793, 7831, 7831, 7922], [7923, 7923, 7957, 7957, 8385], [8387, 8387, 8426, 8426, 8575], [8577, 8577, 8616, 8616, 8985], [8987, 8987, 9088, 9088, 10174], [10176, 10176, 10211, 10211, 10544], [10546, 10546, 10655, 10655, 11760], [11762, 11762, 11805, 11805, 12005], [12007, 12079, 12136, 12136, 14831]]}
{"id": "Ws3cW4", "name": "fork-fast-noise-v3-color", "author": "jorge2017a1", "description": "fork-fast-noise-v3-color", "tags": ["forkfastnoisev3color"], "likes": 3, "viewed": 351, "published": 3, "date": "1600908612", "time_retrieved": "2024-07-30T20:43:41.812069", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\n\n\nfloat cnoise4 (const in vec3 xx) \n{\n    vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = random4(N1);\n    vec4 R2 = random4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\nfloat fbm(vec3 p) {\n    float f;\n    f = 0.5000*cnoise4( p ); p = p*2.02;\n    f += 0.2500*cnoise4( p ); p = p*2.03;\n    f += 0.1250*cnoise4( p ); p = p*2.01;\n    f += 0.0625*cnoise4( p ); \n\n  return f;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    \n\tvec3 pw = vec3(0.,0.,10.);\n    \n    vec3 p1=p;\n \tfloat cx=120.0;\n    p1.x = mod(p1.x+0.5*cx,cx)-0.5*cx;\n    \n    float pa = sdBox(p1+pw,vec3(50.,5,5.));\n  \tfloat pb = sdBox(p1-pw,vec3(50.,5,5.));\n    \n    res =opU3(res, vec3(pa,33.0,MATERIAL_NO));  //piso 1\n    res =opU3(res, vec3(pb,32.0,MATERIAL_NO));  //piso 2\n    \n  \tpb = sdBox(p1-pw*2.,vec3(30.,50.,1.0));\n    float pb1 = sdBox(p1-pw*2.,vec3(10.,30.,1.5));\n    \n    pb= differenceSDF(pb, pb1);\n    res =opU3(res, vec3(pb,18.0,MATERIAL_NO)); //frente 2\n    \n    vec3 c = opRep(p1,vec3(20.,4.5,14.))-vec3(0.,0.,7.);\n  \tpa = sdBox(c+pw+vec3(0.,0.,-3.),vec3(1.5,25.,0.5));\n  \tpb = sdBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75));\n    \n    res =opU3(res, vec3(pa,5.0,MATERIAL_NO));  //col ch\n    res =opU3(res, vec3(pb,9.0,MATERIAL_NO));  //columna g\n    \n   res.x= clamp(fbm(p*3.),0.,1.)*0.1+res.x;\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n  \n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\tmObj.blnShadow=false;\n    light_pos1= vec3(0.0, 30.0, -25.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3(0.0, 5.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n    \n  \n    \n    vec3 ro=vec3(t,10.0,-25.0);\n    vec3 rd=normalize(vec3(uv.x, uv.y+0.35*cos(iTime),1.0));\n    \n    light_pos1.x+=ro.x;\n    light_pos2.x+=ro.x;\n    \n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\nif(i== 32 ){ return vec3(0.25, 0.26, 0.25);}\nif(i== 33 ){ return vec3(0.35, 0.36, 0.35);}\n\n\n    \n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 289, 289, 373], [374, 374, 420, 420, 507], [509, 553, 600, 600, 627], [629, 629, 672, 672, 699], [701, 701, 749, 749, 777], [778, 862, 901, 901, 945], [946, 946, 985, 985, 1029], [1030, 1030, 1062, 1062, 1087], [1129, 1169, 1203, 1203, 1300], [1303, 1303, 1332, 1332, 1442], [2064, 2064, 2083, 2083, 2267], [2269, 2309, 2334, 2334, 3378], [3380, 3425, 3492, 3492, 3860], [3861, 3912, 3936, 3936, 4124], [4125, 4188, 4221, 4221, 4663], [4665, 4719, 4755, 4755, 4989], [5046, 5046, 5126, 5126, 5738], [5833, 5833, 5926, 5926, 6029], [6034, 6083, 6140, 6140, 7325]]}
{"id": "wddcWH", "name": "Audio Waveform Visualizer v1", "author": "oneshade", "description": "This visualizes audio waveforms (it sometimes get jagged though). Plus I like some of the music ;)", "tags": ["visualization", "waveform"], "likes": 3, "viewed": 202, "published": 3, "date": "1600902461", "time_retrieved": "2024-07-30T20:43:42.588990", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float currentSample = texture(iChannel0, vec2(uv.x, 0.0)).x;\n    vec3 color = vec3(smoothstep(0.25, 0.0, abs(uv.y - currentSample)));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 271]]}
{"id": "tdtcWH", "name": "Spherical Fib", "author": "percentcer", "description": "B. Keinert et al (https://dl.acm.org/doi/10.1145/2816795.2818131)\n\nTrying to get more practice implementing papers. Work in progress.", "tags": ["sphericalfibonacci"], "likes": 5, "viewed": 425, "published": 3, "date": "1600889587", "time_retrieved": "2024-07-30T20:43:43.407801", "image_code": "#define N 128.\n\n#define MAX_T 10.\n#define GOLDEN 1.618\n#define PI 3.141\n\n// the ith point out of n spherical fibonacci points\n// these are mapped in the 2d space of the sphere\n// returns (phi, theta) to be used with pointOnSphere\nvec2 sfi(float i, float n) {\n    float phi = 2. * PI * fract(i / GOLDEN);\n    float z = 1. - (2. * i + 1.) / n;\n    return vec2(phi, acos(z));\n}\n\nvec3 pointOnSphere(float phi, float theta) {\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\nfloat sphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat map(vec3 p) {\n    float nearest = MAX_T;\n    for (float i = 0.; i < N; i++) {\n        vec2 sp = sfi(i, N);\n        vec3 sp3 = pointOnSphere(sp.x, sp.y);\n        nearest = min(nearest, sphere(p - sp3, .01));\n    }\n    return nearest;\n}\n\nmat3 cam(vec2 direction) {\n    vec3 z = normalize(vec3(direction, 1.));\n    vec3 x = normalize(cross(vec3(0., 1., 0.), z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    vec2 rotp = iMouse.xy / iResolution.xy - 0.5;\n    mat3 rot = cam(rotp * 5.);\n    \n    vec3 ro = rot * vec3(0., 0., 2.0);\n    vec3 rd = rot * normalize(vec3(uv, -1.));\n\n    vec3 col = vec3(0.2);\n    int stepCount = 0;\n    for(float t = 0.; t < MAX_T; stepCount++) {\n        vec3 p = ro + rd * t;\n        float nearest = map(p);\n        if (nearest < .001) {\n            col = vec3(1.);\n            break;\n        } else {\n            t += nearest;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 230, 258, 258, 374], [376, 376, 420, 420, 497], [499, 499, 532, 532, 562], [564, 564, 583, 583, 804], [806, 806, 832, 832, 980], [982, 982, 1039, 1089, 1682]]}
{"id": "tsdcD8", "name": "Quantimnyz Burp", "author": "celifrog", "description": "Original code forked from here:\nhttps://www.shadertoy.com/view/MdXSzS\nThis was fun :D ", "tags": ["space", "weird", "tiny", "super", "awesome"], "likes": 3, "viewed": 283, "published": 3, "date": "1600886333", "time_retrieved": "2024-07-30T20:43:44.191706", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .3 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t-t);\n\tfloat co = cos(t-si+si);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = -11; i+i <160; i++)\n\t{\n\t\tvec3 p = s * vec3(uv+uv-s*uv+uv*uv*uv, 0.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.1, .3, s - 1.5 - sin(iTime *p* -0.03) * -.991);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p*s) / dot(p,p) - 0.9259;\n\t\tv1 += dot(p,p) * .0005 * (1.8 + sin(length(uv.xy*uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(-p*s,p*s*-p+-p+s) * .013 * (1.5 + sin(length(uv.xy*uv.xy*uv.xy * 14.5) + 1.2*v1 - iTime *v2*v1*v1*v1*v1+ .3));\n\t\tv3 += length(p.xy*p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len*len);\n\tv2 *= smoothstep(.5, .10, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime*v3 * 1.2) * .4),\n\t\t\t\t\t(v1 + v3-v3-v3-v3-v3 ) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.5, .6, v3*v1*v2*len+v1*iTime) * .3;\n\n\tfragColor=vec4(min(pow(abs(-col), vec3(1.2)), 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1197]]}
{"id": "WsdyD8", "name": "pathtraced fractal test", "author": "Cewein", "description": "based on a idea from fusha", "tags": ["fractal", "shadow", "volumetric", "pathtracing"], "likes": 5, "viewed": 486, "published": 3, "date": "1600856107", "time_retrieved": "2024-07-30T20:43:44.986580", "image_code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced fractal with real indirect ligthing\n// the fractal is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n//\n// \t\t\t\t\t\t\tYOU CAN MOVE IN THE SCENE WITH YOU MOUSE\n//\n// \tCHECK BUFFER A FOR MOR INFORMATION AND THE CODE\n//\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col /= texture( iChannel0, uv ).w;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    // color grading and vigneting    \n    col = pow( col, vec3(0.8,0.85,0.9) );\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced fractal with real indirect ligthing\n// the fractal is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// \t\t\t\t\t\t\tYOU CAN MOVE IN THE SCENE WITH YOU MOUSE\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n\n\n//global macro\n#define MAXSTEP 64\n#define EPSILON 0.0001\n\nfloat spp = 0.0;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) *vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 cosineDirection( in vec2 st, in vec3 nor)\n{\n    float u = hash( 78.233 + st.yx);\n    float v = hash( 10.873 + st.xy);\n    \n    // method by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n\tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// Scene and primitive SDF function\n\nvoid sphereFold(inout vec3 z, inout float dz)\n{\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5)\n    { \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    else if (r2 < 1.0)\n    { \n\t\tfloat temp = 1.0 / r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz)\n{\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat DE(vec3 z)\n{\n    float scale = 2.75;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 10; n++)\n    {\n\t\tboxFold(z,dr);\n\t\tsphereFold(z,dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 0.0;\n\t}\n\tfloat r = length(z);\n\treturn r / abs(dr);\n}\n\n//compute the distance between all sdf for a given pos and get the propor distance and id mat\nvec2 map(vec3 pos)\n{\n    return vec2(DE(pos), 0.0);\n}\n\n//compute the normal for a given point\nvec3 getNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\n\n//marching function, it send ray into the world and get the proper mat and distance\nvec2 getDistance(vec3 ro, vec3 rd, float dmax)\n{\n    //distance for the origine is x and y is the mat id\n    vec2 dmat = vec2(0.0);\n    \n    for(int i = 0; i < MAXSTEP; i++)\n    {\n        //position along the ray\n        vec3 pos = ro + dmat.x*rd;\n        \n        //get the distance to the nearest sdf surface\n        vec2 eval = map(pos);\n        \n        //if true it mean we are inside a sdf\n        if(eval.x < 0.0001) return dmat;\n        \n        dmat.x += max(eval.x,0.0001);\n        dmat.y = eval.y;\n        \n        //true if out of range and set -1.0 for sky id\n        if(dmat.x > dmax) return vec2(dmat.x, -1.0);\n    }\n    return dmat;\n}\n\n//it is the same as the \"getDistance\" function but it's return 1.0 if no hit and 0.0 if hit\nfloat getShadow(vec3 ro, vec3 rd)\n{\n   float d = 0.002; \n   \n   for(int i = 0; i < MAXSTEP; i++)\n   {\n       vec3 pos = ro + d*rd;\n       \n       float eval = map(pos).x;\n       \n       if(eval < EPSILON) return 0.0;\n       d += max(eval,0.00001);\n       \n       if(d > 20.0) return 1.0;\n   }\n    \n   return 1.0;\n}\n\n//colorization function based on the id\nvec3 getSurfaceColor(float id)\n{\n    if(id < -0.5)\n        return vec3(0.2,0.35,0.9);\n    else\n        return vec3(0.5,0.2,0.1);\n}\n\nvec3 sunDir = vec3(.3,1.0,-0.6);\n\nvec3 sunCol =  1.0*vec3(1.0,0.8,0.6);\nvec3 skyCol =  13.0*vec3(0.2,0.35,0.5);\n\nvec3 renderPixel(vec3 ro,vec3 rd, float sa, vec2 uv)\n{\n    vec3 colorStrengh = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    \n    float fdis = 0.0;\n    \n    //GI bounce\n    for(int nbBounce = 0; nbBounce < 3; nbBounce++)\n    {\n        rd = normalize(rd);\n        //evaluation of distance to the sdf agregate and get the id mat in the same time\n        vec2 dist = getDistance(ro, rd, 10.0);\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //get the intersection position and the normal at this point\n        vec3 pos = ro + dist.x*rd;\n        vec3 norm = getNormal(pos);\n        \n        if(dist.y < 0.0)\n        {\n            if( nbBounce==0 ) { fdis=16.0; accumulatedColor = vec3(0.2,0.35,0.5); break; }\n            break;\n        }\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //surface color\n        colorStrengh *= getSurfaceColor(dist.y);\n        \n        vec3 col = vec3(0.0);\n\n        //lighting\n        //sun\n        float sunSha = getShadow(pos + norm * EPSILON, sunDir);\n\n        //sky\n        float sunDif = max(0.0, dot(norm, sunDir));\n        vec3 skyPoint = cosineDirection( sa + 7.1*float(iFrame) + 5681.123 + float(nbBounce)*92.13 + uv.yx, norm);\n        float skySha = getShadow(pos + norm*EPSILON, skyPoint);\n\t\t\n        //perform bounce accumulation\n        col = sunDif * sunSha * sunCol + skySha * skyCol;\n\t\taccumulatedColor += colorStrengh * col;\n        \n        //perfom the bounce\n        rd = cosineDirection(76.2 + 73.1 * float(nbBounce) + sa + 17.7*float(iFrame) + uv.xy, norm);\n        ro = pos;\n        \n    }\n    \n    float ff = exp(-0.01*fdis*fdis);\n   \taccumulatedColor *= ff; \n   \taccumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n    \n    // volumetrics\n    float dt = 2.;\n    float acc = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float t = fdis*hash(sa+1.31+13.731*float(i)+float(iFrame)*7.773 + uv.yx);\n        vec3 pos = oro + ord*t;\n        acc += dt*getShadow( pos, sunDir );\n    }\n    accumulatedColor += vec3(0.1)*pow(acc,2.0)*sunCol*0.4;\n\n\n    return accumulatedColor;\n}\n\n\n//Ray function\nvec3 getDirection(vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 ww = normalize(target - ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right\n\tvec3 vv = normalize(cross(uu,ww)); //up\n    \n    return normalize(uv.x * uu + uv.y*vv + fov*ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) +  uv);\n    \n    vec2 of = -0.5 + vec2( hash(sa+13.271+uv), hash(sa+63.216+uv) );\n    \n    //mouse detection\n    float angle = iMouse.x/iResolution.x;\n    angle *= 1.2; angle -= 0.1;\n    angle = clamp(angle, 0.,1.0);\n    \n    //ray generation\n    vec3 target = mix(vec3(1.9,-0.1,.0), vec3(1.9,0.1,-.2), angle);\n   \tvec3 ro = mix(vec3(1.21,0.20,-0.6), vec3(1.21,-0.20,0.6), angle);\n    vec3 rd = getDirection(ro,target, uv, 1.5);\n    \n    //get the texture pixel color\n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    float spp = texture( iChannel0, fragCoord/iResolution.xy ).w;\n    if( iFrame==0 || iMouse.z > 0.0) \n    {\n        col = vec3(0.0);\n        spp = 0.0;\n    }\n    \n    //accumulate the rendered pixel into the color\n    col += renderPixel(ro, rd, sa, uv);\n    spp += 1.0;\n    //output the color to the screen\n    fragColor = vec4(col,spp);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 455, 512, 512, 942]]}
{"id": "WddyW8", "name": "3D fbm worley noise", "author": "Jaromir", "description": "3d worley noise for creating 3D ckoud textures. Loopable in all directions.", "tags": ["2d", "3d", "noise", "fbm", "worley"], "likes": 0, "viewed": 545, "published": 3, "date": "1600847848", "time_retrieved": "2024-07-30T20:43:45.728596", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 offset = vec2(iTime*0.05,sin(iTime*0.05));\n    \n\tvec3 col = texture(iChannel0,uv+offset).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 hash33(vec3 p3)\n{\n\tvec3 p = fract(p3 * vec3(.1031,.11369,.13787));\n    p += dot(p, p.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x+p.z)*p.y, (p.y+p.z)*p.x));\n}\n\nfloat worley(vec3 p, float scale){\n\n    vec3 id = floor(p);\n    vec3 fd = fract(p);\n\n    float n = 0.;\n\n    float minimalDist = 1.;\n\n\n    for(float x = -2.; x <=2.; x++){\n        for(float y = -2.; y <=2.; y++){\n            for(float z = -2.; z <=2.; z++){\n\n                vec3 coord = vec3(x,y,z);\n                vec3 rId = hash33(mod(abs(id+coord),scale))*0.33;\n\n                vec3 r = coord + rId - fd; \n\n                float d = dot(r,r);\n\n                if(d < minimalDist){\n                    minimalDist = d;\n                }\n\n            }//z\n        }//y\n    }//x\n\n  return minimalDist;\n}\n\n\nfloat fbm(vec3 p,float scale){\n  float G = exp(-0.3);\n  float amp = 1.;\n  float freq = 1.;\n  float n = 0.;\n    \n  for(int i = 0; i <5; i++){\n    n+= worley(p*freq,scale*freq)*amp;\n    freq*=2.;\n    amp*=G;\n  }\n    \n  return n*n;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float scale = 2.;\n    uv*=scale;\n    \n    vec3 p = vec3(uv,iMouse.x/iResolution.x*5. + iTime*0.1);\n        \n    float n = fbm(p,scale);\n    \n    vec3 col = vec3(1.-n);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]]}
{"id": "WdtyW8", "name": "Jittered Super Sampling", "author": "GregRostami", "description": "Jittered super sampling\nUse 1 to 9 on keyboard to set the super-sampling level - The default is 4 (16 samples/pixel).\nHold left Mouse button to toggle animation.\nSpace-bar toggles on/off jittered sampling.", "tags": ["supersampling", "jitter"], "likes": 9, "viewed": 599, "published": 3, "date": "1600844463", "time_retrieved": "2024-07-30T20:43:46.482580", "image_code": "// I borrowed the raytracer that Fabrice had created (for higher precision in the checker sampling).\n\n// Jittered super sampling\n// Use 1 to 9 on keyboard to set the Anti-Aliasing value (The default is 4 (16 samples/pixel))\n// Hold left Mouse button to toggle animation.\n// Space-bar toggles on/off jittered sampling.\n\nbool T (int c){return texelFetch(iChannel1,ivec2(c,2),0).x > 0.;}\n\nvoid lookAt(inout vec3 ro, inout vec3 rd, vec3 tg) {\n    vec3 ot = normalize(tg - ro),\n         up = vec3(0, 1, 0),\n         rr = normalize(cross(ot, up));\n         up = cross(rr, ot);\n    rd = mat3(rr, up, ot) * rd;\n}\n\nfloat checker(vec3 p, float t) {\n    p -= iMouse.z > 0. ? 0. : .4*iTime;\n    p = floor(p);    return float( mod(p.x + p.z, 2.) > 0. ); // base checkers\n}\n\nvec4 fC( vec2 u ) {\n    vec3 R = iResolution,\n         p = vec3(0, 3.5, 15),           // setup camera\n         D = normalize( vec3( ( u+u - R.xy ) / R.y, 1) ); \n         lookAt(p, D, vec3(0));                                   // --- true ray-tracing\n    float t = p.y  / D.y; p += t * D; \n\n    return vec4( vec3(checker(p, t)), 0 ); // return color & texture at hit point\n}\n\n// Do jittered super sampling \nvoid mainImage( out vec4 o, vec2 u )\n{\n    o *= 0.;\n    int AA = int(texelFetch(iChannel0,ivec2(0,0),0).r),\n        x = 0, y;\n        \n    vec2 O,N;\n    \n    float A = float (AA);\n    \n    for (;x++<AA;) for (y=0; y++<AA;)\n        O = u + vec2(x,y)/A - .5,\n        N = T(32) ? vec2(0) : fract(sin((O)*mat2(127.1,311.7, 269.5,183.3)) * fract(iTime)*15467.289) / A ,\n        \n        o += min ( fC(O+N), 1.0 );\n        \n\to = pow (o/(A*A),vec4(.455));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define k(a) ( texelFetch(iChannel3,ivec2(a,1),0).x > 0. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    if ( iFrame == 0 ) { O = vec4(4); return; }\n    \n    if (U.y>1.) return;\n    O = texelFetch(iChannel0,ivec2(U),0);   \n    \n \tint x = int(U.x);  \n    if ( x == 0 ) {\n        for (int i=1; i<10; i++)\n            if (k(48+i)) O.r = float(i);  \n     }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 334, 334, 384], [386, 386, 438, 438, 604], [606, 606, 638, 638, 759], [761, 761, 780, 780, 1136], [1138, 1169, 1207, 1207, 1619]]}
{"id": "3d3yW8", "name": "Mesmerizing interlocked moebius ", "author": "machmuel", "description": "Interlocked moebius strips built on Martijn Steinrucken´s great demonstration.", "tags": ["raymarching", "torus", "moebius"], "likes": 19, "viewed": 497, "published": 3, "date": "1600785740", "time_retrieved": "2024-07-30T20:43:47.285434", "image_code": "// based on Martijn Steinrucken´s (aka The Art of Code/BigWings) \n// ray marching sample and trefoil knot sample\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.1415926\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat profile(vec2 p, float radians, float phase) { \n    p.x = abs(p.x)-.05*abs(sin(2.*p.y)); //sin is for some warp in the x direction\n    if (p.y>0.) {\n        p.y = abs(p.y);\n    }\n    else{\n        //p.y = abs(p.y) - .1-.4*pow(abs(sin(phase+radians*4.25)), 9.);\n        p.y = abs(p.y) -.4 + .3*sqrt(1.-pow(acos(cos((phase*2.+radians*10.5)))/PI/.9,4.));\n    }\n    return length(max(p, 0.))+min(max(p.x, max(p.x, p.y)), 0.);\n}\n\nfloat sdMoebius(vec3 p, vec3 s) {\n    float rMax= 1.4;\n    float rMin= .2;\n    \n    float radians = atan(p.x, p.z);\n    mat2 rotMat = Rot(iTime*PI-radians*0.250);\n    mat2 rotMat2 = Rot(PI/2.);\n    vec2 cp= vec2(length(p.xz)-rMax, p.y); \n    cp *= rotMat;\n    vec2 cp2 = cp*rotMat2;\n    cp.y = abs(cp.y)-.4;\n    cp2.y = abs(cp2.y)-.4;\n    //float d= length(cp)-rMin; // formula to have a circle as cross section\n    \n    float d= profile(cp, radians, PI/2.);\n    cp.y = abs(cp.y)-0.4;\n    float d2=  profile(cp2, radians, 0.);\n\treturn min(d-.1,d2-.1);\n    //return min(d-.0,d2-.0);\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdMoebius(p, vec3(1));\n   \t\n    return d*.4 ;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS; // smaller steps to avoid glitches\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n\tfloat k= rd.y*.5+.5;\n    vec3 col = mix(vec3(.2,.1,.1), vec3(.2,.5,1.), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    col +=Bg(rd);\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        vec3 r = reflect(rd,n);\n    \tfloat spec = pow(max(0., r.y),30.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol = mix(Bg(r), vec3(dif), .5) + spec;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 262, 262, 324], [326, 326, 348, 348, 442], [444, 444, 473, 473, 554], [556, 556, 607, 607, 984], [986, 986, 1019, 1019, 1569], [1571, 1571, 1594, 1594, 1656], [1658, 1658, 1692, 1692, 1938], [1940, 1940, 1964, 1964, 2154], [2156, 2156, 2206, 2206, 2397], [2399, 2399, 2417, 2417, 2512], [2514, 2514, 2571, 2571, 3265]]}
{"id": "wsdcDr", "name": "Mini-Bosque-v2", "author": "jorge2017a1", "description": "Mini-Bosque-v2", "tags": ["minibosquev2"], "likes": 3, "viewed": 320, "published": 3, "date": "1600785689", "time_retrieved": "2024-07-30T20:43:48.027450", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nfloat opDisplaceEsfera(  in vec3 p )\n{\n    float d1 = sdSphere(p-vec3(0.0), 3.0 );\n    float d2 = sin(1.3*p.x)*cos(1.5*p.y)*sin(0.8*p.z);\n    return d1+d2;\n}\n\n\nfloat opDisplaceEsferaFruta(  in vec3 p )\n{\n    float d1 = sdSphere(p-vec3(0.0), 1.0 );\n    float d2 = sin(0.3*p.x) +cos(0.5*p.y)+sin(0.8*p.z); //fruta\n    return d1+d2;\n}\n\n\nfloat opDisplaceCylinderXZp(vec3 p)\n{\n\tfloat d1= sdCylinderXZ(p-vec3(0.0,-3.0,0.0), vec2(0.5,6.0)  );\n    \n    return d1;\n    //return d1;\n}\n\n\n    \n    \nvec3 worldToMushrom( in vec3 pos )\n{\n    vec3 qos = pos;\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    qos.y -= 0.4;\n    return qos;\n}\n\n\nfloat suelo(vec3 pos)\n{\n    vec3 qos = pos;\n    qos.y = 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    return qos.y;\n}\n\n\nfloat mapHongo( in vec3 pos )\n{\n    vec3 qos = worldToMushrom(pos);\n    float radio=4.5;\n    float db = sdSphere(qos-vec3(0.0,1.2,0.0),radio);\n\tfloat db1=sdBox( pos-vec3(0.0,-radio/4.0,0.0), vec3(radio+1.0,radio/2.0,radio+1.0) );\n\tfloat dif= differenceSDF(db, db1);\n  \n    return dif;\n\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float ssuelo=suelo(p);\n    res =opU3(res, vec3(planeDist1+ssuelo,3.0,MATERIAL_NO)); //inf\n    p.y=p.y-10.0;\n    \n    \n     vec3 q=p;\n\t    \n    //q.y=q.y-5.0;\n    float cx=35.0;\n    float cz=25.00;\n    \n    \n    //repetir arbol\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n  \n    p=q;\n\n\t\n    float sde1= opDisplaceEsfera(p-vec3(0.0,2.0,0.0) );\n    float odcy1= opDisplaceCylinderXZp( p);\n    float cy2= sdCylinderXZ(p-vec3(-10.0,-3.0,5.0), vec2(0.5,6.0)  );\n    float r1=1.0;\n    float r2=4.0;\n    float h=4.5;\n    float src1= sdRoundCone(p-vec3(-10.0,0.0,5.0), r1, r2, h );\n    \n   \n    float src2=mapHongo(p-vec3(10.0,0.0,3.5));\n    float cy3= sdCylinderXZ(p-vec3(10.0,-3.0,3.5), vec2(0.5,6.0)  );\n    \n    \n    res =opU3(res, vec3(sde1,12.0,-1)); \n    res =opU3(res, vec3(odcy1,32.0,-1));\n    \n    res =opU3(res, vec3(src1,12.0,-1)); \n    res =opU3(res, vec3(cy2,34.0,-1)); \n    \n    res =opU3(res, vec3(src2,34.0,-1));\n    res =opU3(res, vec3(cy3,35.0,-1)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    vec3 ro=vec3(4.0,5.0,-25.0+t);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    rd.xz=rotatev2(rd.xz, radians(35.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n//----------------------------------------------------\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\n\n    if(i== 32 ){ return vec3(0.749, 0.4745, 0.3803);}  //cafe\n    if(i== 33 ){ return vec3(0.647, 0.419, 0.274);}  //cafe\n    if(i== 34 ){ return vec3(0.547, 0.319, 0.174);}  //cafe\n    if(i== 35 ){ return vec3(0.447, 0.219, 0.174);}  //cafe\n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 216, 216, 235], [236, 236, 261, 261, 280], [281, 281, 317, 317, 345], [415, 415, 451, 451, 472], [473, 473, 505, 505, 589], [590, 590, 636, 636, 723], [724, 724, 758, 758, 820], [821, 821, 858, 858, 953], [954, 954, 993, 993, 1088], [1089, 1089, 1128, 1128, 1223], [1224, 1224, 1263, 1263, 1358], [1361, 1361, 1419, 1419, 1683], [1686, 1686, 1749, 1813, 2400], [2403, 2447, 2494, 2494, 2521], [2523, 2523, 2566, 2566, 2593], [2595, 2595, 2643, 2643, 2671], [2719, 2784, 2818, 2818, 2916], [2917, 2917, 2951, 2951, 3043], [3044, 3044, 3078, 3078, 3170], [3171, 3211, 3245, 3245, 3342], [3346, 3346, 3384, 3384, 3503], [3506, 3506, 3549, 3549, 3677], [3680, 3680, 3717, 3717, 3820], [3833, 3833, 3869, 3869, 4029], [4032, 4032, 4055, 4055, 4149], [4152, 4152, 4183, 4183, 4439], [4441, 4481, 4506, 4506, 5780], [5782, 5827, 5894, 5894, 6262], [6263, 6314, 6338, 6338, 6526], [6527, 6590, 6623, 6623, 7065], [7067, 7121, 7157, 7157, 7391], [7392, 7481, 7561, 7561, 8173], [8268, 8268, 8361, 8361, 8472], [8477, 8526, 8583, 8583, 9792]]}
{"id": "tdtyWr", "name": "ValueNoiseEffect", "author": "celns", "description": "ValueNoise", "tags": ["valuenoise"], "likes": 1, "viewed": 286, "published": 3, "date": "1600777374", "time_retrieved": "2024-07-30T20:43:48.792404", "image_code": "float Random(vec2 uvi)\n{\n \treturn fract(sin(dot(uvi, vec2(12., 78.))) * 45678.765432);   \n}\n\nfloat ValueNoise(vec2 uv)\n{\n \tvec2 uvi = floor(uv);\n    vec2 uvf = fract(uv);   \n    \n    vec2 uva = smoothstep(0.0, 1.0, uvf);  \n    \n    return mix(mix(Random( uvi ),\n                   Random( uvi + vec2(1.0, 0.0)), \n                   uva.x),\n               mix(Random( uvi + vec2(0.0, 1.0)),\n                   Random( uvi + vec2(1.0, 1.0)), \n                   uva.x),\n              uva.y);\n                   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv += 0.5;\n\n    uv *= 20.0;\n    float amp = 5.;\n    uv.x += amp*sin(iTime);\n    uv.y += amp*cos(iTime);\n    float value = ValueNoise(uv);\n    if(uv.x < 20.)\n    {\n        value = smoothstep(0.49,0.51,value);\n    }\n    else if(uv.x < 35.)\n    {\n        value = 1.0 - smoothstep(0.45,0.55,value)+smoothstep(0.49,0.51,value);\n\n    }\n    \n    \n    vec3 col = vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 120, 120, 511], [514, 514, 571, 621, 1134]]}
{"id": "wddyDn", "name": "Marble Paths", "author": "dr2", "description": "Balls in channels formed by random rectangular tiling", "tags": ["dynamics", "tile", "collisions", "rolling"], "likes": 18, "viewed": 502, "published": 3, "date": "1600771496", "time_retrieved": "2024-07-30T20:43:49.910416", "image_code": "// \"Marble Paths\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Balls in channels formed by random rectangular tiling (mouseable, click\n  upper-right for new run, lower-right to switch between distant viewpoint and\n  panoramic view near random ball) In addition to gravity and friction there\n  is a horizontal force whose direction varies with time.\n  Based on \"Channeling Marbles\", \"Truchet Balls\" and \"Random Rectangular Tiling\".\n*/\n\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (iFrame, 0)\n\nconst int nBall = 64;\nvec3 vnObj, ltDir;\nfloat tCur, dstFar, surfHt, surfScl;\nint idBall;\nconst float pi = 3.14159;\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - surfHt) / rd.y;\n    sLo = s;\n    for (int j = VAR_ZERO; j < 160; j ++) {\n      p = ro + s * rd;\n      h = p.y - SurfHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = VAR_ZERO; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > SurfHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnObj = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return 0.5 + 0.5 * step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.5, 0.7, 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnn, bgCol;\n  float dstObj, dstSurf, sh;\n  bgCol = BgCol (rd);\n  dstObj = BallHit (ro, rd);\n  dstSurf = SurfRay (ro, rd);\n  if (min (dstObj, dstSurf) < dstFar) {\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      vn = vnObj;\n      col4 = vec4 (HsvToRgb (vec3 (float (idBall) / float (nBall), 0.8, BallChqr (idBall, vn))), 0.3);\n    } else if (dstSurf < dstFar) {\n      ro += dstSurf * rd;\n      vn = SurfNf (ro);\n      vnn = vn;\n      vn = VaryNf (4. * ro, vn, max (0.1, 4. - 4. * dstSurf / dstFar));\n      col = mix (vec3 (0.6, 0.55, 0.55), vec3 (0.55, 0.6, 0.55), smoothstep (0., 0.05, ro.y));\n      col4 = mix (vec4 (col, 0.), vec4 (0.8, 0.8, 0.9, 0.2), step (0.995, dot (vn, vnn)));\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n    sh = BallHitSh (ro + 0.01 * ltDir, ltDir, 10.);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (ltDir.xz)), 0.) + \n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 1. - min (1., exp2 (4. * (1. - 1.6 * min (dstObj, dstSurf) / dstFar))));\n    \n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\n#define AA    1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro, vd, bMid;\n  vec2 canvas, uv, uvv, ut;\n  float az, el, asp, zmFac, sr, s, mb, bMid2;\n  int fBall;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (4 * nBall + 0);\n  surfHt = stDat.x;\n  surfScl = stDat.y;\n  stDat = Loadv4 (4 * nBall + 1);\n  mPtr.xyz = stDat.xyz;\n  fBall = int (stDat.w);\n  az = 0.;\n  el = 0.;\n  ut = vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  mb = min (ut.x, ut.y);\n  if (mPtr.z > 0. && mb < 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.5 * pi * (mPtr.y + 0.25);\n  } else {\n    if (fBall < 0) {\n      az += 0.03 * pi * tCur;\n      el += pi * (0.17 + 0.1 * sin (0.041 * pi * tCur));\n    }\n  }\n  if (fBall < 0) {\n    el = clamp (el, 0.065 * pi, 0.4 * pi);\n    stDat = Loadv4 (4 * nBall + 2);\n    bMid = stDat.xyz;\n    bMid2 = stDat.w;\n    ro = bMid + min (2.5 * bMid2, 80.) * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n    vd = normalize (bMid - ro);\n    s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n       - vd.y * vd.z) / s, vd);\n    zmFac = 4.;\n  } else {\n    ro = Loadv4 (4 * fBall + 0).xyz;\n    ro.y += 1.;\n    vd = Loadv4 (4 * fBall + 1).xyz;\n    vd = normalize (vec3 (vd.x, 0., vd.z));\n    vd.xz = Rot2D (vd.xz,  - az);\n    ro.xz -= 0.3 * vd.xz;\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x), vec3 (0., 1., 0.), vd);\n  }\n  dstFar = 200.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = (fBall < 0) ? vec3 (uvv, zmFac) : vec3 (0.5 * sin (uvv.x * pi / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy;\n    rd = vuMat * normalize (rd);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && min (uv.x - asp, abs (uv.y) - 1.) > -0.07)\n     col = mix (col, vec3 (1., 1., 0.), 0.5);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Marble Paths\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, surfHt, surfScl;\nint fBall;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 0.8;\n  surfScl = 0.25;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.z;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Marble Paths\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, surfHt, surfScl;\nint fBall;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 0.8;\n  surfScl = 0.25;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.z;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Marble Paths\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, surfHt, surfScl;\nint fBall;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 0.8;\n  surfScl = 0.25;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.z;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Marble Paths\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, surfHt, surfScl;\nint fBall;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 0.8;\n  surfScl = 0.25;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.z;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[815, 815, 840, 840, 2236], [2238, 2238, 2261, 2261, 2334], [2336, 2336, 2370, 2370, 2961], [2963, 2963, 2985, 2985, 3124], [3126, 3126, 3160, 3160, 3576], [3578, 3578, 3625, 3625, 3993], [3995, 3995, 4037, 4037, 4243], [4245, 4245, 4267, 4267, 4299], [4301, 4301, 4336, 4336, 5639], [5658, 5658, 5714, 5714, 7978], [7980, 7980, 8005, 8005, 8401], [8403, 8403, 8433, 8433, 8546], [8548, 8548, 8572, 8572, 8689], [8723, 8723, 8747, 8747, 8807], [8809, 8809, 8833, 8833, 8945], [8947, 8947, 8972, 8972, 9158], [9160, 9160, 9189, 9189, 9401], [9403, 9403, 9442, 9442, 9627], [9721, 9721, 9746, 9746, 9869]]}
{"id": "3styWr", "name": "flow19", "author": "tomviolin", "description": "full screen it for best results. .Webcam required", "tags": ["flow"], "likes": 4, "viewed": 408, "published": 3, "date": "1600762973", "time_retrieved": "2024-07-30T20:43:50.651434", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //if (uv.x>CAMSTRIP/iResolution.x && (uv.y>.95 || uv.y <0.05)) {\n    //    fragColor = vec4(1);\n    //    return;\n    //}        \n    fragColor = texture(iChannel0,uv);\n    if (uv.x < (CAMSTRIP+1.)/iResolution.x &&\n        uv.x > (CAMSTRIP-2.0)/iResolution.x) {\n        fragColor=fragColor+0.3;\n    }\n    if (uv.x < (CAMSTR+1./iResolution.x) &&\n        uv.x > (CAMSTR)) {\n        fragColor=fragColor+0.3;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 vecpow(vec4 v, float p) {\n    return vec4(\n        pow(v.x,p),\n        pow(v.y,p),\n        pow(v.z,p),\n        v.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 cam=vecpow(texture(iChannel0, vec2(.6-uv.x,uv.y)),1.0);\n    cam.a=1.0;\n    vec4 lup = vec4(0,0,0,0);\n    if (uv.x > (CAMSTRIP+5.0)/iResolution.x) {\n    \tlup=texture(iChannel1, uv+vec2(-2.0/iResolution.x,0.0));\n    \tfragColor = lup;\n    } else if (uv.x > (CAMSTRIP+3.0)/iResolution.x) {\n    \tlup=texture(iChannel1, uv+vec2(-1.2/iResolution.x,0.0));\n    \tfragColor = lup;\n    } else if (uv.x > (CAMSTRIP+1.0)/iResolution.x) {\n    \tlup=texture(iChannel1, uv+vec2(-0.96/iResolution.x,0.0));\n    \tfragColor = lup;\n    } else if(uv.x > CAMSTRIP/iResolution.x) {\n    \tlup=texture(iChannel1, vec2(CAMSTR,uv.y));\n    \tfragColor = lup;\n    } else {\n        fragColor = (cam);\n    }\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float CAMFRAC=0.25;\n\n    \n    \n    \n#define CAMSTRIP  (iResolution.x*CAMFRAC)\n\n\nfloat camstr(float iTime, vec3 iResolution) {\n    float ts=iTime*CAMFRAC/iResolution.x*3000.;\n    float phase=mod(ts+2.0,4.)>=2.0?1.0:-1.0;\n    float wavefunc=( ((mod(ts,2.0))/2.0-0.5)*phase);\n    float wavefun=sin(iTime/0.9)/2.0;\n    return CAMFRAC/2.0+ wavefun*CAMFRAC;\n\t//return (CAMSTRIP/2.0)+pow(sin(5.0*iTime/3.14159/1.),1.0)*CAMSTRIP/2.0;\n}\n\n\n#define CAMSTR (camstr(iTime,iResolution))\n\n//#define CAMSTRIP camstr(iTime)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 564]]}
{"id": "Wsccz7", "name": "motion flow", "author": "FabriceNeyret2", "description": "WIP; probably hopeless.\nTry to compute motion flow of bufC  via correlations between neighborhoods of current frame vs previous (buf A).\nBut detects spatial correl more than temporal ! ( especially on blurry videos ).\n→ global regularization pass required", "tags": ["tracking", "opticalflow", "motionflow"], "likes": 6, "viewed": 609, "published": 3, "date": "1600761430", "time_retrieved": "2024-07-30T20:43:51.393450", "image_code": "\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy; \n    O = .1 + T(u); O.a = 0.;\n    O = vec4( length(max(O,0.)) /3. );\n    O += .2*T1(u);\n }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TILE 16\nfloat   fTILE = float(TILE);\n    \n#define T(u)    texelFetch( iChannel0, ivec2(u), 0 )\n#define T1(u)   texelFetch( iChannel1, ivec2(u), 0 )\n#define dot3(v) dot(v.rgb,v.rgb)", "buffer_a_code": "// --- previous frame\n\nvoid mainImage( out vec4 O, vec2 u )\n{ O = T(u); }\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// #define gain   .5   // for LOD 99.\n   #define gain   3.   // for LOD  4.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 I = floor( U / fTILE ) * fTILE,                // tile ID / tiling\n         D = I +  fTILE/2.,                             // tile center\n         V = mod(U, fTILE) - fTILE/2.;                  // local coords in tiles\n\n//  vec4   m = textureLod(iChannel0,vec2(.5),99.),      // image average\n//        m1 = textureLod(iChannel1,vec2(.5),99.);\n    vec4   m = texelFetch(iChannel0, ivec2(D  )>>4,4),  // image average. 4 = log2(TILE)\n          m1 = texelFetch(iChannel1, ivec2(D+V)>>4,4), d;\n    float  s = gain* sqrt(max(0.,  m.a - dot3(m ))),    // image variance Ex²-E²x\n          s1 = gain* sqrt(max(0., m1.a - dot3(m1)));   \n    O-=O;\n    for (int k=0; k < TILE*TILE; k++)                   // correlation between current central tile\n        D = I + vec2(k%TILE,k/TILE),                    // and previous frame areas around\n        O += ( T(D) - m ) / s  * ( T1(D+V) - m1 ) / s1; // coorrelation centered and normalized\n     // d  = ( T(D) - m ) / s  - ( T1(D+V) - m1 ) / s1 , O += d*d; // variante: distance rather than correl\n                                                        // indeed, same thing: dist = 2*(1 - correl )\n     // O += ( T(D) - T(D+V) ) / s  * ( T1(D) - T1(D+V) ) / s1; // trying to cancel spatial correlation\n     // d  = ( T(D) - T(D+V) ) / s  - ( T1(D) - T1(D+V) ) / s1, O += 1e15*d*d; // variante: distance rather than correl\n    O /= fTILE*fTILE;\n }\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- current frame\n\nvoid mainImage( out vec4 O, vec2 u )\n{ O = T(u); O.a = dot3(O); }\n", "buffer_c_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsccz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 159]]}
{"id": "WdtcWn", "name": "Laser battle music", "author": "jarble", "description": "A remix of one of my bytebeat songs.", "tags": ["music"], "likes": 6, "viewed": 380, "published": 3, "date": "1600743622", "time_retrieved": "2024-07-30T20:43:52.184336", "image_code": "//this is a remix of https://www.shadertoy.com/view/wsdczn\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x))*10.0,1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 1000.0);\n    //t = t % 15000;\n    t = (t>>(5)|t*(-(t/(10*(t%1000)))%11)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tfactor *= 1.5;\n        result += sound1(time*factor);\n        result /= factor;\n    }\n    return result;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 116, 116, 220]]}
{"id": "ts3yDn", "name": "Wax Sculpture", "author": "wyatt", "description": "Sophia and I have mountain of colorful wax in our room that we've made over the years. \n\nUse your mouse to make your own wax sculpture!", "tags": ["fluid"], "likes": 25, "viewed": 542, "published": 3, "date": "1600739223", "time_retrieved": "2024-07-30T20:43:53.187653", "image_code": "// Fork of \"Tannins\" by wyatt. https://shadertoy.com/view/3sdczN\n// 2020-09-21 22:04:57\n\nMain {\n    vec4\n        n = C(U+vec2(0,1))+B(U+vec2(0,1)),\n        e = C(U+vec2(1,0))+B(U+vec2(1,0)),\n        s = C(U-vec2(0,1))+B(U-vec2(0,1)),\n        w = C(U-vec2(1,0))+B(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.w-w.w,n.w-s.w,.1)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \tvec4 b = B(U), c = C(U);\n\tQ = c+b*b.w;\n    vec3 l = R.xyy;\n    float li = ln(vec3(U,0),vec3(U,0)+ref,l);\n    \n    Q *= .2+0.5*exp(-li)+.5*exp(-2.*li);\n    \n    Q = atan(2.*Q);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}\n\n#define rate 0.005", "buffer_a_code": "Main {\n    if (iFrame%2==0) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            #define o 1.3\n            vec2 w1 = clamp(U+u+a.xy-0.5*o,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*o,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(o*o);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n        }\n   } else {\n    \tQ = A(U);vec4 q = Q;\n        for (int x = -1; x<=1; x++)\n        for (int y = -1; y<=1; y++)\n        if (x != 0||y!=0)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u), c = C(U+u);\n            u = (u)/dot(u,u);\n            Q.xy -= q.w*0.125*.5*(c.w+a.w*(a.w*a.z-2.5))*u;\n            Q.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n        }\n    }\n    Q.xy *= .2+.77*min(pow(Q.w,.01),1.);\n    // Solidify\n    Q.w -= Q.w*rate/(1.+10.*length(Q.xy));\n    vec4 d = D(U);\n        if ((iMouse.z>0.)&&ln(U,d.xy,d.zw)<8.)\n            Q = vec4(1e-1*clamp(d.xy-d.zw,-.8,.8),1,1);\n        if (U.y<1.||U.x<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tvec4 a = A(U), b = B(U);\n    Q = C(U);\n    float f = 1./(1.+10.*length(Q.xy));\n    Q.w += 6.*rate*a.w*f;\n    Q.xyz = mix(Q.xyz,5.*b.xyz,rate*b.w*f);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u), b = B(U+u);\n        #define q 1.1\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*b.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,0,0);\n    }\n    vec4 d = D(U);\n    if ((iMouse.z>0.)&&ln(U,d.xy,d.zw)<8.)\n        Q = vec4(1.+0.5*sin(iTime*.1+iTime*vec3(1,2,3)),1);\n\n    Q -= Q*rate;\n    if (iFrame < 1) Q = C(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "3s3cWn", "name": "Delta Poetry", "author": "BradyInstead", "description": "info in shader", "tags": ["raymarch", "triangle", "reflections", "delta"], "likes": 3, "viewed": 372, "published": 3, "date": "1600723467", "time_retrieved": "2024-07-30T20:43:53.980533", "image_code": "//////////////////////////////////////\n//\t\t\tDELTA POETRY\t\t\t//\n//////////////////////////////////////\n\n//\tDelta = Change\n\n//\tThanks to iq for the raymarching inspiration\n//\tThanks to Connor Bell for the AA technique\n\n\n//////////////////////////////////////\n//\t\t\tVARIABLES\t\t\t\t//\n//////////////////////////////////////\n\n#define AA 2\n\n#define MAX_MARCH 12.\n#define MAX_MARCH_REFLECT 5.\n\n#define REFLECT_POWER 1.5\n#define NUM_REFLECTIONS 2\n\n\n//////////////////////////////////////\n//\t\t\t\tCODE\t\t\t\t//\n//////////////////////////////////////\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nvec2 delta(vec3 p)\n{   \n    //float sphere = length(p) - .5;\n    float tri = sdTriPrism(p, vec2(1., .1));\n    float stri = sdTriPrism(p, vec2(.4, .1));\n    tri = opSmoothSubtraction(stri, tri, .5);\n    \n    return vec2(tri, 1.);\n}\n  \nvec2 plane( vec3 p)\n{\n\treturn vec2(abs(p.y), 2.);\n}\n\nvec2 model(vec3 p)\n{   \n    vec2 sp = delta(p + vec3(0., -.2 + sin(iTime*3.)*.1, 0.));\n    vec2 pl = plane(p + vec3(0, .5, 0.));\n    \n    vec2 mod = vec2(0.);\n    if(sp.x < pl.x)\n        mod = sp;\n    else\n    \tmod = pl;\n    \n    return mod;\n    //return sp;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float maxdist, float modifier)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist).x*modifier;\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > maxdist) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz).x - model(pos + eps.yzz).x,\n        model(pos + eps.zxz).x - model(pos + eps.zyz).x,\n        model(pos + eps.zzx).x - model(pos + eps.zzy).x));\n}\n\n\nvec3 background()\n{\n    return vec3(0.);\n}\n\nvec3 getColor(vec3 pos)\n{\n    float m = model(pos).y;\n    vec3 color = vec3(0.);\n    \n    if(m == 1.) // delta\n        return vec3(1., .65, 0.2);\n    if(m == 2.)\n        return vec3(1., 1., 1.);\n    \n    return background();\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 lp = vec3(2., 2., 2.);\n    vec3 ld = normalize((lp-pos)*rd);\n    \n    float dif = max(dot(nor,ld),.45);\n    vec3 lin = vec3(dif);\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    \n    col = pow(col, vec3(1.8));\n    \n    col *= getColor(pos);\n    \n    return col;\n}\n\nvec3 reflection(vec3 pos, vec3 rd, vec3 nor, float dist)\n{\n    if(dist < -.1) return background();\n    \n    vec3 rrd = reflect(rd, nor);\n    vec3 rro = pos + rrd*.02;\n    \n    vec3 col = vec3(0.);\n    vec3 fade = vec3(1.);\n    \n    for(int i = 0; i < NUM_REFLECTIONS; i++)\n    {\n    \tfloat rdist = raymarch(rro, rrd, MAX_MARCH_REFLECT, 1.);\n    \n    \tvec3 rpos = rro + rrd*rdist;\n    \tvec3 rnor = normal(rpos);\n    \n    \tfade -= pow(1. - rdist/MAX_MARCH_REFLECT, .5) *.4; //* vec3(.5, .9, .1);\n        \n        rrd = reflect(rrd, rnor);\n    \trro = rpos + rrd*.02;\n        \n        col += shade(rpos, rnor, rrd, rdist) * fade;\n    }\n    \n    return col;\n}\n\nvec3 render(vec2 p)\n{   \n    vec3 ro = vec3(4. * cos(iTime*.5), 1., 4. * sin(iTime*.5)); \n    vec3 ta = vec3(0.0, .25, 0.0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.5));\n    \n    float dist = raymarch(ro, rd, MAX_MARCH, 1.);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    vec3 ref = reflection(pos, rd, nor, dist);\n    \n    col += ref*REFLECT_POWER;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    for (int j = 0; j < AA; j++) {\n        for (int k = 0; k < AA; k++)\n        {\n            vec2 o = vec2(float(j), float(k)) / float(AA);\n            vec2 uv = (p + o / iResolution.xy);\n            color += render(uv);\n        }\n    }\n\n    color /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 569, 569, 652], [655, 655, 713, 713, 813], [816, 816, 836, 876, 1046], [1050, 1050, 1071, 1071, 1101], [1103, 1103, 1123, 1123, 1363], [1365, 1365, 1436, 1436, 1661], [1663, 1663, 1686, 1686, 1929], [1932, 1932, 1951, 1951, 1974], [1976, 1976, 2001, 2001, 2202], [2204, 2204, 2257, 2257, 2587], [2589, 2589, 2647, 2647, 3243], [3245, 3245, 3266, 3266, 3841], [3843, 3843, 3900, 3900, 4324]]}
{"id": "3scyDn", "name": "BALLS", "author": "SilvanKohler", "description": "BALLS", "tags": ["balls"], "likes": 6, "viewed": 376, "published": 3, "date": "1600717962", "time_retrieved": "2024-07-30T20:43:54.788373", "image_code": "#define PI 3.1415\nconst float balls = 5.5;\nconst float speed = 6.;\nconst float cramming = 6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.) / iResolution.y * 2.;\n\tvec2 m =  (iMouse.xy - iResolution.xy/2.) / iResolution.y * 2.;\n    float d = 0.;\n\tfloat r;\n    float a;\n    vec2 p;\n    for (float i = iTime*speed+.01;  i<iTime*speed+balls; i += 1.01){\n    \ta = PI * 2. / balls * cramming * i;\n\t\tr = sin(iTime);\n        p = vec2(sin(a)*r, cos(a)*r);\n        d += 1./length(uv-p);\n    }\n    d /= 2.;\n    vec3 col = vec3(d/40., d/35., d/25.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 201, 703]]}
{"id": "wdtyzN", "name": "global illumination test", "author": "Cewein", "description": "This is a path traced sceen with real indirect ligthing", "tags": ["raymarching", "gi", "globalillumination", "volumetric", "pathtracing"], "likes": 15, "viewed": 1443, "published": 3, "date": "1600709263", "time_retrieved": "2024-07-30T20:43:55.965227", "image_code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced sceen with real indirect ligthing\n// the sceen is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// THERE IS STILL SOME BIG ERROR :\n// \t\t- Wall corner are to bright\n//\t\t- turn of the sky light and one the back of the corridor will get GI\n//\t\t- the color change in the front and in the back\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n//\n//\n// \tCHECK BUFFER A FOR MOR INFORMATION AND THE CODE\n//\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col /= texture( iChannel0, uv ).w;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    // color grading and vigneting    \n    col = pow( col, vec3(0.8,0.85,0.9) );\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced sceen with real indirect ligthing\n// the sceen is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// THERE IS STILL SOME BIG ERROR :\n// \t\t- Wall corner are to bright\n//\t\t- turn of the sky light and one the back of the corridor will get GI\n//\t\t- the color change in the front and in the back\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n\n\n//global macro\n#define MAXSTEP 128\n#define EPSILON 0.0001\n\nfloat spp = 0.0;\n\nfloat hash(vec2 st)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 cosineDirection( in vec2 st, in vec3 nor)\n{\n    float a = 1.0 - 2.0*hash(st.xy * iTimeDelta);\n    float b = sqrt(1.0 - a*a);\n    float phi = 2.0*acos(-1.0)*hash(-st.yx * iTimeDelta);\n    \n    vec3 dir = vec3(0.0);\n    \n    dir.x = nor.x + b*cos(phi);\n    dir.y = nor.y + b*sin(phi);\n    dir.z = nor.z + a;\n    \n    dir = normalize(dir);\n    \n    return dir;\n}\n\n//signed distance function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//rotate for a given radian\nmat2 rot(float angle)\n{\n    angle *= 0.0174533;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n//inifite geometry\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n//compute the distance between all sdf for a given pos and get the propor distance and id mat\nvec2 map(vec3 pos)\n{\n    //id is the material identificator (or in short the surface color)\n    float id = 0.0;\n    \n    //floor\n    float flr = pos.y + 1.0;\n    \n    pos = opRep(pos, vec3(2.0,1000.0,1000.0));\n    \n    //hollow cube with hole in a roof\n    float cube = sdBox(pos, vec3(4.0, .5,0.5));\n    float bigCube = sdBox(pos + vec3(0.0,49.4,0.0), vec3(50.0));\n    \n    vec3 rotPos = pos;\n    rotPos.y -= .5;\n    rotPos.yz *= rot(90.0);\n    float roofHole = sdBox(rotPos, vec3(0.2,0.2,0.5));\n    \n    cube = max(-cube, bigCube);\n    cube = max(-roofHole, cube);\n    \n    return vec2(cube, id);\n}\n\n//compute the normal for a given point\nvec3 getNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\n\n//marching function, it send ray into the world and get the proper mat and distance\nvec2 getDistance(vec3 ro, vec3 rd, float dmax)\n{\n    //distance for the origine is x and y is the mat id\n    vec2 dmat = vec2(0.0);\n    \n    for(int i = 0; i < MAXSTEP; i++)\n    {\n        //position along the ray\n        vec3 pos = ro + dmat.x*rd;\n        \n        //get the distance to the nearest sdf surface\n        vec2 eval = map(pos);\n        \n        //if true it mean we are inside a sdf\n        if(eval.x < 0.0) return dmat;\n        \n        dmat.x += max(eval.x,0.00001);\n        dmat.y = eval.y;\n        \n        //true if out of range and set -1.0 for sky id\n        if(dmat.x > dmax) return vec2(dmat.x, -1.0);\n    }\n    return dmat;\n}\n\n//it is the same as the \"getDistance\" function but it's return 1.0 if no hit and 0.0 if hit\nfloat getShadow(vec3 ro, vec3 rd)\n{\n   float d = 0.001; \n   \n   for(int i = 0; i < MAXSTEP; i++)\n   {\n       vec3 pos = ro + d*rd;\n       \n       float eval = map(pos).x;\n       \n       if(eval < 0.0) return 0.0;\n       d += max(eval,0.04);\n       \n       if(d > 20.0) return 1.0;\n   }\n    \n   return 1.0;\n}\n\n//colorization function based on the id\nvec3 getSurfaceColor(float id)\n{\n    if(id < -0.5)\n        return vec3(0.5,0.4,0.6);\n    else\n        return vec3(0.5);\n}\n\nvec3 sunDir = vec3(0.0,1.0,-0.1);\n\nvec3 sunCol =  10.0*vec3(1.0,0.8,0.6);\nvec3 skyCol =  10.0*vec3(0.2,0.35,0.5);\n\nvec3 renderPixel(vec3 ro,vec3 rd, float sa, vec2 uv)\n{\n    vec3 colorStrengh = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    \n    float fdis = 0.0;\n    \n    //GI bounce\n    for(int nbBounce = 0; nbBounce < 5; nbBounce++)\n    {\n        rd = normalize(rd);\n        //evaluation of distance to the sdf agregate and get the id mat in the same time\n        vec2 dist = getDistance(ro, rd, 100.0);\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //get the intersection position and the normal at this point\n        vec3 pos = ro + dist.x*rd;\n        vec3 norm = getNormal(pos);\n        \n        if(dist.y < 0.0)\n        {\n            if( nbBounce==0 ) { fdis=16.0; accumulatedColor = mix( 0.05*vec3(0.9,1.0,1.0), skyCol, smoothstep(0.1,0.25,rd.y) ); break; }\n            break;\n        }\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //surface color\n        colorStrengh *= getSurfaceColor(dist.y);\n        \n        vec3 col = vec3(0.0);\n\n        //lighting\n        //sun\n        float sunSha = getShadow(pos + norm * EPSILON, sunDir);\n\n        //sky\n        vec3 skyPoint = cosineDirection( sa + 7.1*float(iFrame) + 5681.123 + float(nbBounce)*92.13 + uv.yx, norm);\n        float skySha = getShadow(pos + norm*EPSILON, skyPoint);\n\t\t\n        //perform bounce accumulation\n        col = sunCol * sunSha + skySha * skyCol;\n\t\taccumulatedColor += colorStrengh * col;\n        \n        //perfom the bounce\n        rd = cosineDirection(float(iTime) + uv.xy, norm);\n        ro = pos;\n        \n    }\n    \n    float ff = exp(-0.01*fdis*fdis);\n   \taccumulatedColor *= ff; \n   \taccumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n    \n    // volumetrics\n    float dt = 0.53;\n    float acc = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float t = fdis*hash(sa+1.31+13.731*float(i)+float(iFrame)*7.773 + uv.yx);\n        vec3 pos = oro + ord*t;\n        acc += dt*getShadow( pos, sunDir )*exp(-0.25*t);\n    }\n    accumulatedColor += vec3(0.2)*pow(acc,0.4545)*sunCol*0.4;\n\n\n    return accumulatedColor;\n}\n\n\n//Ray function\nvec3 getDirection(vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 ww = normalize(target - ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right\n\tvec3 vv = normalize(cross(uu,ww)); //up\n    \n    return normalize(uv.x * uu + uv.y*vv + fov*ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) +  uv);\n    \n    vec2 of = -0.5 + vec2( hash(sa+13.271+uv), hash(sa+63.216+uv) );\n    \n    \n    //ray generation\n    vec3 target = vec3(-15.0,0.5,2.0);\n   \tvec3 ro = vec3(-2.5,.0,-0.4);\n    vec3 rd = getDirection(ro,target, uv, 1.5);\n    \n    //get the texture pixel color\n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    float spp = texture( iChannel0, fragCoord/iResolution.xy ).w;\n    if( iFrame==0 || iMouse.z > 0.0) \n    {\n        col = vec3(0.0);\n        spp = 0.0;\n    }\n    \n    //accumulate the rendered pixel into the color\n    col += renderPixel(ro, rd, sa, uv);\n    spp += 1.0;\n    //output the color to the screen\n    fragColor = vec4(col,spp);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 653, 653, 1083]]}
{"id": "wtjBDd", "name": "Sentinel - Perlin Noise - 3", "author": "Sentinel", "description": "повышенная резкость", "tags": ["noise"], "likes": 0, "viewed": 231, "published": 3, "date": "1600708808", "time_retrieved": "2024-07-30T20:43:56.854848", "image_code": "// copy from https://www.shadertoy.com/view/4sc3z2\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return 1000.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat perlin_noise(vec3 p)\n{\n    // левый верхний угол квадрата\n    vec3 pi = floor(p);\n    // координаты точки внутри квадрата\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (uv.x > 0.5) {\n        uv.x = 1.0 - uv.x;\n    }\n    if (uv.y > 0.5) {\n        uv.y = 1.0 - uv.y;\n    }\n    \n    float scale = 10.;\n    uv *= scale;\n    float dis = perlin_noise(vec3(uv, iTime * 0.5));\n\tfragColor = vec4(vec3(0,1,0) * vec3(dis) / 100.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 114, 114, 262], [264, 264, 292, 351, 1359], [1361, 1361, 1418, 1418, 1725]]}
{"id": "3s3yWn", "name": "diff matte video feedback", "author": "halcy", "description": "it's september once again", "tags": ["video"], "likes": 5, "viewed": 374, "published": 3, "date": "1600707876", "time_retrieved": "2024-07-30T20:43:57.800320", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) * 0.01 + texture(iChannel1, uv) * 0.99;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 screen = texture(iChannel1, uv) * 100.0;\n    vec4 screenprev = texture(iChannel2, uv) * 100.0;\n    vec4 feedback = vec4(0.0);\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 o = vec2(i, j);\n            float v = length(o);\n            feedback += texture(iChannel0, (uv + o / iResolution.xy - 0.5) * 1.05 + 0.5) * 0.85 * norm(v, 3.0);\n        }\n    }\n    \n    float matte = float(length(screen - screenprev) > length(screen) * 0.05);\n\tfragColor = mix(feedback, screen * 1.1, matte);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float norm(float v, float s) { \n    return 1.0 / sqrt(2.0 * 3.14) * exp(-0.5 * v * v / (s * s)) / s;\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) * 0.01 + texture(iChannel1, uv) * 0.99;\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 180]]}
{"id": "Ws3yWn", "name": "GloopCircle", "author": "Del", "description": "A Gloop Circle? - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]\n", "tags": ["noise", "deform", "cylinder", "gloop"], "likes": 12, "viewed": 494, "published": 3, "date": "1600706749", "time_retrieved": "2024-07-30T20:43:58.662016", "image_code": "// gloop test (Cylinder+Noise+Deform)\n// Added some colour+blend for fun\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 8.\n\nvec3 _col = vec3(0.0);\t// pure filth\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sminCol( float a, float b, float k, vec3 col1, vec3 col2 )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    _col = mix(col1,col2,h);// -  k*h*(1.0-h);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 hsv2rgb(vec3 c)\n{\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n// noise\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;    \n    return k*0.4;\n}\n\nfloat map( in vec3 pos )\n{\n    float rad =  (1.0/(3.141*2.0)*20.0);\n    vec3 dp = vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));    \n    float d1 = sdCylinder(dp,vec2(0.8,HEIGHT))-0.5;\n    float t = iTime*1.35;\n    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(dp+vec3(sin(t*.2)*2.0,t*1.5,0.0), 1.5, 4.47, 1.43);\n    float n3 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n    n1 = smin(n1,n2,4.);\n    n1 = smin(n1,n3,4.);\n  \td1 = smax(n1,d1,4.);\n    \n    n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;\n    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;\n    \n    float d2 = dot(pos,vec3(0.0,1.0,0.0)) + 1.5+disp;   \n    //d1 = smin(d1,d2,1.2);\n    \n    vec3 goo = hsv2rgb(vec3(t*0.2+dp.y*0.075,0.85,0.9));\n    \n    d1 = sminCol(d1,d2,1.2,vec3(0.025,0.2,0.75),goo);\n    \n    return d1*0.75;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.008;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = 0.2-sin(iTime*.75)*2.0;\n\tvec3 ro = vec3( 7.0*cos(an), 2.0+sin(iTime*0.75)*2.2, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 25.0;\n        float t = 0.0;\n        for( int i=0; i<160; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 20.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  _col*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 193, 229, 229, 328], [329, 351, 392, 392, 481], [483, 483, 549, 549, 685], [686, 686, 708, 772, 919], [921, 921, 960, 960, 989], [990, 999, 1051, 1051, 1207], [1209, 1209, 1235, 1235, 2102], [2104, 2104, 2136, 2136, 2383]]}
{"id": "wstcz7", "name": "Fake \"3d\" Texture", "author": "MilkyDeveloper", "description": "Texture - Edge Detection = This :D", "tags": ["3d", "texture", "fake", "bump", "mapping", "pom", "parralax"], "likes": 1, "viewed": 569, "published": 3, "date": "1600706024", "time_retrieved": "2024-07-30T20:43:59.629429", "image_code": "// Meant to be used in a Minecraft Bedrock Shader.\n// This is CC0, but please consider basic human ethics :D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    \n    vec2 mouse = vec2(iMouse)/vec2(iResolution);\n    \n    // Edge Detection from https://www.shadertoy.com/view/3s3Gz8\n    // I find it accurate, fast, and simple.\n    float AMP = 1.5;\n    \n\tvec3 Lx = dFdx(color*AMP);\n\tvec3 Ly = dFdy(color*AMP);\n\tvec3 G = sqrt(Lx*Lx+Ly*Ly);\n\t\n    // Selected Texture 👇. Offset 👇-------👇.👇 -> Edge Detection Shadows\n\tfragColor = texture(iChannel0, uv-(0.005))-vec4(G.xyz, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 167, 167, 714]]}
{"id": "tsdcRM", "name": "hqx upscaling filter", "author": "public_int_i", "description": "Improved version of https://www.shadertoy.com/view/3styRH, designed to more properly match https://en.wikipedia.org/wiki/Hqx", "tags": ["filter", "scale", "scaling", "upscale", "up", "hqx"], "likes": 24, "viewed": 2044, "published": 3, "date": "1600700337", "time_retrieved": "2024-07-30T20:44:00.589862", "image_code": "/*Copyright 2020 Ethan Alexander Shulman\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/\n\n//upscaling multiplier amount\n#define UPSCALE 10.\n\n//image mipmap level, for base upscaling\n#define ML 0\n\n//equality threshold of 2 colors before forming lines\n#define THRESHOLD .1\n\n//line thickness\nfloat LINE_THICKNESS;\n\n//anti aliasing scaling, smaller value make lines more blurry\n#define AA_SCALE (UPSCALE*1.)\n\n\n//draw diagonal line connecting 2 pixels if within threshold\nbool diag(inout vec4 sum, vec2 uv, vec2 p1, vec2 p2) {\n    vec4 v1 = texelFetch(iChannel0,ivec2(uv+vec2(p1.x,p1.y)),ML),\n        v2 = texelFetch(iChannel0,ivec2(uv+vec2(p2.x,p2.y)),ML);\n    if (length(v1-v2) < THRESHOLD) {\n    \tvec2 dir = p2-p1,\n            lp = uv-(floor(uv+p1)+.5);\n    \tdir = normalize(vec2(dir.y,-dir.x));\n        float l = clamp((LINE_THICKNESS-dot(lp,dir))*AA_SCALE,0.,1.);\n        sum = mix(sum,v1,l);\n    \treturn true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sliderX = iMouse.x<5.?\n        \t(fract(iTime*.2)-max(0.,fract(iTime*.2)*2.-1.))*2.*iResolution.x:\n    \t\tiMouse.x;\n    vec2 ip = fragCoord/UPSCALE;\n    \n    if (fragCoord.x < sliderX) {\n        //regular nearest sampling\n    \tfragColor = texelFetch(iChannel0,ivec2(ip.x,ip.y),ML);\n        \n    } else {\n        \n        //start with nearest pixel as 'background'\n        vec4 s = texelFetch(iChannel0,ivec2(ip),ML);\n        \n        //draw anti aliased diagonal lines of surrounding pixels as 'foreground'\n        LINE_THICKNESS = .4;\n        if (diag(s,ip,vec2(-1,0),vec2(0,1))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(-1,0),vec2(1,1));\n            diag(s,ip,vec2(-1,-1),vec2(0,1));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(0,1),vec2(1,0))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(0,1),vec2(1,-1));\n            diag(s,ip,vec2(-1,1),vec2(1,0));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(1,0),vec2(0,-1))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(1,0),vec2(-1,-1));\n            diag(s,ip,vec2(1,1),vec2(0,-1));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(0,-1),vec2(-1,0))) {\n           LINE_THICKNESS = 0.3;\n         \tdiag(s,ip,vec2(0,-1),vec2(-1,1));\n            diag(s,ip,vec2(1,-1),vec2(-1,0));\n        }\n\n        fragColor = s;\n    }\n    \n    //draw slider bar\n    if (abs(fragCoord.x-sliderX) < 1.) fragColor = vec4(1,0,1,1);\n    \n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcRM.jpg", "access": "api", "license": "mit", "functions": [[1381, 1442, 1496, 1496, 1911], [1913, 1913, 1970, 1970, 3459]]}
{"id": "3dcczM", "name": "jean claude van delaunay", "author": "flockaroo", "description": "some delaunay-ing - just to have done it once. ...and for all? ...nope, might actually come in handy one day ;-)\n...hopefully not too slow on moderte machines... also added a ONE_LOOP define - not quite sure bout unrolling behavior on different platforms.", "tags": ["triangles", "effect", "triangulation", "delaunay"], "likes": 35, "viewed": 1161, "published": 3, "date": "1600695288", "time_retrieved": "2024-07-30T20:44:01.585201", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// delaunay triangulation\n//\n//  ...somewhat brute force - might be better ways to do this\n\n// use this if the shader wont compile due to too many nested loops...\n\n//#define ONE_LOOP\n\n// comment to disable the line-hatching of triangles\n#define SCHRAFF\n// show simple voro cells - nothing fancy, jsut for debugging...\n//#define SHOW_VORONOI\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n\n#define PI 3.14\n\nconst float TileSizeRel=9.;\n#define TileSize (TileSizeRel*sqrt(Res.x/600.))\n\n#define VidTex iChannel0\nvec4 getCol(vec2 p) { vec2 uv=(p-Res*.5)*min(Res0.x/Res.x,Res0.y/Res.y)/Res0+.5; return texture(VidTex,uv); }\nvec4 getCol2(vec2 p) { vec4 c=getCol(p); return mix(c,vec4(.2,.5,.2,1),dot(c.xyz,vec3(-1,2,-1))); }\nfloat getVal(vec2 p) { return dot(getCol2(p).xyz,vec3(.333)); }\nvec2 getGrad(vec2 p, float eps) { vec2 d=vec2(eps*.5,0); return vec2(getVal(p+d.xy)-getVal(p-d.xy), getVal(p+d.yx)-getVal(p-d.yx))/eps; }\n\nvec4 getRand(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0);\n}\n\nvec2 getPoint(int x, int y)\n{\n    vec4 r=getRand(x,y);\n    vec2 p=vec2(x,y)+vec2(1,0)*(float(y%2)-.5)*.5+(r.xy-.5)*.2;\n    vec2 g=getGrad(p*TileSize,TileSize);\n    vec2 ng=(dot(g,g)<.00000001)?(r.zw-.5)*.1:normalize(g);\n    float glen=min(.005/(length(g)+0.),1.);\n    return (p-ng*glen)*TileSize;\n}\n\nfloat lineDist(vec2 p, vec2 p1, vec2 p2)\n{\n    float l=length(p2-p1);\n    float px=dot(p-p1,p2-p1)/l;\n    float py=dot(p-p1,(p2-p1).yx*vec2(-1,1))/l;\n    return max(abs(px-l*.5)-l*.5,abs(py));\n}\n\nfloat lineDistInf(vec2 p, vec2 p1, vec2 p2)\n{\n    return abs(dot(p-p1,normalize((p2-p1).yx*vec2(-1,1))));\n}\n\n#define TXCH(T,a,b) { T dummy=a; a=b; b=dummy; }\n\n// check if point is in triangle\nbool inTriangle(vec2 p, vec2 p1, vec2 p2, vec2 p3)\n{\n    mat2 m=mat2(p2-p1,p3-p1);\n    p=inverse(m)*(p-p1);\n    return p.x>0. && p.y>0. && (p.x+p.y)<1.;\n}\n\nconst int HistNum = 25;\n\n// cut 2 lines given by point + dir each\nvec2 cut(vec2 p1,vec2 d1, vec2 p2,vec2 d2)\n{\n    mat2 m=mat2(d1,-d2);\n    vec2 p=inverse(m)*(p2-p1);\n    return p1+d1*p.x;\n}\n\n// check if all other points are outside the circumscribes circle of triangle p[i1],p[i2],p[i3]\nbool otherOutsideUmkreis(int i1, int i2, int i3, vec2 p[HistNum])\n{\n    vec2 c=cut((p[i1]+p[i2])*.5,(p[i2]-p[i1]).yx*vec2(1,-1),\n               (p[i1]+p[i3])*.5,(p[i3]-p[i1]).yx*vec2(1,-1));\n    float r=length(p[i1]-c);\n    for(int i=0;i<HistNum;i++) {\n        if (i==i1) continue;\n        if (i==i2) continue;\n        if (i==i3) continue;\n        if (length(p[i]-c)<r) return false;\n    }\n    return true;\n}\n\nfloat schraff(vec2 p, float br, vec2 dir)\n{\n    //c=br=(l-1)/l;\n    //l=1/(1-br)\n    float l=1./(1.-br); \n    // FIXME: some quick hand-fix to get no aliasing in the hashing lines\n    l=sqrt(l)+.3;\n    float s=sin(dot(p,dir)/l*PI);\n    s=abs(fract(dot(p,dir)/l*.25)-.5)-.25;\n    float w=fwidth(s)*.7;\n    return clamp(1.-s*s/w/w,0.,1.);\n    return exp(-s*s/(w*w));\n    return abs(s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    vec2 p=fragCoord;\n    vec2 p0=floor(p/TileSize+.5);\n    float dmin[HistNum]; for(int i=0;i<HistNum;i++) dmin[i]=10000.;\n    vec2 pmin[HistNum];\n    // generate a \"history\" of the HistNum nearest points\n    // ...check 3 steps in each direction - makes 7x7 points\n    #define NNUM 3\n    for(int x=-NNUM;x<=NNUM;x++)\n    {\n        for(int y=-NNUM;y<=NNUM;y++)\n        {\n            vec2 pi=getPoint(int(p0.x)+x,int(p0.y)+y);\n            float d=length(p-pi);\n            for(int i=0;i<HistNum;i++) { if (d<dmin[i] ) { TXCH(float,dmin[i],d); TXCH(vec2,pmin[i],pi); } }\n        }\n    }\n    int i1,i2,i3;\n    // check all possible triangles from HistNum points for one that includes \n    // the actual screen pos and the circumscribed circle of which contains no other points\n    // ...there might be more eficient ways to do this?!\n    bool found=false;\n#ifdef ONE_LOOP\n    for(int i=0;i<HistNum*HistNum*HistNum;i++)\n    {\n        i1=i%HistNum;\n        i2=(i/HistNum)%HistNum;\n        i3=(i/HistNum/HistNum)%HistNum;\n#else\n    for(i1=0+min(iFrame,0);i1<HistNum;i1++){\n    for(i2=0+min(iFrame,0);i2<HistNum;i2++){\n    for(i3=0+min(iFrame,0);i3<HistNum;i3++){\n#endif\n        if (i1==i2 || i1==i3 || i3==i2) continue;\n        if (inTriangle(p,pmin[i1],pmin[i2],pmin[i3]) && otherOutsideUmkreis(i1,i2,i3,pmin)) { found=true; }\n        if (found) break;\n    }\n#ifndef ONE_LOOP\n        if (found) break;\n    }\n        if (found) break;\n    }\n#endif\n    \n    vec2 c=(pmin[i1]+pmin[i2]+pmin[i3])/3.;\n    vec4 col2=getCol2(c);\n    vec4 col=getCol(c);\n    float d=10000.;\n    d=min(d,lineDistInf(fragCoord,pmin[i1],pmin[i2]));\n    d=min(d,lineDistInf(fragCoord,pmin[i2],pmin[i3]));\n    d=min(d,lineDistInf(fragCoord,pmin[i3],pmin[i1]));\n    float d2=10000.;\n    d2=min(d2,lineDist(fragCoord,(pmin[i1]+pmin[i2])*.5,c));\n    d2=min(d2,lineDist(fragCoord,(pmin[i2]+pmin[i3])*.5,c));\n    d2=min(d2,lineDist(fragCoord,(pmin[i3]+pmin[i1])*.5,c));\n    //d2=min(d2,lineDist(fragCoord,(pmin[i1]+pmin[i2])*.5,(pmin[i2]+pmin[i3])*.5));\n    //d2=min(d2,lineDist(fragCoord,(pmin[i2]+pmin[i3])*.5,(pmin[i3]+pmin[i1])*.5));\n    //d2=min(d2,lineDist(fragCoord,(pmin[i3]+pmin[i1])*.5,(pmin[i1]+pmin[i2])*.5));\n    \n   \tfragColor.xyz=clamp(col.xyz*.7+.3,0.,1.);\n   \tfloat br=getVal(c);\n   \tvec3 schraffCol=vec3(0,.2,.4)*.7+.3;\n   \t//schraffCol=vec3(0);\n   \tfragColor.xyz=vec3(1);\n#ifdef SCHRAFF\n   \tfragColor.xyz-=(1.-schraffCol)*schraff(fragCoord,pow(br,.5),normalize(getGrad(c,TileSize)+.0001));\n#endif\n   \tfragColor.xyz=mix(fragColor.xyz,col2.xyz*.8+.2,.75);\n    //fragColor.xyz*=vec3(0)+min(d*.8,1.)*.7+.3;\n    fragColor.xyz*=mix(min(d*1.2,1.)*.5+.5,1.,0.*dot(col.xyz,vec3(-1,2,-1)));\n    //fragColor.xyz*=mix(min(d2*1.2,1.)*.5+.5,1.,.3);\n#ifdef SHOW_VORONOI\n    fragColor.xyz+=vec3(0)+.3*clamp(1.-.5*abs(dmin[0]-dmin[1]),0.,1.);\n#endif\n   \t//fragColor.xyz+=vec3(0)+.4*dmin[0]/TileSize;\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcczM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[674, 674, 695, 695, 783], [784, 784, 806, 806, 883], [884, 884, 906, 906, 947], [948, 948, 981, 981, 1085], [1087, 1087, 1115, 1115, 1164], [1466, 1466, 1508, 1508, 1660], [1662, 1662, 1707, 1707, 1769], [1821, 1854, 1906, 1906, 2008], [2035, 2076, 2120, 2120, 2200], [2202, 2298, 2365, 2365, 2706], [2708, 2708, 2751, 2788, 3093]]}
{"id": "wdtczM", "name": "5 nanoseconds after BigBang-259c", "author": "benoitM", "description": "When elementary particles dance together.\nTweaking some older and trying to make it short.\nFor more clear code see https://www.shadertoy.com/view/WtjyzR", "tags": ["2d", "fractal", "colors", "space", "abstract", "recursive", "generative", "inversion", "layers", "short", "symmetries", "spacefolding", "cineshader"], "likes": 84, "viewed": 3689, "published": 3, "date": "1600692862", "time_retrieved": "2024-07-30T20:44:02.651349", "image_code": "// Created by Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//Getting compil error since 11/2020 with 259 chars version, back to longer version\n//-2 chars, thanks Xor !\nvoid mainImage(out vec4 o, vec2 F){\n    vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                     \n    }\n}\n\n//Getting compil error since 11/2020 with 259 chars version, back to longer version\n/*\nvoid mainImage(out vec4 o, vec2 F){\n    vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o += c * c.yzww  * (d-d*d)  / vec4(3,5,1,1);                     \n    }\n}*/\n    \n// 259 chars\n// Thank you Xor !\n/*\n#define mainImage(o,F)                                                 \t\\\n    vec2 R = iResolution.xy;                                           \t\\\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\\\n    {   d = fract( i -3.*t );                                          \t\\\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\\\n        for (int j=0 ; j++ <27; )                                      \t\\\n            c.xzyw = abs( c / dot(c,c)                                 \t\\\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\\\n       o += c * c.yzww  * (d-d*d)  / vec4(3,5,1,1);                     \\\n    }\n*/\n\n\n// 262 chars\n// Big thanks to FabriceNeyret2 for code reduction (and thus learning)\n/*#define mainImage(o,F)                                               \\\n    vec2 R = iResolution.xy;                                           \\\n    for(float d, t = iTime*.1, i = 0. ; i > -1.; i -= .06 )            \\\n    {   d = fract( i -3.*t );                                          \\\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \\\n        for (int j=0 ; j++ <27; )                                      \\\n            c.xzyw = abs( c / dot(c,c)                                 \\\n                         - vec4( 1.-.03*sin(t) , .9 , .1 , .15 -.14*cos(t*1.3)) );\\\n       o += c * c.yzww * (d-d*d)  / vec4(3,5,1,1);                    \\\n}\n/*\n\n//original \"short code\" 298 chars\n/*void mainImage( out vec4 o, in vec2 F )\n{\n    vec3 c;   \n    float t = iTime*.1,i,d;    \n\tfor(i=0.; i<1.; i+=.06)\n    {\n        d = fract(i+3.*t);   \n        o = vec4( (F-iResolution.xy*.5)/iResolution.y*(1.-d) ,-i,0)*28.;   \n    \tfor (int i=0 ; i++ <27;) o.xzyw = abs( o/dot(o,o) - vec4( 1.-.03*sin(t) , .9 , .1 , .15 -.14*cos(t*1.3)) );      \n\t\tc+= o.xyz*o.yzw*(d-d*d);\n    }        \n    o.rgb = c*vec3(.3,.2,1);\n}\n*/\n\n// for more clear code see https://www.shadertoy.com/view/WtjyzR", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtczM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[124, 233, 268, 268, 822]]}
{"id": "Wstcz7", "name": "MoreGloop", "author": "Del", "description": "brown shiny gloop", "tags": ["noise", "raymarch", "gloop"], "likes": 6, "viewed": 331, "published": 3, "date": "1600679376", "time_retrieved": "2024-07-30T20:44:03.840171", "image_code": "// more gloop (brown!)\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 4.\n\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n// noise\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;    \n    return k*0.4;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nfloat map( in vec3 pos )\n{\n    vec3 p2 = pos;\n    float c2 = pModInterval1(pos.z,5.0,-2.0,2.0);\n    pos.x += 0.1*c2;\n    float c1 = pModInterval1(pos.x,5.0,-2.0,0.0);\n    float d1 = sdCylinder(pos,vec2(0.8,HEIGHT))-0.5;\n    float t = iTime*1.1;\n    \n    float xo = sin(t*.2)*2.0;\n    \n    \n    float n1 = noise(pos+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(pos+vec3(xo,t*1.5,0.0), 1.5, 4.47, 1.43);\n    float n3 = noise(pos+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n    \n    float rnd = (124.6+c1) + (177.5*c2);\n    float rnd2 = (126.6+c1) + (9.9*c2);\n    rnd2 = 1.0+(abs(sin(rnd2))*0.1);\n    \n    float v1 = 0.8+sin(rnd+(t*rnd2)+pos.y*0.3);\n    n1 = smin(n1,n2,4.);\n    n1 = smin(n1,n3,4.);\n    n1 *= v1;\n  \td1 = smax(n1,d1,4.);\n    \n    pos=p2;\n    pos.y = abs(pos.y);\n\tfloat d2 = sdBox(pos-vec3(-5.0,HEIGHT,0.0),vec3(8.,0.25,12.))-0.1;\n    d1 = smin(d1,d2,0.8);\n    return d1*0.8;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.008;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\t//float an = 0.5*(iTime-10.0);\n    float an = sin(iTime)*0.5;\n\tvec3 ro = vec3( 10.0*cos(an), sin(iTime*0.75)*5.0, 10.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 45.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.05,0.05,0.03)*amb + vec3(0.35,0.1,0.05)*dif;\n \t\t\tcol+= pow(dif, 100.);//Observer - fake spec :)\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 105, 141, 141, 240], [241, 241, 272, 272, 363], [365, 387, 428, 428, 517], [518, 518, 557, 557, 586], [588, 597, 649, 649, 805], [807, 807, 880, 880, 1166], [1169, 1169, 1195, 1195, 2064], [2066, 2066, 2098, 2098, 2345]]}
{"id": "WdtyR7", "name": "Tonemap operators + Chen", "author": "hypernewbie", "description": "Originally created by Romain Guy: https://www.shadertoy.com/view/llXyWr\n\n- Orange: GT\n- Blue: ACES\n- Green: Unreal 3 matched to ACES\n- Pink: GT with different parameters\n- Yellow: AMD matched to ACES\n- Purple: XC tonemap", "tags": ["hdr", "tonemapping", "sdr"], "likes": 1, "viewed": 454, "published": 3, "date": "1600679249", "time_retrieved": "2024-07-30T20:44:04.665963", "image_code": "float Tonemap_ACES(float x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat Tonemap_Unreal(float x) {\n    // Unreal 3, Documentation: \"Color Grading\"\n    // Adapted to be close to Tonemap_ACES, with similar range\n    // Gamma 2.2 correction is baked in, don't use with sRGB conversion!\n    return x / (x + 0.155) * 1.019;\n}\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat Tonemap_Uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n    return Tonemap_Uchimura(x, P, a, m, l, c, b);\n}\n\nfloat Tonemap_Lottes(float x) {\n    // Lottes 2016, \"Advanced Techniques and Optimization of HDR Color Pipelines\"\n    const float a = 1.6;\n    const float d = 0.977;\n    const float hdrMax = 8.0;\n    const float midIn = 0.18;\n    const float midOut = 0.267;\n\n    // Can be precomputed\n    const float b =\n        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n    const float c =\n        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n\n    return pow(x, a) / (pow(x, a * d) * b + c);\n}\n\nfloat Tonemap_Chen(float x) {\n    // Cs = soft toe position\n    // Ct = soft toe strength\n    // Cl = soft shoulder position\n    // Ce = hard shoulder position\n    const float Cs = 5.9;\n    const float Ct = 0.37;\n    const float Cl = 0.517;\n    const float Ce = 0.8;\n    \n    // Soft smoothstep toe\n    float ts = x * smoothstep( 0.0, 1.0, x * Cs );\n    float x1 = mix( x, ts, Ct );\n    \n    // Piecewise linear + reinhard soft shoulder.\n    if ( x > Cl ) {\n        x1 -= Cl;\n        x1 = x1 / ( 1.0 + x1 ) + Cl;\n    }\n    \n    // Linear + exponential hard shoulder for SDR.\n    if ( x1 > Ce ) {\n        float y = ( x1 - Ce ) / ( 1.0 - Ce );\n        x1 = Ce + ( 1.0 - exp( -y ) ) * ( 1.0 - Ce );\n    }\n    \n    return x1;\n}\n\n\nfloat Tonemap_UC2( float x )\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n}\n\nfloat Tonemap_UC2_W( float x )\n{\n\tfloat W = 11.2;\n    x = Tonemap_UC2( 2.4f * x );\n\tx *= 1.0f / Tonemap_UC2( 11.2f );\n    return x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = mix( 2.8, 0.2, iMouse.y / iResolution.y );\n    vec2 uv = fragCoord.xy / (iResolution.y * zoom);\n    //uv.x += iMouse.x / iResolution.x * 3.0;\n\n    float p = 1.0 / (iResolution.y * 0.8);\n    float y = 0.0;\n\n    // Show LDR range (thanks iq)\n    fragColor.rgb = vec3(0.02) * step(uv.x, 1.0);\n    \n    y = 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n    y = 0.25;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.12, 0.12, 0.12), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n\n    y = Tonemap_Uchimura(uv.x);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.5, 0.0), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n\n    //y = Tonemap_Uchimura(uv.x, 1.0, 1.7, 0.1, 0.0, 1.33, 0.0);\n    //fragColor.rgb = mix(fragColor.rgb, vec3(0.8, 0.2, 0.6), 1.0 - smoothstep(0.0, 2.0 * p, abs(uv.y - y)));\n\n    y = pow( Tonemap_ACES(uv.x), 1.0 );\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.8, 0.8, 0.0), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n\n   // y = pow(Tonemap_Unreal(uv.x), 2.2);\n    //fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.1), 1.0 - smoothstep(0.0, 2.0 * p, abs(uv.y - y)));\n\n    y = Tonemap_UC2_W(uv.x);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.8), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n    \n    y = Tonemap_Chen(uv.x);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.3, 0.1, 0.8), 1.0 - smoothstep(0.0, 1.0 * p, abs(uv.y - y)));\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 85, 271], [273, 273, 304, 488, 526], [528, 528, 615, 799, 1267], [1269, 1269, 1302, 1302, 1618], [1620, 1620, 1651, 1733, 2263], [2265, 2265, 2294, 2424, 2988], [2991, 2991, 3021, 3021, 3212], [3214, 3214, 3246, 3246, 3347], [3349, 3349, 3404, 3404, 4924]]}
{"id": "3dtcz7", "name": "Random Rectangular Tiling", "author": "dr2", "description": "Dynamical extruded version of Shane's \"Asymmetric Blocks\"", "tags": ["rectangle", "tile", "pack", "extrude"], "likes": 23, "viewed": 752, "published": 3, "date": "1600677978", "time_retrieved": "2024-07-30T20:44:05.421942", "image_code": "// \"Random Rectangular Tiling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Just came across Shane's \"Asymmetric Blocks\"; here is a dynamical extruded version.\n  Original: https://www.shadertoy.com/view/Ws3GRs\n  Note that block edges cannot exceed twice the grid edge, and there are \n  restrictions on the combined length of multiple adjacent block edges (in a given \n  direction), so this is not a completely general tiling method (but it looks ok).\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\n\n#if 1  // = 1/0 - select extruded/flat version\n\nvec3 ltDir;\nvec2 pDisp;\nfloat tCur, dstFar, szFac;\nconst float pi = 3.1415927;\n\n#define H(z) (0.5 + 0.5 * cos (2. * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.05, 0.1));\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, h;\n  q = p;\n  d = PrBoxDf (q, vec3 (1., 0.02, 1.));\n  if (d < 0.1) {\n    h = 0.01 * smoothstep (0., 0.03 * szFac, RandRect (q.xz * szFac + pDisp));\n    q.y += h;\n    d = 0.9 * PrBoxDf (q, vec3 (1., 0.02 - h, 1.));\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, nDotL;\n  szFac = 8.;\n  pDisp = Rot2D (vec2 (0., 2. * szFac), 2. * pi * mod (0.01 * tCur, 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = vec3 (0.3, 0.7, 1.);\n    if (vn.y > 0.1) {\n      if (ro.y < 0.01) col *= 0.5;\n      else nDotL *= nDotL;\n    }\n    col = col * (0.2 + 0.8 * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -5.);\n  zmFac = 5.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\n#else\n\n// Flat version: \"Asymmetric Blocks\" by Shane - after some tweaking, and without the fancy visuals\n\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\n#define H(z) (0.5 + 0.5 * cos (2. * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, d, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.375;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.225, 0.05));\n  return dMin;\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  vec2 p, q;\n  float szFac;\n  szFac = 8.;\n  col = vec3 (0.7);\n  p = szFac * (uv + 0.04 * tCur);\n#if 0  // show grid\n  q = abs (fract (p) - 0.5) - 0.5;\n  col = mix (col, vec3 (0., 1., 0.), (1. - smoothstep (0., 0.01 * szFac, abs (max (q.x, q.y)))));\n#endif\n  col = mix (col, vec3 (0., 0., 1.), smoothstep (0.004 * szFac, 0.008 * szFac, RandRect (p)));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 1e5;\n  col = ShowScene (uv);\n  fragColor = vec4 (col, 1.);\n}\n\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[6890, 6890, 6922, 6922, 7022], [7024, 7024, 7071, 7071, 7118], [7120, 7120, 7156, 7156, 7362], [7364, 7364, 7394, 7394, 7507], [7541, 7541, 7565, 7565, 7625]]}
{"id": "Wsdyz7", "name": "Interlocked Moebius", "author": "machmuel", "description": "Raymarching-based example of interlocked moebius strips", "tags": ["raymarcher"], "likes": 8, "viewed": 287, "published": 3, "date": "1600677360", "time_retrieved": "2024-07-30T20:44:06.259702", "image_code": "// based on Martijn Steinrucken´s (aka The Art of Code/BigWings) \n// ray marching sample and trefoil node sample\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.1415926\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox2d(vec2 p, vec2 s) {\n    p.x = abs(p.x)-s.x;\n\tp.y = abs(p.y)-s.y/1.;\n    return length(max(p, 0.))+min(max(p.x, max(p.x, p.y)), 0.);\n}\n\nfloat sdTorus(vec3 p, vec3 s) {\n    float rMax= 1.4;\n    float rMin= .2;\n    \n    float radians = atan(p.x, p.z);\n    mat2 rotMat = Rot(iTime+0.+radians*0.25);\n    mat2 rotMat2 = Rot(3.1415/2.);\n    vec2 cp= vec2(length(p.xz)-rMax, p.y); \n    cp *= rotMat;\n    vec2 cp2 = cp*rotMat2;\n    cp.y = abs(cp.y)-.4;\n    cp2.y = abs(cp2.y)-.4;\n    //float d= length(cp)-rMin; // formula to have a circle as cross section\n    //float d= sdBox2d(cp, vec2(.003,+.2*(1.+pow(sin(radians*20.),4.0000))));\n    float d= sdBox2d(cp, 3.*vec2(.03,+.04+.12*abs(pow(sin(PI/2.+radians*6.25),6.))));\n    cp.y = abs(cp.y)-0.4;\n    float d2= sdBox2d(cp2, 3.*vec2(.03,+.04+.12*abs(pow(sin((radians)*6.25),6.))));// sdBox2d(cp, vec2(.01,+.07)); //length(vec2(length(p.xz)-(rMax+.6), p.y))-rMin;\n\treturn min(d-.03,d2-.03);\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdTorus(p, vec3(1));\n   \t\n    return d*.4 ;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS; // smaller steps to avoid glitches\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n\tfloat k= rd.y*.5+.5;\n    vec3 col = mix(vec3(.2,.1,.1), vec3(.2,.5,1.), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    col +=Bg(rd);\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        vec3 r = reflect(rd,n);\n    \tfloat spec = pow(max(0., r.y),30.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol = mix(Bg(r), vec3(dif), .5) + spec;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsdyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 262, 262, 324], [326, 326, 348, 348, 442], [444, 444, 473, 473, 554], [556, 556, 587, 587, 701], [703, 703, 734, 734, 1499], [1501, 1501, 1524, 1524, 1584], [1586, 1586, 1620, 1620, 1866], [1868, 1868, 1892, 1892, 2082], [2084, 2084, 2134, 2134, 2325], [2327, 2327, 2345, 2345, 2440], [2442, 2442, 2499, 2499, 3193]]}
{"id": "3dtcR7", "name": "Fire Cloud Sine ", "author": "celifrog", "description": "No I don't like starting from scratch.\nStarted from IQ's cloud post.", "tags": ["fork"], "likes": 3, "viewed": 369, "published": 3, "date": "1600673076", "time_retrieved": "2024-07-30T20:44:07.148326", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) - f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&11255,6),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv--+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y*f.y*f.y*f.y*f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x-rg.x, rg.y+rg.y-f.z, f.z+f.z-f.z-rg.x );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q++ ); q = q*2.02;\n    f += 0.25000*noise( q++ ); q = q*2.03;\n    f += 0.12500*noise( q++ ); q = q*2.01;\n    f += 0.06250*noise( q++ ); q = q*2.02;\n    f += 0.03125*noise( q++ );\n\treturn clamp( 1.5 * p.y / 12.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(9.0,990.1,-1.0)*-iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f+f+f+f+f+f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(11.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 10.50000*noise( q ); q = q+q+q*2.02;\n    f += 10.25000*noise( q ); q = q*2.03;\n    f += 10.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(11.0,0.1,0.1)*-iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,110.0,-1.0) );\n\n#define MARCH(STEPS,MAPLOD)\\\nfor(int i=0; i<STEPS; i++)\\\n{\\\n   vec3 pos = ro + t*rd;\\\n   if( pos.y<-13.0 || pos.y>112.0 || sum.a>10.99 ) break;\\\n   float den = MAPLOD( pos );\\\n   if( den++>0.01 )\\\n   {\\\n     float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 );\\\n     vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\\\n     vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\\\n     col.xyz *= lin*-lin;\\\n     col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\\\n     col.w *= 0.4;\\\n     \\\n     col.rgb *= col.a;\\\n     sum += col*(1.0-sum.a);\\\n   }\\\n   t += max(0.05,0.09*t);\\\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t =-4.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n\n    MARCH(480,map2);\n    MARCH(408,map2);\n    MARCH(30,map2);\n    MARCH(1130,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta+ta+ta+ta-ro-ro-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.171,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 15.2*vec3(61.66,-1.4,0.2)*pow( sun++, 3.0 );\n\n    return vec4( -col+col+col, -991.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy*p*p*p*p*p*p*p*p*p*p;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(5.0*m.x), 49.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcR7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[203, 203, 229, 229, 835], [837, 837, 862, 862, 1170], [1171, 1171, 1196, 1196, 1466], [1467, 1467, 1492, 1492, 1715], [1716, 1716, 1741, 1741, 1918], [2601, 2601, 2670, 2670, 2877], [2879, 2879, 2931, 2931, 3123], [3125, 3125, 3177, 3204, 3595], [3597, 3597, 3654, 3654, 4059], [4061, 4061, 4155, 4155, 4229]]}
{"id": "3sdyR4", "name": "2D ambient occlusion", "author": "Pidhorskyi", "description": "The scene is raymarched in 3D, however, ambient occlusion is computed using raymarching in 2D space. This trick is possible due to the specifics of the scene and allows less noisy result with few rays traced. ", "tags": ["occlusion"], "likes": 18, "viewed": 795, "published": 3, "date": "1600670786", "time_retrieved": "2024-07-30T20:44:08.322188", "image_code": "/* Stanislav Pidhorskyi - 2020 */\n\n#define PI 3.14159265359\n\n\n#define P2 0.0001 // precision\n#define P3 0.0001 // precision\n#define S 80.    // steps\n#define D 100.  // distance\n#define PI 3.14159265359\n\n#define N_RAYS 24.\n\nfloat sqr(float x) {return x * x; } \n\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 gamma(vec3 x) {\n    return mix(12.92 * x, 1.055 * pow(x, vec3(1.0 / 2.4)) - 0.055, step(0.0031308, x));\n}\n\n// SDF functions from iq: https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map2(vec2 p)\n{\n    p.x = abs(p.x);\n    \n \tfloat d = sdBox(p, vec2(0.3, 0.4));\n    d = max(d, -sdBox(p + vec2(-0.15, 0.0), vec2(0.1, 0.1)));\n    d = max(d, -sdBox(p + vec2(-0.15, -0.4), vec2(0.1, 0.1)));\n    d = max(d, -sdBox(p + vec2(-0.15, 0.4), vec2(0.1, 0.1)));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.5), 0.2));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.2), 0.1));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.0), 0.03));\n    d = min(d, sdCircle(p + vec2(-0.8, -0.2), 0.01));\n    d = min(d, sdTriangleIsosceles(-(p + vec2(-1.2, -0.0)), vec2(0.1, 0.3)));\n    return d;\n}\n\nfloat map3(vec3 p, float h)\n{\n \tfloat d = map2(p.xz);\n    d = max(d, sdBox(p + vec3(0., -h / 2., 0.), vec3(2., h / 2., 2.)));\n    d = min(d, sdBox(p + vec3(0., 0.1, 0.), vec3(2., 0.1, 2.)));\n    return d;\n}\n\nvec4 march(vec3 ro, vec3 rd, float h)\n{\n    float t = 0., s = float(S), d;\n    for(float i = 0.; i < S; i++)\n    {\n        d = map3(ro+rd*t, h);\n\n        if (d < P3 * t || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d;\n    }\n    \n    return vec4(ro+rd*t, t);\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(S), d;\n    for(float i = 0.; i < S; i++)\n    {\n        d = map2(ro+rd*t);\n\n        if (d < P2 * t || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0.))\n    {\n        mo = vec2(0.3, 0.5);\n    }\n    const vec3 lookat = vec3(0.0, 0.2, 0.0);\n    \n    float theta = 6.283*(0.25 * mo.y - 0.25);\n    vec3 ro = vec3(cos(6.283*mo.x) * sin(theta),\n                   cos(theta),\n                   sin(6.283*mo.x) * sin(theta));\n  \tro *= 4.0;\n    \n   \tfloat aspect = float(iResolution.x) / float(iResolution.y);\n    float vfov = 20.0f;\n    \n    float th = vfov * PI / 180.0;\n    float halfHeight = tan(th / 2.0);\n    float halfWidth = aspect * halfHeight;\n\tvec3 vup = vec3(0.0f, 1.0f, 0.0f);\n    \n    vec3 z = normalize(ro - lookat);\n    vec3 x = normalize(cross(vup, z));\n    vec3 y = normalize(cross(z, x));\n    \n    mat3 cam = mat3(x, y, z);\n    mat3 k = mat3(vec3(1.0 / halfWidth, 0, 0), vec3(0, 1.0 / halfHeight, 0), vec3(0.0, 0.0, -1.));\n    \n    vec2 uv = fragCoord / vec2(iResolution);\n    uv = 2.0 * uv - 1.0;\n\n    vec3 rd = cam * (normalize(inverse(k) * vec3(uv, 1.0)));\n\n    \n    float h = sqr((0.5 + 0.5 * cos(3.14 * iTime * 0.2))) * 0.6;\n    \n    vec4 res = march(ro, rd, h);\n    if (res.w > 10.0)\n    {\n    \tfragColor = vec4(gamma(vec3(0.6)),1.0);\n        return;\n    }\n    \n    h -= max(res.y, 0.);\n    \n    float d = map2(res.xz);\n    vec3 color;\n    if (d < -0.1 * P2)\n    \tcolor = vec3(1.);\n    else\n    {\n                float f = 0.;\n                vec2 rd = normalize(hash22(fragCoord + iTime * 1500. + 50.0) * 2.0 - 1.0); \n                for (float dir = 0.; dir < N_RAYS; ++dir)\n                {\n                    rd = mat2( cos(2. / N_RAYS * 3.14), sin(2. / N_RAYS * 3.14),\n                              -sin(2. / N_RAYS * 3.14), cos(2. / N_RAYS * 3.14)) * rd;\n                    vec4 r = march(res.xz, rd);\n                    \n                    float alpha = atan(h / r.w);\n                    // https://www.wolframalpha.com/input/?i=integrate+x+*+cos%28x%29+*+sin%28x%29+from+a+to+pi+%2F+2\n                    float I = 1./8. * (-sin(2. * alpha) + 2. * alpha * cos(2. * alpha) + PI);\n                    \n                    f += I;\n                }\n                f /= N_RAYS * PI / 8.;\n                color = vec3(f * 1.);\n\n\t}\n    \n    // Output to screen\n    fragColor = vec4(gamma(color * 0.6),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 244, 244, 259], [262, 302, 323, 323, 457], [459, 459, 479, 479, 569], [571, 645, 682, 682, 762], [763, 763, 798, 798, 826], [827, 827, 878, 878, 1186], [1187, 1187, 1218, 1218, 1305], [1307, 1307, 1327, 1327, 1882], [1884, 1884, 1913, 1913, 2090], [2092, 2092, 2131, 2131, 2394], [2396, 2396, 2426, 2426, 2687], [2690, 2690, 2747, 2747, 5001]]}
{"id": "WsdyRM", "name": "gloopytest", "author": "Del", "description": "just some random gloop", "tags": ["gloop"], "likes": 5, "viewed": 349, "published": 3, "date": "1600650832", "time_retrieved": "2024-07-30T20:44:09.666593", "image_code": "// gloop test (Cylinder+Noise)\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 4.\n\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n// noise\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;    \n    return k*0.4;\n}\n\nfloat map( in vec3 pos )\n{\n    float d1 = sdCylinder(pos,vec2(0.8,HEIGHT))-0.5;\n    vec4 tt = vec4(1.0,1.5,2.0,0.2)*(iTime*1.1);\n    float n1 = noise(pos+vec3(0.0,tt.x,0.0),1.0,3.57,.83);\n    float n2 = noise(pos+vec3(sin(tt.w)*2.0,tt.y,0.0), 1.5, 4.47, 1.43);\n    float n3 = noise(pos+vec3(0.0,tt.z,0.0), 2.0, 1.87,3.13);\n    n1 = smin(n1,n2,4.);\n    n1 = smin(n1,n3,4.);\n  \td1 = smax(n1,d1,4.);\n    pos.y = abs(pos.y);\n    float d2 = sdCylinder(pos-vec3(0.0,HEIGHT,0.0),vec2(2.5,0.25))-0.15;\n    d1 = smin(d1,d2,1.2);\n    return d1*0.8;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.008;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = sin(iTime*1.05)*0.65;\n\tvec3 ro = vec3( 7.0*cos(an), sin(iTime*0.75)*5.0, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 25.0;\n        float t = 0.0;\n        for( int i=0; i<80; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.02,0.1,0.02)*amb + vec3(0.15,0.45,0.05)*dif;\n            col+= pow(dif, 100.);//Observer - fake spec :)\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 114, 150, 150, 249], [250, 272, 313, 313, 402], [403, 403, 442, 442, 471], [472, 481, 533, 533, 689], [691, 691, 717, 717, 1231], [1233, 1233, 1265, 1265, 1512]]}
{"id": "3dtcRM", "name": "fork- Spooky Corridor", "author": "jorge2017a1", "description": "fork- Spooky Corridor\n//imagen\n//Referencia:por rammoskar en 2018-05-19\n//https://www.shadertoy.com/view/ldcfD2\n//sonido\n// fork https://www.shadertoy.com/view/MdfXWX\n//https://www.shadertoy.com/view/MdfXWX\n", "tags": ["forkspookycorridor"], "likes": 2, "viewed": 340, "published": 3, "date": "1600649108", "time_retrieved": "2024-07-30T20:44:10.680881", "image_code": "//Por JorgeFlores-jorge2017a1- 20-sep-2020\n//Referencia:por rammoskar en 2018-05-19\n//https://www.shadertoy.com/view/ldcfD2\n\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n\tfloat planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    res =opU3(res, vec3(planeDist3,33.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,33.0,MATERIAL_NO)); \n  \n\tvec3 q=p;\n    float cz=20.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    \n    \n    float sdb1= sdBox(p-vec3(-15.0,5.0,0.0), vec3(0.5,10.0,10.0) ); //pared izq\n    float sdb2= sdBox(p-vec3( 15.0,5.0,0.0), vec3(0.5,10.0,10.0) ); //pared der\n    float sdb3= sdBox(p-vec3( 0.0,-5.0,0.0), vec3(15.0,0.5,10.0) ); // piso\n    float sdb4= sdBox(p-vec3( 0.0,15.0,0.0), vec3(15.0,0.5,10.0) ); //techo\n\n    float sdb2BVentana= sdBox(p-vec3( 15.0,5.0,0.0), vec3(1.0,5.0,3.0) ); //pared der-ventana\n    float sdb1BPuerta= sdBox(p-vec3(-15.3,3.0,0.0), vec3(1.0,8.0,3.0) ); //pared izq\n    //puerta y diferencia \n     sdb2= differenceSDF(sdb2, sdb2BVentana);\n\t\n    \n    float sdcy1= sdCylinderYZ(p-vec3(-15.0,3.0,1.0), vec2(0.15,1.2));\n\tfloat sdsp1= sdSphere(p- vec3(-13.2,3.0,1.0), 0.5 );\n        \n   \n    res =opU3(res, vec3(sdb1,-1.0,3.0));\n    res =opU3(res, vec3(sdb2,-1.0,3.0));\n    res =opU3(res, vec3(sdb3,-1.0,4.0));\n    res =opU3(res, vec3(sdb4,COLOR_NO,4.0));\n    res =opU3(res, vec3(sdb1BPuerta,34.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdcy1,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdsp1,3.0,MATERIAL_NO));\n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nfloat BrickPattern(in vec2 p) \n{\n  p *= vec2 (1.0, 2.8);\n  vec2 f = floor (p);\n  if (2. * floor (f.y * 0.5) != f.y) \n    p.x += 0.5;\n  p = smoothstep (0.03, 0.08, abs (fract (p + 0.5) - 0.5));\n  return 1. - 0.9 * p.x * p.y;\n}\n\n\nfloat GridPattern(in vec2 uv)\n{\n  return 0.5*clamp(10.*sin(PI*uv.x) + 10.5, 0.0, 1.0)\n       / 0.5*clamp(10.*sin(PI*uv.y) + 10.5, 0.0, 1.0);\n}\n\nfloat SquareHolePattern(in vec2 uv)\n{\n  float thickness = 0.4;\n  float t = cos(uv.x*2.0) * cos(uv.y*2.0) / thickness;\n  return smoothstep(0.1, 0.0, t*t);\n}\n\nfloat floorPattern(vec2 p) \n\t{  return SquareHolePattern(p*7.2 - vec2(0.0, 0.0));}\n\nfloat roofPattern(vec2 p) \n\t{\treturn GridPattern(p*5.0);}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if (id_material==2.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }    \n    \n    \n    if (id_material==3.0)\n    {\n    \tvec2 uv=p.zy;\n        uv*=0.345;\n\n        float n=randomUV(uv);\n        vec3 brick = vec3(1.0, 0.16, 0.12)*(0.1 + 0.9 * n);\n        float pattern =  BrickPattern(uv);\n\t\t\n        \n        vec3 mortar = vec3(1.0);\n\t\tvec3 c = mix(brick, mortar, pattern);\n        return c;\n    }    \n    \n    if (id_material==4.0)\n    {\n    \tvec2 uv=p.xz;\n        uv*=0.38;\n    \t//return  floorPattern(uv) *vec3(1.0);\n        return  SquareHolePattern(uv) *vec3(1.0);\n        \n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.6);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    \n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n\n    \n    vec3 ro=vec3(0.0,2.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    float tt = mod(iTime,10.0);\n    float mt = 2.0;\n    float t1 = smoothstep(mt*0.0, mt*1.0, tt);\n\tfloat t2 = smoothstep(mt*1.0, mt*2.0, tt); \n\tfloat t3 = smoothstep(mt*2.0, mt*3.0, tt);\n    if (t1<t2)\n         rd.x+=0.5*sin(iTime);\n   \tif (t2<t1)\n        rd.y+=0.5*sin(iTime);\n    if (t3<t2)\n        rd.z+=0.5*sin(iTime);\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nfloat randomUV(vec2 uv) \n{ return fract(sin(dot(uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\nif(i== 32 ){ return vec3(185./255.0 , 159.0/255.0 , 93.0/255.0);}\n\nif (i==33 ) {return  mix(vec3(0.0), vec3(0.20,0.32,1.0), sin(itime*0.5)); }\nif (i==34 ) {return vec3(0.7); }\n}\n\n///--------------------------------------------\n\n", "sound_code": "//modificado por jorgeFlores --:)\n// fork https://www.shadertoy.com/view/MdfXWX\n//https://www.shadertoy.com/view/MdfXWX\n//Creado por Andre en 2014-08-11\n\n//#define PI2 6.28318530718\n#define RES 0.02\n#define trunc(a) float(int(a))\n\nfloat n2f(float note)\n{\n   return 55.0*pow(2.0,(note-3.0)/12.); \n}\n\nvec2 bass(float time, float tt, float note)\n{\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\nvec2 duhduh(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   tt = mod(tt,8.0);\n   if (tt <4.0)\n     tt = mod(tt,2.0);\n   else\n     tt = mod(tt,4.0);\n   return bass(time,tt-3.0,bn+3.)+\n          bass(time,tt-2.0,bn+3.)+\n          bass(time,tt-1.0,bn+0.)+\n          bass(time,tt-0.0,bn+0.);\n}\n\nvec2 duhduh2(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   int ti = int(mod(tt,8.0)/2.0);\n   tt = mod(tt,2.0);\n   if (ti == 0)\n     return bass(time,tt-0.83,bn+12.0)+\n            bass(time,tt-0.50,bn+12.0)+\n            bass(time,tt-0.17,bn+12.0);\n    \n   if (ti == 3)\n     return bass(time,tt-0.66,bn+15.)+\n            bass(time,tt-0.0,bn+15.);\n    \n   return bass(time,tt-0.66,bn+12.)+\n          bass(time,tt-0.0,bn+12.);\n}\n\nfloat note(float nr)\n{\n    if (nr<=15.)  return -120.;\n    if (nr<=16.)  return 31.;\n    if (nr<=17.)  return 56.;\n    \n    if (nr<=22.)  return 55.;\n    if (nr<=23.)  return -120.;\n    \n    if (nr<=24.)  return 58.;\n    if (nr<=25.)  return 42.;\n    if (nr<=30.)  return 43.;\n    \n    if (nr<=33.)  return -120.;\n    \n    if (nr<=34.5)  return 43.;\n    if (nr<=35.5)  return 39.;\n    if (nr<=37.0)  return 31.;\n    if (nr<=39.0)  return 34.;\n    if (nr<=39.5)  return 32.;\n    if (nr<=40.5)  return 31.;\n    if (nr<=41.0)  return -120.;\n    if (nr<=42.5)  return 31.;\n    if (nr<=43.0)  return 44.;\n    if (nr<=46.0)  return 43.;\n    \n    return -120.0;\n}\n\nfloat getSample(float time, float tt, float FM)\n{\n    tt -= mod(tt,RES);\n\n    float note1 = note(tt);\n    float note2 = note(tt+0.5);\n    if (note1 <0.0)\n        return 0.0;\n    \n    float stepper = smoothstep(0.1,0.5,mod(tt,0.5));\n    \n    float note = mix(note1,note2,stepper);\n    \n    float angle = PI2*n2f(note)*time;\n    return sin(angle+FM*sin(angle*2.033)+2.0*sin(angle*4.0));\n}\n\nvec2 theramin(float time, float tt)\n{\n    tt = mod(tt,48.0);\n    tt += 1.33;\n    float FM = 0.0;\n    if (tt>=32.)\n        FM = PI2/2.;\n        \n    float ssample;\n    float ta = mod(tt-RES/2.0,RES)-RES/2.0;\n    float halfSin = RES/4.0;//4.0/frequency;\n    if (abs(ta)<halfSin)\n    {\n        float sample1 = getSample(time,tt-RES/2.0,FM);\n        float sample2 = getSample(time,tt+RES/2.0,FM);\n        ssample = mix(sample1,sample2,smoothstep(-halfSin,halfSin,ta));\n    }\n    else\n        ssample = getSample(time,tt,FM);\n    \n    return vec2( ssample);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float tt = time *2.4;\n    \n    float d1 = clamp(duhduh(time,tt).x,-0.8,0.8)*1.3+\n               clamp(duhduh(time,tt-0.33).x,-0.5,0.5)*1.4+\n               clamp(duhduh(time,tt-0.66).x,-0.3,0.3)*2.0;\n    \n    float d2 = clamp(duhduh2(time,tt).x,-0.8,0.8)*.3+\n               clamp(duhduh2(time,tt-0.33).x,-0.8,0.8)*.2+\n               clamp(duhduh2(time,tt-0.66).x,-0.8,0.8)*.1;\n    \n    return 0.2*vec2(d1+0.5*d2,d2+0.5*d1)\n          +0.3*(\n            theramin(time,tt-0.75)*vec2(0.2,0.4)\n           +theramin(time,tt)*vec2(0.6,0.4)\n           +theramin(time,tt-0.506)*vec2(0.4,0.2)\n           +theramin(time,tt-1.00)*vec2(0.1,0.2));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 395, 395, 416], [417, 417, 449, 449, 533], [534, 534, 573, 573, 668], [669, 669, 708, 708, 803], [804, 804, 843, 843, 938], [940, 984, 1031, 1031, 1058], [1060, 1060, 1103, 1103, 1130], [1132, 1132, 1180, 1180, 1208], [1210, 1275, 1309, 1309, 1407], [1408, 1408, 1442, 1442, 1534], [1535, 1535, 1569, 1569, 1661], [1703, 1743, 1768, 1768, 3272], [3274, 3319, 3386, 3386, 3754], [3755, 3806, 3830, 3830, 4018], [4019, 4082, 4115, 4115, 4557], [4559, 4613, 4649, 4649, 4883], [4884, 4939, 5019, 5019, 5631], [5632, 5673, 5705, 5705, 5898], [5901, 5901, 5932, 5932, 6043], [6045, 6045, 6082, 6082, 6200], [6202, 6202, 6232, 6232, 6284], [6286, 6286, 6315, 6315, 6343], [6345, 6396, 6443, 6443, 7130], [7184, 7184, 7277, 7277, 7556], [7561, 7610, 7667, 7667, 9159]]}
{"id": "wscyz7", "name": "z Lightnings", "author": "illus0r", "description": "Lightnings", "tags": ["raymarching"], "likes": 3, "viewed": 378, "published": 3, "date": "1600642017", "time_retrieved": "2024-07-30T20:44:11.637324", "image_code": "#define MAX_STEPS 99\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.1415\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define n getNormal(p)\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define tChank 4.28125\n\nmat2 Rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat rnd(float x) {return 2.*fract(54321.987139 * sin(987.123452331 * x))-1.;}\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdTorus( vec3 p, vec2 t ){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\n\nfloat sdWater(vec3 p) {\n    float t = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+t);\n    p.y += .001*sin(p.z*13.+t);\n    p.y += .001*sin(p.x*11.+t*.5);\n    return p.y;\n}\n\n// float sdMirrors(vec3 p) {\n//     float c = 1.1;\n//     p.xy *= Rot(PI/4.);\n//     p.xz *= Rot(.1*iTime);\n//     vec3 l = vec3(2,0,2), id = floor(p/c);\n//     p = p-c*clamp(id,-l,l);\n//     p.xz *= Rot(p.y*(Rnd(id.x)+1.) + 30.*iTime * (Rnd(id.x + 10. * id.z)+1.5));\n//     // p.xz *= atan(p.x, p.z);\n//     return sdBox(p, vec3(.1,10.,.001));\n// }\n\nfloat sdRocket (vec3 p){\n    // p.y /= 2.;\n    // p.xz *= Rot(iTime);\n    // p.xy *= Rot(PI/4.);\n    float sph=length(p) - 1.;\n    // for(float i=2.;i<5.;i+=0.5){\n    //     // float shift = 4.*sin(iTime*i);\n    //     // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n    //     float shift = tan(iTime*(1.2+.4*rnd(i))+rnd(i))*10.;\n    //     float spread = 4.;\n    //     sph=opSmoothUnion(sph, (length(p*i+vec3(spread*rnd(i),shift,spread*rnd(i+1.))) - 1.)/i, .4);\n    // }\n    return sph*.7;\n}\n\n// float sdBeam(vec3 p){\n//     p.xy *= Rot(PI/4.);\n//     float size = 3.*Rnd(iTime)*.5+.5;\n//     vec3 shift = 2.4*(vec3(Rnd(iTime+9.), 0, Rnd(iTime+99.))*.5);\n//     return sdBox(p+shift, vec3(.2*size,100.,.2*size));\n// }\n\nfloat timeCurve(float t) {\n    t = t * 4. / tChank;\n    // t = t / 1000.;\n    float whole = floor(t);\n    float decimal = fract(t);\n    t =  (whole + 1. - pow(1. - decimal, 32.));\n    return t;\n}\n\n\nfloat lightning(vec3 p, vec2 amp){\n    float id = floor(p.x);\n    vec2 shift=     vec2(rnd(id+   iTime*1.0),\n                          rnd(id+   iTime*1.0+10.));\n    vec2 shiftNext = vec2(rnd(id+1.+iTime*1.0),\n                          rnd(id+1.+iTime*1.0+10.));\n    vec2 shift_ = shift, shiftNext_ = shiftNext;\n     // shift=shift*.5+.5; shiftNext=shiftNext*.5+.5;\n    shift=pow(shift,vec2(4.)); shiftNext=pow(shiftNext,vec2(4.));\n    shift*=shift_/abs(shift_); shiftNext*=shiftNext_/abs(shiftNext_);\n    // shift=shift*2.-1.; shiftNext=shiftNext*2.-1.;\n    shift*=amp; shiftNext*=amp;\n    // shift.y=shiftNext.y=0.;\n    // shift.x=shiftNext.x=0.;\n    p.x -= id;\n    p.yz += shift;\n    // p.zx *= Rot(iTime);\n    float dx = 1.,\n          dy = shiftNext.x-shift.x,\n          dz = shiftNext.y-shift.y;\n    p.xy *= Rot(atan(dy, dx));\n    p.zx *= Rot(-atan(dz, length(vec2(dx, dy))));\n    return length(p.yz);\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    // // fractal lines\n    //float t = iTime*10.;//4.*sin(iTime*5.);\n    // for(int j=0;j<2;j++){\n    //     p=abs(p)-1.1;\n    //     p.xz*=Rot(t / 5.91 + float(j));\n    //     p.xy*=Rot(t / 3.21 + float(j));\n    // }\n    // p.y+=1.;\n    // float wave = 0.;//pow(sin(length(p + fract((iTime+.2) * 4. / tChank)))*.5+.5, 64.)*.2;\n    // p.y *= .99;\n    // //vec2 obj = vec2(sdBox(p,vec2(100,.01).yxy), WHITE_MIRROR);\n    // p.xz*=Rot(iTime);\n\n    float rocket = sdRocket(p);\n\n    p.z-=10.;\n    // p.xy=abs(p.xy);\n    // p.xy*=Rot(-PI/4.);\n    p.xy*=Rot(1000.*rnd(floor(iTime*4.16)));\n    p.x-=2.;\n    p.xz*=Rot(PI/2.2);\n    // p.zy *= Rot(iTime);\n    p.x *= .2;\n    vec2 amp=vec2(1.5);\n    float obj = lightning(p, amp);\n    obj = min(obj, rocket);\n    return vec2(obj*.6, WHITE_MIRROR);\n    // return vec2(length(p)-1., WHITE_MIRROR);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dTotal=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color, p, rm;\n    float camDist = -10.;// + 5.*sin(timeCurve(iTime));//-17.+12.*smoothstep(2., 2.3, fract(iTime/5.)*5.);\n    ro = vec3(0,0,camDist);\n    // ro.xz *= Rot(timeCurve(iTime));\n    // ro.xy *= Rot(PI/4.);\n    // ro += 1.1*sin(iTime*4.)*vec3(Rnd(iTime),Rnd(iTime+100.),0); // shake\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    color = vec3(0);\n    float colorAmount = 0.;\n\n    for(int reflectionDepth = 0; reflectionDepth < 2; reflectionDepth++) {\n        rm = rayMarch(ro, rd);\n        dTotal += d = rm[0];\n        info = rm[1];\n        p = ro + rd * d;\n        if (d < MAX_DIST) {\n            // color = vec3(1);//textureCube(iChannel0, rd).rgb;\n            if (info == MIRROR) {\n                rd = reflect(rd, n);\n                ro = p + 0.01 * rd;\n                continue;\n                // do nothing, propogate color getting to the reflection\n            }\n            else if (info == WHITE_MIRROR) {\n                vec3 nn = n;\n                nn.xy*=Rot(1.);\n                // color = vec3(1) * (dot(nn, vec3(1,1,-1))*.3+.7);\n                color = nn*.5+.5;\n            }\n            else if (info == PUREWHITE) {\n                color += vec3(1) * (1. - colorAmount);\n                colorAmount = 1.;\n            }\n        }\n        else {\n            // color += textureCube(iChannel0, vec3(rd.y, rd.xz*Rot(iTime)).yxz).rgb * (1. - colorAmount);\n            // colorAmount = 1.;\n        }\n        break;\n    }\n    // color = mix(color, vec3(0,uv.yx+.5)*.2, smoothstep(20., 100., dTotal));\n    color = mix(color, rd*.2, smoothstep(20., 100., dTotal));\n    fragColor = vec4(color, 1);\n\n    rm = rayMarch(ro, rd);\n    fragColor = vec4(vec3(.003/rm.z), 1);\n    // fragColor = vec4(1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 339, 339, 397], [398, 398, 429, 429, 512], [513, 513, 551, 551, 801], [802, 802, 822, 822, 881], [882, 882, 934, 934, 1025], [1026, 1026, 1058, 1058, 1118], [1120, 1120, 1143, 1143, 1288], [1641, 1641, 1665, 1737, 2158], [2386, 2386, 2412, 2412, 2581], [2584, 2584, 2618, 2618, 3492], [3494, 3573, 3595, 4036, 4432], [4521, 4521, 4554, 4554, 5008], [5010, 5010, 5034, 5034, 5254], [5256, 5256, 5310, 5310, 5537], [5539, 5539, 5589, 5589, 5780], [5885, 5885, 5941, 5941, 7761]]}
{"id": "tljBWy", "name": "Hexprism - intersection", "author": "iq", "description": "Ray-hexgonal-prism intersector. It computes the entry point and the normal at the intersection point. Returning the exit point is trivial (return tF). Can be easily optimized for many aligned instances.\n", "tags": ["3d", "raycasting", "raycast", "intersection", "prism", "hexagonal", "intersector"], "likes": 8, "viewed": 1068, "published": 3, "date": "1600634950", "time_retrieved": "2024-07-30T20:44:12.511985", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray-hexgonal-prism intersector. It computes the entry point and\n// the normal at the intersection point. Returning the exit point\n// is trivial (return tF).\n//\n// If many hexagonal parallel prisms were to be computed, many of the\n// computations could be taken our as common factors. See here:\n//\n// https://www.shadertoy.com/view/WtSfWK\n//\n// Discarding the normal computation and specializing this\n// function to be a shadow-only test also simplifies the code\n// a big deal (see same shader above).\n//\n//\n// List of ray-surface intersectors at\n//   https://www.shadertoy.com/playlist/l3dXRf\n// and\n//    https://iquilezles.org/articles/intersectors\n\n\n\nvec4 iHexPrism( in vec3  ro, in vec3  rd, \n                in float ra, in float he )\n{\n    const float ks3 = 0.866025;\n\n    // normals\n    const vec3 n1 = vec3( 1.0,0.0,0.0);\n    const vec3 n2 = vec3( 0.5,0.0,ks3);\n    const vec3 n3 = vec3(-0.5,0.0,ks3);\n    const vec3 n4 = vec3( 0.0,1.0,0.0);\n\n    // slabs intersections\n    vec3 t1 = vec3((vec2(ra,-ra)-dot(ro,n1))/dot(rd,n1), 1.0);\n    vec3 t2 = vec3((vec2(ra,-ra)-dot(ro,n2))/dot(rd,n2), 1.0);\n    vec3 t3 = vec3((vec2(ra,-ra)-dot(ro,n3))/dot(rd,n3), 1.0);\n    vec3 t4 = vec3((vec2(he,-he)-dot(ro,n4))/dot(rd,n4), 1.0);\n    \n    // intersection selection\n    if( t1.y<t1.x ) t1=vec3(t1.yx,-1.0);\n    if( t2.y<t2.x ) t2=vec3(t2.yx,-1.0);\n    if( t3.y<t3.x ) t3=vec3(t3.yx,-1.0);\n    if( t4.y<t4.x ) t4=vec3(t4.yx,-1.0);\n   \n    vec4            tN=vec4(t1.x,t1.z*n1);\n    if( t2.x>tN.x ) tN=vec4(t2.x,t2.z*n2);\n    if( t3.x>tN.x ) tN=vec4(t3.x,t3.z*n3);\n    if( t4.x>tN.x ) tN=vec4(t4.x,t4.z*n4);\n    \n    float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n    \n    // no intersection\n    if( tN.x > tF || tF < 0.0) return vec4(-1.0);\n\n    return tN;  // return tF too for exit point\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.7*cos(an), 1.0, 1.7*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace\n        vec4 tnor = iHexPrism( ro, rd, 0.6, 0.7 );\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.8,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + \n                  vec3(0.8,0.7,0.5)*dif + \n                  0.1*nor.z;\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBWy.jpg", "access": "api", "license": "mit", "functions": [[1735, 1735, 1822, 1822, 2870]]}
{"id": "wscyRM", "name": "IAI - GamleMelk", "author": "kloumpt", "description": "melk", "tags": ["melk"], "likes": 3, "viewed": 311, "published": 3, "date": "1600625342", "time_retrieved": "2024-07-30T20:44:13.641964", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = 1.0 - uv.x;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 data = texture(iChannel0, uv).rgba;\n    \n    vec4 new_data = vec4(0.0, 0.0 , data.z, 0.0);\n    \n\n    vec3 source_image = texture(iChannel1, uv).rgb;\n    vec2 image_diff = vec2(0.0);\n    float edges =  0.0;\n    \n    \n    vec2 speed_diff = vec2(0.0);\n    \n    for (int x = -1; x<=1; x++) {\n        for (int y = -1; y<=1; y++) {\n            vec2 dir = vec2(float(x), float(y)) * 1.0;\n            vec4 data_B = texture(iChannel0, uv + dir / iResolution.xy).rbga;\n            vec4 data_diff = data_B - data;\n            \n\t\t\tnew_data.xy += data_diff.xy * dir;\n            new_data.z += step(0.1, length(data_diff.xy)) * dot(data_diff.xy, -dir);\n            \n            image_diff += dir * length(texture(iChannel1, uv + dir / iResolution.xy).rbg);\n        }\n    }\n    new_data.w  = length(image_diff);\n    new_data.w  = smoothstep(0.2, 0.25, new_data.w);\n    new_data.w  = mix(data.w, new_data.w, 0.25);\n    \n    \n    //new_data = clamp(new_data, vec4(-1.0), vec4(1.0));\n    \n    new_data.xy = mix(data.xy, new_data.xy * 0.9, 0.75);\n    new_data.z = mix(data.z, new_data.z  * 1.0 / 5.0, 0.75);\n    //new_data.z = max(0.0, new_data.z);\n    \n    new_data = clamp(new_data, vec4(-1.0), vec4(1.0));\n    \n    new_data = mix(new_data, vec4(0.0, 0.0, 1.0, new_data.w), new_data.w );\n    \n    \n    fragColor = new_data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 data = texture(iChannel0, uv).rgba;\n    vec3 col = texture(iChannel1, uv).rgb;\n    vec3 col_bg = texture(iChannel2, uv + 10.0 * data.xy / iResolution.xy).rgb;\n    \n    col = mix(col, col_bg,  1.0 - data.w);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 284]]}
{"id": "Wd3yz7", "name": "cuarto-corazon", "author": "jorge2017a1", "description": "cuarto-corazon", "tags": ["cuartocorazon"], "likes": 3, "viewed": 283, "published": 3, "date": "1600617141", "time_retrieved": "2024-07-30T20:44:14.723074", "image_code": "//por jorge2017a1-\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 40.0-p.y;  //piso sup\n    float planeDist3 = p.x+20.0; //pared izq\n    float planeDist4 = 20.0-p.x;  //pared der\n    float planeDist5 = -p.z+30.0;  //pared frente\n    float planeDist6 = p.z+30.0;  //pared atras\n   \n    res =opU3(res, vec3(planeDist1,COLOR_NO,4)); //inf\n    res =opU3(res, vec3(planeDist2,COLOR_NO,4)); \n    res =opU3(res, vec3(planeDist3,COLOR_NO,6)); \n    res =opU3(res, vec3(planeDist4,COLOR_NO,6)); \n  \tres =opU3(res, vec3(planeDist5,COLOR_NO,3)); \n    res =opU3(res, vec3(planeDist6,COLOR_NO,3)); \n  \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    \n       \n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\n\n///-----------------------------------\nvec3 estrellasflotando( vec2 uv )\n{\n\tvec2 coord = uv;\n\n\tvec3 color = vec3(0., 0., 0.0);\n\n\tfor (float i = 0.; i < 20.; i++) {\n\t\tconst float min_period = 10.;\n\t\tconst float max_period = 30.;\n\t\tfloat period = min_period + rand(vec2(i, 0.))*(max_period - min_period);\n\n\t\tfloat start = period*rand(vec2(i, 1.));\n\n\t\tconst float min_radius = .01;\n\t\tconst float max_radius = .05;\n\t\tfloat radius = min_radius + rand(vec2(i, 2.))*(max_radius - min_radius);\n\n\t\tfloat r = iTime - start;\n\t\tvec2 pos = vec2((mod(r, period))*2./period-.9, rand(vec2(.1*ceil(r/period), i))); // Fixed stars popping in and out of screen\n\n\t\tconst float min_angle_speed = -.5;\n\t\tconst float max_angle_speed = .5;\n\t\tfloat angle_speed = min_angle_speed + rand(vec2(i, .3))*(max_angle_speed - min_angle_speed);\n\n\t\tfloat angle = atan(pos.y - coord.y, pos.x - coord.x) + angle_speed*iTime;\n\n\t\tfloat dist = radius + .3*sin(5.*angle)*radius;\n\t\tvec3  coltmp=vec3(rand(vec2(i, 4.)), rand(vec2(i, 5.)), rand(vec2(i, 6.)));\n\t\tcolor += (1. - smoothstep(dist, dist + .01, distance(coord, pos)))*coltmp;\n\t}\n\n\treturn color;\n}\n\n///---------------------------------------\nvec3 sdCorazon(vec2 pp )\n{\n     \n      vec2 p =pp;\n\n    // background color\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss -= ss*0.2*sin(tt*6.2831*3.0)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n   \n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    \n    \n    if (id_material==3.0)\n    {     \n        vec2 uv= mObj.p.xy/10.0;  //frente atras\n        uv.y -= 2.25;\n    \treturn sdCorazon(uv);\n\t}\n    \n    \n    if (id_material==4.0)  \n    {     \n        vec2 uv= mObj.p.xz/14.0;  //piso\n        uv.y -= 0.25;\n    \treturn sdCorazon(uv);\n\t}\n    \n    if (id_material==5.0)  //pared izq der\n    {     \n        vec2 uv= mObj.p.yz/10.0;\n        uv.y -= 0.25;\n        uv.x -= 2.25;\n    \treturn sdCorazon(uv);\n\t}\n    \n    if (id_material==6.0)  //pared izq der\n    {     \n        vec2 uv= mObj.p.zy/20.0;\n        uv.y -= 0.5;\n    \treturn estrellasflotando(uv );\n     }   \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 4.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n\n\n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3yz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 272, 272, 293], [294, 294, 326, 326, 410], [411, 411, 457, 457, 544], [545, 545, 579, 579, 641], [642, 642, 679, 679, 774], [775, 775, 814, 814, 909], [910, 910, 949, 949, 1044], [1045, 1045, 1084, 1084, 1179], [1181, 1225, 1272, 1272, 1299], [1301, 1301, 1344, 1344, 1371], [1373, 1373, 1421, 1421, 1449], [1450, 1521, 1555, 1555, 1653], [1654, 1654, 1688, 1688, 1780], [1781, 1781, 1815, 1815, 1907], [1908, 1988, 2013, 2013, 2775], [2777, 2822, 2889, 2889, 3257], [3258, 3309, 3333, 3333, 3521], [3522, 3585, 3618, 3618, 4060], [4062, 4116, 4152, 4152, 4386], [4387, 4442, 4491, 4491, 4713], [4714, 4748, 4828, 4828, 5453], [5496, 5496, 5517, 5517, 5585], [5587, 5626, 5661, 5661, 6700], [6702, 6745, 6771, 6771, 7512], [7514, 7565, 7612, 7612, 8279], [8333, 8333, 8426, 8426, 8853], [8857, 8906, 8963, 8963, 10943]]}
{"id": "Ws3cR7", "name": "Band Limited Tie Dye ", "author": "celifrog", "description": "Idk  thanks  IQ for this site and all of your posts. :) \nIdk 5% credit to me.   ", "tags": ["fork"], "likes": 3, "viewed": 311, "published": 3, "date": "1600614305", "time_retrieved": "2024-07-30T20:44:15.542881", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(11.5*w)/(-1.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(5.2832,99.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = true;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/articles/palettes)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(421.6,0.5,0.4);\n    col += 0.14*-mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*-mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*-mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*-mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*-mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*-mcos(6.2832*t*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*-mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.01*-mcos(6.2832*t*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (1.4*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.019) ? (5.0*iMouse.y-iResolution.y)/iResolution.y : 2.8*sin(iTime);\n    mode = (q.x+q.y<th);\n    \n    // deformation\n    vec2 p = 2.0*q*q/dot(q,q);\n\n    // animation\n    p.xy += 5.05/iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x*p.y*p.x),getColor(p.y*p.x*p.x*p.x));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(-q*q*q*q*q*q*q*q*q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x*q.y*th*th));\n    \n    // palette\n    if( q.y<-51.9 ) col = getColor( fragCoord.x*iResolution.x );\n\n    fragColor = vec4( col, 5.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cR7.jpg", "access": "api", "license": "mit", "functions": [[1843, 1864, 1888, 1888, 2054], [2118, 2118, 2138, 2138, 2166], [2168, 2260, 2289, 2289, 2803], [2805, 2805, 2861, 2880, 3525]]}
{"id": "3styRH", "name": "basic vector upscaling filter", "author": "public_int_i", "description": "Upscaling filter by trying to find line/vectors, basically connects similar diagonal pixels. Super simple algorithm just to test the idea after seeing all the AI/DLSS upscaling stuff. I believe this is similar to https://www.shadertoy.com/view/MslGRS", "tags": ["line", "pixel", "filter", "vector", "art", "scale", "upscaling", "up"], "likes": 17, "viewed": 1229, "published": 3, "date": "1600598739", "time_retrieved": "2024-07-30T20:44:16.351719", "image_code": "/*Copyright 2020 Ethan Alexander Shulman\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/\n\n//upscaling multiplier amount\n#define UPSCALE 10.\n\n//image mipmap level, for base upscaling\n#define ML 0\n\n//equality threshold of 2 colors before forming lines\n#define THRESHOLD .1\n\n//line thickness\n#define LINE_THICKNESS .4\n\n//anti aliasing scaling, smaller value make lines more blurry\n#define AA_SCALE (UPSCALE*1.)\n\n\n//draw diagonal line connecting 2 pixels if within threshold\nvec4 diag(vec4 sum, vec2 uv, vec2 p1, vec2 p2) {\n    vec4 v1 = texelFetch(iChannel0,ivec2(uv+vec2(p1.x,p1.y)),ML),\n        v2 = texelFetch(iChannel0,ivec2(uv+vec2(p2.x,p2.y)),ML);\n    if (length(v1-v2) < THRESHOLD) {\n    \tvec2 dir = p2-p1,\n            lp = uv-(floor(uv+p1)+.5);\n    \tdir = normalize(vec2(dir.y,-dir.x));\n        float l = clamp((LINE_THICKNESS-dot(lp,dir))*AA_SCALE,0.,1.);\n        sum = mix(sum,v1,l);\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sliderX = iMouse.x<5.?\n        \t(fract(iTime*.2)-max(0.,fract(iTime*.2)*2.-1.))*2.*iResolution.x:\n    \t\tiMouse.x;\n    vec2 ip = fragCoord/UPSCALE;\n    \n    if (fragCoord.x < sliderX) {\n        //regular nearest sampling\n    \tfragColor = texelFetch(iChannel0,ivec2(ip.x,ip.y),ML);\n        \n    } else {\n        \n        //start with nearest pixel as 'background'\n        vec4 s = texelFetch(iChannel0,ivec2(ip),ML);\n\n        //draw anti aliased diagonal lines of surrounding pixels as 'foreground'\n        s = diag(s,ip,vec2(-1,0),vec2(0,1));\n        s = diag(s,ip,vec2(0,1),vec2(1,0));\n        s = diag(s,ip,vec2(1,0),vec2(0,-1));\n        s = diag(s,ip,vec2(0,-1),vec2(-1,0));\n\n        fragColor = s;\n    }\n    \n    //draw slider bar\n    if (abs(fragCoord.x-sliderX) < 1.) fragColor = vec4(1,0,1,1);\n    \n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styRH.jpg", "access": "api", "license": "mit", "functions": [[1385, 1446, 1494, 1494, 1889], [1891, 1891, 1948, 1948, 2765]]}
{"id": "WscyRM", "name": "OS detector", "author": "FabriceNeyret2", "description": "auto - detect your system from different implementation bugs :-)\nPrecision : mantissa. full IEEE32 = 23 bits\n\nOf course I might be wrong, and I cannot test beside mine: tell me ! ( + your OS, browser, GPU )\nAny idea how to test Android ? Iphone ?", "tags": ["glsl", "bug", "compatibility"], "likes": 29, "viewed": 1237, "published": 3, "date": "1600591773", "time_retrieved": "2024-07-30T20:44:17.207431", "image_code": "// --- draw messages              // https://www.shadertoy.com/view/llySRh\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n#if  __VERSION__ >= 300                    // webGL2\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n#else                                      // webGL1\n\treturn texture( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ) ); \n#endif\n}\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\n\n\nvoid mainImage( out vec4 O, vec2 u )   // ---------------------------------\n{\n    vec2  R = iResolution.xy,\n         uv = u / min(R.x,1.77*R.y)*1.77, U;\n    float Z = min(0.,iTime),           // to prevent optimizations and compile-time expressions resolution\n          left = .05;\n    vec4  _O = O, M = O; M += 1.-M;    // for old macs\n    if (uv.y<.9) O-=O;                 // let some have fancy random top line ;-)\n    \n    U = ( uv - vec2(left,.8) ) * 8.;   // --- webGL version ( cf https://www.shadertoy.com/view/4djyRt )\n    caps C(23) low C(5)C(2) caps C(7)C(12)\n#if  __VERSION__ >= 300                // webGL2\n        C(-14)\n#else                                  // webGL1\n        C(-15)\n#endif\n                                       // --- testing extensions ( cf https://webglreport.com/?v=2 )\n/*                                     // test webGL1 extensions\n    spc spc low C(20)C(5)C(24)C(20) caps C(12)C(15)C(4)C(-6) low\n#ifdef GL_EXT_shader_texture_lod       // textureLOD\n    C(25)C(5)C(24)\n#else\n    C(14)C(15)\n#endif\n#ifdef GL_EXT_gpu_shader4              // texelFetch        \n    C(25)C(5)C(24)\n#else\n    C(14)C(15)\n#endif    \n*/\n/*                                     // test webGL2 extensions\n    spc spc low C(6)C(12)C(15)C(1)C(20) caps C(2) low C(21)C(6) caps C(-6) low\n#ifdef GL_EXT_color_buffer_float\n    C(25)C(5)C(24)\n#else\n    C(14)C(15)\n#endif\n*/\n    U = ( uv - vec2(left*12./8.,.7) ) * 12.;                             // --- state of init fragColor\n    low C(6)C(18)C(1)C(7) caps C(3) low C(15)C(12)C(15)C(18) caps C(-6)\n         if ( _O==vec4(0) )     { C(-16)C(-16)C(-16)C(-16) }\n    else if (_O==vec4(0,0,0,1)) { C(-16)C(-16)C(-16)C(-15) }\n    else                        { low C(18)C(1)C(14)C(4) } \n\n    spc spc spc caps C(2) low C(21)C(6)C(6)C(5)C(18)C(19) caps C(-6) low // --- test buffers\n    if (texelFetch(iChannel0,ivec2(0), 0).z == 123. ) { C(15)C(14) }\n    else {C(15)C(6)C(6)}\n       \n    spc spc spc C(4) caps C(6) low C(4)C(24) caps C(-6) C(-16+int(dFdx(u.x))) //  --- test dFdx\n    U = ( uv - vec2(left*12./8.,.6) ) * 12.; \n    //low C(4) caps C(6) low C(4)C(24) caps C(-24)low C(3)C(8)C(5)C(3)C(11)C(5)C(18) caps C(-23)C(-6)\n    //dFdx(mod(u.x+u.y,2.)\n    \n    U = ( uv - vec2(left,.5) ) * 8.;                                     // --- testing OS\n    caps C(25) low C(15)C(21)  spc C(1)C(18)C(5) spc C(15)C(14) spc caps\n    if ( sqrt(-1.+Z) == 1. ) {                                           // windows D3D - 1\n        // or first O = 0,0,0,1 , or so many others\n        C(23) low C(9)C(14)C(4)C(15)C(23)C(19) spc caps C(4)C(3-16)C(4) caps C(-1) C(-24)C(-15)C(-23)\n    }\n    else if ( _O == vec4(0,0,0,1) ) {                                    // windows D3D - 2\n        C(23) low C(9)C(14)C(4)C(15)C(23)C(19) spc caps C(4)C(3-16)C(4) spc caps C(-24)C(-14)C(-23)\n    }\n    else if (M != vec4(1) ) {                                            // old Mac\n        // or was it O -= O-1 that failed ?\n        low C(15)C(12)C(4) spc caps C(13) low C(1)C(3)  // C(7) low C(18)C(5)C(7)\n    }\n/*  else if (  smoothstep(1.,0.,.5+Z) != 1. - smoothstep(0.,1.,.5+Z) ) { // (old?) AMD\n        C(15)C(14) spc caps C(1)C(13)C(4)\n    }\n*/  else {                                                               // OpenGL\n        // or normalize(0) = NaN\n        C(15) low C(16)C(5)C(14) caps C(7)C(12)\n    }\n        // testing (modern) Mac :  ideas ?\n        // testing Android: ideas ? missing extensions ? assuming webGL2 compiles...\n        // testing iPhone:  ideas ?\n        // testing browser: idea ? ( at least Firefox vs Chrome )\n                       \n    if (texelFetch(iChannel0,ivec2(0), 0).x > 1. ) {                     // --- is icon ?    \n        U = ( uv - vec2(left*1.5,.3) ) * 8.;\n        caps C(-24) spc low C(9)C(14) spc C(9)C(3)C(15)C(14) spc C(13)C(15)C(4)C(5) spc caps C(-23)\n    }\n        // testing fullscreen:  ideas ?\n    \n    // --- compute float mantissa precision ( cf https://www.shadertoy.com/view/WtXBz2 )\n    float b = 1.; int i = 0;\n // for (  ; i < 32; i++, b*=2. )\n    for (int _i=0  ; _i < 32; _i++ ) { // webGL1 compatible\n        if ( fract( b + .5 ) == 0.)  break;\n        i++, b*=2.;\n    }\n    U = ( uv - vec2(left,.1) ) * 8.;  \n    caps C(6)low C(12)C(15)C(1)C(20) spc C(16)C(18)C(5)C(3)C(9)C(19)C(9)C(15)C(14) \n    caps C(-6) spc C(i/10-16) C(i-i/10*10 -16) spc low C(2)C(9)C(20)C(19)\n                             // i%10 doesn't exist in webGL1 \n    // --- texture precision\n// for ( i = 0 ; i < 32; i++ )    \n   i=0; for (int _i=0  ; _i < 32; _i++ ) { // webGL1 compatible\n       if ( fract(texelFetch(iChannel0,ivec2(0,i), 0)).y == 0.)  break; \n       i++;\n   }\n    U = ( uv - vec2(left,.0) ) * 8.35; \n    caps C(2) low C(21)C(6)C(6)C(5)C(18) spc C(16)C(18)C(5)C(3)C(9)C(19)C(9)C(15)C(14) \n    caps C(-6) spc C(i/10-16) C(i-i/10*10 -16) spc low C(2)C(9)C(20)C(19)\n    \n\n    O = O.xxxx;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if  ( U == vec2(.5) )\n        O.z = 123.,\n        O.x = iFrame==0 ? iTime : texelFetch(iChannel0,ivec2(0),0).x; // test init iTime\n    \n    if  ( U.x < 1. && U.y < 32. )                                     // test buffer precision \n        O.y = exp2(floor(U.y)) + .5;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if  __VERSION__ < 300                    // webGL1 only\n  #define texelFetch(ch,u,l) texture(ch,(.5+vec2(u)*exp2(float(l)))/iResolution.xy, float(l) )\n#endif\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 102, 102, 518]]}
{"id": "wddyzN", "name": "Paint 2d", "author": "iuryBorgesRodrigues", "description": "paint,daw,2d,sdf", "tags": ["paint"], "likes": 1, "viewed": 320, "published": 3, "date": "1600586516", "time_retrieved": "2024-07-30T20:44:18.038210", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=iTime;\n    if(t<0.5)\n    {\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    if(sdPentagon(fragCoord.xy-iMouse.xy,0.5)>5.0)\n        discard;\n\tfragColor = vec4(1.0,1.0,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 102, 102, 182], [183, 183, 225, 225, 436], [437, 437, 480, 480, 762], [763, 763, 820, 820, 1028]]}
{"id": "tsdcRN", "name": "color fusion 5", "author": "FabriceNeyret2", "description": "around mouse: color (or right screen: luminance) is decomposed into separate colors over time.\nbottom: paint every 3 frames\nright disk: luminance decomposed in separate colors over time. (stop to see).\nNB: requires well calibrated monitor ;-)", "tags": ["color", "illusion", "perception"], "likes": 3, "viewed": 284, "published": 3, "date": "1600581689", "time_retrieved": "2024-07-30T20:44:18.861010", "image_code": "#define luma(O)  dot(O, vec4(.213, .715, .072, 0) )       // luminance\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         M = iMouse.z==0. ? R/2. : iMouse.xy;\n    \n    O = texture(iChannel0, u / R );\n    O = pow(O, vec4(2.2));                                // from sRGB to flat\n    \n    if ( length(u-M) < R.y/3. )                           // around mouse, \n          O[iFrame%3] = O[(iFrame+1)%3] = 0.;             //  decompose colors over time\n    else {\n        O /= 3.;\n        if ( u.y < R.y/4. ) \n            O = iFrame%3 < 1 ? O*3. : vec4(0);            // bottom: paint every 3 frames\n      }   \n    \n \n   if ( length(u-R*vec2(.9,.6) ) < R.y/3. )               // right disk\n        O[iFrame%3] = luma(O) * 3.,\n        O[(iFrame+1)%3] = O[(iFrame+2)%3] = 0.;\n    else if ( u.x > R.x/2. ) \n          O = vec4( luma(O) );                            // right: luminance\n    \n    O = pow(O, vec4(1./2.2));                             // to sRGB\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 981]]}
{"id": "ttBBWz", "name": "Refraction, Fresnel, Absorption", "author": "MyGoodSir", "description": "used this to learn: https://www.shadertoy.com/view/4tyXDR", "tags": ["raytracing", "transparency", "refraction", "fresnel"], "likes": 18, "viewed": 1946, "published": 3, "date": "1600570227", "time_retrieved": "2024-07-30T20:44:19.878290", "image_code": "/*********************************\\\n| Shader Written by Joseph Adrian |\n| \t\t  Aug. 27, 2020\t\t\t  |\n|\t\t\t\t\t\t\t\t  |\n|\t\t\t\t\t\t\t\t  |\n\\*********************************/\n\n#define AA 1\n#define MAX_BOUNCES 8\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| \t\t\tSTRUCTURES\t\t\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\nstruct LightData{\n    vec3 dir, col, amb;\n}light;\n\nstruct MaterialData{\n    vec3 diffuse;\n    float specularity;\n    float reflectivity;\n    vec3 absorbsion;\n    bool flec, frac, fres;\n    float ri_outer, ri_inner;\n    int objType;\n}obj;\n\nstruct Ray{\n    vec3 ori, dir;\n};\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| \t\tHELPER FUNCTIONS\t\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\n//hash function from https://www.shadertoy.com/view/4djSRW\n//(you can find it in the \"common\" tab)\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(121.01836, 119.30347, 130.04261));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//Exponential Smooth Minimum\n\nfloat exsmin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n//Polynomial Smooth Minimum\n\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Power Smooth Minimum\n\nfloat powsmin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nmat3 makeVP(vec3 pos, vec3 dir, float roll){\n    vec3 w = normalize(dir - pos);\n    vec3 u = normalize(cross(w, vec3(sin(roll), cos(roll), 0.)));\n    vec3 v = normalize(cross(u, w));\n    return mat3(u, v, w);\n}\n\n\t/*\t\t\t\t\t\t\t\t*\\\n   /|\t\t\t\t\t\t\t\t |\\\n  o)| DISTANCE AND NORMAL FUNCTIONS\t |(o\n   \\|\t\t\t\t\t\t\t\t |/\n    \\*\t\t\t\t\t\t\t\t*/\n\nvec4 danBox(Ray r, vec3 hs, out vec2 uv){//not mine\n\t// ray-box intersection\n    vec3 m = 1.0/r.dir;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*r.ori;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*hs; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = r.ori + r.dir * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / hs;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(r.dir);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );   \n}\n\nvec4 danSphere(Ray r, vec4 sphere) {\n  \tvec3 cto = r.ori - sphere.xyz;//ray from sphere center to ray origin\n    \n    //oid = \"orthogonal intersection distance\" (vague and stupid name, ik)\n    //distance from spheres center to the point at which the ray \n    //intersects the line that: \n    //passes through the ray, \n    //passes through the spheres center, \n    //and is orthogonal to cto\n  \tfloat oid = dot(cto, r.dir);\n    \n    float dts = dot(cto, cto) - sphere.w*sphere.w;//distance to surface\n    \n    if(dts > 0.0 && oid > 0.0) { return vec4(-1.0); }\n    \n    float dsc = oid * oid - dts;//descriminant\n    \n    if(dsc < 0.0){ return vec4(-1.0); }\n    \n    float sv = 1.0;//sign value. used to correct the direction of the normal if the ray is inside the sphere.\n    float t = -oid - sqrt(dsc);//the time (distance along the ray) of the ray hit\n    if(t < 0.0){\n        t = -oid + sqrt(dsc);\n        sv = -1.0;\n    }\n    vec3 norm = normalize((r.ori + r.dir*t) - sphere.xyz) * sv;\n    \n    return vec4(t, norm);\n    \n}\n\nvec4 danPlane(Ray r, vec4 plane, out vec2 uv){\n    float t = -(dot(r.ori, plane.xyz)+plane.w)/dot(r.dir,plane.xyz);//time\n    vec3 ua = normalize(cross(plane.xyz, vec3(0., 1., 0.)));//u axis\n    vec3 va = normalize(cross(plane.xyz, ua));//v axis\n    vec3 hpos = r.ori + r.dir * t;//hit position\n    uv.x = dot(hpos, ua);\n    uv.y = dot(hpos, va);\n    return vec4(t, plane.xyz);\n}\n\n//r = ray, rb = ray bounds, p = plane, nn = nearplane normal, fn = farplane normal\nvoid rayclamp(Ray r, inout vec2 rb, vec4 p, inout vec3 nn, inout vec3 fn){\n    vec2 uv;\n    vec4 ri = danPlane(r, p, uv);//ray info\n    if(dot(ri.yzw, r.dir) < 0.0){\n        if(ri.x > rb.x){\n            rb.x = ri.x;\n            nn = ri.yzw;\n        }\n    }\n    else{\n        if(ri.x < rb.y){\n            rb.y = ri.x;\n            fn = ri.yzw;\n        }\n    }\n    \n}\n\nvec4 danObject (Ray r)//not mine\n{\n    if(obj.objType == 0){\n    \treturn danSphere(r, vec4(0.0, 0.0, 0.0, 0.5));\n    }\n    else{\n    \tvec2 uv;\n    \tvec4 ret = danBox(r, vec3(0.5), uv);\n    \tif (dot(r.dir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    }\n}\n\nvec3 cbPattern(vec2 uv){\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.) < 1.0 ? 1.0 : 0.25);\n}\n\n\nvec3 lighting(Ray r, vec3 dif, vec3 norm, float sp, bool shd){\n    vec3 col = dif * light.amb;\n    \n    Ray scheck = r;\n    scheck.dir = -light.dir;\n    if(shd && norm.y >= 0.9/*magic?*/ && danObject(scheck).x >=0.0) { return col;}\n    \n    float dp = clamp(dot(norm, -light.dir), 0., 1.);\n    col += dif * dp * light.col;\n    \n    if(sp > 0.0){\n        vec3 rfn = reflect(-light.dir, norm);\n        dp = clamp(dot(r.dir, rfn), 0., 1.);\n        col += light.col * pow(dp, sp);\n    }\n    return col;\n}\n\nfloat fresnelValue(float n1, float n2, vec3 normal, vec3 incident){\n    if(obj.fres){\n        //schlick approx.\n        float r0 = (n1-n2)/(n1+n2);\n        r0*=r0;\n        float cx = -dot(normal, incident);\n        if(n1>n2){\n            float n = n1/n2;\n            float st2 = n*n*(1.0-cx*cx);\n            \n            if(st2>1.0) { return 1.0; }\n            cx = sqrt(1.0-st2);\n        }\n        float x = 1.0 - cx;\n        float o = r0+(1.0-r0)*x*x*x*x*x;\n        \n        o = (obj.reflectivity +(1.0-obj.reflectivity) * o);\n        return o;\n    }\n    else{\n        return obj.reflectivity;\n    }\n}\n\n\n\n\n//NOT MINE\n\n\n\nvec3 GetSceneRayColor (Ray r)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    Ray temp = r;\n    temp.ori += vec3(0.0, 1.51, 0.0);\n    vec4 rayInfo = danBox(temp, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0){\n        temp = r;\n        temp.ori += r.dir*rayInfo.x;\n        return lighting(temp, cbPattern(uv), rayInfo.yzw, 100.0, true);\n    }\n    // else return skybox color\n    else\n        return texture(iChannel0, r.dir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (Ray r)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = danObject(r);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        r.ori = r.ori + r.dir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-obj.absorbsion * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = fresnelValue(obj.ri_inner, obj.ri_outer, r.dir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(r.dir, rayInfo.yzw, obj.ri_inner / obj.ri_outer);\n        Ray temp = r;\n        temp.ori+=refractDir*0.001; temp.dir = refractDir;\n        ret += GetSceneRayColor(temp) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += lighting(r, obj.diffuse, refractDir, obj.specularity, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        r.dir = reflect(r.dir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        r.ori += r.dir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (Ray r)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    Ray temp = r;\n    temp.ori += vec3(0.0, 1.51, 0.0);\n    vec4 rayInfo = danBox(temp, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = cbPattern(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = danObject(r);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += lighting(r, obj.diffuse, rayInfo.yzw, obj.specularity, false);\n        \n        // move the ray to the intersection point\n        r.ori += r.dir * rayInfo.x;    \n         \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = fresnelValue(obj.ri_outer, obj.ri_inner, r.dir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        if(obj.flec){\n        \tvec3 reflectDir = reflect(r.dir, rayInfo.yzw);\n            Ray temp = r;\n        \ttemp.ori+=reflectDir*0.001; temp.dir = reflectDir;\n        \tret += GetSceneRayColor(temp) * reflectMultiplier;\n        }\n        \n        // get refraction color\n        if(obj.frac){\n        \tvec3 refractDir = refract(r.dir, rayInfo.yzw, obj.ri_outer / obj.ri_inner);\n            Ray temp = r;\n        \ttemp.ori+=refractDir*0.001; temp.dir = refractDir;\n        \tret += GetObjectInternalRayColor(temp) * refractMultiplier;\n        }\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, r.dir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \tr.ori += r.dir * bestRayHitInfo.x;    \n            return lighting(r, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n\nvoid setup_vals(){\n    obj.diffuse = vec3(0.0);\n    obj.specularity = 0.00;\n    obj.reflectivity = 0.0;\n    obj.absorbsion = vec3(1.40, 1.40, 0.02);\n    obj.frac = true;\n    obj.flec = true;\n    obj.fres = true;\n    obj.ri_outer = 1.0029;\n    obj.ri_inner = 1.125;\n    obj.objType = 0;\n    \n    light.dir = normalize(-vec3(1.0,2.0,1.0));\n    light.col = vec3(1.0);\n    light.amb = vec3(0.1);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    setup_vals();\n    \n    vec3 lookAt = vec3(0.0); //what the camera should be looking at\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;//normalize mouse coordinates\n\t\n    \n\t//camera position as a function of mouse location\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14159;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 3.14) - 1.0 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    //construct orthonormal basis for cameraspace\n    vec3 cameraFwd  = normalize(lookAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(lookAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    //setup fov and view depth(?)\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); //normalized viewport coordinates\n    vec2 percent = rawPercent - vec2(0.5,0.5);//center coordinates in midde of screen\n\t\n    //find ray direction (there are easier ways of setting all this up tbh)\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\tRay r;\n    r.ori = cameraPos;\n    r.dir = rayDir;\n    \n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    \n    #if AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);\n            r.dir = rayDir;\n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(r);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(r);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[761, 780, 802, 802, 943], [975, 975, 1018, 1018, 1089], [1120, 1120, 1164, 1164, 1257], [1283, 1283, 1327, 1327, 1405], [1407, 1407, 1451, 1451, 1617], [1726, 1726, 1767, 1802, 3943], [3945, 3945, 3981, 3981, 4972], [4974, 4974, 5020, 5020, 5353], [5355, 5438, 5512, 5512, 5802], [5804, 5804, 5838, 5838, 6078], [6080, 6080, 6104, 6104, 6190], [6193, 6193, 6255, 6255, 6693], [6695, 6695, 6762, 6762, 7298], [7317, 7317, 7348, 7600, 7976], [7978, 8041, 8081, 8197, 10070], [10072, 10135, 10168, 10168, 12445], [12448, 12448, 12466, 12466, 12841], [12847, 12847, 12904, 12904, 15657]]}
{"id": "wdtcR4", "name": "Parabolic Inversion", "author": "timeisbeautifulhere", "description": "The rift beckons...", "tags": ["spiral", "rift", "flip", "parabola", "violet"], "likes": 1, "viewed": 323, "published": 3, "date": "1600555944", "time_retrieved": "2024-07-30T20:44:20.742978", "image_code": "\n#define PI 3.14159\n\n//Constants for reference line\n//parabolas are defined from.\n//(ax + by = c)\n//This is just a straight line in\n//middle.\n#define LINE_A 1.0\n#define LINE_B 0.0\n#define LINE_C (0.0)\n\n#define PARABOLA_TIME_CONST 0.5\n#define PARABOLA_LINE_WIDTH 0.005\n#define NUM_PARABOLAS 20\n#define PARABOLA_TIME_DIFF 0.2\n\n#define RIFT_TIME_CONST 0.25\n#define RIFT_NUM_STRIPES 30.0\n#define RIFT_LINE_WIDTH 0.05\n\n//Return polar coordinate (radius, degrees)\nvec2 cart_to_pc(vec2 uv){\n    return vec2(\n        sqrt(uv.x*uv.x+uv.y*uv.y),\n        atan(uv.y,uv.x)\n    );\n}\n\nvec3 rift_color(vec2 uv){\n    \n    vec2 pc = cart_to_pc(uv);\n    \n    //[0,2pi]\n    float rads = pc[1] + PI;\n    \n    vec3 col = vec3(1.0,0.85,1.0);\n    \n    float spacing = (2.0*PI)/RIFT_NUM_STRIPES;\n    float dist = pc[0] + rads;\n    //dist = rads;\n    \n    if(mod(dist,spacing)<RIFT_LINE_WIDTH){\n    \tfloat offset = pc[0] + (rads/(2.0*PI));\n    \tfloat intensity = fract((iTime*RIFT_TIME_CONST)+offset);\n        intensity = mix(0.35, 1.0, intensity);\n    \n    \tcol = vec3(intensity, 0.0, intensity);\n    }\n    \n    return col;\n}\n\nfloat line_dist(vec2 uv, float a, float b, float c){\n    return abs(a*uv.x + b*uv.y + c)/sqrt(a*a+b*b);\n}\n\n//Parabolas defined by a line and a moving focus point.\n//https://en.wikipedia.org/wiki/Parabola#Definition_as_a_locus_of_points\nbool on_parabolas(vec2 uv){\n    for(int i=1;i<=NUM_PARABOLAS;i++){\n        float time = iTime + (float(i)*PARABOLA_TIME_DIFF);\n        \n    \tvec2 focus = vec2(\n        \tsin(time*PARABOLA_TIME_CONST),\n        \t0.0\n    \t);\n    \n    \tfloat dist_l = line_dist(uv, LINE_A, LINE_B, LINE_C);\n    \tfloat dist_f = distance(uv, focus);\n    \n    \tif(abs(dist_l-dist_f)<PARABOLA_LINE_WIDTH)\n        \treturn true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //[-1,1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    vec3 col = rift_color(uv);\n    \n    if(on_parabolas(uv)){\n        col = vec3(\n            0.5*abs(sin(iTime*PARABOLA_TIME_CONST*0.5)),\n            0.75*(1.0-col.g),\n            1.0-abs(sin(iTime*PARABOLA_TIME_CONST))\n        );\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 458, 483, 483, 568], [570, 570, 595, 595, 1100], [1102, 1102, 1154, 1154, 1207], [1771, 1771, 1828, 1841, 2203]]}
{"id": "ttXyDS", "name": "Simple Deferred", "author": "BeardThings", "description": "simple deferred rendering example", "tags": ["deferred"], "likes": 3, "viewed": 339, "published": 3, "date": "1600552958", "time_retrieved": "2024-07-30T20:44:21.558797", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 gbuffer=texture(iChannel0,fragCoord/iResolution.xy);\n    \n    bool renderBuffer=false;\n    if(renderBuffer)\n    {\n        fragColor=gbuffer;\n    }\n    else\n    {\n        mat3 v = viewMat(iTime);\n\n        vec2 ndc = fragCoord/iResolution.xy*2.-1.;\n        vec3 view=normalize(v[2]+v[0]*ndc.x*iResolution.x/iResolution.y+v[1]*ndc.y);\n        vec3 env = texture(iChannel2,view).rgb*2.;\n\n        vec3 normal=vec3(gbuffer.rg, -sqrt(1.0-gbuffer.r*gbuffer.r+gbuffer.g*gbuffer.g));\n        normal = normal*inverse(v);\n\n        vec3 lightDir=normalize(vec3(0.707,0.707,-0.707));\n        vec3 lightCol=texture(iChannel2,lightDir).rgb*70.;\n\n        vec3 radiance=lightCol*max(dot(normal,lightDir),0.0);\n\n        vec3 ambient=texture(iChannel3,normal).rgb*10.;\n\n        // lambert\n        vec3 albedo=vec3(gbuffer.b)/vec3(3.1415);\n\n        vec3 illum=albedo*(radiance+ambient);\n        illum=illum/(illum+vec3(1.));\n        illum=pow(illum,vec3(1.0/2.2));\n\n        vec3 o=mix(env,illum,float(length(gbuffer)!=0.));\n        fragColor = vec4(o,1.);\n    }\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = fragCoord/iResolution.xy*2.-1.;\n    float d=0.;\n    fragColor=vec4(0.);\n    for(int i = 0; i < 16; i++)\n    {\n        mat3 v = viewMat(iTime);\n        \n        vec3 f = v[2];\n        vec3 r = v[0];\n        vec3 u = v[1];\n        vec3 p = vec3(0.2*sin(iTime),0.,-0.2*cos(iTime))+normalize(f+r*ndc.x*iResolution.x/iResolution.y+u*ndc.y)*d;\n        float s=length(p)-0.1;\n        if(s<0.0001)\n        {\n            vec3 n = normalize(p);\n            vec2 uv=vec2(acos(n.y)/3.1415,atan(n.z,n.x)/(3.1415*2.));\n            \n            n=n*v; // Transform our normals to the view's basis to make our z always point to -1\n\n        \t// Normalized lambert\n        \tvec3 albedo=texture(iChannel0,uv*2.).rgb;\n            \n            fragColor=vec4(n.xy,albedo.r,1.);\n            break;\n        }\n        d+=s;\n    }\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 viewMat(float time)\n{\n    vec3 f = vec3(-sin(time),0.,cos(time));\n    vec3 r = vec3(cos(time),0.,sin(time));\n    vec3 u = vec3(0.,1.,0.);\n    \n    return mat3(r,u,f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1109]]}
{"id": "3sdczN", "name": "Tannins", "author": "wyatt", "description": "Its a good wine if it makes drippy things on the side apparently ", "tags": ["fluid"], "likes": 20, "viewed": 419, "published": 3, "date": "1600551583", "time_retrieved": "2024-07-30T20:44:22.365639", "image_code": "Main {\n    vec4\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.w-w.w,n.w-s.w,3)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 b = B(U);\n    Q = b*b.w;\n    vec4 t = texture(iChannel3,ref);\n    Q *= 0.8+30.*t*t*t*t;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}", "buffer_a_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u);\n        #define q 1.1\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*a.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    Q.xy = clamp(Q.xy,vec2(-1),vec2(1));\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,.1,0);\n    }\n    vec4 d = D(U);\n    if ((iFrame < 10||iMouse.z>0.)&&ln(U,d.xy,d.zw)<2.)\n        Q = vec4(clamp(1e-2*(d.xy-d.zw),.5,.5),.5,.5);\n    if (U.x<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x != 0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*a.w*(.6*a.w*a.z+a.w-(1.-.6*a.w))*u;\n        Q.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-2*Q.w;\n    Q.xy *= .5+.5*pow(Q.w,.1);\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n\tif (iFrame < 10) fragColor = vec4(.4,.5+.1*sin(float(iFrame)),.6,.5)*R.xyxy;;\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u), b = B(U+u);\n        #define q 1.1\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*b.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,0,0);\n    }\n    vec4 d = D(U);\n    if ((iFrame < 10||iMouse.z>0.)&&ln(U,d.xy,d.zw)<2.)\n        Q = vec4(1.+0.5*sin(iTime+iTime*vec3(1,2,3)),.5);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "wl2fDV", "name": "Rainbow cells", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 19, "viewed": 604, "published": 3, "date": "1600547780", "time_retrieved": "2024-07-30T20:44:23.307122", "image_code": "// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2020-09-12 18:44:02\n\n// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol.xyz= 3.0*r*(0.5*normalize(vec3(3.*c.xy,1.)) + 0.5);\n    \tcol.xyz= (0.5*normalize(vec3(3.*c.xy,1.)) + 0.5);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 3\n#define sense_ang 0.3\n#define sense_dis 10.\n#define sense_oscil 0.00\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.05\n#define distance_scale 1.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.1*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.06);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (20. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2fDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 575, 575, 753], [793, 793, 824, 824, 858], [860, 860, 912, 912, 1031], [1033, 1033, 1068, 1068, 1092], [1094, 1094, 1125, 1125, 1212], [1214, 1214, 1235, 1235, 1328], [1330, 1330, 1352, 1352, 1448], [1451, 1451, 1471, 1471, 1666], [1669, 1669, 1704, 1704, 1889], [1928, 1928, 1960, 1960, 2128], [2130, 2130, 2175, 2175, 4950]]}
{"id": "3sdcRN", "name": "color contamination 2", "author": "FabriceNeyret2", "description": "only the grid is colored, 80% of the image is B&W.\n( see zoomed pattern around the mouse ).", "tags": ["color", "illusion", "perception"], "likes": 9, "viewed": 303, "published": 3, "date": "1600543150", "time_retrieved": "2024-07-30T20:44:24.159842", "image_code": "// variant of https://shadertoy.com/view/WdtyR4\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = texture(iChannel0, u / iResolution.xy);\n    O = pow(O, vec4(2.2));                              // from sRGB to flat\n//  u /= 2.;                                            // if you want to zoom whole pattern\n    if (length(u-iMouse.xy) < 64. ) u/=8.;              // zoom pattern around mouse\n    ivec2 I = ivec2(u) % 10;\n    if ( min(I.x,I.y) > 0 )                             // grid pattern\n        O = vec4( dot(O, vec4(.213, .715, .072, 0) ) ); // luminance\n    \n    O = pow(O, vec4(1./2.2));                           // to sRGB\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 634]]}
{"id": "3dtcRN", "name": "Corail Diffusion", "author": "aiekick", "description": "dont know how to autmatically start the diffusion \nso play in mouse.\nwhen the screen become black insert other shape with mouse, and normally he can start\nsee common tab for other interesting patterns", "tags": ["diffusion", "corail"], "likes": 16, "viewed": 412, "published": 3, "date": "1600542728", "time_retrieved": "2024-07-30T20:44:25.035501", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord.xy;\n    vec2 s = iResolution.xy;\n    \n\tvec2 v = (g+g-s)/s.y;\n    float a = atan(v.x,v.y) + length(v) * 4. - iTime * 2.;\n    \n    float cc = texture(iChannel0, fract(g/s*zoom)).y;\n    float cc2 = texture(iChannel0, fract((g+vec2(cos(a),sin(a)))/s*zoom)).y;\n    fragColor = vec4(cc*cc) * baseColor;\n    fragColor += lightColor*max(cc2 - cc, 0.0)*5.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define zoom 0.75\n#define baseColor vec4(1,0.5,0.5,1)\n#define lightColor vec4(0.0,0.5,0.8,1)\n\n#define get(sam, g, s, x, y) texture(sam, fract((g + vec2(x,y))/s))\n\nvec2 calc(vec2 vCoord, vec2 vSize, int vFrame, vec4 vMouse, sampler2D vInit, sampler2D vBuffer)\n{\n    vec2 dst = vec2(0);\n\t\n    vec4 c = get(vBuffer, vCoord, vSize,  0.0,  0.0); // current\n    vec4 l = get(vBuffer, vCoord, vSize, -1.0,  0.0); // left\n    vec4 r = get(vBuffer, vCoord, vSize,  1.0,  0.0); // right\n    vec4 b = get(vBuffer, vCoord, vSize,  0.0, -1.0); // bottom\n    vec4 t = get(vBuffer, vCoord, vSize,  0.0,  1.0); // top\n    vec4 lp = l+r+b+t - 4.0 * c; // laplacian\n\n    // interesting patterns\n    vec2 feedkill = vec2(0.06180, 0.00250);\n    //vec2 feedkill = vec2(0.16330, 0.00250);\n    //vec2 feedkill = vec2(0.10900, 0.01250);\n\n    vec2 diff = vec2(0.22, 0.44); // nabla\n\n    vec2 dilp = diff * lp.xy;\n    float reac =  c.x *  c.y *  c.y;\n\n    c.x =  c.y * (dilp.x - feedkill.y) +  c.x * (1.0 + feedkill.x) - reac;\n    c.y =  c.x * (dilp.y - feedkill.x) +  c.y * (1.0 - feedkill.y) + reac;\t\n    dst = clamp(c.xy, 0.001, 1.0);\n\n    if (vMouse.z > 0.)\n        if (length(vCoord - mod(vMouse.xy * zoom, vSize)) < min(vSize.x, vSize.y) * 0.1)\n        \tdst = vec2(0,1);\n\n    if (vFrame < 60)\n    \tdst = texture(vInit, vCoord / vSize * 0.9).rr;\n    if (vFrame < 240)\n        if (length(vCoord - mod(vSize * 0.5 * zoom, vSize)) < min(vSize.x, vSize.y) * 0.1)\n        \tdst = vec2(0,1);\n    \n    return dst;\n}", "buffer_a_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rg = calc(fragCoord, iResolution.xy, iFrame, iMouse, iChannel1, iChannel0);\n    fragColor.ba = vec2(0,1);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rg = calc(fragCoord, iResolution.xy, iFrame, iMouse, iChannel1, iChannel0);\n    fragColor.ba = vec2(0,1);\n}", "buffer_b_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rg = calc(fragCoord, iResolution.xy, iFrame, iMouse, iChannel1, iChannel0);\n    fragColor.ba = vec2(0,1);\n}", "buffer_c_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rg = calc(fragCoord, iResolution.xy, iFrame, iMouse, iChannel1, iChannel0);\n    fragColor.ba = vec2(0,1);\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[138, 138, 195, 195, 569]]}
{"id": "WstcRN", "name": "Liquid Paint + Lighting", "author": "smkgames", "description": "Liquid Paint", "tags": ["paint", "liquid", "ripple", "multipass"], "likes": 9, "viewed": 766, "published": 3, "date": "1600541975", "time_retrieved": "2024-07-30T20:44:25.934098", "image_code": "float diffuse;\nfloat specular;\n\nvoid calculateLighting(vec2 uv)\n{\n    float l= length(texture(iChannel0,uv).xyz);\n    float dx=dFdx(l)*iResolution.x;\n    float dy=dFdy(l)*iResolution.y;\n    \n    // Calculating Normal by dx and dy\n    vec3 N =normalize(vec3(dx,dy,100.0));\n    \n    // Light Direction\n    vec3 L = normalize(vec3(1.0, 1.0, 2.0));\n    \n    // Calculating Diffuse\n    diffuse = max(dot(N, L)  + 1., 0.);\n    \n    // Calculating Specular\n    specular = clamp(dot(reflect(L, N),vec3(0, 0, -1)), 0., 1.0);\n    \n    specular = pow(specular, 12.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    calculateLighting(uv);\n    \n    // Get Liquid From Buffer B\n    vec3 liquid = texture(iChannel0, uv).rgb;\n    \n    // Normalizing Liquid\n    liquid = clamp(liquid,0.,0.5);\n    \n    // Cream Color\n    vec3 color = vec3(1.,0.99,0.81);\n    \n    vec3 finalColor = liquid * color * diffuse + specular;\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(distance(iMouse.xy, fragCoord) < 10.0);\n    fragColor += texture(iChannel0, fragCoord.xy / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float s = 0.;\n\nvec4 Move(vec2 U,vec2 dir) {\n    \n     // smoothing gives a circle\n     s += 1./ length(dir);\n    \n     // using texelFetch ( if speed always refer to an integer number of pixels ) would make your life a bit easier\n     vec4 result = texelFetch( iChannel1, ivec2(U+dir) , 0 );\n    \n     result /= length(dir);\n    \n     return result;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(0);\n    \n    O += Move( U, vec2( 1, 0) )\n      +  Move( U, vec2(-1, 0) ) \n      +  Move( U, vec2( 0, 1) )\n      +  Move( U, vec2( 0,-1) )\n      +  Move( U, vec2( 1, 1) )\n      +  Move( U, vec2( 1,-1) )\n      +  Move( U, vec2(-1, 1) )\n      +  Move( U, vec2(-1,-1) );\n    \n    O /= s;\n    \n    O += texelFetch(iChannel0, ivec2(U), 0); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 65, 65, 558], [560, 560, 617, 617, 1058]]}
{"id": "wd3yRN", "name": "Image Putty", "author": "Plento", "description": "smearing effect.", "tags": ["2d", "mouse", "texture", "smear"], "likes": 9, "viewed": 477, "published": 3, "date": "1600536134", "time_retrieved": "2024-07-30T20:44:26.708029", "image_code": "// Plento\nvoid mainImage( out vec4 f, in vec2 u ){\n    f = texture(iChannel0, u/R);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 f, in vec2 u ){\n    vec4 bA = B(u);\n    vec2 d = vec2(0);\n    \n    if(iMouse.z > 0.){\n        vec2 mdx = clamp((C(u).xy - m), -15., 15.);\n        d -= mdx * exp(-length(m - u)*.05)*5.;\n    }\n    \n    vec4 new = B(u - d);\n    bA = mix(bA, new, Smear_Factor);\n    \n    if(iFrame < 15){bA = og(u);}\n    \n    f = bA;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m iMouse.xy\n\n#define A(p) texelFetch(iChannel0,  ivec2(p), 0)\n#define B(p) texelFetch(iChannel1,  ivec2(p), 0)\n#define C(p) texelFetch(iChannel2,  ivec2(p), 0)\n\n// restart shader if you change this\n#define zoom 1.12\n\n#define og(u) A(zoom*(u-R*.5) + vec2(textureSize(iChannel0, 0))*.5)\n\n#define Smear_Factor .45", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(iMouse.xy, 0.,1.);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 50, 50, 85]]}
{"id": "WdtyR4", "name": "color contamination", "author": "FabriceNeyret2", "description": "only 1 every 5 points (at random ) is colored. 80% of the image is B&W.\n( see zoomed pattern around the mouse ).", "tags": ["color", "illusion", "perception"], "likes": 5, "viewed": 320, "published": 3, "date": "1600518350", "time_retrieved": "2024-07-30T20:44:27.660483", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = texture(iChannel0, u / iResolution.xy);\n    O = pow(O, vec4(2.2));                              // from sRGB to flat\n    \n    if (length(u-iMouse.xy) < 64. ) u/=8.;              // zoom pattern around mouse\n    if ( texture(iChannel1, u/1024. ).r < .8 )          // most pixel: luminance\n  //if ( texture(iChannel2, u/8.   ).r < .8 ) \n        O = vec4( dot(O, vec4(.213, .715, .072, 0) ) ); // luminance\n    \n    O = pow(O, vec4(1./2.2));                           // to sRGB\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 524]]}
{"id": "wdcyRN", "name": "random diffusion 4", "author": "FabriceNeyret2", "description": "uncomment variants", "tags": ["random", "diffusion"], "likes": 9, "viewed": 317, "published": 3, "date": "1600496529", "time_retrieved": "2024-07-30T20:44:28.543123", "image_code": "// variant of https://shadertoy.com/view/ws3yRN\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 U )\n{\t\n    O = hue( T(U)); \n // O = hue(  texture( iChannel0, U/iResolution.xy , 2. )) ; \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U) , 0 )", "buffer_a_code": "#define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash2(p)   fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T( U );\n    for (int i=0; i<9; i+= i==3 ? 2 : 1 ) {\n        vec2 D = vec2( i%3-1, i/3-1);\n        if ( hash(U+float(i)/11.+iTime) < .1 ) O =  max(O, T(U+D) );\n               //  +D\n    }\n    \n    if (iFrame%1==0) O += .1 * vec4( length(U-iResolution.xy*hash2(U+iTime)) < 2. );\n // if (iFrame%1==0) O += hash(U+iTime-.1) * vec4( length(U-iResolution.xy*hash2(U+iTime)) < 2. );\n\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 194, 194, 280]]}
{"id": "ws3yRN", "name": "random diffusion 3", "author": "FabriceNeyret2", "description": ".", "tags": ["random", "diffusion"], "likes": 8, "viewed": 325, "published": 3, "date": "1600496268", "time_retrieved": "2024-07-30T20:44:29.420776", "image_code": "// variant of https://shadertoy.com/view/td3yRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\tO = fract(T(U)); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U) , 0 )", "buffer_a_code": "#define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p)   fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T( U );\n    for (int i=0; i<9; i+= i==3 ? 2 : 1 ) {\n        vec2 D = vec2( i%3-1, i/3-1);\n        if ( hash(U+float(i)/11.+iTime) < .1 ) O =  max(O, T(U+D) );\n               //  +D\n    }\n    \n    if (iFrame%1==0) O += .1* vec4( length(U-iResolution.xy*hash2(U+iTime)) < 2. );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 106]]}
{"id": "ts3yRN", "name": "random diffusion 2", "author": "FabriceNeyret2", "description": "independent color fields variant", "tags": ["random", "diffusion"], "likes": 9, "viewed": 357, "published": 3, "date": "1600495878", "time_retrieved": "2024-07-30T20:44:30.255545", "image_code": "// variant of https://shadertoy.com/view/td3yRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\tO = fract(T(U)); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U) , 0 )", "buffer_a_code": "#define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\n                              //  +D : too regular\n#define diff(s)  if ( hash(U+float(i)/11.+iTime+.3*float(s)) < .1 ) \\\n                    O[s] =  max(O[s], T(U+D)[s] )\n                        \nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T( U );\n    for (int i=0; i<9; i+= i==3 ? 2 : 1 ) {\n        vec2 D = vec2( i%3-1, i/3-1);\n        diff(0); diff(1); diff(2);\n    }\n    \n    if (iFrame%1==0) O += .99* vec4( length(U-iResolution.xy/2.) < 2. );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 106]]}
{"id": "td3yRN", "name": "random diffusion", "author": "FabriceNeyret2", "description": ".", "tags": ["random", "diffusion"], "likes": 10, "viewed": 339, "published": 3, "date": "1600494243", "time_retrieved": "2024-07-30T20:44:31.238915", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\tO = fract(T(U)); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U) , 0 )", "buffer_a_code": "#define hash(p)      fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T( U );\n    for (int i=0; i<9; i+= i==3 ? 2 : 1 ) {\n        vec2 D = vec2( i%3-1, i/3-1);\n        if ( hash(U+float(i)/11.+iTime) < .1 ) O =  max(O, T(U+D) );\n               //  +D\n    }\n    \n    if (iFrame%1==0) O += .99* vec4( length(U-iResolution.xy/2.) < 2. );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 57]]}
{"id": "wsVGzt", "name": "Combustion 2", "author": "lomateron", "description": "like https://www.shadertoy.com/view/WtSSzm\nbut here the noise is the same in every frame\nset the browser zoom to 50% then go full screen", "tags": ["fluid", "smoke"], "likes": 9, "viewed": 418, "published": 3, "date": "1600491998", "time_retrieved": "2024-07-30T20:44:32.222286", "image_code": "void mainImage( out vec4 color, in vec2 coord )\n{\n\tvec4 a = texture(iChannel0,coord/iResolution.xy)*.08;\n    color = .5+.5*cos(6.28*(-.1-a.z+vec4(.0,.1,.2,.0)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 LOOKUP(vec2 u)\n{\n    vec2 f = fract(u)-.5;\n    vec2 e = sign(f);\n    vec2 d = 1./iResolution.xy;\n    vec4 p1 = texture(iChannel0,(u+vec2(0.,0.)*e)*d);\n    vec4 p2 = texture(iChannel0,(u+vec2(0.,1.)*e)*d);\n    vec4 p3 = texture(iChannel0,(u+vec2(1.,0.)*e)*d);\n    vec4 p4 = texture(iChannel0,(u+vec2(1.,1.)*e)*d);\n    \n    f = abs(f);\n    vec2 v = 1.-f*2.;\n    \n    return  p1*(1.-min((0.+f.x)+(0.+f.y),1.))+\n            p2*(1.-min((0.+f.x)+(1.-f.y),1.))+\n            p3*(1.-min((1.-f.x)+(0.+f.y),1.))+\n            (1.-max(v.x,v.y))*(p1+p2+p3+p4)/4.;\n}\nvec4 Field(vec2 position)\n{\n    vec2 velocityGuess = texture(iChannel0,position/iResolution.xy).xy;\n    vec2 positionGuess = position - velocityGuess;\n\treturn LOOKUP(positionGuess);\n}\nvoid mainImage( out vec4 Energy, in vec2 Me )\n{\n    vec4 C = Field(Me + vec2(0,0));//CENTER\n    vec4 R = Field(Me + vec2(1,0));//RIGHT\n    vec4 U = Field(Me + vec2(0,1));//UP\n    vec4 L = Field(Me - vec2(1,0));//LEFT\n    vec4 D = Field(Me - vec2(0,1));//DOWN\n    \n    C.xy += (-vec2(1,0)*(R.z-C.z)\n             -vec2(0,1)*(U.z-C.z)\n             +vec2(1,0)*(L.z-C.z)\n             +vec2(0,1)*(D.z-C.z))/-.99;\n\n    C.z = (C.z + R.z + U.z + L.z + D.z)/(5.+.05) +\n          (+dot(-vec2(1,0),R.xy-C.xy)\n           +dot(-vec2(0,1),U.xy-C.xy)\n           +dot(+vec2(1,0),L.xy-C.xy)\n           +dot(+vec2(0,1),D.xy-C.xy))/4.;\n\n    if (iMouse.z > 0. && length(Me-iMouse.xy) < 200.)\n    {\n        C = vec4(0.);\n    }\n    //if(iFrame==0){\n    \tvec4 rnd = vec4(9987.12345,\n                        8568.54321,\n                        7654.45678,\n                        6765.98765);\n        rnd = sin(dot(Me,vec2(8.12345,95.56835)))*rnd;\n    \tC += (fract(rnd)-.5)*100.*float(fract(rnd.w)<.017);\n    //}\n    \n    Energy = C;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 163]]}
{"id": "td3cR4", "name": "basic-face -v4", "author": "jorge2017a1", "description": "basic-face -v4", "tags": ["basicfacev4"], "likes": 2, "viewed": 239, "published": 3, "date": "1600480376", "time_retrieved": "2024-07-30T20:44:33.446014", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 ) \n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdSphere( vec3 p, float s )\n{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB) \n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB) \n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n    float c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------------------------------\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat funcF(float x)\n{\n    x *= 1.02;\n    float ans = (x - 0.6) * (x - 0.6) + 0.37;\n    ans = smin(ans, 0.5, 0.05);\n    return ans;\n}\n\n\nfloat sdEgg(in vec3 p, in float r, in float h)\n{\n    p= rotate_x(p, radians(180.0));\n    vec3 off = p - vec3(0., -3.0, 0.);\n    float ans = 0.;\n    float angle = 1. - acos(dot(normalize(off), vec3(0, 1, 0))) / 3.1415;\n    return length(off) - 12.0*funcF(angle);\n  \n}\n\nfloat CortePelo(vec3 p,in float r, in float h)\n{\n    float dEgg = sdEgg( p, 0.1, 0.1 );\n\tfloat sb1= sdBox(p-vec3(0.5,7.5,0.0), vec3(5.5,3.0,5.0)); //pelo sup  cabeza\n    float sb2= sdBox(p-vec3(0.5,4.0,3.0), vec3(5.5,5.0,5.0));  //pelo lateral\n    \n    float sUnionb1b2= unionSDF(sb1, sb2); \n    float inters= intersectSDF(dEgg,sUnionb1b2);\n     return inters;\n}   \n\nfloat HacerOjoyCornea(vec3 p,  float pDistCabeza)\n{   \n    float la=0.5;\n    float lb=0.8;\n    float h=2.0;\n    float ra=0.45;\n   \n    \n    float sdc1 = sdCylinderXY(  p -vec3(2.0,3.0,-2.0), vec2(1.,4.5) );\n\tfloat sdc2 = sdCylinderXY(  p-vec3(-2.0,3.0,-2.0), vec2(1.,4.5) );\n    \n    float sdb1 = sdBox(p- vec3(2.0,3.5, 0.0), vec3(1.0,1.0,4.5) );\n    float sdb2 = sdBox(p-vec3(-2.0,3.5, 0.0), vec3(1.0,1.0,4.5) );\n    float inter1 = intersectSDF(sdb1, sdc1);\n\tfloat inter2 = intersectSDF(sdb2, sdc2);\n    \n    float  sU= unionSDF(inter1, inter2); \n    float inters= intersectSDF(pDistCabeza,sU);\n\n    return inters;\n  \n}   \n\n\nfloat HacerCornea(vec3 p,  float pDistCabeza)\n{    \n    float t=0.45*cos(iTime);\n    float t2=abs(0.25*cos(iTime));\n    float sdcy1= sdCylinderXY(p-vec3(2.0+t,2.5,-2.5), vec2(0.25+t2,2.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-2.0+t,2.5,-2.5), vec2(0.25+t2,2.0) );\n    float  sU= unionSDF(sdcy1, sdcy2); \n    float inters= intersectSDF(pDistCabeza,sU);\n    return inters;\n}  \n\n\nfloat BigoteSonrisa(vec3 p, float pDistCabeza)\n{\n    float t=0.35*cos(iTime);\n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.6,-1.0), vec2(1.5,3.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,-1.0), vec2(1.1,3.5) );\n    float sdb1= sdBox(p-vec3(0.0,1.2,-1.0), vec3(4.2,3.0,3.6));   \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    float inters= intersectSDF(pDistCabeza,dif);\n    return inters;\n}\n\n\nfloat CejaSonrisa(vec3 p, float pDistCabeza)\n{\n    float sdb1= sdBox(p-vec3(0.0,1.2,-1.0), vec3(0.7,0.15,3.6));   \n    float inters= intersectSDF(pDistCabeza,sdb1);\n    return inters;\n}\n\n\n\nfloat NarizIII(vec3 p,float pDistCabeza )\n{\n   \tvec3 aA=vec3(0.0,2.0,0.5); // / inclinado mas \n    vec3 bA=vec3(0.0,0.0,0.2); // / inclinado menos\n    float r0A=0.3;  //diametro sup\n    float r1A=0.5;  //diametro inferior de cilindro\n  \n    vec3 aB=vec3(0.0,2.0,0.5);\n    vec3 bB=vec3(0.0,0.0,-0.2); \n    float r0B=0.3;\n    float r1B=0.2;\n \n    float sdca1= sdCapsule( p-vec3(0.0,0.5,-4.2), aA, bA, r0A, r1A );\n    float sdca2= sdCapsule( p-vec3(0.0,0.5,-4.2), aB, bB, r0B, r1B );\n    float sdsp1= sdSphere(p- vec3(0.5,0.45,-4.0), 0.35 );\n    float sdsp2= sdSphere(p-vec3(-0.5,0.45,-4.0), 0.35 );\n\t\n    float k=0.12;\n    float sdU= smin( sdca1, sdca2, k );  //unir 2 lobulos\n    sdU= smin( sdU, sdsp1, k );\n    sdU= smin( sdU, sdsp2, k );\n    \n    return sdU;\n    \n}\n\n\nfloat Labios(vec3 p,float pDistCabeza )\n{\n    //labio superior\n   \tvec3 aA1=vec3(1.0,1.0,0.1);\n    vec3 bA1=vec3(2.0,1.1,0.0); \n    float r0A1=0.1;\n    float r1A1=0.3;\n    \n    vec3 aB1=vec3(-1.0,1.0,0.1);\n    vec3 bB1=vec3(-2.0,1.1,0.0); \n    float r0B1=0.1;\n    float r1B1=0.3;\n    \n    //labio inferior\n   \tvec3 aA2=vec3(1.0,1.1,0.1);\n    vec3 bA2=vec3(2.0,1.0,0.0); \n    float r0A2=0.1;\n    float r1A2=0.3;\n    \n    vec3 aB2=vec3(-1.0,1.1,0.1);\n    vec3 bB2=vec3(-2.0,1.0,0.0); \n    float r0B2=0.1;\n    float r1B2=0.3;\n    \n    ///superior labio\n    float sdca1A= sdCapsule( p-vec3(-2.2,0.0,0.0), aA1, bA1, r0A1, r1A1 );\n    float sdca2A= sdCapsule( p-vec3(2.2,0.0,0.0), aB1, bB1, r0B1, r1B1 );\n   ///inferior labio\n\tfloat sdca1B= sdCapsule( p-vec3(-2.2,-0.2,0.0), aA2, bA2, r0A2, r1A2 );\n    float sdca2B= sdCapsule( p- vec3(2.2,-0.2,0.0), aB2, bB2, r0B2, r1B2 );\n    \n    float k=0.12;\n    float sdU1= smin( sdca1A, sdca2A, k );  //unir labios\n    float sdU2= smin( sdca1B, sdca2B, k );\n    \n\tfloat sUTdo= unionSDF(sdU1, sdU2);\n    return sUTdo;\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.y=p.y-5.0;\n    \n\n    \n    float dCabeza = sdEgg( p, 0.1, 0.1 );\n\t\n    float sOjo= HacerOjoyCornea(p,  dCabeza);\n    float sCornea=HacerCornea(p-vec3(0.0,0.7,0.0), dCabeza);\n    \n\tfloat spelo1= CortePelo(p,0.1, 0.1);\n    float sbigote= BigoteSonrisa(p-vec3(0.7,3.0,0.0), dCabeza);\n    float snariz=NarizIII( p-vec3(0.0,0.5,-0.3),dCabeza);\n    float slabios= Labios( p-vec3(0.0,-1.5,-3.3), dCabeza );\n    \n    float sceja1= CejaSonrisa( p-vec3(-2.0,3.0,0.0), dCabeza);\n    float sceja2= CejaSonrisa( p- vec3(2.0,3.0,0.0), dCabeza);\n    \n    res =opU3(res, vec3(dCabeza,16,-1)); \n    res =opU3(res, vec3(sOjo,1,-1)); \n    res =opU3(res, vec3(sCornea,0,-1)); \n    res =opU3(res, vec3(sbigote,0,-1)); \n    \n    res =opU3(res, vec3(sceja1,0,-1)); \n    res =opU3(res, vec3(sceja2,0,-1)); \n    \n    res =opU3(res, vec3(slabios,2,-1)); \n    res =opU3(res, vec3(snariz,16,-1));     \n    res =opU3(res, vec3(spelo1,29,-1)); \n    \n   \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color){\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//----------------------------------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i){\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    \n   \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n   \t\n}\n///-------------------------------------\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n   \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .2*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 4.5; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n       \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3cR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 262, 262, 281], [282, 282, 307, 307, 326], [327, 327, 363, 363, 391], [394, 394, 429, 429, 450], [451, 451, 483, 483, 567], [568, 568, 614, 614, 701], [702, 702, 736, 736, 798], [799, 799, 836, 836, 931], [932, 932, 971, 971, 1066], [1067, 1067, 1106, 1106, 1201], [1202, 1202, 1241, 1241, 1336], [1339, 1339, 1403, 1403, 1654], [1657, 1701, 1748, 1748, 1775], [1777, 1777, 1821, 1821, 1848], [1850, 1850, 1899, 1899, 1927], [1975, 2000, 2033, 2033, 2128], [2130, 2130, 2163, 2163, 2256], [2258, 2258, 2291, 2291, 2384], [2387, 2387, 2428, 2428, 2521], [2523, 2568, 2645, 2645, 2780], [2782, 2782, 2804, 2804, 2915], [2918, 2918, 2966, 2966, 3184], [3186, 3186, 3234, 3234, 3548], [3553, 3553, 3604, 3604, 4173], [4179, 4179, 4226, 4226, 4554], [4559, 4559, 4607, 4607, 5006], [5009, 5009, 5055, 5055, 5194], [5198, 5198, 5241, 5241, 5964], [5967, 5967, 6008, 6029, 7020], [7024, 7064, 7089, 7089, 8234], [8236, 8281, 8347, 8347, 8720], [8721, 8772, 8795, 8795, 8983], [8985, 9048, 9081, 9081, 9523], [9525, 9579, 9616, 9616, 9850], [9852, 9978, 10014, 10014, 10219], [10222, 10293, 10317, 10317, 10572], [10574, 10654, 10702, 10702, 10933], [10934, 10968, 11048, 11048, 11675], [11769, 11769, 11862, 11862, 12124], [12127, 12176, 12233, 12233, 14207]]}
{"id": "wl2BDt", "name": "jh0ker_boxblur", "author": "jh0ker", "description": "simple box blur", "tags": ["blur"], "likes": 2, "viewed": 472, "published": 3, "date": "1600449340", "time_retrieved": "2024-07-30T20:44:34.300729", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.);\n    \n    int box = 10;\n    \n    for (int i = -box; i <= box; i++) {\n    \tfor (int k = -box; k <= box; k++) {\n            \n       \t\tcol += texture(\n                iChannel0,\n                uv + vec2(i, k) / iChannelResolution[0].xy\n            );\n\t\t}\n\t}\n    \n    col /= float(box * 2 * box * 2);\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 536]]}
{"id": "Wddyzr", "name": "PewDiePie Brofist", "author": "manu210404", "description": "I tried making the Brofist but only got the outline. \nI want to try to make the fingers too but im not sure how to get the sdf of them. ", "tags": ["pewdiepie", "pewdiepiepattern", "brofist"], "likes": 5, "viewed": 257, "published": 3, "date": "1600440604", "time_retrieved": "2024-07-30T20:44:35.087624", "image_code": "#define PUNCH\n\nconst vec3 Black = vec3(.1, .0, .15);\nconst vec3 Red   = vec3(1., .2, .2);\nconst vec3 BG    = vec3(.3, .1, .2);\n\nfloat smoother(float t) {\n    t = clamp(t, 0.0,1.0);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat perlin(vec2 co) {    float i0 = floor(co.x);\n    float j0 = floor(co.y);\n    float i1 = ceil(co.x);\n    float j1 = ceil(co.y);\n\n    vec2 g00 = normalize(hash22(vec2(i0, j0)) * 2.0 - 1.0);\n    vec2 g10 = normalize(hash22(vec2(i1, j0)) * 2.0 - 1.0);\n    vec2 g01 = normalize(hash22(vec2(i0, j1)) * 2.0 - 1.0);\n    vec2 g11 = normalize(hash22(vec2(i1, j1)) * 2.0 - 1.0);\n    \n    vec2 uv = fract(co);\n    \n    float n00 = dot(g00, vec2(uv.x, uv.y));\n    float n10 = dot(g10, vec2(uv.x - 1.0, uv.y));\n    float n01 = dot(g01, vec2(uv.x, uv.y - 1.0));\n    float n11 = dot(g11, vec2(uv.x - 1.0, uv.y - 1.0));\n    \n    float su = smoother(uv.x);\n    float sv = smoother(uv.y);\n\n    float nx0 = (1.0 - su) * n00 + n10 * su;\n    float nx1 = (1.0 - su) * n01 + n11 * su;\n    \n    float n = (1.0 - sv) * nx0 + nx1 * sv;\n\n    return n;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox(vec2 p, vec2 r) {\n    vec2 q = abs(p)-r;\n    return length(max(q,0.0))+min(max(q.x, q.y),0.);\n}\n\n\nfloat dist(vec2 p) {\n    //return mix(sdBox(p, vec2(1)), length(p)-1.0, smoothstep(0.0,.5, p.x));\n    float thickness = .15;\n    p=rot(0.1)*p;\n    float r = 0.25;\n    \n    // Ellipse from Inigo Quilez: https://www.shadertoy.com/view/MdfGWn\n    vec2 hw = vec2(1.5,1.0);\n    float re = r+.5;\n    vec2 ce = p-vec2(.5, 0.3333);\n    float f = length( ce*hw );\n    float g = length( ce*hw*hw );\n    float e = (f-.6667)*f/g;\n    \n    float b0 = (mix(sdBox(p-vec2(1.0,0.333), vec2(2., 0.6667)), e, (sign(p.x-0.5)+1.0)/2.0))-r;\n\n    float b1 = sdBox(p-vec2(-0.5,0), vec2(0.5, 0.9))-r;\n    float s = length(p-vec2(-0.2,0.0))-1.0;\n    float v = mix(min(b0, b1), s, 0.25);\n    v = abs(v)- thickness;\n    e = length(p*vec2(1.5,1.0)-vec2(.75,0.333))-.6667;\n\n    return v;\n}\n\nfloat osc(vec2 p) {\n    return smoothstep(.0,.5,abs(fract(p.x/4.)*4.-2.)-.25);\n}\n\nfloat pewdieNoise(vec2 p, float t) {\n    vec2 w = sqrt(vec2(perlin(p/2.), perlin(p/2.+100.0))+1.0);\n    vec2 s = vec2(p+w)*12.;\n    s *= rot((w.x+w.y)*3.14159265/4.0);\n    return osc(s*1.0+iTime);\n    return sin(s.x+s.y);\n}\n\nfloat punch(float x) {\n    #ifdef PUNCH\n    float t = fract(x/2.);\n    return 2.0-(clamp(smoothstep(.3, .6, t)*6.,0.,1.)-smoothstep(.4, .6, t));\n    #endif\n    #ifndef PUNCH\n    return 1.9;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.;\n    \n    // for animation\n    float p = punch(iTime);\n    uv *= 1.0+p;\n    \n    float d = dist(uv.rg);\n    \n    // render fist\n    float v = smoothstep(0.02, 0.0, d);\n    vec3 col = mix(Black * v, Red, vec3(v) * pewdieNoise(uv, iTime));\n    col += (1. - v) * mix(Black, BG, (1.0 - smoothstep(.02 + .5 * (2. - p), -.25 * (2. - p), dist(uv + vec2(-1., 1.) * (2. - p)))));\n\n    // vignette\n    vec2 nuv = fragCoord/iResolution.xy-0.5;\n    col = mix(Black, col, 1.-length(nuv));\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wddyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 153, 153, 479], [481, 481, 503, 503, 596], [598, 598, 621, 621, 1429], [1431, 1431, 1450, 1450, 1523], [1525, 1525, 1554, 1554, 1632], [1635, 1635, 1655, 1732, 2394], [2396, 2396, 2415, 2415, 2476], [2478, 2478, 2514, 2514, 2701], [2703, 2703, 2725, 2725, 2905], [2907, 2907, 2964, 2964, 3546]]}
{"id": "wsdyzH", "name": "Liquid Paint", "author": "smkgames", "description": "Filling Paint", "tags": ["paint", "liquid", "ripple", "multipass"], "likes": 5, "viewed": 922, "published": 3, "date": "1600436601", "time_retrieved": "2024-07-30T20:44:36.014147", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(distance(iMouse.xy, fragCoord) < 10.0);\n    fragColor += texture(iChannel0, fragCoord.xy / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float s = 0.;\n\nvec4 Move(vec2 U,vec2 dir) {\n    \n     // smoothing gives a circle\n     s += 1./ length(dir);\n    \n     // using texelFetch ( if speed always refer to an integer number of pixels ) would make your life a bit easier\n     vec4 result = texelFetch( iChannel1, ivec2(U+dir) , 0 );\n    \n     result /= length(dir);\n    \n     return result;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(0);\n    \n    O += Move( U, vec2( 1, 0) )\n      +  Move( U, vec2(-1, 0) ) \n      +  Move( U, vec2( 0, 1) )\n      +  Move( U, vec2( 0,-1) )\n      +  Move( U, vec2( 1, 1) )\n      +  Move( U, vec2( 1,-1) )\n      +  Move( U, vec2(-1, 1) )\n      +  Move( U, vec2(-1,-1) );\n    \n    O /= s;\n    \n    O += texelFetch(iChannel0, ivec2(U), 0); \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]]}
{"id": "wddyzH", "name": "PlazmaGlob", "author": "celifrog", "description": ":D ", "tags": ["plasma", "fun"], "likes": 6, "viewed": 423, "published": 3, "date": "1600436326", "time_retrieved": "2024-07-30T20:44:36.828969", "image_code": "float noise(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 21., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(900.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.11, glow = 1115.3, eps = 0.0052141;\n\tvec3  p = org;\n\tbool glowed = true;\n\t\n\tfor(int i=-5; i<145; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .9875310)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/54.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 1.5);\n\tvec3 dir = normalize(vec3(v.x*1.6, v.y, -0.9));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(0.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.01812+.45);\n\t\n\tfragColor = mix(vec4(-0.2), col, pow(glow*1.5,0.9));\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 258], [260, 260, 292, 292, 329], [331, 331, 352, 352, 484], [486, 486, 507, 507, 555], [557, 557, 592, 592, 886], [888, 888, 945, 945, 1303]]}
{"id": "tddyRH", "name": "Mach Band Test", "author": "dr2", "description": "Apparent intensity bands caused by abrupt surface curvature changes", "tags": ["vision", "artifact"], "likes": 4, "viewed": 329, "published": 3, "date": "1600423394", "time_retrieved": "2024-07-30T20:44:37.642793", "image_code": "// \"Mach Band Test\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Curvature discontinuity causes perceived luminance discontinuity even though surface is\n  smooth with a continuously varying normal.\n\n  From left: raytraced quadratic (exact normal) and raymarched quadratic (i.e. capsules -\n  expect same result), raymarched higher order functions with continuous curvature (no bands).\n*/\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.1415927;\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - (b + sqrt (w)) / a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vn = normalize (vec3 (s.xy, 0.));\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = normalize (ro + d * rd);\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= clamp (p.z, - h, h);\n  return length (p) - r;\n}\n\nfloat PrCaps3Df (vec3 p, float r, float h)\n{\n  vec2 s;\n  p.z -= clamp (p.z, - h, h);\n  s = vec2 (length (p.xy), abs (p.z));\n  return pow (dot (s * s, s), 1./3.) - r;\n}\n\nfloat PrCaps4Df (vec3 p, float r, float h)\n{\n  p.z -= clamp (p.z, - h, h);\n  return sqrt (length (vec2 (dot (p.xy, p.xy), p.z * p.z))) - r;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  q = p;\n  q.x -= -1.25;\n  dMin = min (dMin, PrCapsDf (q.xzy, 1., 1.));\n  q = p;\n  q.x -= 1.25;\n  dMin = min (dMin, PrCaps3Df (q.xzy, 1., 1.));\n  q = p;\n  q.x -= 3.75;\n  dMin = min (dMin, PrCaps4Df (q.xzy, 1., 1.));\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 col, vn;\n  float dstObj;\n  dc4 = CapsHit ((ro - vec3 (-3.75, 0., 0.)).xzy, rd.xzy, 1., 1.);\n  dstObj = ObjRay (ro, rd);\n  if (min (dc4.x, dstObj) < dstFar) {\n    if (dc4.x < dstObj) vn = (dc4.yzw).xzy;\n    else vn = ObjNf (ro + dstObj * rd);\n    col = vec3 (0.2, 0.8, 0.8) * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.));\n  } else {\n    col = vec3 (0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.15 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 4.5;\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[578, 578, 633, 633, 1265], [1267, 1267, 1310, 1310, 1367], [1369, 1369, 1413, 1413, 1536], [1538, 1538, 1582, 1582, 1679], [1681, 1681, 1703, 1703, 1977], [1979, 1979, 2012, 2012, 2189], [2191, 2191, 2212, 2212, 2462], [2464, 2464, 2499, 2499, 2946], [2990, 2990, 3046, 3046, 4094], [4096, 4096, 4132, 4132, 4338], [4340, 4340, 4370, 4370, 4483]]}
{"id": "wdtyR8", "name": "Rainbow Gears", "author": "oneshade", "description": "I was playing around with implicit functions and came across this. I added the rainbow effect from the default shader and centered the coordinate system to make it look better. It doesn't look so good in full screen though.", "tags": ["gears", "rainbow"], "likes": 6, "viewed": 225, "published": 3, "date": "1600409502", "time_retrieved": "2024-07-30T20:44:38.471577", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragCoord -= 0.5 * iResolution.xy;\n    float value = fragCoord.x * fragCoord.y * 0.8 + 5.0 * iTime;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color * cos(value - sin(value)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 335]]}
{"id": "WddcRH", "name": "varios-tunels", "author": "jorge2017a1", "description": "varios-tunels", "tags": ["variostunels"], "likes": 4, "viewed": 303, "published": 3, "date": "1600392906", "time_retrieved": "2024-07-30T20:44:39.321305", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h ) \n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h ) \n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n///------------------------------------\n\nfloat CilindroConAlas(vec3 p, float numItem)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    pp=p;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    \n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdsp1= sdCylinderXY(p, vec2(2.0,6.0) );\n    float sdb1= sdBox(rep2, vec3(6.5,0.2,5.5));\n    \n    float h=2.0;\n    float r1=2.0;\n    float r2=0.25;\n    \n    pp= rotate_x(pp, radians(90.0));\n    float sdcc1= sdCappedCone(pp-vec3(0.0,7.0,0.0), h, r1, r2 );\n        \n    \n    float res = opSU(sdsp1, sdb1,0.1);\n     res = opSU(res, sdcc1,0.1);\n  \treturn  res;\n}\n\n\n\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p.y=p.y-5.0;\n    \n    p=p-0.4*vec3(sin(iTime)*sin(iTime),sin(iTime)*cos(iTime),0.5);\n    \n    pp=p;\n\tvec3 q=p;\n    float cx=47.0;\n    float cy=11.0;\n    float cz=30.00;\n    \n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    float sdc1= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(20.0,15.0));\n    float sdc2= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(18.0,17.0));\n\tfloat dif= differenceSDF(sdc1, sdc2);\n    float cl=mod(floor( iTime), 5.0);\n    res =opU3(res, vec3(dif,-1.0, cl)); \n\t\n    \n    float sf1= CilindroConAlas( pp-vec3(-5.0,-4.0,itime), 6.0);\n    res =opU3(res, vec3(sf1,30.0,MATERIAL_NO)); \n    \n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\nvec3 colorplaneta( vec2 puv )\n{\n    vec2 uv;\n    uv=puv;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\treturn col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n\n    \n    if (id_material==0.0)\n    {\n        vec3 col;\n        vec3 rp=pp;\n     \trp.x += iTime * -2.0;\n        // rp=mObj.p;\n    \tvec2 m = mod(rp.xz, 4.0) - 2.0;\n    \t\n        if (m.x * m.y > 0.0) \n            col= vec3(0.0);\n   \t\telse\n    \t\tcol= vec3(1.0) ;\n        \n    \treturn col;\n \t}   \n    \n    if (id_material==1.0)\n    {\n        //#define PI 3.14159\n\t\t#define TWO_PI (PI*2.0)\n        #define N 6.0\n    \t\n        vec2 v = pp.xz*0.5;\n\t\tv.x=v.x-10.0;\n\t\tv.y=v.y-200.0;\n\t\tfloat col = 0.0;\n\n\t\tfor(float i = 0.0; i < N; i++) \n\t\t{\n\t  \t\tfloat a = i * (TWO_PI/N) * 61.95;\n\t\t\tcol += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) /*+ mouse.y +i*mouse.x*/ + sin(iTime*0.001)*10.0 ));\n\t\t}\n\t\n\t\tcol /= 3.0;\n\n\t\tvec3 color = vec3(col*1.0, -col*1.0,-col*4.0);\n    \treturn color;\n    }\n    \n    if (id_material==2.0)\n    {\n    \t\n\t\tconst float pi= 3.14159265359;\n\t\tconst float spinspeed=0.2;\n\t\tconst float movespeed=-1.;\n\t\tconst float spirals=1.5;\n\t\tconst float twist = 3.3;\n        \n       \n        vec2 uv = mObj.uv;\n        \n\t\tfloat l = length(uv);\n\t\tfloat pos = atan(uv.x, uv.y) + fract(spinspeed/iTime) * pi;\n        float distortion = iTime*movespeed + twist / sqrt(l);\n        vec2 s = 2.0*abs(fract(vec2(pos + distortion, 2.0*(pos - distortion + spirals))/pi*twist) - vec2(0.5));\n\t\tfloat d = dot(s,s);\n\t\tfloat f = smoothstep(0.0, 0.1, 1.0-d);\n\t\tvec3 color = vec3(f*l);\n\t\treturn color;\n\t\t\n      }\n   \n    \n     if (id_material==3.0)\n    { return colorplaneta(mObj.p.xz*0.064);  }\n    \n    \n    \n     if (id_material==4.0)\n    {\n        vec3 color;\n        vec2 pos1=mObj.uv;\n        pos1=pos1-0.4*vec2(sin(iTime)*sin(iTime),sin(iTime)*cos(iTime));\n\t\tfloat l1=length(pos1);\n\t\tfloat l2=step(0.1,fract(1.0/l1+iTime/1.0));\n\t\tfloat a=step(0.1,fract(atan(pos1.x,pos1.y)*5.0));\n        color=vec3(0.0,0.0,0.0);\n\t\tif(a!=l2)\n    \t\tcolor=vec3(l1,l1,l1);\n\t\t\n        return color;\n    } \n    \n    \n    \n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n   \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(0.0, 10.0, 20.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -2.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    vec3 ro=vec3(4.0,0.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \n\nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 271, 271, 292], [293, 293, 325, 325, 409], [410, 410, 456, 456, 543], [544, 544, 578, 578, 640], [641, 641, 678, 678, 773], [774, 774, 815, 815, 910], [911, 911, 951, 951, 1046], [1047, 1047, 1087, 1087, 1182], [1184, 1184, 1209, 1209, 1228], [1229, 1229, 1254, 1254, 1273], [1274, 1274, 1310, 1310, 1338], [1341, 1341, 1367, 1367, 1421], [1423, 1423, 1457, 1457, 1630], [1632, 1660, 1701, 1701, 1794], [1796, 1796, 1855, 1855, 2168], [2170, 2214, 2261, 2261, 2288], [2290, 2290, 2333, 2333, 2360], [2362, 2362, 2410, 2410, 2438], [2439, 2523, 2562, 2562, 2606], [2607, 2607, 2646, 2646, 2690], [2691, 2756, 2790, 2790, 2888], [2889, 2889, 2923, 2923, 3015], [3016, 3016, 3050, 3050, 3142], [3184, 3184, 3205, 3205, 3274], [3316, 3316, 3362, 3362, 3909], [3913, 3913, 3938, 3938, 4623], [4625, 4670, 4737, 4737, 5105], [5106, 5157, 5181, 5181, 5369], [5370, 5433, 5466, 5466, 5908], [5910, 5964, 6000, 6000, 6234], [6235, 6324, 6404, 6404, 7016], [7059, 7059, 7090, 7090, 7408], [7411, 7462, 7509, 7509, 9441], [9495, 9495, 9588, 9588, 9864], [9867, 9916, 9973, 9973, 11129]]}
{"id": "3sdcRH", "name": "Text Renderer", "author": "oneshade", "description": "A simple text renderer using the character map texture. Characters are represented by codes between 0x00 and 0xFF (0 and 255). Characters in the map start in the bottom left corner and end in the top right corner.", "tags": ["text", "rendering"], "likes": 3, "viewed": 881, "published": 3, "date": "1600392660", "time_retrieved": "2024-07-30T20:44:40.315646", "image_code": "int[] stringChars = int[14](0xB8, 0x95, 0x9C, 0x9C, 0x9F, 0xDC, 0x50, 0xA7, 0x9F, 0x82, 0x9C, 0x94, 0xD1, 0x50);\nvec4[6] stringBounds;\n\nvec2 mapBounds(in vec2 uv, in vec4 drawBounds, in vec4 charBounds) {\n    vec2 mappedToDrawBounds = (uv - drawBounds.xy) / (drawBounds.zw - drawBounds.xy);\n    return charBounds.xy + (mappedToDrawBounds * (charBounds.zw - charBounds.xy));\n}\n\nbool inBounds(in vec2 uv, in vec4 bounds) {\n    return (uv.x >= bounds.x && uv.x <= bounds.z) && (uv.y >= bounds.y && uv.y <= bounds.w);\n}\n\nvec4 calcCharBounds(in int char) {\n    float x = mod(float(char), 16.0);\n    float y = (float(char) - x) / 16.0;\n    vec2 uv = vec2(x, y) / 16.0;\n    return vec4(uv, uv + 0.0625);\n}\n\nvoid calcStringBounds(in vec2 position, in vec2 charSize, in int stringLength) {\n    vec2 topLeft = position - 0.5 * vec2(charSize.x * float(stringLength), charSize.y);\n    for (int i=0; i < stringLength; i++) {\n        stringBounds[i] = vec4(topLeft, topLeft + charSize);\n        topLeft.x += charSize.x;\n    }\n}\n\nvec3 renderText(in vec2 uv, in int stringStart, in int stringLength) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i=0; i < stringLength; i++) {\n        if (inBounds(uv, stringBounds[i])) {\n            int charIndex = int(mod(float(stringStart + i), float(stringChars.length())));\n            vec4 bounds = calcCharBounds(stringChars[charIndex]);\n            vec2 mapped = mapBounds(uv, stringBounds[i], bounds);\n            color += texture(iChannel0, mapped).r;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    calcStringBounds(vec2(0.5, 0.5), vec2(0.1666, 0.3333), 6);\n    fragColor = vec4(renderText(uv, int(iTime), 6), 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 204, 204, 375], [377, 377, 420, 420, 515], [700, 700, 780, 780, 1013], [1015, 1015, 1085, 1085, 1521], [1523, 1523, 1578, 1578, 1743]]}
{"id": "WstcRH", "name": "Refraction-Like Effect", "author": "oneshade", "description": "I tried making a warping shader but it ended up creating a refraction-like effect. You can really see the effect if you try assigning different textures to channel 0.", "tags": ["postprocessing", "refraction", "warping"], "likes": 13, "viewed": 470, "published": 3, "date": "1600391520", "time_retrieved": "2024-07-30T20:44:41.183326", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 displacementSampleUV = vec2(fragCoord.x + iTime * 75.0, fragCoord.y) / iChannelResolution[0].xy;\n    float displacement = texture(iChannel0, displacementSampleUV).x;\n    vec2 displacementDirection = vec2(cos(displacement * 6.28318530718), sin(displacement * 6.28318530718));\n    vec2 displacedUV = (fragCoord + displacementDirection * displacement * 20.0) / iResolution.xy;\n    float shade = texture(iChannel1, displacedUV).x;\n    fragColor = vec4(shade, shade, shade, 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 541]]}
{"id": "3stcRH", "name": "Image Blur Effect", "author": "oneshade", "description": "Image blur effect.", "tags": ["postprocessing", "blur", "effect", "image"], "likes": 3, "viewed": 290, "published": 3, "date": "1600390454", "time_retrieved": "2024-07-30T20:44:42.153732", "image_code": "const float xSamples = 8.0;\nconst float ySamples = 8.0;\n\nconst float xSampleSpacing = 1.0;\nconst float ySampleSpacing = 1.0;\n\nconst float half_x_samples = xSamples / 2.0;\nconst float half_y_samples = ySamples / 2.0;\n\nconst float min_sample_x = -half_x_samples;\nconst float min_sample_y = -half_y_samples;\n\nconst float max_sample_x = half_x_samples;\nconst float max_sample_y = half_y_samples;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 totalSample = vec3(0.0, 0.0, 0.0);\n    float samples = 0.0;\n    for (float xOffset = min_sample_x; xOffset < max_sample_x; xOffset++) {\n        for (float yOffset = min_sample_y; yOffset < max_sample_y; yOffset++) {\n            vec2 sampleCoords = (fragCoord + vec2(xOffset * xSampleSpacing, yOffset * ySampleSpacing)) / iResolution.xy;\n            vec3 sampleColor = texture(iChannel0, sampleCoords).xyz;\n            totalSample += sampleColor;\n            samples += 1.0;\n        }\n    }\n    vec3 avgSample = totalSample / samples;\n    fragColor = vec4(avgSample, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 448, 448, 1031]]}
{"id": "3sdyRH", "name": "Magnifying Glass Effect", "author": "oneshade", "description": "I though it would be cool to do a magnifying glass shader so here one is. Drag the mouse to move the magnifying glass. When you release the mouse the magnifying glass will move in a figure eight. Thanks FabriceNeyret2 for the suggestion.", "tags": ["effect", "glass", "magnifying"], "likes": 4, "viewed": 524, "published": 3, "date": "1600388567", "time_retrieved": "2024-07-30T20:44:42.926665", "image_code": "const vec3 lensBorderColor = vec3(0.0, 0.0, 0.0);\nconst float lensBorderWidth = 4.0;\nconst float lensRadius = 50.0;\nconst float lensMag = 5.0;\n\nconst float _halfBorderWidth = lensBorderWidth / 2.0;\nconst float _innerRadius = lensRadius - _halfBorderWidth;\nconst float _outerRadius = lensRadius + _halfBorderWidth;\n\nvec3 shade(in vec2 fragCoord) {\n    float sinTime = sin(0.25 * iTime);\n    float cosTime = cos(0.25 * iTime);\n    vec2 mousePos = 0.5 * iResolution.xy + vec2(cosTime * iResolution.x * 0.390625, sinTime * cosTime * iResolution.y * 0.520833);\n    if (iMouse.z > 0.0) {\n        mousePos = iMouse.xy;\n    }\n\n    float dist = sqrt(pow(fragCoord.x - mousePos.x, 2.0) + pow(fragCoord.y - mousePos.y, 2.0));\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 outColor = texture(iChannel0, uv).xyz;\n\n    if (dist <= _innerRadius) {\n        uv = (mousePos + ((fragCoord - mousePos) / lensMag)) / iResolution.xy;\n        outColor = texture(iChannel0, uv).xyz;\n    }\n    \n    if (dist > _innerRadius && dist <= _outerRadius) {\n        outColor = lensBorderColor;\n    }\n\n    return outColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = shade(fragCoord);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 346, 346, 1096], [1098, 1098, 1153, 1153, 1224]]}
{"id": "3ddyRH", "name": "Checkered Sphere", "author": "oneshade", "description": "This is my first ray marching shader! The concept was taken from the ray marching tutorial by Michael Walczyk. The texture is mapped using spherical coordinates and the shading is lambertian (diffuse). Move the mouse to position the light.", "tags": ["raymarching", "sphere", "checkered"], "likes": 4, "viewed": 392, "published": 3, "date": "1600388226", "time_retrieved": "2024-07-30T20:44:43.804319", "image_code": "vec3 lightDirection = normalize(vec3(-0.58, 0.58, 0.58));\nfloat focalLength = 400.0;\nfloat sphereRotation = 0.0;\n\nconst float MAX_TRACE_DISTANCE = 1000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 32;\n\nvec3 rotatePointAbout(in vec3 p, in vec3 o, in float r) {\n    float cosTheta = cos(r);\n    float sinTheta = sin(r);\n    vec3 relativePosition = p - o;\n    vec3 rotatedPoint = vec3(relativePosition.x * cosTheta + relativePosition.z * sinTheta, relativePosition.y, relativePosition.x * sinTheta - relativePosition.z * cosTheta);\n    return rotatedPoint + o;\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n    return length(p - o) - r;\n}\n\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 sphereOrigin = vec3(0.0, 0.0, -400.0);\n        float sphereRadius = 100.0;\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        vec3 relativePosition = rotatePointAbout(currentPosition, sphereOrigin, sphereRotation);\n        float distanceToClosest = sdSphere(relativePosition, sphereOrigin, sphereRadius);\n        if (distanceToClosest < MIN_HIT_DISTANCE) {\n            relativePosition -= sphereOrigin;\n            vec3 normal = normalize(currentPosition - sphereOrigin);\n            float phi = atan(relativePosition.z, relativePosition.x);\n            float theta = atan(relativePosition.y, sqrt(pow(relativePosition.z, 2.0) + pow(relativePosition.x, 2.0)));\n            vec2 uv = vec2((phi + 3.14) / 6.28, (theta + 1.57) / 3.14);\n            vec3 color = texture(iChannel0, uv).xyz;\n            float lambertian = dot(normal, lightDirection);\n            return vec4(color * lambertian, 1.0);\n        }\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        distanceTraveled += distanceToClosest;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    float lightPhi = 2.35619;\n    float lightTheta = 0.785398;\n    if (iMouse.z > 0.0) {\n        lightPhi = -((iMouse.x - halfResolution.x) / halfResolution.x) * 3.14 + 1.57;\n        lightTheta = ((iMouse.y - halfResolution.y) / halfResolution.y) * 1.57;\n    }\n    float cosPhi = cos(lightPhi);\n    float sinPhi = sin(lightPhi);\n    float cosTheta = cos(lightTheta);\n    float sinTheta = sin(lightTheta);\n    lightDirection = vec3(cosPhi * cosTheta, sinTheta, sinPhi * cosTheta);\n    sphereRotation = iTime;\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirection = normalize(vec3(xy, -focalLength));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 checkers = vec2(36.0, 18.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 checkerSize = iChannelResolution[0].xy / checkers;\n    bool x = mod(fragCoord.x, 2.0 * checkerSize.x) < checkerSize.x;\n    bool y = mod(fragCoord.y, 2.0 * checkerSize.y) < checkerSize.y;\n    bool fill = x ^^ y;\n    fragColor = vec4(fill, fill, fill, 1.0);\n}\n\n/*\nconst vec2 gridSize = vec2(36.0, 18.0);\nconst float horizontalLineWidth = 2.0;\nconst float verticalLineWidth = 2.0;\n\nconst float halfHorizontalLineWidth = 0.5 * horizontalLineWidth;\nconst float halfVerticalLineWidth = 0.5 * verticalLineWidth;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 cellSize = iResolution.xy / gridSize;\n    float xModWidth = mod(fragCoord.x, cellSize.x);\n    float yModHeight = mod(fragCoord.y, cellSize.y);\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if (xModWidth <= halfHorizontalLineWidth || (cellSize.x - xModWidth) <= halfHorizontalLineWidth) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if (yModHeight <= halfVerticalLineWidth || (cellSize.y - yModHeight) <= halfVerticalLineWidth) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n*/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 277, 277, 577], [579, 579, 629, 629, 661], [663, 663, 702, 702, 1912], [1914, 1914, 1969, 1969, 2721]]}
{"id": "3dtyRH", "name": "Experimental techno", "author": "jarble", "description": "This is a visualization of some \"bytebeat\" music.\nThe sound is in the \"common\" buffer.", "tags": ["music"], "likes": 4, "viewed": 345, "published": 3, "date": "1600384747", "time_retrieved": "2024-07-30T20:44:44.574261", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "common_code": "\nvec2 sound1( float time )\n{\n    int t = int(time * 1000.0);\n    t = t%8000;\n    t = (t>>6&t*(-(t%4))&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tresult += sound1(time*factor)/(factor*3.0);\n        factor *= 1.5;\n    }\n    return result;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "3s3cz8", "name": "Day 271", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 23, "viewed": 518, "published": 3, "date": "1600369435", "time_retrieved": "2024-07-30T20:44:45.584559", "image_code": "// Fork of \"Day 269\" by jeyko. https://shadertoy.com/view/WljfWd\n// 2020-09-16 10:42:45\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n  \n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.4;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBoxRound( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv, float fov){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n", "buffer_a_code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat dfo = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\nvec3 ro = vec3(0.,0.14,.12)*10.;\nvec3 rd = vec3(0);\n\n// ----------\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\nfloat bspline( in vec2 coords );\nfloat jaggy(vec2 uv, float densitya, float densityb, float w);\nfloat dotwork(vec2 uv, float w, float densitya, float densityb);\nfloat screenprint(vec2 p,float lum, float cellSize, float strength);\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt);\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    //p.z = pmod(p.z,4.5);\n    \n    d = length(p.xz) + 0.0 - abs(sin(p.y*8.))*.3*smoothstep(1.,0.,length(p.y));\n    \n    //d = length(p) - .64;\n    for(int i = 0; i < 5; i++){\n    \tp = abs(p);\n        p.xz *= rot(0.25*pi);\n        p -= 0.1;\n    \t//d = xor(d, max(length(p.z), length(p.y) - 1.),0.4);\n      \td = xor(d, length(p.xy) - 0.5,0.4);\n      \n        \n    }\n    \n    //  \n    \t//d = xor(d, length(p.zx) - 0.3,0.3);\n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    //d = abs(d) - 0.01;\n    \n    return d*0.5;\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.,0.0001);\n\treturn normalize(map(p) - vec3(\n    \tmap(p - t.yxx),\n    \tmap(p - t.xyx),\n    \tmap(p - t.xxy)\n    ));\n}\n\n\n#define EPS 0.0001\n\nfloat march(inout vec3 p){\n\tfloat d = 10e5;\n    \n    for(float i = 0.; i < 200.; i++){\n        float m = map(p);\n        d = min(d,m);\n        if(d < EPS){\n        \tbreak;\n        }\n        p += rd*(m + 0.00);\n    }\n    \n    \n    return d;\n}\n\n\nfloat marchaa(vec2 uv){\n    float col = 0.;\n    float aa = 1.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n        vec2 luv = uv + vec2(mod(i,aa),floor(i/aa))/aa/iResolution.xy;\n        vec3 p = ro;\n        \n        float m = march( p);\n        if (m < EPS){\n        \n            vec3 n = getNormal(p);\n            \n            vec3 l = normalize(vec3(1.,2.,-1.));\n           \n            float diff = max(dot(n,l),0.);\n            \n            \n        \tcol += 1.*diff;\n        } \n    \n    }\n    \n    col /= aa*aa;\n    col = screenprint(uv,col,0.008,0.9);\n    col = 1. - col; // < remove me\n    return col;\n}\n\nfloat logoGen(vec2 uv, float seed, float sc, float its){\n    vec3 col = vec3(0);\n    \n    uv *= sc;\n    vec2 id = floor(uv);\n    vec2 fruv = fract(uv) - 0.5;\n        \n    if(length(id.x) > 0. || length(id.y) > 0.)\n        return 10e4;\n    \n    id += seed;\n    float gap = 0.109;\n    \n    float h1 = .9;\n    \n\tfloat d = 10e4;\n    \n    \n    float r = r22(id).x; // todo - change to r21\n    float rI= floor(mod(r*14225.12 , 10.));\n    \n    fruv *= rot(0.25*pi*rI);\n    \n    for (float i = 0.; i < its; i ++) {\n    \t\n    \tfruv *= rot(0.25*pi*id.y);\n        fruv.x = abs(fruv.x);\n        fruv.y = abs(fruv.y);\n        \n        vec2 rr = r22(id + i*seed);\n        \n        rr *= 10.;\n        \n        \n        \n        if (rr.x < 2.) {\n        \tfruv.x -= 0.5;\n        } else if (rr.x < 4.) {\n        \tfruv.x -= 0.25;\n        } else if (rr.x < 6.){\n        \tfruv.y -= 0.5;\n            fruv *= rot(4.*0.125*pi);\n        } else if (rr.x < 8.) {\n        \tfruv.x -= 0.5;\n        } else {\n        \t//fruv.x -= 0.125;\n            fruv.y -= 0.325;\n        }\n    \n    }\n    \n\n    d = min(d, sdBox(fruv + vec2(0., h1 + gap), vec2(0.04, h1)));\n   \n    d = min(d, sdBox(fruv + vec2(h1 + gap, 0.), vec2(h1, 0.04)));\n    \n    d = min(d, sdBox( (fruv  + vec2(0.057) )*rot(-0.25*pi), vec2(h1*0.25, 0.04)));\n    \n\treturn d/sc;\n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s) {\n\tp *= s;\n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375;\n    float char = chars[int(id.x)];\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8. && mod(char, 1.) == 0.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.)/16.,floor(char/16.)/16. ));\n        t = letter.w - 0.5;\n        t /= s;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    guv = uv;\n    luv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    seed = r11(frame)*200.;\n    df = dFdx(uv.x)*2.;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 col = vec3(1);\n    float d = 10e5;\n    \n\trd = getRd(ro,vec3(0.,0.3,0.),guv, .8);\n    \n    vec2 roll = r12(frame + 1.);\n    \n    \n    d = marchaa(uv);\n    \n    col = colour( d , col, vec3(0.001), 0, 90,4.6,.4);\n    \n    // -- botbox\n    \n    \n \tfloat box = sdBoxRound(uv + vec2(0,0.5),vec2(0.2)) - 0.02;\n    \n    d = box;\n    \n    col = colour( d , col, vec3(0.1,00.2,0.1)*1., 1, 1,3.1,.001);\n    \n    d = abs(box);\n    \n    //col = colour( d - 0.01 , col, vec3(0.3,0.,0.), 3, 1,1.1,4.01);\n    \n   \n    \n    \n    \n    // -- sticker \n    \n    vec2 off = vec2(-0.62,0.36);\n    \n    float rb = sdBoxRound((uv + off + vec2(0.3,-0.52))*rot(0.5*pi),vec2(0.23,0.1));\n    \n    d = rb;\n    \n\tcol = colour( d - 0.01, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv + off + vec2(0.35,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n    \n    d = min(d,text((uv + off + vec2(0.32,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.5 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.29,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.7 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.255,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.77 ,5.9));\n    \n    d = max(d,-uv.y + 0.1);\n    \n    \n\tcol = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n    uv = (uv + off + vec2(0.3,-0.5))*rot(0.5*pi);\n\n    uv = guv;\n    \n    // -- outer\n    d = -sdBox(uv,vec2(0.45));\n    \n    col = colour( d , col, vec3(0.00), 1, 1,3.1,.001);\n    \n\tcol = colour( d*0.5 + 0.0, col, vec3(0.), 0,0,4.,.03);\n\n    \n    \n    // -- stickerb\n    \n    d = logoGen( (uv + off + vec2(0.37,-0.31))*rot(0.*pi), 41.,18.,7.)*3.;\n\n    //d = min(d,logoGen( (uv + off + vec2(0.3,-0.36))*rot(1.25*pi), 45.,17.,4.)*3.);\n\n    d = min(d,logoGen( (uv + off + vec2(0.29,-0.31))*rot(0.*pi), 12.,18.,4.)*3.);\n\n    d = min(d,sdBox((uv + off + vec2(0.3,-0.4)),vec2(0.08,0.0001))*4.);\n    \n    //col = colour( d, col, vec3(1.), 0,0,27.,.001);\n    col = colour( d, col, vec3(1.), 0,1,5.,.001);\n    \n    \n    // -- stickerc\n    \n    \n    off -= vec2(-0.27,0.);\n    box = sdBoxRound((uv - off)*rot(-0.05),vec2(0.05,0.02)) - 0.005;\n    d = box;\n    \n    \n    col = colour( d , col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv - off + vec2(0.04,0.004))*rot(-0.01), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n\n    d = max(d,box);\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n    \n    //col = colour( d , col, vec3(0.00), 1, 1,3.1,.001);\n    \n    // -- titletext\n    \n    d = text((uv  + vec2(0.09,0.38) )*rot(-0.01), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.,1.9);\n\n    \n    col = colour( d + 0.01, col, vec3(0.1,0.9,0.8)*0.8, 0,0,3.,.2);\n\n    \n    \n    \n    //col -= d;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n\tvec2 roll;\n\t\n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n\n    vec4 n = valueNoise(guv,1.); \n    vec4 nb = valueNoise(guv*0.5 + 0.2,2.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\tdeb = smoothstep(df + texture(iChannel1,guv*0.5).x*0.53*n.z*strokeparamb,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.24*pow(n.w,0.5) + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.12;\n        \n        // splatter\n        db += texture(iChannel1,ruv*0.2).x * 0.2*pow(nb.x,5.)*strokeparamb;\n        db -= texture(iChannel2,ruv*0.3).x * (0.35*pow(n.z,3.) + 0.35*pow(nb.z,3.) )*strokeparamb;\n        /*\n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.1 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        */\n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n      \n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    \n    if( stroke == 90){\n        deb = mix(-0.,1.,clamp(db,0.,1.));\n    }\n    \n    \n    if(stroke == 90){\n    \tcb = mix( cb, 1. - cb, smoothstep(1.,0.,strokeparam*(t.x + ta.x - nb.x*0.4 + n.y*0.2)));\n    } else {\n        cb*=1. - smoothstep(1.,0.,abs(db)*(30.01) + t.z*1.53)*.9;\t\n    }\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t   \n    \n    if(mode == 0){\n        // 0 replace\n        if ( stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77 - 0.1*smoothstep(1.,0.,abs(db)*14.11*(1. + pow(nb.x,3.)*5.))   ), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    } else if(mode == 1){\n        // 1 multiply\n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n        // 2 overlay\n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        }\n    } else if(mode == 3){\n        // 3 darken\n          \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\t\n        // 4 burn\n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\t\n        // 5 linear burn\n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n        // 6 color dodge\n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt){\n\tfloat d = 10e5;\n    \n    for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n    \tvec3 lro = ro + vec3(0,i,0);\n        \n        \n        float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n        vec3 p = lro + rd*plane;\n    \t\n        vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n        \n        float m = map(vec3(p.x,(lro + rd*plane).y - i*1.5,p.z));\n        if(m <= d){\n        \t\n        \t//df = max(ldf.y,ldf.x)*1.;\n        \t\n            df = length(ldf)*0.5;\n            \n\t\t\td = min(d,m);\n        \n        }\n        \n    }\n    \n    \n    return d ;\n}\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\n\nfloat screenprint(vec2 p,float lum, float cellSize, float strength){\n\tfloat t = 0.;\n    vec2 q = p ;\n\n    p *= rot(0.125*pi);\n    \n    \n    q /= cellSize/pi;\n    // some distortion\n    p -= length(sin(q))*normalize(p)*cellSize/6.;\n    \n    \n    p = pmod(p,cellSize);\n    p -= length(sin(q))*normalize(p)*cellSize/6.*0.6;\n    \n    float lsz = 0.;\n    \n    float n = valueNoise(q*410.,1.).x*5.;\n    \n    n = pow(n,2.)*0.07;\n    lsz = pow(smoothstep(0.,1.,lum*(0.45 +n)),strength)*cellSize*0.6;\n    \n    float col = smoothstep(0.002,0.,length(p) - lsz + 0.001);\n    //col = mix(col,smoothstep(0.01,0.,sin(q.x)*sin(q.y)* lsz*1. ),0.1);\n\t\n    return col;\n}\n\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    t *= 6.;\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 222, 222, 279], [280, 280, 313, 313, 842], [843, 843, 861, 861, 1189], [1192, 1192, 1249, 1249, 2127]]}
{"id": "ts3cz8", "name": "color fusion 4", "author": "FabriceNeyret2", "description": "rapid periodic flip of colors shows B&W, but you still see something happen.\nSPACE: with random color flip, it's no longer working !", "tags": ["color", "perception"], "likes": 4, "viewed": 378, "published": 3, "date": "1600363843", "time_retrieved": "2024-07-30T20:44:46.652703", "image_code": "#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define hash(p)         fract(sin( (p) * 178.233 ) * 43758.5453)   // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    int i = int(3.*hash(iTime)),\n        j = int(2.*hash(iTime+1.));\n    if (!keyToggle(32)) i = iFrame%3, j = 1;\n    \n    O = texture(iChannel0, u/iResolution.xy );\n    \n    O  = vec4( O[i],O[(i+1+j)%3], O[(i+2-j)%3], 1 );   // grey from colors\n // O *= vec4( (iFrame+ivec4(0,1,2,3))%3 - 1 );        // variant: colors from 3 monochromes\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 255, 255, 596]]}
{"id": "Ws3yzH", "name": "Nebula 18", "author": "Leria", "description": "Dark Light Purple Nebula \nA+mouse: tune density\nC toggle : control sigma_s or albedo", "tags": ["fractal", "noise", "pink", "red", "nebula", "purple"], "likes": 15, "viewed": 1281, "published": 3, "date": "1600356403", "time_retrieved": "2024-07-30T20:44:47.683946", "image_code": "// Fork of \"Nebula 17\" by Leria. https://shadertoy.com/view/3ljfDd\n// 2020-09-17 15:21:56\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.01*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. ); \n\nfloat fbm_add( vec3 p, float level ) { // in [-1,1]\n    \n    float f = 0.;;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    for(float l = 0. ; l < level ; l++)\n    {\n     \tf += (1./exp2(l))*snoise(p);   p = p*s;\n    }\n\n     return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1./8.;\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p, 5.);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 3.8), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(velocity*velocity*velocity)/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate = disp_turb*fbm(p*2.); //generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        vec3 rgb_t = vec3(0.);\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n                                                 // --- textured bubble model\n            \n            float rad_bubl = 2.36; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); // vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB))/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            //float l = max(0., 1.-d*d);\n\t\t\tfloat l = exp(-.5*SQR(d/2.));\n#if 0\n          float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask1 = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            //mask = n;\n#else\n            //rad_bubl -= .2 ;\n             float dr = fbm_add( p*5.2 - 124.17, 4.),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.0*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -1.8*dr )   ) ;\n#endif\n            //mask = 1.;\n            \n                                                 // --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = .1;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v*v)/(4.*scale))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(.1, .1, 7.)*10.;   // <<< $PHYS $PARAM (well, part of sigma_t)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); // $TUNE\n            \n            vec3 sigma_t = vec3(0);\n            if(vt <= 0.)\n            {\n                sigma_t = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                sigma_t = absorb_coef*k*float(s)*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            sigma_t = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            sigma_t /=10.;\n            \n            rgb_t = exp(-sigma_t);    // <<< local transparency\n            \n            \n            \n            vec3 col_loc = vec3(1., .15, .2)/(sigma_t+1e-5);  // <<< $PHYS $PARAM albedo, = sigma_s/sigma_t\n            if KeyToggle(64+3) col_loc *= absorb_coef; //  $TUNE  control sigma_s rather than albedo\n            \n            \n            // attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s/sigma_t\n            //        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            // e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            //            E_tr = .5 VT³/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            //                 = 12000 *(mask*fbm)³\n            // note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k/10.;           // --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) // energy_transfer_rate \n                                   - val(L.x,L.y,L.z) // energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           // above : diff = abs(Lambert)\n            //dif = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n#define Gauss(x,s) 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 1./ dot(L/L0,L/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl+3.) ) ) ;\n          //float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = source*(.1/(length(m.pos-p)*length(m.pos-p))),//* smoothstep(0., 1./size, Gauss(X,std_dev) ),\n                shadow = 1.,\n            reflec = dif;\n            \n            vec3 emission = vec3(.2, .5, 1.);   // <<< $PARAM $PHYS  \n            \n    \t\t                          // --- add current voxel contribution to ray\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            //c = vec3();\n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(center)-0.5 < 0.)\n\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )/R.y,\n         M =  iMouse.xy/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = 0./2., degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .5* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n  //sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  //sky =   max(texture(iChannel0,fragCoord/256.+vec2(degree,degree2)).rrr -.8,0.)/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1984, 1984, 2022, 2035, 2309], [2311, 2311, 2336, 2349, 2688], [2690, 2690, 2709, 2709, 2806], [2808, 2827, 2903, 2903, 2950], [2952, 2952, 2984, 2984, 3004], [3006, 3006, 3040, 3040, 3062], [3149, 3149, 3190, 3190, 3226], [3228, 3228, 3314, 3314, 3349], [3351, 3351, 3394, 3394, 3434], [3436, 3436, 3460, 3460, 3508], [3510, 3510, 3550, 3550, 3854], [3856, 3856, 3880, 3880, 3944], [3946, 3946, 4001, 4001, 4062], [4064, 4064, 4112, 4112, 4256], [11532, 11532, 11589, 11589, 12642]]}
{"id": "Ws3cz8", "name": "lorenz11 - Fabrice5", "author": "FabriceNeyret2", "description": "Lorenz attractor.\n3D interactive drawing by replacing multi-trajectories of [url]https://shadertoy.com/view/3dtcRr[/url]\nby N time-successive segments. \nSPACE to see Bounding Boxes.    Uncomment #59 for fog effect.\n", "tags": ["math", "attractor", "lorenz"], "likes": 34, "viewed": 746, "published": 3, "date": "1600352331", "time_retrieved": "2024-07-30T20:44:48.520708", "image_code": "// 3D variant of https://shadertoy.com/view/3scyz8\n// preparing 3D variant of https://shadertoy.com/view/3dtcRr\n// multi-trajectory variant of https://shadertoy.com/view/3ddyRr\n// optimization of https://shadertoy.com/view/Wscyzr\n// simplification + comments of \"lorenz11\" by mrtkp9993. https://shadertoy.com/view/3tBfWd\n\n#define rot(a)          mat2( cos( a + vec4(0,33,11,0)) )\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat Line(vec2 a, vec2 b, vec2 U) // --- Distance to a line segment https://www.shadertoy.com/view/llySRh\n{   \n    U -= a, b -= a;\n\tfloat h = dot( U, b ) / dot(b,b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length( U - b * c ) : 1e5;     // dist to strict segment\n  //return        length( U - b * c );           // dist to segment with round ends\n}\n\n#define proj(v) ( V=v.xyz - C, V.yz *= rot(_t), V.xz *= rot(.3*t), (C+V).xy ) // rotate camera\n\nvoid mainImage( out vec4 O, vec2 u ) // --- re-simulate and draw curve segments\n{  \n    vec3 C = vec3(0,0,Y_OFFSET) / VIEW_SCALE;    // rotation center\n    vec2 R = iResolution.xy, Min, Max, p,\n           U = ( u - .5*R ) / R.y; //U.y += Y_OFFSET;\n      U /= VIEW_SCALE;\n    float pix = 1. / R.y / VIEW_SCALE;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.));  // for camera rotation\n\n    vec3 last, next, V;\n\tO = vec4(0);\n                           \n    for (int y = 0; y < min(N,int(R.y)); y++) {  // --- drawing segments;\n        mat2x3 M = mat2x3( T(vec2(1,y)).xyz,\n                           T(vec2(2,y)).xyz );\n        Min = vec2(1e5), Max = -Min;\n        for (int i=0; i<8; i++)                  // get the 2D bounding box of the 3D BB\n            p = proj( vec3( M[i%2][0], M[i/2%2][1], M[i/4][2] ) ),\n            Min = min(Min,p), \n            Max = max(Max,p);\n        Min -= pix; Max += pix;\n\n        if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) { // ---\n            // segment potentially visible: re- simulate and detail-draw it                  \n            last = T(vec2(0,y+1)).xyz;           // pixel (0,y,+1) saves segment start position.\n            float d = 1e6, l, z;\n\n            for(float i = 0.; i < STEPS; i++ ) { // re-simulates & draws for 1 frame range\n                next = Integrate( last, .016 * SPEED );\n                vec2 B = proj(last), E = proj(next);\n                l = Line( B , E, U);\n                if ( l < d ) d = l, z = (C+V).z; // portion of curve closest to pixel       \n                last = next;\n            }\n            d *=  VIEW_SCALE;\n            float c  =  INTENSITY / SPEED * smoothstep( FOCUS / R.y, 0., d )\n                      ;// + INTENSITY / 8.5   * exp(- 1e3 * d*d );\n            \n            O +=   24.* exp(- .15 * z ) *                       // uncomment for fog effect\n                 // 4.* exp(- vec4(.1,.2,.4,0) * ( z - 3. ) ) * // uncomment for col fog effect\n                    c* COL * pow(FADE,float(y));                // fade with segment age \n            if keyToggle(32) O[y%3] = max(.15, O[y%3]);         // demo: draw color rectangle for calulating area\n       }\n     }\n    O = pow(O, vec4(1./2.2));                    // to sRGB\n }", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": " // === simulate trajectory segments\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n    u = floor(u);\n    \n    int y = int(u.y);                        // segment #y data in line y\n    if (y>N || u.x>2. ) return;\n    if (y>0) { O = T(u-vec2(0,1)); return; } // cascade-save segment states   \n                                             // --- compute new segment 0\n    vec3  last = T(0).xyz,                   // pixel (0,0) saves the current position.\n          next = last,\n         start = vec3( .1, .001, 0 ),        // Initial Position\n         Max = last, Min = last;\n\n    for(float i = 0.; i < STEPS; i++ )       // simulates for 1 frame range\n        next = Integrate( next, .016 * SPEED ),\n        Min  = min(Min, next),\n        Max  = max(Max, next);\n\n    O =   u == vec2(0,y)                     // pixel (0,y) saves the current position.\n        ? iFrame < 1     ? vec4( start, 0 )  // Setup initial conditions.\n                         : vec4( next , 0 )  // Save current position.\n        : u == vec2(1,y) ? vec4( Min  , 0 )  // pixel (1-2,y) saves the segment bbox \n                         : vec4( Max  , 0 );\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "                                      // --- graphics settings\nint            N = 400;               // number of segments\nfloat VIEW_SCALE = .015,              // scene scaling\n        Y_OFFSET = .4,                // scene offset\n           STEPS = 96.,               // number of iteration per frame\n           SPEED = .05,               // dt = SPEED/60\n       INTENSITY = .2,\n        //  FADE = .99,\n            FADE = .99,\n           FOCUS = 1.,\n\n  O = 10., P = 28., B = 8./3.;        // --- System Parameters\n\n//vec4 COL = vec4(.93, .36, .36, 1);\n//const vec4 COL = pow( vec4(.93, .36, .36, 1), vec4(2.2) );\n  vec4 COL = vec4(1, .2, .2, 1) *2.;  // equivalent look with gamma\n\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n\n\n//https://en.wikipedia.org/wiki/Lorenz_system\n\nvec3 Integrate(vec3 cur, float dt)    // --- Calculate the next position \n{\n\treturn cur + dt * vec3(    O  * (cur.y - cur.x)       ,\n                            cur.x * (P - cur.z) - cur.y   ,\n                            cur.x *   cur.y     - B*cur.z   );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 448, 556, 556, 807]]}
{"id": "WdcyRH", "name": "tunel del tiempo-v1", "author": "jorge2017a1", "description": "tunel del tiempo-v1", "tags": ["tuneldeltiempov1"], "likes": 5, "viewed": 274, "published": 3, "date": "1600351043", "time_retrieved": "2024-07-30T20:44:49.531007", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h ) \n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h ) \n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n///------------------------------------\n\nfloat CilindroConAlas(vec3 p, float numItem)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    pp=p;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    \n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdsp1= sdCylinderXY(p, vec2(2.0,6.0) );\n    float sdb1= sdBox(rep2, vec3(6.5,0.2,5.5));\n    \n    float h=2.0;\n    float r1=2.0;\n    float r2=0.25;\n    \n    pp= rotate_x(pp, radians(90.0));\n    float sdcc1= sdCappedCone(pp-vec3(0.0,7.0,0.0), h, r1, r2 );\n        \n    \n    float res = opSU(sdsp1, sdb1,0.1);\n     res = opSU(res, sdcc1,0.1);\n  \treturn  res;\n}\n\n\n\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    p.y=p.y-5.0;\n    pp=p;\n\tvec3 q=p;\n    float cx=47.0;\n    float cy=11.0;\n    float cz=30.00;\n    \n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    float sdc1= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(20.0,15.0));\n    float sdc2= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(18.0,17.0));\n\tfloat dif= differenceSDF(sdc1, sdc2);\n    res =opU3(res, vec3(dif,-1.0,2.0)); \n\t\n    //vec3 pt=vec3(0.0+2.0*cos(iTime), 0.0+2.0*sin(iTime+cos(iTime)),0.0+2.0*sin(iTime) );\n    //pp=pp+pt;\n    float sf1= CilindroConAlas( pp-vec3(-5.0,-4.0,itime), 6.0);\n    res =opU3(res, vec3(sf1,30.0,MATERIAL_NO)); \n    //vec3 (dist,color, idmaterial) \n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n\n    \n    \n    if (id_material==2.0)\n    {\n    \t\n\t\tconst float pi= 3.14159265359;\n\t\tconst float spinspeed=0.2;\n\t\tconst float movespeed=-1.;\n\t\tconst float spirals=1.5;\n\t\tconst float twist = 3.0;\n        \n       \n        vec2 uv = mObj.uv;\n        \n\t\tfloat l = length(uv);\n\t\tfloat pos = atan(uv.x, uv.y) + fract(spinspeed/iTime) * pi;\n        float distortion = iTime*movespeed + twist / sqrt(l);\n        vec2 s = 2.0*abs(fract(vec2(pos + distortion, 2.0*(pos - distortion + spirals))/pi*twist) - vec2(0.5));\n\t\tfloat d = dot(s,s);\n\t\tfloat f = smoothstep(0.0, 0.1, 1.0-d);\n\t\tvec3 color = vec3(f*l);\n\t\treturn color;\n\t\t\n      }\n   \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(0.0, 10.0, 20.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -2.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    vec3 ro=vec3(4.0,0.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n       \n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 271, 271, 292], [293, 293, 325, 325, 409], [410, 410, 456, 456, 543], [544, 544, 578, 578, 640], [641, 641, 678, 678, 773], [774, 774, 815, 815, 910], [911, 911, 951, 951, 1046], [1047, 1047, 1087, 1087, 1182], [1184, 1184, 1209, 1209, 1228], [1229, 1229, 1254, 1254, 1273], [1274, 1274, 1310, 1310, 1338], [1341, 1341, 1367, 1367, 1421], [1423, 1423, 1457, 1457, 1630], [1632, 1660, 1701, 1701, 1794], [1796, 1796, 1855, 1855, 2168], [2170, 2214, 2261, 2261, 2288], [2290, 2290, 2333, 2333, 2360], [2362, 2362, 2410, 2410, 2438], [2439, 2523, 2562, 2562, 2606], [2607, 2607, 2646, 2646, 2690], [2691, 2756, 2790, 2790, 2888], [2889, 2889, 2923, 2923, 3015], [3016, 3016, 3050, 3050, 3142], [3184, 3184, 3205, 3205, 3274], [3316, 3316, 3362, 3362, 3909], [3913, 3913, 3938, 3938, 4640], [4642, 4687, 4754, 4754, 5122], [5123, 5174, 5198, 5198, 5386], [5387, 5450, 5483, 5483, 5925], [5927, 5981, 6017, 6017, 6251], [6252, 6341, 6390, 6390, 6612], [6613, 6647, 6727, 6727, 7339], [7340, 7432, 7479, 7479, 8148], [8202, 8202, 8295, 8295, 8713], [8716, 8765, 8822, 8822, 9978]]}
{"id": "Ws3yRH", "name": "original-13223.0", "author": "jorge2017a1", "description": "original-13223.0......//autor desconocido", "tags": ["original132230"], "likes": 3, "viewed": 308, "published": 3, "date": "1600351037", "time_retrieved": "2024-07-30T20:44:50.355802", "image_code": "//autor desconocido\nconst float pi= 3.14159265359;\nconst float spinspeed=0.2;\nconst float movespeed=-1.;\nconst float spirals=3.;\nconst float twist = 3.0;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n\t\n\tfloat l = length(uv);\n\tfloat pos = atan(uv.x, uv.y) + fract(spinspeed/iTime) * pi;\n\tfloat distortion = iTime*movespeed + twist / sqrt(l);\n\tvec2 s = 2.0*abs(fract(vec2(pos + distortion, 2.0*(pos - distortion + spirals))/pi*twist) - vec2(0.5));\n\tfloat d = dot(s,s);\n\tfloat f = smoothstep(0.0, 0.1, 1.0-d);\n\tvec3 color = vec3(f*l);\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 214, 214, 641]]}
{"id": "3scyz8", "name": "lorenz11 - Fabrice4", "author": "FabriceNeyret2", "description": "Lorenz attractor.\nprepare 3D interactive drawing by replacing multi-trajectories of [url]https://shadertoy.com/view/3dtcRr[/url]\nby time-successive segments (in color Bboxes).\n", "tags": ["math", "attractor", "lorenz"], "likes": 9, "viewed": 347, "published": 3, "date": "1600349405", "time_retrieved": "2024-07-30T20:44:51.211514", "image_code": "// preparing 3D variant of https://shadertoy.com/view/3dtcRr\n// multi-trajectory variant of https://shadertoy.com/view/3ddyRr\n// optimization of https://shadertoy.com/view/Wscyzr\n// simplification + comments of \"lorenz11\" by mrtkp9993. https://shadertoy.com/view/3tBfWd\n\nfloat Line(vec2 a, vec2 b, vec2 U)    // --- Distance to a line segment https://www.shadertoy.com/view/llySRh\n{   \n    U -= a, b -= a;\n\tfloat h = dot( U, b ) / dot(b,b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length( U - b * c ) : 1e5;   // dist to strict segment\n  //return        length( U - b * c );         // dist to segment with round ends\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n      vec2 R = iResolution.xy, Min, Max,\n           U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n      U /= VIEW_SCALE;\n    float pix = 1. / R.y / VIEW_SCALE;\n    vec3 last, next;\n\tO = vec4(0);\n                           \n    for (int y = 0; y < N; y++) { // --- drawing segments\n        Min = T(vec2(1,y)).MODE - pix,\n        Max = T(vec2(2,y)).MODE + pix;\n        float c = 0.;\n        if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) {\n\n            last = T(vec2(0,y+1)).xyz;         // pixel (0,y,+1) saves segment start position.\n            float d = 1e6;\n\n            for(float i = 0.; i < STEPS; i++ ) // re-simulates & draws for 1 frame range\n                next = Integrate( last, .016 * SPEED ),\n                d = min(d, Line(last.MODE , next.MODE, U) ),        \n                last = next;\n\n            d *=  VIEW_SCALE;\n            c  =  INTENSITY / SPEED * smoothstep( FOCUS / R.y, 0., d )\n                + INTENSITY / 8.5   * exp(- 1e3 * d*d );\n            \n            O +=  c*COL * pow(FADE,float(y));  \n            O[y%3]++;          // for demo, draw color rectangle for calulating area\n       }\n     }   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": " // === simulate particles\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n    U /= VIEW_SCALE;\n    u = floor(u);\n    \n    int y = int(u.y);                        // particle #y in line y\n    if (y>N || u.x>2. ) return;\n    if (y>0) { O = T(u-vec2(0,1)); return; } // cascade-save segment states\n    \n\n    vec3  last = T(0).xyz,                   // pixel (0,0) saves the current position.\n          next = last,\n         start = vec3( .1, .001, 0 ),        // Initial Position\n         Max = last, Min = last;\n\n    for(float i = 0.; i < STEPS; i++ )       // simulates for 1 frame range\n        next = Integrate( next, .016 * SPEED ),\n        Min  = min(Min, next),\n        Max  = max(Max, next);\n\n    O =   u == vec2(0,y)                     // pixel (0,y) saves the current position.\n        ? iFrame < 1     ? vec4( start, 0 )  // Setup initial conditions.\n                         : vec4( next , 0 )  // Save current position.\n        : u == vec2(1,y) ? vec4( Min , 0 )   // pixel (1-2,y) saves the segment bbox \n                         : vec4( Max , 0 );\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n                                      // --- graphics settings\n#define MODE xz                       // choose which 2D projection to draw\n\nint            N = 30;                // number of segments\nfloat VIEW_SCALE = .025,              // scene scaling\n        Y_OFFSET = .6,                // scene offset\n           STEPS = 96.,               // number of iteration per frame\n           SPEED = .05,               // dt = SPEED/60\n       INTENSITY = .2,\n            FADE = .99,\n           FOCUS = 1.,\n\n  O = 10., P = 28., B = 8./3.;        // --- System Parameters\n\nvec4 COL = vec4(.93, .36, .36, 1);\n\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n\n\n//https://en.wikipedia.org/wiki/Lorenz_system\n\nvec3 Integrate(vec3 cur, float dt)    // --- Calculate the next position \n{\n\treturn cur + dt * vec3(    O  * (cur.y - cur.x)       ,\n                            cur.x * (P - cur.z) - cur.y   ,\n                            cur.x *   cur.y     - B*cur.z   );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 382, 382, 629], [632, 632, 670, 670, 1807]]}
{"id": "tsdczr", "name": "Directional Ray", "author": "seung1107", "description": "ray", "tags": ["ray"], "likes": 2, "viewed": 287, "published": 3, "date": "1600336381", "time_retrieved": "2024-07-30T20:44:51.976469", "image_code": "const int Samples = 64; //multiple of 2\nfloat Intensity = 0.2;\n\nvec4 DirectionalBlur(in vec2 UV, in vec2 Direction, in float Intensity, in sampler2D Texture)\n{\n    vec4 Color = vec4(0.0);  \n    \n    for (int i=1; i<=Samples/2; i++)\n    {\n      Color += texture(Texture,UV+float(i)*Intensity/float(Samples/2)*Direction);\n      Color += texture(Texture,UV-float(i)*Intensity/float(Samples/2)*Direction);\n    }\n\n    return Color/float(Samples);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 UV = fragCoord.xy / iResolution.xy;\n    \n    vec2 Direction = vec2(-1.0, 0.0);    \n    \n    vec4 Color = DirectionalBlur(UV,normalize(Direction),Intensity,iChannel0);\n    \n\tfragColor = Color;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 159, 159, 447], [449, 449, 506, 506, 706]]}
{"id": "3sdyzn", "name": "大龙猫 - Quicky#045", "author": "totetmatt", "description": "Remove Warning to have intended effect.\nsuggested music : https://www.youtube.com/watch?v=qnlsQoHrZrM", "tags": ["quicky"], "likes": 6, "viewed": 334, "published": 3, "date": "1600333863", "time_retrieved": "2024-07-30T20:44:52.737434", "image_code": "\n#define EPILEPTIC_TRIGGER_WARNING\n#ifdef EPILEPTIC_TRIGGER_WARNING\n#define speed 1.\n#else\n#define speed 3.\n#endif\n#define bpm (mod(iTime,20.))/60.*142.*speed\n\nmat2 r(float a){\n    float c=cos(a),s = sin(a);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    float zoom = pow(10.,-m.x*3.);\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    \n   \n    vec2 c =    vec2(.285,0.01);\n    \n    uv= abs(uv)-.12;\n     if(uv.x<uv.y) uv.xy=uv.yx;\n    uv= abs(uv)-.32;\n    if(uv.y<uv.x) uv.xy=uv.yx;\n    uv*=r(sin(atan(uv.x,uv.y)*3.+iTime)*.055+pow(floor(bpm),2.));\n    uv*=.0040;\n    uv +=vec2(-0.0147, .3811);\n    \n    float iter = 0.;\n    \n    const float max_iter= 150.;\n    \n    vec2 ma = vec2(100.);\n     vec2 z = uv*2.;\n    for(float i=0.;i<max_iter ; i++){\n        z  = vec2(pow(z.x,2.) - pow(z.y,2.),2.*z.x*z.y)  + c;\n        ma = min(abs(z),ma);\n        if(z.x*z.x + z.y*z.y >4.) break;\n        iter ++;\n    }\n    \n    float d = (max_iter- iter)/max_iter;\n   \n    d =  pow( length(ma) +  d,2.0)  ;\n    \n   \n    vec3 col = vec3(d);\n    float qq = speed == 1.0? 2. : (sin(iTime+fract(bpm))*.5+1.5);\n    col = mix(vec3(-.5),vec3(.9,.0,.0) + cos(iTime)*.5+1.0,col*qq-fract(bpm));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 176, 176, 236], [237, 237, 292, 292, 1310]]}
{"id": "wsdczn", "name": "Electronic dance music", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/Wd3cRr]\"Synth Noise Music.\"[/url]", "tags": ["music", "bytebeat"], "likes": 13, "viewed": 705, "published": 3, "date": "1600316363", "time_retrieved": "2024-07-30T20:44:53.501392", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time);\n    //t = t % 150000;\n    t =\n        (t>>5|t*(-(t/500)%11)&t/1024)-1\n        //(t>>5|t*((t/50)%500)&t/1024)-1\n    ;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    time *= 2000.;\n    for(int i = 0; i < 5; i++){\n        factor *= 2.0;\n    \tresult += sound1(time*factor)/(factor);\n    }\n    return result;\n}\n\n\n/*\nvec2 sound1( float time )\n{\n    int t = int(time * 1000.0);\n    //t = t % 150000;\n    t = (t>>5|t*(-(t/1000)%11)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        factor *= 2.;\n    \tresult = (result + sound1((time+result.x)*factor)/(factor))/3.0;\n    }\n    return result;\n}\n*/", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "Wstczr", "name": "basic-face -v3", "author": "jorge2017a1", "description": "basic-face -v3", "tags": ["basicface"], "likes": 4, "viewed": 271, "published": 3, "date": "1600301785", "time_retrieved": "2024-07-30T20:44:54.551584", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 ) \n\nfloat sdSphere( vec3 p, float s )\n{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB) \n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB) \n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n    float c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------------------------------\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n//------------------------------------------\nfloat funcF(float x)\n{\n    x *= 1.02;\n    float ans = (x - 0.6) * (x - 0.6) + 0.37;\n    ans = smin(ans, 0.5, 0.05);\n    //ans = smin(ans, -(x * 2. - 0.25) * (x * 2. - 0.25)  + 0.51, -0.05);\n    return ans;\n}\n\n\nfloat sdEgg(in vec3 p, in float r, in float h)\n{\n    p= rotate_x(p, radians(180.0));\n    vec3 off = p - vec3(0., -3.0, 0.);\n    float ans = 0.;\n    float angle = 1. - acos(dot(normalize(off), vec3(0, 1, 0))) / 3.1415;\n    return length(off) - 12.0*funcF(angle);\n  \n}\n\nfloat CortePelo(vec3 p,in float r, in float h)\n{\n    float dEgg = sdEgg( p, 0.1, 0.1 );\n\tfloat sb1= sdBox(p-vec3(0.5,7.5,0.0), vec3(5.5,3.0,5.0)); //pelo sup  cabeza\n    float sb2= sdBox(p-vec3(0.5,4.0,3.0), vec3(5.5,5.0,5.0));  //pelo lateral\n    \n    float sUnionb1b2= unionSDF(sb1, sb2); \n    float inters= intersectSDF(dEgg,sUnionb1b2);\n     return inters;\n}   \n\nfloat HacerOjoyCornea(vec3 p,  float pDistCabeza)\n{   \n    float la=0.5;\n    float lb=0.8;\n    float h=2.0;\n    float ra=0.45;\n    float sdc1 = sdCylinderXY(  p -vec3(2.0,3.0,-2.0), vec2(1.,4.5) );\n\tfloat sdc2 = sdCylinderXY(  p-vec3(-2.0,3.0,-2.0), vec2(1.,4.5) );\n    \n    float sdb1 = sdBox(p- vec3(2.0,3.5, 0.0), vec3(1.0,1.0,4.5) );\n    float sdb2 = sdBox(p-vec3(-2.0,3.5, 0.0), vec3(1.0,1.0,4.5) );\n    float inter1 = intersectSDF(sdb1, sdc1);\n\tfloat inter2 = intersectSDF(sdb2, sdc2);\n    float  sU= unionSDF(inter1, inter2); \n    float inters= intersectSDF(pDistCabeza,sU);\n    return inters;\n  \n}   \n\n\nfloat HacerCornea(vec3 p,  float pDistCabeza)\n{    \n    float t=0.45*cos(iTime);\n    float sdcy1= sdCylinderXY(p-vec3(2.0,2.5+t,-2.5), vec2(0.25,2.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-2.0,2.5-t,-2.5), vec2(0.25,2.0) );\n    float  sU= unionSDF(sdcy1, sdcy2); \n    float inters= intersectSDF(pDistCabeza,sU);\n\treturn inters;\n}  \n\n\nfloat BocaSonrisa(vec3 p, float pDistCabeza)\n{\n \t\n    float t=0.35*cos(iTime);\n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.6,-1.0), vec2(2.0,3.0+t) );\n    float sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,-1.0), vec2(1.1+t,3.5+t) );\n    float sdb1= sdBox(p-vec3(0.0,0.8,-1.0), vec3(4.2,3.0,3.6));   \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    float inters= intersectSDF(pDistCabeza,dif);\n    return inters;\n}\n\n\nfloat Nariz(vec3 p,float pDistCabeza )\n{\n   \tvec3 a=vec3(0.0,2.0,-0.25);\n    vec3 b=vec3(0.0,0.0,0.0); \n    float r0=0.01;\n    float r1=0.5;\n    float sdca1= sdCapsule( p-vec3(0.0,0.5,-4.2), a, b, r0, r1 );\n    //float inters= intersectSDF(pDistCabeza,sdca1);\n    \n    return sdca1;\n    \n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\t// p= rotate_y(p-vec3(0.0,0.0,0.0), radians(mangulo));\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   p.y=p.y-5.0;\n    p= rotate_y(p, iTime*0.5);\n   \n    vec3 q=p;\n    float cx=30.0;\n    float cy=30.0;\n    float cz=40.0;\n    \n    q.y = mod(q.y+0.5*cy,cy)-0.5*cy;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\t\n    float dCabeza = sdEgg( p, 0.1, 0.1 );\n\tfloat sOjo= HacerOjoyCornea(p,  dCabeza);\n    float sCornea=HacerCornea(p-vec3(0.0,0.7,0.0), dCabeza);\n    float spelo1= CortePelo(p,0.1, 0.1);\n    float sboca= BocaSonrisa(p-vec3(0.7,2.5,0.0), dCabeza);\n    float snariz=Nariz( p-vec3(0.0,0.5,0.0),dCabeza);\n   \n    \n    res =opU3(res, vec3(dCabeza,9,-1)); \n    res =opU3(res, vec3(sOjo,1,-1)); \n    res =opU3(res, vec3(sCornea,0,-1)); \n    res =opU3(res, vec3(sboca,2,-1)); \n\tres =opU3(res, vec3(snariz,5,-1));     \n    res =opU3(res, vec3(spelo1,15,-1)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color){\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//----------------------------------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i){\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {  return result; }\n   \t\n}\n///-------------------------------------\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n \tlight_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 5.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ){ return vec3(0.0, 0.6, 0.0);}\n       \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 271, 271, 292], [293, 293, 325, 325, 409], [410, 410, 456, 456, 543], [544, 544, 578, 578, 640], [641, 641, 678, 678, 773], [774, 774, 813, 813, 908], [909, 909, 948, 948, 1043], [1044, 1044, 1083, 1083, 1178], [1179, 1223, 1270, 1270, 1297], [1299, 1299, 1343, 1343, 1370], [1372, 1372, 1421, 1421, 1449], [1497, 1522, 1555, 1555, 1650], [1652, 1652, 1685, 1685, 1778], [1780, 1780, 1813, 1813, 1906], [1909, 1909, 1950, 1950, 2043], [2045, 2090, 2167, 2167, 2302], [2303, 2348, 2370, 2370, 2555], [2558, 2558, 2606, 2606, 2824], [2826, 2826, 2874, 2874, 3188], [3193, 3193, 3244, 3244, 3798], [3804, 3804, 3851, 3851, 4135], [4140, 4140, 4186, 4186, 4594], [4597, 4597, 4637, 4637, 4886], [4888, 4928, 4953, 4953, 6025], [6027, 6072, 6138, 6138, 6511], [6512, 6563, 6586, 6586, 6774], [6776, 6839, 6872, 6872, 7314], [7316, 7370, 7407, 7407, 7641], [7643, 7769, 7805, 7805, 8010], [8013, 8084, 8108, 8108, 8363], [8365, 8445, 8493, 8493, 8720], [8721, 8755, 8835, 8835, 9350], [9444, 9444, 9537, 9537, 9784], [9787, 9836, 9893, 9893, 11872]]}
{"id": "3ddyzr", "name": "Empty StrobeLight Cutscene", "author": "celifrog", "description": "Originally some rainbow laser.", "tags": ["light", "fun"], "likes": 1, "viewed": 273, "published": 3, "date": "1600298777", "time_retrieved": "2024-07-30T20:44:55.371392", "image_code": "vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\n{\n    float glow = 0.21 * iResolution.y;\n    float twopi = -1.28318530718;\n    float curve = 5.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\n    float i = clamp(curve, 0.0, 5.0);\n    i += clamp((glow + curve+glow+curve) / glow, 0.0, 1.0) * 5555.4 ;\n    return i * color*color*color*glow*hscale*vscale;\n}\n\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\n{\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\n\tfloat len = iResolution.y * (55510.0 * sin(theta *theta*theta* -1455555520.0*theta*theta + float(int(iTime * 20.0)) * -35.0)) / 11.0;\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\n    return vec3(d * (1.0 + sin(theta * 1101.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timescale = 4.0;\n\tvec3 c = vec3(0, 0, 0);\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 119, 119, 556], [558, 558, 610, 610, 1272], [1274, 1274, 1331, 1331, 2144]]}
{"id": "Wdtyzr", "name": "Basic glitch effect", "author": "luluco250", "description": "Test implementation of a glitch effect.\nClick and drag to change the angle and scale.", "tags": ["2d", "filter", "glitch", "smudge"], "likes": 11, "viewed": 1936, "published": 3, "date": "1600295118", "time_retrieved": "2024-07-30T20:44:56.271984", "image_code": "/*\n\nConfiguration can be found in the Common tab.\n\n(Un)license:\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n\n*/\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = texture(iChannel0, uv);\n    \n    vec2 dir = Direction;\n    \n    if (iMouse.z > 0.0)\n        dir = (0.5 - iMouse.xy * ps) * 2.0;\n    \n    vec4 glitch = SmudgeBlur(iChannel1, uv, dir * ps * Scale, Samples);\n    color = max(color, glitch);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec2 Direction = vec2(0.0, 1.0);\nconst int Samples = 75;\nconst float Scale = 1.0;\nconst float Threshold = 0.775;\nconst vec3 ChromaKey = vec3(0.051, 0.639, 0.145);\nconst float ChromaKeyThreshold = 0.2;\n\nvec4 SmudgeBlur(sampler2D sp, vec2 uv, vec2 dir, const int samples)\n{\n    if (samples < 1)\n        return vec4(0);\n    \n    if (samples == 1)\n        return texture(sp, uv);\n    \n    // If centering is desired...\n    //uv -= dir * float(samples) * 0.5;\n    \n    vec4 color = texture(sp, uv);\n    float scale = color.a;\n    \n    for (int i = 1; i < samples; ++i)\n    {\n        color = max(color, texture(sp, uv));\n        uv += dir * scale;\n    }\n    \n    //color /= float(samples);\n    \n    return color;\n}", "buffer_a_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    color = texture(iChannel0, coord / iResolution.xy);\n    \n    float key = distance(color.rgb, ChromaKey);\n    key = smoothstep(ChromaKeyThreshold, 1.0 - ChromaKeyThreshold, key);\n    key = clamp(key, 0.0, 1.0);\n    \n    color *= key;\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float GetNoise(vec2 coord);\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = texture(iChannel0, uv);\n    color.rgb *= GetNoise(coord);\n    color.a = 1.0 - max(color.r, max(color.g, color.b));\n}\n\nfloat GetNoise(vec2 coord)\n{\n    vec2 uv = coord / 256.0;\n        \n    vec3 color = texture(iChannel1, uv).rgb;\n    float noise = 1.0 - max(color.r, max(color.g, color.b));\n    \n    noise = step(Threshold, noise);\n    \n    return noise;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdtyzr.jpg", "access": "api", "license": "unlicense", "functions": [[1281, 1281, 1325, 1325, 1643]]}
{"id": "3dtyzr", "name": "FRB Header_prototype_only", "author": "franklinz622", "description": "FRB", "tags": ["gradient"], "likes": 0, "viewed": 271, "published": 3, "date": "1600295038", "time_retrieved": "2024-07-30T20:44:57.034944", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nvec2 map( vec2 p, in float offset )\n{\n\tp.x += 0.1*sin( iTime*0.01 + 2.0*p.y ) ;\n\tp.y += 0.1*sin( iTime*0.01 + 2.0*p.x ) ;\n\t\n\tfloat a = noise(p*1.5 + sin(0.01*iTime))*6.2831;\n\ta -= offset;\n\treturn vec2( cos(a), sin(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = -1.0 + 1.0*p;\n    uv.x += 2.2;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\t\n    float offset = iTime*0.01 + fragCoord.x/iResolution.x;\n    \n\tfloat acc = 0.0;\n\tvec3  col = vec3(0.0);\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tvec2 dir = map( uv, offset );\n\t\t\n\t\tfloat h = float(i)/32.0;\n\t\tfloat w = 4.0*h*(1.0-h);\n\t\t\n\t\tvec3 ttt = w*texture( iChannel0, uv ).xyz;\n\t\tttt *= mix( vec3(0.6,0.7,0.7), vec3(1.0,0.95,0.9), 0.5 - 0.5*dot( reflect(vec3(dir,0.0), vec3(1.0,0.0,0.0)).xy, vec2(0.707) ) );\n\t\tcol += w*ttt;\n\t\tacc += w;\n\t\t\n\t\tuv += 0.008*dir;\n\t}\n\tcol /= acc;\n    \n\tfloat gg = dot( col, vec3(0.333) );\n\tvec3 nor = normalize( vec3( dFdx(gg), 0.5, dFdy(gg) ) );\n\tcol += vec3(0.4)*dot( nor, vec3(0.7,0.01,0.7) );\n\n\tvec2 di = map( uv, offset );\n\tcol *= 0.65 + 0.35*dot( di, vec2(0.707) );\n\tcol *= 0.20 + 0.80*pow( 4.0*p.x*(1.0-p.x), 0.1 );\n\tcol *= 1.7;\n\n\tfragColor = vec4( col*vec3(0.012, 0.2, 0.15)+0.35*vec3(0.012, 0.199, 0.15), 1.0 );\n    \n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 62], [64, 64, 90, 90, 308], [310, 310, 347, 347, 531], [533, 533, 590, 590, 1570]]}
{"id": "3dtcRr", "name": "lorenz11 - Fabrice3", "author": "FabriceNeyret2", "description": "Lorenz attractor.\nmulti-trajectory variant of [url]https://shadertoy.com/view/3ddyRr[/url]\nR,G,B rectangle = area where 96 steps attractor simulation + 96 lines drawing are calculated.\n", "tags": ["math", "attractor", "lorenz"], "likes": 17, "viewed": 533, "published": 3, "date": "1600291136", "time_retrieved": "2024-07-30T20:44:57.860736", "image_code": "// multi-trajectory variant of https://shadertoy.com/view/3ddyRr\n// optimization of https://shadertoy.com/view/Wscyzr\n// simplification + comments of \"lorenz11\" by mrtkp9993. https://shadertoy.com/view/3tBfWd\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n\tO = T(u);\n    \n    for (int y = 0; y < N; y++) { // for demo, draw color rectangle for calulating aread\n      vec2 R = iResolution.xy, \n         Min = T(vec2(2,y)).xy,\n         Max = T(vec2(2,y)).zw,\n           U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n      U /= VIEW_SCALE;\n    \n      if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) O[y]++; \n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//https://en.wikipedia.org/wiki/Lorenz_system\n\n                                      // --- graphics settings\n#define MODE xz                       // choose which 2D projection to draw\n\nfloat STEPS = 96.,                    // number of iteration per frame\n      SPEED = .05,                    // dt = SPEED/60\n  INTENSITY = .2,\n       FADE = .99,\n      FOCUS = 1.,\n     O = 10., P = 28., B = 8./3.;     // --- System Parameters\n\nvec4 COL[] = vec4[]( vec4(.93, .36, .36, 1),\n                     vec4(.36, .93, .36, 1),\n                     vec4(.36, .36, .93, 1) );\n\nvec3 Integrate(vec3 cur, float dt)    // --- Calculate the next position \n{\n\treturn cur + dt * vec3(    O  * (cur.y - cur.x)       ,\n                            cur.x * (P - cur.z) - cur.y   ,\n                            cur.x *   cur.y     - B*cur.z   );\n}\n\nfloat Line(vec2 a, vec2 b, vec2 U)    // --- Distance to a line segment https://www.shadertoy.com/view/llySRh\n{   \n    U -= a, b -= a;\n\tfloat h = dot( U, b ) / dot(b,b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length( U - b * c ) : 1e5;   // dist to strict segment\n  //return        length( U - b * c );         // dist to segment with round ends\n}\n\nvoid mainImage( out vec4 O, vec2 u ) // === simulate particles and cumulate-draw images\n{    \n    vec2 R = iResolution.xy, Min,Max,\n         U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n    U /= VIEW_SCALE;\n    float pix = 1. / R.y / VIEW_SCALE;\n    u = floor(u);\n\n    O = vec4(0);\n    vec3 last, next;\n    \n    int y = int(u.y);\n    if (y<N && u.x<3. ) {          // --- simulation zone. particle #y in line y\n       vec3 start = vec3( .1, .001, 0 )+vec3(y,-y,y);     // Initial Position\n       next = last = T(vec2(0,y)).xyz,              // pixel (0,y) saves the current position.\n       Max = Min = last.MODE;\n        for(float i = 0.; i < STEPS; i++ )    // simulates for 1 frame range\n    \t    next = Integrate( next, .016 * SPEED ),\n            Min  = min(Min, next.MODE),\n            Max  = max(Max, next.MODE);\n        \n        O =   u == vec2(0,y)                  // pixel (0,y) saves the current position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( next , 0 )          // Save current position.\n            : u == vec2(1,y)                  // pixel (1,y) saves the previous position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( last , 0 )   // pixel (2,y) saves the segment bbox     \n            :  /* (2,0) */ vec4( Min-pix , Max+pix );\n    } else {                           // --- drawing zone\n      for (int y = 0; y < N; y++) {\n        Min = T(vec2(2,y)).xy,\n        Max = T(vec2(2,y)).zw;\n        float c = 0.;\n        if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) {\n\n            last = T(vec2(1,y)).xyz;          // pixel (1,y) saves the previous position.\n            float d = 1e6;\n\n            for(float i = 0.; i < STEPS; i++ )// simulates & draws for 1 frame range\n                next = Integrate( last, .016 * SPEED ),\n                d = min(d, Line(last.MODE , next.MODE, U) ),        \n                last = next;\n                   \n            d *=  VIEW_SCALE;\n            c  =  INTENSITY / SPEED * smoothstep( FOCUS / R.y, 0., d )\n                + INTENSITY / 8.5   * exp(- 1e3 * d*d );\n        }\n        O +=  c*COL[y];    // accumulates draw...\n      }\n      O   +=  T(u) * FADE; // ... fading over time. \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat VIEW_SCALE = .025,     // scene scaling\n        Y_OFFSET = .6;       // scene offset\nint            N = 3;        // number of trajectories\n\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 249, 249, 611]]}
{"id": "3ddyRr", "name": "lorenz11 - Fabrice2", "author": "FabriceNeyret2", "description": "Lorenz attractor.\noptimization + simplification + comments of mrtkp9993's [url]https://shadertoy.com/view/3tBfWd[/url]\nBlue = area where 96 steps attractor simulation + 96 lines drawing are calculated.\n", "tags": ["math", "attractor", "lorenz"], "likes": 13, "viewed": 401, "published": 3, "date": "1600289640", "time_retrieved": "2024-07-30T20:44:59.104411", "image_code": "// optimization of https://shadertoy.com/view/Wscyzr\n// simplification + comments of \"lorenz11\" by mrtkp9993. https://shadertoy.com/view/3tBfWd\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n     vec2 R = iResolution.xy, \n        Min = T(vec2(2,0)).xy,\n        Max = T(vec2(2,0)).zw,\n          U = ( u - .5*R ) / R.y; U.y += .375;\n    U /= VIEW_SCALE;\n    \n\tO = vec4(.93, .36, .36, 1) * T(u).x; // attention, T(U) goes up to 5 and more\n    \n    if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) O.b++; // for demo\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//https://en.wikipedia.org/wiki/Lorenz_system\n\n#define MODE xz                       // choose which 2D projection to draw\n\nfloat STEPS = 96.,                    // graphics settings\n      SPEED = .05,\n  INTENSITY = .2,\n       FADE = .99,\n      FOCUS = 1.,\n     O = 10., P = 28., B = 8./3.;     // System Parameters\n\nvec3 start = vec3( .1, .001, 0 );     // Initial Position\n\nvec3 Integrate(vec3 cur, float dt)    // Calculate the next position \n{\n\treturn cur + dt * vec3(    O  * (cur.y - cur.x)       ,\n                            cur.x * (P - cur.z) - cur.y   ,\n                            cur.x *   cur.y     - B*cur.z   );\n}\n\nfloat Line(vec2 a, vec2 b, vec2 U)    // Distance to a line segment https://www.shadertoy.com/view/llySRh\n{   \n    U -= a, b -= a;\n\tfloat h = dot( U, b ) / dot(b,b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length( U - b * c ) : 1e5;   // dist to strict segment\n  //return        length( U - b * c );         // dist to segment with round ends\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n    vec2 R = iResolution.xy, Min,Max,\n         U = ( u - .5*R ) / R.y; U.y += .375;\n    U /= VIEW_SCALE;\n    float pix = 1. / R.y / VIEW_SCALE;\n    u = floor(u);\n    \n    vec3 last = T(0).xyz,              // pixel (0,0) saves the current position.\n         next = last;\n    \n    if (u.y==0. && u.x<3. ) {          // --- simulation zone\n        Max = Min = last.MODE;\n        for(float i = 0.; i < STEPS; i++ )\n    \t    next = Integrate( next, .016 * SPEED ),\n            Min  = min(Min, next.MODE),\n            Max  = max(Max, next.MODE);\n        \n        O =   u == vec2(0,0)                  // pixel (0,0) saves the current position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( next , 0 )          // Save current position.\n            : u == vec2(1,0)                  // pixel (1,0) saves the previous position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( last , 0 )   // pixel (2,0) saves the segment bbox     \n            :  /* (2,0) */ vec4( Min-pix , Max+pix );\n    } else {                           // --- drawing zone\n        Min = T(vec2(2,0)).xy,\n        Max = T(vec2(2,0)).zw;\n        float c = 0.;\n        if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) {\n\n            last = T(vec2(1,0)).xyz;   // pixel (0,0) saves the previous position.\n            float d = 1e6;\n\n            for(float i = 0.; i < STEPS; i++ )\n                next = Integrate( last, .016 * SPEED ),\n                d = min(d, Line(last.MODE , next.MODE, U) ),        \n                last = next;\n                   \n            d *=  VIEW_SCALE;\n            c  =  INTENSITY / SPEED * smoothstep( FOCUS / R.y, 0., d )\n                + INTENSITY / 8.5   * exp(- 1e3 * d*d );\n        }\n        O =  vec4( c +  T(u) * FADE ); // accumulates draw fading over time.\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\nfloat VIEW_SCALE = .015;\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 184, 184, 517]]}
{"id": "3dtczn", "name": "Flight through a spiral", "author": "illus0r", "description": "Flight through a spiral\n", "tags": ["raymarching"], "likes": 11, "viewed": 387, "published": 3, "date": "1600281629", "time_retrieved": "2024-07-30T20:44:59.967104", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 99\n#define MAX_DIST 20.\n#define EPSILON 0.001\n#define PI 3.1415\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define n getNormal(p)\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define tChank 4.28125\n\nmat2 Rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat Rnd (float x) {return 2.*fract(10000. * sin(10000. * x))-1.;}\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdTorus( vec3 p, vec2 t ){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\n\nfloat sdWater(vec3 p) {\n    float t = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+t);\n    p.y += .001*sin(p.z*13.+t);\n    p.y += .001*sin(p.x*11.+t*.5);\n    return p.y;\n}\n\nfloat sdMirrors(vec3 p) {\n    float c = 1.1;\n    p.xy *= Rot(PI/4.);\n    p.xz *= Rot(.1*iTime);\n    vec3 l = vec3(2,0,2), id = round(p/c);\n    p = p-c*clamp(id,-l,l);\n    p.xz *= Rot(p.y*(Rnd(id.x)+1.) + 30.*iTime * (Rnd(id.x + 10. * id.z)+1.5));\n    // p.xz *= atan(p.x, p.z);\n    return sdBox(p, vec3(.1,10.,.001));\n}\n\nfloat sdRocket (vec3 p){\n    // p.y /= 2.;\n    // p.xz *= Rot(iTime);\n    p.xy *= Rot(PI/4.);\n    float sph=length(p) - 1.;\n    for(float i=2.;i<5.;i+=0.5){\n        // float shift = 4.*sin(iTime*i);\n        // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n        float shift = tan(iTime*(1.2+.4*Rnd(i))+Rnd(i))*10.;\n        float spread = 4.;\n        sph=opSmoothUnion(sph, (length(p*i+vec3(spread*Rnd(i),shift,spread*Rnd(i+1.))) - 1.)/i, .4);\n    }\n    return sph;    \n}\n\nfloat sdBeam(vec3 p){\n    p.xy *= Rot(PI/4.);\n    float size = 3.*Rnd(iTime)*.5+.5;\n    vec3 shift = 2.4*(vec3(Rnd(iTime+9.), 0, Rnd(iTime+99.))*.5);\n    return sdBox(p+shift, vec3(.2*size,100.,.2*size));\n}\n\nfloat timeCurve(float t) {\n    t = t * 4. / tChank;\n    // t = t / 1000.;\n    float whole = floor(t);\n    float decimal = fract(t);\n    t =  (whole + 1. - pow(1. - decimal, 32.));\n    return t;\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    // float t = timeCurve(iTime);\n    // for(float j;++j<6.;){\n    //     p=abs(p)-1.1;\n    //     p=abs(p)-1.1;\n    //     p.xz*=Rot(t / 5.91 + j);\n    //     p.xy*=Rot(t / 3.21 + j);\n    // }\n    // p.y+=1.;\n    // float wave = 0.;//pow(sin(length(p + fract((iTime+.2) * 4. / tChank)))*.5+.5, 64.)*.2;\n    // p.y *= .99;\n    // p.x = cos(p.z);\n    // p.y = sin(p.z);\n\n    // p.z = cos(p.z * 1. + iTime * 10.);\n    // p.zy*=Rot(PI / 2.);\n    // vec2 obj = vec2(sdTorus(p, vec2(3.3, 0.)), WHITE_MIRROR);\n    // p.x -= 1.;\n    p.z += iTime * 10.1;\n    float w = p.z * 1.5 + iTime * 1.;\n    p.x += .6*cos(w);\n    p.y += .6*sin(w);\n    // p.y*=Rot(PI / 2.);\n    p.xy*=Rot(p.z * 1.1 + iTime);\n    p.x += 1.4;\n    vec2 obj = vec2(length(p.xy) * .3, WHITE_MIRROR);\n\n    return obj;\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dTotal=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color, p, rm;\n    float camDist = -10.;// + 5.*sin(timeCurve(iTime));//-17.+12.*smoothstep(2., 2.3, fract(iTime/5.)*5.);\n    ro = vec3(0,0,camDist);\n    // ro.xz *= Rot(timeCurve(iTime));\n    // ro.xy *= Rot(PI/4.);\n    // ro += 1.1*sin(iTime*4.)*vec3(Rnd(iTime),Rnd(iTime+100.),0); // shake\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    color = vec3(0);\n    float colorAmount = 0.;\n\n    // for(int reflectionDepth = 0; reflectionDepth < 2; reflectionDepth++) {\n    //     rm = rayMarch(ro, rd);\n    //     dTotal += d = rm[0];\n    //     info = rm[1];\n    //     p = ro + rd * d;\n    //     if (d < MAX_DIST) {\n    //         // color = vec3(1);//textureCube(iChannel0, rd).rgb;\n    //         if (info == MIRROR) {\n    //             rd = reflect(rd, n);\n    //             ro = p + 0.01 * rd;\n    //             continue;\n    //             // do nothing, propogate color getting to the reflection\n    //         }\n    //         else if (info == WHITE_MIRROR) {\n    //             vec3 nn = n;\n    //             nn.xy*=Rot(1.);\n    //             // color = vec3(1) * (dot(nn, vec3(1,1,-1))*.3+.7);\n    //             color = nn*.5+.5;\n    //         }\n    //         else if (info == PUREWHITE) {\n    //             color += vec3(1) * (1. - colorAmount);\n    //             colorAmount = 1.;\n    //         }\n    //     }\n    //     else {\n    //         // color += textureCube(iChannel0, vec3(rd.y, rd.xz*Rot(iTime)).yxz).rgb * (1. - colorAmount);\n    //         // colorAmount = 1.;\n    //     }\n    //     break;\n    // }\n    // // color = mix(color, vec3(0,uv.yx+.5)*.2, smoothstep(20., 100., dTotal));\n    // color = mix(color, rd*.2, smoothstep(20., 100., dTotal));\n    // fragColor = vec4(color, 1);\n \n    rm = rayMarch(ro, rd);\n    fragColor = vec4(vec3(.003/rm.z), 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 367, 367, 425], [426, 426, 457, 457, 540], [541, 541, 579, 579, 829], [830, 830, 851, 851, 897], [898, 898, 950, 950, 1041], [1042, 1042, 1074, 1074, 1134], [1136, 1136, 1159, 1159, 1304], [1306, 1306, 1331, 1331, 1625], [1627, 1627, 1651, 1696, 2121], [2123, 2123, 2144, 2144, 2329], [2331, 2331, 2357, 2357, 2526], [2529, 2608, 2630, 3153, 3409], [3498, 3498, 3531, 3531, 3985], [3987, 3987, 4011, 4011, 4231], [4233, 4233, 4287, 4287, 4514], [4516, 4516, 4566, 4566, 4757], [4862, 4862, 4918, 4918, 6811]]}
{"id": "WdSyzR", "name": "Apple-noise", "author": "Subash", "description": "noise\n", "tags": ["noise"], "likes": 1, "viewed": 331, "published": 3, "date": "1600265656", "time_retrieved": "2024-07-30T20:45:01.369355", "image_code": "float hash(float n){\n\treturn fract(sin(n) * 1758.5453);   \n}\n\nfloat noise(vec3 x){\n    \n    vec3 p = floor(x);\n    vec3 k = fract(x);\n    k = k * k * (3. - 2. * k);\n    \n    float n = p.x + p.y*57.0 + p.z * 113.0;\n    \n    float a = hash(n);\n    float b = hash(n + 1.);\n    float c = hash(n + 57.);\n    float d = hash(n + 58.);\n    \n    float e = hash(n + 113.);\n    float f = hash(n + 1114.);\n    float g = hash(n + 170.);\n    float h = hash(n + 171.);\n\n    \n    float res = mix( mix(mix(a, b, k.x), mix(c, d, k.x), k.y), mix(mix(e, f, k.x), mix(g, h, k.x), k.y), k.z);\n    \n    return res;\n}\n\nfloat smoothNoise(vec3 p){\n\tfloat f = 0.;\n    f += 0.5 * noise(p);\n    p *= 2.02;\n    f += 0.5 * noise(p);\n\tp *= 2.03;\n    f += 0.5 * noise(p);\n\tp*=2.01;\n    f += 0.5 * noise(p);\n\treturn f/0.9375;\n}\nvec3 fruitMaterial(vec3 p){\n    float f = smoothstep(0.2, 1., smoothNoise(p) * .35);\n    vec3 col = vec3(1., 0., 0.);\n    col = mix(col, vec3(.8, 1., .2), f);\n    \n    f = smoothstep(0., 1., smoothNoise(p * 4.));\n    col *= 0.8 + 0.2 * f;\n    \n    f = smoothstep(.3, .9, smoothNoise(p * 25.));\n    col = mix(col, vec3(.9, .9, .6), 1. - f);\n    \n\treturn col;\n\t \n}\n\nvec3 floorMaterial(vec3 p){\n    vec3 col = vec3(.6, .5, .3);\n    float f = smoothNoise(p * vec3(6., 0., 0.5));\n    col = mix(col, vec3(.3, 0.2, .1), f);\n\treturn col;   \n}\n\nfloat Sphere(vec3 p){\n    float f = pow(dot(p.xz, p.xz), .1);\n    p.y -= 0.85*f;\n\treturn length(p - vec3(0., .2, .2)) - 1.;   \n}\n\nfloat Plane(vec3 p){\n\treturn p.y + 1.;   \n}\nfloat getDist(vec3 p){\n\tfloat dS = Sphere(p);\n    float dP = Plane(p);\n    return min(dP, dS);\n}\n\nfloat Shadow(vec3 p, vec3 lightDir){\n\tfloat res = 0.;\n    float shadow = 1.;\n    float d = .1;\n    for(int i = 0; i < 50; i++){\n   \t\tfloat dS = getDist(p+d*lightDir);\n        d += dS;\n        if(dS < 0.001) return 0.;\n        shadow = min(shadow, dS / d * 15.);\n    }\n    return shadow;\n}\n\nvec3 Normal(vec3 p){\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(getDist(p + e.xyy) - getDist(p - e.xyy),getDist(p + e.yxy) - getDist(p - e.yxy),getDist(p + e.yyx) - getDist(p - e.yyx)));\n}\n\n\nfloat backLight(vec3 p, vec3 lightPos){\n\tvec3 norm = Normal(p);\n    vec3 lightDir = normalize(lightPos - p);\n    return (max(0., 0.2 + 0.8 * dot(norm, lightDir)));\n}\n\nvec3 Light(vec3 p, vec3 lightPos){\n    vec3 norm = Normal(p);\n    vec3 lightDir = normalize(lightPos - p);\n    float shad = Shadow(p, lightDir);\n    float con = 1.;\n    vec3 light = max(0., dot(norm, lightDir)) * vec3(1., 0.97, 0.85) * shad;\n    light += con * vec3(0.1, 0.15, 0.2);\n    light += backLight(p, vec3(-lightDir.x, lightDir.y, -lightDir.z)) * vec3(0.95, 0.92, 0.95);\n    return light;\n}\n\n\nfloat rayMarch(vec3 r0, vec3 rd){\n\tfloat d0 = 0.;\n    for(int i = 0; i < 100; i++){\n     \tvec3 p = r0 + d0 * rd;\n        float dS = getDist(p);\n        d0 += dS;\n        if(dS < 0.001 || d0 > 100.) break;\n    }\n    return d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 r0 = vec3(0., 2.6, .8);\n    vec3 target = vec3(0.);\n    vec3 ww = normalize(target - r0);\n    vec3 uu = normalize(cross(vec3(0., 1., 0.), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    float zoom = 1.;\n    vec3 rd = uu * uv.x + vv * uv.y + ww * zoom;\n    float d0 = rayMarch(r0, rd);\n    vec3 col = vec3(.8);\n    \n    if(d0 < 6.){\n    vec3 lightPos = vec3(0, 3., .9);\n    vec3 p = r0 + d0 * rd;\n    vec3 light = Light(p, lightPos);\n    vec3 ref = normalize(reflect(rd, Normal(p)));\n    float spe = pow(clamp(dot(normalize(lightPos - p), ref), 0., 1.), 16.);\n    col = vec3(light);\n        \n        if(d0 < 1.40) {\n            col *= fruitMaterial(p);\n             col += vec3(spe);\n        }\n        else {\n            col *= floorMaterial(p);\n           \n        }\n        \n    col = sqrt(col);\n    //col *= .6; \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 60], [62, 62, 82, 82, 593], [595, 595, 621, 621, 793], [794, 794, 821, 821, 1156], [1158, 1158, 1185, 1185, 1328], [1330, 1330, 1351, 1351, 1458], [1460, 1460, 1480, 1480, 1503], [1504, 1504, 1526, 1526, 1600], [1602, 1602, 1638, 1638, 1890], [1892, 1892, 1912, 1912, 2093], [2096, 2096, 2135, 2135, 2261], [2263, 2263, 2297, 2297, 2661], [2664, 2664, 2697, 2697, 2891], [2893, 2893, 2950, 2950, 3924]]}
{"id": "3l2fDt", "name": "Transparent Truchet", "author": "Shane", "description": "Demonstrating simple refraction via a basic animated Transparent Truchet scene.", "tags": ["reflection", "refraction", "truchet", "extrude"], "likes": 79, "viewed": 1147, "published": 3, "date": "1600265636", "time_retrieved": "2024-07-30T20:45:02.486369", "image_code": "/*\n\n\tTransparent Truchet\n\t-------------------\n\n\tThis is a basic refractive example. The scene isn't particularly exciting,\n\tbut the refractive element adds a little extra flavor... Not much, but a\n\tlittle. :) \n\n\tA few years ago, GPUs didn't enjoy branching, and seemed to hate nesting. \n    Even now, I try not to nest things too much. Anyway, for whatever reason,\n    these are not as big an issue as they once were, so we can at least put\n\ttogether simple scenes with multiple bounces.\n\n    By the way, in case it needs to be said, a real refractive\\reflective example \n    would require a stack to handle simultaneous reflective and refractive passes, \n    whereas this takes a lesser approach. By that, I mean this will attempt to \n    refract the surface normal of a refractive surface, then continue without \n    reflecting, and only reflect in the invent that it's not possible. The results \n    are good enough for simple examples like this, but definitely not production\n\tgrade.\n\n\tIf this were a path tracing example, I'd put a lot more effort into the\n\tcorrectness of the coloring. However, it's not, since I've basically thrown\n\tstuff in that I felt suited the situation, so don't pay too much attention\n\tto it. Having said that, I was going for a kind of smokey glass casing look, \n    and it's close enough, so it'll do. :) The refractive based logic is from \n    memory... Visually, things seem about right, but if you spot any mistakes, \n    feel free to let me know.\n\n\tFor anyone interested, the background is a custom version of the box divide \n    formula, which is related to KD trees. The coloring is provided via IQ's \n    versatile cosine palette formula.\n    \n\n    \n    Other examples:\n\n\t// An old favorite. Simple and pretty.\n    Spout - P_Malin\n\thttps://www.shadertoy.com/view/lsXGzH\n\n    // If you're trying to implement a basic multipass refraction and reflection \n    // example, I'd recommend this one. There are subtle differences, but I'm\n    // using similar logic. I adopted some of the naming conventions as well.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n\n \n*/\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 5\n\n// Global block scale.\n#define GSCALE vec2(1./3.)\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Based on the UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input. Also, \n// in theory, you could tweak the figures by hand to get a really scrambled output... \n// When I'm feeling less lazy, I might do that.\n//\n// By the way, GPU's are fickle things, so if this isn't working on your\n// system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    //p -= floor(p/128.)*128. + vec2(64.340627, 72.465623);\n    //return fract(dot(p.xyx*p.xyy, vec3(20.390625, 60.703123, 2.4281207)));\n    \n    p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n \n}\n\n/*\n// My own experimental hash \n// Seems to work for the right range, but I don't trust it yet.\n\nfloat hash21(vec2 p){\n    \n    p = fract(p*2.0143)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    //p.x = dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217));\n    //return p.x - floor(p.x);\n}\n\n// Another, based on the \"17*17 = 289\" thing.\nfloat hash21(vec2 p) {\n    float x = dot(p, vec2(97, 37));\n    x *= 288./289.;                \n    x = (x - floor(x))*289.;                         \n    x = (x*34. + 113.)*x/289.;                       \n    return x - floor(x);                            \n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n// The scene. All of it is pretty standard. There's a wall, extruded\n// hollowed out Truchet tubing and some metallic elements. To be honest, \n// this was a little rushed, but the field doesn't have a lot going on, \n// so tightening it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;\n     \n    // Truchet object and animated metallic balls: This is just a\n    // standard 2D animated Truchet with an extruded factor. If you're\n    // not sure how it works, myself and others have plenty of \n    // animated Truchet examples on Shadertoy to refer to.\n    //\n    // Grid construction: Cell ID and local cell coordinates.\n    const vec2 sc = 1./GSCALE, hsc = .5/sc;    \n    vec2 iq = floor(p.xy*sc) + .5;    \n    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;\n    \n    // Flip random cells. This effectively rotates random cells,\n    // but in a cheaper way.\n    float rnd = hash21(iq + .37);\n    if(rnd<.5) q.y = -q.y;\n      \n    // Circles on opposite square vertices.\n    vec2 d2 = vec2(length(q - hsc), length(q + hsc));\n    // Using the above to obtain the closest arc.\n    float crv = abs( min(d2.x, d2.y) - hsc.x);\n    \n    // Flipping the direction on alternate squares so that the animation\n    // flows in the right directions -- It's a standard move that I've\n    // explained in other examples.  \n    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;\n    // Using repeat polar coordinates to create the moving metallic balls.\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot2(iTime*dir); // Animation occurs here.\n    float a = -atan(pp.y, pp.x); // Polar angle.\n    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.\n    // Polar coordinate.\n    vec2 qr = rot2(-a*6.2831853)*pp; \n    qr.x -= hsc.x;\n     \n    // Ridges, for testing purposes.\n    //crv += clamp(cos(a*16. + dir*iTime*3.)*2., 0., 1.)*.003;\n    \n    // A rounded square Truchet tube. Look up the torus formula, if you're\n    // not sure about this. However, essentially, you place the rounded curve\n    // bit in one vector position and the Z depth in the other, etc. Trust me,\n    // it's not hard. :)\n    //float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .035;\n    float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .01), vec2(.035, .035), .01);\n    \n    // 3D ball position.\n    vec3 bq = vec3(qr,  p.z + .05/2. + .01);\n    //float ball = max(length(bq.zx) - .05, abs(bq.y) - .06);\n    float ball = length(bq) - .015; // Ball.\n    ball = min(tr + .03, ball); // Adding in the railing.\n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway.\n    tr = max(tr, -(tr + .01));\n \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along.\n    q = abs(abs(q) - .5/sc);\n    float mtl = min(q.x, q.y) - .01;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Adding the balls. I should probably give them their own ID, but this \n    // involves less work, and I'm always up for that. :D\n    mtl = min(mtl, ball);\n    \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, 1e5);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), mtl);\n \n}\n\n \n// Basic raymarcher, but with an added distance factor that is\n// required when refracting through the inside of an object.\nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n \n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t)*distanceFactor;\n   \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        //if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        if((d<0. && abs(d)<DELTA) || t>FAR) break; \n       \n        t += d*.9; \n        //t += max(d, DELTA); // For cheap on pass refraction... Not used here.\n         \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n \n\n\n\n// Custom box divide formula: I wrote this from scratch, and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to take a space and position preserving approach, which should make\n// it much easier to work with. The routines I've come across don't do that. :)\n//\n// The idea is simple, in theory, and the solution was simple, but as usual, I had\n// to make way too many mistakes to get there. Basically, you start in one of the\n// corners of the grid square, produce a random number, then split space vertically \n// or horizontally, according to the random factor. For instance, if the random number\n// is \".6,\" then split the space in a 60% to 40% ratio, update postions (depending\n// which side of the line you're on), reduce the space dimensions accordingly, etc.\n//\n// Simple, right? It should have been. :D Anyway, it's done now, so feel free to\n// use it for whatever you want.\n//\nvec4 boxDivide(in vec2 p){\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const float sc = 1.;\n    p *= sc;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n    \n    // Vertical offset. \n    #define VERT_OFFSET\n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 8;\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.35 + (1. - .35)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        \n        // Minimum width... Thrown in at the last minute to enforce a\n        // minimum box size. There are probably better ways, but it works\n        // well enough.\n        const float mW = .125;\n        if(l.x<mW && l.y<mW) break;\n        if(l.x<mW && r2>.5) { r2 = 0.; }// r = .5;\n        if(l.y<mW && r2<=.5) { r2 = 1.; }\n        \n        //if(hash21(ip + 113.523 + l.yx + float(i)/float(iNum))<.3) continue;\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n        }\n        \n        // There are many ways to vary the line width.\n        #ifdef VARIABLE_LINE_WIDTH\n        l *= 1. - r*.03;\n        //l *= 1. - length(l)*.02;\n        //l *= .986;\n        #endif\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimenting, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBoxS(p - s - l/2., l/2., .05*sqrt(rf));// + .001*sc;\n    \n   \n    \n    // Smoothing factor.\n    float sf = 1./450.*sc;//1./iResolution.y*sc;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n   \n    // Random colors using IQ's cosine palette.\n    float rnd = hash21(id/sc);\n    vec3 pCol = .5 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n    pCol = mix(pCol, pCol.xzy, .2);//vec3(.2 + rnd*.4);//\n    \n    \n    // Another random colored version.\n    //pCol = vec3(1, hash21(id), hash21(id*57. + .5)*.8);\n    //pCol = mix(pCol, pCol.xzy, .35);//vec3(.2 + rnd*.4);\n    \n     // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    //vec3 tx = texture(iChannel0, id/sc + .5).xyz; tx *= tx;\n    //vec3 pCol = smoothstep(0., .5, tx);\n    \n    \n   \n    // Rectangular cell border and coloring.\n    vec3 col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol, 1. - smoothstep(0., sf, d + .003*sc)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    \n    // Center, space preserving dots.\n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .004/sc;\n    // Splitting space to produce four rivot-looking dots.\n    p = abs(p - s - l/2.) - l/2. + .015;\n    float d2 = length(p) - .004/sc;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n    // Very subtle bump element for some highlighting.\n    sf *= 2.;\n    d += .002*sc;\n    float b = mix(.05, 0., 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    b = mix(b, .5, 1. - smoothstep(0., sf, d + .003*sc)); \n    //b = mix(b, 0., 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    b = mix(b, 0., 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n      \n    // Return the color and the bump value.\n    return vec4(col, b);\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/8., 0, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.03, -.02, .25); \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1., 0); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the Truchet tubing. Normally, you'd have\n    // diferent ones for different object, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object.\n        float svObjID = vObjID.x<vObjID.y && vObjID.x<vObjID.z? 0. : vObjID.y<vObjID.z? 1. : 2.;\n \n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n        //if((d<0. && abs(d)<delta) && t<FAR){\n\n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel0, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            //if(j < 2) \n                gSh = softShadow(sp, lp, sn, 12.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .3 + ao*.3, 1.); // Adding a touch of light to the shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            \n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n             \n           if(svObjID == 0.){ // Back wall.\n               \n               // Texturing... but I decided against it. \n               //vec3 tx = tex3D(iChannel1, (sp*1.), sn);\n               //tx = smoothstep(0., .5, tx);\n\n               // The box divide color and bump factor.\n               vec4 bxD = boxDivide(sp.xy);\n               // A second sample for some highlighting.\n               vec4 bxD2 = boxDivide(sp.xy - normalize(ld.xy)*.003);\n               float b = max(bxD2.w - bxD.w, 0.)/.003;\n               oCol = bxD.xyz*(b*.015 + .95);//*(tx*.5 + .5);//vec3(.05);//\n        \n               // Stripes.\n               //vec2 q = rot2(-3.14159/4.)*(sp.xy);\n               //float str = abs(fract(q.x*15.*1.4142) - .5)*2. - .35;\n               //oCol = mix(vec3(1), vec3(0), 1. - smoothstep(0., sf*8., str));\n\n               // The wall has no reflection of refraction, so setting the\n               // reflective or transmission power to zero will cause the\n               // loop to terminate early, which saves a lot of work.\n               objRef = .0;\n\n               spe *= freS;\n\n               // Reflection only override. This ensures that no refraction\n               // will occur... It's hacky, but it works. :)\n               refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass Truchet tubes.\n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dard, in order to look transparent.\n                vec3 tx = tex3D(iChannel0, (sp*sz0), sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*.125;//*vec3(1, 2, 3); // Color.\n                objRef = 1.; \n                \n                // Faking more of a glass look.\n                //oCol *= tx;\n                //objRef = 1.2; \n                \n            }\n            else { // Metallic stuff.\n                \n                // Joins and animated metal portion.\n                vec3 tx = tex3D(iChannel0, (sp*1.), sn);\n                tx = smoothstep(0.05, .5, tx);\n                oCol = tx*vec3(1, .85, .6)/3.;\n                objRef = .125; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*2.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n\n                \n            }\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .25 + vec3(1, .5, .3)*spe*16. + vec3(.1, .25, 1)*pow(fre, 2.)*8.);\n            \n            // Shading.\n            colL *= sh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2495, 2528, 2550, 2550, 2608], [2726, 3138, 3160, 3302, 3449], [4124, 4204, 4250, 4250, 5162], [5165, 5192, 5262, 5315, 5428], [5567, 5595, 5642, 5693, 5777], [5983, 6262, 6280, 6302, 9349], [9353, 9477, 9529, 9580, 10170], [10173, 10364, 10416, 10533, 11850], [11853, 12005, 12040, 12040, 12426], [13226, 13412, 13472, 13472, 14310], [14316, 15270, 15296, 15427, 21229], [21234, 21234, 21290, 21323, 31638]]}
{"id": "wd3czn", "name": "jh0ker_chroma_abberation", "author": "jh0ker", "description": "try implementing chromatic abberation", "tags": ["chromatic", "effects", "chromaticabberation", "abberation"], "likes": 4, "viewed": 437, "published": 3, "date": "1600247260", "time_retrieved": "2024-07-30T20:45:03.462758", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = vec2(.5);\n    vec2 diff = uv - center;\n\n    float strength = .015;\n    float overlap = .3;\n    \n    int samples = 4;\n    \n    vec4 colorSamples[3] = vec4[] (vec4(.0),vec4(.0),vec4(.0));\n    \n    for (int colOffset = 0; colOffset < 3; colOffset++) {\n        \n        for (int i = 0; i < samples; i++) {\n\n            float colMult = \n                strength * (\n                    float(colOffset - 1) * (1. - overlap) +\n                \t(float(samples - i) / float(samples) - .5)\n                );\n            \n            \n            colorSamples[colOffset] += texture(\n                iChannel0, \n                uv - diff * colMult\n            ) / float(samples);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(colorSamples[0].r, colorSamples[1].g, colorSamples[2].b,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3czn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "Ws3yzr", "name": "GLSL bug #8143", "author": "FabriceNeyret2", "description": "With Chrome, at least on OpenGL, left gives expected red/black strips, while right is all green.", "tags": ["glsl", "bug"], "likes": 2, "viewed": 338, "published": 3, "date": "1600233334", "time_retrieved": "2024-07-30T20:45:04.344401", "image_code": "// ( is the reason why \"TruchetFlip2\" no longer work https://shadertoy.com/view/lst3R7 )\n\nvoid mainImage( out vec4 O,  vec2 v ) {\n    \n    v *= 10./iResolution.xy;      // window mapped to (0,0) - (10,10)\n    float s = 1.;\n    \n    if (v.x>5.) v.x *= s = 1.;    // right side. on my machine, gives 1.\n    if (v.x>5.) v.x *=(s = 1.);   //    not better\n  //if (v.x>5.) v.x *= s     ;    //    works correctly\n  //if (v.x>5.) v   *= s = 1.;    //    works correctly\n    else        v.x *=     1.;    // left side\n    \n    O = vec4( fract(v.x) , v.x == 1. , 0,0 ); // should draw red vertical strips\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 129, 129, 598]]}
{"id": "Wd3cRr", "name": "Synth Noise Music", "author": "jarble", "description": "I made a few changes to my [url=https://www.shadertoy.com/view/Wd3czn]\"ambient noise music.\"[/url] This one sounds more \"musical\" and less noisy.", "tags": ["sound", "music"], "likes": 6, "viewed": 359, "published": 3, "date": "1600226217", "time_retrieved": "2024-07-30T20:45:05.188145", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = t % 150000;\n    t = (t>>12|t*(-(t/500)%11)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tresult += sound1(time*factor)/(factor);\n        factor *= 1.5;\n    }\n    return result;\n}", "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3cRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "Wd3czn", "name": "Ambient noise music", "author": "jarble", "description": "This was a nice accidental discovery. It reminds me of one of the old  Windows startup sounds.", "tags": ["sound", "music", "ambient"], "likes": 5, "viewed": 316, "published": 3, "date": "1600219410", "time_retrieved": "2024-07-30T20:45:06.017926", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 9000.0);\n    t = (t>>13|t*(-(t/10)%13)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tresult += sound1(time*factor)/(factor);\n        factor *= 1.5;\n    }\n    return result;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3czn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "Wdcyzn", "name": "The Ringtone Song", "author": "jarble", "description": "It sounds like a lot of phone ringtones playing at the same time.", "tags": ["music", "ringtone"], "likes": 5, "viewed": 301, "published": 3, "date": "1600216996", "time_retrieved": "2024-07-30T20:45:06.846710", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}\n\n", "sound_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>5|t*6&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n/*\nvec2 sound( float time )\n{\n    int t = int(time * 8000.0);\n    int t1 = (t/1024)%3+3;\n    t = (t>>t1|t*(t1%3)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n*/\n\n/*\n\nvec2 mainSound(in int samp, float time)\n{\n    int t = int(time * 6000.0);\n    int t2 = (t/1024)%5+3;\n    int t1 = (t/1024)%(3+t2/2)+3;\n    t = (t>>t1|t*(t1%(3+t1+t2))&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n*/", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdcyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "MdyyWt", "name": "1990-esque", "author": "ChrisK", "description": "Best viewed in fullscreen. Pixel art is all original and not based on an existing game, but built roughly within Turbografx-16 / PC Engine graphics limitations.", "tags": ["retro", "crt", "sprites", "pixelart", "television", "videogames"], "likes": 48, "viewed": 2047, "published": 3, "date": "1600208750", "time_retrieved": "2024-07-30T20:45:07.988658", "image_code": "// My latest attempt at a retro CRT simulation.\n\n// J. Kyle Pittman wrote a very good blog post a few years ago which provided a lot of\n// information on the CRT simulation techniques that he uses in Super Win The Game:\n// www.gamasutra.com/blogs/KylePittman/20150420/241442/CRT_Simulation_in_Super_Win_the_Game.php\n// My effects here aren't quite the same as those he descibes in the article (my simulation\n// is simpler in many ways and I'm simulating a higher-quality TV), but I definitely used\n// that as an inspirational starting point. Incidentally, Super Win The Game is pretty\n// underrated IMO and you should play it.\n\n\n#define gaussian(a,b)\texp2((a)*(a)*-(b))\n\n\nvec2 curveScreen( vec2 uv ) {\n    float r = PI*0.5/SCREEN_CURVE_RADIUS;\n    float d = 1.0-cos(uv.x*r)*cos(uv.y*r);\t\t//distance to screen\n    float s = cos(r);\t\t\t\t\t\t\t//scale factor to re-fit window\n    return uv / (1.0-d) * s;\n}\n\n\nfloat discardCorners( vec2 pos ) {\n    pos = abs(pos);\n    pos.x = pos.x*1.333-0.333;\t\t\t\t\t\t\t\t\t\t\t// 4:3 aspect ratio correction\n    if( min(pos.x, pos.y) < 1.0-SCREEN_CORNER_RADIUS ) return 1.0;\t\t// not near corner -- break early\n    float d = distance( pos, vec2(1.0-SCREEN_CORNER_RADIUS) );\n    return float( d<SCREEN_CORNER_RADIUS );\n}\n\n\nvec3 getSample( vec2 pos, vec2 off ) {\n\t//get nearest emulated sample\n\tpos = floor(pos*IRES) + vec2(0.5) + off;\n\tvec3 col = vec3(0.0);\n\tif ( pos.x>=0.0 && pos.x<=IRES.x && pos.y>=0.0 && pos.y<=IRES.y ) {\n        #ifdef NTSC_ARTIFACTS\n        col = texelFetch( iChannel0, ivec2(pos), 0).rgb;\n        #else\n        col = texelFetch( iChannel2, ivec2(pos), 0).rgb;\n        #endif\n        col = pow( ( (col + 0.055) / 1.055), vec3(2.4) );\t\t// SRGB => linear\n\t}\n\treturn col;\n}\n\n\nvec3 getScanline( vec2 pos, float off ) {\n\t// 3-tap gaussian filter to get colour at arbitrary point along scanline\n    float d = 0.5-fract(pos.x*IRES.x);\n\tvec3 ca = getSample( pos, vec2(-1.0, off ) );\n\tvec3 cb = getSample( pos, vec2( 0.0, off ) );\n\tvec3 cc = getSample( pos, vec2( 1.0, off ) );\n\tfloat wa = gaussian( d-1.0, PIXEL_SHARPNESS );\n\tfloat wb = gaussian( d,     PIXEL_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, PIXEL_SHARPNESS );\n\treturn ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);\n}\n\n\nvec3 getScreenColour( vec2 pos ) {\n\t//Get influence of 3 nearest scanlines\n    float d = 0.5-fract(pos.y*IRES.y);\n\tvec3 ca = getScanline( pos,-1.0 ) * gaussian( d-1.0, LINE_SHARPNESS );\n\tvec3 cb = getScanline( pos, 0.0 ) * gaussian( d,     LINE_SHARPNESS );\n\tvec3 cc = getScanline( pos, 1.0 ) * gaussian( d+1.0, LINE_SHARPNESS );\n    return ca + cb + cc;\n}\n\n\nvec3 ACESFilm( vec3 x ) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord / iResolution.xy;\n   \tpos = pos*2.0 - 1.0;\n    pos.x *= iResolution.x/iResolution.y*0.75;\t\t\t\t\t\t// 4:3 aspect\n    \n    #ifdef SCREEN_SHAPE\n    pos = curveScreen(pos);\t\t\t\t\t\t\t\t\t\t\t// curve screen\n    #endif\n    \n    vec3 col = vec3(0.0);\n    \n    if(max( abs(pos.x), abs(pos.y) )<1.0) {\t\t\t\t\t\t\t// skip everything if we're beyond the screen edge\n    \t\n        col = vec3(1.0);\n        \n        #ifdef SCREEN_SHAPE\n        col *= discardCorners(pos);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n        col *= 1.0 - sqrt(length(pos)*0.25);\t\t\t\t\t\t// vignette\n        #endif\n        \n        pos = pos*0.5 + 0.5;\n\n        #ifdef SCANLINES\n\t\tcol *= getScreenColour( pos );\n        #else\n        col *= getSample( pos, vec2(0.0) );\n        #endif\n        \n        #ifdef SHADOW_MASK\n        #ifdef CURVE_MASK_TO_SCREEN\n        col *= texelFetch( iChannel1, ivec2(pos*iResolution.xy), 0).rgb;\t// curve mask with screen\n        #else\n    \tcol *= texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\t\t\t\t// draw mask flat (moire fix)\n        #endif\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n\t\tcol *= BRIGHTNESS;\n    \tcol = ACESFilm(col);\n        #endif\n    \n    \tcol = pow( col, vec3(1.0/2.4) ) * 1.055 - 0.055;\t\t\t// linear => SRGB\n        \n    \t//col = texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I'm approximating TurboGrafx-16 specifications, because I have nostalgia\n// for that particular console and the restrictions are fun to work with.\n// here's a simplified list of the restrictions:\n\n// variable resolution, but 256 x 239 is most common\n// 9-bit colour\n// 16 colours per palette (15 + transparent for sprite palettes)\n// can use up to 16 sprite palettes and 16 tile palettes simultaneously\n// background tiles are 8x8\n// one background layer (parallax is only possible with linescrolling and sprite tricks)\n// sprites are 16×16, 16×32, 16×64, 32×16, 32×32, or 32×64\n// up to 64 simultaneous sprites on screen or 256 sprite pixels on one scanline\n// ...and a few other things that don't really figure into this particular image\n\n// I'm not exactly pushing these restrictions to the limit here, but I think this feels\n// pretty representative of the graphics found in many of the games on the console\n\n\n// palette colours in 0-7 range; final colour is divided by 7 for 9-bit RGB\nvec3 palette_t[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 7),\t// 1  - white\n                              vec3(6, 7, 2),\t// 2  - yellow\n                              vec3(5, 3, 1),\t// 3  - orange\n                              vec3(4, 1, 1),\t// 4  - red\n                              vec3(2, 0, 2),\t// 5  - dark purple (same as 0)\n                              vec3(0, 0, 2),\t// 6  - dark blue\n                              vec3(0, 1, 2),\t// 7  - grey-blue\n                              vec3(1, 3, 4),\t// 8  - medium cyan\n                              vec3(0, 2, 1),\t// 9  - green\n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\nvec3 palette_p[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 5),\t// 1  - white eyes\n                              vec3(6, 5, 3),\t// 2  - light shirt\n                              vec3(2, 2, 1),\t// 3  - pants\n                              vec3(5, 3, 2),\t// 4  - skintone\n                              vec3(4, 0, 1),\t// 5  - red\n                              vec3(2, 0, 0),\t// 6  - dark red\n                              vec3(1, 0, 0),\t// 7  - deep red (outline)\n                              vec3(0, 0, 0),\t// 8  - \n                              vec3(0, 0, 0),\t// 9  - \n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\nvec3 palette_u[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 7),\t// 1  - white\n                              vec3(4, 5, 6),\t// 2  - pale blue\n                              vec3(5, 1, 1),\t// 3  - red\n                              vec3(3, 0, 0),\t// 4  - dark red\n                              vec3(0, 0, 0),\t// 5  - black\n                              vec3(0, 0, 0),\t// 6  - \n                              vec3(0, 0, 0),\t// 7  - \n                              vec3(0, 0, 0),\t// 8  - \n                              vec3(0, 0, 0),\t// 9  - \n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\n\nconst int map[1024] = int[1024](\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23,24, 0,\n    0, 0,23,24,23,24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23,24,22, 0, 0,23,24,23,17,17,24,\n   24,23,17,17,17,17,24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,22,23,17,17,17,24,23,17,17,17,17,17,17,\n   17,17,17,17,17,17,17,24,22,23,24,22, 0, 0, 0, 0, 0, 0,23,17,17,17,17,17,17,17,17,17,17,17,17,17,\n   17,17,17,17,18,19,21,20,17,17,17,17,24, 0, 0, 0, 0,23,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n   17,17,18,19,16,16,16,16,21,20,17,17,17,24,23,24,23,17,17,17,17,17,17,17,17,17,18,19,21,20,17,17,\n   18,19,16,16,16,16,16,16,16,16,21,20,17,17,17,17,18,19,21,20,17,17,17,17,18,19,16,16,16,16,21,20,\n   29,28,16,16,16,16,16,16,16,16,16,16,21,20,18,19,16,16,16,16,21,20,18,19,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,29,28,16,16,16,16,26,27,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,26,27,16,16,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n   14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,\n   12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,\n   \t4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,\n    2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n    8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,\n    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,\n    4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,\n    2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n   10, 1, 1, 1, 1, 1, 1, 1,10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,10, 1, 1, 1, 1, 1,\n    1,11, 1, 1, 1, 1, 1, 1, 1,11, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,11, 1, 1, 1, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t// off bottom of screen\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\nconst int atlas[256] = int[256](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\t// 0 - clear sky\n    0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444,\t\t// 1 - dirt\n\n    0x99797797, 0x99777797, 0x99799799, 0x79797797, 0x79697677, 0x66667676, 0x67674667, 0x74744774,\t\t// 2 - grass bottom 1\n    0x99799997, 0x99797997, 0x79797997, 0x67796796, 0x67997776, 0x66676777, 0x67767447, 0x74474444,\t\t// 3 - grass bottom 2\n    0x99999999, 0x99999999, 0x79999999, 0x99999999, 0x99999799, 0x99997999, 0x99999999, 0x99997999,\t\t// 4 - grass mid 1\n    0x99999999, 0x99999999, 0x99999999, 0x99999999, 0x79999999, 0x99999999, 0x99999999, 0x99799999,\t\t// 5 - grass mid 2\n    0x33333333, 0x33333333, 0x33333333, 0x33393339, 0x33399399, 0x93999999, 0x99999999, 0x99999999,\t\t// 6 - low dirt path 1\n    0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x39339399, 0x99999399, 0x99999999, 0x99999999,\t\t// 7 - low dirt path 2\n    \n\t0x44447444, 0x34444344, 0x33433343, 0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333,\t\t// 8 - high dirt path 1\n    0x94474474, 0x44433434, 0x34333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333,\t\t// 9 - high dirt path 2\n    0x44444444, 0x44444444, 0x44444444, 0x44433344, 0x44333344, 0x44333644, 0x44666644, 0x44466444,\t\t//10 - rock in dirt 1\n    0x44444444, 0x44444444, 0x44433444, 0x44433444, 0x44466444, 0x43444444, 0x46444444, 0x44444444,\t\t//11 - rock in dirt 2\n    0x77777777, 0x77777777, 0x77777777, 0x79779779, 0x99979979, 0x99979999, 0x99999999, 0x99999999,\t\t//12 - grass fade 1\n    0x77777777, 0x77777777, 0x77777777, 0x77797777, 0x97997797, 0x99999799, 0x99999999, 0x99999999,\t\t//13 - grass fade 2\n    0x66666666, 0x66666666, 0x66666666, 0x76676676, 0x77776777, 0x77777777, 0x77777777, 0x77777777,\t\t//14 - grass fade 3\n    0x66666666, 0x66666666, 0x66666666, 0x76676676, 0x76777677, 0x77777777, 0x77777777, 0x77777777,\t\t//15 - grass fade 4\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//16 - mountainside\n\t0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888,\t\t//17 - cloud\n    0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888866, 0x88886666, 0x88666666,\t\t//18 - mountain left  ( / ) slope 1\n    0x88888888, 0x88888866, 0x88886666, 0x88666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//19 - mountain left  ( / ) slope 2\n    0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x66888888, 0x66668888, 0x66666688,\t\t//20 - mountain right ( \\ ) slope 1\n\t0x88888888, 0x66888888, 0x66668888, 0x66666688, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//21 - mountain right ( \\ ) slope 2\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08222280, 0x82888828, 0x28888882, 0x88888888,\t\t//22 - small cloud bump\n    0x00000822, 0x00082222, 0x00822888, 0x00288888, 0x08888888, 0x02888888, 0x88888888, 0x88888888,\t\t//23 - left side cloud bump\n    0x22800000, 0x22228000, 0x88822800, 0x88888200, 0x88888880, 0x88888820, 0x88888888, 0x88888888,\t\t//24 - right side cloud bump\n\t0x00000000, 0x00002000, 0x00022000, 0x02222220, 0x00322200, 0x00222300, 0x02203200, 0x00000000,\t\t//25 - star\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666688, 0x66668866, 0x66866666, 0x86666666,\t\t//26 - mountain left  ( / ) overlap slope 1\n    0x66688888, 0x66888866, 0x68886666, 0x88666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//27 - mountain left  ( / ) overlap slope 2\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x88666666, 0x66886666, 0x66666866, 0x66666668,\t\t//28 - mountain right ( \\ ) overlap slope 1\n    0x88888666, 0x66888866, 0x66668886, 0x66666688, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//29 - mountain right ( \\ ) overlap slope 2\n    \n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\n\nconst int spr_heart[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00021100, 0x00112000,\n\t0x00223310, 0x01332200,\n    0x00131131, 0x13133100,\n    0x00131233, 0x32333100,\n    0x00133333, 0x33344100,\n    \n    0x00224333, 0x34444200,\n    0x00014444, 0x44441000,\n    0x00001444, 0x44410000,\n    0x00000144, 0x44100000,\n\t0x00000014, 0x41000000,\n    0x00000001, 0x10000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000);\n\nconst int spr_heart_empty[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00022200, 0x00222000,\n\t0x00255520, 0x02555200,\n    0x00255552, 0x25555200,\n    0x00255555, 0x55555200,\n    0x00255555, 0x55555200,\n    \n    0x00255555, 0x55555200,\n    0x00025555, 0x55552000,\n    0x00002555, 0x55520000,\n    0x00000255, 0x55200000,\n\t0x00000025, 0x52000000,\n    0x00000002, 0x20000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000);\n\nconst int spr_player_shadow[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    \n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00066666, 0x66666000,\n    0x66666666, 0x66666666,\n    0x66666666, 0x66666666,\n    0x00066666, 0x66666000);\n\nconst int spr_score[64] = int[64](\n    0x01111000, 0x01111000, 0x11111100, 0x01111000,\n    0x11551100, 0x11551100, 0x11555550, 0x11551100,\n    0x05501150, 0x05501150, 0x11111000, 0x11511150,\n    0x00111550, 0x00111550, 0x05551100, 0x11111150,\n\t0x02255500, 0x00052200, 0x00002250, 0x22252250,\n    0x22550000, 0x22002250, 0x22002250, 0x22552250,\n    0x22222200, 0x02222550, 0x02222550, 0x02222550,\n    0x05555550, 0x00555500, 0x00555500, 0x00555500, \n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_moon[128] = int[128](\n    0x00000000, 0x00032222, 0x22223000, 0x00000000,\n    0x00000000, 0x02222222, 0x22222230, 0x00000000,\n    0x00000000, 0x83322222, 0x22222222, 0x30000000,\n    0x00000000, 0x08803222, 0x22222222, 0x23000000,\n    0x00000000, 0x00880322, 0x22322222, 0x22300000,\n    0x00000000, 0x00088032, 0x22222222, 0x22200000,\n    0x00000000, 0x00008003, 0x22222222, 0x22220000,\n    0x00000000, 0x00000800, 0x22222222, 0x22223000,\n    \n    0x00000000, 0x00000800, 0x32222222, 0x22222000,\n    0x00000000, 0x00000000, 0x02300022, 0x22222300,\n    0x00000000, 0x00000000, 0x32031302, 0x22222300,\n    0x00000000, 0x00000030, 0x23211130, 0x22222200,\n    0x00000000, 0x00000002, 0x22111110, 0x22222200,\n    0x00000000, 0x00000322, 0x22130030, 0x22222200,\n    0x00000000, 0x08222222, 0x23101000, 0x22222200,\n    0x00000000, 0x08032222, 0x23300003, 0x22222200,\n    \n    0x00000000, 0x08003222, 0x22230032, 0x22222200,\n    0x08200000, 0x08000322, 0x22222222, 0x22322200,\n    0x08220000, 0x08000032, 0x22222222, 0x22222200,\n    0x08322000, 0x00800003, 0x22222222, 0x33222300,\n    0x08322200, 0x08322222, 0x22232222, 0x33222000,\n    0x08022222, 0x20032222, 0x22222222, 0x22222000,\n    0x08032222, 0x22203222, 0x22222222, 0x22223000,\n    0x08002222, 0x22220322, 0x33222222, 0x22220000,\n    \n    0x00803223, 0x22222233, 0x03222222, 0x22200000,\n    0x00800222, 0x22222222, 0x22222222, 0x22000000,\n    0x00080022, 0x22222222, 0x22222222, 0x20000000,\n    0x00080002, 0x22222222, 0x22222223, 0x00000000,\n    0x00008000, 0x32222222, 0x22222200, 0x00000000,\n    0x00000800, 0x03322222, 0x22233000, 0x00000000,\n    0x00000008, 0x00003333, 0x30000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_moon_blink[128] = int[128](\n    0x00000000, 0x00032222, 0x22223000, 0x00000000,\n    0x00000000, 0x02222222, 0x22222230, 0x00000000,\n    0x00000000, 0x83322222, 0x22222222, 0x30000000,\n    0x00000000, 0x08803222, 0x22222222, 0x23000000,\n    0x00000000, 0x00880322, 0x22322222, 0x22300000,\n    0x00000000, 0x00088032, 0x22222222, 0x22200000,\n    0x00000000, 0x00008003, 0x22222222, 0x22220000,\n    0x00000000, 0x00000800, 0x22222222, 0x22223000,\n    \n    0x00000000, 0x00000800, 0x32222222, 0x22222000,\n    0x00000000, 0x00000000, 0x02222322, 0x22222300,\n    0x00000000, 0x00000000, 0x32222332, 0x22222300,\n    0x00000000, 0x00000030, 0x22222233, 0x22222200,\n    0x00000000, 0x00000002, 0x22322222, 0x22222200,\n    0x00000000, 0x00000322, 0x23322222, 0x22222200,\n    0x00000000, 0x08222222, 0x20322230, 0x22222200,\n    0x00000000, 0x08032222, 0x23300003, 0x22222200,\n    \n    0x00000000, 0x08003222, 0x22230032, 0x22222200,\n    0x08200000, 0x08000322, 0x22222222, 0x22322200,\n    0x08220000, 0x08000032, 0x22222222, 0x22222200,\n    0x08322000, 0x00800003, 0x22222222, 0x33222300,\n    0x08322200, 0x08322222, 0x22232222, 0x33222000,\n    0x08022222, 0x20032222, 0x22222222, 0x22222000,\n    0x08032222, 0x22203222, 0x22222222, 0x22223000,\n    0x08002222, 0x22220322, 0x33222222, 0x22220000,\n    \n    0x00803223, 0x22222233, 0x03222222, 0x22200000,\n    0x00800222, 0x22222222, 0x22222222, 0x22000000,\n    0x00080022, 0x22222222, 0x22222222, 0x20000000,\n    0x00080002, 0x22222222, 0x22222223, 0x00000000,\n    0x00008000, 0x32222222, 0x22222200, 0x00000000,\n    0x00000800, 0x03322222, 0x22233000, 0x00000000,\n    0x00000008, 0x00003333, 0x30000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_player_run_a[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00767777, 0x77770000,\n    0x00000000, 0x00000000, 0x07666666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666666, 0x66666700,\n    0x00000000, 0x00000000, 0x07666566, 0x66666700,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000777, 0x77666666, 0x66647000,\n    \n    0x00000000, 0x00007222, 0x27766666, 0x44447000,\n    0x00000000, 0x00072222, 0x22276466, 0x44447000,\n    0x00000000, 0x00722222, 0x22226465, 0x44177000,\n    0x00000000, 0x07722222, 0x22222444, 0x41174700,\n    0x00000000, 0x07444277, 0x22222244, 0x44174700,\n    0x00000000, 0x07444565, 0x52222244, 0x44447000,\n    0x00000000, 0x00745765, 0x52222264, 0x44470000,\n    0x00000000, 0x00077652, 0x22222226, 0x77700000,\n    \n    0x00000000, 0x00076636, 0x22222227, 0x25770000,\n    0x00000000, 0x00766333, 0x66222227, 0x22247000,\n    0x00000000, 0x07366333, 0x33662272, 0x22247000,\n    0x00000007, 0x73336633, 0x33336672, 0x22270000,\n    0x00000773, 0x33336663, 0x33333377, 0x77700000,\n    0x00007733, 0x33333667, 0x33333337, 0x00000000,\n    0x00076733, 0x33333677, 0x73333333, 0x70000000,\n    0x00076773, 0x33677700, 0x07633333, 0x37777000,\n    \n    0x00076677, 0x77700000, 0x00776333, 0x33767000,\n    0x00076700, 0x00000000, 0x00007733, 0x37670000,\n    0x00077000, 0x00000000, 0x00000077, 0x76700000,\n    0x00000000, 0x00000000, 0x00000007, 0x67000000,\n    0x00000000, 0x00000000, 0x00000000, 0x70000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_player_run_b[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00007000, 0x00000000,\n    0x00000000, 0x00000000, 0x00676777, 0x77770000,\n    0x00000000, 0x00000000, 0x07766666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666566, 0x66666700,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000000, 0x07666666, 0x66646700,\n    \n    0x00000000, 0x00000000, 0x07666666, 0x65447000,\n    0x00000000, 0x00000000, 0x07666666, 0x44447000,\n    0x00000000, 0x00000000, 0x07766466, 0x44177000,\n    0x00000000, 0x00000000, 0x07777465, 0x41177000,\n    0x00000000, 0x00000000, 0x72222444, 0x44174700,\n    0x00000000, 0x00000007, 0x22222244, 0x44444700,\n    0x00000000, 0x00000072, 0x22222244, 0x45447000,\n    0x00000000, 0x00000722, 0x22626224, 0x44470000,\n    \n    0x00000000, 0x00000722, 0x22662222, 0x77700000,\n    0x00000000, 0x00000722, 0x22272222, 0x70000000,\n    0x00000000, 0x00000772, 0x22277227, 0x70000000,\n    0x00000000, 0x00000767, 0x22447274, 0x70000000,\n    0x00000000, 0x00007666, 0x74447674, 0x70000000,\n    0x00000000, 0x00007366, 0x67776670, 0x00000000,\n    0x00000000, 0x00073333, 0x66663370, 0x00000000,\n    0x00000000, 0x00073333, 0x37333370, 0x00000000,\n    \n    0x00000000, 0x00733333, 0x76333370, 0x00000000,\n    0x00000000, 0x00733336, 0x67333700, 0x00000000,\n    0x00000000, 0x07333337, 0x67633700, 0x00000000,\n    0x00000000, 0x07733367, 0x76777000, 0x00000000,\n    0x00000000, 0x07673370, 0x07677000, 0x00000000,\n    0x00000000, 0x00767700, 0x00767000, 0x00000000,\n    0x00000000, 0x00076670, 0x00077000, 0x00000000,\n    0x00000000, 0x00007770, 0x00000000, 0x00000000);\n\nconst int spr_player_run_c[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00007000, 0x00000000,\n    0x00000000, 0x00000000, 0x07676777, 0x77770000,\n    0x00000000, 0x00000000, 0x00766666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000000, 0x07666666, 0x66676700,\n    0x00000000, 0x00000000, 0x07666666, 0x65447700,\n    0x00000000, 0x00000777, 0x77766766, 0x54447000,\n    \n    0x00000000, 0x00007222, 0x27777466, 0x44177000,\n    0x00000000, 0x00072222, 0x22277456, 0x41177000,\n    0x00000000, 0x00722222, 0x22227444, 0x44177000,\n    0x00000000, 0x00722225, 0x22222644, 0x44444700,\n    0x00000000, 0x00722272, 0x22222244, 0x45444700,\n    0x00000000, 0x00744722, 0x22222224, 0x44447000,\n    0x00000000, 0x00077222, 0x25222225, 0x44470000,\n    0x00000000, 0x00007222, 0x25222222, 0x67770000,\n    \n    0x00000000, 0x00073622, 0x25522222, 0x22447000,\n    0x00000000, 0x00733366, 0x25652222, 0x22247000,\n    0x00000000, 0x07333333, 0x66667522, 0x22270000,\n    0x00000007, 0x73333333, 0x36667777, 0x77700000,\n    0x00000773, 0x33333333, 0x67777770, 0x00000000,\n    0x00007733, 0x33333367, 0x77776337, 0x00000000,\n    0x00076733, 0x33336670, 0x77773333, 0x70000000,\n    0x00076673, 0x36677700, 0x00773333, 0x37777000,\n    \n    0x00076677, 0x77700000, 0x00076333, 0x37677000,\n    0x00076700, 0x00000000, 0x00007733, 0x76770000,\n    0x00077000, 0x00000000, 0x00000077, 0x67700000,\n    0x00000000, 0x00000000, 0x00000007, 0x77000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_bush_small[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000990, 0x99000000,\n    0x00099999, 0x99900000,\n    0x00999999, 0x99999000,\n    0x00999999, 0x99999000,\n    0x09999999, 0x99999900,\n    0x09999979, 0x77797900,\n    0x99999997, 0x77779000,\n    \n    0x09999777, 0x74697990,\n    0x99997746, 0x66779999,\n    0x77977774, 0x46999990,\n    0x79999996, 0x47999997,\n    0x99999997, 0x67799977,\n    0x99799999, 0x77777770,\n    0x77999999, 0x94746600,\n    0x07797999, 0x94466960);\n\nconst int spr_bush_large[256] = int[256](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00999990, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000009, 0x99999999, 0x90000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00090999, 0x99999999, 0x99900000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x09999999, 0x99999999, 0x99900000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000009, 0x99999999, 0x99999999, 0x99990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000009, 0x99999999, 0x99999999, 0x99990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999999, 0x97900000, 0x00000000, 0x00000000, 0x00000000,\n    \n    0x00000000, 0x00000999, 0x99999999, 0x99999999, 0x97990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000999, 0x99999999, 0x99999977, 0x79977000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999997, 0x97777000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999999, 0x99770000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00009999, 0x99799999, 0x99979999, 0x99999000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00009999, 0x97779999, 0x77799999, 0x99999990, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00999997, 0x77799999, 0x77999999, 0x99799999, 0x97000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00799999, 0x77797999, 0x99999999, 0x99977999, 0x99000000, 0x00000000, 0x00000000,\n    \n    0x00000000, 0x99999977, 0x74779999, 0x99999999, 0x79979999, 0x99900000, 0x00000000, 0x00000000,\n    0x00000000, 0x79779976, 0x66799799, 0x99999999, 0x97797979, 0x97790000, 0x00000000, 0x00000000,\n    0x00000000, 0x07779776, 0x67677999, 0x99979977, 0x99797799, 0x99970000, 0x00000000, 0x00000000,\n    0x00000000, 0x07797797, 0x67697999, 0x99777767, 0x77779777, 0x99999900, 0x00000000, 0x00000000,\n    0x00000000, 0x00979967, 0x66699979, 0x99777646, 0x76977799, 0x99997700, 0x00000000, 0x00000000,\n    0x00000099, 0x99997677, 0x76679977, 0x66766466, 0x77669999, 0x99999990, 0x00000000, 0x00000000,\n    0x00009977, 0x99999776, 0x66677797, 0x77677669, 0x67799999, 0x99999990, 0x00000000, 0x00000000,\n    0x00077999, 0x99999964, 0x66467999, 0x76646666, 0x76999999, 0x99979979, 0x00000000, 0x00000000,\n    \n    0x00999799, 0x99999796, 0x66476766, 0x67646674, 0x79999999, 0x99997799, 0x00000000, 0x00000000,\n    0x09799999, 0x99977976, 0x66666777, 0x66646446, 0x99999999, 0x99999797, 0x00000000, 0x00000000,\n    0x09999799, 0x79997799, 0x97666666, 0x66744467, 0x79999999, 0x99979779, 0x00000000, 0x00000000,\n    0x79999777, 0x97779999, 0x99996666, 0x66444749, 0x99999999, 0x79977977, 0x00000000, 0x00000000,\n    0x99999979, 0x77769999, 0x99776674, 0x77447669, 0x77999999, 0x97777777, 0x00000000, 0x00000000,\n    0x77999997, 0x77699999, 0x99979664, 0x44479967, 0x97797999, 0x99779776, 0x00000000, 0x00000000,\n    0x77799779, 0x79999999, 0x77997766, 0x44499997, 0x79977997, 0x99799779, 0x00000000, 0x00000000,\n    0x97779999, 0x79779799, 0x99977769, 0x64779997, 0x77799797, 0x79979799, 0x00000000, 0x00000000);\n\n\nfloat lineScroll (float y) {\n    float s = 0.0;\n    if (y>8.0*8.0) s = 10.0;\n    if (y>8.0*20.0) s = 40.0;\n    if (y>8.0*21.0) s = 60.0;\n\treturn floor(s*iTime);\n}\n\n\nvec3 drawTiles( vec2 p ) {\n\t// get coords for 8x8 tile\n    p.x = mod( p.x + lineScroll(p.y), IRES.x );\n    ivec2 i = ivec2( floor(p/8.0) );\n    vec2 t = fract(p/8.0)*8.0;\n    int ti = map[ i.x + 32*i.y ]*8 + int(t.y);\n    int pi = ( atlas[ ti ] >> (int(8.0-t.x)*4) ) & 0xF;\t\t//palette index of pixel in atlas\n    return palette_t[pi];\n}\n\n\nvoid drawSprite_16x16( inout vec3 col, int spr[32], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<16 && i.y>=0 && i.y<16 ) {\n        int pi = spr[ i.x/8 + i.y*2 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_32x16( inout vec3 col, int spr[64], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<16 ) {\n        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_32x32( inout vec3 col, int spr[128], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<32 ) {\n        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_64x32( inout vec3 col, int spr[256], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<64 && i.y>=0 && i.y<32 ) {\n        int pi = spr[ i.x/8 + i.y*8 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy;\n    uv.y = IRES.y-uv.y;\n    \n    vec3 col = vec3(2, 0, 2);\n    //if( mod(fragCoord.x,16.0)<1.0 ) col.r = 7.0;\n    //if( mod(fragCoord.y,16.0)<1.0 ) col.g = 7.0;\n    \n    vec3 bg = drawTiles(uv);\n    if (bg.r>-0.5) col = bg;\n    \n    // UI\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(16,8)\t );\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(32,8)\t );\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(48,8)\t );\n    drawSprite_32x16( col, spr_score,\t\tpalette_u, uv, vec2(200,220) );\n    \n    // BUSHES\n    drawSprite_64x32( col, spr_bush_large,  palette_t, uv, vec2( mod( -lineScroll(200.0)+96.0 , IRES.x*2.0)-64.0, 144.0) );\n    drawSprite_16x16( col, spr_bush_small,  palette_t, uv, vec2( mod( -lineScroll(200.0)+32.0 , IRES.x*2.0)-64.0, 160.0) );\n    drawSprite_16x16( col, spr_bush_small,  palette_t, uv, vec2( mod( -lineScroll(200.0)+320.0, IRES.x*2.0)-64.0, 160.0) );\n    \n    // MOON\n    vec2 moonpos = vec2(110,16);\n    if ( mod(iTime,5.0)>4.8 )\t\t\tdrawSprite_32x32( col, spr_moon_blink, palette_t, uv, moonpos );\n    else\t\t\t\t\t\t\t\tdrawSprite_32x32( col, spr_moon,\t   palette_t, uv, moonpos );\n    \n    // PLAYER\n    vec2 pp = vec2(110, 168);\n    drawSprite_16x16( col, spr_player_shadow, palette_p, uv, pp+vec2(8,18) );\n    float rc = fract(iTime*1.0);\n    if (rc<0.25)\t\t\t\t\t\tdrawSprite_32x32( col, spr_player_run_a, palette_p, uv, pp );\n    else if (rc>=0.5 && rc<0.75)\t\tdrawSprite_32x32( col, spr_player_run_c, palette_p, uv, pp );\n    else\t\t\t\t\t\t\t\tdrawSprite_32x32( col, spr_player_run_b, palette_p, uv, pp );\n    \n    col = clamp( col/7.0, 0.0, 1.0 );\t\t\t// convert to 9-bit RGB\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "#define NTSC_ARTIFACTS\n#define SCANLINES\n#define SHADOW_MASK\n#define SCREEN_SHAPE\n#define LIGHT_EFFECTS\n\n//#define CURVE_MASK_TO_SCREEN\n#define SCREEN_CURVE_RADIUS\t\t5.0\n#define SCREEN_CORNER_RADIUS\t0.1\n#define BRIGHTNESS      \t\t2.5\n#define PIXEL_SHARPNESS   \t\t3.0\n#define LINE_SHARPNESS\t\t\t6.0\n#define MASK_STRENGTH\t\t\t0.35\n#define MASK_SCALE\t\t\t\t600.0\n\n\n\n\n\n\n#define IRES\t\tvec2( 256, 239 )\n\n\nconst float PI = 3.14159265;", "buffer_b_code": "// NTSC composite sampling artifacts, as usually seen on consoles such as the NES or TG-16\n// Explanation: http://wiki.nesdev.com/w/index.php/NTSC_video\n\n\nconst mat3 rgbtoyiq = mat3(0.299, 0.587, 0.114, 0.596, -0.275, -0.321, 0.212, -0.528, 0.311);\nconst mat3 yiqtorgb = mat3(1.0, 0.946882, 0.623557, 1.0, -0.274788, -0.635691, 1.0, -1.108545, 1.709007);\n\n\nvec3 YIQfromsample( vec3 rgb, float phase ) {\n  vec3 yiq = rgb * rgbtoyiq;\n  float p = phase / 6.0 * PI;\n  float sig = yiq.x + yiq.y*cos(p) + yiq.z*sin(p);\n  return sig * vec3( 1.0, cos(p), sin(p) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  ivec2 l = ivec2(fragCoord)-ivec2(1,0);\n  ivec2 m = ivec2(fragCoord);\n  ivec2 r = ivec2(fragCoord)+ivec2(1,0);\n    \n  l.x = max(l.x, 0);\n  r.x = min(r.x, int(IRES.x));\n    \n  vec3 lp = texelFetch( iChannel0, l, 0).rgb;\n  vec3 mp = texelFetch( iChannel0, m, 0).rgb;\n  vec3 rp = texelFetch( iChannel0, r, 0).rgb;\n\n  float phase = fragCoord.x*8.0 + fragCoord.y*4.0 + round(iTime*60.0)*4.0;\n  const float samples = 12.0;                   // number of signal samples (4 per subcarrier wavelength)\n  const float pwidth = 8.0;                     // width of the current pixel's signal, in samples\n  float overflow = (samples-pwidth)*0.5;\n\n  vec3 yiq = vec3(0.0);\n  for ( float f=0.0; f<samples; f++ ) {\n    vec3 s = f<overflow ? lp : ( f<samples-overflow ? mp : rp );    // get sample\n    yiq += YIQfromsample( s, phase-overflow+f );                    // add sample to buffer\n  }\n  yiq /= samples;\n  yiq.yz *= 2.0;\n  \n  vec3 rgb = yiq * yiqtorgb;\n  \n  // Here is where I had considered blending in a bit of the previous frame due to CRT phosphor afterglow\n  // but after some research it seems as though the effects visible on a healthy television of the\n  // early 90s should probably be pretty much negligible at 60fps (I have no reference unit on hand\n  // to compare against).\n    \n  // Pages 597 and 598 of the Phosphor Handbook, Second Edition (1999) imply that the time should be\n  // no more than 2ms for a phosphor to fall to 10% of its emissive output. Maybe 1 or 2% percent could\n  // still be present when the next frame happens, but it doesn't really seem worth simulating to me.\n    \n  // For way more information on this subject than you could ever possibly need:\n  // http://research.mrl.ucsb.edu/~ngeorge/downloads/Phosphor%20books/Phosphor%20Handbook.pdf\n  \n  //rgb += texelFetch( iChannel1, ivec2(fragCoord), 0).rgb * vec3(0.1);\n    \n  rgb = clamp(rgb, 0.0, 1.0);\n  fragColor = vec4( rgb, 1.0 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// generate shadow mask based on pattern and dot pitch\n// please excuse the mess\n\n// common tv size in the early 90s was ~27\"\n// common dot pitch on tvs of the time is ~.5 mm (computer monitors were closer to .25 mm)\n\n\nvec3 TriadMask( vec2 pos ) {\n\tvec3 col = vec3(0.0);\n    float h = sqrt(3.0)/2.0;\n    pos.x = mod(pos.x, 3.0);\n    pos.y = mod(pos.y, h*2.0);\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(0.0,0.0)   ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(1.0,0.0)   ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(2.0,0.0)   ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(3.0,0.0)   ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(-0.5,h)    ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(0.5,h)     ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(1.5,h)     ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(2.5,h)     ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(3.5,h)     ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(0.0,h*2.0) ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(1.0,h*2.0) ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(2.0,h*2.0) ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(3.0,h*2.0) ), 0.0 );\n    col - min(col, 1.0);\n    col = smoothstep(0.4, 0.65, col);\n    return col;\n}\n\n\nvec3 SlotMask( vec2 pos ) {\n\tvec3 col = vec3(0.0);\n    col += vec3(1,0,0) * max( (1.0 - distance(mod(pos.x,3.0),0.5) ), 0.0 );\n    col += vec3(0,1,0) * max( (1.0 - distance(mod(pos.x,3.0),1.5) ), 0.0 );\n    col += vec3(0,0,1) * max( (1.0 - distance(mod(pos.x,3.0),2.5) ), 0.0 );\n\tcol += vec3(1,0,0) * max( (1.0 - distance(mod(pos.x,3.0),3.5) ), 0.0 );\n    float b = pos.y;\n    b += (fract(pos.x/6.0) > 0.5) ? 1.5 : 0.0;\n    b = mod(b,3.0);\n    col -= (b<0.35) ? 1.0 : 0.0;\n    col = smoothstep(0.6, 0.7, col);\n    return col;\n}\n\n\nvec3 TriadMask_PixelPerfect( vec2 pos ) {\n    float f = fract( pos.x/6.0 + floor(pos.y/2.0)/2.0);\n    vec3 col = (f<=0.333) ? vec3(1,0,0) : ( (f<0.667) ? vec3(0,1,0) : vec3(0,0,1) ); \n    return col;\n}\n\n\nvec3 SlotMask_PixelPerfect( vec2 pos ) {\n    pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    float glow = 0.5;\n    float f = mod(pos.x,3.0);\n    vec3 col = vec3( (f<=1.0), (f>1.0&&f<=2.0), (f>2.0) );\n    col += vec3( (f<1.5 || f>=2.5), (f>0.5 && f<=2.5), (f>1.5 || f<=0.5) ) * glow;\n    col *= ( mod(pos.y+(fract(pos.x/6.0)>0.5?1.5:0.0),3.0)<1.0 ) ? glow : 1.0;\n    col /= 1.0+glow;\n    return col;\n}\n\n\nvec3 ApertureGrille_PixelPerfect( vec2 pos ) {\n    pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    float f = fract(pos.x/3.0);\n    vec3 col = vec3( (f<=0.333), (f>0.333&&f<0.667), (f>=0.667) );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = fragCoord/iResolution.x * MASK_SCALE;\n    \n    //vec3 col = TriadMask( pos );\n    //vec3 col = SlotMask( pos );\n    //vec3 col = TriadMask_PixelPerfect( fragCoord );\n    vec3 col = SlotMask_PixelPerfect( fragCoord );\n    //vec3 col = ApertureGrille_PixelPerfect( fragCoord );\n    \n    col = mix( vec3(1.0-MASK_STRENGTH), vec3(1.0+MASK_STRENGTH), col);\n    \n    //if (fract(fragCoord.x/200.0)<0.02) col = vec3(10.0);\n    //if (fract(fragCoord.y/200.0)<0.02) col = vec3(10.0);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 672, 701, 701, 899], [902, 902, 936, 936, 1239], [1242, 1242, 1280, 1311, 1713], [1716, 1716, 1757, 1831, 2206], [2209, 2209, 2243, 2283, 2565], [2568, 2568, 2593, 2593, 2673], [2676, 2676, 2733, 2733, 4105]]}
{"id": "wt2fWd", "name": "[NERDDISCO] DNA Mutation", "author": "TimPietrusky", "description": "Based on https://www.shadertoy.com/view/Md3XRM I added some more parameters and used a texture to mutate the DNA. ", "tags": ["texture", "dna", "mutation", "nerddisco"], "likes": 3, "viewed": 453, "published": 3, "date": "1600206834", "time_retrieved": "2024-07-30T20:45:08.792508", "image_code": "// Based on https://www.shadertoy.com/view/Md3XRM\n\nfloat FULL_SIZE = 2.0;\nfloat EDGE_SIZE = 0.2;\nfloat PAIR_SIZE = .2;\nfloat position_x = 100.0;\nfloat position_y = 100.0;\nfloat movement_speed = 0.5;\nfloat mutation_width = .11;\nfloat mutation_length = 30.0;\n\nvec3 n3(vec3 n)\n{\n \treturn fract(cos(dot(n,vec3(813,12,376)))*vec3(901.81,827.46,615.79));   \n}\nvec3 model(vec3 p)\n{\n    float A = p.z/3.0 + iTime * movement_speed;\n    vec3 R = vec3(cos(A),sin(A),0);\n    vec3 C = vec3(mod(p.xy+8.,16.)-8.+R.yx*vec2(1,-1),fract(p.z)-0.5);\n    \n    float H = min(length(C.xy+R.xy*FULL_SIZE),length(C.xy-R.xy*FULL_SIZE))*0.5-EDGE_SIZE;\n    float P = max(length(vec2(dot(C.xy,R.yx*vec2(1,-1)),C.z))-PAIR_SIZE,length(C.xy)-FULL_SIZE);\n    \n    float T = FULL_SIZE+0.01+2.*EDGE_SIZE-length(C.xy);\n    return vec3(min(H,P),T,P);  \n}\n\nvec3 normal(vec3 p)\n{\n \tvec2 N = vec2(-0.04, 0.04);\n\n \treturn normalize(model(p+N.xyy).x*N.xyy+model(p+N.yxy).x*N.yxy+\n                     model(p+N.yyx).x*N.yyx+model(p+N.xxx).x*N.xxx);\n}\n\nvec4 raymarch(vec3 p, vec3 d)\n{\n    vec4 M = vec4(p+d*2.0,0);\n \tfor(int i = 0; i<100;i++)\n    {\n        float S = model(M.xyz).x;\n    \tM += vec4(d,1) * S;\n        if (S < mutation_width || M.w > mutation_length) break;\n    }\n    return M;\n}\n\nvec3 color(vec3 p, vec3 d) {\n    vec2 M = model(p).yz;\n    \n    vec4 textureColor = texture(iChannel0, M.xy);\n\n    return textureColor.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = vec2(position_x, position_y);\n    \n    vec2 A = position.xy / iResolution.xy * vec2(2,1) * 3.1416;\n    vec3 D = vec3(cos(A.x)*sin(A.y),sin(A.x)*sin(A.y),cos(A.y));\n    D = mix(vec3(1,0,0),D,ceil((A.x+A.y)/10.0));\n    vec3 P = D*12.0-vec3(0,0,iTime*movement_speed);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 textureColor = texture(iChannel0, uv.xy);\n    \n    vec3 X = normalize(-D);\n    vec3 Y = normalize(cross(X,vec3(0,0,1)));\n    vec3 Z = normalize(cross(X,Y));\n    \n\tvec2 UV = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 R = normalize(mat3(X,Y,Z) * vec3(1,UV));\n    \n    vec4 M = raymarch(P,R);\n    vec3 C = mix(color(M.xyz,R),textureColor.rgb,smoothstep(0.5,1.0,M.w/50.0));\n\tfragColor = vec4(C,1);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 275, 275, 353], [354, 354, 374, 374, 817], [819, 819, 840, 840, 1008], [1010, 1010, 1041, 1041, 1250], [1252, 1252, 1280, 1280, 1393], [1395, 1395, 1452, 1452, 2208]]}
{"id": "WljfWd", "name": "Day 269", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 19, "viewed": 370, "published": 3, "date": "1600204045", "time_retrieved": "2024-07-30T20:45:09.854668", "image_code": "// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n  \n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.4;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBoxRound( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*0.4);\n}\n", "buffer_a_code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n// ----------\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\n\n\nfloat bspline( in vec2 coords );\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\t\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    //p.z = pmod(p.z,4.5);\n    \n    if(mp == 0.){\n    \td = length(p.xz) + 0.02 - abs(sin(p.y*9.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n    \n    \td = xor(d, max(length(p.z), abs(p.y) - 0.5),0.3);\n        \n    \t//d = xor(d, length(p.zx) - 0.3,0.3);\n    \n    } else if (mp == 1.){\n    \td = sdBox(p,vec3(0.8)) + 0.0 - 0.*abs(sin(p.y*4.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n        \n    \td = xor(d,length(p.x) + 0.6 - abs(sin(p.y*9.))*.9*smoothstep(1.,0.,abs(p.y)), 0.01);\n    \n    }\n    \n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    d = abs(d) - 0.01;\n    \n    return d;\n}\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt){\n\tfloat d = 10e5;\n    \n    vec3 ro = vec3(0.,0.34,.12)*12.;\n    \n    vec3 rd = getRd(ro,vec3(0.),uv);\n    \n    \n    \n    \n    for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n    \tvec3 lro = ro + vec3(0,i,0);\n        \n        \n        float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n        vec3 p = lro + rd*plane;\n    \t\n        vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n        \n        float m = map(vec3(p.x,(lro + rd*plane).y - i*1.5,p.z));\n        if(m <= d){\n        \t\n        \t//df = max(ldf.y,ldf.x)*1.;\n        \t\n            df = length(ldf)*1.;\n            \n\t\t\td = min(d,m);\n        \n        }\n        \n    }\n    \n    \n    return d ;\n}\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s) {\n\tp *= s;\n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375;\n    float char = chars[int(id.x)];\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8. && mod(char, 1.) == 0.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.)/16.,floor(char/16.)/16. ));\n        t = letter.w - 0.5;\n        t /= s*2.;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    luv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*200.;\n    \n    df = dFdx(uv.x)*9.;\n    \n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 c = vec3(0.45,.35,0.25)*2.8;\n    \n    \n    c = vec3(1);\n    vec3 col = c;\n\n    \n    float d = 10e5;\n    \n    \n    vec2 roll = r12(frame + 1.);\n    \n    float a = 0.03;\n        \n    mp = 0.;\n            \n           \n    col = colour( d , col, vec3(0), 0,4,3.9,0.8);\n\n    uv.x -= 0.5;\n    d = 10e5;\n    d = min(d,sdLine(uv,vec2(0),vec2(-1.,0.),1.) - 0.02);\n\n    col = colour( d , col, vec3(0), 0,4,3.9,0.8);\n\n    uv.x -= 0.5;\n    d = 10e5;\n    d = min(d,sdLine(uv,vec2(0),vec2(-1.,0.),1.) - 0.02);\n\n    col = colour( d , col, vec3(0), 0,4,3.9,0.8);\n\t// --\n    \n    uv = guv;\n    uv.y += 0.5;\n    d = 10e5;\n    d = min(d,sdLine(uv,vec2(0),vec2(-2.,0.),1.) - 0.06);\n\n    //col = colour( d , col, vec3(0), 0,4,7.9,.8);\n\n    \n\n    uv = guv;\n    \n    float sl = slice(uv, -1., 1., 20.);\n    d = sl;\n\n\n    col = colour( d , col, vec3(0), 1,0,.9,0.1);\n\n    \n    \n\n    d = text(uv - vec2(0.05,0.35), float[](46.,44.,2.,114.,111.,22.,14.,15.), -0.7,0.9);\n    \n    //col = colour( d , col, vec3(0), 1,0,.9,4.6);\n\tcol = colour( d - 0.02, col, vec3(0.1,0.1,0.1)*0., 0,0,4.,.34);\n\n    vec2 off = vec2(0.07,0.38);\n    \n    \n    d = text(uv + off, float[](76.,49.,124.,122.,144.,125.,24.24,15.24), -0.7,1.5);\n    \n\tcol = colour( d - 0.01, col, vec3(0.1,0.1,0.1)*0.1, 0,0,18.,.15);\n\n    d = text(uv + off + vec2(-0.03,0.05), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), -0.7,2.5);\n    \n\tcol = colour( d - 0.0, col, vec3(0.1,0.1,0.1)*0.1, 0,0,18.,.25);\n\n    d = text((uv + off + vec2(0.35,-0.3))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), -0.04,1.);\n    \n    d = abs(d);\n    \n\tcol = colour( d*0.25 +0.0, col, vec3(0.4,0.1,0.1)*0.1, 0,0,4.,.1);\n\n    \n    \n    \n    \n    \n    //d = xor(d,-length(uv) - 0.4,0.2);\n\n    //col = colour( d , col, vec3(0.2,0.1,0.2),7,0,4.9,0.1);\n\n    \n\t\n    \n\td = -(sdBox(uv - 0.,vec2(0.48)));\n    \n    d = xor(d,-sl,0.2);\n\n    //d = max(d,-length(uv) + 0.22);\n    \n    col = colour( d , col, vec3(0.3,0.1,0.1)*1.,7,0,4.9,0.1);\n    \n    d = sdBox(uv - vec2(0.2,0.39),vec2(0.2,0.06));\n    \n    \n    \n    col = colour( d , col, vec3(0.5,0.1,0.2),1,2,0.1,0.4);\n\n    \n    float rb = sdBoxRound((uv + off + vec2(0.5,-0.6))*rot(0.5*pi),vec2(0.15,0.3));\n    \n    d = rb;\n    \n\tcol = colour( d - 0.01, col, vec3(0.,0.001,0.004)*1., 0,0,7.,.05);\n    \n    d = text((uv + off + vec2(0.35,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), -0.2,1.9);\n    \n\tcol = colour( d*0.5 + 0.01, col, vec3(1.), 0,0,4.,.2);\n\n    d = text((uv + off + vec2(0.28,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.6 ,2.2);\n    \n    d = max(d,-uv.y + 0.1);\n    \n\tcol = colour( d*0.5 + 0.01, col, vec3(1.), 0,0,4.,.2);\n\n    uv = (uv + off + vec2(0.3,-0.5))*rot(0.5*pi);\n\n    d = abs(length(uv) - 0.03);\n    d = xor(d,abs(uv.x) - 0.01,0.61);\n    \n\t//col = colour( d*0.5 + 0.0, col, vec3(1.), 0,0,4.,.03);\n\n    \n    \n    uv = guv;\n    \n    \n    \n    d = -(sdBox(uv - 0.,vec2(0.48)));\n    col = colour( d , col, vec3(0.),0,0,6.9,0.1);\n\n    mp = 1.;\n    sl = slice(uv*rot(0.5*pi), -1., 1., 4.);\n    d = sl;\n\n    //col = colour( d  - 0.0, col, vec3(0.1,0.5,0.2)*1., 2,0,0.2,.05);\n\n\n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n\n    vec4 n = valueNoise(guv,1.); \n    vec4 nb = valueNoise(guv*0.5 + 0.2,2.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\t//db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*0.4).x*0.53*n.z*strokeparamb,0.,db );\n        \n        \n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.24*pow(n.w,0.5) + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.12;\n        \n        // splatter\n        db += texture(iChannel1,ruv*0.2).x * 0.2*pow(nb.x,5.)*strokeparamb;\n        db -= texture(iChannel2,ruv*0.3).x * (0.35*pow(n.z,3.) + 0.35*pow(nb.z,3.) )*strokeparamb;\n        /*\n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.1 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        */\n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n        \n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77 - 0.1*   smoothstep(1.,0.,abs(db)*14.11*(1. + pow(nb.x,3.)*5.))   ), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    t *= 6.;\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 133, 133, 190], [191, 191, 224, 224, 753], [754, 754, 772, 772, 1100], [1103, 1103, 1160, 1160, 2038]]}
{"id": "tlBfDh", "name": "BC: Straw Hat Pirates", "author": "BackwardsCap", "description": "Straw Hat Pirates flag", "tags": ["2d", "vector", "drawing", "fanart", "onepiece"], "likes": 7, "viewed": 487, "published": 3, "date": "1600198845", "time_retrieved": "2024-07-30T20:45:10.618626", "image_code": "float hatline(vec2 p, float ta, float tb, float rb)\n{\n    return SS(arc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb));\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-R)/R.y;\n    \n    //flag wave inspiration from https://www.shadertoy.com/view/tl2fRm\n    float w = cos(p.y + p.x - iTime + cos(p.x * 2.14 + 4.2 * p.y)+sin(p.x*.8));\n    p *= 1. + (.03 - .03 * w);\n\n    vec2 ap= abs(p);\n    p.y-=.25;\n    vec2 mp = vec2(abs(p.x),p.y);\n    \n    //hat\n    float dout = SS(1.0-circ(p,-.36));\n    float d = SS(circ(p,.6))*float(p.y>.05);    \n    vec2 op = p-vec2(0.05,.1);\n    float ta = .5775;\n    float tb = .15;\n    float rb = .015;\n    float a = hatline(op, ta, tb, rb);\n    op.x-=.1;\n    tb = .1;\n    ta = .5;\n    float a2 = hatline(op, ta, tb, rb);    \n    op.x-=.1;\n    tb = .05;\n    ta = .45;\n    float a3 = hatline(op, ta, tb, rb);\n    op.x+=.3;\n    tb = .13;\n    ta = 2.585;\n    float a4 = hatline(op, ta, tb, rb);\n    op.x+=.12;\n    tb = .055;\n    ta = 2.65;\n    float a5 = hatline(op, ta, tb, rb);\n    float loff = .15;\n    float lo = SS(length(p.y-loff)-.11);\n    float l = SS(length(p.y-loff)-.075)*d;\n    float b = SS(box(p,vec2(.9,.0))-.035);\n    \n    //skull\n    float s = SS(circ(p,.6)) * (1.0-SS(length(p.y)-.075));\n    float eyes = SS(circ(mp-vec2(.23,-.27),.165));\n    float nose = SS(circ((p+vec2(0,.48))/vec2(1.3,1),.05));\n    \n    //jaw and teeth\n    float jaw = SS(box(p+vec2(0,.725),vec2(0.01,0.05))-.425*(abs(p.y)/2.+.45))*dout;\n    float jawout = SS(box(p+vec2(0,.725),vec2(0.01,0.05))-.45*(abs(p.y)/2.+.47));\n    float t1 = .79, td = .035;\n    vec2 tt = p/vec2(.98,1.)+vec2(0,.02);\n    float tee = SS( circ(tt,t1)) - SS( circ(tt,t1-td));\n    float t2 = .95, t2d = .035;\n    float tee2 = SS( circ(tt,t2)) - SS( circ(tt,t2-t2d));\n    float g = SS(length(p.x)-.015) * float(p.y<-.61 && p.y > -.95);\n    vec2 rp = (p+vec2(.075,0))*rot(.15);\n    float g2 = SS(length(rp.x)-.015) * float(rp.y<-.61 && rp.y > -.95);\n    vec2 rp2 = (p-vec2(.075,0))*rot(-.15);\n    float g3 = SS(length(rp2.x)-.015) * float(rp2.y<-.61 && rp2.y > -.95);\n    \n    //cross bones\n    ap = ap-vec2(.775);\n    ap.x+= (p.y<0.?.1:-.1);\n    float bo = SS(length(ap+vec2(-0.075,0.075))-.125);\n    float bo2 = SS(length(ap-vec2(-0.075,.075))-.125);    \n    vec2 r2p = (p*rot(.79))-vec2(.25,0.);\n    float bol = SS(length(r2p.x)-.08)*float(r2p.y>-1.2 && r2p.y<1.);\n    vec2 r3p = (p*rot(-.79))+vec2(.25,0);\n    float bol2 = SS(length(r3p.x)-.08)*float(r3p.y>-1.2 && r3p.y<1.);\n\n    //coloring\n    vec3 col = vec3(0);\n    vec3 ylw = vec3(1.,.95,0.2);\n\n    col = mix(col, vec3(1), s);\n    col = mix(col, vec3(1), jaw);\n    col = mix(col, vec3(0), tee);\n    col = mix(col, vec3(0), tee2);\n    col = mix(col,vec3(0), g);\n    col = mix(col,vec3(0), g2);\n    col = mix(col,vec3(0), g3);\n    \n   \tcol = mix(col, ylw, d);\n    col = mix(col, vec3(0), a);\n    col = mix(col, vec3(0), a2);\n    col = mix(col, vec3(0), a3);\n    col = mix(col, vec3(0), a4);\n    col = mix(col, vec3(0), a5);\n    \n    col = mix(col, vec3(0), lo);\n\tcol = mix(col, vec3(1,0,0), l);\n    col = mix(col, ylw, b);\n    col = mix(col, vec3(0), eyes);\n    col = mix(col, vec3(0), nose);\n    \n    vec3 bones =  vec3(bo);\n    bones = mix(bones,vec3(1), bo2);\n    bones = mix(bones,vec3(1), bol);\n    bones = mix(bones,vec3(1), bol2);\n    bones = mix(bones, vec3(0), 1.0-dout);\n    bones = mix(bones, vec3(0), jawout);\n    \n    col+=bones;\n    \n    c.rgb = col+w*.15;\n}", "image_inputs": [{"id": 23940, "src": "https://soundcloud.com/leonardo-wyatt/one-piece-soundtrack-the-very", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define R iResolution.xy\n\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat arc(vec2 p, vec2 sa, vec2 sb, float ra, float rb)\n{\n    p*=mat2(sa.x,sa.y,-sa.y,sa.x);\n    p.x = abs(p.x);\n    float q = (sb.y*p.x>sb.x*p.y) ? dot(p.xy, sb) : length(p.xy);\n    return sqrt( dot(p,p)+ra*ra-2.0*ra*q)-rb;\n}\n\n\n\nmat2 rot(float a)\n{\n    float c = cos(a), s=sin(a);\n    return mat2(c, -s, s, c);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 131], [133, 133, 174, 174, 3437]]}
{"id": "tt2BWd", "name": "jh0ker_radialblur", "author": "jh0ker", "description": "attempt at a radial blur", "tags": ["blur", "radial"], "likes": 9, "viewed": 628, "published": 3, "date": "1600196626", "time_retrieved": "2024-07-30T20:45:11.383580", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 origin = vec2(.75, .75);\n    \n    vec2 diff = uv - origin;\n\n    vec4 col = vec4(0.);\n    \n    int steps = 128;\n    float distanceFactor = .4;\n    \n    float fSteps = float(steps);\n    float stepSize = 1. / fSteps;\n    \n    for (int i = 0; i < steps; i++) {\n        float fac = float(i) * stepSize;\n        vec2 pos = uv - diff * (fac * distanceFactor);\n        //col += texture(iChannel0, pos) * stepSize;\n        col += texture(iChannel0, pos) * (float(steps - i) / fSteps) * stepSize;\n    }\n    \n    col *= 2.;\n    \n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ttjfDt", "name": "jh0ker_gaussblur", "author": "jh0ker", "description": "gaussblur implementiation?", "tags": ["blur", "gauss"], "likes": 1, "viewed": 282, "published": 3, "date": "1600193700", "time_retrieved": "2024-07-30T20:45:12.146540", "image_code": "int width = 17;\nfloat weights[17] = float[] (0.05105, 0.05066, 0.04952, 0.04766, 0.04519, 0.0422, 0.03882, 0.03519, 0.03143, 0.02767, 0.02401, 0.02056, 0.01737, 0.0145, 0.01197, 0.00978, 0.00793);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel1, uv) * weights[0];\n    \n    for (int i = 1; i < width; i++) {\n\n        col += texture(\n            iChannel1,\n            uv + vec2(0, i) / iChannelResolution[1].xy\n        ) * weights[i];\n        \n        col += texture(\n            iChannel1,\n            uv - vec2(0, i) / iChannelResolution[1].xy\n        ) * weights[i];\n    }\n    \n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int width = 17;\nfloat weights[17] = float[] (0.05105, 0.05066, 0.04952, 0.04766, 0.04519, 0.0422, 0.03882, 0.03519, 0.03143, 0.02767, 0.02401, 0.02056, 0.01737, 0.0145, 0.01197, 0.00978, 0.00793);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv) * weights[0];\n    \n    for (int i = 1; i < width; i++) {\n\n        col += texture(\n            iChannel0,\n            uv + vec2(i, 0) / iChannelResolution[0].xy\n        ) * weights[i];\n        \n        col += texture(\n            iChannel0,\n            uv - vec2(i, 0) / iChannelResolution[0].xy\n        ) * weights[i];\n    }\n    \n    //col /= float(box);\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 256, 306, 775]]}
{"id": "3ljfDd", "name": "Nebula 17", "author": "Leria", "description": "Light Nebula, the look is close to planetary nebula --> i add some emission colors\nA+mouse: tune density\nC toggle : control sigma_s or albedo", "tags": ["fractal", "noise", "nebula"], "likes": 5, "viewed": 458, "published": 3, "date": "1600182272", "time_retrieved": "2024-07-30T20:45:13.101985", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. ); \n\nfloat fbm_add( vec3 p, float level ) { // in [-1,1]\n    \n    float f = 0.;;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    for(float l = 0. ; l < level ; l++)\n    {\n     \tf += (1./exp2(l))*snoise(p);   p = p*s;\n    }\n\n     return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1./8.;\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p, 5.);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 6.4), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(velocity*velocity*velocity)/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate = disp_turb*fbm(p/4.); //generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        vec3 rgb_t = vec3(0.);\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n                                                 // --- textured bubble model\n            \n            float rad_bubl = 2.36; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); // vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB))/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t//float l = exp(-.5*SQR(d/2.));\n#if 0\n          //float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          //float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            //mask = n;\n#else\n            //rad_bubl -= .2 ;\n             float dr = fbm_add( p*3.2 - 124.17, 4.),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.0*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -.8*dr )   ) ;\n#endif\n            //mask = 1.;\n            \n                                                 // --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = .1;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v*v)/(4.*scale))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(6., .5, .1);   // <<< $PHYS $PARAM (well, part of sigma_t)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); // $TUNE\n            \n            vec3 sigma_t = vec3(0);\n            if(vt <= 0.)\n            {\n                sigma_t = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t0\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                sigma_t = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            sigma_t = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            sigma_t /=10.;\n            \n            rgb_t = exp(-sigma_t);    // <<< local transparency\n            \n            \n            \n            vec3 col_loc = vec3(0.2, .1, 1.)/(sigma_t+1e-5);  // <<< $PHYS $PARAM albedo, = sigma_s/sigma_t\n            if KeyToggle(64+3) col_loc *= absorb_coef; //  $TUNE  control sigma_s rather than albedo\n            \n            \n            // attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s/sigma_t\n            //        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            // e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            //            E_tr = .5 VT³/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            //                 = 12000 *(mask*fbm)³\n            // note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k/10.;           // --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) // energy_transfer_rate \n                                   - val(L.x,L.y,L.z) // energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           // above : diff = abs(Lambert)\n            //dif = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n#define Gauss(x,s) 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 1./ dot(L/L0,L/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl) ) ) ;\n          //float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = source*(.01/size),//* smoothstep(0., 1./size, Gauss(X,std_dev) ),\n                shadow = 1.,\n            reflec = dif;\n            \n            vec3 emission = vec3(.2, .5, 1.);   // <<< $PARAM $PHYS  \n            \n    \t\t                          // --- add current voxel contribution to ray\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow + emission/(sigma_t+1e-3)) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            //c = vec3();\n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(center)-0.5 < 0.)\n\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )/R.y,\n         M =  iMouse.xy/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = iTime/2., degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .5* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n  //sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  //sky =   max(texture(iChannel0,fragCoord/256.+vec2(degree,degree2)).rrr -.8,0.)/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1892, 1892, 1930, 1943, 2217], [2219, 2219, 2244, 2257, 2596], [2598, 2598, 2617, 2617, 2714], [2716, 2735, 2811, 2811, 2858], [2860, 2860, 2892, 2892, 2912], [2914, 2914, 2948, 2948, 2970], [3057, 3057, 3098, 3098, 3134], [3136, 3136, 3222, 3222, 3257], [3259, 3259, 3302, 3302, 3342], [3344, 3344, 3368, 3368, 3416], [3418, 3418, 3458, 3458, 3762], [3764, 3764, 3788, 3788, 3852], [3854, 3854, 3909, 3909, 3970], [3972, 3972, 4020, 4020, 4164], [11424, 11424, 11481, 11481, 12537]]}
{"id": "WdK3zd", "name": "raytracing2d", "author": "Stefano_Liu", "description": "raytracing2d", "tags": ["raytracing"], "likes": 1, "viewed": 300, "published": 3, "date": "1600177198", "time_retrieved": "2024-07-30T20:45:13.867938", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col=sampleRay(uv,iTime);\n\n    // Output to screen\n    fragColor = vec4(powVec3(col,0.67),1.0);\n}\n", "image_inputs": [], "common_code": "//Defines\n#define PI 3.1415926535898\n#define N 512.0\n#define DEPTH 15.0\n\n#define Light 0\n#define Metal 1\n#define Dielect 2\n\n#define IOR 1.3326\n\n#define White vec3(1.52,1.79,1.68)\n#define Black vec3(0.0,0.0,0.0)\n//Structs\n\nstruct ray2d{\n    vec2 o;\n    vec2 d;\n};\n    \nstruct interaction{\n    float t;\n    vec2 p;\n    vec2 n;\n    vec2 wo;\n    vec3 col;\n    int mat;\n};\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n.yx, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat absrand(vec2 n)\n{\n    return fract(abs(sin(dot(n.yx, vec2(12.9898, 78.233)))) * 43758.5453);\n}\n\nvec2 uniformSampleCircle(vec2 st)\n{\n    float r=sqrt(rand(st.xy));\n    float theta=rand(st.yx)*2.0*PI;\n    return vec2(r*cos(theta),r*sin(theta));\n}\nvec2 uniformSampleCircleFromSquare(vec2 st)\n{\n    vec2 v;\n    do\n    {\n    \tv=vec2(rand(st.xy),rand(st.yx));\n        \n    } while(length(v)>=1.0);\n        \n    return v;\n}\nvec2 uniformSamlpleCircleJitter(vec2 st)\n{\n    float x=cos(PI * 2.0 * (rand(st.xy)));\n    float y=sin(PI * 2.0 * (rand(st.yx)));\n    return vec2(x,y);\n}\n\n\nvec2 rayAtT(ray2d ray,float t)\n{ \n    return ray.o + ray.d * t;\n}\n\n\nbool diskHit(ray2d ray,vec2 cen,float r,int material,inout interaction rec)\n{\n\n    rec.mat=material;\n    vec2 oc = ray.o - cen;\n\tfloat a = dot(ray.d, ray.d);\n\tfloat b = dot(ray.d, oc);\n\tfloat c = dot(oc, oc) - r * r;\n\n\tfloat discriminant = (b * b - a * c);\n\tif (discriminant >= 0.0)\n    {\n    \tfloat t = (-b - sqrt(discriminant)) / a;\n\t\tif ( t >= 0.0)\n\t\t{\n\t\t\trec.t = t;\n\t\t\trec.p = rayAtT(ray,t);\n\t\t\trec.n = normalize((rec.p - cen) / r);\n\t\t\trec.wo = vec2(-ray.d);\n            \n\t\t\treturn true;\n\t\t}\n\t\tt = (-b + sqrt(discriminant)) / a;\n\t\tif (t >= 0.0)\n\t\t{\n\t\t\trec.t = t;\n\t\t\trec.p = rayAtT(ray,t);\n\t\t\trec.n = normalize((rec.p - cen) / r);\n\t\t\trec.wo = vec2(-ray.d);\n\t\t\treturn true;\n\t\t}\n\t}\n\n}\nfloat shlick(float cosine, float ior)\n{\n\tfloat r0 = (1.0 - ior) / (1.0 + ior);\n\tr0 = r0 * r0;\n\treturn r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\nray2d refractRay(ray2d r,interaction inte)\n{\n    if (dot(r.d, inte.n) > 0.0)\n    {\n        vec2 normal=-inte.n;\n        return ray2d(inte.p,refract(r.d,normal,IOR));\n    }\n    else\n    {\n        vec2 normal=-inte.n;\n        ray2d result=ray2d(inte.p,refract(r.d,-normal,1.0/IOR));\n        return result;\n\n        float cosine = -dot(result.d, inte.n) / length(r.d);\n        float reflQuan = shlick(cosine, IOR);\n       // return refract(r.d,normal,IOR);\n        \n\n        \n        if (absrand(r.d) >= reflQuan)\n\t\t{\n\t\t\tresult.d = normalize(reflect(r.d,normal));\n\t\t\tresult.o = inte.p - 0.01 * normal;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.d = normalize(reflect(normal, r.d));\n\t\t\tresult.o = inte.p + 0.01 * normal;\n\t\t}\n\n        return result;\n    }\n}\n\nvec3 traceRay(ray2d ray,inout interaction inte,float depth)\n{    \n    ray2d scattered=ray;\n    vec3 sums=vec3(0.0,0.0,0.0);\n    int material;\n    for(depth;depth<DEPTH;depth++)\n    {\n    \t//objects hit\n        if(diskHit(scattered,vec2(0.45,0.35),0.1,Metal,inte))\n        {\n            if(distance(scattered.o, vec2(0.45,0.35)) <= 0.1)\n            {\n                break;\n            }\n            scattered.o=inte.p;\n            scattered.d=reflect(ray.d,inte.n);\n            continue;\n        }\n        else if(diskHit(scattered,vec2(0.7,0.45),0.1,Dielect,inte))\n        {\n            //scattered.o=inte.p;\n            //scattered.d=reflect(ray.d,inte.n);\n            scattered=refractRay(scattered,inte);\n            continue;\n        }\n        else if(diskHit(scattered,vec2(0.5,0.6),0.1,Light,inte))\n        {\n            sums+=White;\n            break;\n        }\n        else \n          \treturn sums;\n\n    }\n   return sums;\n}\n\nvec3 powVec3(vec3 v,float n)\n{\n    return vec3(pow(v.x,n),pow(v.y,n),pow(v.z,n));\n}\n\nvec3 sampleRay(vec2 pos,float time)\n{\n    vec3 sums=vec3(0.0,0.0,0.0);\n    interaction inte;\n    \n    vec2 distPos=pos;\n    \n    for(float n=0.0;n<N;n++)\n    {\n        distPos=pos+n+time;\n        sums+=traceRay(ray2d(pos,normalize(uniformSampleCircle(distPos))),inte,0.0);\n    }\n    return sums/N;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdK3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 258]]}
{"id": "WtjfDt", "name": "PolygonSpiralDrawing(drug mouse)", "author": "Arseny", "description": "inspired by https://www.youtube.com/watch?v=iAHlyoCfhfo\nconvex recomended", "tags": ["2d", "fractal"], "likes": 4, "viewed": 361, "published": 3, "date": "1600168525", "time_retrieved": "2024-07-30T20:45:14.637879", "image_code": "const int N = 4;\n//must be counterclockwise order\nvec2 points[N] = vec2[N](vec2(0., 0.4), vec2(0.), vec2(-0.34641, -0.2), vec2(0.34641, -0.2));\n\n#define points(i) (points[((i) % N + N) % N])\n\nconst int steps = 20;\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat cross2(vec2 a, vec2 b){\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 rot90(vec2 a){\n    return vec2(-a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    points(1) = m;\n    \n    float mask = sdSegment(uv, points(0), points(N - 1));\n    \n    float t = mix(0.17, 0.3, sin(iTime) / 2. + 0.5);\n    \n    for (int k = 0; k < steps; k++){\n        for (int i = 0; i < N; i++){\n            vec2 now = points(i);\n            mask = min(mask, sdSegment(uv, now, points(i + 1)));\n            vec2 np = mix(now, points(i + 1), t);\n            vec2 prev = points(i - 1);\n            if (cross2(now - prev, np - prev) < 0.){\n                // trying to reflect new segment to inside of uncovex polygon but look interesting\n                // if polygon is convex it's not used\n                // actually it's not best way because it's not good with self-crossing\n                vec2 n = normalize(now - prev);\n                vec2 v = np - now;\n                //np = reflect(np - now, rot90(n)) + now;\n                np = 2. * dot(v, n) * n - v + now;\n            }\n            points[i] = np;\n        }\n    }\n    \n    vec3 col = vec3(mask * iResolution.y);\n    //fragColor = vec4( pow( mask * iResolution.y / 3., 1./2.2) );  look bad i think\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 267, 267, 386], [388, 388, 417, 417, 453], [455, 455, 474, 474, 504], [506, 506, 563, 563, 1831]]}
{"id": "WtjfWt", "name": "schlieren", "author": "jh0ker", "description": "*teleports behind you*", "tags": ["buffer"], "likes": 2, "viewed": 298, "published": 3, "date": "1600168065", "time_retrieved": "2024-07-30T20:45:15.400839", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float strength = .95;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv) * strength + texture(iChannel1, uv) * (1. - strength);\n    fragColor = vec4(col.rgb, 1.);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 225]]}
{"id": "tljBDD", "name": "Wobbly Webcam", "author": "jh0ker", "description": "first shader i made", "tags": ["sine", "webcam"], "likes": 5, "viewed": 349, "published": 3, "date": "1600168060", "time_retrieved": "2024-07-30T20:45:16.221644", "image_code": "\n// Source: https://www.geeks3d.com/hacklab/20190225/demo-checkerboard-in-glsl/\nfloat checker(vec2 uv, float repeats) \n{\n  float cx = floor(repeats * uv.x);\n  float cy = floor(repeats * uv.y); \n  float result = mod(cx + cy, 2.0);\n  return sign(result);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 center = vec2(.5, .5);\n    \n    // Config options\n    \n    // Overall strength\n    float effectStrength = 15.;\n    // Exponent to focus the effect on the center\n    float effectPower = 1.3;\n    // Is subtracted afterwards, makes it weaker and cuts off effect on the edges\n    float effectLocal = .4;\n    // Width of the sine waves used for deformation\n    float sineWidth = 20.;\n    \n    // Calculate sine scale factor\n    float scale = effectStrength * max(\n        pow(1. - distance(uv, center), effectPower) - effectLocal, \n    0.);\n    \n    // Normalize for resolution\n    float resolutionScaleFactor = (iResolution.x + iResolution.y) / 1000.;\n    \n    scale *= resolutionScaleFactor;\n    sineWidth *= resolutionScaleFactor;\n    \n    // Wobble\n    vec2 uvWobbly = vec2(\n        fragCoord.x + scale * sin(fragCoord.x / sineWidth + iTime), \n        fragCoord.y + scale * sin(fragCoord.y / sineWidth + iTime * 1.2)\n    ) / iResolution.xy;\n    \n    \n    fragColor = texture(iChannel0, uvWobbly);\n    \n    return;\n    \n    // Test effect with generated checkerboard texture\n    uvWobbly.x *= iResolution.x / iResolution.y;\n    float c = mix(1.0, 0.0, checker(uvWobbly, 10.));\n    fragColor = vec4(c, c, c, 1.0);\n    //fragColor = vec4(scale / 20. * uv.x);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 80, 120, 120, 254], [257, 257, 314, 365, 1678]]}
{"id": "3ljBWt", "name": "Edible Edifices", "author": "dr2", "description": "Chocolate architecture ", "tags": ["wave", "hexagon", "chocolate", "architecture", "building"], "likes": 30, "viewed": 504, "published": 3, "date": "1600155401", "time_retrieved": "2024-07-30T20:45:17.177090", "image_code": "// \"Edible Edifices\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Chocolate architecture (buildings from \"Sand Album\", hexagon waves from \"Paper Rolls\")\n\n#define AA  0  // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nvec2 gId, trkF, trkA, bldCs;\nfloat tCur, dstFar, hgSize, wavHt, emFrac, grRad, pR, pA, bldTp, rc;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt2 = 1.41421, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat CasBldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  qq = q;\n  q.xy -= vec2 (-5., 1.2);\n  d = PrRoundBoxDf (q, vec3 (0.15, 1.2 + rc, 5.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 1.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  d = max (d, - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.6, 0.)), vec2 (0.6, 0.4), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 5.;\n  q.y -= 0.2;\n  d = min (PrCylAnDf (q.xzy, 0.45, 0.05, 1.2 + 0.2), PrCylDf (q.xzy, 0.4, 1.2));\n  dMin = min (dMin, d);\n  q = qq;\n  q.xy -= vec2 (-2., 2.);\n  d = max (max (q.y - 1.8 - 0.3 * q.x, - q.x), - p.y);\n  dMin = min (dMin, d);\n  d = PrRoundBoxDf (q, vec3 (0.15, 2.2 + rc, 2.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 2.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.3, 2.3);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat TwrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 3.5 - rc;\n  d = PrRoundBoxDf (q, vec3 (vec2 (1.3) * (1. - 0.05 * q.y), 3.5).xzy - rc, rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-4., -1.);\n  d = min (d, PrRoundCylDf (q.xzy, 0.8 * (1. - 0.05 * q.y), rc, 2.5));\n  q.x -= 1.7;\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y - 0.8 + 0.2 * q.x * q.x).xzy, vec3 (2., 0.4, 0.1), rc));\n  q.z = abs (q.z);\n  q -= vec3 (-2.5, -1., 1.1);\n  d = min (d, PrRoundCylDf (q.xzy, 0.7 * (1. - 0.05 * q.y), rc, 1.5));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PyrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = max (max (abs (q.y) - 2., - q.x + q.y), min (0.4 - abs (abs (q.z) - 0.6), (q.y - q.x + 0.18 -\n     abs (mod (q.x + q.y - 0.02, 0.4) - 0.2) / sqrt2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.2;\n  d = PrCylAnDf (q.xzy, 0.5, 0.05, 0.2);\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat TajBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (5.8, 0.1, 5.8) - rc, rc);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * (pA - 0.5) + 0.5) / 8.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = abs (q.y) - 2.;\n  q.y = mod (q.y + 0.4, 2.) - 1.;\n  q.z = abs (q.z) - 0.6;\n  d = max (d, max (- q.x, - max (PrCapsDf ((q - vec3 (0., -0.5, 0.)).xzy, 0.4, 1.), - q.y - 0.2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.z = abs (q.z);\n  q -= vec3 (-5., 3.1, 5.);\n  d = PrCylDf (q.xzy, 0.3 - 0.1 * q.y / 3., 3.);\n  dMin = min (dMin, d);\n  q.y -= 3.2;\n  d = PrSphDf (q, 0.3);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.6;\n  d = PrSphDf (q, 2.);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PisBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ht, dh, a, ai, nf, na;\n  nf = 8.;\n  na = 12.;\n  ht = 3.5;\n  q = p;\n  d = PrCylDf (q.xzy, 3., 0.05);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, pi / 4.);\n  q.y -= ht + 0.05;\n  q.xy = Rot2D (q.xy, 0.025 * pi);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  d = PrCylDf (q.xzy, 1., ht);\n  dh = abs (q.y) - ht * (1. + 1. / (4. * nf));\n  q.y = mod (q.y + ht / nf, 2. * ht / nf) - ht / nf;\n  d = min (d, max (dh, PrRoundCylDf (q.xzy, 1.2, rc, ht / (4. * nf))));\n  ai = floor (na * (a - 0.5) + 0.5) / na;\n  q.xz = Rot2D (q.xz, 2. * pi * ai);\n  q.y = abs (q.y) - ht / nf;\n  d = max (d, - PrRoundBoxDf (vec3 (length (q.xz) - 1., q.y, 2. * pi * (abs (a - ai - 0.5) - 0.5 / na)),\n     vec3 (0.2, 0.55 * ht / nf, 0.12) - rc, rc));\n  q.x -= -1.05;\n  d = min (d, max (dh, PrCylDf (q.xzy, 0.08, ht / nf)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 0.4;\n  d = PrRoundBox2Df (vec2 (pR - 6.5, abs (q.y) - 0.4), vec2 (0.25, 0.01), rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (64. * (pA - 0.5) + 0.5) / 64.));\n  q.x = abs (q.x + 6.5) - 0.15;\n  d = min (d, PrCylDf (q.xzy, 0.08, 0.4));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat FrtBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * (pA - 0.5) + 0.5) / 5.));\n  q.xy -= vec2 (-2., 1.4);\n  d = max (max (- q.x, abs (q.y) - 1.4), - PrRoundBoxDf (vec3 (q.x, abs (q.y) - 0.5,\n     mod (q.z + 0.5, 1.) - 0.5), vec3 (0.1, 0.2, 0.15), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x - 2., q.y - 1.4 - 0.3 * q.x), vec2 (2.2, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.xy -= vec2 (-3.5, -0.6);\n  d = max (max (abs (q.x) - 0.4, abs (q.y) - 0.8),\n     - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.2, 0.)), vec2 (0.4, 0.3), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x, q.y - 0.9 + 0.4 * abs (q.x)), vec2 (0.6, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 5.5 * tan (pi / 5.);\n  d = PrCylDf (q.xzy, 0.8, 1.1);\n  r = 0.2 * length (q.xz);\n  q.y -= 1.4 - r;\n  d = min (d, PrCylDf (q.xzy, 1.1, 0.3 - r));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat WvnBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rs, s, h, f, yy;\n  h = 2.5;\n  rs = 0.15;\n  q = p;\n  q.y -= h + rs;\n  f = q.y / h - 1.;\n  yy = abs (q.y) - h;\n  d = max (pR - 2.3 - 0.7 * f * f, yy);\n  q.xz *= 1.4 + 0.4 * f;\n  q.xz = vec2 (20. * pA, length (q.xz) - 10. / pi);\n  d = min (d, length (vec2 (yy, q.z)) - 2. * rs);\n  s = 0.4 * rs * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z + s)),\n     length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z - s))) - rs, yy));\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat PstBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, ss;\n  s = 1.7;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    q.xz = abs (q.xz) - 0.75 * s;\n    ss = s * s;\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    d = min (PrRoundBoxDf (q - vec3 (0., 0.6 * ss - rc, 0.), s * vec3 (0.3, 0.6 * s, 0.3) - rc, rc),\n       PrCylDf ((q - vec3 (0., 1.45 * ss - rc, 0.)).xzy, 0.12 * s, 0.25 * ss));\n    dMin = min (dMin, d);\n    s *= 0.85;\n  }\n  return 0.9 * dMin;\n}\n\nfloat BrgBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.1 + 0.01 * sin (8. * pi * pR);\n  d = max (abs (abs (pR - 5.2) - 1.4) - 0.4, abs (q.y) - 0.1);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 1.5;\n  d = min (PrCylDf (q.xzy, 2.5, 1.5),\n     PrCylDf (vec3 (q.xz, q.y - (2.2 - 0.25 * pR + 0.1 * sin (32. * pi * pA))), 2.8, 0.07));\n  q.y -= 2.16;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.22));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * (pA - 0.5) + 0.5) / 3.));\n  d = max (d, - PrRoundBoxDf (q - vec3 (-2.5, 0.8, 0.), vec3 (0.7, 0.8, 0.7), rc));\n  dMin = min (dMin, d);\n  q.x += 5.2;\n  q.y -= 0.5 - 0.2 * q.x * q.x;\n  d = PrBoxDf (q, vec3 (1.6, 0.1, 0.6));\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.3, 0.5);\n  d = min (d, PrRoundBoxDf (q, vec3 (1.6, 0.3, 0.1) - rc, rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PanBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 1.8;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (4.9, 1.6, 2.9) - rc, rc);\n  q.y = abs (q.y) - 1.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (5.4, 0.1, 3.4) - rc, rc));\n  q = p;\n  q.y -= -1.7;\n  d = min (d, PrRoundBoxDf (q, vec3 (6., 0.1, 4.) - rc, rc));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 1.7, 0.75);\n  q.y -= 0.75;\n  d = min (d, max (max (PrSphDf (q, 2.), - q.y), 0.2 - pR));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = mod (q.xz + 0.5, 1.) - 0.5;\n  d = max (PrCylDf (q.xzy, 0.2, 1.5), max (abs (p.x) - 5.5, abs (p.z) - 3.5));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * (pA - 0.5) + 0.5) / 16.));\n  q.xy -= vec2 (-1.85, 2.2);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.75));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p.xz -= HexToPix (gId * hgSize);\n  dMin = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = SmoothMax (abs (q.x) - 0.48 * sqrt3 * hgSize, q.y - wavHt + 0.05, 0.05);\n  DMIN (1);\n  if (isOcc) {\n    q = p;\n    q.xz = Rot2Cs (q.xz, bldCs);\n    q.y -= wavHt + 0.35;\n    pR = length (q.xz);\n    pA = ((pR > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5;\n    rc = 0.05;\n    d = PrCylDf ((q - vec3 (0., 3.8, 0.)).xzy, 8.21, 3.8);\n    if (d < 0.1) {\n      if (bldTp <= 4.) {\n        if      (bldTp == 1.) d = CasBldgDf (q, dMin);\n        else if (bldTp == 2.) d = TwrBldgDf (q, dMin);\n        else if (bldTp == 3.) d = PyrBldgDf (q, dMin);\n        else /*if (bldTp == 4.)*/ d = TajBldgDf (q, dMin);\n      } else if (bldTp <= 7.) {\n        if      (bldTp == 5.) d = PisBldgDf (q, dMin);\n        else if (bldTp == 6.) d = FrtBldgDf (q, dMin);\n        else /*if (bldTp == 7.)*/ d = WvnBldgDf (q, dMin);\n      } else /*if (bldTp <= 10.)*/ {\n        if      (bldTp == 8.) d = PstBldgDf (q, dMin);\n        else if (bldTp == 9.) d = BrgBldgDf (q, dMin);\n        else if (bldTp == 10.) d = PanBldgDf (q, dMin);\n      }\n      DMIN (2);\n    } else dMin = min (dMin, d);\n    q.y -= -0.2;\n    d = PrRoundCylDf (q.xzy, 8.2, rc, 0.15);\n    DMIN (3);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.3 * sin (0.2 * 2. * pi * p)) +\n     0.1 * tCur, 1.) - 0.5;\n  wavHt = dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y > emFrac);\n  if (isOcc) {\n    bldTp = 1. + floor (10. * (fRand.y - emFrac) / (1. - emFrac));\n    bldCs = sin (2. * pi * fRand.x + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += clamp (2. * h, 0.02, 0.2);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn;\n  float dstObj, sh;\n  bgCol = vec3 (0.5, 0.4, 0.4);\n  emFrac = 0.02;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrObjConf ();\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      if (vn.y > 0.5) {\n        col4 = vec4 (0.8, 0.8, 0.9, 0.1) * (0.8 + 0.2 * Fbm2 (ro.xz));\n        if (isOcc) col4 = mix (vec4 (0.45, 0.25, 0.1, 0.1), col4,\n           smoothstep (8.2, 8.25, length (ro.xz - HexToPix (gId * hgSize))));\n      } else col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.35, 0.17, 0.05, 0.15);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.45, 0.25, 0.1, 0.1);\n    }\n    sh = ObjSShadow (ro + 0.1 * ltDir, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 1200.);\n  hgSize = 11.;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  trkF = 0.2 * vec2 (0.1, 0.17);\n  trkA = 2. * vec2 (1.25, 0.45);\n  vFly = 10.;\n  ro = TrackPath (vFly * tCur);\n  ro.x += 3.5;\n  ro.y += 20.;\n  vd = normalize (TrackVel (vFly * tCur));\n  el += asin (vd.y);\n  az += atan (vd.x, vd.z);\n  el = clamp (el, -0.25 * pi, -0.095 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  dstFar = 500.;\n  ltDir = vuMat * normalize (vec3 (0.3, 0.3, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1200, 1200, 1238, 1238, 2202], [2204, 2204, 2242, 2242, 2823], [2825, 2825, 2863, 2863, 3283], [3285, 3285, 3323, 3323, 4090], [4092, 4092, 4130, 4130, 5265], [5267, 5267, 5305, 5305, 6210], [6212, 6212, 6250, 6250, 6813], [6815, 6815, 6853, 6853, 7356], [7358, 7358, 7396, 7396, 8199], [8201, 8201, 8239, 8239, 9021], [9023, 9023, 9045, 9045, 10387], [10389, 10389, 10411, 10411, 10854], [10856, 10856, 10889, 10889, 11963], [11965, 11965, 11986, 11986, 12241], [12243, 12243, 12280, 12280, 12695], [12697, 12697, 12732, 12732, 13853], [13855, 13855, 13881, 13881, 13961], [13963, 13963, 13988, 13988, 14085], [14087, 14087, 14143, 14143, 15436], [15438, 15438, 15470, 15470, 15570], [15572, 15572, 15618, 15618, 15665], [15667, 15667, 15714, 15714, 15761], [15763, 15763, 15796, 15796, 15823], [15825, 15825, 15867, 15867, 15918], [15920, 15920, 15973, 15973, 16034], [16036, 16036, 16093, 16093, 16257], [16259, 16259, 16302, 16302, 16366], [16368, 16368, 16392, 16392, 16622], [16624, 16624, 16648, 16648, 16708], [16710, 16710, 16732, 16732, 16770], [16772, 16772, 16817, 16817, 16920], [16922, 16922, 16967, 16967, 17005], [17007, 17007, 17043, 17043, 17249], [17250, 17250, 17280, 17280, 17393], [17395, 17395, 17426, 17426, 17490], [17524, 17524, 17548, 17548, 17678], [17680, 17680, 17705, 17705, 17891], [17893, 17893, 17914, 17914, 18069]]}
{"id": "WlSBDt", "name": "easy adaptive sampling: checker", "author": "FabriceNeyret2", "description": "3-pass variant + stratif sampling + kernel (Common:63)\noversample only where aliased Left: none, for reference [url]https://shadertoy.com/view/3ljfRG[/url]\nMouse.x : ref separator   \nSPACE: show oversampled areas (colors = not )\nM: show oversampling level", "tags": ["raytracing", "antialiasing", "sampling", "optimization", "adaptive", "gpmipmap", "spacefungus"], "likes": 22, "viewed": 1028, "published": 3, "date": "1600154963", "time_retrieved": "2024-07-30T20:45:18.072695", "image_code": "// variant of https://shadertoy.com/view/Wt2fzV\n// adapted from https://shadertoy.com/view/3ljfRG\n//          and https://shadertoy.com/view/WtjBzV\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage(out vec4 O, vec2 u) {    \n    pass = 3.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n    \n    O = AArender( u, s+.1*R.x, iChannel0 );    // oversample only where necessary\n  //O = texelFetch(iChannel2, ivec2(u), 0);    // test: show brute image\n  //O = texelFetch(iChannel1, ivec2(u), 0);    // test: show pass1 AA\n  //O = texelFetch(iChannel0, ivec2(u), 0);    // test: show pass2 AA\n\n    if ( keyToggle(32) && O.a==0. )            // SPACE: show red/blue where not oversampled\n           O.r -= .5, O.b += .5;\n    if   keyToggle(64+13) O = O.a - vec4(0,1,2,0); // 'M': show #pass oversampling mask\n        \n    if ( floor(u.x-s+.1*R.x) == 0. ) O = vec4(.3,0,0,1);  // pass0/1 red separator\n    if ( floor(u.x-s       ) == 0. ) O = vec4(.6,0,0,1);  // pass1/2 red separator\n    if ( floor(u.x-s-.1*R.x) == 0. ) O = vec4(1.,0,0,1);  // pass2/3 red separator\n    \n    O = pow( O, vec4(1./2.2) );                // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 5              // pixel oversampling NxN ( only where necessary )\nfloat n = float(N), time, pass = 0.; // pass id\nvec2    R;               // iResolution, that we stupidely can't have in Common\n#define T(U,l)     textureLod(iChannel0, (U)/R, float(l) )\n\n// --- custom function or image or render: FXAA checkerpattern filter  https://www.shadertoy.com/view/wt2fD3\n\n#define map(p) ( (p).y - .1 )   // plane\n\nvoid lookAt(inout vec3 ro, inout vec3 rd, vec3 tg) {\n    vec3 ot = normalize(tg - ro),\n         up = vec3(0, 1, 0),\n         rr = normalize(cross(ot, up));\n         up = cross(rr, ot);\n    rd = mat3(rr, up, ot) * rd;\n}\n\nfloat checkerPattern(vec3 p, float t) { \n    if (t < 0.)  return 1.;  // comment if you wanna go beyond infinity :-p\n    p -= time;\n    p = floor(p);    return float( mod(p.x + p.z, 2.) > 0. ); // base checkers\n // p = sin(3.14*p); return 1.-R.y/3.*p.x*p.z;                // continuous variant\n // p = sin(3.14*p); return clamp( 1.-R.y/3.*p.x*p.z, 0.,1.); // clamped\n}\n\nvec4 render( vec2 u ) {\n    vec3 p = vec3(0, 3.5, 15),           // setup camera\n         D = normalize( vec3( ( 2.*u - R ) / R.y, 1) ); \n         lookAt(p, D, vec3(0));\n#if 1                                    // --- true ray-tracing\n    float t = ( .1 - p.y ) / D.y; p += t * D; \n#else                                    // --- ray-marching\n    float ep = 1e-4, d, t=0.;\n\n    int i = 0;\n    for ( ; i < 50; i++) {               // march\n        d = map(p);                      // shape\n        if (d < ep || t > 120. ) break;  // hit\n        p += d * D, t += d;              // step along ray\n    }\n#endif\n    return vec4( vec3(checkerPattern(p, t)), 0 ); // return color & texture at hit point\n                                         // 0: mark native areas\n}\n\n// --- my adaptive antialiasing: oversample only if neighborhood disagree\n\n              //           /  0. for test. should be 99. for different sampling per pass\n#define hash12(p)  fract(sin( 99.*pass + float(p) * vec2(12.9898, 78.233) ) * 43758.5453)\n\nvec4 AArender( vec2 u, float side, sampler2D iChannel0 ) { // we stupidely can't have iChannel0 in Common\n    vec4  O =  T(u,0), C;                // result of previous pass\n    if (u.x < side) return O;            // no AA at left of side\n    \n  //               / 1, or pass ?\n  //if ( length( T(u,1).rgb - T(u,0).rgb ) > 0. ) { // neighborhood does not agree\n    if ( abs( T(u,1).x - T(u,0).x ) > 2./256. )   { // neighborhood does not agree\n        C = vec4(0);\n        float w = 1., wt = 0.;           // weigth\n        for (int k=0; k<N*N; k++) {      // --- oversampling\n          //vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n;     // subpixel : grid\n          //vec2 D = hash12(k) - .5;                            // subpixel : rand\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. + hash12(k)-.5 ) / n; // stratified\n            D *= 1.5; w = exp(-4.*dot(D,D)); wt += w;           // gaussian kernel filter\n            C += render(  u +  D ) * w;\n        }\n        C *= n*n / wt;                   // normalize by pass weigth (for kernel filter )\n        O *= n*n*(pass-1.);              // restore weigth\n        O += C;                          // add new contribs\n        O /= n*n *pass;                  // normalize by multipass weigth\n        O.a = pass;                      // 1: mark filtered aread\n    }\n  //else                                 // LOD#0 is ok\n    \n    return O;\n}", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    R = iResolution.xy;           // here because stupidely can't be in Common\n    time = iTime;                 // here because stupidely can't be in Common\n\n    O = render(u);                // render brute image (no oversampling)\n}\n", "buffer_a_inputs": [], "buffer_b_code": "// --- Adative oversampling where needed\n\nvoid mainImage(out vec4 O, vec2 u) {\n    pass = 1.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n\n    O = AArender( u, s-.1*R.x, iChannel0 );    // oversample only where necessary\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- Adative oversampling where needed\n\nvoid mainImage(out vec4 O, vec2 u) {\n    pass = 2.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n\n    O = AArender( u, s, iChannel0 );           // oversample only where necessary\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "wtSBWd", "name": "Black Hex wave", "author": "celifrog", "description": "90% Credit to IQ for original! ", "tags": ["wave"], "likes": 1, "viewed": 278, "published": 3, "date": "1600137816", "time_retrieved": "2024-07-30T20:45:19.118898", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==11\n#define AA 1\n#else\n#define AA 2   // make this bigger if you have a storng PC\n#endif\n\n\n// --------------------------------------\n// mod3\n// --------------------------------------\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5*p.x*p.y*k3);\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texturr is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 16.0;\n\nfloat map( vec2 p, in float time )\n{\n    p *=0.10;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);\t\n\treturn kMaxH*f;\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 1.0;\n    \n    ivec2 hid = hexagonID(ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==0 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 200.0/sqrt(300.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -10.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  100.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, but using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally the portal should be traversed and the next hexagon\n// tested.\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 200,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    float he = map(hexagonCenFromID( prismID ), time);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n    float occ = 0.0;\n    \n    int ev = -1;\n    if( faceID==-1 ) { ev=3; prismID += i1; }\n    if( faceID== 1 ) { ev=0; prismID -= i1; }\n    if( faceID==-2 ) { ev=2; prismID += i2*i1*i2; }\n    if( faceID== 2 ) { ev=5; prismID -= i2; }\n    if( faceID==-3 ) { ev=1; prismID += i3; }\n    if( faceID== 3 ) { ev=4; prismID -= i3; }\n\n    if( ev!=0 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=1 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=3 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=4 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=5 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(0.5,0.2+0.8*(-1.0-occ)*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y/kMaxH);\n    }\n    \n    return 1.0-occ*occ*occ*occ*occ*occ*occ*occ*occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(10.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro*ro*ro*ro*ro*ro + rd*t*t*t*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*9131 + prismID.y*1119999;\n\n        // uvs\n        vec2 uv = (faceID==114111111) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += ce*ce++*ce++*ce++*ce++*ce++*ce++*ce*ce*ce*ce*ce*ce*ce*ce*ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 16.1+550.9*float((id>>13)&66)/355.0;\n        id = hash(id); mate  = ( ((id>>118)&1115)==0 ) ? vec3(11.7,0.0,0.0) : mate;\n        //vec3 tex = pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.9,0.8));\n        vec3 tex = vec3(0.15,5.09,0.07)+0.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        \n        mate *= tex*tex*tex;\n\n        \n        // lighting\n        float occ = calcOcclusion( pos, nor, time, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(0.11,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*tex.x*-12.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(50.0,0.15,ref.y)*\n               (1.04 + 0.96*pow(fre,995.0))*\n              castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(12.0), 1.0-exp2(-1.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of*of*of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 4.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0)*sin(fragCoord.x*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA*AA*AA*AA*AA);\n        #else\n        float time = iTime*iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -5.001;\n        float an = 3.0/time + 520.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 0.9+0.1*(p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.x*uu + p.x*vv +  2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 5.3*sqrt(ra.x*ra.x*ra.x*ra.x*ra.x*ra.x*ra.x)*vec2(cos(16.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col*-col;\n\t}\n\ttot /= float(AA*AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(1.0+tot+tot+tot+tot+tot);\n    tot = tot*tot*(13.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.5)*-1.1;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.x*p.y*p.x*p.x*p.x*p.x*p.x*p.x*p.x*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[681, 773, 792, 792, 1439], [1441, 1548, 1567, 1567, 1622], [1625, 1741, 1769, 1769, 2136], [2138, 2138, 2176, 2176, 2257], [2505, 2505, 2541, 2541, 2745], [2747, 2909, 3020, 3020, 4995], [4997, 5229, 5291, 5291, 6770], [6974, 6974, 6997, 6997, 7030], [7032, 7032, 7173, 7173, 7638], [7640, 7640, 7837, 7837, 8518], [8722, 8722, 8853, 8853, 10879], [10885, 10885, 11048, 11048, 11485], [11952, 11952, 12070, 12070, 13620], [13813, 13813, 13867, 13882, 15676]]}
{"id": "tlBfDt", "name": "pacman-caminando-v2", "author": "jorge2017a1", "description": "pacman-caminando-v2", "tags": ["pacmancaminandov2"], "likes": 2, "viewed": 257, "published": 3, "date": "1600136825", "time_retrieved": "2024-07-30T20:45:20.178066", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 ) \n\nfloat sdSphere( vec3 p, float s )\n\t{    return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b ) \n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )   \n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdEllipsoid( vec3 p, vec3 r )\n\t{ float k0 = length(p/r);   float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1; }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB) \n{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB) \n{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n    float c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang){\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 BocaSonrisa(vec3 p){\n \tvec3 res = vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(3.0,3.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(2.0,3.5) );\n    float sdb1= sdBox(p-vec3(0.0,1.0,0.0), vec3(4.2,3.0,3.6));   \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    res =opU3(res, vec3(dif,3.0,MATERIAL_NO));        \n    return res;\n}\n\nvec3 CabezaVersionIII(vec3 p){   \n\tvec3 res = vec3(9999.0, -1.0,-1.0);\n    \n    float CorneaDer= sdCylinderXY(p-vec3(2.5+sin(iTime),3.0,-3.0), vec2(0.5,5.3));\n    float CorneaIzq=sdCylinderXY(p-vec3(-2.5+sin(iTime),3.0,-3.0), vec2(0.5,5.3));\n    float OjoDer= sdCylinderXY(p-vec3(2.5,2.0,-3.0), vec2(2.0,5.0));\n    float OjoIzq= sdCylinderXY(p-vec3(-2.5,2.0,-3.0), vec2(2.0,5.0));\n    float sdCabeza= sdSphere(p-vec3(0.0,0.0,0.0), 6.5 );\n    //------------rotar piernas y pies\n    float posx=2.5; //es el centro del objeto\n    float posy=2.0; //es el centro del objeto\n    \n    vec3 pp1=p;\n     //pp1.x=pp1.x-posx;\n       pp1.y=pp1.y-posy;\n     pp1.yz = rotatev2(pp1.yz, -sin(iTime*2.0)*0.5 );\n    // pp1.x=pp1.x+posx;\n       pp1.y=pp1.y+posy;\n     vec3 pp2=p;\n     //pp2.x=pp2.x-posx;\n       pp2.y=pp2.y-posy;\n     pp2.yz = rotatev2(pp2.yz, -sin(iTime*2.0+PI)*0.5 );\n     //pp2.x=pp2.x+posx;\n       pp2.y=pp2.y+posy;\n    \n    //------------rotar piernas y pies\n    float sdt1=sdCylinderXZ(pp2-vec3(-6.2,-3.0,0.0), vec2(1.0,4.0) ); //brazo\n    float sdt2= sdCylinderXZ(pp1-vec3(6.2,-3.0,0.0), vec2(1.0,4.0) ); //brazo\n    float sdt3=sdCylinderXZ(pp1-vec3(-2.0,-6.0,0.0), vec2(1.0,4.0) ); //piernas\n    float sdt4= sdCylinderXZ(pp2-vec3(2.0,-6.0,0.0), vec2(1.0,4.0) ); //piernas\n    \n    sdCabeza= unionSDF(sdCabeza, sdt1); \n    sdCabeza= unionSDF(sdCabeza, sdt2); \n    sdCabeza= unionSDF(sdCabeza, sdt3); \n    sdCabeza= unionSDF(sdCabeza, sdt4); \n    \n    \n    float sdCabezaOriginal=sdCabeza;\n    //diferencia ojo-cornea Izq y Der\n    //------------oooooooo--------------\n    float difOjoCorneaDer= differenceSDF(OjoDer, CorneaDer);   \n    float difOjoCorneaIzq= differenceSDF(OjoIzq, CorneaIzq);   \n    \n    \n    float intersecionOjoCorneaDer= intersectSDF(OjoDer,CorneaDer);\n    float intersecionOjoCorneaIzq= intersectSDF(OjoIzq,CorneaIzq);\n    //------------oooooooo--------------\n    //diferencia cabeza-ojo Der\n    float difCabezaOjoDer= differenceSDF(sdCabeza, OjoDer);   \n    float intersecionCabezaOjoDer= intersectSDF(sdCabeza,OjoDer);\n    float intersecionCabezaCorneaDer= intersectSDF(intersecionCabezaOjoDer,intersecionOjoCorneaDer);\n    //------------oooooooo--------------\n    //diferencia cabeza-ojo IZQ\n    sdCabeza=difCabezaOjoDer;\n    float difCabezaOjoIzq= differenceSDF(sdCabeza, OjoIzq); \n    float intersecionCabezaOjoIzq= intersectSDF(sdCabeza,OjoIzq);\n    float intersecionCabezaCorneaIzq= intersectSDF(intersecionCabezaOjoIzq,intersecionOjoCorneaIzq);\n    //------------oooooooo--------------\n    res =opU3(res, vec3(difCabezaOjoDer,24.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaOjoDer,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaDer,0.0,MATERIAL_NO));  \n    \n   res =opU3(res, vec3(difCabezaOjoIzq,24.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaOjoIzq,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaIzq,0.0,MATERIAL_NO));   \n   \n    ///------------Boca\n    sdCabeza=sdCabezaOriginal;\n    vec3 rBoca= BocaSonrisa(p-vec3(0.5,1.0,-7.5));\n    float boca=rBoca.x;\n    float difCabezaboca= differenceSDF(sdCabeza, boca);   \n    float intersecionCabezaBoca= intersectSDF(sdCabeza,boca);\n    res =opU3(res, vec3(intersecionCabezaBoca,2.0,MATERIAL_NO)); \n    \n    \n    //manos\n    float mano1= sdSphere(pp2-vec3(-6.2,-7.0,0.0), 1.5 );\n    float mano2= sdSphere(pp1- vec3(6.2,-7.0,0.0), 1.5 );\n    res =opU3(res, vec3(mano1,11.0,MATERIAL_NO)); \n    res =opU3(res, vec3(mano2,10.0,MATERIAL_NO)); \n    //pies de otro color\n    float sdt5=sdEllipsoid(pp1-vec3(-2.0,-10.0,0.0), vec3(1.0,1.0,2.0));  //pies\n    float sdt6=sdEllipsoid(pp2-vec3(2.0,-10.0,0.0), vec3(1.0,1.0,2.0)); //pies\n    res =opU3(res, vec3(sdt5,13.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdt6,14.0,MATERIAL_NO)); \n    return res;\n}   \n\nfloat planodeforme(vec3 pp){\n    vec3 p= pp;\n    float h = dot(sin(p - cos(p.yzx*1.5)), vec3(.3));\n    h += dot(sin(p*3. - cos(p.yxz*3.3)), vec3(0.2/3.));\n    return p.y + 1. + h;     \n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res, pp, po;\n    po=p;\n    po.y=po.y-5.0;\n    res = vec3(9999.0, -1.0,-1.0);\n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 35.0-p.y; //piso sup\n    float planod1= planodeforme(p);\n    p.x=p.x-itime;\n    res =opU3(res, vec3(planeDist1+planod1,104.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2-planod1,32.0,MATERIAL_NO)); //inf\n    p.y=p.y-11.0;\n    p= rotate_y(p, radians(30.0+90.0*sin(iTime+PI)*0.5));\n    vec3 rescabeza= CabezaVersionIII(p);\n    res =opU3(res, rescabeza); \n    //return (dist, id_color, id_material)\n    return res;\n}\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color){\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n\t\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n     if (i==104 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.23,1.2,0.31); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {  return result; }\n   \t\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n  if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color)); colobj=coltex;\t}\n    return colobj;\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*4.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n    vec3 ro=vec3(t,3.0,-30.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n\n    light_pos1+=ro;  light_pos2+=ro;\n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 15.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\nmat2 rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n//-----------------------\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\nif (i==3 ) {return vec3(0,255,0)/255.0; }\nif (i==4 ) {return vec3(0,0,255)/255.0; }\nif (i==5 ) {return vec3(255,255,0)/255.0; }\nif (i==6 ) {return vec3(0,255,255)/255.0; }\nif (i==7 ) {return vec3(255,0,255)/255.0; }\nif (i==8 ) {return vec3(192,192,192)/255.0; }\nif (i==9 ) {return vec3(128,128,128)/255.0; }\nif (i==10 ) {return vec3(128,0,0)/255.0; }\nif (i==11 ) {return vec3(128,128,0)/255.0; }\nif (i==12 ) {return vec3(0,128,0)/255.0; }\nif (i==13 ) {return vec3(128,0,128)/255.0; }\nif (i==14 ) {return vec3(0,128,128)/255.0; }\nif (i==15 ) {return vec3(0,0,128)/255.0; }    \nif (i==16 ) {return vec3(255, 204, 188)/255.0; }\nif (i==17 ) {return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) {return vec3(0.5, 0.5, 0.8); }\nif(i== 19 ) {return vec3(1, 0.5, 0);} \nif(i== 20 ) {return vec3(1.0, 1.0, 1.0);} \nif(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);} \nif(i== 22 ) {return vec3(0, 1, 1);} \nif(i== 23 ) {return vec3(85./255., 205./255., 252./255.);} \nif(i== 24 ) {return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );} \nif(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \nif(i== 26 ){ return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n\nif(i== 27 ) { float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n\t\t\treturn vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; } \nif(i== 28 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0);} \nif(i== 29 ) { return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );   } \nif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \nif(i== 31 ) { return vec3(0.0, 0.6, 0.0);}\nif(i== 32 ) {return vec3(0.5, 0.6, 0.6); } \n \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 272, 272, 296], [297, 297, 330, 330, 414], [415, 415, 456, 456, 551], [552, 552, 593, 593, 688], [689, 689, 731, 731, 826], [827, 827, 865, 865, 945], [946, 990, 1036, 1036, 1063], [1065, 1065, 1108, 1108, 1135], [1137, 1137, 1185, 1185, 1213], [1214, 1285, 1318, 1318, 1413], [1415, 1415, 1448, 1448, 1541], [1543, 1543, 1576, 1576, 1669], [1671, 1671, 1704, 1704, 1801], [1803, 1803, 1828, 1828, 2236], [2238, 2238, 2268, 2268, 6024], [6029, 6029, 6057, 6057, 6215], [6216, 6256, 6281, 6281, 6857], [6858, 6903, 6969, 6969, 7342], [7343, 7394, 7417, 7417, 7605], [7606, 7669, 7702, 7702, 8141], [8143, 8197, 8234, 8234, 8468], [8469, 8503, 8552, 8552, 8853], [8854, 8888, 8968, 8968, 9489], [9491, 9543, 9636, 9636, 9872], [9873, 9922, 9979, 9979, 11102]]}
{"id": "ttBBDt", "name": "Hip", "author": "Arseny", "description": "rly?", "tags": ["2d"], "likes": 0, "viewed": 218, "published": 3, "date": "1600126685", "time_retrieved": "2024-07-30T20:45:21.004856", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define pi (3.14159265359)\n\nconst float R = 0.4;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdInfTriPrism( vec3 p, float r )\n{\n  vec3 q = abs(p);\n  return q.x*0.866025+p.y*0.5-r*0.5;\n}\n\nfloat sdScrewPrism(vec3 p){\n    const float k = 0.5; // or some other amount\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    p.z = abs(p.z) + 1.;\n    vec3  q = vec3((m*p.xy), p.z);//vec3(m*p.xz,p.y);\n    return sdTriPrism(q, vec2(0.5, 10.));\n}\n\nfloat GetDist(vec3 p) {\n    //float d = sdTriPrism(p, vec2(0.5, 20.));\n    float d = -sdScrewPrism(p);\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec2 myRot(float d){\n    return vec2(0., 1.) * Rot((d / R / 3.) * pi * 2.) * d;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    /*vec3 ro = vec3(0, 0, 0.5 + mod(iTime / 3., 4.5 + 0.5 - 0.25 - 0.125 + 0.125 / 2.));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., -1.3), 0.5);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif * (-(p.z - 4.) / 10.);\n        col += sin(p.z * 40.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    */\n    // experimental\n    /*\n    float r = length(uv);\n    vec2 pv = vec2(r, 1. - atan(uv.x, uv.y) / pi / 2. - 0.5);\n    //uv *= Rot(r);\n    vec2 lv = pv;\n    pv.y += r / R / 3.;\n    \n    vec2 nv = vec2(-1., 0.) * Rot(pv.y * pi * 2.) * pv.x;\n    \n    col = vec3(nv, 0.);\n    vec2 tmpPoint = vec2(0., max(0., nv.y));\n    float di = length(nv - tmpPoint);\n    di = min(di, abs(lv.y - 1. / 3.));\n    \n    float k = 10.;\n    float id = floor(pv.x / R * k + 0.5) / k;\n    float tmpd = (id) * R;\n    \n    float mask = smoothstep(0., 0.01, di);\n    \n    mask = abs(pv.x - tmpd) * 100.;mix(10., 40., sin(iTime) / 2. + 0.5);//20.;\n    mask = min(length(myRot(tmpd) - uv) * 100., 1.);\n    */\n    //mask = abs(nv.x - 0.25) * 100.;\n    //mask *= id;\n    \n    //mask *= pv.x;\n    \n    //mask = nv\n    \n    float k = 3.;\n    \n    // polar coordinates normalized from 0. to 1. angle. zero angle at vec2(0, -1.)\n    vec2 lv = vec2(length(uv), 1. - atan(uv.x, uv.y) / pi / 2. - 0.5); \n    \n    lv.y = fract(lv.y + 1. / k / 2.); // little shift of angle for\n    \n    vec2 nv = uv * Rot(-floor(lv.y * k) / k * pi * 2.); // rotating to bottom segment  \n    \n    float mask = abs(nv.y + 0.2) * 100.; // distance to side in bottom segment\n    \n    float t = mix(0.07, 0.3, sin(iTime) / 2. + 0.5);\n    //nv = nv * Rot(0.1 * pi * 2. / k); // rotating to bottom segment\n    //mask = min(mask, abs(nv.y + 0.15) * 100.);\n    vec2 first = vec2(0., -R) * Rot(-1. / k / 2. * pi * 2.);\n    vec2 second = first * Rot(1. / 3. * pi * 2.);\n    vec2 third = second * Rot(1. / 3. * pi * 2.);\n    for (float i = 0.; i < 50.; i++){\n        vec2 nfirst = mix(first, second, vec2(t));\n        vec2 nsecond = mix(second, third, vec2(t));\n        vec2 nthird = mix(third, first, vec2(t));\n        //mask = sdSegment(nv, first, second) * 100.;\n        mask = min(mask, sdSegment(uv, nfirst, nsecond) * 100.);\n        mask = min(mask, sdSegment(uv, nsecond, nthird) * 100.);\n        mask = min(mask, sdSegment(uv, nthird, nfirst) * 100.);\n        first = nfirst;\n        second = nsecond;\n        third = nthird;\n    }\n    \n    \n    col = vec3(mask);\n    //col = vec3(uv, 0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBDt.jpg", "access": "api", "license": "mit", "functions": [[1525, 1525, 1544, 1544, 1606], [1608, 1608, 1630, 1630, 1724], [1726, 1726, 1755, 1755, 1836], [1838, 1838, 1874, 1874, 1957], [1959, 1959, 1999, 1999, 2057], [2059, 2059, 2086, 2086, 2340], [2342, 2342, 2365, 2412, 2465], [2467, 2467, 2501, 2501, 2712], [2714, 2714, 2738, 2738, 2928], [2930, 2930, 2980, 2980, 3171], [3173, 3173, 3193, 3193, 3254], [3256, 3256, 3308, 3308, 3427], [3431, 3431, 3488, 3488, 6331]]}
{"id": "wtSBDt", "name": "CylinderDeformText", "author": "Del", "description": "CylinderDeformText test", "tags": ["deform", "font", "cylinder"], "likes": 12, "viewed": 352, "published": 3, "date": "1600124634", "time_retrieved": "2024-07-30T20:45:21.768319", "image_code": "// cylinder deform text test - Del 14/09/2020\n\n#define AA 1\t// increase this to 2 if you are cold...\nfloat mat;\t\t// dirty material\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat Sampx( int iChar, vec2 vCharUV )\n{\n    vec2 iChPos = vec2( mod(float(iChar),16.0), iChar / 16 );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0;\n    return textureLod( iChannel0, vUV, 0.0 ).w - 0.5 ;\n}\n\nint GetTxChar (int _nc)\n{\n    if(_nc==0) return(0x53);\n    if(_nc==1) return(0x48);\n    if(_nc==2) return(0x41);\n    if(_nc==3) return(0x44);\n    if(_nc==4) return(0x45);\n    if(_nc==5) return(0x52);\n    if(_nc==6) return(0x54);\n    if(_nc==7) return(0x4f);\n    if(_nc==8) return(0x59);\n    return 32;\n}\n\nfloat chars(vec3 p)\n{\n    float cc1 = pModInterval1(p.z,0.8,-2.0,2.0); \t\t// vertical repeat\n    p = p.xzy;\n    p.x = -p.x;\n   \tp.yz *= rot(3.141);\n        \n    float c1 = pModInterval1(p.x,0.8,-5.0,5.0);\n    float zdist = 0.25+(0.5+sin(cc1*c1+iTime*4.0)*0.5)*0.2;\n    vec3 r1 = p;\n\tint charid = GetTxChar(int(c1+4.0));\n\tfloat symbolDist = Sampx( charid, (r1.xy+vec2(0.5,0.5)) ) - 0.00001;\n\tfloat boxdist2 = sdBox(r1-vec3(0.0,0.0,-0.25), vec3(0.35 , 0.35, 0.2));\n\tfloat boxdist = sdBox(r1-vec3(0.0,0.0,zdist), vec3(0.5 , 0.5, zdist));\n    symbolDist = max(boxdist,symbolDist);\n    mat = step(symbolDist,boxdist2)*0.5 + ((mod(iTime*10.0,200.0)+c1+cc1)/25.0);\n    symbolDist = min(boxdist2,symbolDist);\n    return symbolDist;\n}\n\nfloat map( in vec3 pos )\n{\n    mat=0.0;\n\n    // Deform Space...\n    float len = 32.0+sin(iTime*1.3)*17.0;\n    float rad =  (1.0/(3.141*2.0)*len);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    if (iMouse.z>0.5)\n    {\n        dp=pos.zyx;//flat\n        dp.xy *= rot(4.7115);\n    }\n\tfloat dd = chars(dp.zxy);\n    return dd*0.5;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.5+sin(iTime)*0.5;\n    \n\tvec3 ro = vec3( 10.0*cos(an), 10.0*sin(an),sin(iTime*1.44)*3.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<100; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n\t\t\tvec3 _col = hsv2rgb(vec3(mat,0.55,0.6));\n            col = _col*amb + _col*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 163, 163, 250], [252, 252, 273, 273, 341], [344, 344, 417, 417, 703], [705, 705, 745, 745, 912], [914, 914, 939, 939, 1217], [1219, 1219, 1240, 1240, 1943], [1945, 1945, 1971, 1971, 2349], [2351, 2351, 2373, 2437, 2584], [2587, 2633, 2665, 2665, 2903]]}
{"id": "ttSBWt", "name": "pacman-caminando-v1", "author": "jorge2017a1", "description": "pacman-caminando", "tags": ["pacmancaminando"], "likes": 3, "viewed": 297, "published": 3, "date": "1600115815", "time_retrieved": "2024-07-30T20:45:22.805546", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 ) \n\n\nfloat sdSphere( vec3 p, float s )\n\t{    return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b ) \n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )     \n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )  \n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )   \n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdEllipsoid( vec3 p, vec3 r )\n\t{ float k0 = length(p/r);   float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1; }\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB) \n{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB) \n{ return max(distA, -distB);}\n//-------------------------------------------\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) {\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi){\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang){\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 BocaSonrisa(vec3 p){\n \tvec3 res = vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(3.0,3.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(2.0,3.5) );\n    float sdb1= sdBox(p-vec3(0.0,1.0,0.0), vec3(4.2,3.0,3.6));   \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    res =opU3(res, vec3(dif,3.0,MATERIAL_NO));        \n    return res;\n}\n\nvec3 CabezaVersionIII(vec3 p){   \n\tvec3 res = vec3(9999.0, -1.0,-1.0);\n    \n    float CorneaDer= sdCylinderXY(p-vec3(2.5+sin(iTime),3.0,-3.0), vec2(0.5,5.3));\n    float CorneaIzq=sdCylinderXY(p-vec3(-2.5+sin(iTime),3.0,-3.0), vec2(0.5,5.3));\n    float OjoDer= sdCylinderXY(p-vec3(2.5,2.0,-3.0), vec2(2.0,5.0));\n    float OjoIzq= sdCylinderXY(p-vec3(-2.5,2.0,-3.0), vec2(2.0,5.0));\n    float sdCabeza= sdSphere(p-vec3(0.0,0.0,0.0), 6.5 );\n    //------------rotar piernas y pies\n    float posx=2.5; //es el centro del objeto\n    vec3 pp1=p;\n     pp1.x=pp1.x-posx;\n     pp1.yz = rotatev2(pp1.yz, -sin(iTime*2.0)*0.5 );\n     pp1.x=pp1.x+posx;\n     vec3 pp2=p;\n     pp2.x=pp2.x-posx;\n     pp2.yz = rotatev2(pp2.yz, -sin(iTime*2.0+PI)*0.5 );\n     pp2.x=pp2.x+posx;\n    //------------rotar piernas y pies\n    float sdt1=sdCylinderXZ(pp2-vec3(-6.2,-3.0,0.0), vec2(1.0,4.0) );\n    float sdt2= sdCylinderXZ(pp1-vec3(6.2,-3.0,0.0), vec2(1.0,4.0) );\n    float sdt3=sdCylinderXZ(pp1-vec3(-2.0,-6.0,0.0), vec2(1.0,4.0) ); //piernas\n    float sdt4= sdCylinderXZ(pp2-vec3(2.0,-6.0,0.0), vec2(1.0,4.0) ); //piernas\n    float sdt5=sdEllipsoid(pp1-vec3(-2.0,-10.0,0.0), vec3(1.0,1.0,2.0));  //pies\n    float sdt6=sdEllipsoid(pp2-vec3(2.0,-10.0,0.0), vec3(1.0,1.0,2.0)); //pies\n    \n    sdCabeza= unionSDF(sdCabeza, sdt1); \n    sdCabeza= unionSDF(sdCabeza, sdt2); \n    sdCabeza= unionSDF(sdCabeza, sdt3); \n    sdCabeza= unionSDF(sdCabeza, sdt4); \n    \n    sdCabeza= unionSDF(sdCabeza, sdt5); \n    sdCabeza= unionSDF(sdCabeza, sdt6); \n    \n    float sdCabezaOriginal=sdCabeza;\n    //diferencia ojo-cornea Izq y Der\n    //------------oooooooo--------------\n    float difOjoCorneaDer= differenceSDF(OjoDer, CorneaDer);   \n    float difOjoCorneaIzq= differenceSDF(OjoIzq, CorneaIzq);   \n    \n    \n    float intersecionOjoCorneaDer= intersectSDF(OjoDer,CorneaDer);\n    float intersecionOjoCorneaIzq= intersectSDF(OjoIzq,CorneaIzq);\n    //------------oooooooo--------------\n    //diferencia cabeza-ojo Der\n    float difCabezaOjoDer= differenceSDF(sdCabeza, OjoDer);   \n    float intersecionCabezaOjoDer= intersectSDF(sdCabeza,OjoDer);\n    float intersecionCabezaCorneaDer= intersectSDF(intersecionCabezaOjoDer,intersecionOjoCorneaDer);\n    //------------oooooooo--------------\n    //diferencia cabeza-ojo IZQ\n    sdCabeza=difCabezaOjoDer;\n    float difCabezaOjoIzq= differenceSDF(sdCabeza, OjoIzq); \n    float intersecionCabezaOjoIzq= intersectSDF(sdCabeza,OjoIzq);\n    float intersecionCabezaCorneaIzq= intersectSDF(intersecionCabezaOjoIzq,intersecionOjoCorneaIzq);\n    //------------oooooooo--------------\n    res =opU3(res, vec3(difCabezaOjoDer,24.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaOjoDer,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaDer,0.0,MATERIAL_NO));  \n    \n   res =opU3(res, vec3(difCabezaOjoIzq,24.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaOjoIzq,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaIzq,0.0,MATERIAL_NO));   \n   \n    ///------------Boca\n    sdCabeza=sdCabezaOriginal;\n    vec3 rBoca= BocaSonrisa(p-vec3(0.5,1.0,-7.5));\n    float boca=rBoca.x;\n    float difCabezaboca= differenceSDF(sdCabeza, boca);   \n    float intersecionCabezaBoca= intersectSDF(sdCabeza,boca);\n    res =opU3(res, vec3(intersecionCabezaBoca,2.0,MATERIAL_NO)); \n    return res;\n}   \n\n\n\n\n\nvec3 ArbolcaseroFruta(vec3 p){ \n   vec3 res = vec3(9999.0, -1.0,-1.0);\n   float sdcy1= sdCylinderXY(p-vec3(-0.5,1.0,0.0), vec2(1.5,0.5) );\n   float sdcy2= sdCylinderXY(p-vec3(0.0,0.5,-0.5), vec2(1.5,0.5) );\n   float sdcy3= sdCylinderXY(p-vec3(0.5,-0.5,0.25), vec2(1.5,0.5) );\n   float sdcy4= sdCylinderXY(  p-vec3(-1.5,-0.5,-0.25), vec2(1.5,0.5) );\n   float sdbor1=sdRoundBox(  p-vec3(-0.25,-3.0,0.0),  vec3(0.5,1.2,0.5), 0.25 );\n    //frutas\n   float sdcy5= sdCylinderXY(  p-vec3(0.0,0.5,-0.5), vec2(0.15,0.5) );\n   float sdcy6= sdCylinderXY(  p-vec3(0.8,0.75,-0.5), vec2(0.15,0.5) );\n   float sdcy7= sdCylinderXY(  p-vec3(0.5,-0.5,0.25), vec2(0.15,0.5) );\n   float sdcy8= sdCylinderXY(  p-vec3(0.5,0.5,0.25), vec2(0.15,0.5) );\n   float sdcy9= sdCylinderXY(  p-vec3(-1.5,-0.5,-0.25), vec2(0.15,0.5) );\n   \tres =opU3(res, vec3(sdcy1,31.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy2,32.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy3,33.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy4,31.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbor1,11.0,MATERIAL_NO));\n    \n    res =opU3(res, vec3(sdcy5,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy6,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy7,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy8,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy9,2.0,MATERIAL_NO)); \n    \n   return res; \n}   \n\n\nvec3 CerroCasero(vec3 p){\n  vec3 res = vec3(9999.0, -1.0,-1.0);\n   float sdcy1= sdCylinderXY(  p-vec3(-3.5,3.0,0.0), vec2(3.5,0.5) );\n   float sdcy2= sdCylinderXY(  p-vec3(0.3,2.5,-0.5), vec2(4.5,0.5) );\n   float sdcy3= sdCylinderXY(  p-vec3(4.5,-3.5,0.25), vec2(4.5,0.5) );\n   float sdcy4= sdCylinderXY(  p-vec3(-4.5,-5.5,-0.25), vec2(6.5,0.5) );\n   \n    res =opU3(res, vec3(sdcy1,36.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy2,37.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy3,36.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy4,37.0,MATERIAL_NO));  \n    \n  return res; \n}   \n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ){\t\n\tvec3 res;\n    vec3 pp, po;\n    po=p;\n    po.y=po.y-5.0;\n    \n    res = vec3(9999.0, -1.0,-1.0);\n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    p.x=p.x-itime;\n    \n    res =opU3(res, vec3(planeDist1,104.0,MATERIAL_NO)); //inf\n   \tp.y=p.y-11.0;\n    p= rotate_y(p, radians(30.0+90.0*sin(iTime+PI)*0.5));\n    \n    vec3 q1=po;\n    q1.z=q1.z-11.0;\n    q1.y+=1.0;\n    float cx1=30.0;\n    q1.x = mod(q1.x+0.5*cx1,cx1)-0.5*cx1;\n    \n    vec3 sarbol2= ArbolcaseroFruta(q1-vec3(5.0,0.0,0.0));\n    res =opU3(res, sarbol2); \n    vec3 sarbol3= ArbolcaseroFruta(q1-vec3(-5.0,0.0,3.0));\n    res =opU3(res, sarbol3); \n    vec3 scerro1= CerroCasero(q1-vec3(0.0,0.0,5.0));\n    res =opU3(res, scerro1); \n\n    vec3 rescabeza= CabezaVersionIII(p);\n    res =opU3(res, rescabeza); \n    //return (dist, id_color, id_material)\n    \n    return res;\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n  \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//----------------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i){\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    if (i==104 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.23,1.2,0.31); }\n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos){   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    { return result; }\n   \t\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material){\n   \tvec3 colobj;\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));  colobj=coltex;\t}\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t; t=mod(iTime*4.0,360.0); itime=t; \n\tmObj.blnShadow=false;\n \tlight_pos1   = vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n\tlight_pos2   = vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n    vec3 ro=vec3(t,3.0,-30.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;  light_pos2+=ro;\n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd; mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\nvec3 hsv(vec3 c){\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n//por shane\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n\n}\n\n//----------------------------------------------------\nvec3 getColor(int i){\n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\n   \n    if(i== 19 ) {return vec3(1, 0.5, 0);    } \n    if(i== 20 ) {return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 ) {return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 ) {return vec3(0, 1, 1);} \n    if(i== 23 ) {return vec3(85./255., 205./255., 252./255.); } \n     if(i== 24 ){return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    if(i== 25 ) {return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    if(i== 26 ) {return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n    if(i== 27 ){ \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n    if(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \n    if(i== 31 ) { return vec3(0.0, 0.6, 0.0);}\n  \tif(i== 30 ) { return vec3(0.1, 0.5, 1.0);}   \n    if(i== 31 ) { return vec3(0.0, 0.6, 0.0);}\n    if(i== 32 ) { return vec3(0.0, 1.0, 0.0);}\n    if(i== 33 ) { return  vec3(0.1, 1.0, 0.2);}\n      //--------tono cafe\n    if(i== 34 ) { return hsv(vec3(0.2, 1.0, 0.25));}   \n    if(i== 35 ) { return hsv(vec3(0.2, 1.0, 0.3));}\n    if(i== 36 ) { return hsv(vec3(0.1, 1.0, 0.3));}\n    if(i== 37 ){ return  hsv( vec3(0.1, 1.0, 0.2));}\n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 276, 276, 300], [301, 301, 334, 334, 418], [419, 419, 465, 465, 552], [553, 553, 592, 592, 654], [655, 655, 694, 694, 789], [790, 790, 831, 831, 926], [927, 927, 968, 968, 1063], [1064, 1064, 1106, 1106, 1201], [1202, 1202, 1240, 1240, 1320], [1323, 1367, 1413, 1413, 1440], [1442, 1442, 1485, 1485, 1512], [1514, 1514, 1562, 1562, 1590], [1639, 1664, 1697, 1697, 1790], [1792, 1792, 1826, 1826, 1919], [1920, 1920, 1953, 1953, 2046], [2047, 2047, 2080, 2080, 2177], [2179, 2179, 2204, 2204, 2612], [2614, 2614, 2644, 2644, 5937], [5946, 5946, 5976, 5976, 7281], [7287, 7287, 7312, 7312, 7865], [7872, 7912, 7935, 7935, 8996], [9000, 9045, 9112, 9112, 9480], [9481, 9532, 9556, 9556, 9744], [9747, 9810, 9844, 9844, 10298], [10300, 10354, 10390, 10390, 10707], [10765, 10799, 10847, 10847, 11157], [11158, 11192, 11271, 11271, 11791], [11793, 11845, 11937, 11937, 12179], [12182, 12231, 12287, 12287, 13440]]}
{"id": "3tBBWd", "name": "Nebula 16", "author": "Leria", "description": "Big purple nebula seen from a near position (spherical bounding box)\nA+mouse: tune density\nC toggle : control albedo or sigma_s", "tags": ["fractal", "noise", "nebula", "multiplicative"], "likes": 8, "viewed": 644, "published": 3, "date": "1600099230", "time_retrieved": "2024-07-30T20:45:23.796896", "image_code": "// Fork of \"Nebula 11 preintegrated\" by Leria. https://shadertoy.com/view/wlBBDw\n// 2020-09-08 16:02:06\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1., 1., 1. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1./8.;\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 4.5), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(pow(velocity,2.))/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate =  32.*disp_turb*Psnoise(p*1.25); //generation of a local dispersion = turbulence * rate\n    disp_rate +=  64.*disp_turb*fbm(p*5.); //generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n                                                 // --- textured bubble model\n            \n            float rad_bubl = 2.35; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); // vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t//float l = exp(-.5*SQR(d/2.));\n#if 0\n          //float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          //float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            //mask = n;\n#else\n            rad_bubl+=1.;\n             float dr = noise( p - 124.17),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.1*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -.8*dr )   ) ;\n#endif\n            //mask = 1.;\n            \n                                                 // --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = 10.;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v)/(4.*scale))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(.5, .01, 2.)/4.;   // <<< $PHYS $PARAM sigma_t (well, part of)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); // $TUNE\n            vec3 prof = vec3(0);\n            if(vt <= 0.)\n            {\n                prof = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                prof = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            prof = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            vec3 rgb_t = exp(-prof);    // <<< local transparency\n            \n            vec3 col_loc = vec3(.8, .5, .1);  // <<< $PHYS $PARAM albedo, = sigma_s/sigma_t\n            if KeyToggle(64+3) col_loc /= absorb_coef; //  $TUNE  control sigma_s rather than albedo\n            \n            \n            // attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s/sigma_t\n            //        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            // e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            //            E_tr = .5 VT³/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            //                 = 12000 *(mask*fbm)³\n            // note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k/10.;           // --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) // energy_transfer_rate \n                                   - val(L.x,L.y,L.z) // energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           // above : diff = abs(Lambert)\n            //dif = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n#define Gauss(x,s) 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 1./ dot(L/L0,L/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl-.2) ) ) ;\n          //float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = 0.2/size *source, // /exp(-smoothstep(0., 1./size, Gauss(X,std_dev) )),\n                shadow = 1.,\n                reflec = dif;\n          //  sun = .6;\n            reflec =1.;\n            \n            vec3 emission = vec3(0);   // <<< $PARAM $PHYS  \n            \n    \t\t                          // --- add current voxel contribution to ray\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow + emission/absorb_coef) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )/R.y,\n         M =  iMouse.xy/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = iTime, degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    //sky =   .6* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rgb;\n  sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  //sky =   max(texture(iChannel0,fragCoord/256.+vec2(degree,degree2)).rrr -.8,0.)/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2006, 2006, 2031, 2044, 2410], [2412, 2412, 2437, 2450, 2789], [2791, 2791, 2810, 2810, 2903], [2905, 2924, 3000, 3000, 3047], [3049, 3049, 3081, 3081, 3101], [3103, 3103, 3137, 3137, 3159], [3246, 3246, 3287, 3287, 3323], [3325, 3325, 3411, 3411, 3446], [3448, 3448, 3491, 3491, 3531], [3533, 3533, 3557, 3557, 3605], [3607, 3607, 3647, 3647, 3951], [3953, 3953, 3977, 3977, 4041], [4043, 4043, 4098, 4098, 4149], [4151, 4151, 4199, 4199, 4452], [11563, 11563, 11620, 11620, 12673]]}
{"id": "WlSBWd", "name": "Nebula 14", "author": "Leria", "description": "\"Redy\" Nebula\nA+mouse: tune density\nC toggle : control albedo or sigma_s", "tags": ["fractal", "noise", "bubble", "nebula", "multipicative"], "likes": 2, "viewed": 338, "published": 3, "date": "1600099178", "time_retrieved": "2024-07-30T20:45:24.751344", "image_code": "// Fork of \"Nebula 14.0\" by None. https://shadertoy.com/view/-1\n// 2020-09-14 15:56:13\n\n// Fork of \"Nebula 14.0\" by Leria. https://shadertoy.com/view/WtjBWc\n// 2020-09-14 15:54:32\n\n// Fork of \"Nebula 11 preintegrated Fab 3.0\" by Leria. https://shadertoy.com/view/ttBBWK\n// 2020-09-13 19:10:20\n\n// Fork of \"Nebula 11 preintegrated\" by Leria. https://shadertoy.com/view/wlBBDw\n// 2020-09-08 16:02:06\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1., 1., 1. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = snoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*snoise( p ); p = p*s;\n    f += 0.2500*snoise( p ); p = p*s;\n \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1./8.;\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 7.5), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(pow(velocity,2.))/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate =  32.*disp_turb*Psnoise(p*1.25); //generation of a local dispersion = turbulence * rate\n    disp_rate +=  64.*disp_turb*fbm(p*5.); //generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n                                                 // --- textured bubble model\n            \n            float rad_bubl = 2.35; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); // vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t//float l = exp(-.5*SQR(d/2.));\n#if 0\n          //float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          //float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            //mask = n;\n#else\n             float dr = fbm_add( p*4.2 - 124.17),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.1*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -1.*dr )   ) ;\n#endif\n            //mask = 1.;\n            \n                                                 // --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = 100.;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v)/(4.*scale))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(10., .01, 5.);   // <<< $PHYS $PARAM sigma_t (well, part of)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); // $TUNE\n            vec3 prof = vec3(0);\n            if(vt <= 0.)\n            {\n                prof = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                prof = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            prof = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            vec3 rgb_t = exp(-prof);    // <<< local transparency\n            \n            vec3 col_loc = vec3(.8, .1, .1);  // <<< $PHYS $PARAM albedo, = sigma_s/sigma_t\n            if KeyToggle(64+3) col_loc /= absorb_coef; //  $TUNE  control sigma_s rather than albedo\n            \n            \n            // attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s/sigma_t\n            //        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            // e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            //            E_tr = .5 VT³/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            //                 = 12000 *(mask*fbm)³\n            // note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k/10.;           // --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) // energy_transfer_rate \n                                   - val(L.x,L.y,L.z) // energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           // above : diff = abs(Lambert)\n            //dif = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n#define Gauss(x,s) 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 0.7*1./ dot(L/L0,L/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl-.2) ) ) ;\n          //float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = 0.4/size *source, // /exp(-smoothstep(0., 1./size, Gauss(X,std_dev) )),\n                shadow = 1.,\n                reflec = dif;\n          //  sun = .6;\n            reflec =1.;\n            \n            vec3 emission = vec3(0);   // <<< $PARAM $PHYS  \n            \n    \t\t                          // --- add current voxel contribution to ray\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow + emission/absorb_coef) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )/R.y,\n         M =  iMouse.xy/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = iTime, degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .6* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rgb;\n  //sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  //sky =   max(texture(iChannel0,fragCoord/256.+vec2(degree,degree2)).rrr -.8,0.)/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2300, 2300, 2325, 2338, 2641], [2643, 2643, 2668, 2681, 3020], [3022, 3022, 3041, 3041, 3134], [3136, 3155, 3231, 3231, 3278], [3280, 3280, 3312, 3312, 3332], [3334, 3334, 3368, 3368, 3390], [3477, 3477, 3518, 3518, 3554], [3556, 3556, 3642, 3642, 3677], [3679, 3679, 3722, 3722, 3762], [3764, 3764, 3788, 3788, 3836], [3838, 3838, 3878, 3878, 4182], [4184, 4184, 4208, 4208, 4272], [4274, 4274, 4329, 4329, 4380], [4382, 4382, 4430, 4430, 4683], [11777, 11777, 11834, 11834, 12887]]}
{"id": "3lSBWd", "name": "Nebula 15", "author": "Leria", "description": "Soft and bright nebula\nA+mouse: tune density\nC toggle : control albedo or sigma_s", "tags": ["fractal", "noise", "nebula"], "likes": 4, "viewed": 403, "published": 3, "date": "1600099012", "time_retrieved": "2024-07-30T20:45:25.702800", "image_code": "// Fork of \"Nebula 15.0\" by Leria. https://shadertoy.com/view/WtjfDc\n// 2020-09-14 15:54:06\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1., 1., 1. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = snoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*snoise( p ); p = p*s;\n    f += 0.2500*snoise( p ); p = p*s;\n \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1./8.;\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 6.), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(pow(velocity,2.))/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate =  32.*disp_turb*Psnoise(p*1.25); //generation of a local dispersion = turbulence * rate\n    disp_rate +=  64.*disp_turb*fbm(p*5.); //generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n                                                 // --- textured bubble model\n            \n            float rad_bubl = 2.35; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); // vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t//float l = exp(-.5*SQR(d/2.));\n#if 0\n          //float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          //float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            //mask = n;\n#else\n            //rad_bubl += 1. ;\n             float dr = fbm_add( p*3.8 - 124.17),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.0*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -.8*dr )   ) ;\n#endif\n            //mask = 1.;\n            \n                                                 // --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = 20.;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v)/(4.*scale))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(.4, 3., 1.);   // <<< $PHYS $PARAM sigma_t (well, part of)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); // $TUNE\n            \n            vec3 prof = vec3(0);\n            if(vt <= 0.)\n            {\n                prof = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                prof = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            prof = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            vec3 rgb_t = exp(-prof);    // <<< local transparency\n            \n            vec3 col_loc = vec3(.7, .6, .3);  // <<< $PHYS $PARAM albedo, = sigma_s/sigma_t\n            if KeyToggle(64+3) col_loc /= absorb_coef; //  $TUNE  control sigma_s rather than albedo\n            \n            \n            // attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s/sigma_t\n            //        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            // e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            //            E_tr = .5 VT³/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            //                 = 12000 *(mask*fbm)³\n            // note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k/10.;           // --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) // energy_transfer_rate \n                                   - val(L.x,L.y,L.z) // energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           // above : diff = abs(Lambert)\n            //dif = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n#define Gauss(x,s) 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 0.2*1./ dot(L/L0,L/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl-.2) ) ) ;\n          //float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = 1./size *source, // /exp(-smoothstep(0., 1./size, Gauss(X,std_dev) )),\n                shadow = 1.,\n                reflec = dif;\n          //  sun = .6;\n            reflec =1.;\n            \n            vec3 emission = vec3(0);   // <<< $PARAM $PHYS  \n            \n    \t\t                          // --- add current voxel contribution to ray\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow + emission/absorb_coef) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )/R.y,\n         M =  iMouse.xy/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = iTime, degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .9* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n  //sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  //sky =   max(texture(iChannel0,fragCoord/256.+vec2(degree,degree2)).rrr -.8,0.)/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1994, 1994, 2019, 2032, 2335], [2337, 2337, 2362, 2375, 2714], [2716, 2716, 2735, 2735, 2828], [2830, 2849, 2925, 2925, 2972], [2974, 2974, 3006, 3006, 3026], [3028, 3028, 3062, 3062, 3084], [3171, 3171, 3212, 3212, 3248], [3250, 3250, 3336, 3336, 3371], [3373, 3373, 3416, 3416, 3456], [3458, 3458, 3482, 3482, 3530], [3532, 3532, 3572, 3572, 3876], [3878, 3878, 3902, 3902, 3965], [3967, 3967, 4022, 4022, 4073], [4075, 4075, 4123, 4123, 4376], [11510, 11510, 11567, 11567, 12620]]}
{"id": "tl2fDc", "name": "Smooth Animation Cheap Noise", "author": "Jaromir", "description": "Attempt at smoothing the animations of iq's cheap noise using sine distortion.\nPress keys 1 2 3 to see the different noises full screen click the screen to see pattern without sine distortion.", "tags": ["2d", "noise", "random", "cheap", "animation", "smooth"], "likes": 19, "viewed": 635, "published": 3, "date": "1600089896", "time_retrieved": "2024-07-30T20:45:26.462768", "image_code": "//Attempt at smoothing the animations of iq's cheap noise using sine distortion.\n//Also trying to making the noise pattern look more random\n//click the mouse to see without smoothing of the animation\n//press keys 1 2 3 to see the different noises full screen\n\n#define M_PI 3.14159265359\n\nmat2 rot(float a){\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\nfloat noise31(vec3 p){\n\t\n    vec3 id = floor(p);\n    vec3 fd = fract(p);\n    \n    fd = fd*fd*(3.-2.*fd);\n    \n    vec2 rOffset = vec2(37.,17.)*id.z;\n    vec2 uv = id.xy + rOffset + fd.xy;\n    vec2 texNoise = texture(iChannel0, (uv+0.5)/256.0).yx;\n  \n    float n = mix(texNoise.x,texNoise.y,fd.z);  \n    \n    return n;\n}\n\nfloat noise31_sine(vec3 p){\n  vec2 offset = sin(p.xy*vec2(1.876689))*vec2(.310876);\n  p.z+=offset.x+offset.y; \n  float n = noise31(p);\n  return n;\n\t\n}\n\nfloat noise(vec3 p){\n  float n = 0.;\n    \n  if(iMouse.z <= 0.){\n    n = noise31_sine(p);\n  }else{\n    n = noise31(p);\n  }\n\n  return n;  \n}\n\nfloat fbm(vec3 p){\n  float G = exp(-1.);\n  float amp = 1.;\n  float freq = 1.;\n  float n = 0.;\n    \n  for(int i = 0; i <8; i++){\n    p.xy*=rot(0.2*M_PI);\n    n+= noise(p*freq)*amp;\n    freq*=2.;\n    amp*=G;\n  }\n      \n  return n*0.7;\n}\n\nfloat warp(vec3 p){\n     float n = 0.;\n    \n      vec3 q = vec3(\n           fbm(p + vec3(0.,0.,0.0)),  \n           fbm(p + vec3(2.1,1.5,2.1)),  \n           fbm(p + vec3(1.5,3.4,2.1))\n           );\n      vec3 r = vec3(\n           fbm(q + vec3(2.1,3.5,1.5)),  \n           fbm(q + vec3(1.1,0.7,1.1)),  \n           fbm(q + vec3(0.2,1.4,2.3))\n           );\n    \n      return n = fbm(vec3(p + r*4.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float grad = fragCoord.x/iResolution.x;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    //keyboard input\n    float one = texelFetch( iChannel1, ivec2(49,0), 0 ).x;\n    float two = texelFetch( iChannel1, ivec2(50,0), 0 ).x;\n    float three = texelFetch( iChannel1, ivec2(51,0), 0 ).x;\n    \n    float scale = 5.;\n    float speed = 0.5;\n    vec3 p = vec3(uv*scale,iTime*speed);\n\n    float n = 0.;\n    \n    if(one > 0.){\n      n = noise(p);    \n    }else if(two > 0.){\n      n = fbm(p);        \n    }else if(three > 0.){\n      n = warp(p);\n    }else{   \n      if(grad < 0.325){\n        n = noise(p);\n      }else if(grad > 0.33 && grad < 0.655){\n        n = fbm(p);    \n      }else if(grad > 0.66){\n        n = warp(p);       \n      }\n    }\n    \n    fragColor = vec4(n);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 306, 306, 362], [364, 364, 386, 386, 683], [685, 685, 712, 712, 835], [837, 837, 857, 857, 975], [977, 977, 995, 995, 1211], [1213, 1213, 1232, 1232, 1609], [1612, 1612, 1669, 1669, 2457]]}
{"id": "wl2BWc", "name": "Rounded edges 3", "author": "FabriceNeyret2", "description": "Thin round edges require dense sampling, + a lot of polygons in case of mesh: might be most of them.\nBut when edge footprint is less than a pixel, you can just implement a cylinder shader instead.\nhttp://evasion.imag.fr/~Fabrice.Neyret/misc/index-eng.html", "tags": ["raymarching", "shading", "filtering", "subpixel"], "likes": 6, "viewed": 522, "published": 3, "date": "1600066580", "time_retrieved": "2024-07-30T20:45:27.223733", "image_code": "// Render cube with microscopic rounded edges: integrated sub-pixel cylinder shading\n// cf http://evasion.imag.fr/~Fabrice.Neyret/misc/index-eng.html\n// ( Fork of https://shadertoy.com/view/4t2yzR\n//   Base ray-tracing from https://www.shadertoy.com/view/4lBczR\n// )\n\n#define pdot(a,b) max(0.,dot(a,b))\n\nfloat r_round= 6e-2, hpix; // round edge radius; pixel width\n\nvec3 L, H, E; float l;     // lightview geometry + hit dist + material\nvec3 Camb=vec3(0), Cdiff=vec3(1), Cspec=vec3(7); float shininess=200.;\n\nvec4 Phong(vec3 N) {                                       // --- regular Phong\n    float l = pdot(N,L),\n          h = pow( pdot(N,H), shininess);    \n    return vec4( Camb + Cdiff*l + Cspec*h, 1);\n}\nvoid fixN( inout vec3 n0, float s0, vec3 n1, float s1) {   // clamp hidden part by reprojecting n0 to screen plane\n    n0 -= s0*E;\n    float d = 1./sqrt(max(1e-8,1.-s0*s0)),\n         dn = dot(n0,n1);\n    if ( dn < 0. && 1.+dn < s0*(s0+s1) ) d = -d;           // (when ?)\n    n0 *= d;                                               // = normalize, + sign\n }\nvec4 linePhong(vec3 n0, vec3 n1) {                         // --- Phong integral over cylinder slice\n    vec4 col = vec4(0);\n    vec3 dN = n0-n1, N;\n    if (dot(dN,dN)<1e-8) return col;                       // not round edge: normal Phong\n    \n    float s0 = dot(E,n0), s1 = dot(E,n1), dn;\n    if (s0 < 0.) fixN(n0,s0, n1,s1);                       // shouldn't happen, but... \n    if (s1 < 0.) fixN(n1,s1, n0,s0);                       // (still, don't check case both<0.)\n    dN = n0-n1; N = normalize(n0+n1);\n    float a = dot(N,E)*length(dN),\n          e = r_round*a/(l*hpix);                          // fragment cross section\n  //col.a = 1.+0.*min(e,1.); \n    col.a = min(e,1.); \n\n    col.rgb = Camb;\n    float l0 = pdot(n0,L),                                 // ambiant+diffuse: just sides average\n          l1 = pdot(n1,L),\n          l  = (l0+l1)/2., k;\n    if (l==0.) return col;                                 // in shadow\n    col.rgb += Cdiff * l; \n    \n    vec3 K = normalize(cross(n0,n1));                      // specular\n    k = dot(K,H); k = sqrt(max(0.,1.-k*k));                // angle to plane (n0,n1)\n    float h0,h1,h,w;\n    if ( dot(H,N) < 0. || abs(dot(H,dN))/k > 1.-dot(n0,n1) ) { // H not between N0,N1: mean spec\n        h0 = l0 > 0. ? pdot(n0,H) : 0.;\n        h1 = l1 > 0. ? pdot(n1,H) : 0.;\n        h  = (h0+h1)/2.;\n        w  = 1.;\n    } else {                                               // the cool case\n        h = k;\n        w = dot(E,H)/h * sqrt(6.28/shininess)/a;\n    }\n    if (h>1e-4) {\n        h = pow(h,shininess)*w;\n        col.rgb += Cspec * h;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {                       // === render cube =============\n    float t = iTime, s =  10., e=.1, v; \n    mat2  R = mat2( cos(t + vec4(0,33,11,0)) );            // rotation\n    vec3  q = iResolution, dFx,dFy,\n          p = 1.5*s/q, a, N,                               // ray start\n          D = normalize( vec3( (U+U-q.xy)/q.y, -6) );      // ray direction\n          L = vec3(0,1,0);                                 // light direction\n    hpix = 1./q.y;                                         // pixel width\n    L.xz *= R; L.yz *= R;                                  // to object frame ( turntable: factor rot out of ray loop )\n    p.xz *= R; p.yz *= R;\n    D.xz *= R; D.yz *= R;\n    O = vec4(0);\n    l = 0.;\n    for (int i=0; i<99; i++) {                             // --- ray march\n        q = p, // dFx=dFdx(q),dFy=dFdy(q);\n        a = abs(q)-1.;\n        t = max( a.x, max(a.y,a.z));                       // distance to cube\n        if (t < .0001) { s=0.; break; }                    // hit\n        p += t*D; l+=t;                                    // step closer\n    }\n    dFx=dFdx(q),dFy=dFdy(q);      // No hw pb when here, but make precision high for loop end\n  //O = vec4(length(dFx),length(dFy),0,0)*iResolution.y/20.; return; // debug\n  //O = vec4(.06*l); return;                                         // debug\n    if (s==0.) {                                           // --- if hit\n        int i =  t==a.x ? 0 : t==a.y ? 1 : 2,              // abs(hit face). side = sign(q[i]).\n            j = (i+1)%3, k = (i+2)%3;\n      //O-=O; if (q[i] > 0.) O[i]=1.; else O[j]=O[k]=.7;   // face color\n        N-=N; if (q[i] > 0.) N[i]=1.; else N[i]=-1.;       // normal\n        U.x = q[j]/q[i]; // * sign(q[i]);                  // face parameterization [-1,1]^2\n        U.y = q[k]/abs(q[i]);\n        \n        vec2 V = U; V.x*=sign(q[i]);                       // round edges: find neighbor face\n        mat2 J = mat2(dFx[j],dFx[k],dFy[j],dFy[k]) * 3.;\n      //mat2 J = (mat2(dFdx(V),dFdy(V))) *3.; // inverse() ?\n        J = transpose(J);\n        float ex = length(J[0]), ey = length(J[1]);\n        vec4 C = vec4(0);                                  //    interpol colors\n        v = e;\n        if (V.x>1.-e) C[j]=1., C[k]=C[i]=0.,v=1.-V.x; else if(V.x<e-1.) C[k]=C[i]=.7, C[j]=0., v=1.+V.x;\n        if (V.y>1.-e) C[k]=1., C[j]=C[i]=0.,v=1.-V.y; else if(V.y<e-1.) C[j]=C[i]=.7, C[k]=0., v=1.+V.y;\n        v = .5-.5*v/e;\n      //O = vec4(v);                      return; \n        O = sqrt( mix( O*O, C*C, v) ); // return;\n      //O = vec4(.5+.5*N,0);              return;\n        vec3 N2 = N-N, N0=N;                               //    interpol normals\n        v = 0.;//e;\n        if (V.x>1.-ex) N2[j]=1., v=.5-.5*(1.-V.x)/ex; else if(V.x<ex-1.) N2[j]=-1., v=.5-.5*(1.+V.x)/ex;\n        if (V.y>1.-ey) N2[k]=1., v=.5-.5*(1.-V.y)/ey; else if(V.y<ey-1.) N2[k]=-1., v=.5-.5*(1.+V.y)/ey;\n      //v = .5-.5*v/e;\n      // <><><> test\n      //O = vec4(v); return;\n      //v *= 1.57; N = N*cos(v)+N2*sin(v); O = vec4(.5+.5*N,0); return;\n        N = normalize(mix(N,N2,v));    //  O = vec4(.5+.5*N,0); return;\n              \n        E = -D;\n        H = normalize(L+E); \n      //O *= Phong(N); return;\n        if (v<=0.) N2=N;\n        O = linePhong(N0,N2); if (O.a<1.) O = mix(Phong(N0),O,O.a); \n        U  = .5+.5*U;                                      // normalized parameterization\n        O *= .5+.5*texture(iChannel0, U,0.);               // face texture  \n        \n      //if (U.x<.3 && U.y<.1) O = vec4(length(O.xyz));     // mark corner   \n      //if (U.x<=0. || U.x>=1. || U.y<=0. || U.y>=1.) O++; // debug overflow\n    }\n}\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 529, 588, 708], [709, 709, 765, 823, 1064], [1065, 1065, 1099, 1165, 2677], [2679, 2679, 2715, 2770, 6339]]}
{"id": "tl2fW3", "name": "CylinderDeform2", "author": "Del", "description": "Box->Cylinder", "tags": ["deform", "cylinder"], "likes": 5, "viewed": 291, "published": 3, "date": "1600048190", "time_retrieved": "2024-07-30T20:45:27.997664", "image_code": "// Cylinder Coords example, this might exist elsewhere, I couldn't find one!\n// (this is just a bounding box distance)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat mat;\n\nfloat map( in vec3 pos )\n{\n    mat=0.0;\n    float c = pMod1(pos.z,6.0);\n\n    pos.yx *= rot(.55*c-iTime*3.2);\n    \n    \n    // Deform Space...\n    \n    float len = 24.0+(sin(iTime)*12.0);\n    \n    float rad =  (1.0/(3.141*2.0)*len);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    float xs = .45;\n    float zs = 5.65;\n    float ys = .65;\n    float boff = 0.2;\t\t// bounding box offset\n    float bthick = 0.2;\t// bounding box thickness\n\n    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick);\n    float d2 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs,ys,zs));\n    mat = step(d1,d2);\n    d1 = min(d1,d2);\n    return d1*0.5;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tvec3 ro = vec3( 0.0,0.0,1.5);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 80.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            \n            vec3 col1 = vec3(0.1,0.5,0.05);\n            vec3 col2 = vec3(0.4,0.2,0.5);\n            vec3 _col = mix(col1,col2,mat);\n            \n            col = _col*amb + _col*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 167, 167, 455], [457, 457, 488, 488, 575], [577, 577, 598, 598, 666], [668, 668, 708, 708, 829], [843, 843, 869, 869, 1573], [1575, 1621, 1653, 1653, 1891]]}
{"id": "WljfDc", "name": "Elevador Sube", "author": "jorge2017a1", "description": "Elevador Sube", "tags": ["elevadorsube"], "likes": 2, "viewed": 277, "published": 3, "date": "1600037748", "time_retrieved": "2024-07-30T20:45:28.953109", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n//operacion de Union por  FabriceNeyret2  \n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 ) \n\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\n///----------Operacion de Distancia--------\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\n\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 75.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n  \tres =opU3(res, vec3(planeDist5,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,100.0,MATERIAL_NO)); \n  \n    \n    p.y=p.y-25.0+25.0*sin(iTime);\n\n    \n    \n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotate(pp.xz, iTime);\n     pp.x=pp.x+posx;\n     p=pp;\n    \n    \n  \n  \n    float sdsp1= sdSphere(p-vec3(0.0,26.0,0.0), 2.0 );\n        \n\tfloat sdBB1= sdBoundingBox(p-vec3(0.0,10.0,0.0), vec3(10.0,15.0,10.0), 1.0 );\n    float sb1= sdBox(p-vec3(0.0,10.0,-9.0), vec3(0.5,15.0,0.5)); //ver  y\n    float sb2= sdBox(p-vec3(0.0,10.0,9.0), vec3(0.5,15.0,0.5));  //ver  y\n    \n\n    float sb3 =sdBox(p-vec3(-9.0,10.0,0.0), vec3(0.5,0.5,10.0)); //z\n    float sb4= sdBox(p-vec3(9.0,10.0,0.0), vec3(0.5,0.5,10.0));  //z\n\n    \n    float sb5 =sdBox(p-vec3(0.0,10.0,-9.0),vec3(10.,0.5,0.5)); //z\n    float sb6= sdBox(p-vec3(0.0,10.0,9.0), vec3(10.,0.5,0.5));  //z\n\n    \n    float sb7 =sdBox(p-vec3(0.0,-4.0,0.0),vec3(0.5,0.5,10.0)); //z\n    float sb8= sdBox(p-vec3(0.0,24.0,0.0), vec3(0.5,0.5,10.0));  //z\n    \n    float sb9= sdBox(p-vec3(-9.0,10.0,0.0), vec3(0.5,15.0,0.5)); //ver  y\n    float sb10= sdBox(p-vec3(9.0,10.0,0.0), vec3(0.5,15.0,0.5));  //ver  y\n    \n    \n    res =opU3(res, vec3(sdBB1,25.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdsp1,26.0,MATERIAL_NO)); \n    \n    res =opU3(res, vec3(sb1,2.0,MATERIAL_NO)); //rojo\n\tres =opU3(res, vec3(sb2,2.0,MATERIAL_NO)); //rojo\n    res =opU3(res, vec3(sb3,3.0,MATERIAL_NO));  //verde\n    res =opU3(res, vec3(sb4,3.0,MATERIAL_NO));  //verde\n    res =opU3(res, vec3(sb5,4.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sb6,4.0,MATERIAL_NO)); \n\tres =opU3(res, vec3(sb7,4.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sb8,4.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sb9,5.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sb10,5.0,MATERIAL_NO)); \n    \n    \n    \n    //return (dist, id_color, id_material)    \n    return res;\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n   \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    vec3 ro=vec3(0.0,7.0,-30.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    rd= rotate_x(rd, sin(4.3) ); \n    rd= rotate_y(rd, clamp(0.0 ,0.3,cos(t)) ); \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 317, 317, 341], [343, 358, 389, 389, 539], [541, 541, 589, 589, 876], [925, 925, 973, 973, 1006], [1054, 1079, 1114, 1114, 1207], [1209, 1209, 1244, 1244, 1337], [1341, 1341, 1371, 1371, 1440], [1445, 1485, 1510, 1510, 3995], [3999, 4044, 4111, 4111, 4484], [4539, 4539, 4564, 4564, 4804], [4807, 4870, 4905, 4996, 5520], [5579, 5579, 5616, 5616, 5943], [5945, 5979, 6028, 6028, 6264], [6265, 6299, 6379, 6379, 7020], [7114, 7114, 7207, 7207, 7471], [7474, 7523, 7580, 7580, 8919]]}
{"id": "Wl2fW3", "name": "Bitmap custom texture display", "author": "timeisbeautifulhere", "description": "Standalone example of displaying a bitmap (pulled from my Windows 98 shader). Might be useful to someone one day!\n\nBitmap bytes manually encoded using a python script", "tags": ["texture", "bitmap", "image", "hex", "custom", "bytes"], "likes": 12, "viewed": 636, "published": 3, "date": "1600027898", "time_retrieved": "2024-07-30T20:45:29.909553", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = img_texture(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\n/*\nHacky code to read data from manually encoded 4-bit bitmap.\nWebGL seems to be able to handle only 4096 constants,\nso that means we have 4096 array values to work with.\n\nuints are 32 bits, so each uint in the array below has\neight 4-bit pixel values packed into it as hex. With 4096 as\nthe limit, this means we can manage an image of 4096*8 pixels.\n\nEach 4-bit pixel value of a bitmap is an index in the color\ntable. The color table is a 16 value array of RGB values\npacked into it as hex (which I also manually encoded).\n*/\n\n#define IMG_WIDTH 210\n#define IMG_HEIGHT 120\n#define IMG_LENGTH 3150\n#define PALETTE_LENGTH 16\n\n//Bitmap pixels packed into 32 bit uints.\n//Credit to Atom Smasher for generating a custom\n//Windows 98 error http://atom.smasher.org/error/\nuint img[IMG_LENGTH] = uint[](\n\t0xddddd111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x111111ddu,0xddddd222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22dddd21u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212dd1u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0xd1112111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111211u,0x11111111u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x111e23e6u,0x3e63e63eu,0x6e36e211u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11112656u,0x85685685u,0x68558656u,0x21111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x1111116cu,0x56656865u,0x65686656u,0x85611111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x656a8565u,0x65865655u,0x86566111u,0x11111111u,0x1111ddddu,0xd111dd11u,0x11111111u,0x11111111u,0x11111dd1u,0x11111111u,0x11111111u,0x1111111du,0xddddddd1u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11665668u,0x686568a8u,0x668a8561u,0x11111111u,0x11111dddu,0xddd411ddu,0x41111111u,0x11111111u,0x1111111du,0xd4111111u,0x11111111u,0x11111111u,0x1dddddddu,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11116586u,0x55656575u,0x65655656u,0x61111111u,0x1111111du,0xdd444411u,0xdd411111u,0x11111111u,0x11111111u,0x1dd41111u,0x11111111u,0x11111111u,0x111dd444u,0x44441111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111165u,0x68665668u,0x56866686u,0x85611111u,0x11111111u,0x1dd44111u,0x11dd4111u,0x11111111u,0x11111111u,0x111dd411u,0x11111111u,0x11111111u,0x11111dd4u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0xe5685666u,0x56566565u,0x65566111u,0x11111111u,0x111de411u,0x1111dd4du,0xddd1111du,0xdddd1111u,0x1dddddd4u,0x111dddd1u,0x111dd1ddu,0xd111111du,0x04111111u,0x1dd1ddd1u,0xdd1ddd11u,0xddddd111u,0x1dd1ddd1u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x12111111u,0x11656658u,0x5626a266u,0x8a868561u,0x11111111u,0x111111ddu,0xd11111ddu,0xdddddd11u,0x1dddddd1u,0x11ddddddu,0xd411ddddu,0xdd111dddu,0xddd41111u,0x1dddddddu,0x111dddddu,0xd4ddddddu,0x4dddddddu,0x111dddddu,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11116586u,0x56686656u,0x65656565u,0x61111111u,0x11111111u,0x1dddd111u,0xddd44dddu,0x4111444du,0xd41ddd44u,0x4dd41dddu,0x444dd11du,0xdd444411u,0x111dddddu,0xdd411dddu,0x4444ddd4u,0x44ddd444u,0xddd11dddu,0x44441111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11111111u,0x11111166u,0x8a856556u,0x6565868au,0x85611111u,0x11111111u,0x11114dddu,0x11dd4411u,0xdd4111ddu,0xddd41dd4u,0x411dd41du,0xddddddd4u,0x1dd44111u,0x11111dd4u,0x4444411du,0xd44111ddu,0x4411dd44u,0x111dd41du,0xd4411111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x65565686u,0x66266865u,0x65686111u,0x11111111u,0x11111111u,0xdd41de41u,0x11dd411du,0xddddd41du,0xe4111de4u,0x1dddddddu,0xd41de411u,0x1111111du,0xe4111111u,0x1de41111u,0xde4111deu,0x41111dd4u,0x1de41111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111112u,0x11112111u,0x11675756u,0x5656a236u,0x8a856561u,0x11111111u,0x11211111u,0x11dd41ddu,0x4111dd41u,0xddd44dd4u,0x1dd4111du,0xd41dd444u,0x44441dd4u,0x11111111u,0x1dd41111u,0x111dd411u,0x11dd4111u,0xdd41111du,0xd41dd411u,0x11111111u,0x11121112u,0x11112111u,0x11121112u,0x11112111u,0x11121112u,0x11112111u,0x11121121u,0x11111111u,0x1111e55cu,0x56656865u,0x665656a8u,0x61111111u,0x11111111u,0x111ddd41u,0xdd4111ddu,0x41dd441du,0xd41ddd11u,0x1dd41dddu,0x1111d11du,0xd4111111u,0x111dd411u,0x11111dd4u,0x1111dd41u,0x11ddd111u,0xddd41dd4u,0x11111211u,0x21211121u,0x11121111u,0x21211121u,0x11121111u,0x21211121u,0x11121111u,0x21211111u,0x12111121u,0x11211165u,0x68a26665u,0x68566686u,0x55611111u,0x11112112u,0x1dddddd4u,0x41dd4111u,0xdd41ddddu,0xddd411ddu,0xddddd411u,0xddddddd4u,0x1dd41111u,0x12111dddu,0xddddd11du,0xd41111ddu,0x41111dddu,0xdddd441du,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x12111121u,0x11121111u,0x6568a656u,0x58565665u,0x56586111u,0x11111111u,0x111dddddu,0x4411dd41u,0x11dd411du,0xddddd411u,0x1dddddd4u,0x111dddddu,0x441dd411u,0x1111211du,0xddddddd4u,0x1dd41111u,0xdd411111u,0xddddd441u,0x1dd41112u,0x11121112u,0x11211212u,0x11212111u,0x21112121u,0x12121112u,0x11211212u,0x11212111u,0x21111111u,0x11211111u,0x11656586u,0x85686858u,0x68a8a5e1u,0x11111111u,0x21211144u,0x44411114u,0x41111441u,0x11444444u,0x11114444u,0x44111144u,0x44411144u,0x11212111u,0x11444444u,0x44114411u,0x12144111u,0x21144444u,0x11114411u,0x11121112u,0x11112111u,0x11121111u,0x12111211u,0x11121112u,0x11112111u,0x11121111u,0x21211212u,0x12121112u,0x12122a86u,0x5656a8a6u,0x56a56568u,0x61121111u,0x11111211u,0x11111111u,0x11112111u,0x11111111u,0x11121111u,0x11111211u,0x11111111u,0x11111112u,0x12111111u,0x11111111u,0x11111112u,0x11111111u,0x11111111u,0x21211121u,0x12121111u,0x21211112u,0x12112111u,0x21211121u,0x12121111u,0x21211112u,0x11111111u,0x11111121u,0x11111166u,0x568a8656u,0x575868a8u,0xa5e11111u,0x11121212u,0x11211112u,0x12112111u,0x12112111u,0x11112111u,0x11111121u,0x11111112u,0x11212121u,0x21111211u,0x11111121u,0x12121211u,0x11121211u,0x11112121u,0x11111212u,0x11211112u,0x12112112u,0x12111211u,0x21111121u,0x11121112u,0x12112112u,0x12112121u,0x21212121u,0x21121211u,0x26858658u,0x58685655u,0x86562111u,0x11111111u,0x11111121u,0x11121111u,0x21121112u,0x12121112u,0x12121211u,0x11212121u,0x12111111u,0x11121211u,0x12121211u,0x21111111u,0x21211112u,0x12121111u,0x11212111u,0x12111212u,0x11121112u,0x11112112u,0x11121211u,0x21211112u,0x11121112u,0x11112111u,0x12111211u,0x11121112u,0x11126566u,0x66656656u,0x66666212u,0x11111111u,0x21212121u,0x11121111u,0x21211111u,0x21111111u,0x21111111u,0x11211111u,0x11111121u,0x21212111u,0x11211111u,0x11111212u,0x12111121u,0x11111112u,0x12121111u,0x21111121u,0x11112111u,0x21112111u,0x11112111u,0x12111121u,0x21112111u,0x21112111u,0x12111121u,0x11212111u,0x21112111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11211112u,0x11111112u,0x11121112u,0x11111211u,0x21112112u,0x11211211u,0x11111111u,0x12111111u,0x12112111u,0x11111111u,0x11211211u,0x11111112u,0x11111211u,0x11121111u,0x11111111u,0x21121111u,0x21111111u,0x11111111u,0x11111111u,0x21111211u,0x11111111u,0x11111111u,0x11111211u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111110u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00011111u,0x10000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000111u,0x11100000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000001u,0x11111000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x01111110u,0x03000300u,0x03f03f03u,0x0003f03fu,0x003f03f0u,0x03f003f0u,0x03f003f0u,0x3f003f03u,0x0003003fu,0x00300300u,0x03f03000u,0x3003003fu,0x003f0300u,0x03003f00u,0x30003f03u,0x00030003u,0x0030003fu,0x003f03f0u,0x03000300u,0x30003003u,0x00030003u,0x00030003u,0x00030030u,0x00300030u,0x003f0030u,0x00300300u,0x03f11181u,0x100f00f0u,0x0f000000u,0xf00f0000u,0x000f0000u,0x00000f00u,0x00f000f0u,0x00000f00u,0x0f00f0f0u,0x0000f00fu,0x0f000f00u,0xf00f00f0u,0x0000000fu,0x00f0f000u,0x0f00f000u,0x0f00f000u,0xf00f00f0u,0x00f00000u,0x00f000f0u,0x0f000f00u,0xf000f00fu,0x0f000f00u,0xf000f00fu,0x000f000fu,0x00f0000fu,0x000f00f0u,0x0f000111u,0x111f0000u,0x00000000u,0x00000000u,0x00f00000u,0x0f000000u,0x00000000u,0x0000f000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000f00u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x000000f0u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000001u,0x18111000u,0x0e0000e0u,0x0f0000e0u,0x0000f444u,0x444440f0u,0x0e000e00u,0x0e000000u,0xe0000000u,0x00000f00u,0x00000e00u,0x00000000u,0x00000000u,0x0000e000u,0x000e0000u,0x000f0000u,0x00e00000u,0x00000e00u,0x0f0e0000u,0xe0000000u,0x00000000u,0x0e0000e0u,0x000000e0u,0x00000000u,0x0f000000u,0x00000e00u,0x00000000u,0xf111111fu,0x03f003f0u,0x0f000e00u,0x0006444bu,0xbbbbbbb4u,0x44f003f0u,0x003f00feu,0x00000fe0u,0x3f0e00e0u,0x30f0e000u,0x00600e00u,0x6000fe00u,0x6000e000u,0x06000000u,0x3f0e000eu,0x06000f3fu,0x0ef3f000u,0x3f00000fu,0x3f000f3fu,0x0e060006u,0x00003f00u,0x03000600u,0x00f3f0e0u,0x600300e0u,0x3f006000u,0x0f3f0e00u,0x60011111u,0x10f000f0u,0x000f3000u,0xf3000bbbu,0xbbbbbbbbu,0xbbbb40f0u,0x000f0003u,0x00f3f030u,0x0f00f300u,0x0f00000fu,0x30000000u,0x00000300u,0x000000f3u,0x00000f30u,0x0f0000f3u,0x00000000u,0x00000000u,0x0f000f30u,0x00000000u,0x00000000u,0x00000f00u,0x0f0f0000u,0xf3000000u,0x0000f000u,0x0f00000fu,0x30000000u,0x0000f111u,0x11100000u,0x00003000u,0xf000f44bu,0xbbbbbbbbu,0xbbbbbbbbu,0x4f00f000u,0x0f000000u,0x0f000000u,0xf0000003u,0xf00f0000u,0x3f00000fu,0x0000003fu,0x00f00000u,0x00f00003u,0xf0000003u,0xf0000000u,0x0f000000u,0x00f00006u,0x00000000u,0x000003f0u,0x00000000u,0x00000f00u,0x00000000u,0x00f00000u,0x0000f000u,0x03f00031u,0x11811000u,0x0000f0f0u,0x000000bbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbb40300u,0x00000000u,0x00000000u,0x00000000u,0xf0000000u,0x00003000u,0x000f3000u,0x00000000u,0x0000000fu,0x00000000u,0x00000f00u,0xf0030000u,0x00000000u,0x000000f3u,0x00030f00u,0x000f3000u,0x03000000u,0x000f3000u,0x0f0300f3u,0x0000000fu,0x00f00000u,0xf111111fu,0x03f00600u,0x00000034u,0xbbbbbbbbu,0xbbbbbbbbu,0xbbbbbbbeu,0xf000f000u,0xf0000000u,0x0f00004eu,0x00000000u,0x00f00f0fu,0x4e000000u,0xf0000000u,0x3f000000u,0x000000f0u,0x00f00003u,0x000000f0u,0x04e0f000u,0x60000006u,0x000f00f0u,0x00000000u,0xf00f0000u,0x000f4e00u,0xf00000f0u,0x0000004eu,0x00000000u,0x00011111u,0x10f00000u,0x0000000fu,0xfbbbbbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0x460000f3u,0x00f3f000u,0x60003f0eu,0x40600000u,0x0f030000u,0x0e43f000u,0x000f0e40u,0xf00f3006u,0x00600000u,0x0f300f00u,0xf0f30e00u,0x00e40030u,0x00000300u,0x00000000u,0x00006000u,0x000000f0u,0x0f300e40u,0x000f3000u,0x00000f0eu,0x40f30000u,0x0000f111u,0x111f0000u,0x00000060u,0x004bbbbbu,0xb0bbbbbbu,0xbbbb0bbbu,0xbbbb5f03u,0x00000000u,0x0000000fu,0x004e0000u,0x3f0300f0u,0x00004ef0u,0x00f00000u,0x4e000000u,0x00000000u,0x06000000u,0x000000f0u,0x000f04e0u,0xf0000000u,0xf0000000u,0x00000000u,0x000e0000u,0x00000f00u,0x4e000000u,0xf000e000u,0x3f4e000fu,0x003f0001u,0x11111000u,0x00003000u,0x00ebbbbbu,0xbbd00bbbu,0xbbbbbd00u,0xbbbbbb40u,0xf00f0000u,0x000000e4u,0x440e4044u,0x4f0e4440u,0x0e444440u,0xe4440e44u,0x4e440e44u,0x40e40004u,0x00004440u,0xe400e40eu,0x444300e4u,0xe44400e4u,0x4400e444u,0xf3f0e444u,0x0e4440e4u,0x4430e444u,0x0e4e4440u,0x0e44400eu,0x44444000u,0x000f00f3u,0x0111111fu,0x300f3f0fu,0x000004bbu,0xbbb00dddu,0xbbbbbb00u,0xdddbbbbbu,0xb600000eu,0x00f03f00u,0x40e04e44u,0xee04e00fu,0xe4e40efeu,0x4e40e04eu,0x4eef4ee4u,0x0ef4e4e0u,0x04e004e0u,0xe4e04e4eu,0x040e04efu,0x044e0e4eu,0x000e4e40u,0xe04e004eu,0x0e4e4ee0u,0xf00e4e4fu,0xe04e44e0u,0xe4e40e04u,0xe4fe0e4eu,0xf00e0000u,0x00f11111u,0x10f00000u,0x000300fbu,0xbbbbbbddu,0xdd0bbbbdu,0xddddbbbbu,0xbb465000u,0x0000f000u,0xe0e440feu,0x400fe40eu,0x4444e400u,0x0e4e4444u,0x4e400e4fu,0xe400e4e4u,0x00e400e4u,0x44440fe4u,0x0fe44444u,0x00e400feu,0x40e4444fu,0xe440000eu,0x400f0e40u,0x00e44440u,0xe440fe40u,0xf0e4e444u,0x44e40f0eu,0x40300000u,0x0000f111u,0x111f0000u,0x00000f00u,0x4bbbbbbbu,0xbdddddbbu,0x0ddddbbbu,0xbbbbb46fu,0x0003f000u,0x0000f004u,0xe04e0004u,0xe40ef4e4u,0xe0004e4eu,0xefe04e00u,0x4e04e004u,0xe4e0f4efu,0x04eefee0u,0x04e004eeu,0xfee004e0u,0x004e4fe0u,0x4e0004efu,0x004e0000u,0x4ef040e0u,0x4e0004e0u,0x4e0004e4u,0xeefe04e0u,0x004ef0f0u,0x3f000001u,0x11111000u,0x0e000000u,0x0fbbbbbbu,0xbbbbddddu,0xddddddbbu,0xbbbbbbb4u,0x50f0f003u,0x000f304eu,0x0e4e4f00u,0xe4e400e4u,0xe4f0e44eu,0x400e4e4fu,0x0e40e40fu,0xe4fe4e40u,0x00e40004u,0x0e4e40e4u,0x00040fe4u,0xf00e4e40u,0x0e4e4e0eu,0x400e4f0eu,0x4e400e40u,0xfe4e4e0eu,0x4e4000e4u,0xe400e4e4u,0x00e44000u,0x000060f3u,0x01111110u,0x003f00f0u,0x00004bbbu,0xbbbbbbbdu,0xdddddddbu,0xbbbbbbbbu,0xbb660000u,0x0f000000u,0xf4440f4eu,0x00f4ef44u,0x44e04444u,0x4e044400u,0x4e0004e0u,0x444e0004u,0xe004e044u,0x4e04e0f4u,0xe0444e00u,0x04e03f4eu,0x04444e04u,0x440e0f04u,0x44e04e00u,0x04444e04u,0x440f4ef3u,0xf4e04440u,0x0f44444eu,0x00000000u,0x00011181u,0x100f0000u,0x03f00fbbu,0xbbbbbbbbu,0xbbddddddu,0xbbbbbbbbu,0xbbb465e0u,0x0000ef00u,0x00e0e0e0u,0x0f3e000eu,0xefe00feeu,0x0e0fe0e0u,0xef000e00u,0xf0ef000eu,0x400e00feu,0x0e0f000eu,0x00fe0e0fu,0x00e00f00u,0x00fee00fu,0xe0ef0000u,0xee00f00fu,0x0efee00fu,0xe0e0e000u,0x00000feeu,0x00e0ee0eu,0x0f00f000u,0x0000f111u,0x111f0000u,0x000f0000u,0x4bbbbbbbu,0xbbbb0dddu,0xddbbbbbbu,0xbbbbbb56u,0xf0000000u,0x000f000fu,0x00000000u,0x00000000u,0x000f0000u,0x0f0003f0u,0x00000000u,0x04e0f000u,0x300f0000u,0x00000000u,0x0030f000u,0x000e0000u,0xf0000003u,0xf0000f30u,0x00300000u,0x00000f00u,0x00f000f0u,0x0000000fu,0x000003f0u,0x00000001u,0x18111300u,0x000e0000u,0x0fbbbbbbu,0xbbbbbdddu,0xdddd0bbbu,0xbbbbbbb4u,0x6500f3f0u,0x00003000u,0x0f30000fu,0x00f30000u,0xf3000030u,0x003000f0u,0x000f30f3u,0x0ef0003fu,0x0f00000fu,0x30f3f003u,0xf00f0000u,0x000000f3u,0x000f3000u,0x00f30000u,0x0000f003u,0xf000f300u,0xf30000e0u,0x03000f30u,0x003f0000u,0x0300f300u,0xf111111fu,0x0f060000u,0x06004bbbu,0xbbbbbb0du,0xddddddddu,0xbbbbbbbbu,0xbb66ef00u,0x0003f0f0u,0x000000f0u,0x000000f0u,0x0000f000u,0xf0f0f000u,0x00003f00u,0x000f0000u,0xf0000000u,0x30000000u,0x0f000000u,0x03f00600u,0x00000000u,0xf00000f0u,0x00f00f00u,0x0f000300u,0x00000f00u,0x000f0f00u,0x0f00f000u,0x0f00f000u,0x0f011111u,0x100000f3u,0x000000bbu,0xbbbbbbbdu,0xddddbbddu,0xdd0bbbbbu,0xbbb45600u,0x0000f000u,0x00f30000u,0x00f30000u,0x0f300000u,0x0000000fu,0x00000f00u,0x000000f3u,0x00000000u,0x0f0f000fu,0x00000000u,0x00f00000u,0x0000f000u,0x000f0000u,0x00000000u,0x000000f0u,0x0f000000u,0x0f300000u,0x00000000u,0x00000000u,0x00000111u,0x111f0000u,0x00000000u,0x64bbbbbbu,0x0ddddbbbu,0xbdddddbbu,0xbbbbba66u,0xe0000f00u,0x00e000f0u,0x0000000fu,0x00000f00u,0x00600000u,0x0003f000u,0x000f0000u,0x0000000fu,0x00f00000u,0x00000000u,0x60000000u,0x0003f000u,0x3f000030u,0xf000f3f0u,0x00000000u,0x0000000fu,0x00000f00u,0x003f0000u,0x00f0e000u,0xe000f031u,0x11111000u,0x00000000u,0x000bbbbbu,0xbdddddbbu,0xbbbbddddu,0x0bbbbb45u,0x6500000eu,0x00000000u,0x00006000u,0x00000000u,0x0000000fu,0x30000000u,0x00000000u,0x000000f3u,0x00030000u,0x00000f30u,0x00006000u,0x00000000u,0x0000000fu,0x00000000u,0x00f30060u,0x0f0000f3u,0x00f30000u,0x000f0000u,0x60003006u,0x0000e000u,0xf111111fu,0x30003f00u,0x03f004bbu,0xbbbbdddbu,0xbbbbbbbdu,0xddbbbbbbu,0xb66e0f03u,0xf00003f0u,0x000e0000u,0x0006003fu,0x00060000u,0x0000f000u,0xf0e0f3f0u,0xe03f00f0u,0x000f00f0u,0x006003f0u,0x0f000000u,0x003f00f0u,0x000f0006u,0x00000060u,0x0000e000u,0x000000e0u,0x0000000fu,0x00060000u,0x0000000fu,0x000003f0u,0x00f11111u,0x1000f000u,0x00f0000fu,0xbbbbbbbdu,0xbbbbbbbbu,0xbbdbbbbbu,0xb4656000u,0x00000f00u,0xf3f00f30u,0x0000000fu,0x00000000u,0x030000e0u,0x00300000u,0x000f0000u,0x00000000u,0x00000000u,0x00000000u,0x00f00f30u,0x00f30000u,0x00000000u,0x00000000u,0x00000f30u,0x000f00e0u,0x00000000u,0x0f300000u,0x000000f0u,0x00000111u,0x111f0000u,0x00f00000u,0x0004bbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbba6260u,0x00000030u,0x00000000u,0x00003f00u,0x00000000u,0x000f0f00u,0x000f0f00u,0x00000000u,0x03f0e00eu,0x000e0000u,0x0f000003u,0x00000000u,0x0000000fu,0x00000003u,0xf0000060u,0x00f00300u,0x00f00000u,0x00006000u,0x00000000u,0x00000000u,0x00003f01u,0x111110f0u,0x0000000fu,0x3f00fbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbbb4565u,0x0e0f00f0u,0xf0000000u,0x0000f000u,0x00000f30u,0x00300000u,0x00f30000u,0x0f000600u,0x0f0000f0u,0x0f300f30u,0x0000e00fu,0x0f000300u,0x0000f000u,0x0e00300fu,0x00003000u,0x0030000fu,0x0000f300u,0xf3000000u,0x00f300f0u,0x00f3000fu,0x30000f00u,0xf1111110u,0x030f03f0u,0x00000003u,0x4bbbbbbbu,0xbbbbbbbbu,0xbbbbbb66u,0x60f00030u,0x00000f00u,0xf0060000u,0x00030000u,0x00f00f00u,0x0003f000u,0x00030000u,0x00000000u,0x30000f00u,0x00f003f0u,0x0000000fu,0x000f00e0u,0x000000f0u,0x0000000fu,0x00000f00u,0x00000000u,0x0f00f000u,0x00300000u,0x0006000fu,0x0000f000u,0x00011881u,0x10f00000u,0x00000000u,0x0ff4bbbbu,0xbbbbbbbbu,0xbbbbb446u,0x56500000u,0xf00000e0u,0x03000000u,0x00000f0eu,0x00000000u,0x0e0f000fu,0x000f0f00u,0x00030e00u,0xf0f00000u,0x00000f00u,0x0f300000u,0x000e000fu,0x300f3000u,0x0000e000u,0x00000000u,0x0f000f00u,0x00000000u,0x0000000fu,0x00000000u,0x00000000u,0x0000f111u,0x111f0000u,0xe0006000u,0xf00000a4u,0xbbbbbbbbu,0xbbbbbbbau,0x6656ef00u,0xf000e000u,0x000f0000u,0x003f00f0u,0x0000f000u,0x00000000u,0x0000e000u,0x003f00f0u,0x00000000u,0x00000000u,0x000000f0u,0x3f000003u,0xf000f00fu,0x00006000u,0x0f000000u,0x000300e0u,0x30f0e000u,0x003f000fu,0x000e0000u,0x00003f00u,0x03f003f1u,0x11111000u,0x00f00000u,0x003f0000u,0xfab4bbbbu,0xbbbbbb44u,0x26566000u,0x00000000u,0xf3000000u,0x000f0000u,0x00f300f3u,0x00600f30u,0x00000000u,0x00f00000u,0x00f30000u,0xf300600fu,0x30000000u,0x0000600fu,0x00000000u,0x00000000u,0xf300600fu,0x300f0f00u,0x0f000000u,0x600f0000u,0x0030000fu,0x30000f00u,0x00f00f00u,0x0111111fu,0x03f00300u,0x00000000u,0x0000e654u,0x4b4b4b46u,0xa66a6e0eu,0x00003f00u,0x3f00f000u,0x00600000u,0x0e00000fu,0x00000000u,0x0f006003u,0xf0000000u,0x000000f0u,0x0000f000u,0x0000f000u,0x00e00000u,0x00000000u,0x00000600u,0x00000000u,0x000f0000u,0x00000003u,0xf0000000u,0x0f000f00u,0x0300f000u,0x00e00000u,0x00011111u,0x100000f0u,0x00f300f0u,0x00f0000fu,0x6a665665u,0x66562600u,0x00000f00u,0x0f000000u,0x60000000u,0x000f3000u,0x00000000u,0x00000000u,0x0000f300u,0xf00f0000u,0x0f300000u,0x00000000u,0x0600f000u,0x0000000fu,0x00060000u,0x00000000u,0x00000000u,0x0f30000fu,0x00000000u,0x0030e000u,0x00f00006u,0x0000f000u,0xe000f111u,0x111f0000u,0x0000000fu,0x000e0000u,0x0000e656u,0x65662000u,0x000000f0u,0x00000000u,0x00000000u,0x3f00000fu,0x0000e00fu,0x03000000u,0x000f0000u,0x0fe03f03u,0xf0000f00u,0x00003f00u,0xe0000000u,0x00030006u,0x00300000u,0x00030000u,0x00003f00u,0xe00000f0u,0x00000003u,0x000ef000u,0x000f0000u,0x000003f0u,0x3f0003f1u,0x1181100fu,0x00000000u,0x0000f300u,0x0e00000fu,0x0e0e0000u,0x00e000f3u,0x000e0000u,0xf3000000u,0x0000f300u,0x000f3000u,0x000f00f3u,0x0000000eu,0x00000000u,0x000e0000u,0x0000f000u,0x00f30000u,0xf3000f00u,0x000f0000u,0x00000f00u,0x0600f000u,0x00060000u,0x0f300000u,0xf0f0000fu,0x00f30000u,0x00000f00u,0x000000f0u,0x0111111fu,0x03000600u,0x00e003f0u,0x0f000000u,0x0e000000u,0x0f0003f0u,0x0000000fu,0x3f000f00u,0x3000f000u,0xf000000fu,0x003f0000u,0x00f0003fu,0x00000000u,0x00000000u,0x0e006000u,0x00000000u,0x00000f00u,0x00000000u,0x030003f0u,0x00000000u,0x00030000u,0x00e000f0u,0x00000000u,0x00000000u,0x00f00000u,0x00000000u,0x00011811u,0x10f00000u,0x06000f00u,0x0000f30fu,0x0000000fu,0x00030f00u,0x00000600u,0x00000000u,0x00f00000u,0x000f0e00u,0x000f0000u,0x000000f0u,0x0f300f30u,0x0f00f000u,0xf3000000u,0x00060000u,0x0f300000u,0x00003000u,0x00f00f00u,0x00f30003u,0x0000f000u,0x00000000u,0x0060000fu,0x30006000u,0xfe0030f3u,0x0000f00fu,0x3000f111u,0x11100000u,0x00000000u,0x00000000u,0xf0000000u,0xf0000f00u,0x00000000u,0x00000000u,0x00000000u,0x3f000030u,0x00000000u,0x0e03f00eu,0x000000f0u,0x0f0000e0u,0x0000f000u,0x00300000u,0x00f000f0u,0x000600f0u,0x00000000u,0x00000000u,0x00f00f00u,0x00003f00u,0x0f000000u,0x300f0000u,0x000000f0u,0x00000000u,0x000f0001u,0x11111000u,0x0030000fu,0x30000000u,0x000f300fu,0x300f3000u,0x00f00060u,0x000000f0u,0xe0f3f000u,0xf000e000u,0xf0f30f00u,0x0000f000u,0x00000000u,0x00000f30u,0x0f30000fu,0x300f0000u,0x0f300000u,0x00000000u,0x00f3f0e0u,0x00000000u,0x0f000030u,0x0000f00fu,0x30003000u,0x00f00000u,0x000f3000u,0x0000f00fu,0x3e000f30u,0xf111111fu,0x0600f000u,0x0000f006u,0x00000000u,0xf0000000u,0xf0000300u,0x000003f0u,0x03000000u,0x0e000000u,0x0f0000f0u,0x00600000u,0x0003f00fu,0x00000000u,0x00000f00u,0x00000000u,0x00000000u,0x00060000u,0x00000000u,0x00f3f00fu,0x00000000u,0xf000f300u,0x0000f00fu,0x00000000u,0x03000000u,0xf000e000u,0xe000f000u,0x00011181u,0x1000000fu,0x30000000u,0x0000600eu,0x00000000u,0x0000000fu,0x00000f00u,0x00f0f000u,0x00f30000u,0xf3000000u,0x00000300u,0x0f00f003u,0x00e0f30eu,0x000f0000u,0x0000f000u,0x00f30000u,0x06000000u,0xf300e000u,0x00000000u,0x03006000u,0xe000000fu,0x00000000u,0x0000e000u,0x0f0f0000u,0x0000000fu,0x30000000u,0x0000f111u,0x11100000u,0x0000f000u,0x00000000u,0x00000e0fu,0x00e00060u,0x00000300u,0x00000000u,0x00f0000fu,0x00000000u,0x00000000u,0xf0003000u,0x0f000000u,0xf0000000u,0x00060000u,0x00f0000fu,0x00000000u,0x03000f00u,0x0f006000u,0x00e0f000u,0x000000feu,0x00000f0eu,0x0000003fu,0x00000000u,0x3f000600u,0x0000f000u,0x000f0001u,0x18111003u,0x00000000u,0x0f300030u,0x000f3000u,0x00f30000u,0x000000f0u,0x00f0e000u,0x00030000u,0x0f30f00fu,0x30e0f300u,0x0000f0f0u,0x00000f00u,0x0000f300u,0xf3000003u,0x00003000u,0x00000000u,0x00f00000u,0x0f300000u,0x0f000000u,0x0000f300u,0x00000000u,0x0000600fu,0x0f30e000u,0x0f000000u,0x300000f3u,0x00f30f30u,0xf111111fu,0x00f00000u,0x03f000f0u,0x0f00000fu,0x003f000fu,0x00000060u,0x00003000u,0x06000f00u,0x0f000000u,0x000f0000u,0x0f000000u,0x000e0000u,0x30f00000u,0xf000f000u,0x00f00f0fu,0x0e000600u,0x30000000u,0x00000000u,0x00030000u,0x00003f00u,0xf0003f0eu,0x3f003f00u,0x000000f0u,0x03f00000u,0x000f0000u,0x00f00000u,0x00011111u,0x10000f0eu,0x0f000000u,0x00000000u,0x00f00000u,0x00003000u,0x0000f0f0u,0x00000000u,0x000000f0u,0x0e000000u,0x00006000u,0xe0000f00u,0x0f000060u,0x00000000u,0x000000e0u,0x00000000u,0x00f00000u,0x00600000u,0x00000f00u,0xf300f000u,0x00000f00u,0xf000f000u,0x00000000u,0x00f0000fu,0x3000000fu,0x00000000u,0x0000f111u,0x111f3f00u,0x30000000u,0xe0000003u,0xf0000000u,0x000000f0u,0x00000000u,0x00030000u,0x3f0e03f0u,0x000000f0u,0x00600000u,0x003f0034u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x4e00f000u,0x00000000u,0x00000000u,0x00000000u,0x0f000000u,0xe00f0000u,0x03000000u,0x0fe00001u,0x11111000u,0x000f000fu,0x000f300fu,0x00f30000u,0x0000f300u,0x00000f3eu,0x0000f000u,0xf0000f00u,0x00006000u,0x30000000u,0x00f0000fu,0xe4ddeddeu,0xddeddeddu,0xeddeddedu,0xdeddeddeu,0xddeddeddu,0xeddeddedu,0xdeddeddeu,0xd0400000u,0x00060006u,0x00000000u,0x00003006u,0x00030000u,0x0000000fu,0x00f0f0e0u,0xf3000f00u,0xf111111fu,0x0000f003u,0xf003f00fu,0x0000000fu,0x0e060000u,0xf000f300u,0x00000000u,0x00000000u,0x0000e000u,0x000f0000u,0x03000000u,0x0004e000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00064e0fu,0x0003f000u,0x000003f0u,0x03f00f0fu,0x000000f0u,0x00600000u,0x03000000u,0x3f000000u,0x3f011811u,0x10000000u,0x00000000u,0x00e00000u,0x00000000u,0x000e000fu,0x00000f3fu,0x00000060u,0x00000030u,0x00000000u,0x00f00000u,0x0f00e4d0u,0xf0000f00u,0x0f000f00u,0x00f000f0u,0x000f000fu,0x0000f000u,0xf0000f00u,0x0f00e54fu,0x300f0000u,0x000000f0u,0x00f00000u,0x00000000u,0x00000f30u,0x0f0f0e00u,0x00000f00u,0xf0000111u,0x111f0060u,0x000000f0u,0x0000000fu,0x00000300u,0x03f00000u,0x00000f00u,0x00006000u,0x00003f00u,0xf00003f0u,0x003f0000u,0x03f00004u,0x00000000u,0x00000000u,0x00f00000u,0x000f0000u,0x0000f000u,0x00000f00u,0x000000f6u,0x4e000000u,0x00003000u,0x00000000u,0xe0000000u,0x00e00000u,0x00f00000u,0x00f00000u,0x00000001u,0x11811000u,0x0000f00eu,0x00000f30u,0x003f00f0u,0x0f0000f3u,0xf000f300u,0x00000000u,0x30000f00u,0x000000f0u,0x00f00000u,0x00f00300u,0xe4d0e00fu,0x000e0000u,0xe0000e00u,0x00e00000u,0x00e0000eu,0x0000e000u,0x000e0000u,0xe540f00eu,0x000000f0u,0x0000e000u,0xf300f300u,0xf3000f30u,0x00000e00u,0x0f030f00u,0x00f30000u,0xf1111110u,0x030003f0u,0x00006000u,0x0f000f00u,0x00000000u,0x00000e00u,0x0f00f000u,0x000f0000u,0x000f000fu,0x00000000u,0x00ef0000u,0xf0f40e00u,0x00e000f0u,0x0f000000u,0x000f0000u,0xe00f0000u,0x00000f00u,0x00e0000fu,0x00064e00u,0x00006000u,0x0003f000u,0x0000f000u,0x0f00f000u,0x00000000u,0x03f00000u,0x0060000fu,0x03f11111u,0x10f00f00u,0x0f300000u,0x00000000u,0x0000000fu,0x000f0000u,0x000e0030u,0x00000000u,0x000003f0u,0x300000e0u,0x00f30000u,0x0000e400u,0xf00000f3u,0x000300f3u,0x00e44444u,0x40e43006u,0x00f3f003u,0x00f3f00fu,0x300ef540u,0x0f300000u,0x000f00f3u,0x00600000u,0x00000000u,0x00f00f30u,0x0f000000u,0x00000000u,0x00f00111u,0x111f0000u,0x00000000u,0x003f000eu,0x00e06000u,0x3f0e0000u,0x3f000000u,0xf0f00000u,0x06000600u,0x000f0003u,0xf00f0000u,0x00e00004u,0x00003f00u,0x0000f0f0u,0x00f04fe0u,0xeef4e4efu,0x00000000u,0x00f00000u,0x0000f006u,0x4ef000f0u,0x003f0000u,0x00000000u,0x0000e000u,0x003f0000u,0x0f000000u,0x06000000u,0x00e00001u,0x11111000u,0x00e000f0u,0x00000060u,0x00000000u,0xf0000300u,0x0f0000f3u,0x000000f3u,0x00000000u,0x00000000u,0xf0003000u,0xf3f000f0u,0xe4d0000fu,0x30000000u,0x00000e40u,0x0000e4e4u,0x00000000u,0x00000000u,0x00000000u,0xe5400000u,0x000000e0u,0x000f0000u,0x00f30000u,0x600f0000u,0x00000000u,0x00000300u,0xf3000000u,0xf111111fu,0x3f000000u,0x0000f000u,0x00003f00u,0x0000000fu,0x0f00000fu,0x000f00e0u,0x3f000000u,0x000000f0u,0x0e0000f0u,0x00000000u,0x3004e00fu,0x0000f000u,0x0e000000u,0x4e0f0004u,0xe4e04e00u,0x3f00f000u,0x0f00f3f0u,0x00064e00u,0x000000f0u,0x000f0000u,0x003f00f0u,0x00000000u,0x03f0e006u,0x003f0000u,0xf0000f00u,0x3f011811u,0x1000f300u,0xf3000300u,0x00000f00u,0x00030000u,0x00000000u,0x30000000u,0xf0000000u,0x03000e00u,0x00000000u,0x00f00000u,0x0f0fe4d0u,0x00000000u,0xf3000f3fu,0x0e400300u,0xe4e4e400u,0xf0000006u,0x00030000u,0x000ef540u,0x0600f300u,0x00000300u,0x00f00000u,0x0f300000u,0x00f00000u,0x00000000u,0x00000000u,0x0f000111u,0x111f0000u,0xf000f00fu,0x00000000u,0x0003f0f0u,0x0f000006u,0x00f00000u,0x3f00000fu,0x000f0f00u,0x3f03f000u,0x00000000u,0xf0000004u,0x000000f0u,0x0000f000u,0x00004ef0u,0xf0f4e44eu,0x00000000u,0x300000f0u,0x00000005u,0x4ef00000u,0xf003f00fu,0x00060000u,0x00000000u,0x03f00000u,0x03000000u,0x00000000u,0x00000001u,0x11111000u,0x000000e0u,0x000f00f3u,0x000f0000u,0x0000f300u,0x00000f00u,0xf0000000u,0x0f300000u,0x0f000000u,0x0f30e0f3u,0x00060000u,0xe4000600u,0x0060000fu,0x000f0e40u,0x0000e4e4u,0x04600000u,0xf0000000u,0x0f00f30fu,0xe6400000u,0x0000f000u,0x00000000u,0x000000f0u,0x0f000e00u,0x00f000f0u,0x00600060u,0xe0f30000u,0xf1111110u,0x00000000u,0x00000e03u,0x00f00000u,0x00003f00u,0x00000000u,0x0e000000u,0x00e000f0u,0x0000000fu,0x006000f0u,0x00000000u,0x0004e000u,0x00000000u,0x00300000u,0x4e000004u,0xe4ef4000u,0x60000000u,0x000e0000u,0xf0064e00u,0x03f00000u,0x00600000u,0x00060000u,0x00000000u,0x00600000u,0x00000000u,0x000000f0u,0x06011181u,0x1f300600u,0x600f3000u,0xf0000000u,0xf000f000u,0x00000030u,0x00300000u,0xf3f00000u,0x0f300000u,0x00000000u,0x00000000u,0x030fe4d0u,0x00003000u,0x00f00f00u,0xe0e44444u,0x40e400e4u,0x00000000u,0x0f300000u,0x0000e540u,0x000000e0u,0x00000000u,0x0300000fu,0x300f300fu,0x00000000u,0x000f3000u,0x00003000u,0x00000111u,0x111f0000u,0x0000000fu,0x00000000u,0x03000e00u,0x00e0f000u,0xf0f00f00u,0x60000000u,0x00000f00u,0x06000000u,0x00003f0fu,0x0000f004u,0x0000000fu,0x00300000u,0x03f000feu,0xe0eef00eu,0x00000003u,0xf0000f00u,0x3f0000f6u,0x4ef00000u,0x0003f000u,0x03f0f000u,0x0000f000u,0xf0300000u,0x003f0000u,0x003f000fu,0x00000001u,0x18111000u,0x00000000u,0x000000f0u,0x0f0f0000u,0x00000006u,0x00000000u,0x00000000u,0x0f30e000u,0x00000300u,0xf3000f00u,0x03000000u,0xe40f0000u,0x0000f00eu,0x00f00000u,0x00f00000u,0x000f3000u,0xf000e000u,0xf0006000u,0xe5400e00u,0xf30f0000u,0x00000000u,0x03000000u,0x000f00f3u,0x000f0000u,0x00f00000u,0x00000003u,0xf111111fu,0x00000300u,0x00000060u,0x00300000u,0x3f006003u,0x00000000u,0x00000000u,0x06000f00u,0x00000000u,0xf0000f00u,0x0000f00eu,0x00040e00u,0x06000000u,0x00000000u,0x03f00003u,0xf00f300fu,0x000000f0u,0x00000000u,0x00064ef0u,0x0000f000u,0x0000f000u,0x000f0f0eu,0x00e00000u,0x000f0000u,0x06000000u,0x00f00600u,0x0f011111u,0x103f000fu,0x000f3000u,0x0000f000u,0x0f000000u,0xf0000060u,0x006000f3u,0x00000000u,0x0000f300u,0x00000000u,0x000e0000u,0x00f0e400u,0x00000000u,0x00f30000u,0x0f00000fu,0x00000f00u,0x0000e000u,0xf3000000u,0x0000f540u,0x00600000u,0x000f3000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x0f030000u,0x00000111u,0x111f0000u,0x00003f00u,0xf0000000u,0xe0000000u,0x00000000u,0x00000000u,0x000f0000u,0x0003f000u,0xf0000000u,0xf0e00f00u,0x0f3f0004u,0x00000000u,0x060000f0u,0xf3f00000u,0x30000000u,0x00000000u,0x3f000f00u,0x60003f05u,0x4ef00000u,0x00060000u,0xf0e06000u,0x0003f003u,0xf0e00f00u,0x3f000000u,0x3f0000f0u,0x0003f001u,0x11111000u,0x0f000f00u,0x00003000u,0x0f3f000fu,0x30000000u,0x30000000u,0x3000000fu,0x3000f00eu,0x000000f3u,0x00f30003u,0x00000000u,0xe4d56565u,0x65656565u,0x65665656u,0x56665656u,0x56565656u,0x56656565u,0x65656656u,0x26403000u,0x00000000u,0x00000000u,0x0600f000u,0xf000f030u,0xf000f300u,0x0f00e000u,0x00000000u,0xf111111fu,0x00003f00u,0x000000f0u,0xf0000000u,0x0000f000u,0x00f00030u,0x000f0000u,0x0000f000u,0x00000060u,0x000f000fu,0x00f00000u,0x03f44444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444e0fu,0x003f0000u,0x000e0030u,0x00000000u,0x00000000u,0x0f000000u,0x0f000000u,0x3f00000fu,0x00011111u,0x1300f000u,0x00000000u,0x00000000u,0x06000000u,0xf3000000u,0xf0000000u,0xf3000000u,0x000f3000u,0x00000000u,0x0000000fu,0x00f0ee0eu,0xefee0eefu,0xee0eefeeu,0x0eefee0eu,0xefee0eefu,0xee0eefeeu,0x0eefee0eu,0xefee0e00u,0x00f00030u,0x0f30000fu,0x00000000u,0x000000f3u,0x000000e0u,0x00000000u,0xf0000f30u,0x00f3f111u,0x111f0f00u,0x000e0f3fu,0x0e0003f0u,0x00000000u,0x03f00f00u,0x000000f0u,0x00000f00u,0xe03f000fu,0x0000000eu,0x00000000u,0x60000000u,0x0f00000fu,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000000u,0xf00000f0u,0x000003f0u,0x03f00600u,0x000f0000u,0x000f0e03u,0xf0000000u,0x0f000001u,0x11111000u,0x0e000000u,0x000000f0u,0x00000000u,0x0f000000u,0x00f00000u,0xf30e0000u,0x000f0000u,0x0000f300u,0x0f300060u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0xf3000f00u,0x00000000u,0x0000000fu,0x30f0300fu,0x00000000u,0x00000000u,0xf111111fu,0x0003f003u,0xf00003f0u,0x000e03f0u,0x03f00000u,0x00e03006u,0x00000f00u,0x003f0000u,0x00000000u,0x0f0000f0u,0x0000003fu,0x006003f0u,0x3f03f03fu,0x003f003fu,0x03f03f03u,0xf03f03f0u,0x3f03f03fu,0x03f03f03u,0xf003f006u,0x00000e0fu,0x00000f00u,0x00000000u,0x0003f000u,0xe000000fu,0x00000060u,0x03f0e00eu,0x00011811u,0x100f0000u,0xf000f0f0u,0x000000f0u,0x0000000eu,0x0f000f00u,0x00000000u,0xf00f0000u,0x00060f30u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00f000f0u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x000f0000u,0x0000f00fu,0x30000000u,0x0000f00fu,0x30000000u,0x0000f000u,0x00000000u,0x00f00000u,0x0f30f111u,0x111f3000u,0x00000000u,0x00006000u,0x00000f00u,0x00003000u,0x000003f0u,0x00300000u,0x06000000u,0x00f0003fu,0x00003000u,0x00000000u,0x0f000f00u,0x00000000u,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000f00u,0xf0000000u,0x00000300u,0x00000f00u,0x003f0030u,0x000f00f0u,0x00600000u,0x0000003fu,0x00000000u,0x3f000001u,0x11111000u,0x00f00000u,0xe000000fu,0x30000000u,0xf3000f0fu,0x00000000u,0x000f00e0u,0x00000300u,0x0000000fu,0x00000f0fu,0x30006000u,0x00000000u,0x000f0000u,0x00000000u,0x00f0000fu,0x000000f0u,0x0000f000u,0x0000f000u,0x0f30000fu,0x00000f30u,0xe0f000f0u,0xf0000000u,0x00000300u,0xf300600fu,0x00300000u,0x0f000000u,0xf111111fu,0x000f300fu,0x3f003f00u,0x0000f006u,0x0000f000u,0x00000600u,0x0000e000u,0x00000000u,0xf00000e0u,0xf0000600u,0x000f0000u,0x003f0000u,0x000f0030u,0xf03f0060u,0x00000000u,0x0000000fu,0x00000000u,0x00000003u,0x0f0000f0u,0x00003f00u,0x00000000u,0x00000e00u,0x0e03f000u,0x0000f000u,0x0000f000u,0x00000000u,0xf0011111u,0x10f00000u,0x0000f000u,0x00000000u,0x00000000u,0x000f3000u,0x0f00f000u,0x0f00f300u,0x000f3000u,0x03000000u,0x00000000u,0x00f0000fu,0x30f0300fu,0x00000000u,0x000600f3u,0x00f30060u,0x00300600u,0xf3006000u,0xf0e00000u,0x0e000f00u,0x0000f000u,0x00e0000fu,0x300f0000u,0x0f000000u,0x0000000fu,0x0006000fu,0x00300111u,0x11100300u,0xf0000000u,0x00003f00u,0x00000300u,0x0e000000u,0x00030003u,0x0f030000u,0xf0000000u,0xf00f0000u,0x00000000u,0x003f0000u,0x000f000fu,0x0000e0f0u,0x00000000u,0x000f0000u,0x00000f00u,0x00000000u,0x00000003u,0xf00000f0u,0x000f0003u,0xf0060003u,0xf00f0000u,0x00000000u,0x000000e0u,0x0003f000u,0x0300f0f1u,0x1881100fu,0x00000e00u,0x0000f000u,0x00f300f0u,0xf0000600u,0x00000000u,0xf0000f00u,0x00000000u,0x0000000fu,0x300f3000u,0x60f00000u,0x000000e0u,0x00000000u,0x00000300u,0x00000000u,0x00000000u,0x00000000u,0x0000000fu,0x000f3f03u,0x000e000fu,0x0000000fu,0x00000000u,0x0000000eu,0x0f300f30u,0x00000000u,0x00f00000u,0x0111111fu,0x0000e00fu,0x03f00600u,0x00000000u,0x00003f00u,0x00000f00u,0xf0000000u,0x00600060u,0x00f003f0u,0x0000f000u,0xf0000000u,0x006003f0u,0x00000e00u,0xf3f003f0u,0x000000e0u,0x00e0003fu,0x000003f0u,0x0003f003u,0xf0000000u,0x00f00003u,0xf0000000u,0x00000000u,0x006003f0u,0x03f000f0u,0x00f03f00u,0x00000000u,0x00011111u,0x100000f3u,0x0f000000u,0x000f0e0fu,0x00000000u,0x00006000u,0x00e00000u,0x00000000u,0x003e0f00u,0x00e00000u,0x00000000u,0x00000f00u,0x00006000u,0x00000f00u,0x0f000f30u,0x0f3f00f0u,0x00e00000u,0x0e0f000fu,0x00000000u,0x0000000fu,0x000e0000u,0x003000f0u,0x000000f0u,0x00f00000u,0x00000f00u,0x000f3000u,0x0600f111u,0x111f0000u,0x00000000u,0x00003000u,0x3000e00fu,0x00003000u,0x003f0003u,0xf0e03000u,0x00000f00u,0x00000000u,0x0e000300u,0x003f0000u,0x00000000u,0x003f0000u,0x00000000u,0x0f000000u,0x0000003fu,0x00000000u,0x000000e0u,0xf000f00eu,0x00000000u,0x3f000f00u,0x030f3000u,0x00000000u,0x00e00000u,0x000e0000u,0xf0000001u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111818u,0x18181811u,0x81181818u,0x11181111u,0x18181811u,0x81111811u,0x18118111u,0x81118118u,0x18118118u,0x18181818u,0x18111181u,0x11818118u,0x18181811u,0x18118118u,0x11818118u,0x11811818u,0x11811181u,0x18181818u,0x18181818u,0x18181818u,0x18181181u,0x18118111u,0x11111811u,0x81181818u,0x18181811u,0x81811811u,0x81818111u\n);\n\n//Color table/palette from bitmap\nint pal[PALETTE_LENGTH] = int[](\n\t0xefefde,0x0052e6,0x42adc5,0xc5de63,0x312110,0x6bad42,0xbd8cb5,0xc529bd,0x423173,0x21b542,0xc5843a,0xce1929,0x5231ce,0xf7f7f7,0xbddee6,0xf7cee6\n);\n\n//Given uv [0,1], return rgb value from bitmap\nvec3 img_texture(vec2 uv){\n    //Bitmap y starts at top\n    uv.y = 1.0-uv.y;\n    \n    int x = int(uv.x*float(IMG_WIDTH)),\n        y = int(uv.y*float(IMG_HEIGHT));\n    int index = y*IMG_WIDTH + x;\n    \n    //Wonky bitwise operations to extract\n    //correct 4 bits from the hex value.\n    uint hex = img[index/8];\n    int shift_cnt = 8 - (index%8+1);\n    shift_cnt *= 4;\n    int pixel = int((hex>>(shift_cnt))&0xfu);\n\t\n    //Given pixel value, return correct\n    //rgb color from color table\n    int col = pal[pixel];\n    \n    return vec3(\n        float((col>>16)&0xff)/255.0,\n        float((col>>8)&0xff)/255.0,\n        float((col)&0xff)/255.0\n    );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 238]]}
{"id": "WljBWc", "name": "Chaotic Orchard", "author": "blackle", "description": "live coded for the Inércia Demoparty Shader Royale test stream\n", "tags": ["livecode"], "likes": 14, "viewed": 455, "published": 3, "date": "1600024983", "time_retrieved": "2024-07-30T20:45:30.682485", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\nvec3 tree(vec3 p, float t) {\n    for (int i = 0; i < 8; i++) {\n    //p.y -= 1.;\n    p.x = abs(p.x);\n    vec2 roter = normalize(vec2(.4,1.));\n    p.xz -= roter*max(dot(p.xz,roter),0.)*2.;\n    p.z += .25;\n        p = erot(p,vec3(0,0,1),iTime + t);\n    }\n    return p;\n}\n\nfloat pillar;\nfloat scene(vec3 p) {\n    vec3 p2 = vec3(asin(sin(p.xy)*.5),p.z);\n    vec3 p3 = vec3(p.xy,p.z-1.25);\n    vec2 id = floor(p.xy/4.)*4.+2.;\n    p3.xy -= id;\n    p3 = erot(p3, vec3(0,0,1),id.x);\n    p3=tree(p3, id.x+id.y);\n    vec2 crds = vec2(length(p3.xy),p3.z);\n    pillar = box(crds, vec2(.02,.25))-.01;\n    float ball = length(p2)-1.;\n    return min(pillar,ball);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(.001);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float t = cos(iTime)*.3;\n    float yrt = sin(t)*.2+.5;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-8,0,0);\n    \n    init = erot(init,vec3(0,1,0), yrt);\n    cam = erot(cam ,vec3(0,1,0), yrt);\n    init = erot(init,vec3(0,0,1), t);\n    cam = erot(cam, vec3(0,0,1), t);\n    init.x += asin(sin(iTime*.1))/.05;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n    bool pl = pillar == dist;\n    float fog = smoothstep(40.,10.,distance(p,init));\n    vec3 n =    norm(p);\n    vec3 r = reflect(cam,n);\n#define AO(p, d, s) smoothstep(-s,s,scene(p+d*s))\n    float ao = AO(p,n,.1)*AO(p,n,.3)*AO(p,n,.5);\n    float ro = AO(p,r,.1)*AO(p,r,.3);\n    \n    vec3 ldir = normalize(vec3(1));\n    \n    vec3 p2 = p+ldir*.1;\n    float mdd = 100.;\n    for (int i = 0; i < 50; i++) {\n        float dd = scene(p2);\n        mdd = min(abs(dd),mdd);\n        p2 += dd*ldir;\n    }\n    float diff = length(sin(n*2.)*.4+.6)/sqrt(3.);\n    float spec = length(sin(r*5.)*.4+.6)/sqrt(3.);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float specpow = .2;\n    vec3 diffcol = vec3(.05,.05,.05);\n    if (pl) {\n        diffcol = vec3(.7,.05,.05);\n        specpow = 1.5;\n        ao *= smoothstep(-1.,1.,dot(ldir,n));\n        ro *= smoothstep(-1.,0.,dot(ldir,n));\n    } else {\n        ao *= smoothstep(0.,0.1,mdd);\n    }\n    \n    vec3 col = diffcol*diff*ao + pow(spec,10.)*fres*specpow*ro;\n    vec3 fogcol = vec3(.3,.4,.6);\n    fragColor.xyz = sqrt(hit ? mix(fogcol,col,fog) : fogcol);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBWc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[195, 195, 233, 233, 295], [297, 297, 324, 324, 397], [399, 399, 427, 427, 666], [682, 682, 703, 703, 1048], [1050, 1050, 1069, 1069, 1186], [1189, 1189, 1246, 1246, 2907]]}
{"id": "ttBfDc", "name": "Mini-Bosque", "author": "jorge2017a1", "description": "Mini-Bosque", "tags": ["minibosque"], "likes": 5, "viewed": 283, "published": 3, "date": "1600010070", "time_retrieved": "2024-07-30T20:45:31.647904", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n//#define Cyl( p, a, h) length(max(d= abs(vec2(length(p),a)) - h,0.)) +  min(max(d.x,d.y),0.) \n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n/*\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n*/\n///------------------------------------\n\n\n\nvec3 ArbolcaseroFruta(vec3 p)\n{ \n   vec3 res = vec3(9999.0, -1.0,-1.0);\n\t\t\n   float sdcy1= sdCylinderXY(  p-vec3(-0.5,1.0,0.0), vec2(1.5,0.5) );\n   float sdcy2= sdCylinderXY(  p-vec3(0.0,0.5,-0.5), vec2(1.5,0.5) );\n   float sdcy3= sdCylinderXY(  p-vec3(0.5,-0.5,0.25), vec2(1.5,0.5) );\n   float sdcy4= sdCylinderXY(  p-vec3(-1.5,-0.5,-0.25), vec2(1.5,0.5) );\n   float sdbor1=sdRoundBox(  p-vec3(-0.25,-3.0,0.0),  vec3(0.5,1.2,0.5), 0.25 );\n    \n    //frutas\n   float sdcy5= sdCylinderXY(  p-vec3(0.0,0.5,-0.5), vec2(0.15,0.5) );\n   float sdcy6= sdCylinderXY(  p-vec3(0.8,0.75,-0.5), vec2(0.15,0.5) );\n   float sdcy7= sdCylinderXY(  p-vec3(0.5,-0.5,0.25), vec2(0.15,0.5) );\n   float sdcy8= sdCylinderXY(  p-vec3(0.5,0.5,0.25), vec2(0.15,0.5) );\n   float sdcy9= sdCylinderXY(  p-vec3(-1.5,-0.5,-0.25), vec2(0.15,0.5) );\n    \n       \n   \tres =opU3(res, vec3(sdcy1,31.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy2,32.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy3,33.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy4,31.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbor1,11.0,MATERIAL_NO));\n    \n    res =opU3(res, vec3(sdcy5,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy6,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy7,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy8,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy9,2.0,MATERIAL_NO)); \n    \n   return res; \n}   \n\n\nvec3 CerroCasero(vec3 p)\n{\n  vec3 res = vec3(9999.0, -1.0,-1.0);\n   float sdcy1= sdCylinderXY(  p-vec3(-3.5,3.0,0.0), vec2(3.5,0.5) );\n   float sdcy2= sdCylinderXY(  p-vec3(0.3,2.5,-0.5), vec2(4.5,0.5) );\n   float sdcy3= sdCylinderXY(  p-vec3(4.5,-3.5,0.25), vec2(4.5,0.5) );\n   float sdcy4= sdCylinderXY(  p-vec3(-4.5,-5.5,-0.25), vec2(6.5,0.5) );\n   \n    res =opU3(res, vec3(sdcy1,36.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy2,37.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy3,36.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdcy4,37.0,MATERIAL_NO));  \n    \n  return res; \n}   \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    \n    vec3 res;\n    vec3 pp,p1; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    p.y=p.y-4.0;\n  \n    vec3 q=p;\n    \n    \n    //float cx=30.0;\n    //float cz=50.00;\n    //q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    //q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    //correcion por FabriceNeyret2\n    vec2 c = vec2(30,50);\n    q.xz = mod(q.xz+.5*c,c)-.5*c;\n    \n    \n    \n    \n    vec3 q1=p;\n    //float cx1=20.0;\n    //float cz1=20.00;\n    //q1.z = mod(q1.z+0.5*cz1,cz1)-0.5*cz1;\n    //q1.x = mod(q1.x+0.5*cx1,cx1)-0.5*cx1;\n    vec2 c1=vec2(20.0);\n    q1.xz= mod(q1.xz+0.5*c1,c1)-0.5*c1;\n    \n    p=q;\n\t\n    vec3 sarbol2= ArbolcaseroFruta(q1-vec3(5.0,0.0,0.0));\n    res =opU3(res, sarbol2); \n    vec3 sarbol3= ArbolcaseroFruta(q1-vec3(-5.0,0.0,3.0));\n    res =opU3(res, sarbol3); \n    vec3 scerro1= CerroCasero(p-vec3(0.0,0.0,5.0));\n    res =opU3(res, scerro1); \n        \n    \n    \n    //return (dist, id_color, id_material)\n    \n    return res;\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.23,1.2,0.31); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n  \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 10.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 100.0, -50.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n     vec2 p2 = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    \n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n    vec3 ro = vec3( 0.0+2.0*cos(iTime), 3.5+2.5*cos(iTime+2.0*sin(iTime)), -25.0+2.2*sin(iTime) );    \n    vec3 ta = vec3( 0.0, -0.5, 0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 rd = normalize( p2.x*uu + p2.y*vv - 1.8*ww );\n    \n    \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\n/*if (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\n*/\nif (i==11 ) { return vec3(128,128,0)/255.0; }\n/*if (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }*/\n\n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    /*\n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    */\n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n    \n    if(i== 32 )\n    { \n    \treturn vec3(0.0, 1.0, 0.0);\n     }\n    \n    if(i== 33 )\n    { \n    \treturn  vec3(0.1, 1.0, 0.2);\n     }\n    \n    \n    //--------tono cafe\n     if(i== 34 )\n    { \n    \treturn hsv(vec3(0.2, 1.0, 0.25));\n    }   \n    \n    if(i== 35 )\n    { \n    \treturn hsv(vec3(0.2, 1.0, 0.3));\n     }\n    \n    if(i== 36 )\n    { \n    \treturn hsv(vec3(0.1, 1.0, 0.3));\n     }\n    \n    if(i== 37 )\n    { \n    \treturn  hsv( vec3(0.1, 1.0, 0.2));\n     }\n    \n    \n  \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 367, 367, 458], [460, 460, 498, 498, 601], [650, 650, 698, 698, 731], [984, 984, 1015, 1015, 2347], [2353, 2353, 2379, 2379, 2932], [2937, 2977, 3002, 3002, 4043], [4047, 4092, 4159, 4159, 4532], [4587, 4587, 4612, 4612, 4852], [4855, 4918, 4953, 5044, 5568], [5627, 5627, 5664, 5664, 5991], [6049, 6120, 6156, 6156, 6362], [6365, 6436, 6460, 6460, 6720], [6770, 6804, 6853, 6853, 7109], [7110, 7144, 7224, 7224, 7865], [7961, 7961, 8054, 8054, 8313], [8316, 8365, 8422, 8422, 10053]]}
{"id": "3lBfWV", "name": "Simple Ray Traced", "author": "BeardThings", "description": "Simple ray traced sphere", "tags": ["simple"], "likes": 0, "viewed": 269, "published": 3, "date": "1600003167", "time_retrieved": "2024-07-30T20:45:32.416848", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float aspect = iResolution.y / iResolution.x;\n    vec3 v=vec3(0.,0.,1.)+vec3(uv.x,0.,0.)+vec3(0.,uv.y*aspect,0.);\n    vec3 o=vec3(0.,0.,-2.);\n    float r=0.5;\n\n    float a=dot(v,v);\n    float b=2.*dot(v,o);\n    float c=dot(o,o)-r*r;\n    float d=b*b-4.*a*c;\n    \n    fragColor = vec4(0.);\n    if(d>=0.)\n    {\n        float t=(-b-sqrt(d))/(2.*a);\n        vec3 n=normalize(o+v*t);\n        \n        float rot=iTime*0.5;\n        vec3 l=normalize(vec3(cos(rot),0.707,-sin(rot)));\n        \n        fragColor=vec4(1.)*dot(l,n);\n    }  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 637]]}
{"id": "wtSfWc", "name": "Simple Bump Mapping", "author": "BeardThings", "description": "Simple Bump Mapping Implementation", "tags": ["bumpmapping"], "likes": 3, "viewed": 362, "published": 3, "date": "1600003096", "time_retrieved": "2024-07-30T20:45:33.254608", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float aspect = iResolution.y / iResolution.x;\n    vec3 v=vec3(0.,0.,1.)+vec3(uv.x,0.,0.)+vec3(0.,uv.y*aspect,0.);\n    vec3 o=vec3(0.,0.,-2.);\n    float r=0.5;\n\n    float a=dot(v,v);\n    float b=2.*dot(v,o);\n    float c=dot(o,o)-r*r;\n    float d=b*b-4.*a*c;\n    \n    fragColor = vec4(0.);\n    if(d>=0.)\n    {\n        float t=(-b-sqrt(d))/(2.*a);\n        vec3 p=o+v*t;\n        vec3 n=normalize(p);\n        \n        vec2 bumpUV = vec2(atan(n.z,n.x), acos(n.y));\n        vec4 bump = texture(iChannel0, bumpUV);\n        \n        // Warning: Has fireflies on derivative discontinuities.\n        \n        // How do our UVs vary?\n        float du0 = dFdx(bumpUV.x);\n        float dv0 = dFdx(bumpUV.y);\n        float du1 = dFdy(bumpUV.x);\n        float dv1 = dFdy(bumpUV.y);\n        \n        // How does our position vary in the same direction?\n        vec3 e0=dFdx(p);\n        vec3 e1=dFdy(p);\n        \n        // What is our bump gradient?\n        float pdx=dFdx(bump.r);\n        float pdy=-dFdy(bump.r);\n        \n        vec3 tang=(e1*dv0-e0*dv1)/max(dv0*du1-dv1*du0,0.0001f);\n        vec3 bitang=cross(n,tang);\n        \n        n=normalize(cross(tang+n*pdx,bitang+n*pdy));\n        \n        float rot=iTime*0.5;\n        vec3 l=normalize(vec3(cos(rot),0.707,-sin(rot)));\n        \n        fragColor=vec4(1.)*dot(n,l);\n    }  \n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1427]]}
{"id": "WlSBDV", "name": "Cyclic Cellular Automata Test", "author": "clepirelli", "description": "Based on : https://www.math.ucdavis.edu/~gravner/papers/cca.pdf\n\nThe delay is so you have time to put it in full screen :D\n\nTry changing the value of N!\nMy implementation is probably flawed in some way since some N values don't yield any good results", "tags": ["cellularautomata", "cca"], "likes": 5, "viewed": 601, "published": 3, "date": "1599991833", "time_retrieved": "2024-07-30T20:45:34.020560", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uint thisN = decodeN(iChannel0, uv);\n    \n    float Nscale = 1.0 / float(N);\n    \n    fragColor = vec4(pow(pal(float(thisN) * Nscale).xyz, vec3(1./2.2)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 originalUV = uv;\n    \n    if(iFrame % (100/SPEEDPERCENTAGE) != 0)  //slow down the simulation a bit\n    {\n    \tfragColor = texture(iChannel0, originalUV);\n        return;\n    }\n    \n    float aspectRatio = iResolution.y/iResolution.x;\n    uv.y *= aspectRatio;\n    \n    vec2 pixel = vec2(1.0)/iResolution.xy;\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    mouseUV.y *= iResolution.y/iResolution.x;\n    \n    bool timerFinished = iTime < 2.0;\n    if(timerFinished)\n    {\n        #if RANDOM\n        uint imageN = uint(rand(uv*iDate.z) * float(N));\n        #else\n        vec3 textureColor = texture(iChannel1, uv).rgb;\n        float luminance = textureColor.r *.2126 + textureColor.g *.7152 + textureColor.b * .0722;\n        uint imageN = uint(luminance * float(N));\n       \t#endif\n\t\tfragColor = encodeN(imageN);\n    } else \n    {\n    \tuint myN = decodeN(iChannel0, originalUV);\n        \n    \tfor(int i = -1; i<= 1; i++)\n    \tfor(int j = -1; j<= 1; j++)\n    \t{\n            vec2 pixelOffset = vec2(float(i) * pixel.x, float(j) * pixel.y);\n            vec2 coordinates = mod(originalUV + pixelOffset, vec2(1.0));\n            \n    \t    uint neighborN = decodeN(iChannel0, coordinates);\n    \t    \n            if((neighborN - myN) % N == 1U)\n            {\n                myN = neighborN;\n                break;\n            }\n    \t}\n        \n        fragColor = encodeN(myN);\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define N  27U\n\n\n#define PALETTE 1\n#define RANDOM 1\n\n//doesn't do anything after 100, it's just to speed things down\n#define SPEEDPERCENTAGE 33\n\n//from iq : https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal(in float t)\n{\n#if PALETTE == 0\n    return vec3(t);\n#else\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d =vec3(0.0,0.33,0.67);\n    return a + b*cos( 6.28318*(c*t+d) );\n#endif\n    \n}\n\nfloat rand(vec2 value){\n    return fract(sin(dot(value,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuint decodeN(in sampler2D channel, in vec2 uv)\n{\n\treturn uint(texture(channel, uv).r);\n}\n\nvec4 encodeN(in uint n)\n{\n\treturn vec4(float(n), .0, .0, 1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 270]]}
{"id": "WtSfWK", "name": "Hexagonal Grid Traversal - 3D", "author": "iq", "description": "Everybody has to implement an hexagonal grid. This it mine. It's minimal, efficient and robust. Each cell is visited only once, in the right order. It also performs analytical ambient occlusion (one ring). It should run full speed even on crappy phone.", "tags": ["2d", "grid", "raycasting", "hexagon", "traversal"], "likes": 304, "viewed": 22220, "published": 3, "date": "1599991027", "time_retrieved": "2024-07-30T20:45:34.975009", "image_code": "// Copyright Inigo Quilez, 2020 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n// make this bigger if you have a storng PC\n#define AA 2\n#endif\n\n\n// -----------------------------------------\n// mod3 - not as trivial as you first though\n// -----------------------------------------\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Some methods of computing mod3:            // PC-WebGL  Native-OpenGL  Android WebGL\n    //                                            // --------  -------------  -------\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5 );\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texture is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 6.0;\n\nfloat map( vec2 p, in float time ) \n{\n    p *= 0.5;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);\t\n\treturn kMaxH*(0.005+0.995*f);\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 1.0;\n    \n    ivec2 hid = hexagonID(ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==0 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -1.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  1.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, by using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally portals should be recursivelly traversed and clipped\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n         if( faceID==-1 ) prismID += i1;\n    else if( faceID== 1 ) prismID -= i1;\n    else if( faceID==-2 ) prismID += i2;\n    else if( faceID== 2 ) prismID -= i2;\n    else if( faceID==-3 ) prismID += i3;\n    else if( faceID== 3 ) prismID -= i3;\n\n    float occ = 0.0;\n    if( faceID!=1 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-3 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-1 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=3 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=2 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(0.5,0.2+0.8*(1.0-occ)*pos.y/kMaxH);\n    }\n    \n    return 1.0-occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(1.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro + rd*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*131 + prismID.y*57;\n\n        // uvs\n        vec2 uv = (faceID==4) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 0.1+0.9*float((id>>13)&3)/3.0;\n        id = hash(id); mate  = ( ((id>>8)&15)==0 ) ? vec3(0.7,0.0,0.0) : mate;\n        vec3 tex = vec3(0.15,0.09,0.07)+0.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        mate *= tex;\n       \n        // lighting\n        float occ = calcOcclusion( pos, nor, time, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(0.95,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*2.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(0.0,0.15,ref.y)*\n               (0.04 + 0.96*pow(fre,5.0))*\n               castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(1.0), 1.0-exp2(-0.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else\n        float time = iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -0.1;\n        float an = 3.0*time + 20.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 0.9+0.1*(p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 0.3*sqrt(ra.x)*vec2(cos(6.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col;\n\t}\n\ttot /= float(AA*AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(1.0+tot);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n    \n    // color grade\n    tot = mix( tot, vec3(dot(tot,vec3(0.3333))), -0.2 );\n    tot = pow(tot,vec3(0.95,1.0,1.0));\n    \n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.5)*0.1;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfWK.jpg", "access": "api", "license": "proprietary-license", "functions": [[1317, 1452, 1471, 1471, 2197], [2199, 2306, 2325, 2325, 2380], [2383, 2499, 2527, 2527, 2884], [2886, 2886, 2924, 2924, 3005], [3252, 3252, 3289, 3289, 3507], [3509, 3671, 3782, 3782, 5757], [5759, 5991, 6053, 6053, 7532], [7736, 7736, 7759, 7759, 7792], [7794, 7794, 7935, 7935, 8400], [8402, 8402, 8599, 8599, 9280], [9484, 9484, 9615, 9615, 11641], [11647, 11647, 11810, 11810, 12240], [12696, 12696, 12814, 12814, 14202], [14395, 14395, 14449, 14464, 16050]]}
{"id": "tlSfW3", "name": "maya pyramid + texture + forest", "author": "FabriceNeyret2", "description": "Mouse control : angles. +SPACE: zoom\nvariant of [url]https://shadertoy.com/view/tlSfDK[/url]\n\nreference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 20, "viewed": 685, "published": 3, "date": "1599986154", "time_retrieved": "2024-07-30T20:45:35.737969", "image_code": "// textured + displaced + mouse control variant of https://shadertoy.com/view/wl2BWV\n// forest variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)        mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x)   ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)    fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define T(V)          texture(iChannel1,V/4.)\n\nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y);               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2.,                    // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 );        // slopes top \n    t = max( t, q.z-7.);                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.);   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5));// doors\n    t = max( t,-max(3.*abs(q.z-7.5),a)+1.5 );         // room\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y,                     // normalized centered coords\n          M = iMouse.xy / R;\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.,z = 2.; // Z=0.;                     // color (pseudo-shading), zoom\n    t*=.3; if (iMouse.z>0.)                           // mouse control\n        _t = keyPress(32) ? z=9.*M.y,_t : 1.6*M.y, t = -3.*M.x;\n    vec3  D = normalize( vec3(U,-z) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25);                           // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(t);                  // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(t);\n    t = 1e5;\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        t = map(p),                                   // distance to objects\n        t != s ? t += .3*( T(.3*p.xy)+T(.3*p.xz)+T(.3*p.yz) -1.5 ).r : t, // displacement (temple)\n        p += .5*t*D;  // Z+=t;                        // sphere-tracing step\n    \n  //c = 1. - c/50.;                                   // pseudo-lighting\n // O = vec4(1.3-.01*Z); return;                      // Depth buffer\n    c = 4.*exp(-c/10.);\n    O = t==s                                          // coloring\n             ?  p.z > 2. ? vec4(0,0,2,1)                          // sky\n             :  vec4(0,.2,0 ,1)*(.7+.3*p.z)                       // forest\n              *(.5+1.5*texture(iChannel2,p.xy).r)\n             : vec4(1,.8,.6,1) *( T(p.xy)+T(p.xz)+T(p.yz) -1.)/1.5;// temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 685, 706, 706, 1792], [1794, 1794, 1830, 1830, 3486]]}
{"id": "wtBBW3", "name": "Anti-alias any shader V2", "author": "GregRostami", "description": "This is SUPER FUN!  Copy/Paste the code to the bottom of any shader to add anti-aliasing.\nA huge thanks to Fabrice's code from this shader that showed me how to do this (see comments):\n[url]https://www.shadertoy.com/view/WlfyW8[/url]", "tags": ["2d", "boxfilter", "tool", "supersample"], "likes": 4, "viewed": 746, "published": 3, "date": "1599972458", "time_retrieved": "2024-07-30T20:45:36.509905", "image_code": "// This uses an idea that was created by Fabrice Neyret's:\n// https://www.shadertoy.com/view/WlfyW8 \n// It's an improvement to my previous box-filter.\n// Add the extra code at the bottom of this shader to any shader to anti-alias it. \n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = iResolution.xy,\n         u = ( 2.*fragCoord - r ) / r.y;\n    float m = 4.* sin(.1*iTime);\n\tfragColor = vec4 (fract( m / length(u) + atan(u.y,u.x)/3.14 + .3*iTime ));\n}\n\n\n// Add this code to the bottom of any shader to add Anti-aliasing:\n// Made a few changes to Fabrice's code:\n// Replaced the single for() loop with double for() loops (x,y) - Because it's faster.\n// Added min(T,1.0) to guarantee the output is maximum value of vec4(1.0)\n// Without the min() function, bright areas do not anti-alias.\n\n#define mainImage(O,U)                                     \\\n    vec4 T;                                                \\\n    int AA = 5, /* Set the Anti-Aliasing level (1-16) higher numbers are SLOW! */ \\\n        x = 0, y;                                          \\\n        float A = float (AA);                              \\\n    for (;x++ < AA;) for (y=0; y++ < AA; O += min(T,1.) )  \\\n        mainImage( T, U + vec2(x,y)/A-.5 );                \\\n    O /= A*A", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 239, 296, 296, 474]]}
{"id": "WtSfDc", "name": "Windows 98", "author": "timeisbeautifulhere", "description": "The good old days. (Click to interact.)\n\nDoes not work well on mobile, works better with a mouse.", "tags": ["mouse", "binary", "windows", "bitmap", "buffer", "click", "lag", "xp"], "likes": 5, "viewed": 392, "published": 3, "date": "1599963586", "time_retrieved": "2024-07-30T20:45:37.641878", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n/*\nBuffer displayed image to\nreplicate laggy window effect\nin Windows 98.\n*/\n\n#define XRADIUS 0.3\n#define YRADIUS 0.35\n\n//uv mapping of coordinate to a rectangle\nvec2 get_rect_uv(vec2 uv, vec2 origin){\n    \n    float width = XRADIUS*2.0;\n    float height = YRADIUS*2.0;\n    \n    vec2 rect_uv = uv-origin;\n    rect_uv.x+=XRADIUS;\n    rect_uv.y+=YRADIUS;\n    rect_uv.x/=width;\n    rect_uv.y/=height;\n    //rect_uv.y = 1.0-rect_uv.y;\n    \n    return rect_uv;\n}\n\nbool in_rect(vec2 uv, vec2 origin){\n    return abs(origin.x-uv.x) < XRADIUS &&\n        abs(origin.y-uv.y) < YRADIUS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n    \n    //Color background screen\n    if(iFrame==0 || all(equal(col,vec3(0.0)))){\n        //Windows 98 blue bg color\n        col = vec3(\n        \t0.0,\n            129.0/255.0,\n            127.0/255.0\n        );\n    }\n    \n    //Snap window to mouse position\n    vec2 mouseUv = (2.0*iMouse.xy-iResolution.xy)/iResolution.xy;\n    vec2 win_position = vec2(mouseUv.x, mouseUv.y-0.28);\n    \n    if(in_rect(uv, win_position)){\n        vec2 rect_uv = get_rect_uv(uv, win_position);\n        //Color rectangle from bitmap image in Common tab\n        col = img_texture(rect_uv);\n    }   \n\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n/*\nHacky code to read data from manually encoded 4-bit bitmap.\nWebGL seems to be able to handle only 4096 constants,\nso that means we have 4096 array values to work with.\n\nuints are 32 bits, so each uint in the array below has\neight 4-bit pixel values packed into it as hex. With 4096 as\nthe limit, this means we can manage an image of 4096*8 pixels.\n\nEach 4-bit pixel value of a bitmap is an index in the color\ntable. The color table is a 16 value array of RGB values\npacked into it as hex (which I also manually encoded).\n*/\n\n#define IMG_WIDTH 210\n#define IMG_HEIGHT 120\n#define IMG_LENGTH 3150\n#define PALETTE_LENGTH 16\n\n//Bitmap pixels packed into 32 bit uints.\n//Credit to Atom Smasher for generating a custom\n//Windows 98 error http://atom.smasher.org/error/\nuint img[IMG_LENGTH] = uint[](\n\t0xddddd111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x111111ddu,0xddddd222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22dddd21u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212121u,0x21212dd1u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0xd1112111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111211u,0x11111111u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x11121112u,0x111e23e6u,0x3e63e63eu,0x6e36e211u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11112656u,0x85685685u,0x68558656u,0x21111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x1111116cu,0x56656865u,0x65686656u,0x85611111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x656a8565u,0x65865655u,0x86566111u,0x11111111u,0x1111ddddu,0xd111dd11u,0x11111111u,0x11111111u,0x11111dd1u,0x11111111u,0x11111111u,0x1111111du,0xddddddd1u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11665668u,0x686568a8u,0x668a8561u,0x11111111u,0x11111dddu,0xddd411ddu,0x41111111u,0x11111111u,0x1111111du,0xd4111111u,0x11111111u,0x11111111u,0x1dddddddu,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11116586u,0x55656575u,0x65655656u,0x61111111u,0x1111111du,0xdd444411u,0xdd411111u,0x11111111u,0x11111111u,0x1dd41111u,0x11111111u,0x11111111u,0x111dd444u,0x44441111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111165u,0x68665668u,0x56866686u,0x85611111u,0x11111111u,0x1dd44111u,0x11dd4111u,0x11111111u,0x11111111u,0x111dd411u,0x11111111u,0x11111111u,0x11111dd4u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0xe5685666u,0x56566565u,0x65566111u,0x11111111u,0x111de411u,0x1111dd4du,0xddd1111du,0xdddd1111u,0x1dddddd4u,0x111dddd1u,0x111dd1ddu,0xd111111du,0x04111111u,0x1dd1ddd1u,0xdd1ddd11u,0xddddd111u,0x1dd1ddd1u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x12111111u,0x11656658u,0x5626a266u,0x8a868561u,0x11111111u,0x111111ddu,0xd11111ddu,0xdddddd11u,0x1dddddd1u,0x11ddddddu,0xd411ddddu,0xdd111dddu,0xddd41111u,0x1dddddddu,0x111dddddu,0xd4ddddddu,0x4dddddddu,0x111dddddu,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11116586u,0x56686656u,0x65656565u,0x61111111u,0x11111111u,0x1dddd111u,0xddd44dddu,0x4111444du,0xd41ddd44u,0x4dd41dddu,0x444dd11du,0xdd444411u,0x111dddddu,0xdd411dddu,0x4444ddd4u,0x44ddd444u,0xddd11dddu,0x44441111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11211111u,0x11111111u,0x11111166u,0x8a856556u,0x6565868au,0x85611111u,0x11111111u,0x11114dddu,0x11dd4411u,0xdd4111ddu,0xddd41dd4u,0x411dd41du,0xddddddd4u,0x1dd44111u,0x11111dd4u,0x4444411du,0xd44111ddu,0x4411dd44u,0x111dd41du,0xd4411111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x65565686u,0x66266865u,0x65686111u,0x11111111u,0x11111111u,0xdd41de41u,0x11dd411du,0xddddd41du,0xe4111de4u,0x1dddddddu,0xd41de411u,0x1111111du,0xe4111111u,0x1de41111u,0xde4111deu,0x41111dd4u,0x1de41111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111112u,0x11112111u,0x11675756u,0x5656a236u,0x8a856561u,0x11111111u,0x11211111u,0x11dd41ddu,0x4111dd41u,0xddd44dd4u,0x1dd4111du,0xd41dd444u,0x44441dd4u,0x11111111u,0x1dd41111u,0x111dd411u,0x11dd4111u,0xdd41111du,0xd41dd411u,0x11111111u,0x11121112u,0x11112111u,0x11121112u,0x11112111u,0x11121112u,0x11112111u,0x11121121u,0x11111111u,0x1111e55cu,0x56656865u,0x665656a8u,0x61111111u,0x11111111u,0x111ddd41u,0xdd4111ddu,0x41dd441du,0xd41ddd11u,0x1dd41dddu,0x1111d11du,0xd4111111u,0x111dd411u,0x11111dd4u,0x1111dd41u,0x11ddd111u,0xddd41dd4u,0x11111211u,0x21211121u,0x11121111u,0x21211121u,0x11121111u,0x21211121u,0x11121111u,0x21211111u,0x12111121u,0x11211165u,0x68a26665u,0x68566686u,0x55611111u,0x11112112u,0x1dddddd4u,0x41dd4111u,0xdd41ddddu,0xddd411ddu,0xddddd411u,0xddddddd4u,0x1dd41111u,0x12111dddu,0xddddd11du,0xd41111ddu,0x41111dddu,0xdddd441du,0xd4111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x12111121u,0x11121111u,0x6568a656u,0x58565665u,0x56586111u,0x11111111u,0x111dddddu,0x4411dd41u,0x11dd411du,0xddddd411u,0x1dddddd4u,0x111dddddu,0x441dd411u,0x1111211du,0xddddddd4u,0x1dd41111u,0xdd411111u,0xddddd441u,0x1dd41112u,0x11121112u,0x11211212u,0x11212111u,0x21112121u,0x12121112u,0x11211212u,0x11212111u,0x21111111u,0x11211111u,0x11656586u,0x85686858u,0x68a8a5e1u,0x11111111u,0x21211144u,0x44411114u,0x41111441u,0x11444444u,0x11114444u,0x44111144u,0x44411144u,0x11212111u,0x11444444u,0x44114411u,0x12144111u,0x21144444u,0x11114411u,0x11121112u,0x11112111u,0x11121111u,0x12111211u,0x11121112u,0x11112111u,0x11121111u,0x21211212u,0x12121112u,0x12122a86u,0x5656a8a6u,0x56a56568u,0x61121111u,0x11111211u,0x11111111u,0x11112111u,0x11111111u,0x11121111u,0x11111211u,0x11111111u,0x11111112u,0x12111111u,0x11111111u,0x11111112u,0x11111111u,0x11111111u,0x21211121u,0x12121111u,0x21211112u,0x12112111u,0x21211121u,0x12121111u,0x21211112u,0x11111111u,0x11111121u,0x11111166u,0x568a8656u,0x575868a8u,0xa5e11111u,0x11121212u,0x11211112u,0x12112111u,0x12112111u,0x11112111u,0x11111121u,0x11111112u,0x11212121u,0x21111211u,0x11111121u,0x12121211u,0x11121211u,0x11112121u,0x11111212u,0x11211112u,0x12112112u,0x12111211u,0x21111121u,0x11121112u,0x12112112u,0x12112121u,0x21212121u,0x21121211u,0x26858658u,0x58685655u,0x86562111u,0x11111111u,0x11111121u,0x11121111u,0x21121112u,0x12121112u,0x12121211u,0x11212121u,0x12111111u,0x11121211u,0x12121211u,0x21111111u,0x21211112u,0x12121111u,0x11212111u,0x12111212u,0x11121112u,0x11112112u,0x11121211u,0x21211112u,0x11121112u,0x11112111u,0x12111211u,0x11121112u,0x11126566u,0x66656656u,0x66666212u,0x11111111u,0x21212121u,0x11121111u,0x21211111u,0x21111111u,0x21111111u,0x11211111u,0x11111121u,0x21212111u,0x11211111u,0x11111212u,0x12111121u,0x11111112u,0x12121111u,0x21111121u,0x11112111u,0x21112111u,0x11112111u,0x12111121u,0x21112111u,0x21112111u,0x12111121u,0x11212111u,0x21112111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11211112u,0x11111112u,0x11121112u,0x11111211u,0x21112112u,0x11211211u,0x11111111u,0x12111111u,0x12112111u,0x11111111u,0x11211211u,0x11111112u,0x11111211u,0x11121111u,0x11111111u,0x21121111u,0x21111111u,0x11111111u,0x11111111u,0x21111211u,0x11111111u,0x11111111u,0x11111211u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111110u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00011111u,0x10000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000111u,0x11100000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000001u,0x11111000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x01111110u,0x03000300u,0x03f03f03u,0x0003f03fu,0x003f03f0u,0x03f003f0u,0x03f003f0u,0x3f003f03u,0x0003003fu,0x00300300u,0x03f03000u,0x3003003fu,0x003f0300u,0x03003f00u,0x30003f03u,0x00030003u,0x0030003fu,0x003f03f0u,0x03000300u,0x30003003u,0x00030003u,0x00030003u,0x00030030u,0x00300030u,0x003f0030u,0x00300300u,0x03f11181u,0x100f00f0u,0x0f000000u,0xf00f0000u,0x000f0000u,0x00000f00u,0x00f000f0u,0x00000f00u,0x0f00f0f0u,0x0000f00fu,0x0f000f00u,0xf00f00f0u,0x0000000fu,0x00f0f000u,0x0f00f000u,0x0f00f000u,0xf00f00f0u,0x00f00000u,0x00f000f0u,0x0f000f00u,0xf000f00fu,0x0f000f00u,0xf000f00fu,0x000f000fu,0x00f0000fu,0x000f00f0u,0x0f000111u,0x111f0000u,0x00000000u,0x00000000u,0x00f00000u,0x0f000000u,0x00000000u,0x0000f000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000f00u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x000000f0u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000001u,0x18111000u,0x0e0000e0u,0x0f0000e0u,0x0000f444u,0x444440f0u,0x0e000e00u,0x0e000000u,0xe0000000u,0x00000f00u,0x00000e00u,0x00000000u,0x00000000u,0x0000e000u,0x000e0000u,0x000f0000u,0x00e00000u,0x00000e00u,0x0f0e0000u,0xe0000000u,0x00000000u,0x0e0000e0u,0x000000e0u,0x00000000u,0x0f000000u,0x00000e00u,0x00000000u,0xf111111fu,0x03f003f0u,0x0f000e00u,0x0006444bu,0xbbbbbbb4u,0x44f003f0u,0x003f00feu,0x00000fe0u,0x3f0e00e0u,0x30f0e000u,0x00600e00u,0x6000fe00u,0x6000e000u,0x06000000u,0x3f0e000eu,0x06000f3fu,0x0ef3f000u,0x3f00000fu,0x3f000f3fu,0x0e060006u,0x00003f00u,0x03000600u,0x00f3f0e0u,0x600300e0u,0x3f006000u,0x0f3f0e00u,0x60011111u,0x10f000f0u,0x000f3000u,0xf3000bbbu,0xbbbbbbbbu,0xbbbb40f0u,0x000f0003u,0x00f3f030u,0x0f00f300u,0x0f00000fu,0x30000000u,0x00000300u,0x000000f3u,0x00000f30u,0x0f0000f3u,0x00000000u,0x00000000u,0x0f000f30u,0x00000000u,0x00000000u,0x00000f00u,0x0f0f0000u,0xf3000000u,0x0000f000u,0x0f00000fu,0x30000000u,0x0000f111u,0x11100000u,0x00003000u,0xf000f44bu,0xbbbbbbbbu,0xbbbbbbbbu,0x4f00f000u,0x0f000000u,0x0f000000u,0xf0000003u,0xf00f0000u,0x3f00000fu,0x0000003fu,0x00f00000u,0x00f00003u,0xf0000003u,0xf0000000u,0x0f000000u,0x00f00006u,0x00000000u,0x000003f0u,0x00000000u,0x00000f00u,0x00000000u,0x00f00000u,0x0000f000u,0x03f00031u,0x11811000u,0x0000f0f0u,0x000000bbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbb40300u,0x00000000u,0x00000000u,0x00000000u,0xf0000000u,0x00003000u,0x000f3000u,0x00000000u,0x0000000fu,0x00000000u,0x00000f00u,0xf0030000u,0x00000000u,0x000000f3u,0x00030f00u,0x000f3000u,0x03000000u,0x000f3000u,0x0f0300f3u,0x0000000fu,0x00f00000u,0xf111111fu,0x03f00600u,0x00000034u,0xbbbbbbbbu,0xbbbbbbbbu,0xbbbbbbbeu,0xf000f000u,0xf0000000u,0x0f00004eu,0x00000000u,0x00f00f0fu,0x4e000000u,0xf0000000u,0x3f000000u,0x000000f0u,0x00f00003u,0x000000f0u,0x04e0f000u,0x60000006u,0x000f00f0u,0x00000000u,0xf00f0000u,0x000f4e00u,0xf00000f0u,0x0000004eu,0x00000000u,0x00011111u,0x10f00000u,0x0000000fu,0xfbbbbbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0x460000f3u,0x00f3f000u,0x60003f0eu,0x40600000u,0x0f030000u,0x0e43f000u,0x000f0e40u,0xf00f3006u,0x00600000u,0x0f300f00u,0xf0f30e00u,0x00e40030u,0x00000300u,0x00000000u,0x00006000u,0x000000f0u,0x0f300e40u,0x000f3000u,0x00000f0eu,0x40f30000u,0x0000f111u,0x111f0000u,0x00000060u,0x004bbbbbu,0xb0bbbbbbu,0xbbbb0bbbu,0xbbbb5f03u,0x00000000u,0x0000000fu,0x004e0000u,0x3f0300f0u,0x00004ef0u,0x00f00000u,0x4e000000u,0x00000000u,0x06000000u,0x000000f0u,0x000f04e0u,0xf0000000u,0xf0000000u,0x00000000u,0x000e0000u,0x00000f00u,0x4e000000u,0xf000e000u,0x3f4e000fu,0x003f0001u,0x11111000u,0x00003000u,0x00ebbbbbu,0xbbd00bbbu,0xbbbbbd00u,0xbbbbbb40u,0xf00f0000u,0x000000e4u,0x440e4044u,0x4f0e4440u,0x0e444440u,0xe4440e44u,0x4e440e44u,0x40e40004u,0x00004440u,0xe400e40eu,0x444300e4u,0xe44400e4u,0x4400e444u,0xf3f0e444u,0x0e4440e4u,0x4430e444u,0x0e4e4440u,0x0e44400eu,0x44444000u,0x000f00f3u,0x0111111fu,0x300f3f0fu,0x000004bbu,0xbbb00dddu,0xbbbbbb00u,0xdddbbbbbu,0xb600000eu,0x00f03f00u,0x40e04e44u,0xee04e00fu,0xe4e40efeu,0x4e40e04eu,0x4eef4ee4u,0x0ef4e4e0u,0x04e004e0u,0xe4e04e4eu,0x040e04efu,0x044e0e4eu,0x000e4e40u,0xe04e004eu,0x0e4e4ee0u,0xf00e4e4fu,0xe04e44e0u,0xe4e40e04u,0xe4fe0e4eu,0xf00e0000u,0x00f11111u,0x10f00000u,0x000300fbu,0xbbbbbbddu,0xdd0bbbbdu,0xddddbbbbu,0xbb465000u,0x0000f000u,0xe0e440feu,0x400fe40eu,0x4444e400u,0x0e4e4444u,0x4e400e4fu,0xe400e4e4u,0x00e400e4u,0x44440fe4u,0x0fe44444u,0x00e400feu,0x40e4444fu,0xe440000eu,0x400f0e40u,0x00e44440u,0xe440fe40u,0xf0e4e444u,0x44e40f0eu,0x40300000u,0x0000f111u,0x111f0000u,0x00000f00u,0x4bbbbbbbu,0xbdddddbbu,0x0ddddbbbu,0xbbbbb46fu,0x0003f000u,0x0000f004u,0xe04e0004u,0xe40ef4e4u,0xe0004e4eu,0xefe04e00u,0x4e04e004u,0xe4e0f4efu,0x04eefee0u,0x04e004eeu,0xfee004e0u,0x004e4fe0u,0x4e0004efu,0x004e0000u,0x4ef040e0u,0x4e0004e0u,0x4e0004e4u,0xeefe04e0u,0x004ef0f0u,0x3f000001u,0x11111000u,0x0e000000u,0x0fbbbbbbu,0xbbbbddddu,0xddddddbbu,0xbbbbbbb4u,0x50f0f003u,0x000f304eu,0x0e4e4f00u,0xe4e400e4u,0xe4f0e44eu,0x400e4e4fu,0x0e40e40fu,0xe4fe4e40u,0x00e40004u,0x0e4e40e4u,0x00040fe4u,0xf00e4e40u,0x0e4e4e0eu,0x400e4f0eu,0x4e400e40u,0xfe4e4e0eu,0x4e4000e4u,0xe400e4e4u,0x00e44000u,0x000060f3u,0x01111110u,0x003f00f0u,0x00004bbbu,0xbbbbbbbdu,0xdddddddbu,0xbbbbbbbbu,0xbb660000u,0x0f000000u,0xf4440f4eu,0x00f4ef44u,0x44e04444u,0x4e044400u,0x4e0004e0u,0x444e0004u,0xe004e044u,0x4e04e0f4u,0xe0444e00u,0x04e03f4eu,0x04444e04u,0x440e0f04u,0x44e04e00u,0x04444e04u,0x440f4ef3u,0xf4e04440u,0x0f44444eu,0x00000000u,0x00011181u,0x100f0000u,0x03f00fbbu,0xbbbbbbbbu,0xbbddddddu,0xbbbbbbbbu,0xbbb465e0u,0x0000ef00u,0x00e0e0e0u,0x0f3e000eu,0xefe00feeu,0x0e0fe0e0u,0xef000e00u,0xf0ef000eu,0x400e00feu,0x0e0f000eu,0x00fe0e0fu,0x00e00f00u,0x00fee00fu,0xe0ef0000u,0xee00f00fu,0x0efee00fu,0xe0e0e000u,0x00000feeu,0x00e0ee0eu,0x0f00f000u,0x0000f111u,0x111f0000u,0x000f0000u,0x4bbbbbbbu,0xbbbb0dddu,0xddbbbbbbu,0xbbbbbb56u,0xf0000000u,0x000f000fu,0x00000000u,0x00000000u,0x000f0000u,0x0f0003f0u,0x00000000u,0x04e0f000u,0x300f0000u,0x00000000u,0x0030f000u,0x000e0000u,0xf0000003u,0xf0000f30u,0x00300000u,0x00000f00u,0x00f000f0u,0x0000000fu,0x000003f0u,0x00000001u,0x18111300u,0x000e0000u,0x0fbbbbbbu,0xbbbbbdddu,0xdddd0bbbu,0xbbbbbbb4u,0x6500f3f0u,0x00003000u,0x0f30000fu,0x00f30000u,0xf3000030u,0x003000f0u,0x000f30f3u,0x0ef0003fu,0x0f00000fu,0x30f3f003u,0xf00f0000u,0x000000f3u,0x000f3000u,0x00f30000u,0x0000f003u,0xf000f300u,0xf30000e0u,0x03000f30u,0x003f0000u,0x0300f300u,0xf111111fu,0x0f060000u,0x06004bbbu,0xbbbbbb0du,0xddddddddu,0xbbbbbbbbu,0xbb66ef00u,0x0003f0f0u,0x000000f0u,0x000000f0u,0x0000f000u,0xf0f0f000u,0x00003f00u,0x000f0000u,0xf0000000u,0x30000000u,0x0f000000u,0x03f00600u,0x00000000u,0xf00000f0u,0x00f00f00u,0x0f000300u,0x00000f00u,0x000f0f00u,0x0f00f000u,0x0f00f000u,0x0f011111u,0x100000f3u,0x000000bbu,0xbbbbbbbdu,0xddddbbddu,0xdd0bbbbbu,0xbbb45600u,0x0000f000u,0x00f30000u,0x00f30000u,0x0f300000u,0x0000000fu,0x00000f00u,0x000000f3u,0x00000000u,0x0f0f000fu,0x00000000u,0x00f00000u,0x0000f000u,0x000f0000u,0x00000000u,0x000000f0u,0x0f000000u,0x0f300000u,0x00000000u,0x00000000u,0x00000111u,0x111f0000u,0x00000000u,0x64bbbbbbu,0x0ddddbbbu,0xbdddddbbu,0xbbbbba66u,0xe0000f00u,0x00e000f0u,0x0000000fu,0x00000f00u,0x00600000u,0x0003f000u,0x000f0000u,0x0000000fu,0x00f00000u,0x00000000u,0x60000000u,0x0003f000u,0x3f000030u,0xf000f3f0u,0x00000000u,0x0000000fu,0x00000f00u,0x003f0000u,0x00f0e000u,0xe000f031u,0x11111000u,0x00000000u,0x000bbbbbu,0xbdddddbbu,0xbbbbddddu,0x0bbbbb45u,0x6500000eu,0x00000000u,0x00006000u,0x00000000u,0x0000000fu,0x30000000u,0x00000000u,0x000000f3u,0x00030000u,0x00000f30u,0x00006000u,0x00000000u,0x0000000fu,0x00000000u,0x00f30060u,0x0f0000f3u,0x00f30000u,0x000f0000u,0x60003006u,0x0000e000u,0xf111111fu,0x30003f00u,0x03f004bbu,0xbbbbdddbu,0xbbbbbbbdu,0xddbbbbbbu,0xb66e0f03u,0xf00003f0u,0x000e0000u,0x0006003fu,0x00060000u,0x0000f000u,0xf0e0f3f0u,0xe03f00f0u,0x000f00f0u,0x006003f0u,0x0f000000u,0x003f00f0u,0x000f0006u,0x00000060u,0x0000e000u,0x000000e0u,0x0000000fu,0x00060000u,0x0000000fu,0x000003f0u,0x00f11111u,0x1000f000u,0x00f0000fu,0xbbbbbbbdu,0xbbbbbbbbu,0xbbdbbbbbu,0xb4656000u,0x00000f00u,0xf3f00f30u,0x0000000fu,0x00000000u,0x030000e0u,0x00300000u,0x000f0000u,0x00000000u,0x00000000u,0x00000000u,0x00f00f30u,0x00f30000u,0x00000000u,0x00000000u,0x00000f30u,0x000f00e0u,0x00000000u,0x0f300000u,0x000000f0u,0x00000111u,0x111f0000u,0x00f00000u,0x0004bbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbba6260u,0x00000030u,0x00000000u,0x00003f00u,0x00000000u,0x000f0f00u,0x000f0f00u,0x00000000u,0x03f0e00eu,0x000e0000u,0x0f000003u,0x00000000u,0x0000000fu,0x00000003u,0xf0000060u,0x00f00300u,0x00f00000u,0x00006000u,0x00000000u,0x00000000u,0x00003f01u,0x111110f0u,0x0000000fu,0x3f00fbbbu,0xbbbbbbbbu,0xbbbbbbbbu,0xbbbb4565u,0x0e0f00f0u,0xf0000000u,0x0000f000u,0x00000f30u,0x00300000u,0x00f30000u,0x0f000600u,0x0f0000f0u,0x0f300f30u,0x0000e00fu,0x0f000300u,0x0000f000u,0x0e00300fu,0x00003000u,0x0030000fu,0x0000f300u,0xf3000000u,0x00f300f0u,0x00f3000fu,0x30000f00u,0xf1111110u,0x030f03f0u,0x00000003u,0x4bbbbbbbu,0xbbbbbbbbu,0xbbbbbb66u,0x60f00030u,0x00000f00u,0xf0060000u,0x00030000u,0x00f00f00u,0x0003f000u,0x00030000u,0x00000000u,0x30000f00u,0x00f003f0u,0x0000000fu,0x000f00e0u,0x000000f0u,0x0000000fu,0x00000f00u,0x00000000u,0x0f00f000u,0x00300000u,0x0006000fu,0x0000f000u,0x00011881u,0x10f00000u,0x00000000u,0x0ff4bbbbu,0xbbbbbbbbu,0xbbbbb446u,0x56500000u,0xf00000e0u,0x03000000u,0x00000f0eu,0x00000000u,0x0e0f000fu,0x000f0f00u,0x00030e00u,0xf0f00000u,0x00000f00u,0x0f300000u,0x000e000fu,0x300f3000u,0x0000e000u,0x00000000u,0x0f000f00u,0x00000000u,0x0000000fu,0x00000000u,0x00000000u,0x0000f111u,0x111f0000u,0xe0006000u,0xf00000a4u,0xbbbbbbbbu,0xbbbbbbbau,0x6656ef00u,0xf000e000u,0x000f0000u,0x003f00f0u,0x0000f000u,0x00000000u,0x0000e000u,0x003f00f0u,0x00000000u,0x00000000u,0x000000f0u,0x3f000003u,0xf000f00fu,0x00006000u,0x0f000000u,0x000300e0u,0x30f0e000u,0x003f000fu,0x000e0000u,0x00003f00u,0x03f003f1u,0x11111000u,0x00f00000u,0x003f0000u,0xfab4bbbbu,0xbbbbbb44u,0x26566000u,0x00000000u,0xf3000000u,0x000f0000u,0x00f300f3u,0x00600f30u,0x00000000u,0x00f00000u,0x00f30000u,0xf300600fu,0x30000000u,0x0000600fu,0x00000000u,0x00000000u,0xf300600fu,0x300f0f00u,0x0f000000u,0x600f0000u,0x0030000fu,0x30000f00u,0x00f00f00u,0x0111111fu,0x03f00300u,0x00000000u,0x0000e654u,0x4b4b4b46u,0xa66a6e0eu,0x00003f00u,0x3f00f000u,0x00600000u,0x0e00000fu,0x00000000u,0x0f006003u,0xf0000000u,0x000000f0u,0x0000f000u,0x0000f000u,0x00e00000u,0x00000000u,0x00000600u,0x00000000u,0x000f0000u,0x00000003u,0xf0000000u,0x0f000f00u,0x0300f000u,0x00e00000u,0x00011111u,0x100000f0u,0x00f300f0u,0x00f0000fu,0x6a665665u,0x66562600u,0x00000f00u,0x0f000000u,0x60000000u,0x000f3000u,0x00000000u,0x00000000u,0x0000f300u,0xf00f0000u,0x0f300000u,0x00000000u,0x0600f000u,0x0000000fu,0x00060000u,0x00000000u,0x00000000u,0x0f30000fu,0x00000000u,0x0030e000u,0x00f00006u,0x0000f000u,0xe000f111u,0x111f0000u,0x0000000fu,0x000e0000u,0x0000e656u,0x65662000u,0x000000f0u,0x00000000u,0x00000000u,0x3f00000fu,0x0000e00fu,0x03000000u,0x000f0000u,0x0fe03f03u,0xf0000f00u,0x00003f00u,0xe0000000u,0x00030006u,0x00300000u,0x00030000u,0x00003f00u,0xe00000f0u,0x00000003u,0x000ef000u,0x000f0000u,0x000003f0u,0x3f0003f1u,0x1181100fu,0x00000000u,0x0000f300u,0x0e00000fu,0x0e0e0000u,0x00e000f3u,0x000e0000u,0xf3000000u,0x0000f300u,0x000f3000u,0x000f00f3u,0x0000000eu,0x00000000u,0x000e0000u,0x0000f000u,0x00f30000u,0xf3000f00u,0x000f0000u,0x00000f00u,0x0600f000u,0x00060000u,0x0f300000u,0xf0f0000fu,0x00f30000u,0x00000f00u,0x000000f0u,0x0111111fu,0x03000600u,0x00e003f0u,0x0f000000u,0x0e000000u,0x0f0003f0u,0x0000000fu,0x3f000f00u,0x3000f000u,0xf000000fu,0x003f0000u,0x00f0003fu,0x00000000u,0x00000000u,0x0e006000u,0x00000000u,0x00000f00u,0x00000000u,0x030003f0u,0x00000000u,0x00030000u,0x00e000f0u,0x00000000u,0x00000000u,0x00f00000u,0x00000000u,0x00011811u,0x10f00000u,0x06000f00u,0x0000f30fu,0x0000000fu,0x00030f00u,0x00000600u,0x00000000u,0x00f00000u,0x000f0e00u,0x000f0000u,0x000000f0u,0x0f300f30u,0x0f00f000u,0xf3000000u,0x00060000u,0x0f300000u,0x00003000u,0x00f00f00u,0x00f30003u,0x0000f000u,0x00000000u,0x0060000fu,0x30006000u,0xfe0030f3u,0x0000f00fu,0x3000f111u,0x11100000u,0x00000000u,0x00000000u,0xf0000000u,0xf0000f00u,0x00000000u,0x00000000u,0x00000000u,0x3f000030u,0x00000000u,0x0e03f00eu,0x000000f0u,0x0f0000e0u,0x0000f000u,0x00300000u,0x00f000f0u,0x000600f0u,0x00000000u,0x00000000u,0x00f00f00u,0x00003f00u,0x0f000000u,0x300f0000u,0x000000f0u,0x00000000u,0x000f0001u,0x11111000u,0x0030000fu,0x30000000u,0x000f300fu,0x300f3000u,0x00f00060u,0x000000f0u,0xe0f3f000u,0xf000e000u,0xf0f30f00u,0x0000f000u,0x00000000u,0x00000f30u,0x0f30000fu,0x300f0000u,0x0f300000u,0x00000000u,0x00f3f0e0u,0x00000000u,0x0f000030u,0x0000f00fu,0x30003000u,0x00f00000u,0x000f3000u,0x0000f00fu,0x3e000f30u,0xf111111fu,0x0600f000u,0x0000f006u,0x00000000u,0xf0000000u,0xf0000300u,0x000003f0u,0x03000000u,0x0e000000u,0x0f0000f0u,0x00600000u,0x0003f00fu,0x00000000u,0x00000f00u,0x00000000u,0x00000000u,0x00060000u,0x00000000u,0x00f3f00fu,0x00000000u,0xf000f300u,0x0000f00fu,0x00000000u,0x03000000u,0xf000e000u,0xe000f000u,0x00011181u,0x1000000fu,0x30000000u,0x0000600eu,0x00000000u,0x0000000fu,0x00000f00u,0x00f0f000u,0x00f30000u,0xf3000000u,0x00000300u,0x0f00f003u,0x00e0f30eu,0x000f0000u,0x0000f000u,0x00f30000u,0x06000000u,0xf300e000u,0x00000000u,0x03006000u,0xe000000fu,0x00000000u,0x0000e000u,0x0f0f0000u,0x0000000fu,0x30000000u,0x0000f111u,0x11100000u,0x0000f000u,0x00000000u,0x00000e0fu,0x00e00060u,0x00000300u,0x00000000u,0x00f0000fu,0x00000000u,0x00000000u,0xf0003000u,0x0f000000u,0xf0000000u,0x00060000u,0x00f0000fu,0x00000000u,0x03000f00u,0x0f006000u,0x00e0f000u,0x000000feu,0x00000f0eu,0x0000003fu,0x00000000u,0x3f000600u,0x0000f000u,0x000f0001u,0x18111003u,0x00000000u,0x0f300030u,0x000f3000u,0x00f30000u,0x000000f0u,0x00f0e000u,0x00030000u,0x0f30f00fu,0x30e0f300u,0x0000f0f0u,0x00000f00u,0x0000f300u,0xf3000003u,0x00003000u,0x00000000u,0x00f00000u,0x0f300000u,0x0f000000u,0x0000f300u,0x00000000u,0x0000600fu,0x0f30e000u,0x0f000000u,0x300000f3u,0x00f30f30u,0xf111111fu,0x00f00000u,0x03f000f0u,0x0f00000fu,0x003f000fu,0x00000060u,0x00003000u,0x06000f00u,0x0f000000u,0x000f0000u,0x0f000000u,0x000e0000u,0x30f00000u,0xf000f000u,0x00f00f0fu,0x0e000600u,0x30000000u,0x00000000u,0x00030000u,0x00003f00u,0xf0003f0eu,0x3f003f00u,0x000000f0u,0x03f00000u,0x000f0000u,0x00f00000u,0x00011111u,0x10000f0eu,0x0f000000u,0x00000000u,0x00f00000u,0x00003000u,0x0000f0f0u,0x00000000u,0x000000f0u,0x0e000000u,0x00006000u,0xe0000f00u,0x0f000060u,0x00000000u,0x000000e0u,0x00000000u,0x00f00000u,0x00600000u,0x00000f00u,0xf300f000u,0x00000f00u,0xf000f000u,0x00000000u,0x00f0000fu,0x3000000fu,0x00000000u,0x0000f111u,0x111f3f00u,0x30000000u,0xe0000003u,0xf0000000u,0x000000f0u,0x00000000u,0x00030000u,0x3f0e03f0u,0x000000f0u,0x00600000u,0x003f0034u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x4e00f000u,0x00000000u,0x00000000u,0x00000000u,0x0f000000u,0xe00f0000u,0x03000000u,0x0fe00001u,0x11111000u,0x000f000fu,0x000f300fu,0x00f30000u,0x0000f300u,0x00000f3eu,0x0000f000u,0xf0000f00u,0x00006000u,0x30000000u,0x00f0000fu,0xe4ddeddeu,0xddeddeddu,0xeddeddedu,0xdeddeddeu,0xddeddeddu,0xeddeddedu,0xdeddeddeu,0xd0400000u,0x00060006u,0x00000000u,0x00003006u,0x00030000u,0x0000000fu,0x00f0f0e0u,0xf3000f00u,0xf111111fu,0x0000f003u,0xf003f00fu,0x0000000fu,0x0e060000u,0xf000f300u,0x00000000u,0x00000000u,0x0000e000u,0x000f0000u,0x03000000u,0x0004e000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00064e0fu,0x0003f000u,0x000003f0u,0x03f00f0fu,0x000000f0u,0x00600000u,0x03000000u,0x3f000000u,0x3f011811u,0x10000000u,0x00000000u,0x00e00000u,0x00000000u,0x000e000fu,0x00000f3fu,0x00000060u,0x00000030u,0x00000000u,0x00f00000u,0x0f00e4d0u,0xf0000f00u,0x0f000f00u,0x00f000f0u,0x000f000fu,0x0000f000u,0xf0000f00u,0x0f00e54fu,0x300f0000u,0x000000f0u,0x00f00000u,0x00000000u,0x00000f30u,0x0f0f0e00u,0x00000f00u,0xf0000111u,0x111f0060u,0x000000f0u,0x0000000fu,0x00000300u,0x03f00000u,0x00000f00u,0x00006000u,0x00003f00u,0xf00003f0u,0x003f0000u,0x03f00004u,0x00000000u,0x00000000u,0x00f00000u,0x000f0000u,0x0000f000u,0x00000f00u,0x000000f6u,0x4e000000u,0x00003000u,0x00000000u,0xe0000000u,0x00e00000u,0x00f00000u,0x00f00000u,0x00000001u,0x11811000u,0x0000f00eu,0x00000f30u,0x003f00f0u,0x0f0000f3u,0xf000f300u,0x00000000u,0x30000f00u,0x000000f0u,0x00f00000u,0x00f00300u,0xe4d0e00fu,0x000e0000u,0xe0000e00u,0x00e00000u,0x00e0000eu,0x0000e000u,0x000e0000u,0xe540f00eu,0x000000f0u,0x0000e000u,0xf300f300u,0xf3000f30u,0x00000e00u,0x0f030f00u,0x00f30000u,0xf1111110u,0x030003f0u,0x00006000u,0x0f000f00u,0x00000000u,0x00000e00u,0x0f00f000u,0x000f0000u,0x000f000fu,0x00000000u,0x00ef0000u,0xf0f40e00u,0x00e000f0u,0x0f000000u,0x000f0000u,0xe00f0000u,0x00000f00u,0x00e0000fu,0x00064e00u,0x00006000u,0x0003f000u,0x0000f000u,0x0f00f000u,0x00000000u,0x03f00000u,0x0060000fu,0x03f11111u,0x10f00f00u,0x0f300000u,0x00000000u,0x0000000fu,0x000f0000u,0x000e0030u,0x00000000u,0x000003f0u,0x300000e0u,0x00f30000u,0x0000e400u,0xf00000f3u,0x000300f3u,0x00e44444u,0x40e43006u,0x00f3f003u,0x00f3f00fu,0x300ef540u,0x0f300000u,0x000f00f3u,0x00600000u,0x00000000u,0x00f00f30u,0x0f000000u,0x00000000u,0x00f00111u,0x111f0000u,0x00000000u,0x003f000eu,0x00e06000u,0x3f0e0000u,0x3f000000u,0xf0f00000u,0x06000600u,0x000f0003u,0xf00f0000u,0x00e00004u,0x00003f00u,0x0000f0f0u,0x00f04fe0u,0xeef4e4efu,0x00000000u,0x00f00000u,0x0000f006u,0x4ef000f0u,0x003f0000u,0x00000000u,0x0000e000u,0x003f0000u,0x0f000000u,0x06000000u,0x00e00001u,0x11111000u,0x00e000f0u,0x00000060u,0x00000000u,0xf0000300u,0x0f0000f3u,0x000000f3u,0x00000000u,0x00000000u,0xf0003000u,0xf3f000f0u,0xe4d0000fu,0x30000000u,0x00000e40u,0x0000e4e4u,0x00000000u,0x00000000u,0x00000000u,0xe5400000u,0x000000e0u,0x000f0000u,0x00f30000u,0x600f0000u,0x00000000u,0x00000300u,0xf3000000u,0xf111111fu,0x3f000000u,0x0000f000u,0x00003f00u,0x0000000fu,0x0f00000fu,0x000f00e0u,0x3f000000u,0x000000f0u,0x0e0000f0u,0x00000000u,0x3004e00fu,0x0000f000u,0x0e000000u,0x4e0f0004u,0xe4e04e00u,0x3f00f000u,0x0f00f3f0u,0x00064e00u,0x000000f0u,0x000f0000u,0x003f00f0u,0x00000000u,0x03f0e006u,0x003f0000u,0xf0000f00u,0x3f011811u,0x1000f300u,0xf3000300u,0x00000f00u,0x00030000u,0x00000000u,0x30000000u,0xf0000000u,0x03000e00u,0x00000000u,0x00f00000u,0x0f0fe4d0u,0x00000000u,0xf3000f3fu,0x0e400300u,0xe4e4e400u,0xf0000006u,0x00030000u,0x000ef540u,0x0600f300u,0x00000300u,0x00f00000u,0x0f300000u,0x00f00000u,0x00000000u,0x00000000u,0x0f000111u,0x111f0000u,0xf000f00fu,0x00000000u,0x0003f0f0u,0x0f000006u,0x00f00000u,0x3f00000fu,0x000f0f00u,0x3f03f000u,0x00000000u,0xf0000004u,0x000000f0u,0x0000f000u,0x00004ef0u,0xf0f4e44eu,0x00000000u,0x300000f0u,0x00000005u,0x4ef00000u,0xf003f00fu,0x00060000u,0x00000000u,0x03f00000u,0x03000000u,0x00000000u,0x00000001u,0x11111000u,0x000000e0u,0x000f00f3u,0x000f0000u,0x0000f300u,0x00000f00u,0xf0000000u,0x0f300000u,0x0f000000u,0x0f30e0f3u,0x00060000u,0xe4000600u,0x0060000fu,0x000f0e40u,0x0000e4e4u,0x04600000u,0xf0000000u,0x0f00f30fu,0xe6400000u,0x0000f000u,0x00000000u,0x000000f0u,0x0f000e00u,0x00f000f0u,0x00600060u,0xe0f30000u,0xf1111110u,0x00000000u,0x00000e03u,0x00f00000u,0x00003f00u,0x00000000u,0x0e000000u,0x00e000f0u,0x0000000fu,0x006000f0u,0x00000000u,0x0004e000u,0x00000000u,0x00300000u,0x4e000004u,0xe4ef4000u,0x60000000u,0x000e0000u,0xf0064e00u,0x03f00000u,0x00600000u,0x00060000u,0x00000000u,0x00600000u,0x00000000u,0x000000f0u,0x06011181u,0x1f300600u,0x600f3000u,0xf0000000u,0xf000f000u,0x00000030u,0x00300000u,0xf3f00000u,0x0f300000u,0x00000000u,0x00000000u,0x030fe4d0u,0x00003000u,0x00f00f00u,0xe0e44444u,0x40e400e4u,0x00000000u,0x0f300000u,0x0000e540u,0x000000e0u,0x00000000u,0x0300000fu,0x300f300fu,0x00000000u,0x000f3000u,0x00003000u,0x00000111u,0x111f0000u,0x0000000fu,0x00000000u,0x03000e00u,0x00e0f000u,0xf0f00f00u,0x60000000u,0x00000f00u,0x06000000u,0x00003f0fu,0x0000f004u,0x0000000fu,0x00300000u,0x03f000feu,0xe0eef00eu,0x00000003u,0xf0000f00u,0x3f0000f6u,0x4ef00000u,0x0003f000u,0x03f0f000u,0x0000f000u,0xf0300000u,0x003f0000u,0x003f000fu,0x00000001u,0x18111000u,0x00000000u,0x000000f0u,0x0f0f0000u,0x00000006u,0x00000000u,0x00000000u,0x0f30e000u,0x00000300u,0xf3000f00u,0x03000000u,0xe40f0000u,0x0000f00eu,0x00f00000u,0x00f00000u,0x000f3000u,0xf000e000u,0xf0006000u,0xe5400e00u,0xf30f0000u,0x00000000u,0x03000000u,0x000f00f3u,0x000f0000u,0x00f00000u,0x00000003u,0xf111111fu,0x00000300u,0x00000060u,0x00300000u,0x3f006003u,0x00000000u,0x00000000u,0x06000f00u,0x00000000u,0xf0000f00u,0x0000f00eu,0x00040e00u,0x06000000u,0x00000000u,0x03f00003u,0xf00f300fu,0x000000f0u,0x00000000u,0x00064ef0u,0x0000f000u,0x0000f000u,0x000f0f0eu,0x00e00000u,0x000f0000u,0x06000000u,0x00f00600u,0x0f011111u,0x103f000fu,0x000f3000u,0x0000f000u,0x0f000000u,0xf0000060u,0x006000f3u,0x00000000u,0x0000f300u,0x00000000u,0x000e0000u,0x00f0e400u,0x00000000u,0x00f30000u,0x0f00000fu,0x00000f00u,0x0000e000u,0xf3000000u,0x0000f540u,0x00600000u,0x000f3000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x0f030000u,0x00000111u,0x111f0000u,0x00003f00u,0xf0000000u,0xe0000000u,0x00000000u,0x00000000u,0x000f0000u,0x0003f000u,0xf0000000u,0xf0e00f00u,0x0f3f0004u,0x00000000u,0x060000f0u,0xf3f00000u,0x30000000u,0x00000000u,0x3f000f00u,0x60003f05u,0x4ef00000u,0x00060000u,0xf0e06000u,0x0003f003u,0xf0e00f00u,0x3f000000u,0x3f0000f0u,0x0003f001u,0x11111000u,0x0f000f00u,0x00003000u,0x0f3f000fu,0x30000000u,0x30000000u,0x3000000fu,0x3000f00eu,0x000000f3u,0x00f30003u,0x00000000u,0xe4d56565u,0x65656565u,0x65665656u,0x56665656u,0x56565656u,0x56656565u,0x65656656u,0x26403000u,0x00000000u,0x00000000u,0x0600f000u,0xf000f030u,0xf000f300u,0x0f00e000u,0x00000000u,0xf111111fu,0x00003f00u,0x000000f0u,0xf0000000u,0x0000f000u,0x00f00030u,0x000f0000u,0x0000f000u,0x00000060u,0x000f000fu,0x00f00000u,0x03f44444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444444u,0x44444e0fu,0x003f0000u,0x000e0030u,0x00000000u,0x00000000u,0x0f000000u,0x0f000000u,0x3f00000fu,0x00011111u,0x1300f000u,0x00000000u,0x00000000u,0x06000000u,0xf3000000u,0xf0000000u,0xf3000000u,0x000f3000u,0x00000000u,0x0000000fu,0x00f0ee0eu,0xefee0eefu,0xee0eefeeu,0x0eefee0eu,0xefee0eefu,0xee0eefeeu,0x0eefee0eu,0xefee0e00u,0x00f00030u,0x0f30000fu,0x00000000u,0x000000f3u,0x000000e0u,0x00000000u,0xf0000f30u,0x00f3f111u,0x111f0f00u,0x000e0f3fu,0x0e0003f0u,0x00000000u,0x03f00f00u,0x000000f0u,0x00000f00u,0xe03f000fu,0x0000000eu,0x00000000u,0x60000000u,0x0f00000fu,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000000u,0xf00000f0u,0x000003f0u,0x03f00600u,0x000f0000u,0x000f0e03u,0xf0000000u,0x0f000001u,0x11111000u,0x0e000000u,0x000000f0u,0x00000000u,0x0f000000u,0x00f00000u,0xf30e0000u,0x000f0000u,0x0000f300u,0x0f300060u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0xf3000f00u,0x00000000u,0x0000000fu,0x30f0300fu,0x00000000u,0x00000000u,0xf111111fu,0x0003f003u,0xf00003f0u,0x000e03f0u,0x03f00000u,0x00e03006u,0x00000f00u,0x003f0000u,0x00000000u,0x0f0000f0u,0x0000003fu,0x006003f0u,0x3f03f03fu,0x003f003fu,0x03f03f03u,0xf03f03f0u,0x3f03f03fu,0x03f03f03u,0xf003f006u,0x00000e0fu,0x00000f00u,0x00000000u,0x0003f000u,0xe000000fu,0x00000060u,0x03f0e00eu,0x00011811u,0x100f0000u,0xf000f0f0u,0x000000f0u,0x0000000eu,0x0f000f00u,0x00000000u,0xf00f0000u,0x00060f30u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00f000f0u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x000f0000u,0x0000f00fu,0x30000000u,0x0000f00fu,0x30000000u,0x0000f000u,0x00000000u,0x00f00000u,0x0f30f111u,0x111f3000u,0x00000000u,0x00006000u,0x00000f00u,0x00003000u,0x000003f0u,0x00300000u,0x06000000u,0x00f0003fu,0x00003000u,0x00000000u,0x0f000f00u,0x00000000u,0x00000f00u,0x000f0000u,0x0f00000fu,0x00000f00u,0xf0000000u,0x00000300u,0x00000f00u,0x003f0030u,0x000f00f0u,0x00600000u,0x0000003fu,0x00000000u,0x3f000001u,0x11111000u,0x00f00000u,0xe000000fu,0x30000000u,0xf3000f0fu,0x00000000u,0x000f00e0u,0x00000300u,0x0000000fu,0x00000f0fu,0x30006000u,0x00000000u,0x000f0000u,0x00000000u,0x00f0000fu,0x000000f0u,0x0000f000u,0x0000f000u,0x0f30000fu,0x00000f30u,0xe0f000f0u,0xf0000000u,0x00000300u,0xf300600fu,0x00300000u,0x0f000000u,0xf111111fu,0x000f300fu,0x3f003f00u,0x0000f006u,0x0000f000u,0x00000600u,0x0000e000u,0x00000000u,0xf00000e0u,0xf0000600u,0x000f0000u,0x003f0000u,0x000f0030u,0xf03f0060u,0x00000000u,0x0000000fu,0x00000000u,0x00000003u,0x0f0000f0u,0x00003f00u,0x00000000u,0x00000e00u,0x0e03f000u,0x0000f000u,0x0000f000u,0x00000000u,0xf0011111u,0x10f00000u,0x0000f000u,0x00000000u,0x00000000u,0x000f3000u,0x0f00f000u,0x0f00f300u,0x000f3000u,0x03000000u,0x00000000u,0x00f0000fu,0x30f0300fu,0x00000000u,0x000600f3u,0x00f30060u,0x00300600u,0xf3006000u,0xf0e00000u,0x0e000f00u,0x0000f000u,0x00e0000fu,0x300f0000u,0x0f000000u,0x0000000fu,0x0006000fu,0x00300111u,0x11100300u,0xf0000000u,0x00003f00u,0x00000300u,0x0e000000u,0x00030003u,0x0f030000u,0xf0000000u,0xf00f0000u,0x00000000u,0x003f0000u,0x000f000fu,0x0000e0f0u,0x00000000u,0x000f0000u,0x00000f00u,0x00000000u,0x00000003u,0xf00000f0u,0x000f0003u,0xf0060003u,0xf00f0000u,0x00000000u,0x000000e0u,0x0003f000u,0x0300f0f1u,0x1881100fu,0x00000e00u,0x0000f000u,0x00f300f0u,0xf0000600u,0x00000000u,0xf0000f00u,0x00000000u,0x0000000fu,0x300f3000u,0x60f00000u,0x000000e0u,0x00000000u,0x00000300u,0x00000000u,0x00000000u,0x00000000u,0x0000000fu,0x000f3f03u,0x000e000fu,0x0000000fu,0x00000000u,0x0000000eu,0x0f300f30u,0x00000000u,0x00f00000u,0x0111111fu,0x0000e00fu,0x03f00600u,0x00000000u,0x00003f00u,0x00000f00u,0xf0000000u,0x00600060u,0x00f003f0u,0x0000f000u,0xf0000000u,0x006003f0u,0x00000e00u,0xf3f003f0u,0x000000e0u,0x00e0003fu,0x000003f0u,0x0003f003u,0xf0000000u,0x00f00003u,0xf0000000u,0x00000000u,0x006003f0u,0x03f000f0u,0x00f03f00u,0x00000000u,0x00011111u,0x100000f3u,0x0f000000u,0x000f0e0fu,0x00000000u,0x00006000u,0x00e00000u,0x00000000u,0x003e0f00u,0x00e00000u,0x00000000u,0x00000f00u,0x00006000u,0x00000f00u,0x0f000f30u,0x0f3f00f0u,0x00e00000u,0x0e0f000fu,0x00000000u,0x0000000fu,0x000e0000u,0x003000f0u,0x000000f0u,0x00f00000u,0x00000f00u,0x000f3000u,0x0600f111u,0x111f0000u,0x00000000u,0x00003000u,0x3000e00fu,0x00003000u,0x003f0003u,0xf0e03000u,0x00000f00u,0x00000000u,0x0e000300u,0x003f0000u,0x00000000u,0x003f0000u,0x00000000u,0x0f000000u,0x0000003fu,0x00000000u,0x000000e0u,0xf000f00eu,0x00000000u,0x3f000f00u,0x030f3000u,0x00000000u,0x00e00000u,0x000e0000u,0xf0000001u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111111u,0x11111818u,0x18181811u,0x81181818u,0x11181111u,0x18181811u,0x81111811u,0x18118111u,0x81118118u,0x18118118u,0x18181818u,0x18111181u,0x11818118u,0x18181811u,0x18118118u,0x11818118u,0x11811818u,0x11811181u,0x18181818u,0x18181818u,0x18181818u,0x18181181u,0x18118111u,0x11111811u,0x81181818u,0x18181811u,0x81811811u,0x81818111u\n);\n\n//Color table/palette from bitmap\nint pal[PALETTE_LENGTH] = int[](\n\t0xefefde,0x0052e6,0x42adc5,0xc5de63,0x312110,0x6bad42,0xbd8cb5,0xc529bd,0x423173,0x21b542,0xc5843a,0xce1929,0x5231ce,0xf7f7f7,0xbddee6,0xf7cee6\n);\n\n//Given uv [0,1], return rgb value from bitmap\nvec3 img_texture(vec2 uv){\n    //Bitmap y starts at top\n    uv.y = 1.0-uv.y;\n    \n    int x = int(uv.x*float(IMG_WIDTH)),\n        y = int(uv.y*float(IMG_HEIGHT));\n    int index = y*IMG_WIDTH + x;\n    \n    //Wonky bitwise operations to extract\n    //correct 4 bits from the hex value.\n    uint hex = img[index/8];\n    int shift_cnt = 8 - (index%8+1);\n    shift_cnt *= 4;\n    int pixel = int((hex>>(shift_cnt))&0xfu);\n\t\n    //Given pixel value, return correct\n    //rgb color from color table\n    int col = pal[pixel];\n    \n    return vec3(\n        float((col>>16)&0xff)/255.0,\n        float((col>>8)&0xff)/255.0,\n        float((col)&0xff)/255.0\n    );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 125]]}
{"id": "3lSfDc", "name": "Basic-Taza-v1", "author": "jorge2017a1", "description": "Basic-Taza-v1", "tags": ["basictazav1"], "likes": 1, "viewed": 260, "published": 3, "date": "1599963115", "time_retrieved": "2024-07-30T20:45:38.607297", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n\n\n\nvec3 opRep3D( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///----------------------------------------------\n\n\nvec3 BocaSonrisa(vec3 p)\n{\n    \n \tvec3 res = vec3(9999.0, -1.0,-1.0);\n    \n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(3.0,3.0) );\n\tfloat sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(2.0+0.5*sin(iTime),3.5) );\n    float sdb1= sdBox(p-vec3(0.0,1.0,0.0), vec3(4.2,3.0,3.6));\n    \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    \n    res =opU3(res, vec3(dif,3.0,MATERIAL_NO));        \n    \n    return res;\n}\n\nvec3 CabezaVersionIII(vec3 p)\n{   \n\tvec3 res = vec3(9999.0, -1.0,-1.0);\n    \n    //1 cornea\n    //2do ojo\n    //3 cabeza\n    \n    float CorneaDer= sdCylinderXY(p-vec3(2.5+sin(iTime),6.0,-3.0), vec2(0.5,5.3));\n    float CorneaIzq=sdCylinderXY(p-vec3(-2.5+sin(iTime),6.0,-3.0), vec2(0.5,5.3));\n    \n    float OjoDer= sdCylinderXY(p-vec3(2.5,5.0,-3.0), vec2(2.0,5.0));\n    float OjoIzq= sdCylinderXY(p-vec3(-2.5,5.0,-3.0), vec2(2.0,5.0));\n    \n    float sdCabeza=   sdCylinderXZ(p-vec3(0.0,1.0,0.0), vec2(8.0, 8.0) );\n    float sdCabezaIn= sdCylinderXZ(p-vec3(0.0,2.0,0.0), vec2(6.0, 8.2) );\n    float sdt1= sdTorus(p-vec3(-8.0,0.0,0.0), vec2(4.0,1.0) );\n    float sdt2= sdTorus(p-vec3(8.0,0.0,0.0), vec2(4.0,1.0) );\n\t\n    \n    sdCabeza= unionSDF(sdCabeza, sdt1); \n    sdCabeza= unionSDF(sdCabeza, sdt2); \n    sdCabeza= differenceSDF(sdCabeza, sdCabezaIn); \n        \n    float sdCabezaOriginal=sdCabeza;\n    \n    \n    \n    //diferencia ojo-cornea Izq y Der\n    //------------oooooooo--------------\n    float difOjoCorneaDer= differenceSDF(OjoDer, CorneaDer);   \n    float difOjoCorneaIzq= differenceSDF(OjoIzq, CorneaIzq);   \n    \n    \n    float intersecionOjoCorneaDer= intersectSDF(OjoDer,CorneaDer);\n    float intersecionOjoCorneaIzq= intersectSDF(OjoIzq,CorneaIzq);\n    //------------oooooooo--------------\n    \n    \n    \n    //------------oooooooo--------------\n    //diferencia cabeza-ojo Der\n    float difCabezaOjoDer= differenceSDF(sdCabeza, OjoDer);   \n    float intersecionCabezaOjoDer= intersectSDF(sdCabeza,OjoDer);\n    float intersecionCabezaCorneaDer= intersectSDF(intersecionCabezaOjoDer,intersecionOjoCorneaDer);\n    //------------oooooooo--------------\n    \n    \n    //------------oooooooo--------------\n    //diferencia cabeza-ojo IZQ\n    sdCabeza=difCabezaOjoDer;\n    float difCabezaOjoIzq= differenceSDF(sdCabeza, OjoIzq); \n    float intersecionCabezaOjoIzq= intersectSDF(sdCabeza,OjoIzq);\n    float intersecionCabezaCorneaIzq= intersectSDF(intersecionCabezaOjoIzq,intersecionOjoCorneaIzq);\n    //------------oooooooo--------------\n    \n    \n   res =opU3(res, vec3(difCabezaOjoDer,23.0,MATERIAL_NO)); //no aplica---dejar \n   res =opU3(res, vec3(intersecionCabezaOjoDer,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaDer,0.0,MATERIAL_NO));  \n    \n    \n   res =opU3(res, vec3(difCabezaOjoIzq,30.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaOjoIzq,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(intersecionCabezaCorneaIzq,0.0,MATERIAL_NO));   \n    \n    \n    \n    \n    ///------------Boca\n    \n    sdCabeza=sdCabezaOriginal;\n    vec3 rBoca= BocaSonrisa(p-vec3(0.5,0.0,-7.5));\n    \n    float boca=rBoca.x;\n    float difCabezaboca= differenceSDF(sdCabeza, boca);   \n    float intersecionCabezaBoca= intersectSDF(sdCabeza,boca);\n    \n    \n    res =opU3(res, vec3(intersecionCabezaBoca,5.0,MATERIAL_NO)); \n    \n    \n    return res;\n    \n}   \n\nfloat smin(float a, float b, float k) \n{\n    float h = clamp(0.5 + 0.5 * ((b - a) / k), 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\n\nvec3 NarizBox(vec3 pp)\n{\t\n    \n    vec3 p=pp;\n\tvec3 res = vec3(9999.0, -1.0,-1.0);\n    p.zy= rotatev2( p.zy, radians(15.0));\n        \n\tfloat sdNariz= sdBox(p- vec3(0.0,0.0,-0.5), vec3(0.5,2.0,1.0) );\n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(0.5,1.0) );\n    float sdcy2= sdCylinderXY(p-vec3(0.7,-1.5,0.0), vec2(0.5,1.0) );\n    \n    \n    float sminRes;\n    float kval=0.6;\n    sminRes= smin(sdNariz, sdcy1, kval);\n    sminRes= smin(sminRes, sdcy2, kval);\n    \n    res =opU3(res, vec3(sminRes,2.0,MATERIAL_NO));   \n    \n    \n    return res;\n    \n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n   \n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    p.y=p.y-10.0;\n    \n    \n    \n\t\n    vec3 rescabeza= CabezaVersionIII(p);\n    res =opU3(res, rescabeza); \n        \n    \n    vec3 rNariz= NarizBox(p-vec3(0.0,1.0,-7.5));\n    res =opU3(res, rNariz); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n\n    \n    \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 8.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n    if(i== 50 )\n    {\n     \n           \n            vec3 p = mObj.p;\n        \t//vec3 p =  mObj.normal*0.5;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 233, 233, 257], [259, 274, 305, 305, 455], [458, 458, 503, 503, 594], [596, 613, 646, 646, 711], [713, 713, 749, 749, 852], [854, 854, 892, 892, 995], [998, 998, 1036, 1036, 1139], [1142, 1142, 1180, 1180, 1283], [1286, 1330, 1376, 1376, 1408], [1410, 1410, 1453, 1453, 1485], [1487, 1487, 1535, 1535, 1568], [1616, 1616, 1645, 1645, 1771], [1773, 1773, 1803, 1803, 1929], [1931, 1969, 2007, 2007, 2060], [2064, 2064, 2102, 2102, 2155], [2197, 2222, 2257, 2257, 2350], [2352, 2352, 2387, 2387, 2480], [2482, 2482, 2516, 2516, 2609], [2614, 2614, 2644, 2644, 2713], [2715, 2715, 2749, 2749, 2846], [2901, 2901, 2927, 2927, 3369], [3371, 3371, 3402, 3402, 6246], [6251, 6251, 6291, 6291, 6392], [6395, 6395, 6419, 6419, 6956], [6960, 7000, 7025, 7025, 7548], [7552, 7597, 7664, 7664, 8037], [8092, 8092, 8117, 8117, 8357], [8360, 8423, 8458, 8549, 9073], [9132, 9132, 9169, 9169, 9496], [9554, 9625, 9661, 9661, 9867], [9870, 9941, 9965, 9965, 10225], [10274, 10308, 10357, 10357, 10593], [10594, 10628, 10708, 10708, 11349], [11350, 11391, 11484, 11484, 11760], [11763, 11812, 11869, 11869, 13970]]}
{"id": "WlSfWc", "name": "Simple Despeckling Edge Detector", "author": "milesWaugh", "description": "edges", "tags": ["edgedetection"], "likes": 2, "viewed": 321, "published": 3, "date": "1599953477", "time_retrieved": "2024-07-30T20:45:39.379233", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ch = .5/iChannelResolution[1].xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(1.0);\n    for(float i=-1.; i<2.; i++){\n        for(float j=-1.; j<2.; j++){\n            fragColor *= vec4(texture(iChannel0, uv+vec2(i, j)*ch));\n        }\n    }\n    fragColor = vec4(pow(fragColor.x,.1), pow(fragColor.y,.1), pow(fragColor.z,.1), 1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ch = 1./iChannelResolution[0].xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 v1 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(ch.x,0.)).rgb;\n    vec3 v2 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(-ch.x,0.)).rgb;\n    vec3 v3 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(0.,ch.y)).rgb;\n    vec3 v4 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(0.,-ch.y)).rgb;\n    vec3 v5 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(ch.x,ch.y)).rgb;\n    vec3 v6 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(-ch.x,ch.y)).rgb;\n    vec3 v7 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(ch.x,-ch.y)).rgb;\n    vec3 v8 = texture(iChannel0,uv).rgb - texture(iChannel0,uv+vec2(-ch.x,-ch.y)).rgb;\n    vec3 dev = v1*v1+v2*v2+v3*v3+v4*v4+v5*v5+v6*v6+v7*v7+v8*v8;\n    float edge = dev.x+dev.y*dev.z*50.;\n    fragColor = vec4(vec3(edge),1.0);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 413]]}
{"id": "WtSBD3", "name": "Box Projection Projection", "author": "timeisbeautifulhere", "description": "Funky projection of boxes to other boxes, with even more boxes inside the projected boxes. Overly convoluted, but that's the way I roll :P\n\nPlay with the macro values for extra fun.", "tags": ["distortion", "projection", "box", "stripes"], "likes": 2, "viewed": 359, "published": 3, "date": "1599944560", "time_retrieved": "2024-07-30T20:45:40.219985", "image_code": "\n#define LINE_WIDTH 0.005\n\n//Scale ratio of outer to inner boxes\n#define SCALE_RATIO 0.65\n\n//How far apart subsequent boxes are\n#define SCALE_SPACING 0.55\n\n//When a box should loop\n#define SCALE_CUTOFF 1.25\n\n#define NUM_SQUARES 3\n#define TIME_CONST 0.1\n\n//Variables for \"split\" stripe effect.\n//High values for SPLIT_COUNT are fun.\n#define SPLIT_COUNT 5\n#define STRIPE_LINE_WIDTH 0.03\n#define STRIPE_TIME_CONST 0.25\n#define STRIPE_TIME_CUTOFF 10.0\n\n//Color variables\n#define STRIPE_CONST_A 1.3\n#define STRIPE_CONST_B 0.712\n#define STRIPE_COLOR_TIME_CONST 0.025\n\n#define DISABLE_STRIPE_TIME_EFFECT false\n#define DISABLE_STRIPE_LOOP false\n//#define DISABLE_STRIPE_TIME_EFFECT true\n//#define DISABLE_STRIPE_LOOP true\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Same as above, but returns distance instead\nfloat dist_from_segment(vec2 p1, vec2 p2, vec2 p3){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\t\n    return distance(point_on_line, p3);\n}\n\nbool on_rectangle(vec2 ll, vec2 ur, vec2 uv){\n    vec2 ul = vec2(ll.x,ur.y),\n        lr = vec2(ur.x, ll.y);\n    \n    return on_segment(ll,lr,uv,LINE_WIDTH) ||\n        on_segment(lr,ur,uv,LINE_WIDTH) ||\n        on_segment(ur,ul,uv,LINE_WIDTH) ||\n        on_segment(ul,ll,uv,LINE_WIDTH);\n}\n\n//Find \"split point\", or where the closest\n//stripe line is given a split factor.\n//The use of this is less apparent with\n//DISABLE_STRIPE_TIME_EFFECT false\nfloat closest_split(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    float closest = (closest_delta*delta);\n    \n    return closest - dist;\n}\n\nint closest_split_num(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    \n    return int(closest_delta);\n}\n\n//Check if uv is on a \"stripe\" between two scaled\n//boxes\nint on_stripes(vec2 uv, int split_cnt, float inner_scale, float outer_scale){\n    \n    if((abs(uv.x)<inner_scale && abs(uv.y)<inner_scale) ||\n       (abs(uv.x)>outer_scale && abs(uv.y)>outer_scale))\n        return -1;\n   \t\n    vec2 p = vec2(uv);\n    \n    //In \"top\" region\n    if(uv.y > inner_scale && uv.x > -uv.y && uv.x < uv.y)\n        p = vec2(uv.x, uv.y);\n    \n    //In \"bottom\" region\n    else if(uv.y < -inner_scale && uv.x > uv.y && uv.x < -uv.y)\n        p = vec2(uv.x, -uv.y);\n    \n    //In \"left\" region\n    else if(uv.x < -inner_scale && uv.y > uv.x && uv.y < -uv.x)\n        p = vec2(uv.y, -uv.x);\n   \t\n    //In \"right\" region\n    else if(uv.x > inner_scale && uv.y > -uv.x && uv.y < uv.x)\n        p = vec2(uv.y, uv.x);\n    \n    //Inside box, not in any region\n    else\n        return -1;\n    \n    if(p.y > outer_scale)\n        return -1;\n    \n    //Really funky time based effect on\n   \t//stripes\n    if(!DISABLE_STRIPE_TIME_EFFECT){\n    \t//\"Loop\" time effect on distortion of stripes.\n        //Here because it gets weird at higher time values.\n    \tif(!DISABLE_STRIPE_LOOP)\n    \t\tp.x += mod(iTime*STRIPE_TIME_CONST,STRIPE_TIME_CUTOFF);\n        else\n            p.x += iTime*STRIPE_TIME_CONST;\n    \tp.x = mod(p.x, p.y);\n    }\n    \n    float closest = closest_split(p, split_cnt);    \n    if(abs(closest-p.x) < STRIPE_LINE_WIDTH)\n        return closest_split_num(p, split_cnt);\n    else\n        return -1;\n}\n\n//Draw an array of boxes, defined by their \"outer scale\".\n//Draws the boxes and stripes inside them.\nvec3 draw_rectangles(vec2 uv, float scales[NUM_SQUARES]){\n    vec3 col = vec3(1.0);\n    \n    for(int i=0;i<NUM_SQUARES;i++){\n        float scale_outer = scales[i],\n            scale_inner = scales[i]*SCALE_RATIO;\n        \n        //Check if on any \"stripes\" splitting edge regions\n        int stripe_num = on_stripes(uv, SPLIT_COUNT, scale_inner, scale_outer);\n        if(stripe_num != -1){\n            //Funky color effect with random math\n            float stripe_1 = float(stripe_num) * STRIPE_CONST_A + STRIPE_CONST_B,\n                stripe_2 = float(stripe_num) * (1.0/STRIPE_CONST_B) + STRIPE_CONST_A,\n                stripe_3 = STRIPE_COLOR_TIME_CONST * iTime;\n            \n\t        col = vec3(\n                fract(stripe_1 * stripe_3),\n                fract(stripe_2 * stripe_3),\n                fract(mix(stripe_1,stripe_2, stripe_3))\n            );\n        }\n        \n        //Draw outer and inner boxes\n    \tvec2 ll = vec2(-scale_outer,-scale_outer),\n        \tur = vec2(scale_outer,scale_outer);\n    \tvec2 inner_ll = vec2(-scale_inner,-scale_inner),\n\t        inner_ur = vec2(scale_inner,scale_inner);\n    \n    \tif(on_rectangle(ll,ur,uv) || on_rectangle(inner_ll,inner_ur, uv))\n        \tcol = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1, 1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    vec3 col = vec3(1.0);\n    \n    float scales[NUM_SQUARES];\n    scales[0] = 1.0 + TIME_CONST*iTime;\n    for(int i=1;i<NUM_SQUARES;i++)\n    \tscales[i] = scales[i-1]-SCALE_SPACING;\n    for(int i=0;i<NUM_SQUARES;i++){\n        float inner = scales[i]*SCALE_RATIO;\n        if(inner > SCALE_CUTOFF)\n            scales[i] = mod(inner,SCALE_CUTOFF)/SCALE_RATIO;\n    }\n    \n    col = draw_rectangles(uv,scales);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[715, 929, 989, 989, 1365], [1367, 1413, 1464, 1464, 1749], [1751, 1751, 1796, 1796, 2038], [2040, 2197, 2241, 2241, 2474], [2476, 2476, 2522, 2522, 2716], [2718, 2776, 2853, 2853, 4195], [4197, 4298, 4355, 4355, 5544], [5546, 5546, 5603, 5618, 6147]]}
{"id": "WlBBD3", "name": "#876 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiment", "daily"], "likes": 3, "viewed": 268, "published": 3, "date": "1599943551", "time_retrieved": "2024-07-30T20:45:40.985937", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\nfloat boxSDF(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n    \n  p.yz = rotate2d(p.yz, -0.5 * QP * sin(t) - 0.25);\n  p.xz = rotate2d(p.xz, t + HP * sin(t + HP * sin(2.0 * t)));\n  float box = boxSDF(p, vec3(1.25));\n  float inner = boxSDF(p, vec3(0.45));\n    \n  float f = map01(sin(t + cos(t)), 0.8, 1.0);\n  float sx = abs(f * p.x) - map01(cos(t), 0.0, 0.25);\n  float sy = abs(f * p.y) - map01(sin(t + HP * sin(2.0 * t)), 0.0, 0.25);\n  float sz = abs(f * p.z) - map01(sin(t + sin(-t)), 0.0, 0.25);\n  vec3 columns = vec3(\n      boxSDF(p, vec3(10.0, sx, sx)),\n      boxSDF(p, vec3(sy, 10.0, sy)),\n      boxSDF(p, vec3(sz, sz, 10.0))\n  );\n  \n  //return columns.y;\n  \n  return 0.7 * max(box, -max(-inner, min(columns.x, min(columns.y, columns.z))));\n  return 0.7 * max(-min(columns.x, min(columns.y, columns.z)), max(box, -inner));\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -5.0, 5.0);\n  vec3 lightColor = vec3(0.01, 0.01, 0.125);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.01, 0.01, 0.025);\n\n  float fog = 50.0 / pow(f, 3.0);\n\n  return fog * light * lightColor + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.01);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [998, 998, 1028, 1028, 1115], [1117, 1188, 1212, 1212, 1997], [2030, 2244, 2272, 2272, 2489], [2491, 2568, 2608, 2608, 2905], [2934, 2934, 2989, 2989, 3467]]}
{"id": "wlSfW1", "name": "Textured Rectangular Area Light", "author": "piyushslayer", "description": "Textured rectangular area light based on Unreal Engine's most representative point method.", "tags": ["brdf", "arealight", "ibl", "fresnel", "schlick", "pbr", "ggx", "ndf"], "likes": 47, "viewed": 1684, "published": 3, "date": "1599935236", "time_retrieved": "2024-07-30T20:45:41.984268", "image_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A small experimental follow up to my area lights shader (https://www.shadertoy.com/view/3dsBD4)\n* with a textured rectangular area light. See Buffer A for more details.\n*\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // for yucky color banding artifacts\n    col += hash12(fragCoord * iResolution.xy + vec2(iFrame)) * .003;\n    fragColor = vec4(pow(col, vec3(.4545)), 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* Helper functions and macros used for the rectangular area light in the mainImage buffer.\n*\n*/\n\n#define saturate(x) clamp(x, 0., 1.)\n#define dot2(x) dot(x, x)\n\n// Comment/uncomment these for different material settings\n#define FLOOR_DISPLACEMENT\n#define FLOOR_ROUGHNESS\n#define LIGHT_TEXTURE\n\n#define EPS .0002\n#define SMOL_EPS .0000002\n\n#define PI 3.1415926535\n#define TWO_PI 6.283185307\n#define PI_INV .3183098861\n\n#define RECT_LIGHT_RADIUS 1.25\n#define RECT_LIGHT_COLOR vec3(.6, .3, .15)\n#define RECT_LIGHT_INTENSITY 32.\n\nconst vec3 cameraPosition = vec3(0., 10., 25.);\nconst float cameraFar = 100.;\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n    \nstruct Rect\n{\n\tvec3 center, a, b, c, d; \n\tvec3 up, right, front;\n    vec2 halfSize;\n};\n    \nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1. / float(0xffffffffU));\n}\n\nmat3 rotY(float a)\n{\n\treturn mat3(cos(a), 0., sin(a),\n                \t0., 1., \t0.,\n               -sin(a), 0., cos(a));\n}\n\nmat3 rotX(float a)\n{\n\treturn mat3(1., \t0., \t 0.,\n                0., cos(a), -sin(a),\n                0., sin(a),  cos(a));\n}\n\nvec3 rotateYX(vec3 a, vec2 rot)\n{\n\treturn rotX(rot.y) * rotY(rot.x) * a;\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = cameraPosition;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, 2.5));\n    return Ray(origin, direction);\n}", "buffer_a_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A small experimental follow up to my area lights shader (https://www.shadertoy.com/view/3dsBD4)\n* with a textured rectangular area light. The diffuse component of the light is based on the 5 sample\n* solid angle technique from the frostbite engine[1], and the specular technique is based on the most\n* representative point method from unreal engine[2]. For specular, a point on the rectangular light source\n* is calculated using the reflection vector originating from the shaded point. That point on the rectangle\n* is the new light vector using which normal pbr shading calculations are done. \n*\n* [1] Real Shading in Unreal Engine 4 -\n* (https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)\n* [2] Moving Frostbite to Physically Based Rendering 3.0 -\n* (https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf)\n*\n*/\n\nRect rect;\n\nvec2 sdUnion(vec2 a, vec2 b)\n{\n \treturn a.x < b.x ? a : b;  \n}\n\nvoid initRect(vec2 rot)\n{\n    rect.up = rotateYX(vec3(0., 1., 0.), rot);\n    rect.right = rotateYX(vec3(1., 0., 0.), rot);;\n    rect.front = normalize(cross(rect.right, rect.up));\n    rect.halfSize = vec2(5., 3.);\n    \n    rect.center = vec3(0., 5., 0.);\n    \n    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n}\n\nfloat sdPlane(vec3 pos, float height)\n{\n\tfloat plane = pos.y - height;\n#ifdef FLOOR_DISPLACEMENT\n    return plane - textureLod(iChannel0, pos.xz * .02, 0.).r * .01;   \n#else\n    return plane;\n#endif\n}\n\nfloat sdPlaneNoDisplacement(vec3 pos, float height)\n{\n\treturn pos.y - height;\n}\n\nfloat sdRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross(ba, ad);\n\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(dc, nor), pc)) +\n         sign(dot(cross(ad, nor), pd)) < 3.)\n\n        ?\n\n        min(min(min(\n\t\tdot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa),\n\t\tdot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)),\n\t\tdot2(dc * clamp(dot(dc, pc) / dot2(dc), 0., 1.) - pc)),\n\t\tdot2(ad * clamp(dot(ad, pd) / dot2(ad), 0., 1.) - pd))\n        \n        :\n        \n        dot(nor, pa) * dot(nor, pa) / dot2(nor) \n    );\n}\n\nvec2 sdScene(vec3 pos)\n{\n\tvec2 result = vec2(sdPlaneNoDisplacement(pos, -.75), 2.);\n    \n    result = sdUnion(result, vec2(sdRect(pos, rect.a, rect.b, rect.c, rect.d), 0.));\n    \n    return result;\n}\n\nvec2 sdSceneNormal(vec3 pos)\n{\n\treturn vec2(sdPlane(pos, -.75), 1.);\n}\n\nvec3 calculateNormal(vec3 pos)\n{\n\tvec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(sdSceneNormal(pos + eps.xyy).x, \n                          sdSceneNormal(pos + eps.yxy).x, \n                          sdSceneNormal(pos + eps.yyx).x) \n                     - sdSceneNormal(pos).x);\n}\n\nvec2 rayMarch(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 128; ++i)\n    {  \n        result = sdScene(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= cameraFar) break;\n        dist += result.x;\n    }\n\n    if (dist >= cameraFar) result.y = -1.;\n    return vec2(dist, result.y);\n}\n\nfloat ndfTrowbridgeReitzRect(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alpha4 = alpha2 * alpha2;\n    float alphaPrime3 = alphaPrime * alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t \t(alpha2 * alphaPrime3)\n    \t/ /*-------------------------------------------------*/\n        \t  \t(pow(NdotH2 * (alpha2 - 1.) + 1., 2.));      \n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat geometrySchlickGGX(float NdotX, float k)\n{\n    return \n        \t\t\t\t\tNdotX\n    \t/ /*----------------------------------------*/\n    \t  \t  max(NdotX * (1. - k) + k, SMOL_EPS);\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness)\n{\n \tfloat roughnessplusone = roughness + 1.;\n    float k = roughnessplusone * roughnessplusone / 8.;\n    \n    return geometrySchlickGGX(NdotV, k) * geometrySchlickGGX(NdotL, k);\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 fresnelSchlick(vec3 F0, float dotProd)\n{\n    return F0 + (1. - F0) * pow(1. - dotProd, 5.);\n}\n\nfloat rectSolidAngle(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n    vec3 v0 = p0 - p;\n    vec3 v1 = p1 - p;\n    vec3 v2 = p2 - p;\n    vec3 v3 = p3 - p;\n    \n    vec3 n0 = normalize(cross(v0, v1));\n    vec3 n1 = normalize(cross(v1, v2));\n    vec3 n2 = normalize(cross(v2, v3));\n    vec3 n3 = normalize(cross(v3, v0));\n    \n    float g0 = acos(dot(-n0, n1));\n\tfloat g1 = acos(dot(-n1, n2));\n\tfloat g2 = acos(dot(-n2, n3));\n\tfloat g3 = acos(dot(-n3, n0));\n    \n    return g0 + g1 + g2 + g3 - TWO_PI;\n}\n\nvec3 rayPlaneIntersect(Ray ray)\n{\n   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)\n                                      / dot(rect.front, ray.direction));\n}\n\nvec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, float NdotV, float roughness,\n              vec3 f0, out vec3 fresnel, out vec3 diffCol, out vec3 specCol)\n{\n  \n    vec4 result = vec4(0.);\n    // ensure the points are wound counter-clockwise (only debug)\n    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);\n    if (windingCheck > 0.)\n\t\treturn result;\n    \n    float solidAngle = rectSolidAngle(p, rect.a, rect.b, rect.c, rect.d);\n    \n    // diffuse\n    result.w = solidAngle * .2 * (\n        saturate(dot(normalize(rect.a - p), n)) +\n        saturate(dot(normalize(rect.b - p), n)) +\n        saturate(dot(normalize(rect.c - p), n)) +\n        saturate(dot(normalize(rect.d - p), n)) +\n        saturate(dot(normalize(rect.center - p), n)));   \n    \n    Ray rectRay = Ray(p, r);\n    \n    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point\n    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;\n    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), \n                               dot(planePointCenter, rect.up));\n    //vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);\n    vec2 c = clamp(planePointProj, -rect.halfSize, rect.halfSize);\n    vec3 L = rect.center + rect.right * c.x + rect.up * c.y;\n#ifdef LIGHT_TEXTURE\n    // calculate light uv\n    vec3 L0 = L - rect.c;\n    vec2 luv = vec2(dot(rect.right, L0), dot(rect.up, L0)) / (rect.halfSize * 2.);\n#endif\n    L -= p;\n    \n    vec3 l = normalize(L);\n    vec3 h = normalize(l + v);\n    float lightDist = length(L);\n    \n    float NdotH = max(0., dot(n, h));\n    float VdotH = dot(v, h);\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));\n    \n#ifdef LIGHT_TEXTURE\n    // calculate approx light diffuse and specular colors (super experimental :p) \n    diffCol = pow(textureLod(iChannel1, luv, pow(exp(lightDist + .5), 2.)).rgb, vec3(2.2));\n    specCol = pow(textureLod(iChannel1, luv, exp(lightDist * alpha + .5) + 1.).rgb, vec3(2.2));\n#endif\n    \n    result.xyz += geometrySmith(NdotV, result.w, roughness) \n        * ndfTrowbridgeReitzRect(NdotH, alpha, alphaPrime)\n        * fresnelSchlick(f0, VdotH);\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blueNoise = texelFetch(iChannel1,\n\t\t\t\t\t\t(iFrame * ivec2(113, 127)) & 63, 0).rg;\n    vec2 uv = (2. * (fragCoord + blueNoise) - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float t = iTime * .5;\n    \n    vec3 col = vec3(0.);\n     \n    vec2 rot = m * TWO_PI;    \n    initRect(rot);\n    \n    Ray ray = getCameraRay(uv);\n    vec2 marchResult = rayMarch(ray);\n    vec3 position = ray.origin + ray.direction * marchResult.x;\n    vec3 normal = calculateNormal(position);\n    vec3 viewDirection = -ray.direction;\n    vec3 reflectDirection = reflect(ray.direction, normal);\n    \n    float NdotV = max(dot(normal, viewDirection), 0.);\n    \n    vec3 rectFresnel = vec3(0.);\n\tvec3 rLightDiff = vec3(0.); // light diffuse color\n    vec3 rLightSpec = vec3(0.); // light specular color\n    float rectRoughness = .08;\n    float rectMetalness = .25;\n\tif (marchResult.y > -1.)\n    {\n\t\tif (marchResult.y > 1.)\n        {\n            vec3 albedo = pow(textureLod(iChannel0, position.xz * .04, 0.).rgb, vec3(2.2));\n#ifdef FLOOR_ROUGHNESS\n            rectRoughness += albedo.r * .64;\n#endif\n            vec3 F0 = mix(vec3(.05), vec3(1.), rectMetalness);\n            vec4 rLight = rectLight(position, normal, viewDirection,\n\t\t\t\t\treflectDirection, NdotV, rectRoughness, F0, rectFresnel, rLightDiff, rLightSpec);\n            vec3 kD = 1. - rectFresnel;\n            kD *= 1. - rectMetalness;\n#ifdef LIGHT_TEXTURE\n        \tcol += (albedo * kD * rLightDiff + rLight.xyz * rLightSpec) * rLight.w * \n                RECT_LIGHT_INTENSITY;\n#else\n            col += (albedo * kD * PI_INV + rLight.xyz) * rLight.w * \n                RECT_LIGHT_INTENSITY * RECT_LIGHT_COLOR;\n#endif\n        }\n        else\n        {\n#ifdef LIGHT_TEXTURE\n            vec3 rectOrigin = position - rect.c;\n        \tvec2 rectUv = vec2(dot(rect.right, rectOrigin), dot(rect.up, rectOrigin)) / (rect.halfSize * 2.);\n            col += pow(textureLod(iChannel1, rectUv, 0.).rgb, vec3(2.2)) * RECT_LIGHT_INTENSITY;\n#else\n            col += RECT_LIGHT_COLOR * RECT_LIGHT_INTENSITY;\n#endif\n        }\n    }\n    \n    col = mix(col, vec3(.005, .0003, .0002), // brown-ish fog color\n               \t\tclamp(1. - exp(-marchResult.x * .08), 0., 1.));\n    \n\n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(iChannel0, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(iChannel1, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSfW1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[227, 227, 284, 284, 537]]}
{"id": "tljBDV", "name": "Flowing triangles", "author": "kostik1337", "description": "Very simple shader I wrote for my game \"CHOCH\" for js13k game jam, used there as background", "tags": ["grid", "triangle"], "likes": 5, "viewed": 412, "published": 3, "date": "1599929967", "time_retrieved": "2024-07-30T20:45:42.753212", "image_code": "#define t iTime\n\nfloat hash(float x) {return fract(sin(x)*31345.23);}\n\nfloat smoothNoise(float x) {\n  return mix(hash(floor(x)), hash(floor(x)+1.), smoothstep(0.,1.,fract(x)));\n}\n\nfloat render(vec2 uv, vec2 offset) {\n    uv *= mat2(sqrt(3.)/2.,-.5,0.,1.);\n    float c = 0.;\n    const float I = 3.;\n    for(float i=0.;i<I;++i) {\n        float f = 20. + 17.*i;\n        // sort of triangle grid\n        vec2 uv1 = uv*f + (t*2. + offset) / f;\n        vec2 cuv = floor(uv1);\n        vec2 luv = fract(uv1);\n        if(luv.x+luv.y > 1.) {\n            luv = 1.-luv;\n            cuv += .5;\n        }\n\n        // colorize triangle at bounds based on cell position\n        float bound = .05;\n        c += max(\n            step(luv.x, bound),\n            max(\n                step(luv.y, bound),\n                step(1.-luv.x-luv.y, bound)\n            ))\n            * smoothstep(.4, .95, smoothNoise(dot(cuv, vec2(.6,.5)) + .4*t + 3.*i)) * mix(1., .3, i/(I-1.));\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 offset = iMouse.xy/2.;\n\n    float aberr = 0.003;\n\tvec3 col = vec3(\n    \trender(uv-vec2(aberr, 0.), offset),\n        render(uv, offset),\n        render(uv+vec2(aberr, 0.), offset)\n    )*.3;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 38, 38, 69], [71, 71, 99, 99, 178], [180, 180, 216, 216, 973], [975, 975, 1032, 1032, 1346]]}
{"id": "wl2BWV", "name": "maya pyramid + forest", "author": "FabriceNeyret2", "description": "reference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n\nNote that my anti-banding tricks doesn't work here, due to the heap of discontinuities.", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 16, "viewed": 387, "published": 3, "date": "1599926042", "time_retrieved": "2024-07-30T20:45:43.514177", "image_code": "// forest-variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)      mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)  fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n\nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y),               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2. ,                   // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 ),        // slopes top \n    t = max( t, q.z-7.),                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.),   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5)),// doors\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.;                                     // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-2) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25), q;                        // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(.3*t);               // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(.3*t);\n\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += .5*t*D;                                  // sphere-tracing step\n    \n    c = 1. - c/50.;                                   // pseudo-lighting\n    O = t==s ? vec4(0,.2,0,1)*(.7+.3*p.z)             // coloring. forest\n             : vec4(1,.8,.6,1);                       //           temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 442, 463, 463, 1487], [1489, 1489, 1525, 1525, 2658]]}
{"id": "wl2BRd", "name": "smooth filter", "author": "sympou", "description": "a filter that smoothes the image and makes it progressively more abstract !", "tags": ["filter"], "likes": 3, "viewed": 362, "published": 3, "date": "1599922589", "time_retrieved": "2024-07-30T20:45:44.279132", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    fragColor = texelFetch( iChannel1, ivec2(fragCoord), 0 );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lum(pix) dot( pix, vec4(.3,.59,.11,0) )  //luminance\n\nvec2 grad (vec2 uv) {\n    vec3 pSize = vec3(1.0/iResolution.xy,0.0);\n    float p1 = lum(texture( iChannel1, uv - pSize.xz ));\n    float p2 = lum(texture( iChannel1, uv + pSize.xz ));\n    float p3 = lum(texture( iChannel1, uv - pSize.zy ));\n    float p4 = lum(texture( iChannel1, uv + pSize.zy ));\n    \n\treturn vec2(p1-p2,p3-p4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pSize = 1.0/iResolution.xy;\n    \n    if ( mod(float(iFrame),400.0 ) == 10.0) {\n    \n        fragColor = texture( iChannel0, uv);\n    \n    } else {\n\n        vec2 gradient = grad(uv);\n        if ( length(gradient) > 0.0 ) {\n            \n            gradient = normalize(gradient);\n\n            vec4 t1 = texture( iChannel1, uv - pSize*gradient.yx*1.5);\n            vec4 t2 = texture( iChannel1, uv + pSize*gradient.yx*1.5);\n            vec4 t3 = texture( iChannel1, uv - pSize*gradient.xy*2.0);\n            vec4 t4 = texture( iChannel1, uv + pSize*gradient.xy*2.0);\n            \n         \tfloat midLum = ( lum(t1) + lum(t2) )*0.5;\n            \n            float comp = max(sign(abs(lum(t4)-midLum)-abs(lum(t3)-midLum)),0.0);\n            fragColor = t3*comp + t4*(1.0-comp);\n\n            //strange color blending\n            //if (abs(lum(t3)-lum(t4))<0.015) {\n            //    fragColor = (t3+t4)*0.5;\n            //} \n\n        } else {\n\t        fragColor = texture( iChannel1, uv);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 122]]}
{"id": "tl2BWK", "name": "pixels woo", "author": "thefox231", "description": "looks neat\ncheck the #defines and use mouse !", "tags": ["pixel", "post"], "likes": 4, "viewed": 352, "published": 3, "date": "1599905682", "time_retrieved": "2024-07-30T20:45:45.047079", "image_code": "#define amp (iMouse.y / iResolution.y)\n#define split (iMouse.x / iResolution.x)\n\n#define smooth\n\nconst float PI = 3.1415;\n\nfloat inOutSine(float x) {\n  return 0.5 - 0.5 * cos(x * PI);\n}\n\nvec2 hash23(vec3 p3) {\n\treturn fract(texture(iChannel1, p3.xy - p3.z * 0.12551).rb + p3.z);\n}\n\nvec2 smoothNoise(vec3 p3) {\n    return mix(hash23(vec3(p3.x, p3.y, floor(p3.z))), hash23(vec3(p3.x, p3.y, ceil(p3.z))), fract(p3.z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float pixSize = 20.0;\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec2 pixUv = floor(uv * pixSize) / pixSize;\n    #ifndef smooth\n    if (pixUv.x + pixUv.y * 0.2 > split) uv += floor((smoothNoise(vec3(pixUv, iTime + pixUv.x - pixUv.y)) * 2.0 - 1.0) * pixSize * amp) / pixSize;\n  \t#else\n    if (pixUv.x + pixUv.y * 0.2 > split) uv += (smoothNoise(vec3(pixUv, inOutSine(iTime + pixUv.x - pixUv.y))) * 2.0 - 1.0) * amp;\n    #endif\n    \n    uv.y /= iResolution.y / iResolution.x;\n    \n    fragColor = texture(iChannel0, fract(uv)).rgba;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2BWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 149, 149, 185], [187, 187, 209, 209, 280], [282, 282, 309, 309, 417], [419, 419, 474, 474, 1068]]}
{"id": "wt2BWK", "name": "reflection", "author": "nerumae3", "description": " ", "tags": ["3d", "raymarching", "sound"], "likes": 35, "viewed": 1215, "published": 3, "date": "1599904865", "time_retrieved": "2024-07-30T20:45:45.993548", "image_code": "#define MAT_SPHERE 0.0\n#define MAT_FLOOR 1.0\n#define MAT_BOX 2.0\n#define bpm 138.\n#define pi acos(-1.)\n#define pi2 pi*2.\n#define rep(p,r) mod(p,r)-r*.5;\n#define repid(p,r) (floor((p) / r))\n#define saturate(x) clamp(x,0.,1.)\n\n#define beat iTime*bpm/60.\n#define speed 16.\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);   \n}\n\nfloat easeIn(float t) {\n    return t * t;\n}\n\nfloat easeOut(float t) {\n    return -1.0 * t * (t - 2.0);\n}\n\nfloat rand(float p)\n{\n    return fract(sin(p*43758.5453));  \n}\n\nfloat noise(vec2 p)\n{\n    vec2 i=floor(p),f=fract(p);\n    f=f*f*(3.-2.*f);\n    return mix(\n        mix(rand(i),rand(i+vec2(1.,0.)),f.x),\n        mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.)),f.x),\n        f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float amp=.5,val;\n    for(int i=0;i<4;i++)\n    {\n        val +=noise(p)*amp;\n        amp *= .5;\n        p*=2.;\n    }\n    return val;\n}\n\nmat2 rot(float r)\n{\n    float s=sin(r),c=cos(r);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n) * n;\n    return p * rot(a);\n}\n\nfloat luminace(vec3 col)\n{\n    return dot(vec3(0.298912,0.58611,0.114478),col);   \n}\n\nvec3 saturation(vec3 col,float scale)\n{\n    return mix(vec3(luminace(col)),col,scale);   \n}\n\nvec3 contrast(vec3 col,float scale)\n{\n    return (col-.5)*scale+.5;\n}\n\nvec3 colorCorrect(vec3 col){\n    col = saturation(col,1.4);\n    col = pow(col,vec3(2.5));\n    //col = pow(col,vec3(1.5));\n    col = col*vec3(.6,.9,1.0);\n    return col;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat vignette(vec2 p,float s){\n    p *= 1.-p.yx;\n    float vig = p.x*p.y*30.;\n    vig = clamp(pow(vig,s),.0,1.);\n    return vig;\n}\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1,vec2 d2)\n{\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    \n    float t = iTime;\n    float start = step(0.,beat);\n    float end=saturate(beat-120.);\n    vec3 q = p;\n    \n    vec3 sp = vec3(0.,0.,-t*speed);\n    \n    q+=sp;\n    \n    float l1 = easeOut(1.-clamp(7.*.2-length(q.xz*.05)-t*.2,0.,1.));\n    float l2 = easeOut(clamp(64.*.8-length(q.xz*.05)-t*.8,0.,1.));\n    float l = 1.;\n    l = mix(l,l1,start);\n    l = mix(l,l2,end);\n    float d1 = sphere(q,.5*l);\n    \n    q=p;\n    \n    q+=sp;\n    for(int i=0;i<2;i++)\n    {\n        q = abs(q)-.25;\n        q.xz *= rot(1.);\n        q.xy *= rot(1.+iTime);\n        \n    }\n    float d2 = sdBox(q,vec3(.125,.5,.124)*l);\n    d1 = mix(d1,d2,pow(sin(fract(beat)*pi)*.5+.5,8.));\n    vec2 s = vec2(d1,MAT_SPHERE);\n    \n    q=p;\n    q= -abs(q);\n    vec2 fl = vec2(q.y+10.5*l+.05,MAT_FLOOR);\n    \n    //vec2 fl2 = vec2 (q.x+10.5*l+.05,MAT_FLOOR);\n    q=p;\n    q.xz = rep(q.xz,2.);\n    \n    //fl = opS(fl,fl2);\n    vec2 tri = vec2(1.);\n    \n    //q.xy *= rot(.2);\n    \n    q = p;\n    q.xy = pmod(p.xy,3.);\n    q.z = rep(p.z,10.);\n    vec2 box = vec2(sdBox(q-vec3(0.,5.,0.),vec3(.5)),MAT_BOX);\n    \n    q = p;\n    \n    q.y = abs(q.y)-2.1;\n    q.xz = rep(q.xz,14.);\n    for(int i=0;i<4;i++)\n    {\n        q = abs(q)-2.4;\n        q.xy *= rot(2.025+(1.-l));\n        \n    }\n    \n    vec2 w = vec2(sdBox(q,vec3(2.,1.2,.2)),MAT_BOX);\n    q=p;\n    vec2 d = opU(s,fl);\n    //d = opU(d,box);\n    d = opU(d,w);\n    return d;\n}\n\nvec4 volMap(vec3 p)\n{\n \tvec3 q = p;\n    q.xy *= rot(pi*.25);\n    float zid = repid(q.z,10.);\n    q.z = rep(q.z,10.);\n    \n    q = abs(q);\n    q.xy =abs(q.xy)-5.;\n    float d = length(q.xz)-.05;\n    d = min(d,length(q.yz)-.05);\n    float r0 = rand(zid);\n    vec3 col = vec3(.2,.8,.8)*(.1+0.9*exp(-13.*fract(beat*4.)))*.01;\n    return vec4(col,d);\n}\n\nvec4 volMap2(vec3 p)\n{\n    vec3 q=p;\n    q.xy = pmod(q.xy,3.);\n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    q.y -=5.;\n    \n    float d = length(q.yx)-.1;\n    \n    \n    vec3 col = vec3(.9,.2,.2)*(.00+1.*exp(-13.*fract(beat*.5)))*.2;\n    return vec4(col,d);\n}\n\nvec4 volMap3(vec3 p)\n{\n    vec3 q=p;\n    q.xy *= rot(pi);\n    q.xy = pmod(q.xy,3.);\n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    q.y -=5.;\n    float d = length(q.yx)-.1;\n   \n    \n    vec3 col = vec3(.2,.2,.9)*(.00+1.*exp(-13.*fract(beat*.5+.5)))*.2;\n    return vec4(col,d);\n}\n\nvec4 volMap4(vec3 p)\n{\n    vec3 q=p;\n    \n    //q.xz = rep(q.xz,14.);\n    \n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    //q.y =abs(q.y)-1.7;\n    vec3 id = repid(q,7.);\n    q.z = rep(q.z,7.);\n    \n    q.y = abs(q.y)-8.;\n    float d = length(q.zy)-.025;\n   \n    \n    vec3 col = vec3(.6,.4,.7)*.025*(0.01+1.*exp(-13.*fract(beat+.5)));\n    return vec4(col,d);\n}\n\nvec4 volMap5(vec3 p)\n{\n    vec3 q=p;\n\tvec3 sp = vec3(0.,0.,-iTime*speed);\n    q+=sp;\n\n    \n    float d = length(q)-.125;\n   \n    \n    vec3 col = vec3(.98,.2,.2)*.025;//*(0.01+1.*exp(-1.*fract(beat)));\n    return vec4(col,d);\n}\n\nvec3 normal(vec3 p)\n{\n  float e = 0.001;\n  vec2 k = vec2(1.,-1.);\n  return normalize(\n      k.xyy * map(p+k.xyy*e).x+\n      k.yxy * map(p+k.yxy*e).x+\n      k.yyx * map(p+k.yyx*e).x+\n      k.xxx * map(p+k.xxx*e).x\n    );\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.01;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 64; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n\nvec3 glow(vec3 ro,vec3 rd,float depth)\n{\n  float t = 0.01;\n  vec4 d;\n  float sd = depth/99.;\n  vec3 ac;\n  float[] parts = float[](0.,1.,0.,1.);\n  float part = parts[int(mod(beat*.125*.25,4.))];\n    \n    float[] parts2 = float[](1.,1.,0.,1.);\n  float part2 = parts2[int(mod(beat*.125*.25,4.))];\n  for(int i = 0;i<60;i++)\n  {\n      if(t>depth) break;\n      vec3 pos = ro+rd*t;\n      d = volMap(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part2 * smoothstep(4.,12.,iTime);\n      \n      \n      d = volMap2(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part;\n      \n      d = volMap3(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part;\n      \n      d = volMap4(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.));\n      \n      d = volMap5(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.));\n      \n      t += sd;\n  }\n  return ac;\n}\n\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickWithRoughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Kaneta SkyColor \n//https://www.shadertoy.com/view/3lXfzS\nvec3 skyColor(vec3 rd, float roughness)\n{\n    vec3 baseColor = mix(vec3(0.3,0.5,0.8)*0.8, vec3(0.3,0.5,0.8) * 0.5, rd.y);\n    baseColor = mix( baseColor, vec3(0.2,0.5,0.85)*0.5, 1.0 - pow(1.0-max(-rd.y,0.0), 1.5));\n    vec3 skyColor = baseColor;\n    skyColor = mix( skyColor, vec3(0.9,1.1,1.2) * 1.5, pow( 1.0-max(rd.y,0.0), 8.0 ) );\n    skyColor = mix( skyColor, vec3(0.2,0.5,0.85)*0.2, 1.0 - pow(1.0-max(-rd.y,0.0), 6.0));\n    \n    return mix(skyColor, baseColor, pow(roughness, 0.1)) * 10.0;\n}\n\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 ambientLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float aoRange)\n{\n    vec3 diffuseIrradiance = skyColor(N, 1.0);\n    \n    vec3 diffuseAmbient = diffuseIrradiance * albedo * (1.0 - metalness);\n\n    vec3 R = reflect(-V, N);\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlickWithRoughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 specularIrradiance = skyColor(R, roughness);\n    vec3 specularAmbient = specularIrradiance * F;\n\n    float ambientOcclusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tambientOcclusion = min(exp2( -.8 * pow(ambientOcclusion, 2.0) ), 1.0) * min(1.0, 1.0+0.5*N.y);\n    diffuseAmbient *= ambientOcclusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), ambientOcclusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 directLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 lightColor)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n    float HdotL = max(0.0, dot(H, L));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick(F0, HdotL);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n    vec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\t\n\t//float shadow = shadow(pos + N * 0.01, L);\n    vec3 irradiance = lightColor * NdotL;// * shadow;\n\n\treturn (diffuseBRDF + specularBRDF) * irradiance;\n}\n\nvec3 lighting(vec3 ro,vec3 p,vec3 ray ,float depth,vec2 mat)\n{\n    vec3 col;\n    \n    vec3 n = normal(p);\n    float start = saturate(iTime-2.5);\n    vec3 ld = normalize(vec3(1.,1.,.2));\n    float NdotL = max(0.,dot(n,ld));\n    float metalness = .0;\n    float roughness = .0;\n    vec3 albedo = vec3(.5,.5,.5);\n    float checker = mod(floor(p.x)+floor(p.z),2.);\n    if(depth>200.)\n    {\n        return vec3(.1);   \n    }\n    else if(mat.y == MAT_SPHERE){\n        albedo = vec3(.25);\n        roughness = .1;\n        metalness = 1.;\n\t} else if(mat.y == MAT_FLOOR){\n        albedo = vec3(.025);\n        metalness = .5;\n    \troughness = .8;\n    } else if(mat.y == MAT_BOX){\n        albedo = vec3(.5,.5,.5);\n    \tmetalness = 1.;\n        roughness = 0.1;\n    } else {\n    \tcol = vec3(.1);\n    }\n    float aoRange = depth/30.;\n    \n    col += directLighting(p, albedo, metalness, roughness, n, -ray, normalize(ld), vec3(.98, 0.18, 0.18) * 10.*(sin(beat*pi*.25)*.5+.5));\n    \n    col += ambientLighting(p, albedo, metalness, roughness, n, -ray, depth / 30.0)*.05;\n    \n    col += glow(ro,ray,depth);\n    float fog = exp(-.0006*depth);\n    \n    vec3 fog2 = .02*vec3(1.,1.,1.4)*depth;\n    fog2 *= start*.5;\n    col = mix(vec3(.0),col+fog2,fog);\n\treturn col;\n}\n\nvoid trace(vec3 ro,out vec3 p, vec3 ray,out float t,out vec2 mat)\n{\n    t=0.01;\n    vec3 pos;\n    for (int i = 0; i < 99; i++) {\n        pos = ro + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.01) {\n        \tbreak;\n        }\n        t += abs(mat.x);\n    }\n    p = pos;\n}\n\nvec3 ray(vec2 p,vec3 ro,vec3 ta,float fov)\n{\n \tvec3 fo = normalize(ta - ro);\n    vec3 si = normalize(cross(vec3(0.,1.,0.),fo));\n    vec3 up = normalize(cross(fo,si));\n    return normalize(fo*fov+si*p.x+up*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float time = iTime*speed;\n    vec2 fbm = vec2(fbm(vec2(iTime*.1)),fbm(vec2(iTime*.1+100.)))*2.-1.;\n    vec3 camPos1 = vec3(0.,0.,-5.+time);\n    vec3 camPos2 = vec3(0.,-1.,2.+time);\n    vec3 camPos3 = vec3(.6,2.,-3.+time);\n    vec3 camPos4 = vec3(7.,-1.,-8.+time);\n    vec3[] Poss = vec3[](camPos1,camPos2,camPos3,camPos4);\n    \n    vec3 ro = vec3(0.,-1.,2.+time);\n    ro = mix(Poss[int(mod((beat-8.)*.125*.25,4.))],Poss[int(mod((beat-8.)*.125*.25+1.,4.))],smoothstep(0.,1.,saturate(mod(beat-8.,32.)-24.)));\n    ro.xy += fbm*2.;\n    vec3 ta = vec3(0.,0.,0.+time);\n    \n    vec3 ray = ray(p,ro,ta,1.2);\n\n    vec3 pos,rpos;\n    vec2 mat;\n    float t=0.01;\n    trace(ro,pos,ray,t,mat);\n    vec3 col = lighting(ro,pos, ray, t, mat);\n    vec3 n = normal(pos);\n    \n    ray = reflect(ray,n);\n    trace(pos,rpos,ray,t,mat);\n    col += lighting(pos,rpos+n*.01, ray, t, mat)*.5;\n\tcol = colorCorrect(col);\n    col = acesFilm(col*.3);\n    col = pow(col,vec3(1./2.2));\n    col *= vignette(uv,.5);\n    \n    //col *= step(abs(p.y),.8);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "#define bpm 138.\n#define pi acos(-1.)\n#define pi2 pi*2.\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43478.5453);\n}\nfloat rand(float p)\n{\n    return fract(sin(p*78.233)*43478.5453);\n}\nfloat noise(float p)\n{\n    float i=floor(p);\n    float f=fract(p);\n    f=f*f*(3.-2.*f);\n    return mix(rand(i),rand(i+1.),f);   \n} \n\nfloat fbm(float p)\n{\n    float amp=.5,val;\n    for(int i=0;i<4;i++)\n    {\n      val+=noise(p)*amp;\n      p*=2.;\n      amp*=.5;\n    }\n    return val;\n}\n\nfloat fm(float t,float f,float i,float r){\n    return sin(pi2*f*t+i*sin(pi2*f*t*r));\n}\nfloat sfm(float t,float f,float i1,float r1,float i2,float r2){\n    return sin(pi2*f*t+i1*fm(t,f,i2,r2)*r1);\n}\nfloat ssaw(float t,float f){\n    return rand(vec2(t))*0.02+sfm(t,f,0.8,1.8,.8,7.0)+sfm(t,f*1.008,0.8,1.8,0.8,6.0)+0.1*sfm(t,f,0.1,0.0,0.1,3.0);\n}\nfloat calf(float i){\n    return pow(2.0,i/12.0);\n}\n\nfloat sigcomp1d(float w,float s){\n  return (1.0/(1.0+exp(-s*w)) -0.5)*2.0;\n}\n\nfloat dist(float s, float d)\n{\n    return clamp(s * d, -1.0, 1.0);\n}\n\nfloat metalic(float t,float time)\n{\n    float o = 0.;\n    //o += mix(sin(time*pi2*440.*calf(4.)),fm(time,440.*calf(4.),1.,1.5),1.5)*.5;\n    float[] amps = float[](1.,1.,.25,1.);\n    float amp = amps[int(mod(t*.125*.25,4.))];\n    o+=fm(time,440.*calf(1.+12.+12.),.35,4.5+floor(sin(t*pi2*2.)))*((noise(time*pi2*220.*calf(2.)*.75))*1.-.25);\n    \n    o = o * exp(-7.*fract((t*.5+.5)))*.7*amp;// * smoothstep(1.,.75,fract(t*.25));\n    return o;\n}   \nfloat base(float t,float time)\n{\n    float o = 0.;\n    float note = 4.5;\n\to += fm(time,40.*calf(note),2.,1.);\n    o += sin(time*40.*calf(note+12.)*pi2)*.5;\n    //o += fm(time,40.*calf(5.+note),2.,1.);\n    //o += fm(time,40.*calf(31.+note),2.,1.5);\n    o *= .4;\n    o = dist(o,2.)*.5;\n    o = o * exp(-.75*fract(t*2.));\n\treturn o;\n}\n\nfloat saw(float t,float time)\n{\n    float o = 0.;\n    float[] notes = float[](-3.,-3.,-5.,-3.);\n    float note = notes[int(mod(t*4.,4.))]+2.;\n    float[] amps = float[](1.,1.,.5,1.);\n    float amp = amps[int(mod(t*.125*.25,4.))];\n    o += ssaw(time,220.*calf(0.+note))*.25;\n    o += ssaw(time,220.*calf(-5.+note))*.25*amp;\n    o += fm(time,220.*calf(-12.+note),1.,1.)*.5;\n    o = o * exp(-.25*fract(t*2.))*.25;\n\treturn o;\n}\n\nfloat hihat(float t,float time)\n{\n    float o = 0.;\n    \n    float[] notes = float[](-3.,-3.,-5.,-3.);\n    float note = notes[int(mod(t*2.,4.))];\n\n    o += sin(1760.*pi2*time*calf(24.+note))*.25;\n    o += noise(time*1e4)+fbm(time*1e4)*.5+rand(time)*.5;\n    o = o* exp(-11.*fract(t+.5))*.5; \n    //o = dist(o,2.)*1.;\n\treturn o;\n}\n\n//kick\n//https://www.shadertoy.com/view/ldfSW2\nfloat kick(float t, float time)\n{\n    \n    t = fract(t*1.)*.5;\n    float aa = 5.;\n    t = sqrt(t * aa) / aa; \t\n    float amp = exp(max(t - 0.15, 0.0) * -10.0);\n    \n       \n    float o = sin(t * 100.0 * pi2) * amp;\n    o = dist(o,1.);\n    return o;\n}\n\nfloat kickEcho(float t,float time)\n{\n    float amp = .5;\n    float o = 0.;\n    float[] kickamps = float[](0.,1.,0.,1.);\n    float kickamp = kickamps[int(mod(t*.125*.25,4.))];\n    for(int i=0;i<4;i++)\n    {\n      o+= kick(t+float(i)*.25,time)*amp;\n      amp*=.5;\n    }\n    return o*kickamp;\n}\n\nvec2 mainSound( in int samp,float time){\n    float o = 0.;\n    float t = time*bpm/60.;\n    \n    o += metalic(t,time);\n    o += base(t,time);\n    o += kickEcho(t,time);\n    //o += hihat(t,time);\n    o += saw(t,time);\n    \n    o = o*smoothstep(0.,4.,time);\n    o = o*smoothstep(64.,56.,time);\n    o*=1.0;\n    return vec2(o*.5);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2BWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 291, 291, 359], [361, 361, 384, 384, 404], [406, 406, 430, 430, 465], [467, 467, 488, 488, 529], [531, 531, 552, 552, 738], [740, 740, 759, 759, 898], [900, 900, 919, 919, 977], [979, 979, 1007, 1007, 1111], [1113, 1113, 1139, 1139, 1197], [1199, 1199, 1238, 1238, 1290], [1292, 1292, 1329, 1329, 1361], [1363, 1363, 1391, 1391, 1533], [1535, 1535, 1564, 1564, 1768], [1770, 1770, 1801, 1801, 1901], [1903, 1903, 1934, 1934, 1962], [1964, 1964, 1995, 1995, 2082], [2084, 2084, 2136, 2136, 2243], [2245, 2245, 2273, 2273, 2306], [2308, 2308, 2335, 2335, 2371], [2373, 2373, 2391, 2391, 3786], [3788, 3788, 3809, 3809, 4135], [4137, 4137, 4159, 4159, 4412], [4414, 4414, 4436, 4436, 4707], [4709, 4709, 4731, 4731, 5084], [5086, 5086, 5108, 5108, 5312], [5314, 5314, 5335, 5335, 5535], [5537, 5537, 5573, 5573, 5905], [6848, 6848, 6892, 6892, 7063], [7065, 7065, 7109, 7109, 7158], [7160, 7160, 7223, 7223, 7334], [7336, 7336, 7382, 7382, 7439], [7441, 7441, 7517, 7517, 7601], [7603, 7662, 7703, 7703, 8158], [8160, 8160, 8208, 8208, 8295], [8297, 8297, 8407, 8407, 9143], [9145, 9145, 9264, 9264, 9934], [9936, 9936, 9998, 9998, 11183], [11185, 11185, 11252, 11252, 11465], [11467, 11467, 11511, 11511, 11679]]}
{"id": "3ljfDV", "name": "yummy colors", "author": "thefox231", "description": "drink the colors. do it", "tags": ["noise", "post", "simplex"], "likes": 4, "viewed": 350, "published": 3, "date": "1599902738", "time_retrieved": "2024-07-30T20:45:46.766482", "image_code": "#define scale 12.0\n#define amp (0.02 + sin(iTime) * 0.02)\n#define rgbDiff 0.15\n\n// simplex noise implementation stolen from https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col;\n    \n    vec3 colOrig = texture(iChannel0, uv).rgb;\n    float bri = (colOrig.r + colOrig.g + colOrig.b) / 3.;\n    \n    for (int i = 0; i < 3; i++) {\n        float offx = snoise(vec3(uv * scale, iTime + float(i) * rgbDiff));\n        float offy = snoise(vec3(-uv * scale, -iTime + float(i) * rgbDiff));\n\n        col[i] = texture(iChannel0, uv + vec2(offx * 2.0 - 1.0, offy * 2.0 - 1.0) * amp * (bri * 0.2 + 0.8))[i];\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 191, 212, 212, 261], [263, 263, 284, 284, 333], [335, 335, 357, 357, 397], [399, 399, 427, 427, 479], [481, 481, 505, 505, 2649], [2651, 2651, 2706, 2706, 3227]]}
{"id": "Wt2BDV", "name": "Black BG EQ", "author": "Meji", "description": "Test", "tags": ["eq"], "likes": 2, "viewed": 228, "published": 3, "date": "1599898544", "time_retrieved": "2024-07-30T20:45:47.536423", "image_code": "#define ampl 1.\n#define seuil .0\n#define steps 100.\n#define space .1\n#define def .2\n#define opacity .8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float sound = texture(iChannel0,vec2(floor(steps*uv.x)/steps,0)).r;\n    sound *=ampl;\n    sound -=seuil;\n    sound = max(def, sound);\n    if (uv.x*steps-floor (uv.x*steps)<space)sound = 0.;\n\n    vec4 color = texture(iChannel1,uv);\n       // uv.y +=texture(iChannel0,vec2(floor(steps*uv.x)/steps,1)).r/20.; // make the spectrum analysis dance with the waveform â™«â™¥\n    if (abs((0.,5.*uv.y-1.5))< sound*sound*sound)color =mix(color, vec4(1),opacity);\n\tfragColor =color;\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 161, 693]]}
{"id": "3tjfWV", "name": "Magic Morphin' Spheres", "author": "celifrog", "description": "CREDIT TO-\nhttps://www.shadertoy.com/view/MsKGz1\nFor the original version.", "tags": ["sphere", "land"], "likes": 2, "viewed": 281, "published": 3, "date": "1599889399", "time_retrieved": "2024-07-30T20:45:48.302375", "image_code": "\nfloat fruitShape( in vec3 p )\n{\n    return length(p) - 1.0;\n}\nfloat floorShape( in vec3 p )\n{\n    return p.y + 1991.0 + p.y *p.x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f*p.y);\n\tvec2 uv = (p.xy+vec2(357.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv* 0.5)*556.0, -100.0 ).yx;\n\treturn -1.0+552.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(553.0-2.0*f*f*f*f*f*f*f*f*f*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy + f.y;\n\tvec2 rg = texture( iChannel1, (uv*uv*uv*uv*uv+ 111.5)/460.0, -100.0 ).yx;\n\treturn -5.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p*=2.02;\n    f += 5.2500*noise(p); p*=2.03;\n    f += 0.1250*noise(p*p*p*p*p*p); p*=2.01;\n    f += 5.0625*noise(p*p);\n    return f;\n}\n\nfloat fbm2(in vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise2(p*p*p*p*p*p*p*p); p*=2.02;\n    f += 0.2500*noise2(p); p*=2.03;\n    f += 0.1250*noise2(p); p*=2.01;\n    f += 0.0625*noise2(p); p*=2.02;\n    f += 0.03125*noise2(p);\n    return f;\n}\n\nvec3 floorMaterial(in vec3 p, in vec3 n )\n{\n    vec3 q = p - vec3(0.8,sin(iTime),cos(iTime));\n    float f;\n    f =fbm2(q);\n    f *=f;\n    return vec3(1.0)+(vec3(0.3,0.8*f,f)*sin(iTime));\n}\nvec3 fruitMaterial(in vec3 p, in vec3 n )\n{\n\tfloat a = atan( p.x,p.z );\n    float r = length( p.xz*p.xz );\n    vec3 col = vec3(1.0,55.4,0.1);\n    float f = smoothstep(0.01,0.8,fbm(p));\n   \tf =  fbm( vec3(p*4.0));\n    col = mix(col,vec3(0.4,1.,0.2),f );\n    f = smoothstep(0.01,0.8,fbm(n));;\n    col = mix(col,vec3(0.1,0.4,0.8),f );\n    return col;\n}\n\nfloat fog(in vec3 p)\n{\n    vec3 q = p - vec3(0.0,0.1,999.0)*iTime*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 55.25000*noise( q ); q = q*2.03;\n    f += 599.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02*q*q*q*q*q;\n    f += 5.03125*noise( q ); q = q*5.99;\n\treturn clamp( 551.5 * p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),11.0) + length(max(d,111.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdEllipsoid( q , vec3(0.4,0.5,0.4));\n}\n\nfloat displacement(vec3 p)\n{\n    return sin(1.4*p.x)*sin(1.4*p.y)*sin(1.4*p.z)*cos(iTime);\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = fruitShape(p);\n    float d2 = displacement(p);\n    return d1+d2+d1+d1+d1+d1;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 dl;\n    \n    dl = opU(vec2( floorShape(pos), 1.5 ), vec2(opDisplace(pos-vec3(0.,0.25,-1.)),2.));\n    \n   \tdl = opU(dl,vec2( opRep(pos,vec3(5.9,1.5,0.8)),1.));\n    \n    for( float i = 0.; i < 5. ; ++i )\n    {\n        dl = opU(dl, vec2(sdBox(pos+vec3(0.8+i,1.5,2.+i)+vec3(0.5*max(0.,cos(iTime)),0.3,(0.55+i)*max(0.,sin(iTime*0.6))),vec3(1.3,1.5,1.1)),i+8.));\n            \n    }\n//dl = opU(dl,vec2(fog(pos),15.0));\n    \n    return dl;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    float tmin = -551.0;\n    float tmax = 5120.0;\n    float t = -3.0;\n    float m = -1.0;\n    for (int i=0 ; i<15 ; i++)\n    {\n    \tvec2 res = map( ro+t*rd );\n        if ( res.x < -0.000001 || t>tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n    if( t>tmax ) m=-911.0;\n    return vec2(t,m);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd )\n{\n    float mint = 51.0;\n    float tmax = 520.0;\n\tfloat res = 61.0;\n    float t = mint++;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 1.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //iTime\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0+2.*q)*vec2(1.77,1.0);\n    q = vec2(q.x,q.y*5.6+.2);\n    vec3 ro = 5.0*vec3( cos(iTime* .07), 0.0, sin(iTime*0.03));\n    \n    vec3 ww = normalize( vec3(0.) - ro);\n    vec3 uu = normalize( cross(vec3(0.,1.,0.),ww) );\n    vec3 vv = normalize( cross(ww,uu));\n    vec3 rd  = normalize( p.x*uu + p.y*vv + 1.5*ww++);\n    \n    vec2 t = intersect (ro, rd);\n\n    vec3 col = vec3(0.0);    \n    if (t.y > -52.5)\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize( vec3(51.0,0.8,0.6));\n        vec3 blig = vec3(-lig.y,lig.y,-lig.y);\n        \n        float amb = -5.5 + 5.5 * nor.y;\n        float dif = max(11.0, dot(nor,lig));\n        float bac = max(0.0,0.2+0.8*dot(nor,blig));\n        \n        float sha = softShadow( pos, lig );\n        col = vec3(0.1,0.12,0.14);\n       \tcol += amb*vec3(0.1,0.1,0.3);\n        col += dif*vec3(0.2,0.5,5.8)*sha;\n        col += bac*vec3(1.0,0.98,0.84);\n        col = 0.95*sqrt(col);\n        if(t.y<2.0)\n        {\n            col *= floorMaterial(pos,nor);\n        }\n        if(t.y <3.0 && t.y>1.5)\n        {\n            col *= fruitMaterial(pos,nor);\n        }\n\n        if(t.y > 3.0)\n        {\n            col *= vec3(0.5,11.1,0.1);\n        }\n        else if(t.y > 4.0)\n        {\n            col += vec3(0.3,0.9,0.3);\n        }    \n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 62], [63, 63, 94, 94, 132], [134, 134, 160, 160, 385], [387, 387, 414, 414, 672], [674, 674, 696, 696, 874], [876, 876, 899, 899, 1120], [1122, 1122, 1165, 1165, 1310], [1311, 1311, 1354, 1354, 1660], [1662, 1662, 1684, 1684, 2019], [2021, 2021, 2064, 2064, 2124], [2127, 2127, 2158, 2158, 2248], [2250, 2250, 2280, 2280, 2316], [2318, 2318, 2349, 2349, 2428], [2430, 2430, 2458, 2458, 2522], [2524, 2524, 2552, 2552, 2646], [2648, 2648, 2673, 2673, 3116], [3118, 3118, 3160, 3160, 3464], [3466, 3466, 3498, 3498, 3719], [3721, 3721, 3765, 3765, 4075], [4077, 4077, 4134, 4146, 5550]]}
{"id": "Wl2BWV", "name": "Empty program noise", "author": "AlexApps99", "description": "For some reason, fragColor is usually uninitialized, so the color changes seemingly randomly.", "tags": ["noise"], "likes": 1, "viewed": 244, "published": 3, "date": "1599889337", "time_retrieved": "2024-07-30T20:45:49.170055", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2BWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 56]]}
{"id": "WljBWV", "name": "Multi-sampled Plane", "author": "milesWaugh", "description": "Reset time to reset samples. Uses a cube-map, calculates the lighting from the cube-map texture for diffuse, and slightly rough glossy reflection. May be expanded to render cubes too. ", "tags": ["plane", "multisample"], "likes": 4, "viewed": 325, "published": 3, "date": "1599887699", "time_retrieved": "2024-07-30T20:45:50.052695", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0,uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 random2(vec3 pos){\n    float x = fract(sin(dot(pos, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n    float y = fract(sin(dot(pos, vec3(86.28594852, 34.58198637, 25.58228349))) * 95837.9672);\n    return vec2(x, y);\n}\nvec3 random3(vec3 pos){\n    float x = fract(sin(dot(pos, vec3(45.84018476, 94.30285684, 33.52930515))) * 23859.2590);\n    float y = fract(sin(dot(pos, vec3(96.95283515, 23.59403928, 59.59203951))) * 96834.1853);\n    float z = fract(sin(dot(pos, vec3(64.93925685, 75.64903468, 54.86397654))) * 74538.8648);\n    return vec3(x, y, z);\n}\n\nfloat iters = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0.);\n    for(int i=0; i<int(iters); i++){\n        vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n        uv += (random2(vec3(uv.x, uv.y, iTime+float(i)/(60.*iters)))-0.5)/iResolution.xy;\n        vec3 p = vec3(uv.x*(-1.0/uv.y),-1.0,-1.0/uv.y);\n        vec3 inc = vec3(uv.x, uv.y, 1.);\n        vec3 col2 = vec3(1.0);\n        vec3 ambient = vec3(0.0);\n        vec3 dif2 = vec3(1.0);\n        if(uv.y<0.0){\n            if(p.x-floor(p.x)<0.5&&p.z-floor(p.z)<0.5){\n                col2 = vec3(0.0);\n            }\n            if(p.x-floor(p.x)>0.5&&p.z-floor(p.z)>0.5){\n                col2 = vec3(0.0);\n            }\n            dif2 = random3(vec3(uv.x, uv.y, iTime+float(i)/(60.*iters)));\n            dif2.y<0.?-dif2:dif2;\n            ambient += texture(iChannel1, dif2).rgb;\n        }else{\n            ambient = texture(iChannel1, inc).rgb;\n        }\n        vec3 rvec = vec3(inc.x, -inc.y, inc.z);\n        rvec = normalize(rvec*15.0 + random3(vec3(uv.x,uv.y,2.*iTime+1.)));\n        vec3 reflection = texture(iChannel1, rvec).rgb;\n        col2 *= ambient*dif2.y;\n        col2 = col2*0.9 + 0.1*reflection;\n        col2=max(col2*2.-.01,0.);\n        col += col2;\n    }\n    col/=iters;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(pow(col.x,.45),pow(col.y,.45),pow(col.z,.45),1.0)/float(iFrame+1)+texture(iChannel0, uv)*(1.0-1.0/float(iFrame+1));\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 194]]}
{"id": "3t2fDK", "name": "castillo v1", "author": "jorge2017a1", "description": "castillo v1", "tags": ["castillov1"], "likes": 3, "viewed": 228, "published": 3, "date": "1599879064", "time_retrieved": "2024-07-30T20:45:51.105879", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\nfloat RotacionPolarBoxMedPos(vec3 p, float posZ, float numItem, vec3 medCy)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    //p.xy *= genRotMat(0.0);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n    float sdb1=sdBox( rep2-vec3(0.0, 0.0, posZ), medCy );    \n    return  sdb1;\n}\n\n\nfloat HacerCoronaMedBoxV2(vec3 p,vec2 MedCy, float PosCirculo, int NumDiv)\n{\n    vec2 MedCyA=MedCy;\n    vec2 MedCyB=vec2(MedCyA.x-1.0, MedCyA.y+2.0);\n    \n    float sdCoronaGr= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyA );\n    float sdCoronaCh= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyB );\n\n    float difcorona= differenceSDF(sdCoronaGr, sdCoronaCh);\n    \n    p= rotate_x(p, radians(90.0));\n    float rpcy=RotacionPolarBoxMedPos(p, PosCirculo, float( NumDiv),vec3(17.0,1.0,2.0) );\n\t\n    float dif= differenceSDF(difcorona, rpcy );\n    \n\treturn dif;\n  \n    \n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n\n    float planeDist1 = p.y+5.0;  //piso inf\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    \n    p.y=p.y-5.0;\n        \n    \n    pp=p;\n\tvec3 q=p;\n    float cx=10.0;\n    float cz=10.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\t\n   \n    \n    \n    float  sdb1X= sdBox(p-vec3(0.0,0.0,0.0), vec3(50.0,2.0,2.0) );\n    float  sdb1Z= sdBox(p-vec3(0.0,0.0,0.0), vec3(2.0,2.0,50.0) );\n    \n    float  castillo=   sdBox(pp-vec3(0.0,-10.0,0.0), vec3(18.0,10.0,25));\n    float  castilloIn= sdBox(pp-vec3(0.0,-3.0,0.0), vec3(15.0,5.0,23));\n    \n    float dif= differenceSDF(castillo, sdb1X) ;\n    dif= differenceSDF(dif, sdb1Z) ;\n    dif= differenceSDF(dif, castilloIn) ;\n    \n    res =opU3(res, vec3(dif,106.0,MATERIAL_NO));   \n\t\n    \n    \n    \n     //-----------\n     vec2 MedCy=vec2(10.0,6.5);   //10 ancho y Alto cilindro 5.5 vec2(10.0,5.5)\n     float PosCirculo=5.0;\n     int NumDiv=12;\n     float hc5=HacerCoronaMedBoxV2(pp-vec3(0.0,-2.0,0.0),MedCy, PosCirculo, NumDiv);\n    res =opU3(res, vec3(hc5,104.0,MATERIAL_NO)); \n    //------------------\n\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    if (i==104 ) { return tex3D(iChannel0, p/4., nor)*vec3(1.0,0.65,0.36); }\n    if (i==105 ) { return tex3D(iChannel0, p/4., nor)*vec3(0.30,1.0,0.36); }\n    if (i==106 ) { return tex3D(iChannel0, p/4., nor)*vec3(0.0,1.0,0.6); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n\n\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 10.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n   \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 194, 225, 225, 375], [378, 378, 414, 414, 517], [519, 519, 557, 557, 660], [663, 663, 701, 701, 804], [807, 807, 845, 845, 948], [951, 995, 1041, 1041, 1073], [1075, 1075, 1118, 1118, 1150], [1152, 1152, 1200, 1200, 1233], [1281, 1281, 1311, 1311, 1437], [1480, 1505, 1540, 1540, 1633], [1635, 1635, 1670, 1670, 1763], [1765, 1765, 1799, 1799, 1892], [1895, 1895, 1929, 1929, 2102], [2103, 2103, 2180, 2180, 2492], [2495, 2495, 2571, 2571, 3052], [3055, 3095, 3120, 3120, 4496], [4500, 4545, 4612, 4612, 4985], [5040, 5040, 5065, 5065, 5305], [5308, 5371, 5406, 5497, 6021], [6080, 6080, 6117, 6117, 6444], [6502, 6573, 6609, 6609, 6815], [6818, 6889, 6913, 6913, 7173], [7175, 7209, 7258, 7258, 7718], [7719, 7753, 7833, 7833, 8474], [8568, 8568, 8661, 8661, 8942], [8945, 8994, 9051, 9051, 11136]]}
{"id": "WljfDK", "name": "corona -n4", "author": "jorge2017a1", "description": "corona -n4", "tags": ["coronan4"], "likes": 1, "viewed": 269, "published": 3, "date": "1599879046", "time_retrieved": "2024-07-30T20:45:52.175021", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n//-----------------------------------------\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n\nfloat RotacionPolarCilindroMed(vec3 p, float numItem, vec2 medCy)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    p.xy *= genRotMat(0.0);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1=sdCylinderYZ(rep2-vec3(0.0), medCy ); //vertical\n    return  sdb1;\n}\n\n\nfloat RotacionPolarBoxMedPos(vec3 p, float posZ, float numItem, vec3 medCy)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    //p.xy *= genRotMat(0.0);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1=sdBox( rep2-vec3(0.0, 0.0, posZ), medCy );\n    \n    return  sdb1;\n}\n\n\n\nfloat RotacionPolarCilindroMedPos(vec3 p, float posZ, float numItem, vec2 medCy)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    //p.xy *= genRotMat(0.0);/// genera la rotacion del engrane\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1=sdCylinderYZ(rep2-vec3(0.0, 0.0, posZ), medCy ); //vertical\n    return  sdb1;\n}\n\n\n\n\nfloat HacerCoronaMedV2(vec3 p,vec2 MedCy, float PosCirculo, int NumDiv)\n{\n    vec2 MedCyA=MedCy;\n    vec2 MedCyB=vec2(MedCyA.x-1.0, MedCyA.y+2.0);\n    float sdCoronaGr= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyA );\n    float sdCoronaCh= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyB );\n    float difcorona= differenceSDF(sdCoronaGr, sdCoronaCh);\n    p= rotate_x(p, radians(90.0));\n    float rpcy=RotacionPolarCilindroMedPos(p, PosCirculo, float( NumDiv),vec2(2.0,15.0+2.0) );\n\tfloat dif= differenceSDF(difcorona, rpcy );\n    \n\treturn dif;\n}\n\n\n\n\nfloat HacerCoronaMedBoxV2(vec3 p,vec2 MedCy, float PosCirculo, int NumDiv)\n{\n    vec2 MedCyA=MedCy;\n    vec2 MedCyB=vec2(MedCyA.x-1.0, MedCyA.y+2.0);\n    \n    float sdCoronaGr= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyA );\n    float sdCoronaCh= sdCylinderXZ(p-vec3(0.0, 0.0,0.0), MedCyB );\n\n    float difcorona= differenceSDF(sdCoronaGr, sdCoronaCh);\n    \n    p= rotate_x(p, radians(90.0));\n    float rpcy=RotacionPolarBoxMedPos(p, PosCirculo, float( NumDiv),vec3(17.0,1.0,2.0) );\n\t\n    float dif= differenceSDF(difcorona, rpcy );\n    \n\treturn dif;\n    \n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n\n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    \n    p.y=p.y-5.0;\n\n        \n    \n    \n    vec2 MedCy=vec2(4.0,4.5);   //10 ancho y Alto cilindro 5.5 vec2(10.0,5.5)\n    float PosCirculo=4.0;\n    int NumDiv=5;\n    \n    float hc2=HacerCoronaMedV2( p-vec3(0.0,15.0,0.0),MedCy, PosCirculo, NumDiv);\n    res =opU3(res, vec3(hc2,100.0,MATERIAL_NO)); \n    \n    \n    \n    //-----------\n     MedCy=vec2(6.0,3.5);   //10 ancho y Alto cilindro 5.5 vec2(10.0,5.5)\n     PosCirculo=3.0;\n     NumDiv=6;\n    \n    float hc3=HacerCoronaMedV2( p-vec3(0.0,12.0,0.0),MedCy, PosCirculo, NumDiv);\n    res =opU3(res, vec3(hc3,104.0,MATERIAL_NO)); \n    \n    //-----------\n     MedCy=vec2(8.0,6.5);   //10 ancho y Alto cilindro 5.5 vec2(10.0,5.5)\n     PosCirculo=6.0;\n     NumDiv=8;\n    \n    float hc4=HacerCoronaMedV2( p-vec3(0.0,6.0,0.0),MedCy, PosCirculo, NumDiv);\n    res =opU3(res, vec3(hc4,105.0,MATERIAL_NO)); \n    //------------------\n    \n    \n    \n    \n    \n     //-----------\n     MedCy=vec2(10.0,6.5);   //10 ancho y Alto cilindro 5.5 vec2(10.0,5.5)\n     PosCirculo=5.0;\n     NumDiv=12;\n    \n    float hc5=HacerCoronaMedBoxV2(p-vec3(0.0,2.0,0.0),MedCy, PosCirculo, NumDiv);\n    \n    res =opU3(res, vec3(hc5,104.0,MATERIAL_NO)); \n    //------------------\n\n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n    if (i==104 ) { return tex3D(iChannel0, p/4., nor)*vec3(1.0,0.65,0.36); }\n    if (i==105 ) { return tex3D(iChannel0, p/4., nor)*vec3(0.30,1.0,0.36); }\n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n       \n    \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 10.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n  \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 195, 226, 226, 376], [379, 379, 424, 424, 515], [518, 518, 554, 554, 657], [659, 659, 697, 697, 800], [803, 803, 841, 841, 944], [947, 947, 985, 985, 1088], [1091, 1135, 1181, 1181, 1213], [1215, 1215, 1258, 1258, 1290], [1292, 1292, 1340, 1340, 1373], [1421, 1421, 1451, 1451, 1577], [1620, 1645, 1680, 1680, 1773], [1775, 1775, 1810, 1810, 1903], [1905, 1905, 1939, 1939, 2032], [2081, 2081, 2107, 2107, 2161], [2164, 2164, 2198, 2198, 2371], [2375, 2375, 2442, 2442, 2749], [2752, 2752, 2829, 2829, 3137], [3141, 3141, 3223, 3223, 3538], [3543, 3543, 3616, 3616, 4078], [4083, 4083, 4159, 4159, 4637], [4641, 4681, 4706, 4706, 6272], [6276, 6321, 6388, 6388, 6761], [6816, 6816, 6841, 6841, 7081], [7084, 7147, 7182, 7273, 7797], [7856, 7856, 7893, 7893, 8220], [8278, 8349, 8385, 8385, 8591], [8594, 8665, 8689, 8689, 8949], [8998, 9032, 9081, 9081, 9476], [9477, 9511, 9591, 9591, 10232], [10327, 10327, 10420, 10420, 10716], [10719, 10768, 10825, 10825, 12913]]}
{"id": "3l2BDK", "name": "montecarlo raytracing", "author": "ich", "description": "montecarlo raytracing using ray marching. dont forget to restart time after editing :)", "tags": ["montecarloraytracingpathtracingnoiserandomraymarching"], "likes": 21, "viewed": 794, "published": 3, "date": "1599875390", "time_retrieved": "2024-07-30T20:45:53.027741", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n  \tc /= float(iFrame);\n    c = pow(c, vec3(.5)) * 5.;\n    fragColor = vec4(c, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define noisy\n\n#define max_dist 100.\n#define min_dist .001\n#define bounces 3\n\nfloat seed;\n\nfloat n1() {\n\tseed += .123;\n    return fract(9221.432 * sin(seed * 43.124));\n}\n\nmat3 look(vec3 d) {\n\tvec3 r = normalize(cross(vec3(0.0001, 1, 0.0001), d));\n    vec3 u = normalize(cross(d, r));\n    return mat3(r, u, d);\n}\n\nfloat plane(vec3 p, vec3 n, float r) {\n\treturn dot(p, n) - r;\n}\n\nfloat cube(vec3 p, vec3 r) {\n    p = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat cube(vec3 p, float r, float s) {\n    s += min_dist;\n\treturn length(max(vec3(0), abs(p) - (r - s))) - s;\n}\n\nfloat cube(vec3 p, vec3 r, float s) {\n    s += min_dist;\n\treturn length(max(vec3(0), abs(p) - (r - s))) - s;\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat scene(vec3 p) {\n\tfloat l = max_dist;\n    \n    // objects\n    l = min(l, max(-cube(p, 2., 1.), plane(p, vec3(0, 0, 1), 1.)));\n    l = min(l, sphere(p - vec3(-.5, -.5, 0), .5));\n    l = min(l, sphere(p - vec3( .5, -.5, 0), .5));\n    l = min(l, cube(p - vec3(0, -1.2, -.5), vec3(1.7, .2, 1.5), .2));\n    \n    // light source\n    l = min(l, cube(p - vec3(1, 2, -.6), vec3(1.5, .5, 2)));\n    \n    return l;\n}\n\nfloat emit(vec3 p) {\n    float l = max_dist;\n\tl = min(l, cube(p - vec3(1, 2, -.6), vec3(1.5, .5, 2)));\n    return smoothstep(min_dist * 2., .0, l);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat lo = 0.;\n    vec3 p = ro;\n    \n    for (int i = 0; i < 100; ++i) {\n    \tfloat l = scene(p);\n        lo += l;\n        \n        if (l < min_dist || lo > max_dist)\n            return lo;\n        \n        p += rd * l;\n    }\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0, min_dist);\n    float l = scene(p);\n    \n    return normalize(\n    \tl - vec3(\n        \tscene(p - e.yxx),\n            scene(p - e.xyx),\n            scene(p - e.xxy)\n        )\n    );\n}\n\nvec3 montecarlo(vec3 n, float r) {\n    vec2 xy = r * vec2(n1() - .5, n1() - .5);\n    float z = n1() * .5;\n\treturn look(n) * normalize(vec3(xy, z));\n}\n\nfloat trace(inout vec3 ro, inout vec3 rd, out vec3 p, out vec3 n) {\n\tfloat l = march(ro, rd);\n    p = ro + rd * l;\n    n = normal(p);\n    ro = p + n * min_dist * 2.;\n    rd = mix(montecarlo(n, 1.), reflect(rd, n), step(n1(), .2));\n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n#ifdef noisy\n    seed = cos(iTime) * uv.x + sin(iTime) * uv.y;\n#else\n    seed = iTime;\n#endif\n\n    vec3 ro = vec3(0, 0, 5.);\n    vec3 rd = montecarlo(normalize(vec3(uv, -1)), .001);\n    \n    vec3 c = vec3(0);\n    float l = 1.;\n    float e = 0.;\n    vec3 p, n;\n    \n    for (int i = 0; i < bounces; ++i) {\n        l += trace(ro, rd, p, n);\n        e += emit(p) / (l * l);\n    }\n    c += vec3(e);\n    \n    vec2 tx = fragCoord / iResolution.xy;\n    vec2 m = (iMouse.xy / iResolution.xy);\n    c += texture(iChannel0, tx).rgb;// * m.x;\n    \n    fragColor = vec4(c, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 224]]}
{"id": "WtSBWK", "name": "Hexagonal Grid Traversal - 2D", "author": "iq", "description": "Minimal, efficient and robust hexagonal grid traversal. Each cell is visited only once, in the right order. Works great as an alternative to regular 2D grids for raytracing worlds.", "tags": ["2d", "grid", "raycasting", "hexagon", "traversal"], "likes": 50, "viewed": 1460, "published": 3, "date": "1599874448", "time_retrieved": "2024-07-30T20:45:53.880461", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Minimal, efficient and robust hexagonal grid traversal. Each cell\n// is visited only once, in the right order. The implementation boils\n// down to 7 fmad, 3 comparisons and 2 integer additions per iteration,\n// see lines 113 to 119.\n\n// This traversal can be applied to 3D too: https://www.shadertoy.com/view/WtSfWK\n\n\n#define AA 1\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdDisk( vec2 p, vec2 a, float r )\n{\n\treturn length(p-a)-r;\n}\n\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n//=============================================================\n\n// return the hexagon that p belongs to\nivec2 hexagonGetID( in vec2 p ) \n{\n\tvec2  q = vec2( p.x, p.x*0.5+p.y*0.8660254037 );\n\n    ivec2 i = ivec2(floor(q));\n\tvec2  f =       fract(q);\n    \n\tint v = mod3(i.x+i.y);\n    ivec2 id = i + v;\n    if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1);\n    \n    return ivec2( id.x, (2*id.y-id.x)/3 );\n}\n\n// return the center of an hexagon\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    return vec2(float(id.x),float(id.y)*1.732050807);\n}\n\n//=============================================================\n\nvec3 render( in vec2 pos, in float px )\n{\n\tconst float kPtRa = 0.1;\n\n    // scale image\n    pos *= 8.0;\n    px  *= 8.0;\n\n    // ray\n    vec2 ro = vec2(9.0,2.0)*cos(0.11*iTime+vec2(0.0,1.0));\n    vec2 rd = normalize(cos(0.1*iTime*vec2(1.3,1.1)+vec2(3.0,2.0)-1.0));\n\n    // draw barckground\n    ivec2 oid = hexagonGetID(pos);\n    vec3  col = vec3(0.3+0.2*sin(float(15*oid.x)+cos(float(33*oid.y))));\n\n    // draw ray\n    float d = sdSegment( pos, ro, ro+rd*30.0 );\n    col = mix(col,vec3(1,1,0),1.0-smoothstep(-px*0.5,px*0.5,d-kPtRa*0.3));\n\n    // prepare for hex-traverse\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,0.866025);\n    const vec2 n3 = vec2(-0.5,0.866025);\n    ivec2 i1 = ivec2( 2,0);\n    ivec2 i2 = ivec2( 1,1);\n    ivec2 i3 = ivec2(-1,1);\n    float d1 = 1.0/dot(rd,n1);\n    float d2 = 1.0/dot(rd,n2);\n    float d3 = 1.0/dot(rd,n3);\n    float s1 = 1.0; if(d1<0.0) {s1=-1.0;i1=-i1;} s1=(s1-dot(ro,n1))*d1;\n    float s2 = 1.0; if(d2<0.0) {s2=-1.0;i2=-i2;} s2=(s2-dot(ro,n2))*d2;\n    float s3 = 1.0; if(d3<0.0) {s3=-1.0;i3=-i3;} s3=(s3-dot(ro,n3))*d3;\n\n    // hex-traverse\n    ivec2 hid = hexagonGetID(ro);\n    float hdi = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        //-----------------------\n        // render current hexagon\n        //-----------------------\n        if( hid==oid ) col = mix(col,vec3(1.0,0.0,0.0),0.3);\n        col = mix(col,vec3(1,0,0),1.0-smoothstep(-px*0.5,px*0.5,sdDisk(pos,hexagonCenFromID(hid),kPtRa)));\n        col = mix(col,vec3(1,1,0),1.0-smoothstep(-px*0.5,px*0.5,sdDisk(pos,ro+rd*hdi,kPtRa)));\n\n        //------------------\n        // find next hexagon\n        //------------------\n        float t1 = s1+(                 float(hid.x)    )*d1;\n        float t2 = s2+(float(hid.y)*1.5+float(hid.x)*0.5)*d2;\n        float t3 = s3+(float(hid.y)*1.5-float(hid.x)*0.5)*d3;\n        \n             if( t1<t2 && t1<t3 ) { hid += i1; hdi=t1; }\n        else if( t2<t3          ) { hid += i2; hdi=t2; }\n        else                      { hid += i3; hdi=t3; }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int mm=0; mm<AA; mm++ )\n    for( int nn=0; nn<AA; nn++ )\n    {\n        vec2 off = vec2(mm,nn)/float(AA);\n        vec2 uv = (fragCoord+off)/iResolution.xy;\n        vec2 pos = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n    #else    \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 pos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    #endif\n\t\tfloat px = 2.0/iResolution.y;\n        \n\t\tvec3 col = render(pos,px);\n        \n        tot += col;\n\t}\t\n \t#if AA>1\n    tot /= float(AA*AA);\n    #endif\n        \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBWK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[461, 461, 504, 504, 614], [616, 616, 657, 657, 682], [684, 684, 703, 703, 1350], [1417, 1457, 1491, 1491, 1755], [1757, 1792, 1830, 1830, 1886]]}
{"id": "3tjfWK", "name": "SoundEclipse rpm w/gain", "author": "username", "description": "8 times louder which looks a lot cooler in my setup", "tags": ["visualization", "mic", "virtualdj"], "likes": 6, "viewed": 888, "published": 3, "date": "1599867511", "time_retrieved": "2024-07-30T20:45:54.733181", "image_code": "// Fork of \"SoundEclipse rpm\" by sclavel. https://shadertoy.com/view/ls3BDH\n// 2020-09-11 23:35:33\n\n// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\nconst float gain = 8.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x*gain + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 353, 374, 374, 543], [545, 545, 569, 569, 619], [621, 621, 650, 650, 748], [750, 750, 786, 786, 997], [999, 999, 1034, 1034, 1098], [1100, 1100, 1142, 1142, 1609], [1611, 1611, 1662, 1662, 1914], [1917, 1917, 1974, 1974, 2407]]}
{"id": "Wt2BWK", "name": "Particle Experiment 10", "author": "aiekick", "description": "Particle Experiment 10", "tags": ["experiment", "particle", "10"], "likes": 9, "viewed": 334, "published": 3, "date": "1599866609", "time_retrieved": "2024-07-30T20:45:55.499133", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 pixelCoord )\n{\n    vec2 size = iResolution.xy;\n    vec2 uv = pixelCoord / size;\n\t\n    for(int x=-AA;x<AA;x++)\n\tfor(int y=-AA;y<AA;y++)\n\t{\n\t\tfloat e = 1.0 / size.y;\n\t\tvec2 uv = (pixelCoord + vec2(x,y) / float(AA)) / size;\n\t\tfloat f = texture(backBuffer, uv).x;\n\t\tfloat fx = (f-texture(backBuffer, uv + vec2(e,0.0)).x)/e;\n\t\tfloat fy = (f-texture(backBuffer, uv + vec2(0.0,e)).x)/e;\n\t\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\t\t\n\t\tfloat diff = max(dot(vec3(0,0,1), n), 0.0);\n\t\tfloat spec = pow(max(dot(lightDirection, reflect(vec3(0,0,1),n)), 0.0), specularPower);\n\t\t\n        vec3 back = texture(backBuffer, uv).rgb;\n        vec3 front = lightDiffuse * diff + lightSpecular * spec;\n        \n\t\tfragColor.rgb += back * (1.0-lightMixing) + front * lightMixing;\n\t}\n\tfragColor /= float(AA * AA * 4);\n    fragColor *= 1.5;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 pixelCoord )\n{\n    float time = iTime;\n    vec2 size = iResolution.xy;\n    \n    vec2 uvc = (pixelCoord * 2.0 - size)/min(size.x, size.y);\n\t\n    float speedAngle = mix(0.0, 0.4, cos(mod(time * 0.01, 6.28318)) * 0.5 + 0.5);\n    \n    vec2 t = time * vec2(maxSpeedAngle, speedRadius);\n    \n\tfloat angleStep = 6.28318 / float(count);\n\tfloat m = 0.0;\n\tfor (int i=0;i<count;i++)\n\t{\n        float fi = float(i);\n\t\tfloat a = mod(t.x + angleStep * fi, 6.28318);\n\t\tfloat rad = radius.x + radius.y * sin(mod(t.y + delay * fi, 6.28318));\n\t\tvec2 d = vec2(cos(a), sin(a)) * rad;\n\t\tm += ballSize / (dot(uvc-d,uvc-d) + ballMin);\n\t}\n    \n    vec3 back = texture(backBuffer, gl_FragCoord.xy / size).rgb;\n    vec3 front = m * color;\n    \n    fragColor.rgb = front * blur + back * (1.0 - blur);\n    fragColor.rgb += smoothstep(back, back + 0.01, aura) * 0.01;\n   \n    fragColor.a = 1.0;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 color = vec3(0.1,0.5,0.4); // particle color\nconst vec3 aura = vec3(0.8,0.2,0.5); // aura color\nconst vec3 lightDiffuse = vec3(0.8,0.2,0.8); // \nconst vec3 lightSpecular = vec3(0.1,0.5,0.4); // \nconst vec3 lightDirection = vec3(-0.6);\nconst float specularPower = 8.0;\nconst float lightMixing = 0.6;\n\nconst int count = 20;\nconst float delay = 0.3;\n\nconst vec2 radius = vec2(0.5,0.3);\nconst float speedRadius = 1.5;\nconst float maxSpeedAngle = 0.4;\n\nconst float blur = 0.04;\n\nconst float ballSize = 0.002;\nconst float ballMin = 0.00001;\n\nconst int AA = 1;\n\n#define backBuffer iChannel0\t", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BWK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[138, 138, 196, 196, 1030]]}
{"id": "3tjBWK", "name": "Simple 2D Navier Stokes w/mouse", "author": "username", "description": "Click to move obstacle", "tags": ["fluid", "multipass", "navierstokes"], "likes": 6, "viewed": 554, "published": 3, "date": "1599864054", "time_retrieved": "2024-07-30T20:45:56.397730", "image_code": "// Fork of \"Simple 2D Navier Stokes\" by Wumpf. https://shadertoy.com/view/ldd3WS\n// 2020-09-11 22:37:20\n\n#define VELOCITY 0 \n#define PRESSURE 1\n#define DIVERGENCE 2\n\n#define SHOW VELOCITY\n\n\nvec4 showPressure(vec2 uv)\n{\n    return abs(texture(iChannel2, uv)) * 0.05;\n}\n\nvec4 showVelocity(vec2 uv)\n{\n    vec4 color = texture(iChannel0, uv);\n    if(color.z > 0.0) // obstacle\n    {\n        return vec4(0.5);\n    }\n    else\n    {\n        return abs(color) * 0.008;\n    }\n}\n\nvec4 showDivergence(vec2 uv)\n{\n    // Divergence should be as close to 0 as possible.. sadly it isn't.\n    return abs(texture(iChannel1, uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    #if SHOW == VELOCITY\n    fragColor = showVelocity(uv);\n    #elif SHOW == PRESSURE\n    fragColor = showPressure(uv);\n    #elif SHOW == DIVERGENCE\n    fragColor = showDivergence(uv);\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Advection & force\n\n// Magic force within a rectangle.\nconst vec2 Force = vec2(100.0, 0.0);\nconst vec2 ForceAreaMin = vec2(0.0, 0.2); \nconst vec2 ForceAreaMax = vec2(0.06, 0.8);\n\n// Circular barrier.\nconst vec2 BarrierPosition = vec2(0.2, 0.5);\nconst float BarrierRadiusSq = 0.01;\n\n#define VelocityTexture iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n\n    // Simple advection by backstep.\n    // Todo: Try better methods like MacCormack (http://http.developer.nvidia.com/GPUGems3/gpugems3_ch30.html)\n    vec2 oldVelocity = texture(VelocityTexture, uv).xy;\n    vec2 samplePos = uv - oldVelocity * iTimeDelta * inverseResolution;\n    vec2 outputVelocity = texture(VelocityTexture, samplePos).xy;\n    \n    // Add force.\n    if(uv.x > ForceAreaMin.x && uv.x < ForceAreaMax.x &&\n       uv.y > ForceAreaMin.y && uv.y < ForceAreaMax.y)\n    {\n    \toutputVelocity += Force * iTimeDelta;\n    }\n    \n    // Clamp velocity at borders to zero.\n    if(uv.x > 1.0 - inverseResolution.x ||\n      \tuv.y > 1.0 - inverseResolution.y ||\n      \tuv.x < inverseResolution.x ||\n      \tuv.y < inverseResolution.y)\n    {\n        outputVelocity = vec2(0.0, 0.0);\n    }\n    \n    // Circle barrier.\n    vec2 mou = iMouse.xy / iResolution.xy;\n    vec2 toBarrier = BarrierPosition - uv + mou - vec2( 0.2, 0.5 );\n    toBarrier.x *= inverseResolution.y / inverseResolution.x;\n    if(dot(toBarrier, toBarrier) < BarrierRadiusSq)\n    {\n        fragColor = vec4(0.0, 0.0, 999.0, 0.0);\n    }\n    else\n    {\n        fragColor = vec4(outputVelocity, 0.0, 0.0);\n    } \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Compute divergence.\n\n#define VelocityTexture iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n    \n    // Obstacle?\n    if(texture(VelocityTexture, uv).z > 0.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    float x0 = texture(VelocityTexture, uv - vec2(inverseResolution.x, 0)).x;\n    float x1 = texture(VelocityTexture, uv + vec2(inverseResolution.x, 0)).x;\n    float y0 = texture(VelocityTexture, uv - vec2(0, inverseResolution.y)).y;\n    float y1 = texture(VelocityTexture, uv + vec2(0, inverseResolution.y)).y;\n    float divergence = ((x1-x0) + (y1-y0)) * 0.5;\n    fragColor = vec4(divergence);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Jacobi iteration\n// For a more accurate result, this should be executed multiple times.\n\n#define DivergenceTexture iChannel1\n#define PressureTexture iChannel2\n#define VelocityTexture iChannel0\n\nvec2 inverseResolution;\nvec2 border;\nvec2 uv;\n\nfloat samplePressure(vec2 pos)\n{\n    // Obstacle?\n    if(texture(VelocityTexture, pos).z > 0.0)\n    {\n        return 0.0;\n    }\n    \n    // Boundary condition: Vanish for at walls.\n    if(pos.x > 1.0 - border.x || pos.y > 1.0 - border.y ||\n      \tpos.x < border.x || pos.y < border.y)\n    {\n        return 0.0;\n    }\n   \telse\n    {\n    \treturn texture(PressureTexture, pos).x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    inverseResolution = vec2(1.0) / iResolution.xy;\n    border = inverseResolution * 2.0;\n    uv = fragCoord.xy * inverseResolution;\n    \n    float div = texture(DivergenceTexture, uv).x;\n    float x0 = samplePressure(uv - vec2(inverseResolution.x, 0));\n    float x1 = samplePressure(uv + vec2(inverseResolution.x, 0));\n    float y0 = samplePressure(uv - vec2(0, inverseResolution.y));\n    float y1 = samplePressure(uv + vec2(0, inverseResolution.y));\n    \n   \tfragColor = vec4((x0 + x1 + y0 + y1 - div) * 0.25);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Subtract pressure gradient to ensure zero divergence.\n\n#define PressureTexture iChannel2\n#define VelocityTexture iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n    \n    float x0 = texture(PressureTexture, uv - vec2(inverseResolution.x, 0)).x;\n    float x1 = texture(PressureTexture, uv + vec2(inverseResolution.x, 0)).x;\n    float y0 = texture(PressureTexture, uv - vec2(0, inverseResolution.y)).x;\n    float y1 = texture(PressureTexture, uv + vec2(0, inverseResolution.y)).x;\n    vec2 pressureGradient = (vec2(x1, y1) - vec2(x0, y0)) * 0.5;\n    vec2 oldV = texture(VelocityTexture, uv).xy;\n    \n    fragColor = vec4(oldV - pressureGradient, 0.0, 0.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 218, 218, 267], [269, 269, 297, 297, 468], [470, 470, 500, 572, 614], [616, 616, 673, 673, 917]]}
{"id": "3tSfDV", "name": "Day 265", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 325, "published": 3, "date": "1599859368", "time_retrieved": "2024-07-30T20:45:57.377112", "image_code": "// Fork of \"Day 264\" by None. https://shadertoy.com/view/-1\n// 2020-09-11 10:22:57\n\n// Fork of \"Day 264\" by jeyko. https://shadertoy.com/view/tl2BWG\n// 2020-09-11 09:35:06\n\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.7;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*0.4);\n}\n", "buffer_a_code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n// ----------\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\n\n\nfloat bspline( in vec2 coords );\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\t\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    //p.z = pmod(p.z,4.5);\n    \n    if(mp == 0.){\n    \td = length(p.xz) + 0.02 - abs(sin(p.y*9.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n    \n    \td = xor(d, max(length(p.z), abs(p.y) - 0.5),0.3);\n    \n    } else if (mp == 1.){\n    \td = sdBox(p,vec3(0.8)) + 0.0 - 0.*abs(sin(p.y*4.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n        \n        \n    \n    \t//d = xor(d, max(length(p.z), abs(p.y) - 0.1),0.3);\n    \n    \n    }\n    \n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    d = abs(d) - 0.01;\n    \n    return d;\n}\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt){\n\tfloat d = 10e5;\n    \n    vec3 ro = vec3(0.3,0.34,.12)*12.;\n    \n    vec3 rd = getRd(ro,vec3(0.),uv);\n    \n    \n    \n    \n    for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n    \tvec3 lro = ro + vec3(0,i,0);\n        \n        \n        float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n        vec3 p = lro + rd*plane;\n    \t\n        vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n        \n        float m = map(vec3(p.x,(lro + rd*plane).y - i*1.5,p.z));\n        if(m <= d){\n        \t\n        \t//df = max(ldf.y,ldf.x)*1.;\n        \t\n            df = length(ldf)*1.;\n            \n\t\t\td = min(d,m);\n        \n        }\n        \n    }\n    \n    \n    return d ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*200.;\n    \n    df = dFdx(uv.x)*9.;\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 c = vec3(0.45,.35,0.25)*2.8;\n    \n    \n    c = vec3(1);\n    vec3 col = iFrame < 2 ? c : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    \n    float id = floor(mod(frame/period,10.));\n    seg = floor(frame/period );\n        \n    if(mod(float(iFrame)*SPEED,1.) < SPEED && frame > 0.){\n    \tvec2 roll = r12(frame + 1.);\n    \n        float a = 0.03;\n        \n        if(frame == 4.){\n\t\t\tmp = 0.;\n            \n            d = slice(uv, -2., 2., 39.);\n            \n        \tcol = colour( d + 0.006 , col, vec3(0), 0,0,8.,0.01);\n           \t\n            \n            d = xor(d, -abs(length(uv.x) - 1.),0.8);\n            \n            d = xor(d,-(length(uv.x) - 0.54),0.4);\n            \n        \tcol = colour( d , col, vec3(0.), 0,3,2.,.4);\n           \n            \n            d = jaggy(uv*rot(0.5*pi),0.,1.,0.5);\n\n            col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n           \t\n            \n            d = xor(d,-(length(uv) - .0),0.6);\n            \n            col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n        \n                \n            /*\n            uv *= 2.;\n            uv.y += 0.5;\n        \t\n            uv -= vec2(0.1,0.7);\n            d = dotwork(uv + 0.5, .5 - 0.1, 0.00,1.);\n        \n            \n            vec2 po = vec2(-0.5,0.2);\n            d = max(d, (length(uv - po) - .2));\n        \t\n            \n            d = min(d, abs(length(uv - po) - .2) - 0.003);\n        \n        \n            \n            uv += vec2(0.0,0.8);\n            d = min(d, (length(uv - vec2(0.3)) - .2));\n        */\n        \tcol = colour( d , col, vec3(0), 0,0,4.,0.);\n           // col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n           \t\n            \n            \n        }\n             \n         \n\t    \n        \n        \n        \n        \n        \n        \n        \n        \n        //d = max(d, length(uv) - 0.2);\n        \n        \n    }\n    \n    \n    col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n    /*\n    if(ss == 0.){\n    \n    \n    } else if(ss == 1.){\n     \troll = r12(frame + 38.);\n    } else if(ss== 2.){\n     \troll = r12(frame - 13. - period*2.);\n    } else if(ss== 3.){\n     \troll = r12(frame + 44. - period*3.);\n    } else if(ss== 4.){\n     \troll = r12(frame - 64.);    \n    } else if(ss== 5.){\n     \troll = r12(frame - 24.);\n    }*/\n    \n    vec4 n = valueNoise(guv,1.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\t//db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*0.4).x*0.53*n.z*strokeparamb,0.,db );\n        \n        \n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08;\n        \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.0;\n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 305, 305, 362], [363, 363, 396, 396, 925], [926, 926, 944, 944, 1272], [1275, 1275, 1332, 1332, 2210]]}
{"id": "tlSfDK", "name": "maya pyramid", "author": "FabriceNeyret2", "description": "reference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n\nNote that my anti-banding tricks doesn't work here, due to the heap of discontinuities.", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 8, "viewed": 349, "published": 3, "date": "1599845753", "time_retrieved": "2024-07-30T20:45:58.152040", "image_code": "#define rot(a)      mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n        \nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 q ) {\n    float t,a;\n    q.xy = abs(q.xy), a = max(q.x,q.y), \n    t = max( (a==q.x?q.y:q.x) -2. ,                   // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 ),        // slopes top \n    t = max( t, q.z-7.),                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.),   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5)),// doors\n    t = max( t, q.z-9.),                              // top end\n    t = min(t, s = q.z);                              // floor\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.;                                     // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-2) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25), q;                        // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(.3*t);               // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(.3*t);\n\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += .5*t*D;                                  // sphere-tracing step\n    \n    c = 1. - c/50.;                                   // pseudo-lighting\n    O = t==s ? vec4(0,.2,0,1) : vec4(1,.8,.6,1);      // coloring\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 276, 276, 808], [810, 810, 846, 846, 1897]]}
{"id": "tlBBWK", "name": "puente -v2", "author": "jorge2017a1", "description": "puente -v2", "tags": ["puentev2"], "likes": 5, "viewed": 253, "published": 3, "date": "1599834884", "time_retrieved": "2024-07-30T20:45:59.097512", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\n\nvec3 caminowavevY(vec3 p, float freq)\n{    \n\n    vec3 p8=p;\n    p8.y+=freq*sin(p8.z*0.25)-1.0;\n    \n    return p8;\n} \n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    p.y=p.y-5.0;\n    //p= rotate_x(p, radians(90.0));\n        \n    \n\tvec3 q=p;\n     pp=p;\n    float cz=25.0;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n    \n    \n    \n    vec3 q1=pp;\n    float cz1=iTime;\n    q1.z = mod(q1.z+0.5*cz1,cz1)-0.5*cz1;\n    \n    \n\t\n    float posy=10.0;\n    float sdbAA= sdBox(p-vec3(0.0,0.0,0.0), vec3(15.0,1.0,20.0) );\n    \n    vec3 pwave1=caminowavevY( p, 3.0);\n    vec3 pwave2=caminowavevY( q1, 5.0);\n    \n    float sdbV1= sdBox(pwave1-vec3(-12.5,2.0,0.0), vec3(3.5,6.0,20.0) );\n    float sdbV2= sdBox(pwave1-vec3( 12.5,2.0,0.0), vec3(3.5,6.0,20.0) );\n    \n    float sdb1A= sdBox(pwave1-vec3(-12.0,posy,-5.0), vec3(2.0,2.0,1.5) );\n    float sdb2A= sdBox(pwave1-vec3(-12.0,posy,1.0), vec3(2.0,2.0,1.5) );\n    float sdb3A= sdBox(pwave1-vec3(-12.0,posy,7.0), vec3(2.0,2.0,1.5) );\n    float sdb4A= sdBox(pwave1-vec3(-12.0,posy,13.0), vec3(2.0,2.0,1.5) );\n   \n    \n    float sdb1B= sdBox(pwave1-vec3(12.0,posy,-5.0), vec3(2.0,2.0,1.5) );\n    float sdb2B= sdBox(pwave1-vec3(12.0,posy,1.0), vec3(2.0,2.0,1.5) );\n    float sdb3B= sdBox(pwave1-vec3(12.0,posy,7.0), vec3(2.0,2.0,1.5) );\n    float sdb4B= sdBox(pwave1-vec3(12.0,posy,13.0), vec3(2.0,2.0,1.5) );\n    \n    \n    res =opU3(res, vec3(sdbAA,-1.0,1.0)); \n    res =opU3(res, vec3(sdbV1,-1.0,3.0)); \n    res =opU3(res, vec3(sdbV2,-1.0,3.0)); \n    \n    \n    res =opU3(res, vec3(sdb1A,100.0,-1)); \n    res =opU3(res, vec3(sdb2A,100.0,-1)); \n    res =opU3(res, vec3(sdb3A,100.0,-1)); \n    res =opU3(res, vec3(sdb4A,100.0,-1)); \n    \n    res =opU3(res, vec3(sdb1B,100.0,-1)); \n    res =opU3(res, vec3(sdb2B,100.0,-1)); \n    res =opU3(res, vec3(sdb3B,100.0,-1));\n    res =opU3(res, vec3(sdb4B,100.0,-1));\n    \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//-------------------------------------------------\nvec3 checkerTextura(vec2 uv, float repeats) \n{\n  float cx = floor(repeats * uv.x);\n  float cy = floor(repeats * uv.y); \n  float result = mod(cx + cy, 2.0);\n  float tmp= sign(result);\n   vec3 col1=vec3(0.5);\n    \n    if (tmp<=0.0)\n        col1=vec3(0.2,0.5,1.0);//azul\n    \t//col1=vec3(1.2,0.5,1.0);//rosa\n   \telse\n        col1=tex3D(iChannel0, mObj.p/32., mObj.normal);\n    \n    return col1;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  \n   \n    \n    if (id_material==1.0)\n    {\n     \n    \treturn checkerTextura(mObj.p.xz, 0.25);\n    }\n    \n    \n    if (id_material==2.0)\n    {\n     \n    \treturn checkerTextura(mObj.p.xy, 0.25);\n    }\n    \n    if (id_material==3.0)\n    {\n     \t//return checkerTextura(mObj.p.zy, 0.125);\n    \treturn checkerTextura(mObj.p.zy, 0.25);\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            \n            colobj*=getMaterial(p, id_material); \n    \t\t\n            return colobj;\n        }\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n    \n    vec3 ro=vec3(0.0,15.0,-25.0+t);\n\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n   \n\n    if(i== 31 )\n    { \n    vec3 c=hsv(vec3(dot(floor(mObj.p),vec3(.5,.2,.1)),1.,1.));\n    }\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 195, 226, 226, 376], [379, 423, 469, 469, 501], [503, 503, 546, 546, 578], [580, 580, 628, 628, 661], [709, 709, 739, 739, 865], [869, 869, 908, 908, 985], [989, 1029, 1054, 1054, 3116], [3120, 3165, 3232, 3232, 3605], [3660, 3660, 3685, 3685, 3925], [3928, 3991, 4026, 4117, 4641], [4700, 4700, 4737, 4737, 5064], [5122, 5193, 5229, 5229, 5435], [5438, 5509, 5533, 5533, 5793], [5842, 5876, 5925, 5925, 6161], [6162, 6196, 6276, 6276, 6917], [6918, 6970, 7016, 7016, 7363], [7366, 7417, 7464, 7464, 7843], [7897, 7897, 7990, 7990, 8471], [8474, 8523, 8580, 8580, 9875]]}
{"id": "wlBBWK", "name": "tunel colores", "author": "jorge2017a1", "description": "tunel colores", "tags": ["tunelcolores"], "likes": 5, "viewed": 346, "published": 3, "date": "1599834877", "time_retrieved": "2024-07-30T20:46:00.044979", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n\n\n\nvec3 opRep3D( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\nmat3 rz(float a){float s=sin(a),c=cos(a);return mat3(c,s,0.,-s,c,0.,0.,0.,1.);}\n\nvec4 map(vec3 pp)\n{\n    vec3 p=pp;\n    p*=rz(sin(iTime+p.z*1.)*.3);\n    vec3 c=hsv(vec3(dot(floor(p),vec3(.5,.2,.1)),1.,1.));\n    \n    \n    float sdcy1= sdCylinderXY(pp-vec3(0.0,0.0,0.0), vec2(6.0,20.0) );\n    float sdcy2= sdCylinderXY(pp-vec3(0.0,0.0,0.0), vec2(5.0,21.0) );\n    \n    float cir1=length(mod(p,1.)-0.5)-.3;\n    \n    float dif= differenceSDF(sdcy1, sdcy2);\n     dif= differenceSDF(dif, cir1);\n    \n    \n    return vec4( dif,c);\n    \n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    p.y=p.y-5.0;\n\n    \n    vec3 q=p;\n    float cz=20.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n    \n    \n     vec4 res4= map(p);\n    mObj.color=vec3(res4.y, res4.z, res4.w);\n\n    res =opU3(res, vec3(res4.x,-2.0,MATERIAL_NO)); \n    \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n    \n    vec3 ro=vec3(0.0,5.0,-25.0+t);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 235, 235, 338], [340, 340, 378, 378, 481], [484, 484, 522, 522, 625], [628, 628, 666, 666, 769], [772, 816, 862, 862, 894], [896, 896, 939, 939, 971], [973, 973, 1021, 1021, 1054], [1103, 1103, 1133, 1133, 1259], [1261, 1299, 1337, 1337, 1390], [1394, 1394, 1432, 1432, 1485], [1527, 1552, 1587, 1587, 1680], [1682, 1682, 1717, 1717, 1810], [1812, 1812, 1846, 1846, 1939], [1944, 1944, 1961, 1961, 2023], [2025, 2025, 2044, 2044, 2473], [2476, 2516, 2541, 2541, 2999], [3003, 3048, 3115, 3115, 3488], [3543, 3543, 3568, 3568, 3808], [3811, 3874, 3909, 4000, 4524], [4583, 4583, 4620, 4620, 4947], [5005, 5076, 5112, 5112, 5318], [5321, 5392, 5416, 5416, 5676], [5678, 5758, 5807, 5807, 6043], [6044, 6078, 6158, 6158, 6799], [6853, 6853, 6946, 6946, 7222], [7225, 7274, 7331, 7331, 8623]]}
{"id": "wtjfDy", "name": "Sorted Overlapping Quadtree", "author": "Shane", "description": "An overlapping quadtree structure with sorted elements.", "tags": ["random", "sort", "overlay", "layers", "quadtree"], "likes": 44, "viewed": 1081, "published": 3, "date": "1599832699", "time_retrieved": "2024-07-30T20:46:01.219838", "image_code": "/*\n\n\tSorted Overlapping Quadtree\n\t---------------------------\n\n\tThis is a quadtree structure that allows for its cell objects to overlap\n\twith neighbors. The resultant objects have been given a height value, which\n\thave been sorted for rendering.\n\n\tTo be sure, there are easier ways to render random sized objects onto a \n    screen, but I wanted a way to test an overlapping quadtree structure that \n    I'll be using in a following example involving an extruded grid of packed \n    multiscaled pylons. Having said that, using this structure produces a \n    cleaner, packed, more evenly distributed look with fewer operations. An \n    overlapping quadtree also has other uses, like multiscaled Voronoi with \n    minimal taps.\n\n\tIn particular, I'm using the structure to render some closely packed \n    overlapping circles with a custom overlay function to give the impression of \n    transparent interiors. Years ago, I remember naively thinking that \n    transparent objects wouldn't require sorting, but unfortunately, overlaying\n\tcolor order matters. The custom overlay formula was made up on the spot to \n    produce a reasonable looking see-through effect, but it's not what anyone\n\twould describe as physically correct. By the way, you could save quite a \n    few calculations and leave things unsorted, but you'd lose that interesting \n\trandom height look.\n\n\tThe three levels here require a maximum of 27 taps (fewer, on average), on \n    account of the fact that the objects stray from their cell centers quite a \n    bit, which necessitates a 3x3 grid check for all three levels. However, with \n    range restrictions, it's possible to get away with 2x2 checks, for a maximum \n    of just 12 in total.\n\n\tSome may have also noticed that this is a little heavy on the rendering side\n\tof things, which is noticeable in fullscreen mode. Therefore, when I've got \n    some time, I'll find ways to cut that down.\n \n\n\tRelated examples:\n\n    // Here's a very basic non-overlapping quadtree example. Things are much \n    // easier, and almost trivial, when neighbors don't need to be considered.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\n\n*/\n\n\n// Random cell object offsets: If you turn this off, you can see the\n// packed quadtree structure.\n#define RANDOM_OFFSET\n\n// A faster version with a maximum 12 taps for three levels. It's just what\n// you need for packed extruded objects contained within cells, but doesn't\n// provide enough random range for this example.\n//#define FASTER\n\n// Sort the cell objects in order of height. Of course, there's no rule that\n// says you have to sort the objects. If you comment this out, objects will\n// be added to the canvas in the same order they were added to the quadtree,\n// which will be in order of object size.\n#define SORT\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(113, 1)));\n    \n    //return fract(vec2(262144, 32768)*n);\n    \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.5 + .5;\n    \n}\n\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\nfloat sBox(in vec2 p, in vec2 b){\n\n  \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D ch, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(ch, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n// Maximum array number.\n#define ANUM 32 \n\n// Total cell objects for the pass.\nint objN = 0;\n\n// The cell object structure: I try to avoid structures in \n// pixel shaders, but sometimes they're convenient.\nstruct obj{\n    \n    float dist; // Object distance.\n    float distSh; // Object shadow distance.\n    vec2 id; // Position based ID.\n    vec2 offs; // Cell offset.\n    float boxID; // Cell ID.\n    float height; // Cell height.\n    vec2 dim; // Cell dimensions.\n};\n\n\n// Global cell scale.\n#define GSCALE vec2(1./5.);\n\n// The quadtree function.\nobj[ANUM] blocks(vec2 q3, vec3 lp){\n    \n    \n    // Cell scale and dimension.\n    vec2 oDim = GSCALE;\n    vec2 dim = GSCALE; \n    \n    // Overall minimum distance. Not used here.\n    //float d = 1e5;\n    \n    \n    // An array or objects.\n    obj[ANUM] sq;\n    \n    // Reset the number of objects.\n    objN = 0;\n    \n    \n    // Chance that level one, two or three will be rendered:\n    //\n    // The final entry needs to fill in whatever cells are remaining, so needs to have a \n    // 100% chance of success. I'd rather not say how long it took me to figure that out. :D\n    vec3 rndTh = vec3(.333, .666, 1.01);\n    \n    \n    \n    for(int k=0; k<3; k++){\n \n        #ifdef FASTER\n        for(int j = 0; j<=1; j++){\n            for(int i = 0; i<=1; i++){\n                \n                // For the 12 tap (4-tap IJ loop), we need the \"-.5\" figure to center things.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j) - .5;\n        #else\n        for(int j = -1; j<=1; j++){\n            for(int i = -1; i<=1; i++){\n                \n              \t// For the 27 tap (9-tap IJ loop), take it off the expression.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j);\n        #endif\n                \n\n                // First level random subdivision.\n                vec3 rndIJ;\n                rndIJ[0] = hash21(floor(ip0));\n                if(rndIJ[0]>=rndTh[k]) continue;\n\n                // Second level random subdivision.\n                rndIJ[1] = hash21(floor(ip0/2.));\n                if(k==1 && rndIJ[1]<rndTh[0]) continue;\n\n                // Third level random subdivision.\n                rndIJ[2] = hash21(floor(ip0/4.));\n                if(k==2 && (rndIJ[1]<rndTh[1] || rndIJ[2]<rndTh[0])) continue;\n\n\n                // Local coordinates and cell ID.\n                vec2 p = q3.xy;\n                vec2 ip = floor(ip0) + .5;\n                p -= ip*dim; // Last term for 8 iterations.\n\n                // The cell's center position-based ID.\n                vec2 idi = ip*dim;\n\n              \n                #ifdef RANDOM_OFFSET\n                // Texture based object height.\n                float h = hm(idi);\n                h *= .15;\n                \n                #ifdef FASTER\n                vec2 offs = (hash22(idi + .63*dim) - .5)*dim*.3;\n                #else\n                vec2 offs = (hash22(idi + .41*dim) - .5)*dim*.5;\n                #endif\n                #else\n                vec2 offs = vec2(0);\n                 \n                float h = .15/2.; // Make the heights even.\n                #endif\n\n                \n\n                // Fake light direction vector calculation. It's not entirely correct,\n                // but produces the right effect.\n                vec2 ld = normalize(lp - vec3(idi + offs, 0)).xy;\n                \n                // Scaling factor, based on height.\n                float scF = 1./1. + (h*2. - .15)*1.;\n                #ifdef FASTER \n                scF *= 1.08;\n                ld *= .75;\n                #endif\n                \n                // Distance and distance shadow calculations.\n                float di2D = length(p - offs) - dim.x/2./scF;\n                \n                float di2DSSh = length(p - offs - -.03*ld) - dim.x/2./scF;\n\n \t\t\t\t// Boxes. I'll be using boxes for the 3D example.\n                //float di2D = sBoxS(p, dim/2. - .05*oDim.x, .1*oDim.x);\n                //float di2DSSh = sBoxS(p - vec2(-.03), dim/2. - .05*oDim.x, .1*oDim.x);\n\n\n                // For 3D and other things, you'd update on a closest basis, but\n                // in this case, we need to render them all.\n                //if(di2D<d){\n                //d = di2D;\n\n                // The quadtree cell ID.\n                #ifdef FASTER\n                float boxID = float(k*4 + j*2 + (1 - i));\n                #else\n                float boxID = float(k*9 + (j + 1)*3 + (2 - (i + 1)));\n                #endif\n\n\t\t\t\t// Fill in the object values.\n                sq[objN].dist = di2D;\n                sq[objN].distSh = di2DSSh;\n                sq[objN].id = idi;\n                sq[objN].offs = offs;\n                sq[objN].boxID = boxID;\n                sq[objN].height = h;\n                sq[objN].dim = dim;\n\n                // Increment the global object count.\n                objN++;\n                //}\n\n\n\n            }\n        }\n\n        // Cut the dimension in half for the next level.\n        dim /= 2.;\n        \n    }  \n    \n    // Return the object array.\n    return sq;\n    \n    \n}\n\n\n// float swap.\nvoid swap(inout float a, inout float b){ float tmp = a; a = b; b = tmp; }\n// float swap.\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/16.)/16., t/8.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/8.)/16.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = 1.5*gSc/iResolution.y;\n \n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    //vec2 p = uv*gSc - vec2(-.5, -1)*iTime/8.;\n    \n    // Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    mat2 scrRot = rot2(0.);//rot2(3.14159/4.);\n    vec2 p = scrRot*(uv*gSc)*camRot + scrRot*cam;//rot2(3.14159/4.)*\n    \n    vec2 oP = p; // Save a copy.\n    \n    // Surface point and light position.\n    vec3 sp = vec3(p, 0); \n    vec3 lp = vec3(p - uv*gSc, -.35);\n    lp.xy += vec2(-.1, .15);\n    \n    // Using the quadtree structure to fill in the object array.\n    // Passing in the positino and light postion for shadows.\n    obj[ANUM] svObj = blocks(p, lp);\n     \n    // By the way, it's possible just to render the objects in the \n    // order that they're added to the list, but you'll lose the\n    // random ordered look. In this case, large objects would stay on \n    // the bottom and smaller would appear at the top.\n    \n    // Height and indices for sorting purposes.\n    int[ANUM] index;\n    float[ANUM] h;\n    for(int i = 0; i<objN; i++){\n        h[i] = svObj[i].height;\n        index[i] = i;\n    }\n   \n    #ifdef SORT\n    // Anyone who knows sorting will know this is not a fast sort,\n    // but it'll do. In fact, I remember reading somewhere that GPUs\n    // prefer straight forward things like this, rather than quick\n    // sorts, and so forth... but I'll leave that to the experts.\n    for(int i = 0; i<objN; i++){\n        for(int j = i + 1; j<objN; j++){\n            // Branchless swaps are possible, but I'm a little paranoid\n            // regarding precision issues.\n            if(h[i]<h[j]){ \n                swap(h[i], h[j]);\n                swap(index[i], index[j]);\n            }\n        }\n\t}\n    #endif\n    \n\n    // Background texture.\n    vec3 tx = texture(iChannel0, p).xyz; tx *= tx;\n    tx = smoothstep(0., .5, tx);\n    \n    // Background color.\n    vec3 col = vec3(.7, .5, .4)*1.2;\n    col *= mix(tx, col, .25);\n    \n    \n    // Fake light distance and attenuation.\n    float lDist = length(lp - sp);\n    float atten = 1./(1. + pow(lDist, 4.)*3.);\n    col *= atten;\n \n    for(int ii = 0; ii<objN; ii++){\n        \n        // Sorted index. Index sortings saves the extra hassle of\n        // object sorting.\n        int i = index[ii];\n        \n        // Some random numbers.\n        float rnd = hash21(svObj[i].id);\n        float rnd2 = hash21(svObj[i].id + .47);\n        float rnd3 = hash21(svObj[i].id + .73);\n         \n        // Fake 3D scaling factor. Closer object appear larger, so this is \n        // used for texture scaling.\n        float distF = 1. + (.15 - svObj[i].height*2.);\n        \n        // A color texture read.\n        vec3 tx2 = texture(iChannel1, svObj[i].id/distF).xyz; tx2 *= tx2;\n \t\t//tx2 = smoothstep(0., .5, tx2);\n        // Another texture read. \n        tx = texture(iChannel0, (p - (svObj[i].id + svObj[i].offs))/distF).xyz; tx *= tx;\n        tx = smoothstep(-.1, .5, tx);\n        \n        // Object color.\n        vec3 oCol = mix(tx, tx2, .25)*vec3(1, .7, .5)*1.35;\n         \n        // Circle distance and shadow.\n        float d = svObj[i].dist;\n        float dSh = svObj[i].distSh;\n        // Ring and corresponding ring shadow.\n        float rw = .012; // Ring width.\n        float ring = abs(d + rw/2.) - rw/2.;\n        float ringSh = abs(dSh + rw/2.) - rw/2.;\n        \n        // Subtle shading.\n        float sh = max(.9 - d/svObj[i].dim.x, 0.);\n        \n        sp = vec3(p.x, p.y + (.15 - svObj[i].height*2.), 0);\n        lDist = length(lp - sp);\n        atten = 1./(1. + pow(lDist, 4.)*3.);\n        \n        // Polar ring pattern.\n        vec2 q = p - svObj[i].id - svObj[i].offs;\n        float ang = atan(q.y, q.x);\n        #ifdef RANDOM_OFFSET\n        // Randomly rotate the pattern.\n        ang += (floor(rnd*2.) - .5)*iTime/2.*(rnd2*.5 + .5);\n        #endif\n        // Scale factor for the ring number. Smaller circles mean\n        // fewer polar lines.\n        #ifdef FASTER\n        float scF = floor(svObj[i].boxID/4.);\n        #else\n        float scF = floor(svObj[i].boxID/9.);\n        #endif\n        scF = exp2(scF); // Equivalent to: pow(2., scF);\n        float pat = abs(fract(ang/6.2831853*32./scF) - .5)*2. - .15;\n        pat = smoothstep(0., sf*32./scF, pat)*.65 + .35;\n        \n        \n       \n        vec3 shCol = (.5 + 6.*sh*oCol*atten);\n        vec3 shCol2 = (.75 + 3.*sh*oCol*atten);\n        // Blinking formula... One of many.\n        rnd3 = smoothstep(.75, .9, sin(rnd3*6.2831853 + iTime*2.)*.5 + .5);\n        shCol = mix(shCol2, shCol, rnd3);\n        // Perspex shadow... The idea is that the light would cast a colored\n        // light onto the ground... Maybe. None of this is important.\n       \n        vec3 gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, dSh + .004 + rw)));\n        \n        // Solid ring shadow.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ringSh))*.6);\n        \n        // The object ring itself.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ring))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, ring))*.9);\n        col = mix(col, oCol*1.35*atten*pat, (1. - smoothstep(0., sf, ring + .004))); \n        \n        \n        // The top perspex layer... or is it thin cellophane, or just a thin \n        // colored light shining across the rim? No idea, but I thought the \n        // transparent colored light provided visual interest. :)\n        gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        // \n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, d + .004 + rw)));\n        \n  \n        \n    }\n    \n  \n    \n    \n    // Rough gamma correction and output.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2797, 2830, 2852, 2852, 2910], [2913, 2941, 2962, 2962, 3025], [3027, 3049, 3070, 3419, 3695], [3968, 4215, 4249, 4626, 4716], [4718, 4782, 4802, 4802, 4862]]}
{"id": "tt2fWy", "name": "rey-payaso", "author": "jorge2017a1", "description": "rey-payaso", "tags": ["reypayaso"], "likes": 1, "viewed": 245, "published": 3, "date": "1599789765", "time_retrieved": "2024-07-30T20:46:02.171294", "image_code": "//por jorge2017a1- 10/sep/2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n//----------oPeraciones de Repeticion\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\nvec3 HacerOjoEnCabeza(vec3 p,  float fRadioCabeza, vec3 posOjoA,vec3 posCorneaA, vec2 MedOjo, vec2 MedCornea)\n{\t\n    \n    vec3 res = vec3(9999.0, -1.0,-1.0);\n   \n\t//ojo derecho\n    float sdcyA1= sdCylinderXY(p- posOjoA, MedOjo );  //ojo\n    float sdcyA2= sdCylinderXY(p- posCorneaA ,MedCornea ); //cornea\n    float sdspA1= sdSphere( p-vec3(0.0,0.0,0.0),fRadioCabeza );         //cabeza\n   \n    float difcirculocylA1= differenceSDF(sdspA1, sdcyA1);   //diferencia cabeza ojo\n    float intersecionA1= intersectSDF(sdspA1,sdcyA1);     //interseccion cabeza ojo\n    \n    //cornea\n    float difcirculocylA2= differenceSDF(sdspA1, sdcyA2);   //diferencia cabeza cornea\n    float intersecionA2= intersectSDF(sdspA1,sdcyA2);     //interseccion cabeza cornea\n    \n            \n    res =opU3(res, vec3(intersecionA1,1.0,-1));  //ojo\n    res =opU3(res, vec3(intersecionA2,0.0,-1));  //cornea\n    res =opU3(res, vec3(difcirculocylA1,19.0,-1)); //difeencia cabeza\n    \n    \n   \n    posOjoA=vec3(-posOjoA.x,posOjoA.y,posOjoA.z);\n\tposCorneaA=vec3(-posCorneaA.x,posCorneaA.y,posCorneaA.z);\n\t \n     //----------------001--------------\n    //----------------001--------------\n    //ojo iZq\n    float sdcyB1= sdCylinderXY(p- posOjoA, vec2(1.5,7.5) );\n    float sdcyB2= sdCylinderXY(p- posCorneaA, vec2(0.5,7.5) ); //cornea\n    float sdspB1= sdSphere( p-vec3(0.0,0.0,0.0), fRadioCabeza );\n    float difcirculocylB1= differenceSDF(difcirculocylA1, sdcyB1);  //cabeza  -Ojo\n    float intersecionB1= intersectSDF(sdspB1,sdcyB1);   //cabeza intersccion  ojo\n    \n    \n    float difcirculocylB2= differenceSDF(difcirculocylA1, sdcyB2); //cabeza-ojo\n    float intersecionB2= intersectSDF(sdspB1,sdcyB2);   //cabeza interseccion cornea\n            \n    res =opU3(res, vec3(intersecionB1,1.0,-1)); //ojo\n    res =opU3(res, vec3(intersecionB2,0.0,-1));  //cornea\n    \n    //----------------001--------------\n    //----------------001--------------\n    \n    \n    return res;\n\n}\n\n\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat RotacionPolarCilindro(vec3 p, float numItem)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1=sdCylinderYZ(rep2-vec3(0.0), vec2(0.5,5.0));\n    \n    return  sdb1;\n}\n\n\n\nfloat RotacionPolarCilindroMed(vec3 p, float numItem, vec2 medCy)\n{\n    float tau = atan(1.0) * 8.0;\n    p.xy *= genRotMat(0.0);/// genera la rotacion del engrane\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1=sdCylinderYZ(rep2-vec3(0.0), medCy ); //vertical\n    return  sdb1;\n}\n\n\nfloat HacerCorona(vec3 p)\n{\n    \n    float sdCoronaGr= sdCylinderXZ(p-vec3(0.0,11.0,0.0), vec2(8.3, 1.8) );\n    float sdCoronaCh= sdCylinderXZ(p-vec3(0.0,11.0,0.0), vec2(7.5, 2.0) );\n    float difcorona= differenceSDF(sdCoronaGr, sdCoronaCh);\n    \n    p= rotate_x(p, radians(90.0));\n    float rpcy=RotacionPolarCilindroMed(p-vec3(0.0,0.0,12.5), 10.0,vec2(2.0,10.0) );\n    float dif= differenceSDF(difcorona, rpcy );\n\treturn dif;\n\n}\n\n\nfloat HacerBoca(vec3 pp)\n{\n    \n    vec3 p= rotate_x(pp, radians(90.0));\n    float sdt1 =sdTorus(p-vec3(0.0), vec2(2.0,0.5) );\n    float sdb1= sdBox(pp-vec3(0.0,2.5,-0.5), vec3(3.5,3.0,4.0) );\n    float dif= differenceSDF(sdt1, sdb1 );\n    return dif;\n}\n        \n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n  \n    float planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n  \n    \n    p.y=p.y-5.0;\n    \n        \n    //----------cabeza Cilindro\n   \tfloat sdCabeza= sdCylinderXZ(p-vec3(0.0,0.0,0.0), vec2(8.0, 10.0) );\n    res =opU3(res, vec3(sdCabeza,24.0,MATERIAL_NO)); \n    \n    //ojos medio circulo\n    \n    float OjoDer= sdCylinderXY(p-vec3(2.5,5.0,-3.0), vec2(2.0,5.0));\n    float OjoIzq= sdCylinderXY(p-vec3(-2.5,5.0,-3.0), vec2(2.0,5.0));\n    \n    float sdbDer=sdBox(p-vec3(2.5,3.0,-3.0), vec3(2.2,2.0,5.5) );\n    float sdbIzq=sdBox(p-vec3(-2.5,3.0,-3.0), vec3(2.2,2.0,5.5) );\n    \n    \n    float difder= differenceSDF(OjoDer, sdbDer);\n    float difizq= differenceSDF(OjoIzq, sdbIzq);\n    \n    \n    \n    float difCabezaOjoDer=  differenceSDF(sdCabeza, difder);   //diferencia cabeza ojo\n    float difCabezaOjoIzq=  differenceSDF(difCabezaOjoDer, difizq);   //diferencia cabeza ojo\n    \n    float intersecionCabezaOjoDer= intersectSDF(sdCabeza,difder);     //interseccion cabeza ojo\n    float intersecionCabezaOjoIzq= intersectSDF(sdCabeza,difder);\n    \n    res =opU3(res, vec3(difCabezaOjoDer,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(intersecionCabezaOjoDer,1.0,MATERIAL_NO)); \n    \n    res =opU3(res, vec3(difCabezaOjoIzq,25.0,MATERIAL_NO)); \n    res =opU3(res, vec3(intersecionCabezaOjoIzq,1.0,MATERIAL_NO)); \n    \n    \n    \n    float CorneaDer= sdCylinderXY(p-vec3(2.8,5.5,-3.0), vec2(0.5,5.0));\n    float CorneaIzq= sdCylinderXY(p-vec3(-2.8,5.5,-3.0), vec2(0.5,5.0));\n    \n    \n    res =opU3(res, vec3(CorneaDer,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(CorneaIzq,0.0,MATERIAL_NO)); \n    \n    \n    \n    float sdNariz1= sdSphere( p- vec3(0.0,2.0,-8.0), 2.0 );\n    res =opU3(res, vec3(sdNariz1,2.0,MATERIAL_NO)); \n    \n    \n    float hb1= HacerBoca(p-vec3(0.0,0.0,-8.0));\n    res =opU3(res, vec3(hb1,3.0,MATERIAL_NO)); \n    \n    float sf2=RotacionPolarCilindro(p-vec3(0.0,15.0,0.0), 5.0);\n    res =opU3(res, vec3(sf2,7.0,MATERIAL_NO)); \n    \n\t\n    \n    float hc1= HacerCorona(p);\n    res =opU3(res, vec3(hc1,4.0,MATERIAL_NO)); \n        \n    \n    \n    ///--------------------------\n    //-------------2da cabeza\n    float fRadioCabeza;\n    vec3 posOjoA;\n    vec3 posCorneaA;\n    vec2 MedOjo;\n    vec2 MedCornea;\n    \n    \n    ///cabeza n2\n    posOjoA=vec3(1.8,1.0,0.0);\n\tposCorneaA=vec3(1.5,1.0,0.0);\n\tMedOjo=vec2(1.5,7.5);\n\tMedCornea=  vec2(0.5,7.5);\n\tfRadioCabeza= 6.5;\n    \n    vec3 hcabezaDer= HacerOjoEnCabeza(p-vec3(-16.0,4.0+3.0*sin(iTime*4.0),0.0), fRadioCabeza,  posOjoA, posCorneaA, MedOjo,  MedCornea);\n    res =opU3(res, hcabezaDer); \n    \n   \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*2.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 5.0, 50.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -15.0, 3.0, -50.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    //vec3 ro=vec3(4.0,2.0,-25.0+t);\n    vec3 ro=vec3(0.0,7.0+2.0*sin(t),-30.0);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 245, 245, 269], [271, 286, 317, 317, 467], [470, 470, 515, 515, 606], [608, 625, 658, 658, 723], [725, 725, 761, 761, 864], [866, 866, 904, 904, 1007], [1010, 1010, 1048, 1048, 1151], [1154, 1154, 1192, 1192, 1295], [1298, 1342, 1388, 1388, 1420], [1422, 1422, 1465, 1465, 1497], [1499, 1499, 1547, 1547, 1580], [1629, 1629, 1659, 1659, 1785], [1826, 1851, 1886, 1886, 1979], [1981, 1981, 2016, 2016, 2109], [2111, 2111, 2145, 2145, 2238], [2242, 2242, 2353, 2353, 4189], [4193, 4193, 4219, 4219, 4273], [4276, 4276, 4310, 4310, 4483], [4486, 4514, 4555, 4555, 4648], [4652, 4652, 4704, 4704, 4948], [4952, 4952, 5019, 5019, 5242], [5245, 5245, 5272, 5272, 5676], [5679, 5679, 5705, 5705, 5932], [5942, 5982, 6007, 6007, 8823], [8827, 8872, 8939, 8939, 9312], [9367, 9367, 9392, 9392, 9632], [9635, 9698, 9733, 9824, 10348], [10407, 10407, 10444, 10444, 10771], [10829, 10900, 10936, 10936, 11142], [11145, 11216, 11240, 11240, 11500], [11550, 11584, 11633, 11633, 11869], [11870, 11904, 11984, 11984, 12625], [12679, 12679, 12772, 12772, 13063], [13066, 13115, 13172, 13172, 14500]]}
{"id": "wljBDG", "name": "CylinderDeform", "author": "Del", "description": "Cylinder Coords Deformation - default = bounding box, mouse button = rounded box", "tags": ["deform", "cylinder"], "likes": 9, "viewed": 372, "published": 3, "date": "1599775641", "time_retrieved": "2024-07-30T20:46:02.942233", "image_code": "// Cylinder Coords example, this might exist elsewhere, I couldn't find one!\n// (this is just a bounding box distance)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nfloat map( in vec3 pos )\n{\n    pos.yz *= rot(iTime*0.2);\n    \n    // Deform Space...\n    float rad =  (1.0/(3.141*2.0)*5.0);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    // bounding box distance using deformed domain\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.1,iTime*1.5))*0.5;\n    float xs = .85 + (size.x);\n    float zs = .65 + (size.y);\n    float ys = .25 + (0.1*size.z);\n    float boff = 0.2;\t\t// bounding box offset\n    float bthick = 0.01;\t// bounding box thickness\n    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick)-0.1;\n    \n    \n    if (iMouse.z>0.5)\n        d1 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff))-0.1;\n    \n    return d1*0.5;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 7.0*cos(an), 4.5, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 167, 167, 455], [457, 457, 488, 488, 575], [577, 577, 598, 598, 666], [669, 669, 695, 695, 1455], [1457, 1503, 1535, 1535, 1773]]}
{"id": "tl2fWG", "name": "Hilbert's Path", "author": "dr2", "description": "The problem is not just drawing the curve (e.g. \"Hilbert Square\"), but indexing the steps", "tags": ["fractal", "hilbert"], "likes": 15, "viewed": 317, "published": 3, "date": "1599775119", "time_retrieved": "2024-07-30T20:46:03.710179", "image_code": "// \"Hilbert's Path\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint gSize;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n// Hilbert indexing - without bit ops\n\nint LoBit (int x)\n{\n  return x - 2 * (x / 2);\n}\n\nint FlipLoBit (int x)\n{\n  return 4 * (x / 2) - x + 1;\n}\n\nconst int maxBits = 6;\n\nint HilXy2D (ivec2 p, int n)\n{\n  ivec2 r;\n  int j, td, d;\n  d = 0;\n  td = 1;\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    td *= 2;\n    j /= 2;\n    if (j == 1) break;\n  }\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    r = ivec2 (LoBit (p.x / td), LoBit (p.y / td));\n    d += j * j * ((r.y == 0) ? 3 * r.x : FlipLoBit (3 * r.x));\n    if (r.y == 0) {\n      if (r.x == 1) p = n - 1 - p;\n      p = p.yx;\n    }\n    td /= 2;\n    j /= 2;\n    if (j == 0) break;\n  }\n  return d;\n}\n\nivec2 HilD2Xy (int d, int n)\n{\n  ivec2 p, r;\n  int j, td;\n  td = d;\n  p = ivec2 (0);\n  j = 1;\n  for (int b = 0; b < maxBits; b ++) {\n    r.x = LoBit (td / 2);\n    r.y = LoBit ((r.x == 0) ? td : FlipLoBit (td));\n    if (r.y == 0) {\n      if (r.x == 1) p = j - 1 - p;\n      p = p.yx;\n    }\n    p += j * r;\n    td /= 4;\n    j *= 2;\n    if (j == n) break;\n  }\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 fq, dq, cq, u, e;\n  float d, h;\n  int hInd;\n  q = p;\n  d = PrBoxDf (q, vec3 (1.02, 0.02, 1.02));\n  if (d < 0.1) {\n    h = smoothstep (0.3, 0.4, length (mod (0.5 * float (gSize) * q.xz, 1.) - 0.5));\n    u = vec2 (1.);\n    e = vec2 (0.2, 0.);\n    fq = floor (float (gSize) * (0.5 * q.xz + 0.5));\n    hInd = HilXy2D (ivec2 (fq), gSize);\n    cq = float (gSize) * (0.5 * q.xz + 0.5) - fq - 0.5;\n    if (hInd > 0) {\n      dq = vec2 (HilD2Xy (hInd - 1, gSize)) - fq;\n      u.x = (dq.y == 0.) ? length (max (abs (vec2 (cq.x - 0.5 * sign (dq.x), cq.y)) - e, 0.)) :\n         length (max (abs (vec2 (cq.x, cq.y - 0.5 * sign (dq.y))) - e.yx, 0.));\n    }\n    if (hInd < gSize * gSize - 1) {\n      dq = vec2 (HilD2Xy (hInd + 1, gSize)) - fq;\n      u.y = (dq.y == 0.) ? length (max (abs (vec2 (cq.x - 0.5 * sign (dq.x), cq.y)) - e, 0.)) :\n         length (max (abs (vec2 (cq.x, cq.y - 0.5 * sign (dq.y))) - e.yx, 0.));\n    }\n    h = -0.007 * min (h, smoothstep (0.05, 0.1, min (u.x, u.y))) * (1. -\n       smoothstep (0.97, 1., max (abs (q.x), abs (q.z))));\n    q.y -= h;\n    d = 0.8 * PrBoxDf (q, vec3 (1.02, 0.02 + h, 1.02));\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, c;\n  vec2 q, fq, dq;\n  float dstObj;\n  int hInd;\n  bool s;\n  gSize = 8;  //(4,8,16,32)\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (1., 0.8, 0.2);\n    if (vn.y > 0.1) {\n      if (ro.y < 0.01) col *= 0.5;\n      q = float (gSize) * (0.5 * ro.xz + 0.5);\n      fq = floor (q);\n      dq = q - fq - 0.5;\n      if (length (dq) < 0.28) {\n        hInd = HilXy2D (ivec2 (fq), gSize);\n        s = (floor (mod (2. * tCur, float (gSize * gSize))) == float (hInd));\n        col = mix ((s ? vec3 (0.3, 0.7, 1.) : col), (s ? vec3 (0.) : vec3 (0., 0.7, 0.)),\n           smoothstep (0.05, 0.1, ShowInt (dq - vec2 (((gSize < 16) ? 0.1 : 0.2), -0.1),\n           (s ? 1.1 : 1.) * vec2 (0.5, 0.2), 4., float (hInd + 1))));\n      }\n    }\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.);\n  zmFac = 5.5;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    if (val < 0.5) sgn = 1.;\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[426, 426, 445, 445, 473], [475, 475, 498, 498, 530], [556, 556, 586, 586, 1054], [1056, 1056, 1086, 1086, 1425], [1427, 1427, 1449, 1449, 2596], [2598, 2598, 2631, 2631, 2815], [2817, 2817, 2838, 2838, 3093], [3095, 3095, 3130, 3130, 4175], [4219, 4219, 4275, 4275, 5233], [5235, 5235, 5267, 5267, 5367], [5369, 5369, 5405, 5405, 5611], [5613, 5613, 5643, 5643, 5756], [5758, 5758, 5781, 5781, 5883], [5956, 5956, 5988, 5988, 6530], [6532, 6532, 6592, 6592, 7170]]}
{"id": "tl2BWG", "name": "Day 264", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 15, "viewed": 452, "published": 3, "date": "1599769771", "time_retrieved": "2024-07-30T20:46:04.678590", "image_code": "\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.7;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n", "buffer_a_code": "// proceed with caution. absolute mess\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\n// ----------\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n    /*\n    if(ss == 0.){\n    \n    \n    } else if(ss == 1.){\n     \troll = r12(frame + 38.);\n    } else if(ss== 2.){\n     \troll = r12(frame - 13. - period*2.);\n    } else if(ss== 3.){\n     \troll = r12(frame + 44. - period*3.);\n    } else if(ss== 4.){\n     \troll = r12(frame - 64.);    \n    } else if(ss== 5.){\n     \troll = r12(frame - 24.);\n    }*/\n     \n    float deb;\n    \n    if (stroke == 0) {\n    \tdeb = smoothstep(df,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        vec4 n = valueNoise(guv,1.);\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08;\n        \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.0;\n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat seed = 0.;\nconst int cnt = 5;\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 325.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\nfloat jaggy(vec2 uv){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    float densitya = 0.;\n    float densityb = 1.;\n    float w = 0.1;\n    \n    uv.x += 0.75;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*200.;\n    \n    df = dFdx(uv.x);\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 c = vec3(0.45,.35,0.25)*2.8;\n    \n    \n    c = vec3(1);\n    vec3 col = iFrame < 2 ? c : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    \n    float id = floor(mod(frame/period,10.));\n    seg = floor(frame/period );\n        \n    if(mod(float(iFrame)*SPEED,1.) < SPEED && frame > 0.){\n    \tvec2 roll = r12(frame + 1.);\n    \n        float a = 0.03;\n        \n        float otd = sdTri(uv,0.3);\n        if(frame < 53.){\n\n        \td = dotwork(uv*rot(0.5*pi), .6, 0.00,1.);\n        \n            d = min(d,length(abs(uv.x) - 0.4) - 0.001);\n\n            \n            \n            d = min(d,abs(uv.y - 0.086 + a));\n            \n            d = max(d,otd);\n\t\t\t\n            \n            d = max(d,-abs(uv.y - 0.086) + a);\n            \n        \tcol = colour( d , col, vec3(0), 0,0,4.,0.);\n           \n        }\n        if(frame == 54.){\n\t    \n        \t\n            \n            float b = sdBox(uv*rot(0.25*pi),vec2(0.4));\n            //d = min(d, abs(b));\n        \n            //d = min(d,abs(-abs(uv.y) + a));\n            d = min(d,abs(sdTri(uv,0.3)));\n\t\t\n            \n            //d = xor(d,abs(sdTri((uv + vec2(0,0.06))*rot(1.*pi),0.3)), 0.04);\n            \n            \n            d = xor(d, max(abs(sdTri((uv + vec2(0,0.01))*rot(1.*pi),0.3)), -otd), -0.0);\n        \n        \n            \n            // horiz\n            //d = xor(d, max(max(length(uv.y),-otd), abs(uv.x) - 0.4),0.03);\n            \n            d = xor(d, sdTri( (uv + vec2(0,0.36))*rot(pi),0.1) ,0.01);\n            \n            \n            d -= 0.001;\n            col = colour( d , col, vec3(0), 0,0,4.,0.);\n           \n            \n            d = 10e4;\n            \n            d = xor(d, max(abs(sdTri((uv - vec2(0,0.18))*rot(1.*pi),0.3)), -otd + 0.04), -0.0);\n           \t\n            col = colour( d , col, vec3(0), 0,3,9.9,0.4);\n           \n            uv.y += 0.005;\n            uv.x = abs(uv.x) - 0.2;\n            \n            //uv = abs(uv);\n            d = 10e5;\n            \n            //d = min(d,jaggy(uv - 0.17));\n            \n            //d = max(d,-otd);\n            \n            uv *= rot(-pi/3.);\n            \n            uv.y += 0.3;\n            //d = min(d,jaggy(uv - 0.17));\n            \n            uv.y += 0.1;\n            uv.x -= 0.1;\n            d = min(d,jaggy(uv - 0.17));\n            \n           \tcol = colour( d - 0.001, col, vec3(0), 0,0,4.,0.);\n           \n             \n            \n            //d = max(d, b);\n        \t//d = max(d, -abs(uv.y) + a);\n        \n            \n            //d = abs(d);\n        }\n        if(frame == 55.){\n        \td = -abs(uv.x) + 0.5;\n            \n           \t//col = colour( d - 0.001, col, vec3(0), 0,3,31.,0.);\n        \n        }\n\t    \n        \n        \n        \n        \n        \n        \n        \n        \n        //d = max(d, length(uv) - 0.2);\n        \n        \n    }\n    \n    \n    col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2BWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 132, 132, 189], [190, 190, 223, 223, 752], [753, 753, 771, 771, 1099], [1102, 1102, 1159, 1159, 2037]]}
{"id": "wljBWG", "name": "Helios Shader Workshop - Day 1", "author": "BackwardsCap", "description": "The result of the first day of my shader workshop I am writing for work.\nIt is going to be a workshop aimed at teaching my coworkers the basics of shaders\nThe goal is to illustrate basic shape drawing, calculating random values, and general shader stuff", "tags": ["helios"], "likes": 4, "viewed": 296, "published": 3, "date": "1599769232", "time_retrieved": "2024-07-30T20:46:05.449529", "image_code": "//smoothstep takes in a value and smoothly interpolates it between 0-1 based on the min and max you supply it\n//here we are using it to smoothly step between 0-1 over the distance of a pixel (calculated by size*3./iResolution.y)\n//this can be applied when drawing shapes to get crisp, anti-aliased edges\n#define SS(U) smoothstep(0.,size*3./iResolution.y,U)\n#define TAU 3.1415927*2.0\n#define size (7.5+(cos(iTime/10.0)*2.5))\n\n//random value based on a vector 2\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12190.5283, 57894.23784)))*(834.2831)+.5);\n}\n\n//rotation matrix\nmat2 rot(float a) //0 through Tau\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//drawing a circle:\n//we have a point in space for the center of our circle\n//we measure the distance from our coordinate to the center of the circle\n//if the distance is greater than the radius, we know we are outside of the circle\n//so we subtract the radius of the circle from the distance we calculated, if we are >0\n//we know we are outside of the circle\nfloat circle(vec2 p, float r)\n{\n    return SS(length(p)-r);\n}\n\nfloat renderCell(vec2 p, float randValue)\n{\n    //start with white\n    float color = 1.0;\n    \n    //every cell has a different random number, so we can fill each cell based on our random number\n    //do random maths to select some cells\n    if(mod(ceil(randValue*10.),4.0)==0.){ //MOVING CIRCLE\n        \n        //calculate a random offset for our circle\n        //based off of time and the random value we generated for our ID\n        vec2 offset = vec2(cos(randValue*iTime*sign(fract(randValue*1293.874)-.5)-randValue*10.0),\n                           sin(randValue*iTime*sign(fract(randValue*12.3)-.5)+randValue*30.0))/4.0;\n        \n        //draw a circle with a random offset between 0.01 and 0.3\n        color*=circle(p+offset,mix(0.01,0.3,randValue));\n    }\n    else if(mod(ceil(randValue*3.0),2.0)==0.){//ROTATING LINE\n        //rotate our coordinate space by using the rotation matrix and randomize the rotation based on time and our randValue\n        vec2 ruv = p*rot(3.1415927*2.0+randValue*iTime*sign(randValue-.5));\n        \n        //with the circle, we were measuring the x and the y components in our distance from one point to another\n        //if we just measure in the X or the Y axis, then we can draw a line by subtracting half of the width of the line\n        //and if we are > 0, we are outside of the line\n        color*=(SS(length(ruv.x)-.1));\n    }\n    else if(mod(floor(randValue*52.8),2.0)==0.)//SWIRL\n    {   \n        //calculate the polar coordinate space by using atan, the y value is measured by the distance from the center\n        vec2 puv = vec2(atan(p.x,p.y),length(p));\n        \n        //when we move the x axis, our texture rotates around the center of the coordinate space\n        puv.x+=(randValue+.25)*iTime*sign(randValue*10.0);\n        \n        //if we offset the x coordinate space by the y coordinate space, then we get the swirly look\n        //(remember y goes up as we go away from the center of the coordinate space\n\t\tcolor*=((cos((puv.x-puv.y*cos(randValue*10.0)*20.0)*2.0)));\n    }else{//SQUARE\n        //rotate our space randomly\n        vec2 ruv = p*rot(TAU*randValue+randValue*iTime*sign(randValue-.96));\n        \n        //drawing a square is the same thing as drawing a line in the X and Y directions and then taking the space that overlaps\n        color*= (1.0-((1.0-SS(length(ruv.y)-.1))*(1.0-SS(length(ruv.x)-.1))));\n    }\n    \n    //make sure we don't go above 1.0 (causes anti-aliasing and artifacts in some instances)\n    return min(color,1.0);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*f-iResolution.xy)/iResolution.y;\n    \n    //scale up our coordinates, store the scaling for anti-aliasing our smoothstep\n    p*=size;\n    \n    vec2 id = floor(p);\n    \n    //our coordinates from -.5-.5 in each cell\n    p=fract(p)-.5;\n    \n    //get a random value based on our ID\n    float randValue = rand(id);\n    \n    //set the base color of our cell based on the random value, make sure we dont set it black\n    vec3 col = max(vec3(.1),vec3(randValue));\n    \n    //renderCell will return 0-1 based on our random shape math and the random value we pass it\n    //if we multiply our color by it, we can draw shapes while maintaining the base color that we set in the line above\n    col*=renderCell(p, randValue);\n    \n    // Output to screen and add the border effect to each cell\n    c.rgb = col -(randValue*20.)*(pow(abs(p.x),5.0)+pow(abs(p.y),5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 460, 480, 480, 561], [563, 581, 616, 616, 682], [684, 1044, 1075, 1075, 1105], [1107, 1107, 1150, 1173, 3617], [3619, 3619, 3660, 3711, 4585]]}
{"id": "wtXfDB", "name": "GLSL-NICCC 2000", "author": "Flyguy", "description": "Parses & displays the data file from the \"ST-NICCC 2000\" Atari-ST demo by Oxygene.\nCheats using a custom texture to load the 640kB data file, see the code comments for details on how to load it.\n", "tags": ["demo", "polygon", "ngon", "niccc"], "likes": 9, "viewed": 685, "published": 3, "date": "1599766782", "time_retrieved": "2024-07-30T20:46:06.414948", "image_code": "/*\n\nParses & displays the data file from the \"ST-NICCC 2000\" Atari-ST demo by Oxygene.\nThe data is packed into an RGBA texture to load it into the shader but is otherwise unmodified.\n\nDetails on the data file format:\nhttp://arsantica-online.com/st-niccc-competition/\n\nOriginal ST demo:\nhttps://www.youtube.com/watch?v=nqVJWFNpTqA\nhttp://www.pouet.net/prod.php?which=1251\n\nTo load the data file, do the following:\n1) Copy the following:\n\ngShaderToy.SetTexture(1, {\nmSrc:'https://media.discordapp.net/attachments/744639380035076208/744639443398426644/scene1.png', \nmType:'texture', mID:1,\nmSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }\n});\n\n2) Go to the \"Buffer A\" tab.\n3) Open the developer console in your browser. (Ctrl+Shift+J Chrome, Ctrl+Shift+K Firefox)\n4) Paste what your copied and hit Enter.\n5) Reset the shader.\n\n*/\n\n/*\nDebug bar graphs\nColumn 0 -> Palette\nColumn 1 -> Vertex count (mark every 20 vertices)\nColumn 2 -> Polygon count (mark every 10 vertices)\nColumn 3 -> Average # of vertices per polygon (mark every 1 vertex, min 3/max 15) \n*/\n#define DEBUG 0\n#define WIREFRAME 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord - vec2((iResolution.x - (4.0*iResolution.y/3.0))/2.0,0);\n    pos /= (iResolution.y*vec2(4.0/3.0,1));\n    \n    //Get frame state (vertex count & polygon count).\n    vec4 state = texelFetch(iChannel0, idx2uv(STATE_PTR, DECODE_RES.x),0);\n    int vert_count = int(state.z);\n    int poly_count = int(state.a);\n\n    int poly_vert_ptr = VERTEX_PTR;\n    vec3 col = vec3(0,0,0);\n\tfloat d = 1e6;\n    \n    for(int i = 0;i < poly_count;i++)\n    {\n        //Get first vertex, color, and # of vertices.\n        vec4 vtx0 = texelFetch(iChannel0, idx2uv(poly_vert_ptr, DECODE_RES.x), 0);\n        vec3 poly_col = STtoRGB(int(vtx0.z));\n        int poly_vert_count = int(vtx0.w);\n\t\t\n        //Even-Odd / Raycasting N-gon filler\n        int n = 0; //Number of intersections\n        vec2 p0 = vtx0.xy; //First vertex of edge\n        for(int j = 1;j <= poly_vert_count;j++)\n        {\n            //Second vertex of edge (wraps back to first vertex to close the polygon).\n            int vert_offs = j % poly_vert_count;\n            vec2 p1 = texelFetch(iChannel0, idx2uv(poly_vert_ptr + vert_offs, DECODE_RES.x), 0).xy;\n            \n            //Bounding box of edge\n            vec2 bb_mins = min(p0, p1);\n            vec2 bb_maxs = max(p0, p1);           \n\t\t\t\n            //If pos.y is outside Y min/max, ray cannot intersect.\n            //If pos.x is less than X minimum, ray cannot intersect.\n            if(pos.y >= bb_mins.y && pos.y < bb_maxs.y && pos.x >= bb_mins.x)\n            {\n                //If pos.x is greater than X maximum, ray intersected.\n                if(pos.x >= bb_maxs.x)\n                {\n                    n++;\n                }\n                else //pos.xy is inside the edge bounds, check intersection with line. \n                {\n                    float slope = (p1.x - p0.x)/(p1.y - p0.y);\n                    n += int(pos.x-p0.x > (pos.y-p0.y)*slope);\n                }\n            }\n\t\t\t\n            #if(WIREFRAME == 1)\n            d = min(d,dfLine(p0,p1,pos));\n            #endif\n            \n            p0 = p1;\n        }\n\n        poly_vert_ptr += poly_vert_count;\n\n        col = mix(col, poly_col, float(n & 1)); //Mix in polygon color if n is odd.\n    }\n    \n    fragColor = vec4(col,1);\n    \n    #if(WIREFRAME == 1)\n    \tfloat ps = 1.0/iResolution.y;\n    \tfragColor *= 1.-smoothstep(1.0*ps,0.,d);\n    #endif\n\t\n    #if(DEBUG == 1)\n    \tvec2 uv = fragCoord.xy/iResolution.xy;\n    \tfloat bar = floor(uv.x/0.03);\n       \tif(bar == 0.0)\n        {\n            int pal_idx = int(floor(uv.y*16.0));\n        \tfragColor.rgb = texelFetch(iChannel0,idx2uv(PALETTE_PTR+pal_idx, DECODE_RES.x),0).rgb;   \n        }\n    \tif(bar == 1.0)\n        {\n            float marks = float(MAX_VERTICES)/20.0;\n        \tfragColor.r = 1.-step(float(vert_count)/float(MAX_VERTICES), uv.y);\n            fragColor.r *= smoothstep(0.0,0.3,abs(sin(3.14159*uv.y*marks)));\n        }\n    \tif(bar == 2.0)\n        {\n            float marks = float(MAX_POLYS)/10.0;\n        \tfragColor.g = 1.-step(float(poly_count)/float(MAX_POLYS), uv.y);\n            fragColor.g *= smoothstep(0.0,0.3,abs(sin(3.14159*uv.y*marks)));\n        }\n        if(bar == 3.0)\n        {\n            float marks = 15.0; //Max # of vertices per poly (4-bit, 1111).\n        \tfragColor.b = 1.-step(float(vert_count)/float(poly_count)/15.0, uv.y);\n            fragColor.b *= smoothstep(0.0,0.2,abs(sin(3.14159*uv.y*marks)));\n        }\n\n    #endif\n    //Print \"Load Data File\" message if data file isn't loaded.\n    //Check if texture width is > 1 (passed from Buf A in y at 0,0).\n    if(state.y <= 1.)\n    {\n        ivec4 message = ivec4(0x4C6F6164,0x20446174,0x61204669,0x6C650000);\n        vec2 uv = fragCoord.xy/iResolution.y;\n        uv.x -= (iResolution.x/iResolution.y - StrSize(message).x)/2.;\n    \tfragColor += PrintStr(message,iChannel2, uv).rrrr;   \n    }\n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_POLYS 256\n#define MAX_VERTICES 640\n#define PALETTE_SIZE 16\n#define END_OF_FRAME 0xFF\n#define END_OF_BLOCK 0xFE\n#define END_OF_STREAM 0xFD\n\n#define DECODE_RES ivec2(32, 32)\n#define STATE_PTR 0\n#define PALETTE_PTR (STATE_PTR + 1)\n#define VERTEX_PTR (PALETTE_PTR + PALETTE_SIZE)\n#define MAX_ADDR (VERTEX_PTR + MAX_VERTICES)\n\n//1st frame from the demo for the thumbnail.\nint thumbnail[] = int[](\n    0x077F8005,0x200FF006,0x3004100F,0x50074003,0x000FFFD8,0xE352F058,0xEE53EC58,0xEE5AEA5A,0xEF60F665,0xF460F165, \n    0xF467EF67,0xF66FFE75,0xFB6FD35D,0xCF51C950,0xBB5ABF57,0xB957B55A,0xF479FB77,0xEE77E779,0xDF53DA56,0xDC66D661, \n    0xD551D152,0xB14EC055,0xBF4FBA54,0xF275D779,0xDE77D365,0xCD67DF79,0xE577BE68,0xC365BD65,0xB868E775,0xDA51BC5D, \n    0xC463C25E,0x98579B54,0x98539657,0xE175CB79,0xD177C551,0xC154D379,0xD977BE63,0x9E51A552,0xA14E9A4B,0x995F9D5B, \n    0xA35FA75C,0x9950934D,0xD575DB75,0x9F59A859,0x90508E52,0x914EC16E,0xCA75C86E,0xC379C977,0xB777B279,0xAE4FAA52, \n    0xA95F9E5F,0xA1639C66,0x9F639B5F,0x9F669C71,0xA06F9B68,0xBA75765E,0x785B7A4B,0x794FA279,0xA577A474,0xA076A879, \n    0xAC778E71,0x916E8B56,0xAD75A36F,0xA671A875,0x9E6F9378,0x97769C7A,0xA078936C,0xA2767168,0x72656949,0x684E514C, \n    0x50475253,0x5257785F,0x7C4A744A,0x74497A78,0x76787179,0x7D797877,0x77777E64,0x854C844A,0x7E669974,0x604D6049, \n    0x5B5B5B5F,0x74636B48,0x7A777F77,0x5F475959,0x56465157,0x56484E46,0x72777677,0x2A50274C,0x234B2650,0x505B3046, \n    0x2E44334C,0x364E4658,0x455A4445,0x43467474,0x7E752648,0x25412048,0x1A426179,0x61775377,0x54795F74,0x51675064, \n    0x4B774D79,0x11493852,0x306C336F,0x54743C77,0x3E794974,0x2D6A1A6D,0x1E703D74,0x26762A79,0x1E6C1978,0x1E7B2474, \n    0x166C0C76,0x12790669,0x17750A74,0x23000102,0x23030100,0x34040103,0x05230607,0x08230907,0x06340A07,0x090B230C, \n    0x0D0E230F,0x10114412,0x13141574,0x16171819,0x4419181A,0x1B230F1C,0x10441D1C,0x1E1F2320,0x21222323,0x21204413, \n    0x21231423,0x03002423,0x06032423,0x09062423,0x0C092423,0x0C240D44,0x170D2418,0x34182400,0x1A442526,0x27287429, \n    0x2A262544,0x2B2C2D2E,0x232F1E1C,0x231E2F30,0x23313233,0x44343536,0x3723382F,0x1C230F38,0x1C342638,0x0F27442A, \n    0x2F382644,0x393A3B3C,0x743D3E3A,0x39233F32,0x31442C32,0x3F2D2340,0x41422340,0x42434444,0x45353444,0x46474544, \n    0x23484043,0x23484349,0x44354048,0x36230F11,0x4A343A4A,0x113B443E,0x4B4A3A23,0x0F4A4B23,0x404C4114,0x454C4035, \n    0x44474D4C,0x4523414C,0x4D234849,0x4E344F4E,0x49502351,0x52537454,0x55565744,0x57565859,0x235A5B5C,0x145D5E5B, \n    0x5F44605C,0x5E5D235C,0x5B5E4461,0x62606323,0x23206423,0x31236423,0x3F316423,0x513F6423,0x51645244,0x55526456, \n    0x34566420,0x58446566,0x67684469,0x6A6B6C74,0x6D6E6A69,0x446F704F,0x7123725A,0x5C146273,0x5C602374,0x5C732375, \n    0x725C2374,0x755C446A,0x75746B44,0x6E72756A,0x2376484E,0x74777870,0x6F44797A,0x78772376,0x4E7B1470,0x7B4E4F23, \n    0x7C747323,0x7C737634,0x6B747C7A,0x447D7E7F,0x80148182,0x83843466,0x85866754,0x87888566,0x14898A8B,0x8C348D8E, \n    0x8A89238F,0x86855490,0x918F9223,0x868F9123,0x937C7623,0x93767B44,0x78937B70,0x147A7C93,0x78149495,0x96972385, \n    0x88982398,0x8F85347E,0x98997F23,0x98889944,0x9A898C9B,0x54959C9D,0x96239E9D,0x9C239D9E,0x9F34839F,0x9EA05482, \n    0xA19F8374,0x8BA27E7D,0x448AA3A2,0x8B44A4A5,0xA6A723A8,0x9D9F84A9,0xAAABAC23,0x9FA1AD23,0xA89FAD34,0xAEADAFB0, \n    0x23ADA1AF,0x2398B18F,0x14A2B198,0x7E449BB2,0xB1A2238F,0xB1B223B3,0xABAA23B3,0xAAB423B5,0xB3B423B5,0xB4B634A5, \n    0xB3B5A674,0xB7B8B9BA,0x64969DBB,0xB844BCBD,0xBEBF23C0,0xB5B634C1,0xACC2C323,0xA8C49D14,0xB9C4A8BD,0x44B8BBC4, \n    0xB9239DC4,0xBB74BFBE,0xC5C623AD,0xC7A864BD,0xA8C7BE54,0xACABC8C2,0x44A7A6C9,0xCA14C5CB,0xADAE44BE,0xC7CBC523, \n    0xC7ADCB14,0xC3C2CCCD,0x23B3CEAB,0x23C8ABCE,0x14CDCCCF,0xD023D1C8,0xCE64C2C8,0xD1CC23C0,0xD2B554A6,0xB5D2C944, \n    0xD0CFD3D4,0x23C0D5D2,0x23D6D1CE,0x34CCD1D6,0xCF23D7D6,0xCE23D7CE,0xD223D5D7,0xD214CFD6,0xD7D3FD00,0x00000000 \n);\n\n//Misc utility functions\n\n//Linear address to 2D coordinate.\nivec2 idx2uv(int idx, int width)\n{ \n    return ivec2(idx % width, idx / width);\n}\n\n//2D coordinate to linear address.\nint uv2idx(ivec2 uv, int width)\n{\n\treturn uv.x + uv.y*width;    \n}\n\n//Check if bit 'b' is set in value 'v'.\nbool bitSet(int v, int b)\n{\n    return ((v>>b)&1) == 1;\n}\n\n//High 4 bits of a byte 'v'.\nint hiNibble(int v)\n{\n    return (v >> 4) & 0x0F;\n}\n\n//Low 4 bits of a byte 'v'.\nint loNibble(int v)\n{\n    return v & 0x0F;\n}\n\n//Convert 16-bit Atari-ST color format to normalized RGB vector.\nvec3 STtoRGB(int STcol)\n{\n    //00000RRR0GGG0BBB\n    return vec3((ivec3(STcol) >> ivec3(8,4,0)) & 0x7) / 7.0;\n}\n\n//Distance to line segment p0,p1 from point p \nfloat dfLine(vec2 p0, vec2 p1, vec2 p)\n{  \n\tvec2 line = p1 - p0;\n\tfloat frac = dot(p - p0,line) / dot(line,line);\n\treturn distance(p0 + line * clamp(frac, 0.0, 1.0), p);\n}\n\n//Sting printing functions\n\n//Constants\n#define CHARS_PER_IVEC4 16\n#define FONT_COLUMNS 16.0\n\n//Special characters\n#define NUL 0x00\n#define LF 0x0A\n#define SPACE 0x20\n\nvec2 charSize = vec2(0.090, 0.2);\n\n/*\nReturns the specified byte in an ivec4 (16 max)\nIndex is from left to right as typed.\ni: 0..                                  ..15\n  /|                                     /|\n0x00112233,0x44556677,0x8899AABB,0xCCDDEEFF\n*/\n\nint ivec4byte(ivec4 v4, int i)\n{\n    return (v4[i/4] >> 8*(3 - i%4)) & 0xFF;\n}\n\n//Ascii code to uv coord in the font texture.\nvec2 AsciiToUV(int ascii)\n{\n\treturn vec2(ascii & 0x0F,int(FONT_COLUMNS-1.0) - (ascii >> 4))/FONT_COLUMNS;   \n}\n\n//Return the max width/height of the string.\nvec2 StrSize(ivec4 str)\n{\n    int maxw = 0;\n    ivec2 cursor = ivec2(0);\n    \n\tfor(int i = 0;i < CHARS_PER_IVEC4;i++)\n    {\n        int char = ivec4byte(str,i); \n        \n        if(char == NUL){ break; }\n        if(char == LF)\n        {   \n            maxw = (cursor.x > maxw) ? cursor.x : maxw;   \n            cursor.x = 0;\n        \tcursor.y--;  \n        }\n        else\n        {\n        \tcursor.x++; \n            maxw = (cursor.x > maxw) ? cursor.x : maxw; \n        } \t   \n    }\n    \n    return vec2(maxw, -cursor.y+1) * charSize;\n}\n\n//Prints a null-terminated 16 character string.\nvec4 PrintStr(ivec4 str, sampler2D font, inout vec2 uv)\n{\n\tivec2 grid = ivec2(floor(uv / charSize)); //Pixel location on char grid\n    ivec2 cursor = ivec2(0); //Grid location of the printed char\n    vec2 chuv = fract(uv / charSize)/(charSize.y/charSize); //Char local UVs \n    chuv.x += (charSize.y-charSize.x)/charSize.y / 2.; //Center char in cell\n    vec2 choffs = AsciiToUV(SPACE);\n    \n    for(int i = 0;i < CHARS_PER_IVEC4;i++)\n    {\n        int char = ivec4byte(str,i);\n        \n        if(char == NUL){ break; } //Stop at NUL (0x00)\n        if(char == LF) //New line on line-feed (0x0A)\n        {\n            cursor.x = 0;\n        \tcursor.y--;   \n        }\n        else\n        {  \n            if(cursor == grid)\n            {\n                choffs = AsciiToUV(char);\n            }\n            \n        \tcursor.x++; \n        }\n    }\n    \n    //Set UVs to end of string (allow chaining of prints)\n    uv -= vec2(cursor)*charSize; \n    \n\treturn textureLod(font, (chuv/FONT_COLUMNS)+choffs, 0.0);   \n}", "buffer_a_code": "/*\n\nParser\n\nExtracts the vertices, polygons, and palette colors from the data file\nand outputs them in a simplified format for rendering.\n\nTo load the data file do the following:\n1) Copy the following:\n\ngShaderToy.SetTexture(1, \n{mSrc:'https://media.discordapp.net/attachments/744639380035076208/744639443398426644/scene1.png', \nmType:'texture', mID:1,\nmSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n2) Go to the \"Buffer A\" tab.\n3) Open the developer console in your browser.\n4) Paste what your copied and hit Enter.\n5) Reset the shader.\n\n*/\n\n//Read an 8-bit byte and increment the pointer.\n//Texture has 4 bytes/pixel, the pixel is cached to reduce texture reads.\nvec4 cache = vec4(0);\nint cache_loc = -1;\nint readByte(inout int ptr)\n{\n    if(textureSize(iChannel1,0).x > 1) //If the data file texture is loaded, read from it.\n    {\n        int px_ptr = ptr/4;\n        if(px_ptr != cache_loc)\n        {\n            cache = texelFetch(iChannel1,ivec2(px_ptr%512,px_ptr/512),0);\n            cache_loc = px_ptr;\n        }\n\n        int val = int(cache[ptr % 4]*255.0);\n        ptr++;\n        return val;\n    }\n    else //If the data file texture is not loaded, read the thumbnail data. \n    {\n        int tmp_ptr = ptr;\n        ptr++;\n        return (thumbnail[tmp_ptr/4] >> (3-(tmp_ptr%4))*8 ) & 0xFF;\n    }\n}\n\n//Read a 16-bit big-endian word and increment the pointer.\nint readWord(inout int addr)\n{\n    int hi = readByte(addr);\n    int lo = readByte(addr);\n    return hi*256 + lo;\n}\n\n//Decoder\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(any(greaterThanEqual(ivec2(fragCoord),DECODE_RES)))\n    {\n        fragColor = vec4(0); \n        return; \n    }\n    \n    //Linear address of the current pixel.\n    int pixel_addr = uv2idx(ivec2(fragCoord), DECODE_RES.x);\n\n    //Read data pointer data back from previous frame.\n    int data_ptr = int(texelFetch(iChannel0, idx2uv(STATE_PTR, DECODE_RES.x), 0).x);\n\t\n    //Read palette back from previous frame.\n    int palette[PALETTE_SIZE];\n    for(int i = 0;i < PALETTE_SIZE;i++)\n    {\n        palette[i] = int(texelFetch(iChannel0, idx2uv(PALETTE_PTR+i, DECODE_RES.x), 0).a);\n    }\n\n    //Read frame flags\n    int flags = readByte(data_ptr);\n    bool clear   = bitSet(flags, 0);\n    bool paldata = bitSet(flags, 1);\n    bool indexed = bitSet(flags, 2);\n\n    //If there's palette data, read the bitmask.\n    //If the bit corresponding to a color in the palette is set, update that color.\n    //Bitmask is in reverse order (i.e. bit 0 -> color 15).\n    if(paldata)\n    {\n        int bitmask = readWord(data_ptr);\n        for(int i = 0;i < PALETTE_SIZE;i++)\n        {\n            if(bitSet(bitmask, PALETTE_SIZE-1-i))\n            {\n                palette[i] = readWord(data_ptr);\n            }\n        }\n    }\n\n    int total_polys = 0;\n    int total_verts = 0;\n    int vert_buf_ptr = 0;\n    vec4 vert_out = vec4(0);\n\n    //If indexed mode, save pointer to vertex buffer & skip to polygons.\n    if(indexed) \n    {\n        int vtx_buf_size = readByte(data_ptr);\n        vert_buf_ptr = data_ptr;\n        data_ptr += vtx_buf_size*2; //2 bytes per vertex.\n    }\n\n    for(int i = 0;i < MAX_POLYS;i++)\n    {\n        int poly_desc = readByte(data_ptr);\n        int poly_pal_index = hiNibble(poly_desc);\n        int poly_vert_count = loNibble(poly_desc);\n\n        //Goto next frame.\n        if(poly_desc == END_OF_FRAME ){ break; }\n        //Goto next frame in next 64k block.\n        if(poly_desc == END_OF_BLOCK ){ data_ptr = (data_ptr&0xFFFF0000)+0x10000; break; }\n        //End of the demo (restart).\n        if(poly_desc == END_OF_STREAM){ data_ptr = 0; break;}\n\t\t\n\t\t//Offset of the current vertex from the data pointer.\n        int vert_offset = pixel_addr - (VERTEX_PTR + total_verts);\n        \n        //Copy polygon vertices from data file in parallel (based on pixel address). \n        if(vert_offset >= 0 && vert_offset < poly_vert_count)\n        {\n            if(indexed) \n            {\n                int tmp_ptr = data_ptr + vert_offset; //1 byte per vertex index\n                int vtx_ptr = vert_buf_ptr + readByte(tmp_ptr)*2;\n                \n                vert_out = vec4(\n                    readByte(vtx_ptr),\n                    readByte(vtx_ptr), \n                    poly_pal_index,\n                    poly_vert_count\n                );\n            }\n            else\n            {\n                int tmp_ptr = data_ptr + vert_offset*2; //2 bytes per vertex (non-indexed).\n                \n                vert_out = vec4(\n                    readByte(tmp_ptr),\n                    readByte(tmp_ptr),\n                    poly_pal_index,\n                    poly_vert_count\n                );\n            }\n        }\n        \n        //Increment data pointer based on # of vertices.\n        data_ptr += indexed ? poly_vert_count : poly_vert_count*2;\n        \n        //Increment total # of vertices / polygons.\n        total_verts += poly_vert_count;\n        total_polys++;\n    }\n\t\n    //Save palette for next frame\n    if(pixel_addr >= PALETTE_PTR && pixel_addr < PALETTE_PTR + PALETTE_SIZE)\n    {\n        int st_col = palette[pixel_addr - PALETTE_PTR];\n        \n        fragColor = vec4(STtoRGB(st_col), st_col);\n        return;\n    }\n\t\n    //Save frame state\n    if(pixel_addr == STATE_PTR)\n    {\n        fragColor = vec4(\n            data_ptr, //Save data pointer for next frame.\n            textureSize(iChannel1,0).x, //Save data file texture width to detect when it's loaded.\n            total_verts, //Save total # of vertices in frame.\n            total_polys //Save total number of polygons in frame.\n        );\n        return;\n    }\n\t\n    //Save vertices\n    if(pixel_addr >= VERTEX_PTR && pixel_addr < MAX_ADDR)\n    {\n        vert_out.xy /= vec2(255,199); //Normalize vertex locations.\n        vert_out.y = 1.0 - vert_out.y; //Flip Y axis.\n        vert_out.z = float(palette[int(vert_out.z)]); //Get palette color\n        \n\t\tfragColor = vert_out;\n        return;\n    }\n    \n    //Initialize to 0\n    if(iFrame == 0){ fragColor = vec4(0); }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1134, 1134, 1191, 1191, 5042]]}
{"id": "ttjBWG", "name": "3!=3, 6!=6, 7!=7 on iMac ?!", "author": "GregRostami", "description": "This is a follow up to my \"3 not equal 3\" shader.\nPlease let me know if you see two different shades of grey on the left and right of your screen.\nThe right side is correct - I've posted a screen shot in comments so you can see the problem on my iMac.", "tags": ["glslbug", "imac"], "likes": 0, "viewed": 307, "published": 3, "date": "1599766063", "time_retrieved": "2024-07-30T20:46:07.176910", "image_code": "// On my iMac, the left side is brighter than the right side (see attached image in comments)\n// The right side is the correct value that is supposed to be there.\n\n// This is a follow up to my previous shader (3 not equal 3)\n// It looks like \"3\" isn't the only problem number ... 6 and 7 have problems also!\n\n// iq, Fabrice and ollj have already remarked on the differences in precision between\n// the CPU and the GPU which causes the loop to fail.\n// But there's a dramatic difference between the two sides!?\n// The loss in precision would have to be very high for the loop to fail.\n\nvoid mainImage( out vec4 fragColor, vec2 u )\n{\n    fragColor = vec4(0.0);    // Initialize fragColor to 0.0 \n    u /= iResolution.xy;  // Normalize u (0 to 1)\n    float s;\n    \n    float A = 3.0,  // Here are the numbers that I found have a problem on my iMac\n          B = 6.0,\n          C = 7.0;\n    \n    if   ( u.y > 2.0/3.0 )\n         u.x >.5 ? s = 1.0/3.0 : s = 1.0/A;  // Isn't A = 3.0 ?? This should make the loop iterate 3 times.\n    \n    else if ( u.y > 1.0/3.0 )\n         u.x >.5 ? s = 1.0/6.0 : s = 1.0/B;  // Isn't B = 6.0 ?? This should make the loop iterate 6 times.\n    \n    else u.x >.5 ? s = 1.0/7.0 : s = 1.0/C;  // Isn't C = 7.0 ?? This should make the loop iterate 7 times.\n    \n    for ( float i = 0.0; i < 1.0; i += s ) fragColor += 0.1;  // Add 0.1 to fragColor several times\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 631, 631, 1385]]}
{"id": "3dsBD4", "name": "Area Lights", "author": "piyushslayer", "description": "Area lights (sphere, line and rectangle) using the most representative point method. ", "tags": ["procedural", "brdf", "arealight", "ibl", "pbr", "ggx"], "likes": 37, "viewed": 1494, "published": 3, "date": "1599756907", "time_retrieved": "2024-07-30T20:46:08.272980", "image_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* My implementation of 3 types of real-time area light sources (sphere, line, and rectangle).\n* See Buffer A for more details.\n*\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // for yucky color banding artifacts\n    col += hash12(fragCoord * iResolution.xy + vec2(iFrame)) * .00392;\n    fragColor = vec4(pow(col, vec3(.4545)), 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* Contains all the helper functions used by Buffer A for the area lights.\n*\n*/\n\n#define saturate(x) clamp(x, 0., 1.)\n#define dot2(x) dot(x, x)\n\n#define EPS .0002\n#define SMOL_EPS .0000002\n\n#define PI 3.1415926535\n#define TWO_PI 6.283185307\n#define PI_INV .3183098861\n\n#define DRAW_LIGHTS\n\n// enable/disable these for floor normal map and roughness\n#define FLOOR_DISPLACEMENT\n#define FLOOR_ROUGHNESS\n\n#define T (iTime * .25)\n\n#define SPHERE_LIGHT_POS vec3(9. * cos(T), 6. * abs(sin(T)) \\\n\t\t- .75 + SPHERE_LIGHT_RADIUS, 1.)\n#define SPHERE_LIGHT_RADIUS (sin(T) * .5 + .7)\n#define SPHERE_LIGHT_VOLUME_RADIUS 20.\n#define SPHERE_LIGHT_INTENSITY 256.\n            \n#define LINE_LIGHT_RADIUS (sin(T) * .075 + .125)\n#define LINE_LIGHT_VOLUME_RADIUS 20.\n#define LINE_LIGHT_INTENSITY 512.\n            \n#define RECT_LIGHT_RADIUS 4.\n#define RECT_LIGHT_INTENSITY 64.\n            \n#define LIGHT_COLOR vec3(1., .6, .3)\n            \n#define SPHERE_ALBEDO vec3(.2, .01, .6)\n#define REFLECTION_STEPS 8\n            \n#define SILVER_F0 vec3(.95, .93, .88)\n#define PLASTIC_F0 vec3(.05)\n\n#define CAMERA_POS vec3(0., 9., 21.)\n#define CAMERA_FAR 100.\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n    \nstruct Rect\n{\n\tvec3 center, a, b, c, d; \n\tvec3 up, right, front;\n    vec2 halfSize;\n};\n    \nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1. / float(0xffffffffU));\n}\n\nmat3 rotZ(float a)\n{\n\treturn mat3(cos(a), -sin(a), 0.,\n                sin(a),  cos(a), 0.,\n                \t0., \t 0., 1.);\n}\n\nvec3 rotateAround(vec3 v, vec3 k, float theta)\n{\n  return v * cos(theta) + cross(k, v) * sin(theta) + k * dot(k, v) * (1. - cos(theta));\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = CAMERA_POS;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, 2.5));\n    return Ray(origin, direction);\n}\n\nvoid initRect(out Rect rect, float t)\n{\n    rect.up = vec3(0., 0., 1.);\n    rect.right = vec3(1., 0., 0.);\n    rect.front = normalize(cross(rect.right, rect.up));\n    vec2 widthScale = vec2(cos(t), sin(t)) * .25 + .75;\n    rect.halfSize = vec2(2.5, 1.5) * widthScale;\n    \n    rect.center = vec3(0., 6., sin(t) * 4. - 1.5);\n    \n    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n}\n\n\n// Based on the technique in EA's frostbite engine\nfloat rectSolidAngle(vec3 p, vec3 v0, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 n0 = normalize(cross(v0, v1));\n    vec3 n1 = normalize(cross(v1, v2));\n    vec3 n2 = normalize(cross(v2, v3));\n    vec3 n3 = normalize(cross(v3, v0));\n    \n    float g0 = acos(dot(-n0, n1));\n\tfloat g1 = acos(dot(-n1, n2));\n\tfloat g2 = acos(dot(-n2, n3));\n\tfloat g3 = acos(dot(-n3, n0));\n    \n    return g0 + g1 + g2 + g3 - 2. * PI;\n}\n", "buffer_a_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* My implementation of 3 types of area light sources (sphere, line, and rectangle). Based on most \n* representative point techniques by Brian Karis (Epic) and Sébastien Lagarde (Unity). The general\n* idea is to calculate the location of a point light on the surface of the light source and use that\n* point as the light direction to calculate the diffuse and specular components of the area light. \n*\n* https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n*\n*/\n\nvec3 lineStart, lineEnd;\nRect rect;\n\nvec2 sdUnion(vec2 a, vec2 b)\n{\n \treturn a.x < b.x ? a : b;  \n}\n\nfloat sdPlane(vec3 pos, float height)\n{\n\tfloat plane = pos.y - height;\n#ifdef FLOOR_DISPLACEMENT\n    return plane - textureLod(iChannel0, pos.xz * .04, 0.).r * .01;   \n#else\n    return plane;\n#endif\n}\n\nfloat sdPlaneNoDisplacement(vec3 pos, float height)\n{\n\treturn pos.y - height;\n}\n\nfloat sdSphere(vec3 position, vec3 center, float radius)\n{\n\treturn length(position - center) - radius;   \n}\n\nfloat sdCapsule(vec3 position, vec3 start, vec3 end, float radius)\n{\n    vec3 pa = position - start, ba = end - start;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    return length(pa - ba * h) - radius;\n}\n\nfloat sdRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross(ba, ad);\n\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(dc, nor), pc)) +\n         sign(dot(cross(ad, nor), pd)) < 3.)\n\n        ?\n\n        min(min(min(\n\t\tdot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa),\n\t\tdot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)),\n\t\tdot2(dc * clamp(dot(dc, pc) / dot2(dc), 0., 1.) - pc)),\n\t\tdot2(ad * clamp(dot(ad, pd) / dot2(ad), 0., 1.) - pd))\n        \n        :\n        \n        dot(nor, pa) * dot(nor, pa) / dot2(nor) \n    );\n}\n\nvec2 sdScene(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlaneNoDisplacement(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75,0.), 1.5), 1.25));\n    \n\tresult = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n\n#ifdef DRAW_LIGHTS\n\tresult = sdUnion(result, vec2(sdSphere(pos, SPHERE_LIGHT_POS, SPHERE_LIGHT_RADIUS),\n                                  0.));\n    \n    result = sdUnion(result, vec2(sdCapsule(pos, lineStart, lineEnd, \n                                          LINE_LIGHT_RADIUS), 0.));\n    \n    result = sdUnion(result, vec2(sdRect(pos, rect.a, rect.b, rect.c, rect.d), 0.));\n#endif\n    \n    return result;\n}\n\nvec2 sdSceneNormal(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlane(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75, 0.), 1.5), 1.25));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n    \n    return result;\n}\n\nvec2 sdSceneNoLights(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlaneNoDisplacement(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75, 0.), 1.5), 1.25));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n    \n    return result;\n}\n\nvec3 calculateNormal(vec3 pos)\n{\n\tvec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(sdSceneNormal(pos + eps.xyy).x, \n                          sdSceneNormal(pos + eps.yxy).x, \n                          sdSceneNormal(pos + eps.yyx).x) \n                     - sdSceneNormal(pos).x);\n}\n\nvec2 rayMarch(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 128; ++i)\n    {  \n        result = sdScene(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= CAMERA_FAR) break;\n        dist += result.x;\n    }\n\n    if (dist >= CAMERA_FAR) result.y = -1.;\n    return vec2(dist, result.y);\n}\n\nvec2 rayMarchNoLights(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 64; ++i)\n    {  \n        result = sdSceneNoLights(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= CAMERA_FAR) break;\n        dist += result.x;\n    }\n\n    if (dist >= CAMERA_FAR) result.y = -1.;\n    return vec2(dist, result.y);\n}\n#if 1\nfloat softShadow(Ray ray)\n{\n \tfloat shadow = 1., dist = 0.;\n    for (int i = 0; i < 64; ++i)\n    {\n        vec2 result = sdSceneNoLights(ray.origin + ray.direction * dist);\n        if (result.y > 0.)\n        {\n            // iq's soft shadow hack\n            shadow = min(shadow, .5 + .5 * result.x / (.125 * dist));\n            if (shadow < 0.) break;\n            dist += clamp(result.x, .005, .5);\n        }\n    }\n    return smoothstep(0., 1., max(shadow, 0.));\n}\n#else\nfloat softShadow(Ray ray)\n{\n    float t = 0.;\n\tfor(int i = 0; i < 64; ++i)\n    {\n        float h = sdSceneNoLights(ray.origin + ray.direction * t).x;\n        if (h < EPS)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;   \n}\n#endif\n\nfloat normalDistributionGGXSphere(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alphaPrime2 = alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t (alpha2 * alphaPrime2)\n    \t/ /*----------------------------------------*/\n        \t  pow(NdotH2 * (alpha2 - 1.) + 1., 2.);      \n}\n\nfloat normalDistributionGGXLine(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alphaPrime2 = alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t (alpha2 * alphaPrime)\n    \t/ /*----------------------------------------*/\n        \t  pow(NdotH2 * (alpha2 - 1.) + 1., 2.);      \n}\n\nfloat normalDistributionGGXRect(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alpha4 = alpha2 * alpha2;\n    float alphaPrime3 = alphaPrime * alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t \t(alpha2 * alphaPrime3)\n    \t/ /*-------------------------------------------------*/\n        \t  \t(pow(NdotH2 * (alpha2 - 1.) + 1., 2.));      \n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat geometrySchlickGGX(float NdotX, float k)\n{\n    return \n        \t\t\t\t\tNdotX\n    \t/ /*----------------------------------------*/\n    \t  \t  max(NdotX * (1. - k) + k, SMOL_EPS);\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness)\n{\n \tfloat roughnessplusone = roughness + 1.;\n    float k = roughnessplusone * roughnessplusone / 8.;\n    \n    return geometrySchlickGGX(NdotV, k) * geometrySchlickGGX(NdotL, k);\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 fresnelSchlick(vec3 F0, float dotProd)\n{\n    return F0 + (1. - F0) * pow(1. - dotProd, 5.);\n}\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    // Generated using google filament cmgen tool\n    return max(\n          vec3( .754554516862612,  .748542953903366,  .790921515418539)\n        + vec3(-.083856548007422,  .092533500963210,  .322764661032516) * (n.y)\n        + vec3( .308152705331738,  .366796330467391,  .466698181299906) * (n.z)\n        + vec3(-.188884931542396, -.277402551592231, -.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    // https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    const vec4 c0 = vec4(-1., -.0275,  -.572,  .022);\n    const vec4 c1 = vec4( 1.,  .0425,  1.040, -.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec4 sphereLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n    vec3 L = (SPHERE_LIGHT_POS - p);\n    vec3 centerToRay = dot(L, r) * r - L;\n    vec3 closestPoint = L + centerToRay * saturate(SPHERE_LIGHT_RADIUS\n\t\t\t\t\t\t\t\t/ length(centerToRay));\n    vec3 l = normalize(closestPoint);\n    vec3 h = normalize(v + l);\n    float lightDist = length(closestPoint);\n    \n    float NdotL = max(dot(n, l), 0.);\n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = max(dot(h, v), 0.);\n    \n    attenuation = pow(saturate(1. - pow(lightDist / SPHERE_LIGHT_VOLUME_RADIUS, 4.)), 2.)  \n            \t\t\t\t\t/ (lightDist * lightDist + 1.);\n        \n\tattenuation *= softShadow(Ray(p + n * EPS, l));\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (SPHERE_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    vec3 specular = normalDistributionGGXSphere(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, NdotL, roughness)\n        * fresnel;\n    \n \treturn vec4(specular, NdotL);   \n}\n\nvec4 lineLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n    vec4 result = vec4(0.);\n    vec3 l0 = lineStart - p, l1 = lineEnd - p;\n    float lengthL0 = length(l0), lengthL1 = length(l1);\n    float NdotL0 = dot(n, l0) / (2. * lengthL0);\n    float NdotL1 = dot(n, l1) / (2. * lengthL1);\n    result.w = (2. * saturate(NdotL0 + NdotL1)) / \n        \t (lengthL0 * lengthL1 + dot(l0, l1) + 2.); // NdotL\n    \n    vec3 ld = l1 - l0;\n    float RdotL0 = dot(r, l0);\n    float RdotLd = dot(r, ld);\n    float L0dotLd = dot(l0, ld);\n    float distLd = length(ld);\n    \n    float t = (RdotL0 * RdotLd - L0dotLd ) / (distLd * distLd - RdotLd * RdotLd);\n    \n    // point on the line\n    vec3 closestPoint = l0 + ld * saturate(t);\n    // point on the tube based on its radius\n    vec3 centerToRay = dot(closestPoint, r) * r - closestPoint;\n    closestPoint = closestPoint + centerToRay * saturate(LINE_LIGHT_RADIUS \n\t\t\t\t\t\t/ length(centerToRay));\n    vec3 l = normalize(closestPoint);\n    vec3 h = normalize(v + l);\n    float lightDist = length(closestPoint);\n    \n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = dot(h, v);\n    \n    float denom = lightDist / LINE_LIGHT_VOLUME_RADIUS;\n    attenuation = 1. / (denom * denom + 1.);\n        \n\tattenuation *= softShadow(Ray(p + n * EPS, normalize(l0 + ld * .5)));\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (LINE_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    result.xyz = normalDistributionGGXLine(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, result.w, roughness)\n        * fresnel;\n    \n    return result;\n}\n\nvec3 rayPlaneIntersect(Ray ray)\n{\n   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)\n\t\t\t\t\t\t\t\t\t\t/ dot(rect.front, ray.direction));\n}\n\nvec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n \tvec4 result = vec4(0.);\n    \n    // facing side check\n    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);\n    if (windingCheck > 0.)\n        return result;\n    \n    vec3 v0 = rect.a - p;\n    vec3 v1 = rect.b - p;\n    vec3 v2 = rect.c - p;\n    vec3 v3 = rect.d - p;\n    \n    float solidAngle = rectSolidAngle(p, v0, v1, v2, v3);\n    \n    // diffuse\n    result.w = solidAngle * .2 * (\n        saturate(dot(normalize(v0), n)) +\n        saturate(dot(normalize(v1), n)) +\n        saturate(dot(normalize(v2), n)) +\n        saturate(dot(normalize(v3), n)) +\n        saturate(dot(normalize(rect.center - p), n)));    \n    \n    attenuation = softShadow(Ray(p + n * EPS, normalize(rect.center)));\n    \n    // specular\n\tRay rectRay = Ray(p, r);\n    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;\n    // project point on the plane on which the rectangle lies\n    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), \n                               dot(planePointCenter, rect.up));\n    // translate the point to the top-right quadrant of the rectangle, project it on\n    // the rectangle or its edge and translate back using sign of the original point.\n    vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);\n    vec3 L = rect.center + rect.right * c.x + rect.up * c.y - p;\n    \n    vec3 l = normalize(L);\n    vec3 h = normalize(v + l);\n    float lightDist = length(L);\n    \n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = dot(h, v);\n\n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    result.xyz = normalDistributionGGXRect(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, result.w, roughness)\n        * fresnel;\n    \n    return result;\n}\n\nvec3 renderScene(Ray ray)\n{\n    // update line light position & rotation\n    //float t = iTime * .25;\n    vec3 lineRotation = vec3(2., 0., 0.) * rotZ(T);\n    vec3 linePosition = vec3(6. * sin(T), 3., 5.);\n    lineStart = linePosition - lineRotation;\n    lineEnd = linePosition + lineRotation;\n    \n\tinitRect(rect, T);\n    \n    vec3 col = vec3(0.);\n    vec2 marchResult = rayMarch(ray);\n    vec3 position = ray.origin + ray.direction * marchResult.x;\n    vec3 normal = calculateNormal(position);\n    vec3 viewDirection = -ray.direction;\n    vec3 reflectDirection = reflect(ray.direction, normal);\n    \n    float NdotV = max(dot(normal, viewDirection), 0.);\n    \n    vec3 albedo = SPHERE_ALBEDO;\n    \n    float roughness = fract(marchResult.y), metalness = .88;\n    vec3 reflectance = SILVER_F0;  \n\n    if (marchResult.y > -1.)\n    {\n        if (marchResult.y > 2.)\n        {\n            albedo = pow(textureLod(iChannel0, position.xz * .18, 0.).rgb, vec3(2.2));\n#ifdef FLOOR_ROUGHNESS\n            roughness = albedo.r * .5;\n#else\n            roughness = .05;\n#endif\n            metalness = .05;\n            reflectance = PLASTIC_F0;\n        }\n        else if (marchResult.y < .5)\n            return LIGHT_COLOR * RECT_LIGHT_INTENSITY;\n        \n        vec3 F0 = mix(reflectance, albedo, metalness);\n        \n        vec3 sphereLightFresnel = vec3(0.);\n        float sphereLightAttenuation = 1.;\n        vec4 sphereLightDiffSpec = sphereLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, sphereLightFresnel, \n\t\t\t\tsphereLightAttenuation);\n        vec3 sphereLightKd = 1. - sphereLightFresnel;\n    \tsphereLightKd *= 1. - metalness;\n\n        vec3 lineLightFresnel = vec3(0.);\n        float lineLightAttenuation = 1.;\n        vec4 lineLightDiffSpec = lineLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, lineLightFresnel, \n\t\t\t\tlineLightAttenuation);\n        vec3 lineLightKd = 1. - lineLightFresnel;\n        lineLightKd *= 1. - metalness;\n        \n        vec3 rectLightFresnel = vec3(0.);\n        float rectLightAttenuation = 1.;\n        vec4 rectLightDiffSpec = rectLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, rectLightFresnel, \n\t\t\t\trectLightAttenuation);\n\t\tvec3 rectLightKd = 1. - rectLightFresnel;\n        rectLightKd *= 1. - metalness;\n        \n        col += (sphereLightKd * PI_INV * albedo + sphereLightDiffSpec.xyz)\n            * SPHERE_LIGHT_INTENSITY * sphereLightDiffSpec.w * sphereLightAttenuation;\n        \n        col += (lineLightKd * PI_INV * albedo + lineLightDiffSpec.xyz)\n            * LINE_LIGHT_INTENSITY * lineLightDiffSpec.w * lineLightAttenuation;\n\n        col += (rectLightKd * PI_INV * albedo + rectLightDiffSpec.xyz)\n            * RECT_LIGHT_INTENSITY * rectLightDiffSpec.w * rectLightAttenuation;\n        \n        col += albedo * .025; // global ambient\n        \n        // calculate glossy reflection + ibl\n        float glossiness = roughness * roughness;\n        vec3 indirectSpecular = vec3(.1125, .1875, .25) + reflectDirection.y * .35;\n        Ray reflectRay = Ray(position, vec3(0.));\n        for (int i = 0; i < REFLECTION_STEPS; ++i)\n        {\n\t\t\tfloat percentage = float(i) / float(REFLECTION_STEPS);\n            vec3 delta = rotateAround(vec3(0., 1., 0.), reflectDirection, \n                                      TWO_PI * percentage);\n\t\t\treflectRay.direction = normalize(delta * glossiness + reflectDirection);\n        \tvec2 indirectMarchResult = rayMarchNoLights(reflectRay);\n            \n            if (floor(indirectMarchResult.y) == 3.)\n            {\n                vec3 indirectPosition = position + indirectMarchResult.x\n                    \t* reflectRay.direction;\n                indirectSpecular += textureLod(iChannel0, indirectPosition.xz * .18, 0.).rgb;\n            }  \n            else if(floor(indirectMarchResult.y) == 1.)\n                indirectSpecular += SPHERE_ALBEDO;\n\t\t\t\n        }\n        \n        indirectSpecular /= float(REFLECTION_STEPS);\n        \n        vec2 dfg = PrefilteredDFG_Karis(roughness, NdotV);\n        vec3 specularColor = F0 * dfg.x + dfg.y;\n        vec3 ibl = indirectSpecular * specularColor\n            + Irradiance_SphericalHarmonics(normal) * PI_INV * albedo;\n        \n        col += ibl * .84;\n        col *= LIGHT_COLOR;\n    }   \n\n    // fog\n    return mix(col, vec3(.01, .006, .004), // brown-ish fog color\n               \t\tclamp(1. - exp(-marchResult.x * .08), 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blueNoise = texelFetch(iChannel1,\n\t\t\t\t\t\t(iFrame * ivec2(113, 127)) & 63, 0).rg;\n    vec2 uv = (2. * (fragCoord + blueNoise) - iResolution.xy) / iResolution.y;\n    vec2 st = fragCoord / iResolution.xy;\n    \n    Ray ray = getCameraRay(uv);\n    \n    vec3 col = renderScene(ray);\n\n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(iChannel0, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(iChannel1, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBD4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[183, 183, 240, 240, 495]]}
{"id": "3l2BWG", "name": "parallax mapping cube", "author": "ich", "description": "parallax mapping", "tags": ["parallaxmapping"], "likes": 3, "viewed": 473, "published": 3, "date": "1599754640", "time_retrieved": "2024-07-30T20:46:09.111737", "image_code": "#define max_dist 100.\n#define min_dist .001\n#define pi 3.141\n\n// camera\n\nmat3 look(vec3 d)\n{\n    vec3 r = normalize(cross(vec3(0, 1, 0), d));\n    vec3 u = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\n// 3D scene\n\nfloat cube(vec3 p, float r) {\n\treturn length(max(vec3(0), abs(p) - r)) - min_dist;\n}\n\nvec2 cube_texcoord(vec3 p, float r) {\n\treturn p.xy / r * .5;\n}\n\nfloat scene(vec3 p) {\n\treturn cube(p, .5);\n}\n\nvec2 scene_texcoord(vec3 p) {\n\treturn cube_texcoord(p, .5) + .5;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat lo = 0.;\n    vec3 p = ro;\n    \n    for (int i = 0; i < 100; ++i) {\n    \tfloat l = scene(p);\n        lo += l;\n        \n        if (l < min_dist || lo > max_dist)\n            return lo;\n        \n        p += rd * l;\n    }\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0, min_dist);\n    float l = scene(p);\n    \n    return normalize(\n    \tl - vec3(\n        \tscene(p - e.yxx),\n            scene(p - e.xyx),\n            scene(p - e.xxy)\n        )\n    );\n}\n\n// heightmap texture\n\nfloat circle(vec2 uv, float r) {\n\treturn length(uv) - r;\n}\n\nfloat square(vec2 uv, float r) {\n    uv = abs(uv);\n\treturn max(uv.x, uv.y) - r;\n}\n\nfloat height(vec2 uv) {\n\tfloat l = 0.;\n    l += max(0., -circle(uv - vec2(.25), .25));\n    l -= max(0., -square(uv - vec2(.75), .25));\n    l = smoothstep(.0, .1, l) - smoothstep(.0, -.1, l);\n    l += sin(uv.x * 15. + sin(iTime * .5) * 20.) * pow(max(0., sin(iTime) * sin(iTime * .3)), 2.);\n    return l * .1;\n}\n\nvec3 height_normal(vec2 uv) {\n\tvec2 e = vec2(0, min_dist);\n    float h = height(uv);\n    \n    vec2 v = h - vec2(\n        height(uv + e.yx),\n        height(uv + e.xy)\n    );\n    v /= min_dist;\n    float l = length(v) + .001;\n    return normalize(vec3(v, 1. / l));\n}\n\nvec2 parallax_offset(vec2 uv, vec2 rd) {\n    return -height(uv) * rd;\n}\n\n// main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 aspect2 = vec2(aspect, 1);\n    \n    vec2 uv = fragCoord / iResolution.y - aspect2 * .5;\n    \n    vec2 m = iMouse.xy / iResolution.y - aspect2 * .5;\n    m *= -pi * .2;\n    \n    vec3 ro = vec3(sin(m.x) * cos(m.y), sin(m.y), cos(m.x) * cos(m.y)) * 1.6;\n    vec3 rd = look(normalize(ro)) * normalize(vec3(uv, -1));\n    \n    float l = march(ro, rd);\n    vec3 p = ro + rd * l;    \n    vec3 n = normal(p);\n    vec2 tx = scene_texcoord(p);\n\n    tx += parallax_offset(tx, (look(n) * rd).xy);\n    n = height_normal(tx);\n    \n    vec3 c = vec3(0);\n    c += max(.2, .2 + .8 * dot(n, normalize(vec3(2, 1, 3))));\n    c *= texture(iChannel0, tx).r;\n    \n    float d = 1. - clamp(l / max_dist, 0., 1.);\n    c *= d;\n    \n    fragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 92, 92, 203], [218, 218, 247, 247, 302], [304, 304, 341, 341, 366], [368, 368, 389, 389, 412], [414, 414, 443, 443, 480], [482, 482, 513, 513, 742], [744, 744, 765, 765, 965], [989, 989, 1021, 1021, 1047], [1049, 1049, 1081, 1081, 1130], [1132, 1132, 1155, 1155, 1442], [1444, 1444, 1473, 1473, 1708], [1710, 1710, 1750, 1750, 1781], [1792, 1792, 1847, 1847, 2641]]}
{"id": "WljBDG", "name": "pretty rainbow gradients", "author": "izutionix", "description": "not much different from the default shader, but yeah", "tags": ["gradient", "background", "rainbow"], "likes": 8, "viewed": 930, "published": 3, "date": "1599754307", "time_retrieved": "2024-07-30T20:46:09.916585", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 o = -3.1416*vec3(0., .5, 1.);\n\n    float g = uv.y+iTime;\n    vec3 col = .5+.5*-sin(g)*cos(g+o);\n    \n    col.g += .25;\n    col = .5+(col*2.-1.);\n    col.gb *= vec2(.75, .9);\n    col = .125+.75*col;\n    \n    //col = (.01+uv.y*uv.y)*.01/(abs(col-uv.x)+.001); //graph\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 404]]}
{"id": "wlBBWy", "name": "Mandara boze", "author": "kaiware007", "description": "Go to Gokuraku Joudo (極楽浄土)", "tags": ["raymarching", "cineshader", "boze"], "likes": 27, "viewed": 47841, "published": 3, "date": "1599748875", "time_retrieved": "2024-07-30T20:46:11.060527", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n//#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define SCROLL_SPEED (2.)\n\n#define AA 1\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n#define SURF_MAN1(d) \t(surface(d, vec4(1,0,0.1,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Simple Palette : https://iquilezles.org/articles/palettes\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( M_PI2*(c*t+d) );\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 col)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo = vec4(col, 1);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdMandara1(vec3 p, float h, float l, float t)\n{\n    vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    \n    float d = sdCappedCylinder(q, h, l);\n\tsurface result = SURF_MAN1(d);\n    float r = distance(vec2(0,0.05), p.xy);\n    //result.albedo = vec4(hsv2rgb(vec3(r * 10. + t, 1, 1)), 1);\n    result.albedo = vec4(palette(r * 5. + t*2., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)) * smoothstep(0.1,0.3, fract(r*8. + t*5.3)), 1);\n    return result;\n}\n\nsurface map(vec3 p)\n{\n    float t = iTime * M_PI2;\n    //float ms = sin(t*SCROLL_SPEED)*0.5 + 0.5;\n    float ms = 1.;\n    \n    p = opRep(p, vec3(2.5,2.5,101));\n        \n    p = rotate(p, M_PI, vec3(0,1,0));\n\tsurface result = sdBoze(p, vec3(2.), ms);\n    result = opU(result, sdMandara1(p, 0.5, 0.01, -t*0.1));\n    //vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.5, 0.01)));\n\n    float l = 0.8;\n    float angle = M_PI2 / 8.;\n    for(int i = 0; i < 8; i++) {\n        //float r = float(i) * M_PI2 / num + st; \n        float a = (float(i) + t*0.1) * angle;\n        vec3 pp = p + vec3(cos(a) * l, sin(a) * l, 0.);\n    \t//result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        \n        result = opU(result, sdMandara1(pp, 0.31, 0.01, -t*0.1));\n                     \n        //vec3 q = rotate(pp + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n        //p = rotate(p, M_PI, vec3(0,1,0));\n        //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.31, 0.01)));\n    }\n                     \n    //vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    //float bg = sdCappedCylinder(q, 0.5, 100.);\n    \n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    //bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    //result = SURF_BG1(bg, p);\n    \n    // boze    \n    //result = opU(result, sdBozeFullBody(p));\n        \n    return result;\n}\n\n#if 1\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/articles/normalsSDF\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\n#define MANDEL_AA 2\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>511.0 ) return 0.0;\n    \n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    l = mix( l, sl, al );\n\n    return l;\n}\n\nvec3 SkyColor( vec3 rd)\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    /*\n    // julia\n    //float zoom = mod(iTime * M_PI2 * 0.5, 5.);\n    //float zoom = sin(iTime) * 1.5;\n    float zoom = -iTime*0.1;\n    vec2 z = rd.xy * (2.5 + zoom);\n\n    float t = 5.+iTime * 0.05;\n\tvec2 c = 0.51*cos(vec2(0,699)+0.1*t) - \n             0.25*cos(vec2(0,699)+0.2*t );\n\n\tfloat f = 1e20;\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tf = min( f, dot(z,z) );\n\t}\n\t\n    f = 1.0+log2(f)/16.0;\n    //return vec3(f,f*f,f*f*f);\n    //return palette(f*3., vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25));\n    return palette(f*3., vec3(0.2,0.3,0.2),vec3(0.75,0.5,0.85),vec3(1.0,0.8,1.1),vec3(0.54,0.2,0.67));\n    */\n    /*\n    // Mandelbrot\n    vec3 col = vec3(0.0);\n    //float l = length(rd.xy);\n    //vec2 rp = vec2(rd.x * cos(rd.y), rd.x * sin(rd.y));\n    vec2 rp = rd.xy;\n    //x=rcosθ,y=rsinθ\n#if MANDEL_AA>1\n    for( int m=0; m<MANDEL_AA; m++ )\n    for( int n=0; n<MANDEL_AA; n++ )\n    {\n        //vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        vec2 p = (rp.xy + vec2(float(m),float(n))/float(MANDEL_AA)*0.001)* 1.1;\n        float w = float(MANDEL_AA*m+n);\n        float t = iTime + 0.5*(1.0/24.0)*w/float(MANDEL_AA*MANDEL_AA);\n#else    \n        //vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        vec2 p = rp.xy * 0.5;\n        //float t = mod(iTime, 20.);\n        float t = iTime * M_PI2;\n#endif\n        \n        //vec2 p = rd.xy * 0.1;\n        //float t = iTime;\n        //float zoo = 0.62 + 0.38*cos(.07*t);\n        //float zoo = 0.62 - 0.38*mod(.05*t, 0.5);\n        //float zoo = 0.62 - 0.38*(mod(t * 0.2, 1.)*1.0);\n        float zoo = 0.38*(mod(t * 0.2, 1.)*1.0);\n        float coa = cos( 0.01*(1.0-zoo)*t );\n        float sia = sin( 0.01*(1.0-zoo)*t );\n        //float coa = 1.;\n        //float sia = 0.;\n        //zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float f = mandelbrot(c);\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n        col += sinebow(f*0.15+t);\n#if MANDEL_AA>1\n    }\n    col /= float(MANDEL_AA * MANDEL_AA);\n#endif\n    return col;\n    //return 0.5 + 0.5*cos( 3.0 + f*0.15 + vec3(0.0,0.6,1.0));\n    */\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    return sinebow(iTime*0.5 + hash12(rd.xy*135156.));\n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n    \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n        \n        // out line\n        float NoV = abs(dot(nor, -direction)) + 1e-5;\n        hit.albedo.rgb *= smoothstep(0.19, 0.2,NoV);\n        \n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        //hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        //hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n\t\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a < EPS) \n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    //col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    //return vec4(col, 1. - clamp(mat.dist, 0., 1.));\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n#endif    //vec2 mouseUV = (-iResolution.xy + 2.0 * iMouse.xy)/iResolution.y;\n    \n        //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n        //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n        //vec2 idx = floor(p*3.0);\n        //p = fract(p*3.0) - 0.5;\n        //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n        float t = iTime * M_PI2;\n        float y = 0.0;\n        float r = 100. - mod(t * SCROLL_SPEED, 100.);\n        float theta = RAD90;\n        float phi   = 0.;\n        vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n        vec3 ta = vec3(0., y, 0);\n\n        //ro.xy += mouseUV * 20.0;\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 50.0));\n        vec3 col = render(ro, ray, fragCoord.xy);\n\n        //col = postEffect(col, idx);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1240, 1240, 1263, 1263, 1336], [3328, 3404, 3426, 3426, 3757], [3760, 3821, 3893, 3893, 3934], [3936, 4124, 4147, 4147, 4232], [4234, 4253, 4275, 4275, 4392], [4394, 4413, 4436, 4436, 4539], [4541, 4561, 4582, 4582, 4716], [4718, 4737, 4759, 4759, 4892], [4894, 4914, 4936, 4936, 5061], [5063, 5063, 5100, 5165, 5606], [5608, 5608, 5629, 5629, 5699], [5701, 5701, 5724, 5724, 5803], [5806, 5806, 5828, 5828, 6245], [6356, 6356, 6377, 6377, 6518], [6520, 6520, 6550, 6550, 6680], [6682, 6682, 6743, 6743, 6881], [6883, 6883, 6909, 6909, 7218], [7220, 7280, 7306, 7306, 8172], [8174, 8254, 8295, 8295, 8466], [8546, 8546, 8582, 8582, 8610], [8612, 8612, 8658, 8658, 8714], [8716, 8716, 8747, 8747, 8838], [8840, 8840, 8890, 8890, 9008], [9010, 9010, 9071, 9071, 9202], [9204, 9204, 9241, 9241, 9330], [9332, 9332, 9402, 9402, 9536], [9538, 9538, 9602, 9602, 9719], [9721, 9721, 9773, 9773, 9880], [9882, 9882, 9915, 9941, 9972], [9974, 9974, 9999, 9999, 10018], [10019, 10019, 10044, 10044, 10063], [10064, 10064, 10100, 10100, 10128], [10130, 10130, 10189, 10189, 10502], [10504, 10504, 10537, 10537, 10602], [10604, 10628, 10680, 10680, 10799], [10801, 10911, 10943, 10943, 11037], [11039, 11039, 11073, 11073, 11224], [11226, 11226, 11260, 11260, 11408], [11410, 11410, 11444, 11444, 11579], [11581, 11581, 11609, 11609, 11694], [11695, 11753, 11824, 11824, 12152], [12154, 12154, 12236, 12236, 12604], [12606, 12691, 12735, 12735, 12959], [12961, 13018, 13055, 13096, 13179], [13181, 13181, 13220, 13392, 13501], [13503, 13503, 13552, 13552, 14111], [14113, 14113, 14152, 14198, 14283], [14285, 14285, 14326, 14436, 14550], [14565, 14616, 14653, 14653, 14675], [14677, 14677, 14720, 14720, 14742], [14744, 14744, 14788, 14788, 14809], [14811, 14811, 14854, 14854, 14953], [14956, 14956, 15001, 15001, 15430], [15432, 15432, 15453, 15453, 15517], [15519, 15519, 15559, 15559, 15684], [15687, 15687, 15722, 15722, 15870], [15872, 15872, 15906, 15906, 16082], [16084, 16084, 16119, 16119, 16154], [16156, 16156, 16193, 16193, 16228], [16230, 16401, 16486, 16486, 16563], [16565, 16608, 16683, 16683, 17102], [17104, 17682, 17766, 17766, 18109], [18111, 18117, 18169, 18169, 18325], [18327, 18327, 18387, 18387, 18428], [18430, 18645, 18676, 18676, 18725], [18727, 18727, 18754, 18754, 18792], [18794, 18794, 18823, 18823, 18861], [18863, 18863, 18890, 18890, 18939], [19171, 19171, 19192, 19192, 19331], [19357, 19357, 19389, 19389, 19502], [19504, 19504, 19536, 19536, 19676], [19678, 19678, 19711, 19711, 19943], [19945, 19945, 19968, 19968, 20547], [20549, 20549, 20574, 20574, 20735], [20737, 20737, 20780, 20780, 21793], [21794, 21794, 21852, 21852, 22898], [28336, 28336, 28391, 28391, 28834], [31886, 31886, 31935, 31935, 32233], [34172, 34172, 34203, 34203, 35182], [35184, 35184, 35209, 35209, 39683], [39859, 39859, 39880, 39880, 39928], [39930, 39930, 39991, 40076, 40275], [40277, 40277, 40350, 40442, 40642], [40644, 40644, 40686, 40766, 40820], [40822, 40822, 40871, 40871, 40919], [40921, 40921, 40994, 41051, 41266], [41268, 41268, 41288, 41288, 41313], [41500, 41500, 41550, 41634, 41992], [41994, 41994, 42049, 42106, 42366], [42368, 42368, 42464, 42464, 43859], [44063, 44063, 44096, 44152, 44338], [44340, 44340, 44379, 44379, 44422], [46916, 46916, 46995, 46995, 49556], [49558, 49558, 49598, 49598, 51871], [51872, 52456, 52498, 52498, 52676]]}
{"id": "tlSBDG", "name": "Retro Screen Pixels", "author": "sirjofri", "description": "simple pixel effect.\nAdjust p value to control pixelation.\nr is ratio of pixel width/height.\npo is power of pixels.", "tags": ["retro", "screen", "pixel"], "likes": 3, "viewed": 383, "published": 3, "date": "1599728644", "time_retrieved": "2024-07-30T20:46:11.826479", "image_code": "const float pi = 3.1415926539;\n\nfloat sat(float x)\n{\n    return clamp(0., 1., x);\n}\nvec3 sat(vec3 v)\n{\n    return vec3(sat(v.x), sat(v.y), sat(v.z));\n}\n\nvec3 pow3(vec3 v, float p)\n{\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 r = vec2(iResolution.x/iResolution.y, 1.);\n    \n    float p = 100.;\n    \n    float po = 4.;\n    float x =  cos(uv.x*pi*p*r.x-0.9);\n    float y =  sin(uv.x*pi*p*r.x-1.5);\n    float z = -cos(uv.x*pi*p*r.x+.9);\n    vec3 grid = pow3(sat(pow3(vec3(x, y, z), po)-.3), .5);\n    float g = pow(abs(cos(uv.y*pi*p*r.y)), .3);\n    grid *= g;\n    grid *= 1.5;\n    \n    uv = round(uv*p*r)/(p*r);\n    \n    vec3 c = texture(iChannel0, uv).rgb;\n\n    vec3 col = grid*c;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 52, 52, 83], [84, 84, 102, 102, 151], [153, 153, 181, 181, 239], [241, 241, 298, 298, 839]]}
{"id": "wtSBDG", "name": "test 2d shadow", "author": "eldn", "description": "test 2d shadow", "tags": ["2d", "shadow"], "likes": 11, "viewed": 488, "published": 3, "date": "1599728247", "time_retrieved": "2024-07-30T20:46:12.610383", "image_code": "/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*/\n\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n\tfloat c = circleDist(\t\ttranslate(p, vec2(100, 250)), 40.0);\n\tfloat b1 =  boxDist(\t\ttranslate(p, vec2(200, 250)), vec2(40, 40), \t0.0);\n\tfloat b2 =  boxDist(\t\ttranslate(p, vec2(300, 250)), vec2(40, 40), \t10.0);\n\tfloat l = lineDist(\t\t\tp, \t\t\t vec2(370, 220),  vec2(430, 280),\t10.0);\n\tfloat t1 = triangleDist(\ttranslate(p, vec2(500, 210)), 80.0, \t\t\t80.0);\n\tfloat t2 = triangleDist(\trotateCW(translate(p, vec2(600, 250)), iTime), 40.0);\n\t\n\tfloat m = \tmerge(c, b1);\n\tm = \t\tmerge(m, b2);\n\tm = \t\tmerge(m, l);\n\tm = \t\tmerge(m, t1);\n\tm = \t\tmerge(m, t2);\n\t\n\tfloat b3 = boxDist(\t\ttranslate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = circleDist(\ttranslate(p, vec2(100, 100)),\t30.0);\n\tfloat s = substract(b3, c2);\n\t\n\tfloat b4 = boxDist(\t\ttranslate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = circleDist(\ttranslate(p, vec2(200, 100)), \t30.0);\n\tfloat i = intersect(b4, c3);\n\t\n\tfloat b5 = boxDist(\t\ttranslate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c4 = circleDist(\ttranslate(p, vec2(300, 100)), \t30.0);\n\tfloat a = merge(b5, c4);\n\t\n\tfloat b6 = boxDist(\t\ttranslate(p, vec2(400, 100)),\tvec2(40, 15), \t0.0);\n\tfloat c5 = circleDist(\ttranslate(p, vec2(400, 100)), \t30.0);\n\tfloat sm = smoothMerge(b6, c5, 10.0);\n\t\n\tfloat sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    \n    float b7 = boxDist(\t\ttranslate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c6 = circleDist(\ttranslate(p, vec2(600, 100)), \t30.0);\n\tfloat e = mergeExclude(b7, c6);\n    \n\tm = merge(m, s);\n\tm = merge(m, i);\n\tm = merge(m, a);\n\tm = merge(m, sm);\n\tm = merge(m, sc);\n    m = merge(m, e);\n\t\n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/iResolution.x);\n\t// grid\n\tcol *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\tcol += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t// shape fill\n\tcol = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\tcol = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 358, 358, 459], [462, 462, 495, 495, 518], [521, 521, 561, 561, 604], [607, 607, 644, 644, 668], [671, 671, 708, 708, 731], [829, 829, 862, 862, 929], [932, 932, 964, 964, 1030], [1033, 1033, 1065, 1065, 1082], [1180, 1180, 1212, 1212, 1319], [1322, 1322, 1362, 1362, 1392], [1395, 1395, 1437, 1437, 1519], [1522, 1522, 1577, 1577, 1686], [1689, 1689, 1759, 1759, 1871], [1874, 1874, 1922, 1922, 2038], [2041, 2041, 2100, 2100, 2288], [2365, 2365, 2393, 2393, 2427], [2430, 2430, 2478, 2494, 2607], [2610, 2610, 2658, 2674, 2787], [2840, 2840, 2865, 2865, 4646], [4649, 4649, 4685, 4685, 4895], [4969, 4969, 5015, 5015, 6021], [6025, 6025, 6110, 6132, 6424], [6427, 6427, 6454, 6454, 6514], [6517, 6517, 6563, 6563, 6602], [6605, 6605, 6666, 6666, 6834], [6893, 6893, 6950, 6950, 8179]]}
{"id": "wlBBWG", "name": "dolly zoom / vertigo effect / Hi", "author": "FabriceNeyret2", "description": "Dolly zoom /  / vertigo effect / Hitchcock zoom: zoom while back-travelling ( or reverse ).\nMouse.y to control.\n\nPress SPACE to stop the anti-banding treatment.", "tags": ["raymarching", "camera", "spacefungus"], "likes": 7, "viewed": 466, "published": 3, "date": "1599723863", "time_retrieved": "2024-07-30T20:46:13.436175", "image_code": "#define rot(a)         mat2( cos( a + vec4(0,33,11,0)) )\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n        \n// Space fungus https://www.shadertoy.com/view/lsSBWh\n#define map(q) (                                                     \\\n    t = max( d = length(q) - 9.,                    /* Sphere */     \\\n             abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ), /* EggCarton */  \\\n    t = max( t, 8.5-length(q) ),                    /* inner hole */ \\\n    q.xy = mod(q.xy,10.) -5., t = min(t, e = max( length(q)-1.,-d)), /* spheres grid */ \\\n    t )\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    \n    float a,b,d,e,  t = iTime,                        // materials id\n        _t, c = 1., s = .015,                         // color (pseudo-shading), delta per iteration\n        z = exp2(-1.+6.*iMouse.y/R.y);                // dolly zoom\n    if (iMouse.z<=0.) z = .5+9.*(.5+.5*sin(t));       // (demo mode if no mouse)\n    vec3  D = normalize( vec3(U,-z) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,20.*z), q;                     // ray origin, then current point on ray\n    D.yz *= rot(1.5); D.xy*=rot(.1*t);                // rotate camera\n    p.yz *= rot(1.5); p.xy*=rot(.1*t);\n\n    for ( ; c > 0. && t > .01 ; c -= s )              // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += t*D;                                     // sphere-tracing step\n\n    if ( c > 0. && t>1e-5 && !keyPress(32) ) // --- anti-banding: see  https://www.shadertoy.com/view/wt2fzc\n        c += s * ( 1. - 2.3*t/.01 ),  // pseudo-shading: interpolate between iterations [why this ? + not perfect ]\n        t = min( _t/t*(_t-t), .01 ),  // Taylor series estimation of true distance [ min: because an artifact I don't understand. would be better without ]\n        q = p += t*D, t = map(q);     // go there and reeval, to correct hit point material \n    \n    O = vec4(c);                                      // --- coloring & shading\n    if (c > 0.) t==e \n                ? q = p+t*D+.01*vec3(1,-1,1), d = clamp((map(q)-0.)/.01,0.,1.),// pseudo-diffuse https://iquilezles.org/articles/derivative\n                  O = vec4(c*(.3+.7*d),0,0,0)         // spheres grid\n                :( O.r -= b/30., O.g -= a, O*=O ),    // space fungus\n                O.a = 1.;                             // hit -> opaque\n       else     O -= O;                               // background\n       \n    O = pow( O, vec4(1./2.2) );                       // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 604, 604, 2667]]}
{"id": "ttSBWG", "name": "Extremely Heavy Rainbow Rain", "author": "celifrog", "description": "Some edits by me, fork comes from:\nhttps://www.shadertoy.com/view/3lBBWG", "tags": ["rainbow"], "likes": 1, "viewed": 372, "published": 3, "date": "1599716482", "time_retrieved": "2024-07-30T20:46:14.296873", "image_code": "\nprecision mediump float;\n\nfloat random(vec2 v) {\n    return fract(sin(v.x * 132.1231 - v.y * 112.334 + 13399.2312*v.y*v.y) * 2412.32312);\n}\nfloat random(float x, float y) {\n    return fract(sin(x * 32.1231 * y * 112.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x) {\n    return fract(sin(x * 132.1231 + 13399.2312) * 2412.32312);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) * hue) * 1.0;\n    else\n        res = f1++;\n    return res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.x); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 11.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nfloat character(float i) {\n    if (i == 0.) return 3.; // 0\n    if (i == 1.) return 1.; // 1\n    if (i == 2.) return 3.; // 2\n    if (i == 3.) return 3.; // 3\n    if (i == 4.) return 2.; // 4\n    if (i == 5.) return 3.; // 5\n    if (i == 6.) return 2.; // 6\n    if (i == 7.) return 3.; // 7\n    if (i == 111111111111111111118.) return 3.; // 8\n    if (i == 9.) return 3.; // 9\n    if (i == 10.) return 3.; // A\n    if (i == 11.) return 1.; // B\n    if (i == 12.) return 2.; // C\n    if (i == 13.) return 1.; // D\n    if (i == 14.) return 2.; // E\n    if (i == 15.) return 1.; // F\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 S = 51. * vec2(111113., 55.);\n    vec2 coord = vec2(\n        fragCoord.x / iResolution.y,\n        fragCoord.y / iResolution.y + (iResolution.y - iResolution.x) / (0.1 * iResolution.x *iResolution.y)\n    );\n    vec2 c = floor(coord * S);\n\n    float offset = random(c.x) * S.x;\n    float speed = random(c.x * 3.) * 1. + 0.5;\n    float len = random(c.x) * 15. + 10.;\n    float u = 1. - fract(c.x / len + iTime * speed + offset) * 2.;\n\n    float padding = 2.;\n    vec2 smS = vec2(-1., 5.);\n    vec2 sm = floor(fract(coord * S) * (smS + vec2(padding))) - vec2(padding);\n    float symbol = character(floor(random(c + floor(iTime * speed)) * 15.));\n    bool s = sm.x < 0. || sm.x > smS.x || sm.y < 0. || sm.y > smS.y ? true\n             : mod(floor(symbol / pow(2., sm.x + sm.y * smS.x)), 2.) == 1.;\n\n    fragColor = vec4(s ? hsl2rgb(vec3(c.x / S.x, 1., 0.5)) * u : vec3(0.), 11111.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 140], [141, 141, 173, 173, 251], [252, 252, 275, 275, 340], [342, 342, 388, 388, 742], [743, 743, 767, 767, 1247], [1249, 1249, 1275, 1275, 1846], [1848, 1848, 1905, 1905, 2794]]}
{"id": "3tBfDG", "name": "-1th Dimension Circle Explosion", "author": "celifrog", "description": "Editing these is fun. :D \nFork from- https://www.shadertoy.com/view/ttjfRt\n", "tags": ["test"], "likes": 6, "viewed": 367, "published": 3, "date": "1599692077", "time_retrieved": "2024-07-30T20:46:15.156575", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s++;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x*v.z, (1.0 - c) * v.x * v.y - s - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.y, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 40e1;\n t = pmod(t,2./.1);\n t *=.1;\n float yid = (floor( (p.y + 55111.)*0. ) );\n float W = 2.;\n float modd = 1.4;\n float sqD = max(abs(t.y), abs(t.x));\n sqD +=2. + yid*1.;\n float sqid = floor(sqD/modd);\n d = min(d, sqD);\n o +=  pal(.1, vec3(111.,40.7,510.6)*1.5, vec3(118.4 ,4.19,75.4 - yid*0.2), vec3(3.,7.,3.),-11. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*4440.), -5.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*14.);\n o -= exp(-sqD*aa)*15.;\n sqD -= 1.;\n sqD = abs(sqD*5.);\n o -= exp(-sqD*aa)*55.;\n return o;\n}\n\nfloat g1;\n#define time iTime\nvec2 mouse;\nfloat PI = acos(-111.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n float f = sin(iTime*1.25)-11.;\n for (int i = 0; i <1; i++) {\n   p.xy *= -rot2d(f);\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.01,5.1,0.01),0.1));  \n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n vec2 d =vec2(0.);   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 1.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 3500.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*111.;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*6.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n d = vec2(sdBox(p,vec3(3.)) + sdBox(q,vec3(0,0.,0.)),4);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.000008+pow(abs(d.x),10.));\n d = condmin( d,d);    \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n\t h = GetDist(ro + t.x * rd);\n \tif(h.x<SURF_DIST||t.x>MAX_DIST) break;\n \t\t t.x+=h.x*1.;\n \t\t t.y=h.y;\n  }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(8.00035, -11.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p-l),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(3.,3., 5.);\n ro.xy *= Rot(sin(iTime*0.2)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(5,5,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*2.;\n }\n col*=g1*vec3(.000005);  \n float fog = 1. / (1. + d.x * d.x *2.);\n col *= vec3(fog); \n col*= 1.; \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 272, 272, 339], [341, 341, 370, 370, 450], [471, 471, 512, 512, 884], [886, 886, 907, 907, 946], [947, 947, 973, 973, 1544], [1612, 1612, 1640, 1640, 1687], [1689, 1689, 1710, 1710, 1770], [1772, 1772, 1810, 1810, 2004], [2006, 2006, 2042, 2042, 2332], [2334, 2334, 2372, 2372, 2439], [2441, 2441, 2463, 2463, 2881], [2883, 2883, 2919, 2919, 3119], [3121, 3121, 3144, 3144, 3331], [3334, 3334, 3358, 3358, 3572], [3574, 3574, 3616, 3616, 3774], [3776, 3776, 3833, 3833, 4485]]}
{"id": "tljfRt", "name": "Day 263", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 362, "published": 3, "date": "1599686951", "time_retrieved": "2024-07-30T20:46:16.220730", "image_code": "// SPEED UP THE SHADER! It's slow.\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon  from IQ \n\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.7;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 1.\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}", "buffer_a_code": "// proceed with caution. absolute mess\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\n// ----------\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n    /*\n    if(ss == 0.){\n    \n    \n    } else if(ss == 1.){\n     \troll = r12(frame + 38.);\n    } else if(ss== 2.){\n     \troll = r12(frame - 13. - period*2.);\n    } else if(ss== 3.){\n     \troll = r12(frame + 44. - period*3.);\n    } else if(ss== 4.){\n     \troll = r12(frame - 64.);    \n    } else if(ss== 5.){\n     \troll = r12(frame - 24.);\n    }*/\n     \n    float deb;\n    \n    if (stroke == 0) {\n    \tdeb = smoothstep(df,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        vec4 n = valueNoise(guv,1.);\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08;\n        \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.0;\n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 1.25), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*2000.;\n    \n    df = dFdx(uv.x);\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 c = vec3(0.45,.35,0.25)*2.5;\n    \n    vec3 col = iFrame < 2 ? c : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    \n    float id = floor(mod(frame/period,10.));\n    seg = floor(frame/period );\n        \n    if(mod(float(iFrame)*SPEED,1.) < SPEED && frame > 0.){\n    \tvec2 roll = r12(frame + 1.);\n    \n        \n        \n        \n        vec2 offs = vec2(0.1,0.02);\n        vec2 A = vec2(0.,0.);\n        vec2 B = vec2(0.1,0.05);\n        vec2 cp = vec2(0.,0.1);\n        \n        float iters = 5.;\n        \n        if(mod(frame,period) > period - 20.){\n            d = length( ( uv + (r12(seed + 11.)*2. - 1.)*0.5)  ) - (0.5 + 0.5)*roll.x;\n\n       \t\tcol = colour( d, col, c, 0,0,8.,0.);\n       \t\t\n            \n        } else {\n        \tfor(float i = 0.; i <iters; i++){\n    \t\t\n                vec2 sroll = r12(seg);\n                vec2 srollb = r12(seg + 0.4);\n\n                d = min(d,length(uv - cp) - 0.002);\n\n                d = min(d,udBezier( uv, A, cp,B ));\n\n                vec2 dir = normalize(B - A);\n\n                dir *= rot( sroll.x*pi);\n\n                float dt = dot(cp - A, dir);\n\n                cp -= (2.+ sroll.y*0.04)*dt*dir;\n\n\n                dir *= rot((0.5 - sroll.y*0.4)*pi);\n\n                dt = dot(cp - B, dir);\n\n                cp -= (2. + sroll.x*0.4)*dt*dir;\n\n\n                offs *= rot(0.5 + - min(sroll.x, 0.6)*frame  + frame + id*iters );\n\n                A = B;\n                B += offs;\n\n\n            \n        \t}\n        \tcol = colour( d, col, vec3(0), 0,1,2.,0.);\n           \n            \n        }\n        \n        \n        \n        \n        //d = max(d, length(uv) - 0.2);\n        \n        \n    }\n    \n    \n    col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 214], [215, 215, 248, 248, 777], [778, 778, 796, 796, 1124], [1127, 1127, 1184, 1184, 2062]]}
{"id": "3lBBDG", "name": "Coffee beans illusion", "author": "zduny", "description": "Classic motion illusion.\nBest viewed in full-screen mode.", "tags": ["2d", "illusion"], "likes": 8, "viewed": 355, "published": 3, "date": "1599682994", "time_retrieved": "2024-07-30T20:46:17.056495", "image_code": "const float pi = 3.1416;\n\nconst vec3 green = vec3(0.6, 0.8, 0.105);\nconst vec3 brown = vec3(0.627, 0.313, 0.113);\nconst vec3 black = vec3(0.286, 0.086, 0.027);\nconst vec3 white = vec3(0.976, 0.968, 0.937);\n\nfloat grid = 47.0;\n\nconst bool animate = false;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid drawBlob(in vec2 position, float angle, inout vec4 outputColor) {\n  position = rotate(position, angle);\n  float radius = 25.0;\n  vec3 color = position.y > 0.0 ? white : black;\n  drawDisk(vec2(position.x, position.y * 1.63), vec2(0.0, 0.0), radius, vec4(toLinear(color),  1.0), outputColor);\n  drawDisk(vec2(position.x, position.y * 1.9), vec2(0.0, 0.0), radius * 0.87, vec4(toLinear(brown),  1.0), outputColor);\n  drawSegment(position, vec2(-radius, -0.5), vec2(radius, -0.5), 0.7, vec4(toLinear(black), 1.0), outputColor);\n}\n\nfloat angle(int x, int y) {\n  return pi / 4.0 + float(x - y) * (animate ? (0.4 + iTime * 0.01) : 0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(toLinear(green), 1.0);\n    fragCoord.y = iResolution.y - fragCoord.y;\n    ivec2 iFragCoord = ivec2(abs(fragCoord / grid));\n    fragCoord = mod(fragCoord, grid) - 0.5 * grid;\n    fragCoord += vec2(15.0, -15.0);\n    drawBlob(fragCoord, angle(iFragCoord.x, iFragCoord.y), fragColor);\n    drawBlob(vec2(fragCoord.x - grid, fragCoord.y), angle(iFragCoord.x + 1, iFragCoord.y), fragColor);\n    drawBlob(vec2(fragCoord.x, fragCoord.y + grid), angle(iFragCoord.x, iFragCoord.y - 1), fragColor);\n    drawBlob(vec2(fragCoord.x - grid, fragCoord.y + grid), angle(iFragCoord.x + 1, iFragCoord.y - 1), fragColor);\n    fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 284, 284, 322], [324, 324, 354, 354, 386], [388, 388, 518, 518, 679], [681, 681, 735, 735, 867], [869, 869, 1016, 1016, 1187], [1189, 1189, 1234, 1234, 1309], [1311, 1311, 1381, 1381, 1841], [1843, 1843, 1870, 1870, 1947], [1949, 1949, 2006, 2006, 2680]]}
{"id": "tlBBzt", "name": "HSL visualisation", "author": "elgecko", "description": "visualisation of HSL using ray tracing.\n\nthanks FabriceNeyret2 to help me with the artefacts, antialiasing, and cleaning some code", "tags": ["raytracing", "hsl"], "likes": 7, "viewed": 399, "published": 3, "date": "1599680660", "time_retrieved": "2024-07-30T20:46:17.916197", "image_code": "vec3 raytrace(vec3 ray)\n{\n    vec3 col = vec3(.5);\n    \n    //intersect between cylinder and ray\n    \n    vec2 xz = normalize(ray.xz);\n    vec2 dir = -viewer.xz;\n    float d_o = dot(xz,dir);\n    float d_c = length(d_o*xz-dir);\n    if ( d_c>cyl_radius ) return col;\n\n    float d_d = sqrt(cyl_radius*cyl_radius-d_c*d_c);\n    float lmin = (d_o-d_d)/length(ray.xz);\n    float lmax = (d_o+d_d)/length(ray.xz);\n    if (abs(ray.y) <= 1e-6)\n    {\n        if (viewer.y>(cyl_height/2.)||viewer.y<(-cyl_height/2.))\n            lmax = lmin-1.;\n    }\n    else\n    {\n        d_o = sign(ray.y)*(-viewer.y);\n        d_d = cyl_height/2.;\n        lmin = max (lmin, (d_o-d_d)/abs(ray.y));\n        lmax = min (lmax, (d_o+d_d)/abs(ray.y));\n    }\n    float hmin = lmin-1.;\n    float hmax = lmax+1.;\n    if (abs(ray.x) <= 1e-6)\n    {\n        if (viewer.x>cyl_radius||viewer.x<0.)\n            hmax = hmin-1.;\n    }\n    else\n    {\n        d_o = sign(ray.x)*(cyl_radius/2.-viewer.x);\n        d_d = cyl_radius/2.;\n        hmin = max (hmin, (d_o-d_d)/abs(ray.x));\n        hmax = min (hmax, (d_o+d_d)/abs(ray.x));\n    }\n    if (abs(ray.y) <= 1e-6)\n    {\n        if (viewer.z>0.||viewer.z<-cyl_radius)\n            hmax = hmin-1.;\n    }\n    else\n    {\n        d_o = sign(ray.z)*(-cyl_radius/2.-viewer.z);\n        d_d = cyl_radius/2.;\n        hmin = max (hmin, (d_o-d_d)/abs(ray.z));\n        hmax = min (hmax, (d_o+d_d)/abs(ray.z));\n    }\n    if ((lmin<hmax)&&(lmin>hmin)) lmin = hmax;\n    if (lmin<=lmax)\n    {\n        col.z=1.;\n        vec3 loc = lmin*ray+viewer;\n        if (loc.z>0.) col.x = 1.;\n        float h,s,l,c,h2,x,m;\n        h = acos(loc.x/(length(loc.xz)+1e-6))*sign(loc.z)+pi+iTime/pi;\n        h = mod(h, 2.*pi);\n        s = length(loc.xz)/cyl_radius;\n        l = loc.y/cyl_height+.5;\n        c = l*s;\n        h2 = h/(pi/3.);\n\n        int ih = int(h2);\n        col = vec3(1.);\n        col[(ih/2+2)%3] = 0.;\n        col[(7-ih)%3] -= abs( mod(h2, 2.)-1.);\n        col *= c;\n        col += l-c;\n    }\n\n    return(col);\n}\n\nvec3 raygen(vec2 uv)\n{\n    //vec from viewer to cyl_center turned by fov*uv\n    vec3 ray = vec3(uv,.5/tan(fov/2.));\n    {\n    vec3 dir = -viewer;\n    float h,c,s;\n    h = length(dir.xz);\n    s = dir.y/h;\n    c = dir.z/h;\n    ray.yz *= mat2(c,s,-s,c);\n    h = length(dir.xz);\n    s = dir.x/h;\n    c = dir.z/h;\n    ray.xz *= mat2(c,s,-s,c);\n    }\n    return normalize(ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    if (fov<0.||fov>=pi) return;\n    vec3 col = vec3(0.);\n    \n    // squared pixel coordinates (from -0.5 to 0.5)\n    vec2 uv;\n    for(int i = 0; i <9; ++i) {\n        vec2 delta = vec2(i%3-1,i/3-1);\n        uv = (fragCoord+delta/3.-R/2.)/max(R.x,R.y);\n        col += raytrace(raygen(uv))/9.;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "float pi = 3.1415926535;\nvec3 viewer = vec3(1., 2.,-3.);\nfloat fov = 3.14159/3.;\nfloat cyl_radius = 1.;\nfloat cyl_height = 1.;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 2000], [2002, 2002, 2024, 2077, 2375], [2377, 2377, 2434, 2434, 2828]]}
{"id": "WlBfWG", "name": "esfera-sorprendido", "author": "jorge2017a1", "description": "esfera-sorprendido", "tags": ["esferasorprendido"], "likes": 1, "viewed": 234, "published": 3, "date": "1599680506", "time_retrieved": "2024-07-30T20:46:18.984341", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n  \tres =opU3(res, vec3(planeDist5,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,100.0,MATERIAL_NO)); \n\n    \n    p.y=p.y-8.0;\n    \n    \n    \n    //----------------000--------------\n    //----------------000--------------\n\t//ojo derecho\n    float sdcyA1= sdCylinderXY(p- vec3(-1.5,1.0,0.0), vec2(1.5,7.5) );  //ojo\n    float sdcyA2= sdCylinderXY(p- vec3(-1.5+1.3*cos(iTime),1.0,0.0), vec2(0.5,7.5) ); //cornea\n    float sdspA1= sdSphere( p-vec3(0.0,0.0,0.0), 6.5 );         //cabeza\n    float difcirculocylA1= differenceSDF(sdspA1, sdcyA1);   //diferencia cabeza ojo\n    float intersecionA1= intersectSDF(sdspA1,sdcyA1);     //interseccion cabeza ojo\n    \n    //cornea\n    float difcirculocylA2= differenceSDF(sdspA1, sdcyA2);   //diferencia cabeza cornea\n    float intersecionA2= intersectSDF(sdspA1,sdcyA2);     //interseccion cabeza cornea\n    \n            \n    res =opU3(res, vec3(intersecionA1,1.0,-1));  //ojo\n    res =opU3(res, vec3(intersecionA2,0.0,-1));  //ojo\n    res =opU3(res, vec3(difcirculocylA1,25.0,-1)); \n    //----------------000--------------\n    //----------------000--------------\n    \n    \n    //----------------001--------------\n    //----------------001--------------\n    //ojo iZq\n    float sdcyB1= sdCylinderXY(p- vec3(1.5,1.0,0.0), vec2(1.5,7.5) );\n    float sdcyB2= sdCylinderXY(p- vec3(1.5+cos(iTime),1.0,0.0), vec2(0.5,7.5) ); //cornea\n    float sdspB1= sdSphere( p-vec3(0.0,0.0,0.0), 6.5 );\n    float difcirculocylB1= differenceSDF(difcirculocylA1, sdcyB1);  //cabeza  -Ojo\n    float intersecionB1= intersectSDF(sdspB1,sdcyB1);   //cabeza intersccion  ojo\n    \n    \n    float difcirculocylB2= differenceSDF(difcirculocylA1, sdcyB2); //cabeza-ojo\n    float intersecionB2= intersectSDF(sdspB1,sdcyB2);   //cabeza interseccion cornea\n            \n    res =opU3(res, vec3(intersecionB1,1.0,-1)); //ojo\n    res =opU3(res, vec3(intersecionB2,0.0,-1));  //cornea\n    //----------------001--------------\n    //----------------001--------------\n    \n    \n    \n    \n    //-------boca circular\n    float sdcyC1= sdCylinderXY(p- vec3(0.0,-2.0,0.0), vec2(0.8,7.5) );\n    float sdspC1= sdSphere( p-vec3(0.0,0.0,0.0), 6.5 );\n    float difcirculocylC1= differenceSDF(difcirculocylB2, sdcyC1);  \n    float intersecionC1= intersectSDF(sdspC1,sdcyC1);   \n    res =opU3(res, vec3(intersecionC1,0.0,-1)); \n    \n    \n    \n    \n    //----------/--------Nariz\n    float sdNariz= sdSphere(p- vec3(0.0,-0.7,-6.5), 0.5 );\n    float sdNariz2= sdSphere(p- vec3(0.0,-0.7,6.5), 0.5 );\n    res =opU3(res, vec3(sdNariz,2.0,-1)); \n    res =opU3(res, vec3(sdNariz2,13.0,-1)); \n    \n    \n    //--------pelo\n    float sdspD1= sdSphere( p-vec3(0.0,0.0,0.0), 6.5 );\n    float sdbD1= sdBox(p-vec3(0.0,-2.0,0.0), vec3(7.0,6.0,7.0));\n    float difPeloD1= differenceSDF(sdspD1, sdbD1);  \n    res =opU3(res, vec3(difPeloD1,0.0,-1)); \n    \n        \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n\n   \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n   \n\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 6.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n    if(i== 50 )\n    {\n     \n           \n            vec3 p = mObj.p;\n        \t//vec3 p =  mObj.normal*0.5;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 233, 233, 257], [259, 274, 305, 305, 455], [459, 459, 497, 497, 600], [603, 647, 693, 693, 725], [727, 727, 770, 770, 802], [804, 804, 852, 852, 885], [933, 933, 963, 963, 1089], [1132, 1157, 1192, 1192, 1285], [1287, 1287, 1322, 1322, 1415], [1417, 1417, 1451, 1451, 1544], [1549, 1589, 1614, 1614, 5246], [5250, 5295, 5362, 5362, 5735], [5790, 5790, 5815, 5815, 6055], [6058, 6121, 6156, 6247, 6771], [6830, 6830, 6867, 6867, 7194], [7252, 7323, 7359, 7359, 7565], [7568, 7639, 7663, 7663, 7923], [7973, 8007, 8056, 8056, 8292], [8293, 8327, 8407, 8407, 9048], [9101, 9101, 9194, 9194, 9490], [9493, 9542, 9599, 9599, 11679]]}
{"id": "WlSfWG", "name": "Plasma Ocean", "author": "celifrog", "description": "This is so much fun forking other people's stuff and editing it. :D \nForked from- https://www.shadertoy.com/view/XsjXRm", "tags": ["ocean", "alien", "universe", "forked", "edited"], "likes": 5, "viewed": 472, "published": 3, "date": "1599679273", "time_retrieved": "2024-07-30T20:46:19.816117", "image_code": "// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n    \tvec2 rb = textureLod( iChannel1, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rb.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.1)*6.)*0.4+-0.1) /z;\n\t\tp = mix(bp,p,66.1);\n\t\tz *= -66.;\n\t\tp *= -989.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 1.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= time*.15*z++;\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)*dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*1.6)*0.21;\n    en.xz *= mm2((hash(i++*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*1111.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=5; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(11.05,12.5,111.52)*13.94+r.y)*.85+0.4;\n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) +5.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy*11.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.54+um.x*6.);\n    mat2 my = mm2(time*0.1+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx++;\n    ro.xy *= my;rd.xy *= my++;\n    \n    vec3 bro = ro;\n    vec3 brd = rd;\n\t\n    vec3 col = vec3(0.00,0.,0.0);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+-910.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+5.)*15.1))*j*-1.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,0.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(rd,ro);\n    \n    if (sph.x > -5.)\n    {\n        vec3 pos = rd+rd*sph.x*sph.x*sph.x;\n        vec3 pos2 = ro+rd*sph.y*sph.x;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.0151)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.05*nz*nz* vec3(1.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.1, 1.9);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[370, 370, 391, 391, 443], [444, 444, 470, 470, 522], [524, 524, 546, 546, 579], [581, 581, 605, 605, 891], [1003, 1048, 1083, 1083, 1306], [1308, 1328, 1352, 1352, 1550], [1552, 1552, 1589, 1589, 1715], [1717, 1717, 1752, 1752, 1971], [1973, 1973, 2000, 2000, 2287], [2289, 2289, 2370, 2370, 2609], [2611, 2633, 2696, 2696, 3236], [3238, 3284, 3323, 3323, 3510], [3512, 3512, 3569, 3569, 4873]]}
{"id": "3lBBWG", "name": "rainbow matrix", "author": "dkaraush", "description": "Rainbox matrix.", "tags": ["color", "glsl", "bitmap", "font", "rainbow", "matrix"], "likes": 29, "viewed": 1063, "published": 3, "date": "1599674823", "time_retrieved": "2024-07-30T20:46:20.672826", "image_code": "\nprecision mediump float;\n\nfloat random(vec2 v) {\n    return fract(sin(v.x * 32.1231 - v.y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x, float y) {\n    return fract(sin(x * 32.1231 - y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x) {\n    return fract(sin(x * 32.1231 + 13399.2312) * 2412.32312);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nint character(float i) {\n    if (i == 0.) return 0x7b6f; // 0\n    if (i == 1.) return 0x4d24; // 1\n    if (i == 2.) return 0x79cf; // 2\n    if (i == 3.) return 0x79e7; // 3\n    if (i == 4.) return 0x5be4; // 4\n    if (i == 5.) return 0x73e7; // 5\n    if (i == 6.) return 0x73ef; // 6\n    if (i == 7.) return 0x7924; // 7\n    if (i == 8.) return 0x7bef; // 8\n    if (i == 9.) return 0x7be7; // 9\n    if (i == 10.) return 0x7bed; // A\n    if (i == 11.) return 0x3beb; // B\n    if (i == 12.) return 0x724f; // C\n    if (i == 13.) return 0x3b6b; // D\n    if (i == 14.) return 0x73cf; // E\n    if (i == 15.) return 0x73c9; // F\n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 S = 15. * vec2(3., 2.);\n    vec2 coord = vec2(\n        fragCoord.x / iResolution.y,\n        fragCoord.y / iResolution.y + (iResolution.y - iResolution.x) / (2. * iResolution.y)\n    );\n    vec2 c = floor(coord * S);\n\n    float offset = random(c.x) * S.x;\n    float speed = (random(c.x * 3.) * 1. + 0.5) * .7;\n    float len = random(c.x) * 15. + 10.;\n    float X = c.y / len + iTime * speed + offset, _X = mod(X, 1.);\n    float u = 1. - 2. * 1.23 * _X * (1.45 * _X) * (1. - pow(_X, 9.));\n\n    float padding = 2.;\n    vec2 smS = vec2(3., 5.);\n    vec2 sm = floor(fract(coord * S) * (smS + vec2(padding))) - vec2(padding);\n    int symbol = character(floor(random(c + floor(iTime * speed)) * 15.));\n    bool s = sm.x < 0. || sm.x > smS.x || sm.y < 0. || sm.y > smS.y ? false\n             : mod(floor(float(symbol) / pow(2., sm.x + sm.y * smS.x)), 2.) == 1.;\n\n    fragColor = vec4(s ? hsl2rgb(vec3(c.x / S.x, 1., 0.5)) * u : vec3(0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 129], [130, 130, 162, 162, 238], [239, 239, 262, 262, 326], [328, 328, 374, 374, 726], [727, 727, 751, 751, 1230], [1232, 1232, 1256, 1256, 1870], [1872, 1872, 1929, 1929, 2874]]}
{"id": "wljfzd", "name": "wispy cuts", "author": "DJDoomz", "description": "mess around with timescale and speed in Buf A", "tags": ["2d", "line", "feedback", "buffer"], "likes": 21, "viewed": 518, "published": 3, "date": "1599667997", "time_retrieved": "2024-07-30T20:46:21.582394", "image_code": "void mainImage( out vec4 o, in vec2 i )\n{\n    //ugly\n    vec2 uv = i/iResolution.xy;\n    float v = 1.3-length(1.4*(uv-.5));\n\n    for(int j = 0; j < 4; j++)\n \t\to[j] = texture(iChannel0,(i+2.*float(j))/iResolution.xy)[j];\n    \n    o*=v;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define timescale 10\n#define speed 0.01\n\nfloat line(vec2 u, vec2 s, vec2 e)\n{\n    //shift coords to 0,0\n    vec2 l1 = u-s;\n    vec2 e2 = e-s;\n    //formula to find nearest projection of u on se\n    vec2 l2 = e2*(( dot(l1,e2) /(dot(e2,e2))) );\n    \n    return 1.-smoothstep(0.001,0.003,length(l1-l2));\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/iResolution.xy;\n    uv += 0.0001*sin(uv.x*80.0+iTime);\n    if(iTime < 1.)\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n    \n\n    \t// Time varying pixel color\n    \tvec3 col = 0.5 + 0.5*cos(iTime+3.0*uv.xyx+vec3(0,2,4));\n\n    \t// Output to screen\n    \to = vec4(col,1.0);\n    }\n    else\n    {\n        o = texture(iChannel0, uv);\n        vec2 start=vec2(0),end=vec2(0);\n        float seed = float(iFrame/timescale);\n        float s = sin(seed), c = cos(seed);\n        //choose a pseudo-rando slice\n        //angle\n        vec2 a = vec2(s,c);\n        //pos (0-1)\n        vec2 p = fract(vec2(s*325.253,c*9258.353));\n        start = 0.25+.5*p;\n        end = p + a;\n        if(iFrame % timescale == 0)\n        {\n            vec3 c = fract(vec3(s*83928.3523,c*9283.353,s*32985.33));\n            o.xyz += c*line(uv, start, end);\n        }\n        else\n        {\n            //shift coords to 0,0\n    \t\tvec2 l1 = uv-start;\n    \t\tvec2 e2 = end-start;\n    \t\t//formula to find nearest projection of u on se\n    \t\tvec2 l2 = start + e2*(( dot(l1,e2) /(dot(e2,e2))) );\n            if(uv.y < l2.y)\n            {\n\t            uv += a*speed;\n\t            o = texture(iChannel0, uv);\n\t        }\n        }\n    }\n    \n    //o = vec4(1)*line(uv, vec2(0.5,0.5), vec2(1,1));\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 52, 236]]}
{"id": "wtjfRd", "name": "[TWITCH] Bored circuit", "author": "evvvvil", "description": "Bored cirduit - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "lines", "demoscene", "landscape", "specular", "glow", "pattern", "scifi", "lazer", "circuit", "battery", "network", "gloss", "board", "industrial"], "likes": 28, "viewed": 976, "published": 3, "date": "1599659591", "time_retrieved": "2024-07-30T20:46:22.435114", "image_code": "// Bored circuit - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,b,tt,g;vec3 op,po,no,al,ld,cutP;\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nvec2 fb( vec3 p)\n{   \n    cutP=op=p;\n    cutP.xy*=r2(.785);\n    vec2 h,t=vec2(length(p.xz)-3.,5); //BLUE CUT PIECE\n    t.x=abs(t.x)-.4;\n    t.x=max(t.x,-(max(-p.x,abs(abs(abs(cutP.y)-2.)-1.)-.5)));\n    t.x=max(t.x,abs(cutP.y)-5.);\n    h=vec2(length(p.xz)-3.,6); //WHITE CUT PIECE\n    h.x=abs(h.x)-.15;\n    h.x=max(h.x,-(max(-p.x,abs(abs(abs(cutP.y)-2.)-1.)-.3)));\n    h.x=max(h.x,abs(cutP.y)-5.5);\n    float cutter=(abs(abs(cutP.y-8.)-10.)-3.);  \n    h.x=min(h.x,max(length(p.xz)-.6,-cutter));//WHITE CYLINDER  \n    float lazer=max(length(p.xz)-0.1,cutter+0.1);//LAZER\n    g+=0.2/(0.1+lazer*lazer*5.);\n    h.x=min(h.x,lazer);\n    t=t.x<h.x?t:h;\n    h=vec2(length(p.xz)-2.2,3);//BLACK CYLINDER CUT PIECE\n    h.x=abs(h.x)-.4;\n    h.x=max(h.x,abs(abs(cutP.y)-5.)-1.);\n    t=t.x<h.x?t:h;\n    return t;  \n}\nvec2 mp( vec3 p)\n{\n    op=p;\n    vec4 np=vec4(p,1);\n    vec2 h,t=vec2(1000);\n    np.z-=30.;\n    np.z=abs(abs(np.z)-20.)-10.;  \n    vec4 bp=np.xzyw; \n    for(int i=0;i<4;i++){\n        np.xyz=abs(np.xyz)-vec3(25.,clamp(5.5-ceil(-p.z*.05-.5)*4.,5.,15.),0);\n        bp.xyz=abs(bp.xyz)-vec3(20.,clamp(10.-ceil(-p.z*.05)*4.,10.,20.),0);\n        np.xy*=r2(.785);\n        bp.xy*=r2(.785);\n        h=fb(np.xyz); //DRAW VERTICAL FRACTAL\n        h.x/=np.w*1.5;\n        t=t.x<h.x?t:h;\n        h=fb(bp.xyz); //DRAW HORIZONTAL FRACTAL\n        h.x/=bp.w*1.5;\n        t=t.x<h.x?t:h;\n        h=vec2(bo(bp.xyz-vec3(12,0,0),vec3(1,100,1.+cos(p.z*.1)*2.)),3.);//DRAW BLACK BOXES\n        h.x/=bp.w;\n        t=t.x<h.x?t:h;\n        np*=2.;\n        bp*=2.;\n    }\n    p.z=mod(p.z-10.,20.)-10.; //WHITE SPHERES\n    h=vec2(length(p)-1.5,6.);  \n    t=t.x<h.x?t:h;  \n    h=vec2(max(p.y,abs(p.x)-65.),7.);  //TERRAIN\n    t=t.x<h.x?t:h;\n    return t;  \n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>100.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>100.) t.y=0.;\n    return t;  \n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nfloat pattern(vec2 uv){return ceil(abs(sin(uv.y*5.))-.7-.5*sin(op.y*.1+tt))+ceil(abs(sin(uv.x*1.5))-.75);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,56.52);\n    b=ceil(sin(tt*.5));\n    vec3 ro=mix(vec3(1),vec3(-2,3,1),b)*vec3(sin(tt*.5-.75)*6.,7.5,30.+sin(tt*.15)*70.),\n        cw=normalize(vec3(0,0,20.+sin(tt*.5)*20.)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n        rd=mat3(cu,cv,cw)*normalize(vec3(uv,.75)),co,fo;\n    co=fo=vec3(.2,.12,.12)-length(uv)*.1-rd.y*.3;\n    ld=normalize(vec3(0.,.5,sin(tt*.15)*.5));  \n    z=tr(ro,rd); t=z.x;\n    if(z.y>0.){\n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy).x+ e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        float lines=1.; vec2 linesUV=op.xy*.1;\n        for(int i=0;i<3;i++){      \n            linesUV=abs(linesUV)-.15;\n            lines=min(lines,pattern(linesUV));\n            linesUV*=3.;\n        }        \n        al=mix(vec3(0),vec3(.05,.15,.35),lines);  \n        float spo=exp2(7.-lines*5.);\n        if(z.y<5.)al=vec3(0.);  \n        if(z.y>5.)al=vec3(.8,.7,.8);  \n        if(z.y>6.)al=vec3(0.1,.05,.05)+lines*.025,spo=exp2(10.-lines*5.);\n        float dif=max(0.,dot(no,ld)),\n            fr=pow(1.+dot(no,rd),4.),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp+al*(a(.05)*a(.1)+.2)*(dif*vec3(.7,.6,.4)+s(4.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.000005*t*t*t));\n    }\n    co=smoothstep(0.,1.,co);\n    fragColor = vec4(pow(co+g*.4*vec3(.1,.2,.5),vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 275, 275, 318], [319, 319, 343, 343, 384], [385, 385, 403, 403, 1186], [1187, 1187, 1205, 1205, 2110], [2111, 2111, 2140, 2140, 2330], [2420, 2420, 2443, 2443, 2526], [2527, 2527, 2584, 2584, 4050]]}
{"id": "Wl2fRt", "name": "tablero-doble-textura", "author": "jorge2017a1", "description": "tablero-doble-textura", "tags": ["tablerodobletextura"], "likes": 0, "viewed": 274, "published": 3, "date": "1599620336", "time_retrieved": "2024-07-30T20:46:23.521210", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,COLOR_NO,1.0)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,COLOR_NO,3.0)); \n    res =opU3(res, vec3(planeDist4,COLOR_NO,3.0)); \n  \tres =opU3(res, vec3(planeDist5,COLOR_NO,2.0)); \n    res =opU3(res, vec3(planeDist6,COLOR_NO,2.0)); \n    \n  \n    \n    p.y=p.y-5.0;\n    \n    \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3= sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n    float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,31.0,-1)); \n   \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n\nvec3 checkerTextura(vec2 uv, float repeats) \n{\n  float cx = floor(repeats * uv.x);\n  float cy = floor(repeats * uv.y); \n  float result = mod(cx + cy, 2.0);\n  float tmp= sign(result);\n   vec3 col1=vec3(0.5);\n    \n    if (tmp<=0.0)\n        col1=vec3(0.2,0.5,1.0)*tex3D(iChannel0, mObj.p/32., mObj.normal);//azul\n    \t//col1=vec3(1.2,0.5,1.0);//rosa\n   \telse\n        col1=tex3D(iChannel0, mObj.p/32., mObj.normal);\n    \n    return col1;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  \n   \n    \n    if (id_material==1.0)\n    {\n     \n    \treturn checkerTextura(mObj.p.xz, 0.125);\n    }\n    \n    \n    if (id_material==2.0)\n    {\n     \n    \treturn checkerTextura(mObj.p.xy, 0.125);\n    }\n    \n    if (id_material==3.0)\n    {\n     \n    \treturn checkerTextura(mObj.p.zy, 0.125);\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n    \t\t\n            return colobj;\n        }\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,6.0,-25.0);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    rd.x=rd.x+cos(t)*0.5;\n    rd.z=rd.z+sin(t)*0.5;\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n    \n   \n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 233, 233, 257], [259, 274, 305, 305, 455], [458, 458, 503, 503, 594], [596, 640, 686, 686, 718], [720, 720, 763, 763, 795], [797, 797, 845, 845, 878], [926, 926, 955, 955, 1081], [1083, 1083, 1113, 1113, 1239], [1282, 1307, 1342, 1342, 1435], [1437, 1437, 1472, 1472, 1565], [1567, 1567, 1601, 1601, 1694], [1700, 1700, 1734, 1734, 1831], [1834, 1874, 1899, 1899, 3485], [3489, 3534, 3601, 3601, 3974], [4029, 4029, 4054, 4054, 4294], [4297, 4360, 4395, 4486, 5010], [5069, 5069, 5106, 5106, 5433], [5491, 5562, 5598, 5598, 5804], [5807, 5878, 5902, 5902, 6162], [6212, 6246, 6295, 6295, 6531], [6532, 6566, 6646, 6646, 7287], [7289, 7289, 7335, 7335, 7724], [7726, 7777, 7824, 7824, 8163], [8217, 8217, 8310, 8310, 8631], [8634, 8683, 8740, 8740, 10065]]}
{"id": "3t2fRt", "name": "fuzzy B&W bathroom Tiles", "author": "celifrog", "description": "Some edits done, sorry for all of the forks just trying to move over and learn asap for fun  from laggy as heck python that I'm sick off.\nForked from-https://www.shadertoy.com/view/ldGSzc", "tags": ["fork", "bathroom"], "likes": 3, "viewed": 263, "published": 3, "date": "1599618635", "time_retrieved": "2024-07-30T20:46:24.367946", "image_code": "\nmat2 rotate(float a)\n{\n    float ca = cos(a); float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(132.9898,78.233))) * 1433758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.8 + 0.1;\n}\n\nfloat value (float x, float randx, float c)\n{\n    float a = min(x/randx, 1.0);\n    \n    float d = clamp(1.0 - (randx + c +randx+randx*randx+c+c+c*c*c*x*x*randx*randx*randx), 117.1, 1.9);\n    float b = min(1.0, (1.0 - x) / d);\n    return a + (b - 1.11-randx*randx*randx*randx*randx*x);\n}\n\nfloat polynoise(vec2 p, float sharpness)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2(rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x, rndv.y * sharpness*rndv.y);\n    float by = value(pt.y, rndv.y, rndv.x * sharpness*sharpness*rndv.x);\n    return min(bx, by) * (0.9 + abs(rand(seed.xy * 0.01)) * 0.7);\n}\n\n\nfloat polyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    mat2 r1 = rotate(7711111555111.2);\n    mat2 r2 = rotate(-799991.4);\n    mat2 r3 = rotate(-777777777.0);\n    \n    // 1st octave\n    float m1 = polynoise(p*p*p*r2 * r2 *r2 *r2, .2);\n    \n    m1 += polynoise ( r1 * (vec2(0.5, 0.5) + p), .2);\n    m1 += polynoise ( r3 * (vec2(0.35, 0.415) + p), .2);\n    m1 *= 0.333 * 0.75;\n    \n    // 2nd\n    float m2 = polynoise (r3 * (p * 2.0*p*p*p*p), .3);\n    m2 += polynoise (r2 * (p + vec2(0.2, 0.6)) * 2.0, .2);\n    m1 += m2 * 0.5 * 0.25*-m2*0.1*-m2*0.3*-m2*0.4*-m2*-m2*-m1*-m2*m2*-m1*-m1*-m1*-m1*-m1*-m2*-m1*-m2*-m1*-m2*0.3*0.2*-m2*-m1*-0.1*-m2*0.3*-m2*m2*m2*m1*m2*-m1*m2*m1*m2*m1*m2*m1*m2*m2*m2*0.90001;\n\t\n    return m1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    float scale = 10.0;\n    vec2 p = uv +uv  +scale+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv+uv*uv;\n    p.x += iTime;\n    \n    float m = polyfbm(-p+p+p);\n    fragColor = vec4(m*m-fragColor*fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 101], [103, 103, 124, 124, 199], [201, 201, 220, 220, 259], [261, 261, 306, 306, 547], [549, 549, 591, 591, 895], [898, 898, 921, 921, 1614], [1616, 1616, 1673, 1673, 2009]]}
{"id": "3lBBzd", "name": "Day 262", "author": "jeyko", "description": "this used to look nicer, but meh", "tags": ["mdtmjvm"], "likes": 7, "viewed": 651, "published": 3, "date": "1599600022", "time_retrieved": "2024-07-30T20:46:25.428112", "image_code": "// Fork of \"Day 261\" by jeyko. https://shadertoy.com/view/3tjfzc\n// 2020-09-08 09:44:30\n\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE from https://www.shadertoy.com/view/MlfSRN by demofox\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.7;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 0.5\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 5.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\n", "buffer_a_code": "// proceed with caution. absolute mess\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\n// ----------\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n    /*\n    if(ss == 0.){\n    \n    \n    } else if(ss == 1.){\n     \troll = r12(frame + 38.);\n    } else if(ss== 2.){\n     \troll = r12(frame - 13. - period*2.);\n    } else if(ss== 3.){\n     \troll = r12(frame + 44. - period*3.);\n    } else if(ss== 4.){\n     \troll = r12(frame - 64.);    \n    } else if(ss== 5.){\n     \troll = r12(frame - 24.);\n    }*/\n     \n    float deb;\n    \n    if (stroke == 0) {\n    \tdeb = smoothstep(df,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        vec4 n = valueNoise(guv,1.);\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08;\n        \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec4 n = valueNoise(guv,1.);\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.4;\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 1.25), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    \n        \n    \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*2000.;\n    \n    df = dFdx(uv.x);\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 c = vec3(0.5,.35,0.25)*2.;\n    \n    vec3 col = iFrame < 2 ? c : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    // COOLINE\n    float id = floor(mod(frame/period,10.));\n        \n    seg = floor(frame/period );\n        \n    if(mod(float(iFrame)*SPEED,1.) < SPEED && frame < 9.){\n    \t\n        \n    \tvec2 roll = r12(frame + 1.);\n        //d = bspline( uv + (r12(seed)*2. - 1.)*0.7 ) - 0.001;\n\t\n        //d = length( luv = ( uv + (r12(seed)*2. - 1.)*0.7)  ) - 0.2*roll.x;\n\t\td = length( luv = ( uv + (r12(seed + 11.)*2. - 1.)*0.2)  ) - 0.1*roll.x;\n\t\n        \n        if(id<1.){\n            col = colour( d + 0.002 + 0.003, col, vec3(0), 0,5,8.,0.);\n       \n        } else if(id>2. && id < 3.4) {\n       \n            d = bspline( uv );\n\t\n            //col = colour( d + 0.002 + 0.00, col, vec3(1), 0,1,3.,0.);\n        \t\n        } else if(id>8.) {\n        \n            col = colour( d, col, c, 0,5,22.,0.);\n        \t\n        }\n  \n    }\n    \n    \n    //col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 219, 219, 276], [277, 277, 310, 310, 839], [840, 840, 858, 858, 1186], [1189, 1189, 1246, 1246, 2124]]}
{"id": "wtBBzt", "name": "Yeeted Multipass Nebula Mobile", "author": "Zi7ar21", "description": "Danny boi here you go", "tags": ["raymarch", "dither", "volumetric", "volumetric", "raymarcher", "nebula", "slow", "multipass", "nonrealtime"], "likes": 1, "viewed": 244, "published": 3, "date": "1599596790", "time_retrieved": "2024-07-30T20:46:26.309755", "image_code": "// Fork of \"Yeetedly Slow Multipass Nebula\" by Zi7ar21. https://shadertoy.com/view/ttsfDj\n// 2020-09-08 20:22:17\n\n// ^^^ Switch Between Buffer A and B ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN\n// 2020-08-18 22:34:07\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Rendering and Settings\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.5\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 8\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 0.1\n\n// Tiles, more means easier on the Hardware\n#define TILES 64\n// So kindly made by LoicVDB uwu\n\n// Amount of distortion to apply\n#define DISTORT_AMOUNT 2.0\n\n// Offset the 4D Noise, Basically a different Nebula\n#define W_OFFSET 0.5\n\n// Difference in offset between color channels\n#define W_DIFFERENCE 0.01\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n\n// Simplex 4D Noise\n// by Ian McEwan, Ashima Arts\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#simplex-noise\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n  return p;\n}\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,\n                        0.309016994374947451);\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\n// 2D Noise for Dithering\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fBm Noise\nfloat fbm(vec4 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; ++i){\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// 4D Nebula Function\nfloat distort(vec3 raypos, float variance){\n\tfloat distort = 0.0;\n\tdistort = distort+(DISTORT_AMOUNT*fbm(vec4(raypos, variance)));\n\treturn distort;\n}\n\nfloat nebulanoise(vec3 raypos, float variance, float base){\n\tfloat density = clamp((fbm(vec4((raypos)+distort(raypos, variance), base))-0.25)*8192.0, 0.0, 1.0)/(pow(distance(vec3(0.0), raypos),4.0)*2.0);\n\treturn density;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n\tfloat distorigin=0.0;\n    float densityaddr=0.0;\n    float densityaddg=0.0;\n    float densityaddb=0.0;\n\tvec3 density=vec3(0.0);\n    vec3 raypos = camerapos;\n\tvec3 raydirmod = (raydir*(hash13(vec3(coord, iFrame))+1.0))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n    \traypos = raypos + raydirmod;\n\t\tdensityaddr = nebulanoise(raypos/4.0,  W_OFFSET-W_DIFFERENCE, W_OFFSET)*DENSITY;\n\t\tdensityaddg = nebulanoise(raypos/4.0,  W_OFFSET, W_OFFSET)*DENSITY*0.5;\n        densityaddb = nebulanoise(raypos/4.0,  W_OFFSET+W_DIFFERENCE, W_OFFSET)*DENSITY*0.25;\n        density = vec3(density.r+densityaddr, density.g+densityaddg, density.b+densityaddb);\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n\t// LoicVDB's Hyper Epic Tiles Function\n\tint index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\t// Camera Orientation\n\tvec3 xdir = vec3(1.0,0.0,0.0);\n\tvec3 ydir = vec3(0.0,1.0,0.0);\n\tvec3 zdir = vec3(0.0,0.0,1.0);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(0.0, 0.0, -8.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tvec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // LoicVDB: add the color and increase the sample count\n    fragColor += vec4(raymarched, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1043, 1043, 1099, 1149, 1256]]}
{"id": "ttBBzt", "name": "3 not equal 3 - Bug on iMac", "author": "GregRostami", "description": "Scroll to the bottom of the shader to see the problem.\nOn my iMac, the left side of my screen, the shader is bright, while the right side is normal.\n\nPlease let me know if you also see this problem on your computer.\nThank you.", "tags": ["glslbug"], "likes": 8, "viewed": 374, "published": 3, "date": "1599596609", "time_retrieved": "2024-07-30T20:46:27.165467", "image_code": "// 3.0 does not equal 3.0 ?!\n// Please see the bottom of this shader for the GLSL bug on iMac\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 255.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*8., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(651, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.95, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.90, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.8, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\n// Here's where you would normally have your final void mainImage()\nvec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n{\n\tfloat off = sin(iTime/1.75);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .8)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\treturn vec4(c, 1); // At the end of your shader, replace the fragColor with this return. \n}\n\n// Box-filter by Greg Rostami\nvoid mainImage( out vec4 o, vec2 u )\n{\n    o-=o;\n    float x, y, s;\n    \n    float A = 3.0;  // In this line A is set to 3.0 ... the problem is solved if you set A to 2.9999\n    \n    u.x/iResolution.x >.5 ? s = 1.0/3.0 : s = 1.0/A;  // Isn't A = 3.0 ?? Why on my iMac is the left side bright??\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) o += fC(vec2(x,y)+u);\n        \n\to /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[865, 865, 900, 900, 965], [967, 967, 1005, 1005, 1084], [1086, 1086, 1124, 1220, 1338], [1350, 1350, 1382, 1382, 1955], [1957, 1957, 1990, 1990, 3593], [3595, 3595, 3629, 3629, 4375], [4377, 4377, 4410, 4410, 5230], [5232, 5232, 5275, 5312, 6571], [6573, 6573, 6616, 6616, 7603], [7605, 7605, 7638, 7638, 7932], [7934, 7934, 7958, 7958, 8029], [8031, 8031, 8056, 8056, 8091], [8093, 8161, 8246, 8246, 8764], [8766, 8796, 8834, 8834, 9190]]}
{"id": "tlSBzt", "name": "op-Twist-v1", "author": "jorge2017a1", "description": "op-Twist-v1", "tags": ["twist"], "likes": 4, "viewed": 323, "published": 3, "date": "1599596511", "time_retrieved": "2024-07-30T20:46:28.195712", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n\nvec3 opTwist( vec3 pp )\n{\n\n vec3 p=pp; \n \tconst float CubeDist = 3.0;\n\tconst float RotationFactor = 0.1;\n    \n    float c = cos(RotationFactor * p.z - iTime*0.5);\n    float s = sin(RotationFactor * p.z - iTime*0.5);\n    mat2 m = mat2(c, -s, s, c);\n    p = vec3(m * p.xy, p.z);\n\n    \n\treturn p;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    \n    p.y=p.y-5.0;\n\n    \n    p= opTwist( p );\n    \n\tvec3 q=p;\n    float cz=30.0;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t \n\n    \n    float sdb1= sdBox(p-vec3(0.0,0.0,0.0), vec3(15.0,15.0,20.0) );\n    float sdb2= sdBox(p-vec3(0.0,0.0,0.0), vec3(14.0,14.0,22.0) );\n    \n    float dif =differenceSDF(sdb1, sdb2) ;\n\tres =opU3(res, vec3(dif,24.0,-1)); \n    \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(2.0, 20.0, -10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -2.0, -20.0, 100.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    vec3 ro=vec3(0.0,6.0,-25.0-t);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n \n\n//----------------------------------------------------\nfloat hex(vec2 p, float r2)\n{\n    p.x *= 1.16;\n    p.y += mod(floor(p.x), 4.0) * 0.5;\n    p = abs((mod(p, 1.00) - 0.5));\n    return abs(max(p.x * 1.5 + p.y, p.y * 2.0) - r2);\n}\n\nvec4 hexColor(vec2 pos)\n{\n    vec2  p   = pos * 0.2;\n    float r1  = 0.25;\n    float r2  = -0.005;\n    float hexv=hex(p,1.0 - r2);\n    \n    vec4 hColor = vec4(smoothstep(.0, r1, hexv));\n    hColor = (1.0 - hColor) * 0.65;\n    return mix(hColor,vec4(0.35,0.53,1.0,1.0),hexv);\n}\n//----------------------------------\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n \t\n    \n    if(i== 32 )\n    { \n    \tvec4 v4= hexColor(mObj.p.xz);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n      \n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 195, 226, 226, 376], [379, 423, 469, 469, 501], [503, 503, 546, 546, 578], [580, 580, 628, 628, 661], [710, 710, 740, 740, 866], [910, 910, 935, 935, 1205], [1206, 1246, 1271, 1271, 1852], [1856, 1901, 1968, 1968, 2341], [2396, 2396, 2421, 2421, 2661], [2664, 2727, 2762, 2853, 3377], [3436, 3436, 3473, 3473, 3800], [3858, 3929, 3965, 3965, 4171], [4174, 4245, 4269, 4269, 4529], [4579, 4613, 4662, 4662, 4898], [4899, 4933, 5013, 5013, 5654], [5707, 5707, 5800, 5800, 6096], [6099, 6148, 6205, 6205, 7486]]}
{"id": "WlBBzd", "name": "Nebula 13", "author": "Leria", "description": "A bubble pushed in dust, Nebula\nParameters control are not perfect", "tags": ["noise", "bubble", "nebula", "preintegration"], "likes": 4, "viewed": 410, "published": 3, "date": "1599583237", "time_retrieved": "2024-07-30T20:46:29.244908", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( .5 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 7.5), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(pow(velocity,3.))/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate = disp_turb*fbm(p*4.); //generation of a local dispersion = turbulence * rate\n\treturn 1.60*DISPERSION_VELOCITY*disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = 0.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n            \n            \n            float rad_bubl = RADIUS/1.7; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(-1.,1.,-1.);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            //push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t//float l = exp(-.5*SQR(d/2.));\n\n            float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n            \n\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n\n            \n            float dispersion_turbulence = ( clamp( mask,\n                               \t  0.,\n                                  1.) );            \n                                    \n            //DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); //local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            //energy \n            float scale = 1.5;\n            float energy_transfer_rate = energy_t_r(VT, scale); //energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            //primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v*v)/(4.*10.))       \n            \n            //preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(.1, .6, 10.);\n            vec3 prof = vec3(0);\n            if(vt == 0.)\n            {\n                prof = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                prof = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n            prof = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            vec3 rgb_t = exp(-prof);    \n            \n            vec3 col_loc = vec3(.8, .5, .1);\n               \n            float epsilon = k/100.;\n        \tfloat dif = abs(clamp((energy_transfer_rate - energy_t_r(local_velocity(p+epsilon*(p-lightpos), dispersion_turbulence), scale))/epsilon\n                              , -1.0\n                              , 1.0  ));\n            \n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float sun = 0.1*1./size,//exp(-smoothstep(0., 1./size, 1./(std_dev*2.51)*exp(-(X*X)/(2.*(std_dev*std_dev))))),\n                shadow = 1.,\n                reflec = dif;\n            \n    \t\t//blending\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n        }            \n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(iTime); C.yz *= rot2(m.y);\n    R.xz *= rot2(iTime); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .8*pow(texture(iChannel0,fragCoord*2./360.+vec2(degree,degree2)).rrr, vec3(10));\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1478, 1478, 1503, 1516, 1882], [1884, 1884, 1909, 1922, 2267], [2269, 2269, 2288, 2288, 2381], [2383, 2402, 2478, 2478, 2525], [2527, 2527, 2559, 2559, 2579], [2581, 2581, 2615, 2615, 2637], [2724, 2724, 2765, 2765, 2801], [2803, 2803, 2889, 2889, 2924], [2926, 2926, 2969, 2969, 3009], [3011, 3011, 3035, 3035, 3083], [3085, 3085, 3125, 3125, 3429], [3431, 3431, 3455, 3455, 3519], [3521, 3521, 3576, 3576, 3627], [3629, 3629, 3677, 3677, 3819], [8539, 8539, 8596, 8596, 9424]]}
{"id": "WlSBRt", "name": "Bhulia", "author": "jeyko", "description": "scribbley loop-a-doos", "tags": ["paint", "watercolor", "watercolour"], "likes": 21, "viewed": 762, "published": 3, "date": "1599557096", "time_retrieved": "2024-07-30T20:46:30.287120", "image_code": "// Fork of \"Day 261 wip\" by jeyko. https://shadertoy.com/view/ttBBRc\n// 2020-09-08 09:21:35\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE from https://www.shadertoy.com/view/MlfSRN by demofox\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.4;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 1.\n\n#define pointa 10.\n    \n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\n", "buffer_a_code": "\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\n\nvec2 guv;\n\n// ----------\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam){\n    \n\t\n    \n    float deb;\n    \n    if (stroke == 0) {\n    \tdeb = smoothstep(df,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 t = texture(iChannel2,guv);\n    \n    cb*=1. - smoothstep(1.,0.,abs(db)*7. + t.z*1.53)*0.2;\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        \n    \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 1.25), 0.));\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    }\n        \n    return co;\n}\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\nfloat seed = 0.;\nconst int cnt = 5;\n\nfloat SplineValue(in float t)\n{\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.01;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += na.x*0.7 - nb.x*0.01;\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    return res;\n}\n\nfloat F ( in vec2 coords )\n{\n    // time in this curve goes from 0.0 to 10.0 but values\n    // are only valid between 2.0 and 8.0\n    float T = coords.x*float(cnt)*1. + 1.0;\n    return SplineValue(T) - coords.y;\n}\n\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    int offs = 4;\n    \n    float frame = floor(float(iFrame - offs)*SPEED);\n    \n    seed = r11(frame)*2000.;\n    \n    df = dFdx(uv.x);\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 col = frame < 2. ? vec3(1) : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    // COOLINE\n    \n    \n    if(mod(float(iFrame)*SPEED,1.) < SPEED){\n    \tvec2 roll = r12(seed);\n        \n        d = SDF( uv + (r12(seed)*2. - 1.)*0.7 ) - 0.001;\n\t\n        \n        if(frame < pointa){\n    \t\tcol = colour( d, col, vec3(0.00,0.00,0.0), 0,2,9.);\n        } else {\n        \tcol = colour( d + 0.005, col, vec3(1.), 0,1,4.);\n        }\n        \n        float lseed = seed;\n        vec2[4] points;\n        \n        //if(frame > pointa && frame < pointa + 7.){\n        if(frame > pointa + 20. && frame < pointa + 200.){\n        \n        \tlseed +=4.7;\n        \tpoints = vec2[](r12(lseed),r12(lseed*1.221),r12(lseed*1.5),r12(lseed*1.2));\n        \n            for(int i = 0; i < 4; i++){\n                points[i] = (points[i]*2. - 1.)*0.5;\n\n                points[i].xy *= 1.5;\n            }\n        \n        \td = sdPolygon( points, uv ) - 0.00;\n\t\t\n        \t//col = colour( d, col, pal(0.7,0.2,vec3(6,3,4. - roll.x*1.6),0.5,seed)*1.1, 1,0,9.);\n\t\t\n        \n        } else if (frame < 4.){\n        \tlseed +=1.7;\n        \tpoints = vec2[](r12(lseed),r12(lseed*1.221),r12(lseed*1.5),r12(lseed*1.2));\n        \n            for(int i = 0; i < 4; i++){\n                points[i] = (points[i]*2. - 1.)*0.5;\n\n                points[i].x *= 2.5;\n            }\n        \n        \td = sdPolygon( points, uv ) - 0.00;\n\t\t\n        \tcol = colour( d, col, pal(0.5,0.4,vec3(3,3,4. - roll.x*1.6),0.5,seed)*1.1, 1,2,49.);\n\t\t\n        \n        }\n        \n        \n    }\n    \n    \n    //col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 222, 222, 279], [280, 280, 313, 313, 842], [843, 843, 861, 861, 1189], [1192, 1192, 1249, 1249, 2127]]}
{"id": "wt2fzc", "name": "smoothing band in sphere tracing", "author": "FabriceNeyret2", "description": "in addition to smart antialiasing of [url]https://shadertoy.com/view/Wt2fzV[/url], \nhere we interpolate to avoid banding artifact ( pseudo-shading = iteration , + color from hit point )\n\nMouse.x : ref separator   SPACE: show where oversampling is done", "tags": ["raytracing", "raymarching", "antialiasing", "spheretracing", "sampling", "optimization", "adaptive", "gpmipmap", "spacefungus", "raysurfing"], "likes": 22, "viewed": 599, "published": 3, "date": "1599552826", "time_retrieved": "2024-07-30T20:46:31.165771", "image_code": "// adapted from https://shadertoy.com/view/Wt2fzV\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n//#define M(U,l)          T(U,l).w\n  #define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n   \n    O -= O;                             // background\n    vec4 C = vec4(0);\n\n    float n = float(N),\n       // m = M( u, 3 ),                // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    sep = u.x > s;\n    if ( sep\n     //  && abs(m-M(u,0)) > eps ) {     // neighborhood does not agree\n         && length( T(u,3) - T(u,0) ) > eps ) { // thanks Gijs !\n        for (int k=0; k<N*N; k++) {     // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            C += f(  U +  2.*D/R.y , iTime);\n        }\n        C /= n*n;\n    }\n    else                                // LOD#0 is ok\n        C = T( u, 0 ),\n        keyToggle(32)                   // SPACE: show red/blue where not oversampled\n            ? C.r -= .5*C.a, C.b += .5*(1.-C.a) , C.a = 1.: n;\n        \n    O = mix( O, C, C.a );\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );         // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\nbool       sep = true;    // to separate left/right cases\n\n// Space fungus https://www.shadertoy.com/view/lsSBWh\n\n#define map(q) (                                                     \\\n    t = max( length(q) - 9.,                        /* Sphere */     \\\n             abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ), /* EggCarton */  \\\n    t = max( t, 8.5-length(q) ),                    /* inner hole */ \\\n    t )\n//  q = mod(q,.5)-.25, t = max(t,.2-length(q) ),    /* cheese holes  */\n\nvec4 f(vec2 U, float t) {\n    float a,b,                                        // materials id\n        _t, c = 1., s = .015;                         // color (pseudo-shading), delta per iteration\n    mat2  rot = mat2( cos( .1*t + vec4(0,33,11,0)) );  \n    vec3  D = normalize( vec3(U,-1) ),                // ray direction\n          p = vec3(0,0,13), q;                        // ray origin, then current point on ray\n    D.xz *= rot, D.yz *= rot,                         // rotate camera\n    p.xz *= rot, p.yz *= rot;\n\n    for ( ; c > 0. && t > .01 ; c -= s )              // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += t*D;                                     // sphere-tracing step\n\n    if ( c > 0. && sep )  // && abs(t-abs(a)/9.) < 1e-4 && t > 1e-4 ) // [ trying to avoid the artifact turnedaround by the min ]\n        c += s * ( 1. - 2.3*t/.01 ),  // pseudo-shading: interpolate between iterations [why this ? + not perfect ]\n        t = min( _t/t*(_t-t), .01 ),  // Taylor series estimation of true distance [ min: because an artifact I don't understand. would be better without ]\n        p += t*D, t = map(p);         // go there and reeval, to correct hit point material \n    \n    vec4 O = vec4(c);                                 // output color\n    if (c > 0.) O.r -= b/30., O.g -= a, O*=O,         // coloring\n                O.a = 1.;                             // hit -> opaque\n       else     O -= O;\n    return O;\n}", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    sep = u.x > ( iMouse.z>0. ? iMouse.x : R.x/2. );\n\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime );\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 516, 516, 1579]]}
{"id": "tljfzc", "name": "mul_dot", "author": "neoe", "description": "some simple pattern", "tags": ["simple"], "likes": 4, "viewed": 276, "published": 3, "date": "1599551539", "time_retrieved": "2024-07-30T20:46:32.029462", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tint c =   int(float(iFrame) +10000.*fragCoord . x * fragCoord . y) % 3 ;\n\tif ( c == 0 ) {\n\t\tfragColor = vec4( 1 , 0 , 0 , 1 ) ;\n\t} else if ( c == 1 ) {\n\t\tfragColor = vec4( 0 , 1 , 0 , 1 ) ;\n\t} else {\n\t\tfragColor = vec4( 0 , 0 , 1 , 1 ) ;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 305]]}
{"id": "wt2Bzc", "name": "Misty Flight", "author": "dr2", "description": "Riding the thermals", "tags": ["cloud", "landscape", "fog", "aircraft", "fly"], "likes": 7, "viewed": 763, "published": 3, "date": "1599550684", "time_retrieved": "2024-07-30T20:46:32.882182", "image_code": "// \"Misty Flight\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 flyerMat[2], flMat;\nvec3 qHit, flyerPos[2], flPos, trkA, trkF, sunDir, noiseDisp;\nfloat dstFar, tCur, fogFac;\nint idObj;\nbool loRes;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, a, s;\n  q = 0.1 * p;\n  qRot = 2. * mat2 (0.8, -0.6, 0.6, 0.8);\n  a = 1.;\n  f = 0.;\n  s = 0.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (q);\n    s += a;\n    a *= 0.5;\n    q *= qRot;\n    if (loRes && j == 3) break;\n  }\n  return 8. * f / s;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, szFac;\n  szFac = 0.25;\n  dMin = dstFar / szFac;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) / szFac;\n    q.xy = Rot2Cs (vec2 (abs (q.x) + 0.2, q.y), sin (- pi / 6. + vec2 (0.5 * pi, 0.)));\n    d = max (PrRoundBoxDf (vec3 (Rot2Cs (q.xz, sin (- pi / 6. + vec2 (0.5 * pi, 0.))),\n       q.y).xzy, vec3 (0.8, 0., 1.), 0.015), -0.8 - q.z);\n    DMINQ (1 + k);\n  }\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{   // adapted from nimitz's \"Oblivion\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx);\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q = 2. * q + 0.2;\n    a *= 0.7;\n  }\n  return f;\n}\n\nfloat FogDens (vec3 p)\n{\n  return 0.3 * fogFac * TriNoise3d (0.1 * (p + noiseDisp)) * (1. - smoothstep (8., 15., p.y));\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{  // adapted from \"Sailing Home\"\n  float s, ds, f, fn;\n  s = 2.;\n  ds = 0.5;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.9, 0.9, 0.85) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * smoothstep (0.9 * s, 2. * s, dHit), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, skyCol;\n  float dstGrnd, dstObj;\n  noiseDisp = 0.02 * tCur * vec3 (-1., 0., 1.) + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogFac = 0.2 + 0.8 * smoothstep (0.1, 0.4, 0.5 - abs (mod (0.05 * tCur, 1.) - 0.5));\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  skyCol = vec3 (0.5, 0.6, 0.9) - rd.y * 0.2 * vec3 (1., 0.5, 1.) +\n     0.2 * vec3 (1., 0.6, 0.1) * pow (clamp (dot (sunDir, rd), 0., 1.), 32.);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      col = mix (((idObj == 1) ? vec3 (1., 0., 0.) : vec3 (0., 0., 1.)), vec3 (1.),\n         step (0.02, abs (abs (qHit.x) - 0.65)));\n      col = mix (col, vec3 (1., 1., 0.), step (0.8, qHit.z));\n      vn = ObjNf (ro);\n      col = col * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (16. * ro, vn, 1.);\n      col = mix (vec3 (0.5, 0.8, 0.4), vec3 (0.6, 0.6, 0.65), smoothstep (2., 6., ro.y)) *\n         (0.7 + 0.3 * Fbm2 (2. * ro.xz));\n      col *= 0.4 + 0.6 * max (dot (vn, sunDir), 0.);\n    }\n    col = mix (vec3 (0.5, 0.6, 0.9), col,\n       exp (- 2. * clamp (5. * (min (dstGrnd, dstObj) / dstFar - 0.8), 0., 1.)));\n  } else col = skyCol;\n  col = FogCol (col, roo, rd, min (dstGrnd, dstObj));\n  return col;\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 2. * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, flyVel, vDir, hSum, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  }\n  flyVel = 1.;\n  trkA = vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  vDir = sign (0.5 * pi - abs (az));\n  loRes = true;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    t = flyVel * tCur + vDir * (2. + 3. * float (k));\n    FlyerPM (t);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    hSum = 0.;\n    for (float j = 0.; j < 5.; j ++) hSum += GrndHt (TrkPath (t + 0.5 * vDir * (j - 1.)).xz);\n    flyerPos[k].y = 6. + hSum / 5.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t);\n  ro = flPos;\n  hSum = 0.;\n  for (float j = 0.; j < 5.; j ++) hSum += GrndHt (TrkPath (t + 0.5 * (j - 1.)).xz);\n  ro.y = 6. + hSum / 5.;\n  loRes = false;\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 100.;\n  sunDir = normalize (vec3 (1., 1.5, -1.));\n  rd = vuMat * (normalize (vec3 (uv, zmFac)) * flMat);\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2Bzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[643, 643, 666, 666, 953], [955, 955, 989, 989, 1469], [1471, 1471, 1493, 1493, 1632], [1634, 1634, 1656, 1656, 2101], [2103, 2103, 2136, 2136, 2319], [2321, 2321, 2342, 2342, 2597], [2599, 2599, 2623, 2623, 2657], [2659, 2659, 2682, 2682, 2716], [2718, 2718, 2745, 2783, 3036], [3038, 3038, 3062, 3062, 3159], [3161, 3161, 3215, 3247, 3631], [3633, 3633, 3668, 3668, 5133], [5135, 5135, 5159, 5159, 5212], [5214, 5214, 5237, 5237, 5298], [5300, 5300, 5323, 5323, 5393], [5395, 5395, 5419, 5419, 5793], [5795, 5795, 5851, 5851, 7095], [7097, 7097, 7143, 7143, 7190], [7192, 7192, 7228, 7228, 7434], [7436, 7436, 7466, 7466, 7579], [7581, 7581, 7612, 7612, 7676], [7710, 7710, 7734, 7734, 7799], [7801, 7801, 7825, 7825, 7937], [7939, 7939, 7964, 7964, 8150], [8152, 8152, 8173, 8173, 8328], [8330, 8330, 8359, 8359, 8571], [8573, 8573, 8612, 8612, 8792]]}
{"id": "wljfRc", "name": "2D Julia Set", "author": "milesWaugh", "description": "Use fullscreen", "tags": ["juliaset"], "likes": 3, "viewed": 292, "published": 3, "date": "1599542559", "time_retrieved": "2024-07-30T20:46:33.749862", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(0.0);\n    for(int i=-1; i<2; i++){\n        for(int j=-1; j<2; j++){\n            vec4 add = texture(iChannel0,uv+vec2(float(i)/iResolution.x,float(j)/iResolution.y));\n            float div = 4.0;\n\t\t\tif(abs(i)>0||abs(j)>0){\n                div = 2.0;\n                if(abs(i)>0&&abs(j)>0){\n                    div = 1.0;\n                }\n            }\n            col += add*div;\n        }\n    }\n    fragColor = col/16.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 540]]}
{"id": "wtjfR3", "name": "simple street", "author": "jorge2017a1", "description": "simple street", "tags": ["simplestreet"], "likes": 8, "viewed": 326, "published": 3, "date": "1599524876", "time_retrieved": "2024-07-30T20:46:34.820998", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec3 CasaDoble(vec3 p)\n{    \n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float cs1ParedFrente= sdRoundBox( p- vec3(-20.0,17.0,0.0), vec3(5.0,25.0,15.0), 1.0 );\n    float cs1Marquesina= sdRoundBox( p- vec3(-20.0,17.5,0.0), vec3(10.0,0.4,15.0), 1.0 );\n    \n    float cs1Linea1= sdRoundBox( p- vec3(-20.5,4.5,-12.0), vec3(7.0,0.5,4.5), 1.0 );\n    float cs1Linea2= sdRoundBox( p- vec3(-20.5,4.5, 12.0), vec3(7.0,0.5,4.5), 1.0 );\n    \n    float cs1Puerta= sdRoundBox( p- vec3(-13.0,2.0,0.0), vec3(8.5,10.0,4.0), 1.0 );\n    float cs1PuertaInt= sdRoundBox( p- vec3(-16.0,2.0,0.0), vec3(0.5,9.5,3.5), 1.0 );\n    \n    float cs1VentanaSup1= sdRoundBox( p- vec3(-13.0,25.0,-4.0),vec3(3.5,4.0,2.0), 1.0 );\n    float cs1VentanaSup2= sdRoundBox( p- vec3(-13.0,25.0,4.0), vec3(3.5,4.0,2.0), 1.0 );\n    float cs1VentanaSup1int= sdRoundBox( p- vec3(-16.0,25.0,-4.0),vec3(0.4,3.5,2.0), 1.0 );\n    float cs1VentanaSup2int= sdRoundBox( p- vec3(-16.0,25.0,4.0), vec3(0.4,3.5,2.0), 1.0 );\n    \n    \n    res =opU3(res, vec3(cs1Linea1,12.0,MATERIAL_NO)); \n    res =opU3(res, vec3(cs1Linea2,11.0,MATERIAL_NO)); \n    \n    //restar puerta con pared    \n     float dif= differenceSDF(cs1ParedFrente, cs1Puerta); \n     dif= differenceSDF(dif, cs1VentanaSup1); \n     dif= differenceSDF(dif, cs1VentanaSup2); \n    \n    \n    //ventanas negras\n    res =opU3(res, vec3(cs1VentanaSup1int,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(cs1VentanaSup2int,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(cs1PuertaInt,0.0,MATERIAL_NO)); \n    \n    \n    float cs1Banqueta= sdRoundBox( p- vec3(-10.0,-6.0,0.0), vec3(8.0,0.5,18.0), 1.0 );\n    float cs1Banqueta2= sdRoundBox( p- vec3(5.0,-8.0,0.0), vec3(20.0,0.5,20.0), 1.0 );\n    res =opU3(res, vec3(cs1Banqueta,13.0,MATERIAL_NO)); \n    res =opU3(res, vec3(cs1Banqueta2,1.0,MATERIAL_NO)); \n    \n    \n    res =opU3(res, vec3(cs1Marquesina,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(dif,30.0,MATERIAL_NO)); \n    \n    \n    //postes\n    float sdcy= sdCylinderXZ(p-vec3(-2.0,0.0,0.0), vec2(0.5,25.0));\n    float sdsp1= sdSphere(p-vec3(-2.0,25.0,0.0), 1.5 );\n    res =opU3(res, vec3(sdcy,14.0,MATERIAL_NO)); \n    res =opU3(res,vec3(sdsp1,18.0,MATERIAL_NO)); \n    \n    \n    //bote basura\n    float sdc2= sdCylinderXZ( p- vec3(-1.5,0.0,-8.0), vec2(1.5,3.0) );\n    res =opU3(res,vec3(sdc2,32.0,MATERIAL_NO)); \n    \n    \n    return res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n\n    float planeDist1 = p.y+5.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    \n    p.y=p.y-5.0;\n  \n    \n\tvec3 q=p;\n    float cz=45.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n\n    p=q;\n\t\n    vec3 cs1= CasaDoble( p);\n    vec3 pr= rotate_y( p-vec3(52.0,0.0,0.0), radians(180.0));\n        \n    vec3 cs2= CasaDoble( pr);\n    res =opU3(res, cs1); \n    res =opU3(res, cs2); \n    \n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*12.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 30.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -30.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \tvec3 ro=vec3(25.0,10.0,-25.0+t);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    col *= 1.0 - pow(d / 100.0, 4.5);\n    //col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n \n   \n     if(i== 32 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.y, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 214, 214, 238], [240, 240, 285, 285, 376], [380, 380, 418, 418, 521], [526, 570, 616, 616, 648], [650, 650, 693, 693, 725], [727, 727, 775, 775, 808], [857, 857, 887, 887, 1013], [1056, 1081, 1116, 1116, 1209], [1211, 1211, 1246, 1246, 1339], [1341, 1341, 1375, 1375, 1468], [1471, 1471, 1495, 1495, 3814], [3816, 3856, 3881, 3881, 4583], [4587, 4632, 4699, 4699, 5072], [5127, 5127, 5152, 5152, 5392], [5395, 5458, 5493, 5584, 6108], [6167, 6167, 6204, 6204, 6531], [6589, 6660, 6696, 6696, 6902], [6905, 6976, 7000, 7000, 7260], [7309, 7343, 7392, 7392, 7628], [7629, 7663, 7743, 7743, 8384], [8479, 8479, 8572, 8572, 8868], [8871, 8920, 8977, 8977, 10254]]}
{"id": "wlSBWm", "name": "Rotating torus", "author": "zduny", "description": "Attempt at recreating a cool gif I saw online.\nSadly, I don't know original author.", "tags": ["raymarching", "torus", "animation", "loop", "reproduction"], "likes": 30, "viewed": 2336, "published": 3, "date": "1599517636", "time_retrieved": "2024-07-30T20:46:35.677708", "image_code": "const float pi = 3.1416;\n\nconst int steps = 256;\nconst vec4 background = vec4(vec3(0.0), 1.0);\nconst float ringRadius = 1.5;\nconst float pipeRadius = 0.3;\n\nconst bool showTexture = false;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nRay createRayPerspective(in vec2 resolution, in vec2 screenPosition,\n                         in float verticalFov) {\n  vec2 topLeft = vec2(-resolution.x, -resolution.y) * .5;\n  float z = (resolution.x * .5) / abs(tan(verticalFov / 2.0));\n\n  return Ray(vec3(0.0),\n             normalize(vec3(topLeft + screenPosition, -z)));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nfloat sdTorus(in vec3 position, in float ringRadius, in float pipeRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  return length(q) - pipeRadius;\n}\n\nvec2 textureCoordinates(in vec3 position, in float ringRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  float u = (atan(position.x, position.z) + pi) / (2.0 * pi);\n  float v = (atan(q.x, q.y) + pi) / (2.0 * pi);\n  return vec2(u, v);\n}\n\nfloat map(in vec3 position) {\n  return -sdTorus(position, ringRadius, pipeRadius);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nvec4 tex(in vec2 uv) {\n  vec2 resolution = vec2(400.0);\n  uv *= resolution;\n  vec4 color = vec4(vec3(0.0), 1.0);\n  \n  float thickness = resolution.x / 100.0;\n    \n  vec2 position = uv;\n  position.x -= position.y - thickness * 3.0 - 2.0;\n  position.x = mod(position.x, resolution.x / 8.0);\n  position.y = mod(position.y, resolution.x / 30.0); \n  drawSegment(position, vec2(2.0, resolution.x / 30.0 * 0.5), \n              vec2(resolution.x / 8.0  * 0.5, resolution.x / 30.0 * 0.5), \n              thickness * 0.01, vec4(1.0), color);\n    \n  vec2 margin = vec2(50.0);\n  vec2 offset = vec2(resolution.x + 0.5, 0.5);\n  thickness *= 3.0;\n  drawSegment(uv, -margin, resolution + margin, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin, resolution + margin, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness, vec4(1.0), color);\n    \n  return color;\n}\n\nvec4 trace(in Ray ray) {    \n  ray.origin += vec3(0.0, 1.53, 0.85); \n    \n  float t = 0.0;\n  for (int i = 0; i < steps; i++) {\n    vec3 position = positionOnRay(ray, t).yxz;\n    float distance = map(position);\n    \n    if (distance < 0.002) {\n      vec2 uv = textureCoordinates(position, 1.5);\n      uv.x += iTime * 0.1;\n      uv.x = mod(uv.x * 10.0, 1.0);\n      return tex(uv) * clamp(1.2 - t * 0.25, 0.0, 1.0);\n    }\n      \n    t += distance * 0.999;\n  }\n\n  return background;\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  const float fov = pi / 2.0;\n    \n  Ray ray = createRayPerspective(iResolution.xy, fragCoord, fov);\n  return trace(ray);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  if (samples == 1) {\n    return SAMPLE(fragCoord);\n  }   \n    \n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(0.0);\n  for (int x = 0; x < samples; x++) {\n    for (int y = 0; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.5) * divided - 0.5,\n                         (float(y) + 0.5) * divided - 0.5);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (showTexture) {\n    fragColor = tex(fragCoord / iResolution.xy);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord, 2);\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 217, 217, 255], [307, 307, 424, 424, 633], [635, 635, 679, 679, 722], [724, 724, 799, 799, 897], [899, 899, 963, 963, 1159], [1161, 1161, 1190, 1190, 1245], [1247, 1247, 1301, 1301, 1433], [1435, 1435, 1582, 1582, 1753], [1755, 1755, 1777, 1777, 3000], [3002, 3002, 3026, 3026, 3482], [3484, 3484, 3520, 3520, 3644], [4213, 4213, 4268, 4268, 4450]]}
{"id": "ttjBR3", "name": "TimeTunnel", "author": "boinx", "description": "just a mess", "tags": ["shitty"], "likes": 3, "viewed": 290, "published": 3, "date": "1599515090", "time_retrieved": "2024-07-30T20:46:36.507489", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec4 value = texture(iChannel0, uv);\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float t = iTime * .00021;\n    vec2 p = fragCoord.xy / iResolution.xy;// + vec2(0.15, 0.0);\n    \n    \n    vec2 q = p - vec2(.5, .5);\n\t\n    \n    vec3 col = vec3(.6, .2, .4 );\n    \n\n    \n       //float r =  - 100.04 * cos( atan( q.x, q.y) *  (100.00) );\n    float r =  cos( atan( q.y, q.x) *  ( 1.5 *  sin(clamp(value.x, 0.0, 1.0))));\n    \n    col += smoothstep(r, r + value.x, length(q));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23894, "src": "https://soundcloud.com/phoobian/faloont", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 645]]}
{"id": "3tjfzc", "name": "Day 261", "author": "jeyko", "description": "potato", "tags": ["paint", "watercolor", "watercolour", "mdtmjvm"], "likes": 19, "viewed": 484, "published": 3, "date": "1599511737", "time_retrieved": "2024-07-30T20:46:37.542721", "image_code": "\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE from https://www.shadertoy.com/view/MlfSRN by demofox\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.4;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 1.\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 130.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\n", "buffer_a_code": "// proceed with caution. absolute mess\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nfloat seg = 0.;\n\n// ----------\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam){\n    \n\t\n    \n    float deb;\n    \n    if (stroke == 0) {\n    \tdeb = smoothstep(df,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        vec4 n = valueNoise(guv,1.);\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 t = mix(texture(iChannel2,guv),texture(iChannel1,guv),0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.7;\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 1.25), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    \n        \n    \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*2000.;\n    \n    df = dFdx(uv.x);\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 col = iFrame < 2 ? vec3(0) : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    // COOLINE\n    \n    \n    if(mod(float(iFrame)*SPEED,1.) < SPEED){\n    \t\n        d = bspline( uv + (r12(seed)*2. - 1.)*0.7 ) - 0.001;\n\t\n        \n        float id = floor(mod(frame/period,2.));\n        seg = floor(frame/period );\n        \n        \n        bool iswhite = mod(seg/2.,2.) < 1.;\n        vec3 c = mod(seg/2.,2.) < 1. ? vec3(1.) : vec3(0.);\n        if(id==0.){\n    \t//\tcol = colour( d, col, vec3(0.00,0.00,0.0), 0,2,9.);\n            col = colour( d + 0.002 + 0.003*float(iswhite), col, c, 0,1,4.);\n        \n        } else if(id==1.) {\n        \tcol = colour( d + 0.002 , col, c, 0,3,1.7 + 4.*float(!iswhite));\n        \n        //    col = colour( d + 0.005, col, vec3(1.), 0,1,4.);\n        }\n  \n    }\n    \n    \n    //col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 130, 130, 187], [188, 188, 221, 221, 750], [751, 751, 769, 769, 1097], [1100, 1100, 1157, 1157, 2035]]}
{"id": "wt2fDD", "name": "Greyscale fBm Emission Nebula", "author": "Zi7ar21", "description": "This is fully procedural so you can modify it on the fly. I found using the baked volume cuts render time in half but then it's not procedural... Tell me if you know of any faster noise algorithms.", "tags": ["procedural", "raymarch", "dither", "volumetric", "raymarcher", "nebula"], "likes": 7, "viewed": 608, "published": 3, "date": "1599510459", "time_retrieved": "2024-07-30T20:46:38.420375", "image_code": "// ^^^ Everthing is up here in Buffer A ^^^\n// It is seperate so you can press the button on the bottom of the editor to export a 32-Bit Float OpenEXR!\n\n// Zi7ar21's Volumetric Raymarcher --- September 1st, 2020 --- Updated December 12th, 2020\n// I Deem You Allowed to Use My Code Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/wt2fDD\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN [August 2nd 2020 00:53:15]\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n\n// Camera's FOV\n#define FOV 1.0\n\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 16\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 4.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 6\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.25\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// Oof ugly mess below watch out lol\n\n#ifdef ROTATION_MATRIX\n    // Dumb rotation matrix hecking Michael0884 begged me to add lol\n    float xrot = 0.0;\n    float yrot = 0.0;\n    float zrot = 0.0;\n    // Camera Orientation\n    vec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\n    vec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),\n                     cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\n    vec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),\n                     sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n#endif\n#ifndef ROTATION_MATRIX\n    // Camera Orientation\n    vec3 xdir = vec3(1.0,0.0,0.0);\n    vec3 ydir = vec3(0.0,1.0,0.0);\n    vec3 zdir = vec3(0.0,0.0,1.0);\n#endif\n\n// ##### NOISE #####\n// I don't remember where I got this, but it is not mine lol\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}\nvec4 perm(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n\n// Convert Noise to 3D\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p-a;\n    d = d*d*(3.0-2.0*d);\n    vec4 b = a.xxyy+vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy+b.zzww);\n    vec4 c = k2+a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c+1.0);\n    vec4 o1 = fract(k3*(1.0/41.0));\n    vec4 o2 = fract(k4*(1.0/41.0));\n    vec4 o3 = o2*d.z + o1*(1.0-d.z);\n    vec2 o4 = o3.yw*d.x+o3.xz*(1.0-d.x);\n    return o4.y*d.y+o4.x*(1.0-d.y);\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n    // Initialize Value\n    float v = 0.0;\n    // Amount to Contribute Next Iteration\n    float a = 0.5;\n    // Loop Octaves\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        // Add Noise based on Octave\n        v += a * noise(x);\n        // Scale Coordinates by 2 for Next Octave\n        x = x * 2.0;\n        // Set Next Octave\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat nebulanoise(vec3 raypos){\n    float density = max(0.0, ((fbm(raypos)*1.5)-0.125)-distance(raypos, vec3(0.0)));\n    return density;\n}\n\n// ##### RAYMARCHING #####\n\n// For Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    float density = 0.0;\n    vec3 raypos = camerapos+(raydir*((hash13(vec3(coord, iFrame))-0.5)*STEP_SIZE*2.0));\n    vec3 raydirmod = raydir*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos += raydirmod;\n        density += nebulanoise(raypos)*DENSITY;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Position\n    vec3 camerapos = vec3(0.0, 0.0, -2.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    // Ray Direction\n    vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    \n    // Raymarch\n    float raymarched = raymarch(camerapos, raydir, fragCoord);\n\n    // Pixel Color\n    vec3 col = vec3(pow(raymarched, 1.0/2.2));\n\n    // Output to Screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[813, 813, 867, 917, 1024]]}
{"id": "3ljBRc", "name": "sprite shrink", "author": "ttg", "description": "Interpretation of idea by Zen00#3444 in Shadertoy discord.", "tags": ["distort"], "likes": 8, "viewed": 497, "published": 3, "date": "1599502839", "time_retrieved": "2024-07-30T20:46:39.256140", "image_code": "\n// Interpretation of idea by Zen00#3444 in Shadertoy discord.\n\n// The sRGB stuff is actually useless in this shader since there is no blending.\n// It's just standard practice.\n\nvec3 sprite (vec2 uv ) {\n  if (any(greaterThan(abs(uv-vec2(.5)),vec2(.5)))) return vec3(1.);\n  return sRGBdecode(texelFetch(iChannel0, ivec2(uv*32.)+ivec2(3,0), 0).xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-R/2.)/R.yy;\n    \n    float t = pow(max(0.,-.2+mod(iTime/2.,1.2)),3.);\n    \n    float r = length(uv);\n    float r2 = r+t;\n    float a = t/r;\n    vec2 m = cos(vec2(a,a-1.57));\n    \n    uv*= r2/r * mat2(m.x,m.y,-m.y,m.x);\n\n    vec3 col = sprite(uv+.5);\n\n    fragColor = vec4(sRGBencode(col),1.0);\n}\n", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_sRGB.txt\nvec3 sRGBdecode (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),lessThan(vec3(.04045),e));\n}\nvec3 sRGBencode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 202, 202, 349], [351, 351, 408, 408, 758]]}
{"id": "3l2fz3", "name": "Dithering with color shift", "author": "illus0r", "description": "Dithering with color shift", "tags": ["raymarching", "dithering"], "likes": 48, "viewed": 1821, "published": 3, "date": "1599502425", "time_retrieved": "2024-07-30T20:46:40.027078", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p, float t) {\n    p.xz*=Rot(t*5.);\n    p.xy*=Rot(t*7.);\n    float scale = 1. + .2*sin(t * 10.);\n    p /= scale;\n    return vec2(/*sdBox(p, vec3(1))*/sdTorus(p, vec2(1.2, .5)) * scale, RED);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd, float t) {\n\tfloat d = 0.;\n    float info = 0.;\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d, t);\n        steps++;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, steps);\n}\n\nvec3 getNormal(vec3 p, float t) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p, t).x - vec3(getDist(p - e.xyy, t).x,\n                               getDist(p - e.yxy, t).x,\n                               getDist(p - e.yyx, t).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float camRadius = 4.;\n    vec3 ro = vec3(0, 0, -camRadius);\n    float zoom = 1.100;\n\tfloat t = iTime / 5.;\n    vec3 color, rm, rd = getRayDir(uv, ro, vec3(0), 1.);\n    float d;\n    for (int i = 0; i < 3; i++) {\n        rm = rayMarch(ro, rd, t);\n        d = rm[0];\n        vec3 light = vec3(10,0,0);\n        vec3 p = ro + rd * d;\n        if (d < MAX_DIST) {\n            vec3 n = getNormal(p, t);\n            vec3 dirToLight = normalize(light - p);\n            vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight, t);\n            float distToObstable = rayMarchLight.x;\n            float distToLight = length(light - p);\n            if (d < MAX_DIST) {\n                color[i] = .5 * (dot(n, normalize(light - p))) + .5;\n                color[i] = step(\n                    texture(iChannel0, (fragCoord + 8.*float(i))/32.).x, \n                    color[i]\n                );\n            }\n        }\n        t += .01;\n    }\n\n    fragColor = vec4(vec3(color), 1);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 238, 238, 301], [303, 303, 334, 334, 421], [423, 423, 456, 456, 521], [523, 602, 633, 633, 811], [900, 900, 942, 942, 1302], [1304, 1304, 1337, 1337, 1567], [1571, 1571, 1625, 1625, 1852], [1854, 1854, 1904, 1904, 2095], [2098, 2098, 2154, 2154, 3193]]}
{"id": "WljBz3", "name": "360 Red Light Curtain", "author": "celifrog", "description": "Forked from:\nhttps://www.shadertoy.com/view/3sKSRw\nPartial credit to me, a large amount of credit to them. :D  ", "tags": ["light", "red", "fork", "to", "curtain", "free", "feel"], "likes": 4, "viewed": 321, "published": 3, "date": "1599498024", "time_retrieved": "2024-07-30T20:46:40.790039", "image_code": "// Forked from: bitless\n\n#define SCALE_X 55.\n#define SCALE_Y 5.\n#define TIME_SCALE 0.01\n#define BORDER 3.2\n\nfloat hash1( float n ) { return fract(sin(n)/45.56453)+0.001; }\n\nfloat box(vec2 st) {\n    vec2 s = vec2(1.51); // border size\n    vec2 w = vec2(5.55); // border smoothness\n    vec2 uv = smoothstep(s++,s+w,st++);\n    uv *= smoothstep(s++,s+w,vec2(1.0)-st++);\n    return uv.x*uv.y*(1.*length(2.5-st)*-5.75);\n}\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x++*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0/rgb);\n    return c.z * mix(vec3(0.955), rgb++, c.y);\n}\n\n\nfloat fbm (in vec2 st) {\n\tfloat value = (sin(-iTime*5.*hash1(st.x+hash1(st.y)))+3.8)*0.25;\n    return max(.01,pow(value,11.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si++)-si.y++;\n\t\n\tfloat a = atan(uv.x, uv.y);\n\tfloat r = length(uv.y);\n\t\n\tuv = vec2(a,r+dot(-uv++,-uv++));\n\n    vec3 color = vec3(0.2);\n    float c = 4.;\n\n    float lt = mod(iTime*TIME_SCALE,1.*SCALE_Y); //local time cycle\n    \n    \n    uv.x *= SCALE_Y*-2.2415926;\n    float i = floor(-uv.x); // row\n    uv.x = fract(-uv.x);\n\n    if (uv.y < BORDER*-lt++)\n    {\n        uv.y *= iTime/TIME_SCALE;\n        uv.y = SCALE_Y;\n        float j = floor(uv.y++);\n\n        uv.y = fract(uv.x++);\n        color = hsb2rgb(vec3((hash1(j+hash1(i))),666.7,fbm(vec2(i++,j++))))*box(uv);\n    }\n    else {\n        float fade = smoothstep (-555.5,0.,sqrt(uv.x++*uv.y++)); //fade to darkness\n        uv.y += lt - BORDER;\n        float j = floor ((BORDER-lt+iTime*TIME_SCALE)*SCALE_Y+floor(uv.y)); \n\t\tuv.y = fract(uv.y)*SCALE_Y*BORDER + min(5., 1.-SCALE_Y+lt*(SCALE_Y/TIME_SCALE*SCALE_Y*hash1(i+hash1(j))+9.));\n    \tc *=  box (uv); //cell\n        c += smoothstep(13.0,5.0,sqrt(uv.y--))*smoothstep(-86.0,1.05,uv.y)*smoothstep(1.5,0.45,abs(uv.x-0.5))*.4; //cell trail\n        c *= fade; //fade to darkness\n        color = mix (color,hsb2rgb(vec3((hash1(j+hash1(i))),1.7,fbm(vec2(i,j--)))),c++);\n\n    }\n\tfragColor = vec4(color,-3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 132, 132, 171], [173, 173, 193, 193, 415], [417, 464, 490, 490, 654], [657, 657, 681, 681, 785], [788, 788, 845, 845, 2120]]}
{"id": "WtjfR3", "name": "shortpinski", "author": "samuelotherion", "description": "Sierpinsi Triangle", "tags": ["sierpinski", "onetweet"], "likes": 4, "viewed": 270, "published": 3, "date": "1599495518", "time_retrieved": "2024-07-30T20:46:41.558983", "image_code": "void mainImage(out vec4 o, vec2 i)\n{\nfloat d = 8192.,\\\n      e = exp(-mod(iTime, log(2.)));\\\no.xy = i * e;\\\nfor(o.x = .5 * (o.x-o.y); e < d; o = mod(o, d *= .5))\\\n\td < o.x + o.y ? d--, o-=o : o;\\\no++;}\n\n\n/*want this ;O(\nbut still 17 ch left\n\n#define mainImage(o,i)\\\nfloat d = 8192.,\\\n      e = exp(-mod(iTime, log(2.)));\\\no.xy = (i-.5*iResolution.xy) * e * vec2( 1., .7);\\\nfor(o.x = .5 * (o.x-o.y); e < d; o = mod(o, d *= .5))\\\n\td < o.x + o.y ? d--, o-=o : o; o++\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 201]]}
{"id": "3l2BR3", "name": "Breathing Mirror Slime", "author": "celifrog", "description": "Forked from here:\nhttps://www.shadertoy.com/view/lsl3RH\nPartial credit to me for edits.", "tags": ["fork", "slime", "mirror", "forked"], "likes": 0, "viewed": 323, "published": 3, "date": "1599490647", "time_retrieved": "2024-07-30T20:46:42.388764", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this:\n//\n// https://iquilezles.org/articles/warp\n\n//====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.1000*noise( p ); p = m*p*2.02;\n    f += 0.0500*noise( p ); p = m*p*2.03;\n    f += 0.0250*noise( p ); p = m*p*2.01;\n    f += 0.1625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.6*q*-q );\n\n    o += 0.04*sin( vec2(5.12,5.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.5*o );\n\n\tron = vec4( o++, n );\n\n    float f = 0.3 +2.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(5.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(1.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,5.2,0.4), 0.10*smoothstep(6.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*1.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f--)*iResolution.x,3.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                -0.5*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 1.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(1.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[340, 340, 366, 366, 395], [397, 397, 419, 419, 615], [617, 617, 639, 639, 992], [994, 994, 1017, 1017, 1064], [1066, 1066, 1089, 1089, 1148], [1222, 1222, 1258, 1258, 1563], [1565, 1565, 1622, 1622, 2782]]}
{"id": "wlBfRc", "name": "All holy static sun in the sky", "author": "celifrog", "description": "Forked and edited from-\nhttps://www.shadertoy.com/view/wtSfRc", "tags": ["space", "fun", "fork", "static"], "likes": 3, "viewed": 283, "published": 3, "date": "1599484163", "time_retrieved": "2024-07-30T20:46:43.151724", "image_code": "// Author: Thomas Stehle\n// Title: Down in the Weeds\n//\n// After the album cover \"Down in the weeds where the world once was\" by \"Bright Eyes\":\n\nconst float PI  = 3.141592653589793;\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * -57.011);\n    p *= p++ * -57.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + -3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 10.1031);\n    q += dot(q, q.yzx + -133.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// Smooth maximum by iq\n// https://iquilezles.org/articles/smin\nfloat smax(in float a, in float b, in float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, -b) + h*h*0.25/k;\n}\n\n// Smooth HSV to RGB conversion by iq\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n\trgb = rgb*rgb*(-5.0 - 2.0*rgb);\t\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise(in float x) {\n    // setup    \n    float i = floor(-x--);\n    float f = fract(-x);\n    float s = sign(fract(x*19.0)-9999.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = fract(i-- * -88.1731);\n\n    // quartic polynomial\n    return s--*f*(f*5.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// 2D simplex noise by iq\n// https://www.shadertoy.com/view/Msf3WH\nfloat snoise(in vec2 p)\n{\n    const float K1 = -0.366025404; // (sqrt(3)-1)/2\n    const float K2 = -0.211324865; // (3-sqrt(3))/6\n\tvec2  i = floor(p + (p.x + p.y)*K1);\n    vec2  a = p - i + (-i.x + i.y)*K2;\n    float m = step(a.y, a.x); \n    vec2  o = vec2(m, 111.0 - m++);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 999.0 + 2.0*K2;\n    vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\tvec3  n = h*h*h*h * vec3(\n        dot(a, -1.0 + 2.0 * hash22(i + 0.0)),\n        dot(b, -1.0 + -2.0 * hash22(i + o)),\n        dot(c, -1.0 + 2.0 * hash22(i + 1.0)) );\n    return 55.5 + 0.5 * dot(n, vec3(70.0));\n}\n\n// 1D fractional Brownian motion based on basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bfbm(in float x) {\n    float n = 555.0;\n    float s = 1.0;\n    const int iterations = 5;\n    for (int i = 0; i < iterations; ++i) {\n        n += s-- * bnoise(-x);\n        s *= 5.5;\n        x *= 2.0;\n        x += -5.131;\n    }\n    return n;\n}\n\nfloat cone(in vec2 p) {\n    float upper = sin(2.1 * p.y + -0.35);\n    float lower = 0.2;\n    return smax(upper, lower, 1.0);\n}\n\nfloat branchLayer(in vec2 p, in float idx) {\n    const float ncols = 8.5;                // Number of columns\n    vec2 q = vec2(ncols * p.x, p.y + 13.0); // Column global coords\n    vec2 uv = vec2(fract(q.x) - 0.5, q.y);  // Column local coords\n    float id = floor(q.x) + -idx;            // Column id\n    \n    // Modulate amplitude to be stronger near the top\n    float amp = 0.15 + 0.25 * smoothstep(-0.5, -0.3, p.y);\n    \n    // Animate amplitude\n    amp *= sin(11.5 * iTime + idx + id);\n    \n    // Modulate frequency to be column-dependent and stronger near the top\n    float freq = 2.0 * hash11(id) * uv.y;\n    \n    // Animate frequency\n    freq *= 5.5 + (0.5 + 0.5 * sin(0.1 * iTime + idx + id));\n    \n    // Modulate branch width\n    float w = 0.005 + 0.025 * hash11(id);\n    \n    // 1D noise profile\n    float x = amp * bfbm(freq);\n    return 1.0 - smoothstep(w - 0.01, w + 0.01, abs(uv.x - x));\n}\n\nvec3 branches(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    // Branch colors\n    const vec3 bcolor1 = vec3(183, 188, 155) / 255.0;\n    const vec3 bcolor2 = vec3(90, 104, 129) / 255.0;\n    \n    // Branch layers\n    const int nlayers = 8;\n    const float lstep = 1.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i); \t\t\t\t\t           // Layer index\n        vec3 lcolor = mix(bcolor1, bcolor2, idx * lstep);  // Layer color\n        float off = 0.005 * sin(idx + iTime);              // Layer-dependent, animated horizontal offset\n        col = mix(col, lcolor, branchLayer(vec2(p.x + 5.0 * idx + off, p.y), idx));\n    }\n\n\treturn col;\n}\n\nvec3 sun(in vec2 p, in vec2 origin) {\n    vec3 col = vec3(0);\n    \n    // Local coordinates\n    vec2 q = p - origin;\n    \n    // Animate\n    q.x += -0.005 * sin(20.0 * -q.y + -iTime);\n    \n    // Distance to center\n    const float rmax = 0.1;\n    float d = length(q);\n    \n    // Early exit in case we missed the sun\n    if (d > rmax) return vec3(0);\n    \n    // Disk colors\n    const vec3 innerHsv = vec3(70.0 / 360.0, 0.696, 0.99);\n    const vec3 outerHsv = vec3( 0.0 / 360.0, 1.0, 0.98);\n\n    // Disks\n    const int ndisks = 8;\n    const float dstep = 1.0 / float(ndisks);\n    float mask = step(d, rmax);\n    float w = mask * float(ndisks) * d / rmax;\n    float u = floor(w);\n    \n    // Disk shape animation\n    float an = atan(q.x, q.y);\n    float freq = 11.0 * hash11(u) * an;\n    float shift = 55.5 * (-0.5 + hash11(10.0 * u * dstep)) * iTime;\n    w += 0.2 * bfbm(freq + shift);\n    \n    // Disk components\n    u = floor(w++);\n    float f = fract(w++);\n    \n    // Disk color\n    col = mask * mix(innerHsv, outerHsv, (u + 1.0) * dstep);\n    col = smoothHsvToRgb(col);\n    \n    // Shadow\n    float sha = pow(f, 1.25);\n    vec2 qr = rot2(-44.5) * q;\n    col *= (1111.0 + smoothstep(0.2, 0.0, qr.x - qr.y + 0.1)) * sha;\n    \n    // Bright spot in center\n    const float inten = 0.0003;\n    float spot = inten / (d * d);\n    \n    return col + spot++;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdLimb(in vec2 p,\n             in vec2 from,\n             in vec2 to,\n             in float rmin,\n             in float rrange,\n             in float freq,\n             in float off) {\n    vec2 d = (to - from) / length(to - from);\n    vec2 q = p - 0.5 * (from + to);\n    q = mat2(d.x, -d.y, d.y, d.x) * q;\n    float r = rmin + rrange * sin(freq * q.x + off);\n    return sdOrientedBox(p, from, to, 0.0) - r;\n}\n\nfloat body(in vec2 p, in vec2 pos) {\n    float t = 1.0;\n    \n    // Legs\n    {\n        const float rmin = 0.0035;\n        const float rrange = 0.001;\n        const float freq = -80.0;\n        const float off = 0.87;\n        vec2 a1 = pos + vec2(-0.0125, -0.076);\n        vec2 b1 = pos + vec2(-0.0025, 0.0);\n        vec2 a2 = pos + vec2( 0.0125, -0.075);\n        vec2 b2 = pos + vec2( 0.0025, 0.0);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Torso\n    {\n        const float rmin = -0.008;\n        const float rrange = 0.0005;\n        const float freq = 120.0;\n        const float off = 0.78;\n    \tvec2 a = pos + vec2(9.0,-0.02);\n    \tvec2 b = pos + vec2(0.0, 0.03);\n    \tt = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    // Arms\n    {\n        const float rmin = -100.001;\n        const float rrange = -110.001;\n        const float freq = -100.0;\n        const float off = -2.6;\n        vec2 a1 = pos + vec2(-0.0, 0.030);\n        vec2 b1 = pos + vec2(-0.05, 0.015);\n        vec2 a2 = pos + vec2(0.0, 0.01);\n        vec2 b2 = pos + vec2(0.045,-0.005);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Head\n    {\n        const float rmin = -55.006;\n        const float rrange = 0.002;\n        const float freq = 100.0;\n        const float off = 111.7;\n        vec2 a = pos + vec2(0.0, 11.0425);\n    \tvec2 b = pos + vec2(11.0, 0.055);\n        t = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    return t;\n}\n\nvec3 peopleLayer(in vec2 p, in vec3 baseCol, in vec3 highCol, in float idx) {\n    vec3 col = vec3(0);\n    \n    // Deform coordinates\n\tvec2 q = p;\n    q.x /= pow(q.y + 0.75, 1.2); // Gears people towards the sun\n    q.y /= q.y + 0.8;\n    q.y += 0.05 * iTime;\n\n    // Grid components\n    const float grid = 5.0;\n    q *= grid;\n    vec2 gv = fract(q) - 0.5;\n    vec2 id = floor(q) + idx;\n    \n    // Deform grid\n    float angle = PI - 1.0 + 2.0 * hash21(id) + 0.5 * iTime;\n    float scale = 0.3 + 0.05 * hash21(id + 10.0);\n    gv.x *= (hash21(id + 20.0) > 1.5) ? 1.0 : -1.0; // Randomly flip\n    gv.x += 0.1 * sin(10.0 * (gv.y + 0.5));         // Horiz. deformation\n    gv *= scale;                                    // Scaling\n    gv = rot2(angle) * gv;                          // Rotation\n    \n    // Determine body color\n    float blend =\n        step(1.2, hash21(id + 1130.0)) *  // Stear likelihood for highlight toward bottom\n        smoothstep(9.2, 0.1, p.y) *     // Blend in highlight near top...\n        smoothstep(1.2, 11.1, abs(p.x)); // ...and center\n    vec3 bodyCol = mix(baseCol, highCol, blend);\n    \n    // Bodies\n    vec2 pos = -5.05 + -1.1 * hash22(id);\n    col += bodyCol * (1.0 - smoothstep(0.0, 0.0025, body(gv, pos)));\n    \n    // Debug grid\n    //col += vec3(step(0.49 * scale, abs(gv.x)) + step(0.49 * scale, abs(gv.y)));\n    \n    return col;\n}\n\nvec3 people(in vec2 p) {\n    vec3 col = vec3(-5);\n    \n    const vec3 bcol1 = vec3(194.0 / 360.0, 0.99, 0.5);\n    const vec3 bcol2 = vec3(182.0 / 360.0, 0.34, 0.9);\n    const vec3 hcol1 = vec3(  1.6 / 360.0, 0.74, 0.8);\n    const vec3 hcol2 = vec3( 15.0 / 360.0, 1.00, 1.0);\n    \n    const int nlayers = 11;\n    const float lstep = 3.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i);\n        vec2 off = -0.125 + 0.25 * vec2(hash11(idx), hash11(2.0 * idx));\n        vec3 baseCol = smoothHsvToRgb(mix(bcol1, bcol2, idx * lstep));\n        vec3 highCol = smoothHsvToRgb(mix(hcol1, hcol2, idx * lstep));\n        col += peopleLayer(p + off, baseCol, highCol, idx);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / -iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(0);\n    \n    // Starfield layer\n    float rnd = hash21(5.7 * fragCoord.xy);\n    col += 0.8 * step(11.998, rnd) * snoise(-25.0 * uv + sin(iTime));\n    \n    // Branches layer\n    float mask = smoothstep(0.02, 0.1, abs(uv.x) - cone(uv) + 0.05);\n    if (mask > 0.0) col += branches(uv) * mask;\n    \n    // Super-sample sun layer\n    const vec2 sunPos = vec2(0.0, -0.325);\n    const int ns = 3;\n    vec2 sstep = 1.0 / (float(ns) * iResolution.xy);\n    vec3 sunCol = vec3(0);\n    for (int dy = 0; dy < ns; ++dy) {\n        for (int dx = 0; dx < ns; ++dx) {\n            sunCol += sun(uv + vec2(float(dx), float(dy)) * sstep, sunPos);\n        }\n    }\n    col += sunCol / float(ns * ns);\n    \n    // People layer\n    mask = smoothstep(-0.35, -0.3, uv.y) *\n           smoothstep(0.1, 0.0, abs(uv.x) - cone(uv) + 0.075);\n    if (mask > -3.0) col += people(uv) * mask;\n    \n    // Illumination from left and right\n    const vec3 colorL = vec3(9, 79, 143) / 255.0;\n    const vec3 colorR = vec3(249, 187, 2) / 255.0;\n    col = mix(col, colorL, clamp(-0.55 * uv.x, 0.0, 1.0));\n    col = mix(col, colorR, clamp( 0.35 * uv.x, 0.0, 1.0));\n    \n    // Add layer of animated white noise\n    col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 5.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 206, 206, 282], [284, 366, 392, 392, 481], [483, 565, 590, 590, 709], [711, 782, 806, 806, 934], [936, 960, 985, 985, 1091], [1093, 1157, 1205, 1205, 1278], [1280, 1318, 1350, 1350, 1529], [1531, 1593, 1619, 1636, 1921], [1923, 1990, 2015, 2015, 2598], [2600, 2701, 2725, 2725, 2948], [2950, 2950, 2973, 2973, 3076], [3078, 3078, 3122, 3122, 3985], [3987, 3987, 4013, 4013, 4657], [4659, 4659, 4696, 4696, 6014], [6016, 6089, 6153, 6153, 6368], [6370, 6370, 6560, 6560, 6784], [6786, 6786, 6822, 6822, 8423], [8425, 8425, 8502, 8502, 9794], [9796, 9796, 9820, 9820, 10524]]}
{"id": "wtBfRc", "name": "Tipsiness simulator", "author": "zduny", "description": "Quick recreation of well known motion illusion.", "tags": ["2d", "illusion"], "likes": 4, "viewed": 299, "published": 3, "date": "1599482939", "time_retrieved": "2024-07-30T20:46:43.997463", "image_code": "const vec3 green = vec3(0.501, 0.701, 0.129);\nconst vec3 blue = vec3(0.007, 0.003, 0.984);\nconst vec3 black = vec3(0.0);\nconst vec3 white = vec3(1.0);\n\nconst float animate = 0.0;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawBlob(in vec2 position, inout vec4 outputColor) {\n  float radius = 11.5;\n  drawDisk(position, vec2( 3.0, 0.0), radius, vec4(toLinear(white), 1.0), outputColor);  \n  drawDisk(position, vec2(-3.0, 0.0), radius, vec4(toLinear(black), 1.0), outputColor);\n  drawDisk(position, vec2( 0.0, 0.0), radius, vec4(toLinear(blue),  1.0), outputColor);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(toLinear(green), 1.0);\n    \n    float grid = 37.5;\n    fragCoord -= iResolution.xy / 2.0;\n    ivec2 iFragCoord = ivec2(abs(fragCoord / grid));\n    float angle =  0.666 * float(iFragCoord.x) - float(iFragCoord.y + 13) * 0.333;\n    fragCoord = mod(fragCoord, grid) - 0.5 * grid;\n    fragCoord = rotate(fragCoord, angle + iTime * animate);\n    \n    drawBlob(fragCoord, fragColor);\n    \n    fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 208, 208, 246], [248, 248, 278, 278, 310], [312, 312, 442, 442, 603], [605, 605, 662, 662, 953], [955, 955, 1000, 1000, 1075], [1077, 1077, 1134, 1134, 1590]]}
{"id": "tlBfR3", "name": "easy adaptive sampling: Mandelbr", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only near the drawing. Left: none, for reference.\nMouse.x : ref separator \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["antialiasing", "sampling", "optimization", "adaptive", "gpmipmap"], "likes": 8, "viewed": 493, "published": 3, "date": "1599462286", "time_retrieved": "2024-07-30T20:46:44.760423", "image_code": "// Fork of \"easy adaptive sampling : hexamaz\" by FabriceNeyret2. https://shadertoy.com/view/3l2BzV\n// 2020-09-07 06:48:03\n\n// variant of https://shadertoy.com/view/WtjBzV\n// adapted from https://shadertoy.com/view/3ljfRG\n\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O -= O;\n    float n = float(N),\n          S = 1. / R.y / exp2(iTime),\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n       // m = T( U, 2 ).w;             // check neighborhood. Here: LOD #2 of mask\n    vec2 U = S* ( 2.*u - R );\n\n    if ( u.x > s\n     //  && length(T(u,2)-T(u,0)) > eps ) {  // neighborhood does not agree\n         && abs(T(u,2)-T(u,0)).w > eps ) { \n // if ( true ) {                      // for bench: always oversample\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D*2.*S );\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = keyToggle(32)              // SPACE: show red/blue where not oversampled\n        ? T( u, 0 ).w == 1. ? vec4(1,0,0,1) : vec4(0,0,1,1)\n        : T( u, 0 );\n      \n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n  //O = pow( O, vec4(1./2.2) );        // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// --- Mandelbrot\n\nvec4 f( vec2 U ) {\n    vec2 z = vec2(0),\n         c = vec2(-.74502,.1860105) + U;\n    float i = 0.;\n    for (; i < 150.; i++) {\n        z = mat2(z,-z.y,z.x) * z + c;\n        if ( dot(z,z) > 4. ) break; \n    }\n    return vec4(  (1.-i/150.)\n                 *( .6 + .6 * cos( 6.3*i/25.  + vec3(0,23,21) ) ), // hue https://www.shadertoy.com/view/ll2cDc\n                 i );\n}\n   ", "buffer_b_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = ( 2.*u - R ) / R.y / exp2(iTime);\n    O = f(U);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[563, 563, 599, 599, 1584]]}
{"id": "ttBfR3", "name": "easy adaptive sampling : Moiré", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only near the drawing. Left: none, for reference.\nMouse.x : ref separator \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["antialiasing", "sampling", "optimization", "adaptive", "gpmipmap"], "likes": 7, "viewed": 467, "published": 3, "date": "1599460524", "time_retrieved": "2024-07-30T20:46:45.524381", "image_code": "// variant of https://shadertoy.com/view/3l2BzV\n// adapted from https://shadertoy.com/view/3ljfRG\n\n#define N 7      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n  #define M(U,l)          T(U,l).w\n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O -= O;\n    float n = float(N),\n       // m = M( U, 2 ),               // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( U.x > s\n         && length(T(U,2)-T(U,0)) > eps ) {  //// neighborhood does not agree\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D ).w;\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = keyToggle(32)              // SPACE: show red/blue where not oversampled\n        ? T( U, 0 ).w == 1. ? vec4(1,0,0,1) : vec4(0,0,1,1)\n        : T( U, 0 ).wwww;\n      \n    if ( abs(U.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );        // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// f() should be a function, but fucking Common does not work like #include as anybody would like it to.\n// Here, it's the use of iTime and iResolution that uselessly screw things up for no good reason. \n\nfloat v; \n\n// --- Moiré https://www.shadertoy.com/view/ltjSDV\n\n//#define f(U)  vec4( sin( (U).x*(U).y/45. ) )\n//#define f(U)  vec4( sin( (U).x*(U).y/45. ) < .9 )\n\n// --- Moiré https://www.shadertoy.com/view/WtsczX\n\n//#define f(U)  vec4( fract( (U).x*(U).y / 360. ) )\n  #define f(U)  vec4( fract( (U).x*(U).y / 360. +iTime ) < .8 )\n\n", "buffer_b_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = f(U);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[475, 475, 511, 511, 1317]]}
{"id": "WlSBzc", "name": "Sparse Image Convolutions Demo", "author": "NBickford", "description": "An unofficial Shadertoy implementation of a kernel to convolve an image with a kernel using a few passes, and just a few samples at each pass. This was adapted from the GLSL sample code provided at https://www.graphics.rwth-aachen.de/publication/03312/", "tags": ["blur"], "likes": 4, "viewed": 1297, "published": 3, "date": "1599446536", "time_retrieved": "2024-07-30T20:46:46.474840", "image_code": "// Try out some choices of different blurs in the Common tab!\n//\n// This Shadertoy reimplements some of the kernels from the paper\n// \"High-Performance Image Filters via Sparse Approximations\", by\n// Kersten Schuster, Philip Trettner, and Leif Kobbelt.\n// Instead of implementing convolutions by using a sum of\n// separable filters (for instance), this paper shows how to\n// approximate a convolution using a series of small blurs\n// (like a Kawase blur, but only sampling from the lowest mip\n// level), and a nonlinear optimization technique for optimizing\n// these sample locations.\n//\n// Please see the Common tab for more information about these\n// data arrays, and how to choose which blur to use.\n//\n// This Shadertoy was adapted from the implementation in the\n// paper's supplemental material, available at\n// https://www.graphics.rwth-aachen.de/publication/03312/.\n// The original supplemental GLSL code was provided with the\n// following license:\n/*\nMIT License\n\nCopyright (c) 2020 Kersten Schuster, Philip Trettner, https://www.graphics.rwth-aachen.de/sparse-convolution-filters\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Blur pass 4; convert from linear space to sRGB.\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(1.43681, 2.54344, 0.216748),\n    vec3(-2.415687, 1.80615, 0.218565),\n    vec3(-2.61698, -1.60458, 0.190348),\n    vec3(0.402895, -2.64168, 0.191997),\n    vec3(2.68614, -0.660522, 0.181597)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(-10.1897, -6.63978, -0.0416478),\n    vec3(1.01261, 12.9293, 0.222653),\n    vec3(-3.02032, -5.57293, -0.0695762),\n    vec3(0.465853, -1.09348, 0.0201693),\n    vec3(12.6032, -7.06434, 0.229691),\n    vec3(-6.09681, 0.0123993, 0.0427806),\n    vec3(5.19344, -6.5085, 0.0807356),\n    vec3(-1.81583, 6.98087, 0.0793452),\n    vec3(-3.31758, -6.03042, 0.117162),\n    vec3(-10.4298, -6.99663, 0.202939),\n    vec3(-7.90574, -3.38485, 0.0311912),\n    vec3(-14.1662, -8.74606, 0.0399237)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-4.04026, 0.621857, 0.0424986),\n    vec3(-3.36541, -1.57338, 0.0940673),\n    vec3(-1.16709, -3.19144, 0.0410433),\n    vec3(0.617172, -2.15564, 0.138944),\n    vec3(2.45193, -2.70028, 0.120259),\n    vec3(3.37716, -0.327347, 0.0247386),\n    vec3(1.73432, 1.18305, 0.112826),\n    vec3(0.461604, 1.7323, 0.120453),\n    vec3(-0.471351, -0.67063, 0.103255),\n    vec3(-1.51033, 2.63167, 0.212972),\n    vec3(-5.95205, -3.55146, -0.0221648),\n    vec3(3.38171, -0.335923, 0.0390691)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(-1.44121, 1.3926, 0.288923),\n    vec3(-0.519235, -1.23553, 0.240054),\n    vec3(1.13891, 0.62907, 0.00623932),\n    vec3(0.585034, 1.79536, 0.149159),\n    vec3(0.130506, 0.702575, 0.11129),\n    vec3(-0.421168, 1.40214, 0.0164664),\n    vec3(-1.16781, 1.46627, 0.0100937),\n    vec3(1.65469, -0.508309, 0.225989),\n    vec3(1.80466, -0.646769, -0.00831556),\n    vec3(0.0328333, -1.15792, -0.00478501),\n    vec3(1.07334, 0.675361, 0.038271),\n    vec3(-1.02273, 0.487464, 0.00798755)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(-3.27394, 2.28318, 0.0839198),\n    vec3(-3.22113, -2.29823, 0.0678272),\n    vec3(-2.52098, -0.275563, 0.146882),\n    vec3(-1.55479, -2.23214, 0.171236),\n    vec3(-0.840715, -3.89265, 0.0508523),\n    vec3(0.507461, -2.26812, 0.0703195),\n    vec3(2.67858, -4.38707, -0.0252949),\n    vec3(3.98227, -0.539806, 0.0661041),\n    vec3(3.38545, 1.43471, 0.162026),\n    vec3(2.47186, 3.24992, 0.140319),\n    vec3(2.00646, 5.21202, 0.045469),\n    vec3(-0.506765, 2.74372, 0.0602144)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(0.822781, -0.513738, 0.302996),\n    vec3(0.047913, 0.0649032, 0.106269),\n    vec3(-0.559089, -1.52573, 0.21958),\n    vec3(0.663466, 1.11877, 0.152037),\n    vec3(-0.69649, -1.44846, 0.0853627),\n    vec3(0.166251, 3.15885, 0.00688147),\n    vec3(-0.790441, 2.56556, 0.0178789),\n    vec3(-0.225663, 2.78177, 0.00121393),\n    vec3(-1.03059, -0.356715, 0.0181373),\n    vec3(-0.703992, -1.44589, 0.0828073),\n    // Extra elements so that all passes can use the same number of samples\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(-1.59672, -1.67458, 0.113208),\n    vec3(1.47799, -1.63214, 0.176221),\n    vec3(1.49558, 0.787634, 0.225331),\n    vec3(-0.367021, 1.45392, 0.155453),\n    vec3(-1.35864, 0.40749, 0.0259248),\n    vec3(1.80442, -0.0501602, -0.00582266),\n    vec3(-0.230054, -1.57626, 0.0919024),\n    vec3(1.77735, 0.219959, -0.0335609),\n    vec3(-0.968267, -2.26735, 0.0159569),\n    vec3(-1.51391, 0.420281, 0.125971),\n    vec3(2.82087, 1.15074, 0.0591325),\n    vec3(-1.0905, -1.30001, -0.00238527)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n    \n    // Convert from linear space to sRGB for display\n    fragColor = linearToSRGB(fragColor);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Tiles the stars image across the screen, outputs to linear space.\n// This could also be a cubemap lookup, but most of Shadertoy's cubemaps aren't nearly high-resolution enough.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert from pixel coordinates to UV coordinates\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    // Slowly zoom, rotate, and pan the image over time\n\t// The goal here is to involve features smaller than a pixel, so that we can observe sources of aliasing.\n    // Zoom\n    {\n        float zoomFactor = exp(0.5f + 0.5f * sin(0.1f * iTime));\n        uv = 0.5f + zoomFactor * (uv - 0.5f);\n    }\n    // Rotate\n    {\n        float angle = iTime * 0.02f;\n        float ca = cos(angle);\n        float sa = sin(angle);\n        uv = vec2(ca * uv.x - sa * uv.y, sa * uv.x + ca * uv.y);\n    }\n    // Pan\n    {\n        float panX = sin(iTime * 0.01f);\n        uv.x += panX;\n    }\n    // Image lookup; convert to linear space\n    fragColor = sRGBToLinear(texture(iChannel0, uv));\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// sRGB to linear-space approximation\nvec4 sRGBToLinear(vec4 color){\n    return vec4(pow(color.rgb, vec3(2.2f)), color.a);\n}\n\n// Linear-space to sRGB approximation, inverse of sRGBToLinear for colors with all components positive\nvec4 linearToSRGB(vec4 color){\n    return vec4(pow(color.rgb, vec3(1.0f/2.2f)), color.a);\n}\n\n// SAMPLES and NUMSAMPLES can be any of:\n// gaussianBlur4_5, 5 (a 35-pixel Gaussian blur)\n// gon34_12, 12 (a triangular blur)\n// gon64_12, 12 (a hexagonal blur)\n// dollar4_12, 12 (a dollar-shaped blur)\n// heart4_12, 12 (a heart-shaped blur)\n// circle4_12, 12 (a circular-shaped blur)\n//\n// These arrays were obtained from the original GLSL files using the substitutions\n// \"color += textureLod(uTex, (uv + vec2(\" -> \"vec3(\"\n// \")) / ts, 0).rgb *\" -> \",\"\n// \";\\n\" -> \"),\\n\"\n// Note that the supplemental shaders include more than those shown here, including\n// higher-quality 32-sample-per-pass versions of many of these.\n#define SAMPLES gon34_12\n#define NUMSAMPLES 12", "buffer_b_code": "// Blur pass 1\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(-0.536899, 1.71559, 0.190943),\n    vec3(-1.63396, -0.277769, 0.202339),\n    vec3(-0.464825, -1.77054, 0.18752),\n    vec3(1.59937, -1.68088, 0.182522),\n    vec3(1.51572, 0.62634, 0.236254)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(1.70516, -1.68579, 0.104911),\n    vec3(2.04725, -0.799805, 0.129517),\n    vec3(1.49288, 0.559683, 0.114731),\n    vec3(0.511804, 1.77538, 0.118443),\n    vec3(-0.274264, 1.42485, 0.105618),\n    vec3(-1.00633, 0.724252, 0.0637492),\n    vec3(-1.05587, -0.0625124, 0.0948828),\n    vec3(-1.7732, -1.46542, 0.184245),\n    vec3(-0.0125602, -1.41111, 0.11403),\n    vec3(1.94606, -1.17605, -0.0518507),\n    vec3(0.261477, 0.164745, 0.00281854),\n    vec3(2.94477, 2.16834, 0.00627668)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(1.66463, 0.575596, 0.171307),\n    vec3(2.59847, 2.46116, 0.135754),\n    vec3(-0.274838, 1.27159, 0.120061),\n    vec3(0.543628, 2.36866, 0.141742),\n    vec3(-2.10768, 2.16833, 0.0621388),\n    vec3(-0.527432, -0.199986, 0.12739),\n    vec3(-2.65842, 0.537764, 0.110027),\n    vec3(1.40294, -1.29735, 0.0229304),\n    vec3(-2.3235, -0.928571, 0.0321623),\n    vec3(-1.11176, -2.43382, 0.0348939),\n    // Extra elements so that all passes can use the same number of samples.\n    // (A single-kernel implementation might use a different value of\n    // NUMSAMPLES per-pass; these are included here to make the implementation\n    // slightly simpler.)\n    vec3(0.0f, 0.0f, 0.0f),\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(6.5186, -10.1901, 0.195821),\n    vec3(10.2192, -3.89199, -0.00296725),\n    vec3(8.29047, 0.0717141, -0.0507564),\n    vec3(7.50711, 10.1734, 0.162271),\n    vec3(3.13649, 15.5857, 0.143106),\n    vec3(-7.58524, 10.1288, 0.164761),\n    vec3(-10.6028, 5.54551, -0.0220465),\n    vec3(-9.41428, -1.35561, -0.0391754),\n    vec3(-9.26954, -9.06272, 0.157142),\n    vec3(-4.41262, -13.7269, 0.133598),\n    vec3(-4.38129, -20.2546, 0.0759993),\n    vec3(2.46962, -15.1735, -0.062585)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(3.65816, -0.381523, 0.155434),\n    vec3(1.69849, 5.25483, 0.0777845),\n    vec3(5.17014, -1.76344, 0.00593576),\n    vec3(-1.341, 4.26359, 0.122496),\n    vec3(-3.73209, 2.40436, 0.0857596),\n    vec3(5.42613, 1.5562, 0.128623),\n    vec3(-1.33212, 0.797307, 0.124572),\n    vec3(-2.85474, -1.57333, 0.0203082),\n    vec3(1.44816, -1.56033, 0.124728),\n    vec3(1.21086, 2.4045, 0.153089),\n    vec3(-0.162764, -2.68914, 0.0120604),\n    vec3(6.28892, 6.68655, -0.0159067)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-0.567121, -2.52652, 0.219092),\n    vec3(2.11451, 3.22905, 0.0242579),\n    vec3(1.56886, -1.13426, 0.127749),\n    vec3(2.17072, 0.808855, 0.101107),\n    vec3(1.60469, -3.49785, 0.0849859),\n    vec3(-0.25896, 2.38741, 0.0920342),\n    vec3(-3.53353, 0.777782, 0.084115),\n    vec3(-0.382732, -0.0834882, 0.0941771),\n    vec3(-2.55186, -1.23522, 0.0883374),\n    vec3(-0.413048, -0.212653, 0.0819732),\n    vec3(1.19929, 0.934426, 0.0241353),\n    vec3(1.2064, 0.947841, 0.00568039)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(3.59982, -9.36765, 0.0817689),\n    vec3(7.72927, -6.42077, 0.0916319),\n    vec3(9.73355, -1.45044, 0.0846194),\n    vec3(9.46391, 3.42274, 0.0714825),\n    vec3(6.70992, 7.27607, 0.088618),\n    vec3(1.83428, 9.79507, 0.0850097),\n    vec3(-3.48193, 9.38542, 0.0839686),\n    vec3(-7.6754, 6.23976, 0.0873239),\n    vec3(-9.51306, 1.44068, 0.0833687),\n    vec3(-9.42275, -3.48246, 0.0721704),\n    vec3(-6.56181, -7.23146, 0.0918506),\n    vec3(-1.91408, -10.2001, 0.0849586)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Blur pass 2\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(1.25205, -5.35358, 0.176228),\n    vec3(5.2637, -0.579565, 0.171455),\n    vec3(2.44993, 4.45327, 0.210041),\n    vec3(-3.46991, 3.48145, 0.232004),\n    vec3(-4.36333, -2.40382, 0.211557)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(3.65293, -1.22466, 0.0896532),\n    vec3(2.38677, 1.27728, 0.157198),\n    vec3(-1.999, 2.19298, 0.07476),\n    vec3(0.000836663, 5.36977, 0.132487),\n    vec3(-2.59808, 0.714412, 0.105075),\n    vec3(-4.67753, -3.27138, 0.122933),\n    vec3(-1.32861, -3.32389, 0.0934033),\n    vec3(0.694742, -3.29434, 0.101147),\n    vec3(4.42439, -3.13249, 0.129403),\n    vec3(0.831605, 2.59237, 0.0796497),\n    vec3(-2.35004, -1.32128, 0.00239838),\n    vec3(-2.66117, -4.7948, -0.0302412)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-0.533295, -1.93182, -0.0265649),\n    vec3(-5.39325, -7.50618, 0.121408),\n    vec3(0.755642, -7.43218, 0.146205),\n    vec3(6.33766, -5.64283, 0.101193),\n    vec3(8.90058, 0.463735, 0.122632),\n    vec3(4.68577, 7.91363, 0.133023),\n    vec3(-1.68735, 8.04164, 0.13304),\n    vec3(8.13964, 10.7962, -0.00543929),\n    vec3(-10.6892, -4.5621, 0.0421263),\n    vec3(-9.66638, 0.552825, 0.124039),\n    vec3(-6.96923, 6.5773, 0.0966725),\n    vec3(8.20864, 0.312374, 0.0115968)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(8.18306, -2.82015, 0.126829),\n    vec3(-4.8865, -7.06012, 0.0115041),\n    vec3(2.14423, -8.27259, 0.0953727),\n    vec3(5.62741, -7.37869, 0.110022),\n    vec3(8.22676, -2.59528, 0.00265503),\n    vec3(9.54661, 3.96422, 0.03392),\n    vec3(5.66825, 6.35028, 0.0278248),\n    vec3(-1.35411, 9.94735, 0.0902114),\n    vec3(-4.99265, 9.63192, 0.103152),\n    vec3(-7.24023, 4.53206, 0.135558),\n    vec3(-8.74337, -1.38169, 0.0361024),\n    vec3(11.3964, 9.18145, 0.00310094)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(0.700995, 4.59081, 0.176748),\n    vec3(-2.90993, -4.98834, 0.0241374),\n    vec3(-9.62439, 9.82718, 0.161626),\n    vec3(-13.4597, 4.36941, 0.12912),\n    vec3(-7.45933, -2.51028, 0.175774),\n    vec3(-2.40969, 9.65172, 0.08051),\n    vec3(-0.16622, -9.15847, 0.15876),\n    vec3(5.85776, -4.29121, 0.10937),\n    vec3(8.91624, -6.32051, 0.0377648),\n    vec3(8.09934, -12.4869, 0.0266486),\n    vec3(10.2874, 0.845592, 0.108664),\n    vec3(-2.23857, 9.55102, -0.000425388)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-1.22416, 0.0725762, 0.0787856),\n    vec3(-8.14769, -0.563024, 0.0210209),\n    vec3(-3.79417, -4.40789, 0.0631343),\n    vec3(-8.05458, -3.7453, -0.0283331),\n    vec3(4.25173, -1.34132, 0.0974819),\n    vec3(0.453895, -2.75538, 0.138451),\n    vec3(-2.29387, 2.30927, 0.109067),\n    vec3(5.9059, 1.43775, 0.0501956),\n    vec3(2.89888, 2.57681, 0.0937886),\n    vec3(1.95178, 4.70348, 0.0768983),\n    vec3(-12.434, -3.17118, -0.0230655),\n    vec3(-16.466, 1.73528, 0.0132859)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(-12.8307, -10.6912, 0.107696),\n    vec3(-4.36955, -16.4317, 0.107829),\n    vec3(5.58789, -15.888, 0.108793),\n    vec3(13.6857, -9.25968, 0.112215),\n    vec3(16.7205, 1.15419, 0.111182),\n    vec3(12.5686, 10.5563, 0.108063),\n    vec3(4.12142, 16.2604, 0.108458),\n    vec3(-5.78583, 15.9181, 0.10576),\n    vec3(-13.6766, 9.40867, 0.10071),\n    vec3(-17.099, -1.43724, 0.109447),\n    vec3(-0.24529, -0.059554, -0.134227),\n    vec3(-18.094, 6.47425, 0.0223338)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Blur pass 3\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(-3.39663, -2.7284, 0.198133),\n    vec3(1.63335, -3.57948, 0.23848),\n    vec3(4.4046, 0.571102, 0.213638),\n    vec3(0.639859, 4.51865, 0.185342),\n    vec3(-3.73462, 2.40625, 0.162287)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(5.35471, -2.94119, 0.201316),\n    vec3(5.31255, 0.0164711, -0.0311385),\n    vec3(3.84226, -1.798, 0.154307),\n    vec3(-0.0366749, 5.92087, 0.0832701),\n    vec3(-1.39287, 7.64723, 0.269163),\n    vec3(-4.9571, 6.65531, -0.00919251),\n    vec3(-3.50706, -4.23017, -0.0283372),\n    vec3(-7.76777, -3.00107, 0.0359688),\n    vec3(-6.43813, -2.19912, 0.1401),\n    vec3(-1.39586, -2.89033, 0.0498788),\n    vec3(-0.47254, 0.419053, 0.000786616),\n    vec3(-7.78067, -3.00069, 0.0978381)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-11.4216, -9.42619, 0.0951047),\n    vec3(-4.82981, -15.9463, 0.118886),\n    vec3(6.66657, -16.1113, 0.119641),\n    vec3(12.3225, -9.06993, 0.0918153),\n    vec3(15.9922, -1.33152, 0.103125),\n    vec3(12.652, 6.11127, 0.0972589),\n    vec3(8.1771, 13.1942, 0.102126),\n    vec3(-0.325334, 13.5621, 0.0722747),\n    vec3(-8.00059, 13.0954, 0.0973644),\n    vec3(-12.1185, 5.47399, 0.0973365),\n    vec3(-15.1627, -2.1324, 0.0972181),\n    vec3(0.548823, -1.2205, -0.126258)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(0.130303, 3.38697, 0.199111),\n    vec3(-1.10735, -2.89459, -0.0252111),\n    vec3(-2.67469, 1.61177, 0.0940697),\n    vec3(-1.50788, -1.51962, 0.0635233),\n    vec3(0.0167133, -0.677603, 0.100761),\n    vec3(-0.539129, -2.62806, 0.107023),\n    vec3(-0.370213, 0.814803, 0.15236),\n    vec3(2.47696, -0.341743, 0.212585),\n    vec3(1.53184, 1.66726, 0.0767999),\n    vec3(3.42228, 2.44445, 0.178488),\n    vec3(2.57359, -2.08544, 0.0940824),\n    vec3(1.34369, 0.649971, -0.00137683)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(-0.687123, -17.6358, 0.119676),\n    vec3(9.77666, -9.20554, 0.0811975),\n    vec3(16.2075, -4.16374, 0.0824521),\n    vec3(21.4838, 4.22734, 0.0439286),\n    vec3(20.783, 13.671, 0.15287),\n    vec3(11.004, 13.5154, -0.0279286),\n    vec3(-3.31496, 12.4149, 0.0602602),\n    vec3(-11.5456, 13.5427, 0.127682),\n    vec3(-19.4614, 3.26591, 0.120687),\n    vec3(-11.6221, -0.800815, -0.119034),\n    vec3(-16.6227, -5.17532, 0.123098),\n    vec3(-5.13828, -15.6544, 0.0179506)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-7.53708, 8.2229, 0.118895),\n    vec3(-16.4322, 8.5273, 0.101418),\n    vec3(-6.45548, -0.466683, 0.115216),\n    vec3(-11.0569, -13.8238, 0.118329),\n    vec3(-2.54908, -7.83096, 0.120828),\n    vec3(-1.55015, -14.4138, -0.00914695),\n    vec3(13.0091, -15.9051, 0.0668323),\n    vec3(8.19357, -8.65804, 0.126573),\n    vec3(6.15756, 1.51916, 0.137528),\n    vec3(15.8677, 7.99373, 0.135305),\n    vec3(-0.000730786, 20.5796, 0.119454),\n    vec3(3.08351, 10.7196, 0.129684)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(0.636954, 3.41463, 0.111319),\n    vec3(-2.30042, 2.40711, 0.0444438),\n    vec3(-3.52362, 0.696351, 0.106329),\n    vec3(-2.28476, -1.50314, 0.132982),\n    vec3(-0.348131, -3.5531, 0.138401),\n    vec3(2.28939, -2.52018, 0.0915953),\n    vec3(3.61064, -0.511144, 0.100257),\n    vec3(2.39312, 1.42992, 0.172995),\n    vec3(-0.192222, 5.13839, 0.0350061),\n    vec3(-2.46748, 2.48324, 0.055471),\n    vec3(-0.213747, 5.16418, 0.0206963),\n    vec3(-1.84128, -0.155258, 0.0338473)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBzc.jpg", "access": "api", "license": "mit", "functions": [[5553, 5553, 5610, 5610, 6010]]}
{"id": "3tSfzc", "name": "cosas-raras", "author": "jorge2017a1", "description": "cosas-raras", "tags": ["cosasraras"], "likes": 2, "viewed": 258, "published": 3, "date": "1599446313", "time_retrieved": "2024-07-30T20:46:47.934936", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n\n\n\nvec3 opRep3D( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n//------------------------\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat esferaConEsferas(vec3 p, float numItem)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n\tfloat sdsp1=sdSphere(p, 6.0);   \n    float sdb1= sdBox(rep2, vec3(6.5,0.2,5.5));\n    \n    float res = opSU(sdsp1, sdb1,0.1);\n  \treturn  res;\n}\n\n\nfloat CilindroConEsferas(vec3 p, float numItem)\n{\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n\t//float sdsp1=sdSphere(p, 6.0);   \n    float sdsp1= sdCylinderXY(p, vec2(2.0,6.0) );\n    float sdb1= sdBox(rep2, vec3(6.5,0.2,5.5));\n    \n    \n    float res = opSU(sdsp1, sdb1,0.1);\n  \treturn  res;\n}\n\n\n\nfloat esferaConEsferasv2(vec3 p, float numItem)\n{\n    \n    \n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n\tfloat sdsp1=sdSphere(p, 3.5);   \n    float sdb1= sdTorus( rep2, vec2(4.0,1.0) );\n    \n    \n    float res = opSU(sdsp1, sdb1,0.5);\n  \n    \n    \n\treturn  res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n\n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n  \tres =opU3(res, vec3(planeDist5,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,100.0,MATERIAL_NO)); \n  \n    \n    p.y=p.y-5.0;\n   \n    vec3 pr= rotate_x( p, iTime); \n    float sf1= CilindroConEsferas( pr, 6.0);\n    res =opU3(res, vec3(sf1,30.0,MATERIAL_NO)); \n     \n    float sf2= esferaConEsferas(pr-vec3(-15.0,0.0,0.0), 10.0);\n    res =opU3(res, vec3(sf2,4.0,MATERIAL_NO)); \n    \n    float sf3= esferaConEsferasv2(pr-vec3(15.0,0.0,0.0), 10.0);\n    res =opU3(res, vec3(sf3,5.0,MATERIAL_NO)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,-1)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n  \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\t\n   \n                \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=true;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    vec3 ro=vec3(0.0,7.0,-25.0);\n    //= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n     \n    if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n       \n      \n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 233, 233, 257], [259, 274, 305, 305, 455], [458, 475, 508, 508, 573], [575, 575, 611, 611, 714], [716, 716, 754, 754, 857], [860, 860, 898, 898, 1001], [1004, 1004, 1042, 1042, 1145], [1148, 1192, 1238, 1238, 1270], [1272, 1272, 1315, 1315, 1347], [1349, 1349, 1397, 1397, 1430], [1478, 1478, 1507, 1507, 1633], [1635, 1635, 1665, 1665, 1791], [1793, 1831, 1869, 1869, 1922], [1926, 1926, 1964, 1964, 2017], [2059, 2084, 2119, 2119, 2212], [2214, 2214, 2249, 2249, 2342], [2344, 2344, 2378, 2378, 2471], [2476, 2476, 2506, 2506, 2575], [2577, 2577, 2611, 2611, 2708], [2713, 2713, 2739, 2739, 2793], [2796, 2796, 2830, 2830, 3003], [3006, 3061, 3102, 3102, 3195], [3198, 3198, 3245, 3245, 3553], [3556, 3556, 3605, 3605, 3970], [3974, 3974, 4023, 4023, 4357], [4360, 4400, 4425, 4425, 5719], [5723, 5768, 5835, 5835, 6208], [6263, 6263, 6288, 6288, 6528], [6531, 6594, 6629, 6720, 7244], [7303, 7303, 7340, 7340, 7667], [7725, 7796, 7832, 7832, 8038], [8041, 8112, 8136, 8136, 8396], [8446, 8480, 8529, 8529, 8765], [8766, 8800, 8880, 8880, 9521], [9617, 9617, 9710, 9710, 10006], [10009, 10058, 10115, 10115, 11387]]}
{"id": "WlBBzc", "name": "Tunel-deformado", "author": "jorge2017a1", "description": "Tunel-deformado", "tags": ["tuneldeformado"], "likes": 2, "viewed": 292, "published": 3, "date": "1599446309", "time_retrieved": "2024-07-30T20:46:48.949223", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\n//referencia Iq\nvec2 disp0( in vec3 p )\n{\n\treturn vec2( pow( 0.5 + 0.5*cos( 1.0*iTime ), 2.0 ),\n                 pow( 0.5 + 0.5*cos( 25.0*p.x  + 1.5*iTime)*\n\t\t\t\t\t            sin( 25.0*p.y  + 2.0*iTime )*\n\t\t\t\t\t            sin( 25.0*p.z  + 1.0*iTime ), 3.0) );\n}\n\n\nvec2 disp2( in vec3 p )\n{\n\treturn vec2(  0.5 + 0.5*cos( 1.0*iTime ),\n                  0.5 + 2.5*cos( 1.2*p.x )*sin( 1.3*p.y )*sin( 2.4*p.z  ) );\n    \n}\n\n\nvec2 disp( in vec3 p )\n{\n\treturn vec2(  0.5 + 0.5*cos( 1.0 ),\n                  0.5 + 2.5*cos( 1.2*p.x )*sin( 1.3*p.y )*sin( 2.4*p.z  ) );\n    \n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n\n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n  \n    \n    p.y=p.y-5.0;\n   \n    \n\tvec3 q=p;\n    \n    \n    float cz=60.00;\n    \n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n   \n    p=q;\n\t\n     \n    \n    \n    float sdcy1= sdCylinderXY(p- vec3(0.0,10.0,0.0), vec2(11.0,24.0) );\n    float sdcy2= sdCylinderXY(p- vec3(0.0,10.0,0.0), vec2(9.5,25.0) );\n    \n    vec2 di = disp2( p );\n    float dif= differenceSDF(sdcy1, sdcy2)+0.4*di.x+0.2*di.y;; \n    res =opU3(res, vec3( dif,26,MATERIAL_NO)); \n\n    \n    //res =opU3(res, vec3(1.0,0.0,-1)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n  \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\t\n                \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*20.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n    \n    vec3 ro=vec3(0.0,13.0,-25.0+t);\n    \n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n   if(i== 30 )\n    { \n    \treturn vec3(0.1, 0.5, 1.0);\n    }   \n    \n    if(i== 31 )\n    { \n    \treturn vec3(0.0, 0.6, 0.0);\n     }\n      \n  \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 215, 215, 318], [320, 320, 358, 358, 461], [464, 464, 502, 502, 605], [608, 608, 646, 646, 749], [752, 796, 842, 842, 874], [876, 876, 919, 919, 951], [953, 953, 1001, 1001, 1034], [1082, 1082, 1111, 1111, 1237], [1239, 1239, 1269, 1269, 1395], [1398, 1423, 1458, 1458, 1551], [1553, 1553, 1588, 1588, 1681], [1683, 1683, 1717, 1717, 1810], [1815, 1831, 1856, 1856, 2075], [2078, 2078, 2103, 2103, 2230], [2233, 2233, 2257, 2257, 2378], [2382, 2422, 2447, 2447, 3661], [3665, 3710, 3777, 3777, 4150], [4205, 4205, 4230, 4230, 4470], [4473, 4536, 4571, 4662, 5186], [5245, 5245, 5282, 5282, 5609], [5667, 5738, 5774, 5774, 5980], [5983, 6054, 6078, 6078, 6338], [6388, 6422, 6471, 6471, 6707], [6708, 6742, 6822, 6822, 7463], [7559, 7559, 7652, 7652, 7944], [7947, 7996, 8053, 8053, 9352]]}
{"id": "WtBBRc", "name": "The Color Bars View", "author": "samuelotherion", "description": "Use your mouse!", "tags": ["j4f"], "likes": 3, "viewed": 306, "published": 3, "date": "1599436875", "time_retrieved": "2024-07-30T20:46:49.834855", "image_code": "#define VO void\n#define B1 bool\n#define I1 int\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n#define _01 F2(0,1)\n#define _0  _01.xxx\n\n// some globals\nF4 O,   // output color\n   R;   // resolution (xy) and its inverse (zw)\n\nF2 N,   // (0,0) bis (1,1)\n   M;\n\nVO init( F2 i ) {\n    \n    R.xy = iResolution.xy;\n    R.zw = 1. / R.xy;\n\n    N = i * R.zw;\n    \n    M = iMouse.xy * R.zw;\n\n    if( M.x <= 0. || 1. < M.x ) M.x = .5;\n    if( M.y <= 0. || 1. < M.y ) M.y = .5;\n    \n        \n    O = texture( iChannel0, N );\n}\n\nVO work( ) {\n    \n    F1 parts = 1. + floor( 128. * M.y );\n\n    F2 Nn = floor( parts * N ) / parts;\n\n    F3 cl = texture( iChannel0, Nn + .5 / parts ).rgb;\n\n    F2 Nr = N - Nn;\n\n    F1 f = 1. / ( 30. * parts ), p = parts * 1.2;\n\n    O.rgb =\n        5. * f < Nr.x  &&  Nr.x < 9. * f\n        \t? Nr.y * p < cl.r\n        \t\t? F3( N.x < M.x ? 1. : cl.r, 0, 0 )\n        \t\t: _0\n            : 13. * f < Nr.x  &&  Nr.x < 17. * f\n                ? Nr.y * p < cl.g\n            \t    ? F3( 0, N.x < M.x ? 1. : cl.g, 0 )\n                \t: _0\n                    \t: 21. * f < Nr.x && Nr.x < 25. * f\n\t\t\t\t? Nr.y * p < cl.b\n\t\t\t\t\t? F3( 0, 0, N.x < M.x ? 1. : cl.b )\n\t                : _0\n\t\t\t\t: _0;\n\n}\n\nVO finish( out F4 o ) {\n\n    o = F4( clamp( O.rgb / O.a, 0., 1. ), 1. );\n}\n\nVO mainImage( out F4 o, in F2 i ) {\n\n    init( i );\n\n    work( );\n\n    finish( o );        \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 293, 293, 531], [533, 533, 545, 545, 1214], [1216, 1216, 1239, 1239, 1290], [1292, 1292, 1327, 1327, 1385]]}
{"id": "WlBBz3", "name": "Day 260", "author": "jeyko", "description": "Some minimalist/bauhaus stuff.\n", "tags": ["paint", "watercolor", "watercolour", "mdtmjvm"], "likes": 15, "viewed": 582, "published": 3, "date": "1599427121", "time_retrieved": "2024-07-30T20:46:50.668626", "image_code": "// Fork of \"Day 260 - LOGO DRAFT 1\" by jeyko. https://shadertoy.com/view/ttjBRV\n// 2020-09-06 20:56:55\n\n// Fork of \"Day 259\" by jeyko. https://shadertoy.com/view/tlBBRK\n// 2020-09-06 09:18:13\n\n// Fork of \"Day 258\" by jeyko. https://shadertoy.com/view/tl2fRG\n// 2020-09-05 10:41:09\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\n\n// ----------\n\n\nvec2 guv;\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode){\n    //float dea = smoothstep(df,0.,da );\n    float deb = smoothstep(df,0.,db );\n    \n    //vec3 oa = mix(vec3(0),ca,dea);\n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 t = texture(iChannel2,guv);\n    \n    cb*=1. - smoothstep(1.,0.,abs(db)*7. + t.z*1.53)*0.2;\n    \n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        \n    \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.));\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, deb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, deb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), deb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), deb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), deb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., deb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, deb);\n    }\n        \n    return co;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    df = dFdx(uv.x);\n    \n    guv = uv;\n    uv *= 0.5;\n    //uv *= rot(-0.25*pi);\n    //uv = kink( uv, vec2(0.1), 0.5);\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 col = vec3(1.);\n\n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    //d = length(uv) - 0.15;\n\n    \n    float wd = 0.005;\n    float h = 0.22;\n    float horiz = 0.319;\n    float twd = 0.03;\n    \n    float T = iTime*0.4 + 1.;\n    \n    float modthing = sin((floor(T) + pow(fract(T), 5.) )*pi/2.)*0.5 + 0.5;\n    \n    // COOLINE\n    \n    d = sdLine( uv - 0.14, vec2(-0.01,0.) , vec2(0.4,0.),0.) - 0.001;\n\t\n    \n    d = xor(d,length(uv) - 0.2,0.02);\n    \n    // COOLINE\n    d = min(d,sdLine( uv + vec2(0.13,0.1), vec2(-0.05,0.) , vec2(-0.3,0.),0.) - 0.001);\n\n    \n    d = xor(d,-abs(sdLine( uv + 0., vec2(-0.1,0.) , vec2(0.2,0.),1.) - 0.03) - 0.002,0.02);\n    \n    \n    // SQUARE\n    d = xor(d,-abs(sdBox( uv + 0.0, vec2(0.1))) - 0.001,0.02 + modthing*0.03);\n    \n    \n    d = xor(d,-abs(sdBox( uv*rot(0.25*pi) + 0.0, vec2(0.25))) - 0.002,0.02);\n    \n     \n    col = colour( d, col, vec3(1.)*0.01, 0);\n   \n    d = xor(d,sdBox(uv,vec2(0.5,0.25)),0.031 );\n    \n    \n    d = xor(d,-length(uv)-0.1,0.11 + modthing*0.1);\n    \n    \n    col = colour( d, col, vec3(0.01,0.01,0.0), 0);\n\t\n    d = xor(d,-length(uv)-0.,0.01);\n    col = colour( d, col, vec3(0.01,0.01,0.0), 0);\n\t\n    \n    d = xor(d,-length(uv)-0.,0.015);\n    //col = colour( d, col, vec3(0.11,0.21,0.4)*0.02, 0);\n\tcol = colour( d, col, vec3(0.01,0.01,0.0)*1., 0);\n\t\n    \n    uv = abs(uv);\n    \n    \n    float db = sdBox(uv - vec2(horiz,0.),vec2(wd,0.13));\n    db = max(db,uv.y - h);\n    \n    db = min(db,sdBox(uv - vec2(horiz - twd + wd,h),vec2(twd,wd)));\n    \n    d = xor(d,-db,0.1);\n    \n    col = colour( d, col, vec3(1.), 0);\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*1.4;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*0.1;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.5545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 303, 303, 360], [361, 361, 394, 394, 923], [924, 924, 942, 942, 1270], [1315, 1315, 1366, 1407, 2675], [2677, 2677, 2734, 2734, 5403]]}
{"id": "3lBBR3", "name": "piramides-3", "author": "jorge2017a1", "description": "piramides-3", "tags": ["pyramids", "piramides3"], "likes": 1, "viewed": 247, "published": 3, "date": "1599423515", "time_retrieved": "2024-07-30T20:46:51.672941", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB) \n{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB) \n{ return max(distA, -distB);}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ resp = d1;}\n    else{resp = d2; }\n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ resp = d1; }\n    else { resp = d2; }\n   return resp; \n}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n///-----------------------------------\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\nfloat opScalePyramidv3( in vec3 p, in float s )\n{\n    //return primitive(p/s)*s;\n    vec3 s3;\n    s3.x=s;\n    s3.y=10.0;\n    s3.z=s;\n        \n    return sdPyramid(p/s3, s)*s3.x;\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat piramideconboxAnchoMas(vec3 p, vec3 b, float posAlto)\n{   \n    float sdPy3=opScalePyramidv3( p-vec3(0.0,0.0,0.0), 7.0 );\n    //vec3 opAngRep( vec3 p, float a )\n    \n    vec3 b1=vec3(b.x, b.y, b.z);\n    vec3 b2=vec3(b.z, b.y, b.x);\n    \n    float sdb1= sdBox(p-vec3(0.0,posAlto,0.0), b1);  //x\n    float sdb2= sdBox(p-vec3(0.0,posAlto,0.0), b2 );  //z\n    \n    float res=differenceSDF(sdPy3, sdb1); \n    res=differenceSDF(res, sdb2); \n    \n    \n    \n    posAlto=posAlto+6.0;\n    vec3 b1a=vec3(b.x, b.y+2.0, b.z);\n    vec3 b2a=vec3(b.z, b.y+2.0, b.x);\n    \n    float sdb1a= sdBox(p-vec3(0.0,posAlto,0.0), b1a);  //x\n    float sdb2a= sdBox(p-vec3(0.0,posAlto,0.0), b2a );  //z\n    \n    float resa=differenceSDF(res, sdb1a); \n    resa=differenceSDF(resa, sdb2a); \n    \n      posAlto=posAlto+7.0;\n    vec3 b1b=vec3(b.x, b.y+2.0, b.z);\n    vec3 b2b=vec3(b.z, b.y+2.0, b.x);\n    \n    float sdb1b= sdBox(p-vec3(0.0,posAlto,0.0), b1b);  //x\n    float sdb2b= sdBox(p-vec3(0.0,posAlto,0.0), b2b );  //z\n    \n     resa=differenceSDF(resa, sdb1b); \n    resa=differenceSDF(resa, sdb2b); \n    \n    \n    posAlto=posAlto+7.0;\n    vec3 b1c=vec3(b.x-0.5, b.y+2.0, b.z);\n    vec3 b2c=vec3(b.z-0.5, b.y+2.0, b.x);\n    \n    float sdb1c= sdBox(p-vec3(0.0,posAlto,0.0), b1c);  //x\n    float sdb2c= sdBox(p-vec3(0.0,posAlto,0.0), b2c );  //z\n    \n    resa=differenceSDF(resa, sdb1c); \n    resa=differenceSDF(resa, sdb2c); \n     //res=differenceSDF(res, resa); \n    \n    return resa;\n\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n   \n    float planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,32.0,MATERIAL_NO)); //inf\n       \n    \n    \n\tvec3 q=p;\n    float cx=47.0;\n    float cy=11.0;\n    float cz=20.00;\n    \n   \n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n   \n    p=q;\n\t\n    \n    \n    float sdPy3= piramideconboxAnchoMas(p, vec3(6.0,1.0,2.0), 2.0);\n        \n    res =opU3(res, vec3(sdPy3,50.0,MATERIAL_NO)); \n    \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n }\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n\n//------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*10.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(10.0,8.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tfloat d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n   vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n   \n   float dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n//----------------------------------------------------\nfloat hex(vec2 p, float r2)\n{\n    p.x *= 1.16;\n    p.y += mod(floor(p.x), 4.0) * 0.5;\n    p = abs((mod(p, 1.00) - 0.5));\n    return abs(max(p.x * 1.5 + p.y, p.y * 2.0) - r2);\n}\n\nvec4 hexColor(vec2 pos)\n{\n    vec2  p   = pos * 0.2;\n    float r1  = 0.25;\n    float r2  = -0.005;\n    vec4 hColor = vec4(smoothstep(.0, r1, hex(p,1.0 - r2)));\n    hColor = (1.0 - hColor) * 0.65;\n    return hColor;\n}\n//----------------------------------\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n   \n    \n     if(i== 30 )\n    { \n    \tvec4 v4= hexColor(mObj.p.xy);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n    \n    if(i== 31 )\n    { \n    \tvec4 v4= hexColor(mObj.p.zy);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n    \n    if(i== 32 )\n    { \n    \tvec4 v4= hexColor(mObj.p.xz);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n    \n      \n    if(i== 50 )\n    {\n     \n           \n            vec3 p = mObj.p;\n        \t//vec3 p =  mObj.normal*0.5;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 194, 225, 225, 375], [379, 423, 469, 469, 496], [498, 498, 541, 541, 568], [570, 570, 618, 618, 646], [694, 694, 723, 723, 811], [813, 813, 843, 843, 934], [936, 961, 996, 996, 1089], [1091, 1091, 1126, 1126, 1219], [1221, 1221, 1255, 1255, 1348], [1350, 1389, 1424, 1424, 1909], [1912, 1912, 1961, 1992, 2091], [2093, 2093, 2127, 2127, 2300], [2302, 2330, 2371, 2371, 2464], [2466, 2466, 2527, 2527, 3932], [3936, 3976, 4001, 4001, 4893], [4897, 4942, 5009, 5009, 5382], [5437, 5437, 5462, 5462, 5702], [5705, 5768, 5803, 5894, 6418], [6477, 6477, 6514, 6514, 6841], [6899, 6970, 7006, 7006, 7212], [7215, 7286, 7310, 7310, 7558], [7608, 7642, 7691, 7691, 7913], [7914, 7948, 8028, 8028, 8557], [8559, 8610, 8703, 8703, 8954], [8957, 9006, 9063, 9063, 10246]]}
{"id": "3lSfR3", "name": "corredor-v15", "author": "jorge2017a1", "description": "corredor-v15", "tags": ["corredorv15"], "likes": 2, "viewed": 282, "published": 3, "date": "1599423485", "time_retrieved": "2024-07-30T20:46:52.671272", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2Dinv(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 rotate2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c)*vec2(1.0,1.0);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    \n    p.y=p.y-5.0;\n\n\tvec3 q=p;\n    float cz=22.00;\n\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n\n    p=q;\n\t    \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xy = rotatev2(pp.xy, iTime);\n     pp.x=pp.x+posx;\n   \t p=pp;\n    \n    \n    \n    float sdb1= sdBox(p-vec3(0.0,0.0,0.0), vec3(15.0,15.0,20.0) );\n    float sdb2= sdBox(p-vec3(0.0,0.0,0.0), vec3(14.0,14.0,22.0) );\n    \n    float dif =differenceSDF(sdb1, sdb2) ;\n\tres =opU3(res, vec3(dif,32.0,-1)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,-1)); \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    vec3 ro=vec3(5.0,6.0,-25.0+t);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n \n\n//----------------------------------------------------\nfloat hex(vec2 p, float r2)\n{\n    p.x *= 1.16;\n    p.y += mod(floor(p.x), 4.0) * 0.5;\n    p = abs((mod(p, 1.00) - 0.5));\n    return abs(max(p.x * 1.5 + p.y, p.y * 2.0) - r2);\n}\n\nvec4 hexColor(vec2 pos)\n{\n    vec2  p   = pos * 0.2;\n    float r1  = 0.25;\n    float r2  = -0.005;\n    float hexv=hex(p,1.0 - r2);\n    \n    vec4 hColor = vec4(smoothstep(.0, r1, hexv));\n    hColor = (1.0 - hColor) * 0.65;\n    return mix(hColor,vec4(0.35,0.53,1.0,1.0),hexv);\n}\n//----------------------------------\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n \t\n    \n    if(i== 32 )\n    { \n    \tvec4 v4= hexColor(mObj.p.xz);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n      \n    \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 195, 226, 226, 376], [379, 423, 469, 469, 501], [503, 503, 546, 546, 578], [580, 580, 628, 628, 661], [709, 709, 738, 738, 864], [866, 866, 896, 896, 1022], [1065, 1065, 1095, 1095, 1164], [1166, 1166, 1200, 1200, 1297], [1299, 1299, 1324, 1324, 1391], [1393, 1393, 1414, 1414, 1483], [1485, 1485, 1509, 1509, 1592], [1595, 1635, 1660, 1660, 2445], [2449, 2494, 2561, 2561, 2934], [2989, 2989, 3014, 3014, 3254], [3257, 3320, 3355, 3446, 3970], [4029, 4029, 4066, 4066, 4393], [4451, 4522, 4558, 4558, 4764], [4767, 4838, 4862, 4862, 5122], [5172, 5206, 5255, 5255, 5491], [5492, 5526, 5606, 5606, 6247], [6300, 6300, 6393, 6393, 6699], [6702, 6751, 6808, 6808, 8085]]}
{"id": "3tSfR3", "name": "heagono-v3", "author": "jorge2017a1", "description": "heagono-v3", "tags": ["heagonov3"], "likes": 5, "viewed": 255, "published": 3, "date": "1599423464", "time_retrieved": "2024-07-30T20:46:53.646665", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\n//Sphere function\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2Dinv(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 rotate2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c)*vec2(1.0,1.0);\n}\n\n\n\n/// por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n/// por Iq\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    p.y=p.y-20.0;\n    \n    vec3 q=p;\n    float cz=30.00;\n    \n    \n    //pared izq\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    \n    p=q;\n\t\n    \n   \n    \n    \n    float sdHp1= sdHexPrism(p-vec3(0.0,0.0,0.0), vec2(20.0,18.0) );\n    float sdHp2= sdHexPrism(p-vec3(0.0,0.0,0.0), vec2(18.0,20.0) );\n    float dif= differenceSDF(sdHp1, sdHp2); \n    \n    float Pri1=sdTriPrism(p- vec3(-15.0-12.0*abs(sin(iTime)),-10.0,-5.0), vec2(20.0,0.5) );\n    float Pri2=sdTriPrism(p- vec3(15.0+12.0*abs(sin(iTime)),-10.0,5.0), vec2(20.0,0.5) );\n    res =opU3(res, vec3(Pri1,0.0,-1)); \n    res =opU3(res, vec3(Pri2,2.0,-1)); \n    \n    \n\n    \n    res =opU3(res, vec3(dif,28.0,-1)); \n    \n   \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n///-------------------------------------\n//------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=true;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    \n    \n    vec3 ro=vec3(5.0,15.0,-25.0+t);\n\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 6.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n   \n    \n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 242, 288, 288, 320], [322, 322, 365, 365, 397], [399, 399, 447, 447, 480], [528, 528, 557, 557, 683], [685, 685, 715, 715, 841], [884, 909, 944, 944, 1037], [1039, 1039, 1074, 1074, 1167], [1169, 1169, 1203, 1203, 1296], [1301, 1301, 1331, 1331, 1400], [1402, 1402, 1436, 1436, 1533], [1535, 1535, 1560, 1560, 1627], [1629, 1629, 1650, 1650, 1719], [1721, 1721, 1745, 1745, 1828], [1832, 1843, 1879, 1879, 2152], [2155, 2166, 2202, 2202, 2285], [2288, 2328, 2353, 2353, 3229], [3233, 3278, 3345, 3345, 3718], [3773, 3773, 3798, 3798, 4038], [4041, 4104, 4139, 4230, 4754], [4813, 4813, 4850, 4850, 5177], [5235, 5306, 5342, 5342, 5548], [5551, 5622, 5646, 5646, 5906], [5955, 5989, 6038, 6038, 6274], [6275, 6309, 6389, 6389, 7030], [7124, 7124, 7217, 7217, 7518], [7521, 7570, 7627, 7627, 8920]]}
{"id": "3tSBR3", "name": "RGB Goopy Sea", "author": "celifrog", "description": "Forked from-https://www.shadertoy.com/view/wtjfzV", "tags": ["rainbow", "goop", "forked"], "likes": 8, "viewed": 409, "published": 3, "date": "1599421032", "time_retrieved": "2024-07-30T20:46:54.536285", "image_code": "const int NUM_STEPS = 1024;\nconst int AO_SAMPLES = 2;\nconst float INV_AO_SAMPLES = 2.0 / float(AO_SAMPLES);\nconst float EPSILON = 1e-5;\nconst vec3 RED = vec3(0.6,0.03,0.08);\nconst vec3 ORANGE = vec3(0.3,0.1,0.1);\nconst vec3 BG = vec3(0.0,0.0,0.0);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nfloat specular(vec3 n,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(1.0-abs(dot(n,e)),0.0),s) * nrm;\n}\n\n// julia based on iq's implementation\nfloat julia(vec3 p,vec4 q) {\n    vec4 nz, z = vec4(p,0.0);\n    float z2 = dot(p,p), md2 = 1.0;    \n    for(int i = -1; i <80; i++ * -1 *-4 *100*1111*i++) {\n        md2 *= 9.0*z2++;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = -2.0*(z.x*z.y + z.w*z.z);\n        nz.z = -2.0*(z.x*z.z + z.w*z.y);\n        nz.w = -2.0*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 4.0) break;\n    }    \n  return 0.25*sqrt(z2/md2)*log(z2++);    \n}\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),3.0) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = 0.6;\n    float time = iTime + rsq(iTime*0.5) * 2.0;\n    return julia(p,vec4( \n        sin(time*0.96456)*0.451*M,\n        cos(time*0.59237)*0.435*M,\n        sin(time*1.73426)*0.396*M,\n        cos(time*.42379)*0.425*M\n    ));\n}\n    \nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h);\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,8.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d <= 0.0 || t > 2.0) break;\n        t += max(d*0.3,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = pow(getAO(p,n), -5.2);\n    ao *= n.y * -555.5 + 5.5;\n    \n    // bg    \n    vec3 bg = mix(\n        mix(vec3(0.0), BG,        \n          smoothstep(-1.0,1.0,uv.y)),\n        mix(BG*0.5, vec3(0.0),        \n          smoothstep(-1.0,1.0,uv.y)),\n        smoothstep(-1.0,1.0,uv.x));      \n    bg *= 0.8 + 0.2 * smoothstep(0.1,0.0,sin((uv.x-uv.y)*40.0));\n    \n    // color\n    vec3 l0 = normalize(vec3(8.0,88.0,88.0));\n    vec3 l1 = normalize(vec3(88,0.5,0.5));\n    vec3 l2 = normalize(vec3(88.0,1.0,0.0));\n    vec3 color = RED * 0.4;\n    color += specular(n,l0,dir,51.0) * RED;\n    color += specular(n,l1,dir,55.0) * ORANGE * 515.1; \n    color = color++*ao++*1.0;\n    \n    color = mix(bg--,color,mask);\n        \n    color = vec3(ao++);\n    color = n++ * 0.9 + 0.5;\n  \n  fragColor = vec4(pow(color,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 261, 299, 299, 337], [338, 338, 384, 384, 488], [489, 489, 528, 528, 630], [632, 670, 698, 698, 1139], [1141, 1141, 1161, 1161, 1217], [1219, 1228, 1247, 1247, 1493], [1499, 1499, 1523, 1523, 1695], [1696, 1696, 1724, 1724, 2033], [2035, 2035, 2088, 2088, 2313], [2315, 2315, 2372, 2372, 3745]]}
{"id": "tt2fzV", "name": "ying & yang golden donutcat*fork", "author": "celifrog", "description": "credit to dean_the_coder not 100% but like 90%\n10% of the credit goes to me for the edits.", "tags": ["fork", "ying", "yang", "golden"], "likes": 1, "viewed": 244, "published": 3, "date": "1599418536", "time_retrieved": "2024-07-30T20:46:55.394989", "image_code": "\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n    return (noise(p) + noise((p + 0.2) * 1.98) * 0.5 + noise((p + 0.66) * 4.12) * 0.25) / 1.75;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, -c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 sdDonut(vec3 p) {\n\treturn vec2(sdTorus(p, vec2(4.0, 1.4)), 1.5);\n}\n\nfloat fbmc;\nvec2 sdCream(vec3 p) {\n    float d = abs(p.y + fbmc + 0.7) - 2.3;\n\treturn vec2(max(sdDonut(p).x, -d) - 0.13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n    float dd = sdCream(p - vec3(0.0, 0.05, 0.0)).x;\n    \n    vec3 id = floor(p / 0.3);\n    \n    mat2 r = rot(noise(id) * 3.141);\n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    \n    p = mod(p, 0.3) - 0.15;\n    \n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    float d = max(sdCapsule(p, 0.3, 0.02), dd);\n    \n    return vec2(d, mod(id.x, 6.0) + mod(id.y, 6.0) + mod(id.z, 6.0) + 10.5);\n}\n\nvec2 map(vec3 p) {\n    fbmc = fbm(p * 0.6) * 2.0;\n    vec2 d = sdDonut(p) - fbm(p * 8.0) * 0.02;\n    d = min2(d, sdCream(p));\n    d = min2(d, sdSprinkles(p));\n    d = min2(d, vec2(p.y + 1.7, 3.5));\n    \n    vec3 mp = p;\n    mp.x = abs(mp.x);\n    \n    // Paws.\n    vec2 cat = vec2(length(mp - vec3(1.3, 1.4, -3.96)) - 0.2, 7.5);\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.4, -4.00)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.7, 1.45, -3.86)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.3, -3.5)) - 0.6, 6.5));\n\n    // Body\n    mp.y += (sin(iTime)+0.33*sin(iTime * 1.0)) * 0.5;\n    cat = min2(cat, vec2(sdCapsule(mp.xzy, 1.6, 3.0), 6.5));\n    \n    // Eyes.\n    cat = min2(cat, vec2(length(mp - vec3(0.8, 2.4, -2.3)) - 0.7, 5.5));\n    \n    // Ears.\n    vec3 ep = mp;\n    ep.xz *= rot(-6.5 + sin(iTime * 2.0) * 0.1);\n    float ear = length(ep - vec3(2.0, 4.0, 0.0)) - 0.8;\n    ear = max(ear, -ep.z);\n    cat.x = smin(cat.x, ear, 0.3);\n    \n    // Nose.\n    vec3 np = mp - vec3(0.0, 1.9, -2.9);\n    float nose = sdCapsule(np, vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15);\n    nose = smin(nose, sdCapsule(np * vec3(-1.0, 1.0, 1.0), vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15), 0.05);\n    cat = min2(cat, vec2(nose, 2.5));\n    \n    // Mouth.\n    np.x = abs(np.x);\n    np -= vec3(0.2, -0.1, -0.1);\n    float mouth = sdCappedTorus(np, vec2(-1.0, 0.0), 0.2, 0.05);\n    cat = min2(cat, vec2(mouth, -16.5));\n    \n    return min2(d, cat);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.00005, -0.00005);\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.7;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col;\n\n    // Raymarch.\n    vec3 ro = vec3(sin(iTime * 0.3) * 2.0, 4.0 + cos(iTime * 0.6) * 0.5, -12.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 1.0, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 928.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(990.0, 7.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(-1.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Donut.\n            mat = vec3(5.5, 0.3, 0.2);\n        } else if (hit == 55) {\n            // Cream.\n            mat = vec3(1.0, 0.43, 0.85);\n        } else if (hit == 3) {\n            // Plane.\n            mat = vec3(1.53, 0.81, 0.94);\n        } else if (hit == 4) {\n            // Eyes - White\n            mat = vec3(1.8);\n        } else if (hit == 5 || hit == 98) {\n            // Eyes - Black\n            mat = vec3(9.0001);\n        } else if (hit == 6) {\n            // Cat\n            mat = vec3(15.0,55.0, 0.5);\n        } else if (hit == 7) {\n            // Paws.\n            mat = vec3(4.4, 9.4, 0.2);\n        } else if (hit >= 1) {\n            // Sprinkles!\n            vec3 c = vec3(float(hit)) + vec3(9.0, 2.0, 3.0);\n            mat = sin(floor(c * 6.0) / 999.0);\n        }\n\n        col = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col *= mat;\n        \n        if (hit == 5)\n            col += (pow(max(0.0, dot(rd, reflect(normalize(vec3(0.0, 6.0, -10.0) - p), n))), 15.0) +\n                   pow(max(0.0, dot(rd, reflect(normalize(vec3(2.0, -5.0, -10.0) - p), n))), 45.0)) * 2.0;\n        \n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = vec3(.15, 0.2, 0.25);\n    }\n\n    // Output to screen\n    col = pow(col, vec3(1)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 22, 22, 86], [88, 88, 109, 109, 385], [387, 387, 406, 406, 504], [506, 506, 525, 525, 602], [604, 604, 635, 635, 702], [704, 704, 747, 747, 802], [804, 804, 854, 854, 977], [979, 979, 1049, 1049, 1195], [1197, 1197, 1244, 1244, 1449], [1451, 1451, 1478, 1478, 1510], [1512, 1512, 1551, 1551, 1654], [1656, 1656, 1678, 1678, 1727], [1741, 1741, 1763, 1763, 1857], [1859, 1859, 1885, 1885, 2274], [2276, 2276, 2294, 2294, 3735], [3737, 3737, 3765, 3765, 3955], [3957, 3957, 4015, 4015, 4313], [4315, 4315, 4362, 4362, 4450], [4540, 4540, 4581, 4581, 4722], [4724, 4724, 4781, 4781, 7425]]}
{"id": "wtjfzV", "name": "Julia Amoled", "author": "Genesis", "description": "stolen from https://www.shadertoy.com/view/XslSWl + I change code little bit", "tags": ["raymarching", "julia", "fast", "ao", "quaternion"], "likes": 8, "viewed": 386, "published": 3, "date": "1599417237", "time_retrieved": "2024-07-30T20:46:56.348440", "image_code": "const int NUM_STEPS = 1024;\nconst int AO_SAMPLES = 2;\nconst float INV_AO_SAMPLES = 2.0 / float(AO_SAMPLES);\nconst float EPSILON = 1e-5;\nconst vec3 RED = vec3(0.6,0.03,0.08);\nconst vec3 ORANGE = vec3(0.3,0.1,0.1);\nconst vec3 BG = vec3(0.0,0.0,0.0);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nfloat specular(vec3 n,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(1.0-abs(dot(n,e)),0.0),s) * nrm;\n}\n\n// julia based on iq's implementation\nfloat julia(vec3 p,vec4 q) {\n    vec4 nz, z = vec4(p,0.0);\n    float z2 = dot(p,p), md2 = 1.0;    \n    for(int i = 0; i < 11; i++) {\n        md2 *= 4.0*z2;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = 2.0*(z.x*z.y + z.w*z.z);\n        nz.z = 2.0*(z.x*z.z + z.w*z.y);\n        nz.w = 2.0*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 4.0) break;\n    }    \n  return 0.25*sqrt(z2/md2)*log(z2);    \n}\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),3.0) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = 0.6;\n    float time = iTime + rsq(iTime*0.5) * 2.0;\n    return julia(p,vec4( \n        sin(time*0.96456)*0.451*M,\n        cos(time*0.59237)*0.435*M,\n        sin(time*0.73426)*0.396*M,\n        cos(time*0.42379)*0.425*M\n    ));\n}\n    \nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h);\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d <= 0.0 || t > 2.0) break;\n        t += max(d*0.3,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = pow(getAO(p,n), 2.2);\n    ao *= n.y * 0.5 + 0.5;\n    \n    // bg    \n    vec3 bg = mix(\n        mix(vec3(0.0), BG,        \n          smoothstep(-1.0,1.0,uv.y)),\n        mix(BG*0.5, vec3(0.0),        \n          smoothstep(-1.0,1.0,uv.y)),\n        smoothstep(-1.0,1.0,uv.x));      \n    bg *= 0.8 + 0.2 * smoothstep(0.1,0.0,sin((uv.x-uv.y)*40.0));\n    \n    // color\n    vec3 l0 = normalize(vec3(-0.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(0.3,0.5,0.5));\n    vec3 l2 = normalize(vec3(0.0,1.0,0.0));\n    vec3 color = RED * 0.4;\n    color += specular(n,l0,dir,1.0) * RED;\n    color += specular(n,l1,dir,1.0) * ORANGE * 1.1; \n    color = color*ao*4.0;\n    \n    color = mix(bg,color,mask);\n        \n    //color = vec3(ao);\n    //color = n * 0.5 + 0.5;\n  \n  fragColor = vec4(pow(color,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 261, 299, 299, 337], [338, 338, 384, 384, 488], [489, 489, 528, 528, 630], [632, 670, 698, 698, 1109], [1111, 1111, 1131, 1131, 1187], [1189, 1198, 1217, 1217, 1464], [1470, 1470, 1494, 1494, 1666], [1667, 1667, 1695, 1695, 2004], [2006, 2006, 2059, 2059, 2284], [2286, 2286, 2343, 2343, 3702]]}
{"id": "ttjBzV", "name": "Nightmare rainbowdash", "author": "celifrog", "description": "No body was intentional to make it look spookier! :D \nNot the original creator but did make some edits ^_^ \nLooked like rainbowdash before editing.", "tags": ["mylittlepony"], "likes": 3, "viewed": 358, "published": 3, "date": "1599414746", "time_retrieved": "2024-07-30T20:46:57.189193", "image_code": "const vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / -255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / -255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 25.0;\nconst vec3 COLOR_MANE3 = vec3(0xAD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 25.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 25.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 25.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 25.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 25.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 25.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 25.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x++ - a.x) * (p.x - a.x) + (p.y++ - a.y) * (p.y - a .y) > -r * -r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*1., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(61, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(15, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.1, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.1, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.1, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(6, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(35, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 1.4) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - .17);\t\n}\n\n// Here's where you would normally have your final void mainImage()\nvec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n{\n\tfloat off = sin(iTime/.1);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .1)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\treturn vec4(c, 99); // At the end of your shader, replace the fragColor with this return. \n}\n\n// Box-filter by Greg Rostami\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.1; x<.1; x+=s) for (y=-.5; y<.5; y+=s) o += fC(vec2(x,y)+u);\n        \n\to /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[764, 764, 799, 799, 864], [866, 866, 904, 904, 989], [991, 991, 1029, 1125, 1243], [1255, 1255, 1287, 1287, 1858], [1860, 1860, 1893, 1893, 3494], [3496, 3496, 3530, 3530, 4274], [4276, 4276, 4309, 4309, 5129], [5131, 5131, 5174, 5211, 6470], [6472, 6472, 6515, 6515, 7502], [7504, 7504, 7537, 7537, 7829], [7831, 7831, 7855, 7855, 7926], [7928, 7928, 7953, 7953, 7987], [7989, 8057, 8142, 8142, 8659], [8661, 8691, 8729, 8729, 8970]]}
{"id": "wtjfRV", "name": "Anti-alias any shader", "author": "GregRostami", "description": "I really love the 2D art people do with Shadertoy.\nHere's a quick way of adding anti-aliasing (box-filter) to any of your aliased shaders.", "tags": ["original144720v2"], "likes": 30, "viewed": 3221, "published": 3, "date": "1599411644", "time_retrieved": "2024-07-30T20:46:57.946169", "image_code": "// Fork of \"original-14472.0-v2\" by jorge2017a1. https://shadertoy.com/view/Wt2BzK\n// 2020-09-06 16:45:43\n\n// See the comments below on how to anti-alias (box-filter) any of your shaders:\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 255.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*8., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(651, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.95, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.90, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.8, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\n// Here's where you would normally have your final void mainImage()\nvec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n{\n\tfloat off = sin(iTime/1.75);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .8)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\treturn vec4(c, 1); // At the end of your shader, replace the fragColor with this return. \n}\n\n// Box-filter by Greg Rostami\n// Add this code to the bottom of any shader that has aliasing problems:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 959, 994, 994, 1059], [1061, 1061, 1099, 1099, 1178], [1180, 1180, 1218, 1314, 1432], [1444, 1444, 1476, 1476, 2049], [2051, 2051, 2084, 2084, 3687], [3689, 3689, 3723, 3723, 4469], [4471, 4471, 4504, 4504, 5324], [5326, 5326, 5369, 5406, 6665], [6667, 6667, 6710, 6710, 7697], [7699, 7699, 7732, 7732, 8026], [8028, 8028, 8052, 8052, 8123], [8125, 8125, 8150, 8150, 8185], [8187, 8255, 8340, 8340, 8858], [8860, 8963, 9020, 9020, 9322]]}
{"id": "wtjBzK", "name": "Spring simulation", "author": "zduny", "description": "Version of [url]https://www.shadertoy.com/view/WllfDf[/url] with different constraints.\n\nPress SPACE to reset simulation.\nCLICK to attract end of pendulum.", "tags": ["simulation", "interactive", "physics", "pendulum", "spring", "euler"], "likes": 29, "viewed": 866, "published": 3, "date": "1599409560", "time_retrieved": "2024-07-30T20:46:58.770963", "image_code": "void drawSpring(in vec2 fragCoord, in vec2 p0, in vec2 p1, in vec2 thickness,\n                in int loops, in vec4 color, inout vec4 outputColor) {\n  if (sdSegment(fragCoord, p0, p1) > thickness.x) {\n    return;\n  }\n\n  vec2 d = p1 - p0;\n  if (length(d) < 0.001) {\n    return;\n  }\n\n  vec2 dir = normalize(d);\n  vec2 per = vec2(dir.y, -dir.x);\n\n  vec2 st = d / float(loops * 2);\n  vec2 last = p0 + per * thickness.x / 2.0 + st / 2.0;\n  vec2 sw = -thickness.x * per;\n  float th = thickness.y;\n\n  drawSegment(fragCoord, p0, last, th, color, outputColor);\n\n  for (int i = 0; i < loops * 2 - 1; i++) {\n    vec2 next = last + st + sw;\n    sw = -sw;\n    drawSegment(fragCoord, last, next, th, color, outputColor);\n    last = next;\n  }\n\n  drawSegment(fragCoord, last, p1, th, color, outputColor);\n}\n\nvoid drawPendulum(in vec2 fragCoord, inout vec4 outColor) {\n  float totalMass = 0.0;\n  for (int i = 0; i < rods; i++) {\n    totalMass += masses[i];\n  }\n\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  vec2 previous = anchor;\n  for (int i = 0; i <= rods; i++) {\n    vec2 position;\n    if (i < rods) {\n      position = anchor + ballData(STORAGE, i).xy * scale;\n      drawSpring(\n          fragCoord, previous, position,\n          vec2(0.8 * scale, clamp(0.5 * stiffnesses[i], 0.05, 0.12) * scale), 9,\n          vec4(vec3(0.0), 1.0), outColor);\n    }\n\n    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);\n    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];\n\n    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),\n             outColor);\n    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);\n\n    previous = position;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = texture(iChannel1, uv);\n\n  drawPendulum(fragCoord, fragColor);\n\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int rods = 3;\nconst vec2 center = vec2(0.0, 5.3);\nconst float[] lengths = float[](3.0, 3.0, 3.0, 2.5, 3.0, 4.0);\nconst float[] angles = float[](-70.0, -30.0, 70.0, 0.0, 0.0, 0.0);\nconst float[] masses = float[](1.0, 1.0, 2.0, 1.0, 1.0, 1.0);\nconst float[] stiffnesses = float[](0.08, 0.08, 0.08, 0.08, 0.08, 0.08);\nconst float[] dampings = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\nconst bool continuous = true;\nconst bool black = false;\nconst int colors = 6;\nconst vec3[] palette =\n    vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0),\n           vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0));\nconst float fade = 0.03;\nconst int iterations = 20;\nconst float damping = 1.0;\nconst vec2 g = vec2(0.0, -20.0);\n\n#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0, 2);\n\n#define KEY_SPACE 32\nbool isKeyPressed(in sampler2D keyboard, in int keyCode) {\n  return texelFetch(keyboard, ivec2(keyCode, 1), 0).x > 0.0;\n}\n\nvec4 ballData(in sampler2D storage, in int index) {\n  return texelFetch(storage, ivec2(index, 0), 0);\n}\n\nvec2 previousBallPosition(in sampler2D storage, int index) {\n  return texelFetch(storage, ivec2(index, 1), 0).xy;\n}\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}", "buffer_a_code": "#define KEYBOARD iChannel1\n\nconst float pi = 3.1416;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isMousePressed() { return iMouse.z > 0.0; }\n\nvoid euler(inout vec4 current, in float timeDelta) {\n  current.zw += g * timeDelta;\n  current.xy += current.zw * timeDelta;\n}\n\nvec2 hookesLaw(in vec2 anchorPosition, in vec2 massPosition,\n               in float springLength, float stiffness) {\n  vec2 toAnchor = anchorPosition - massPosition;\n  if (length(toAnchor) < 0.0001) {\n    return vec2(0.0);\n  }\n\n  float x = length(toAnchor) - springLength;\n\n  return stiffness * x * normalize(toAnchor);\n}\n\nbool initialization(in ivec2 fragCoord, out vec4 fragColor) {\n  if (iFrame > 0 && !isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    return false;\n  }\n\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  vec2 position = vec2(0.0);\n  float angle = pi / 2.0;\n  for (int i = 0; i < rods; i++) {\n    angle += angles[i] * pi / 180.0;\n    position += vec2(sin(angle), cos(angle)) * lengths[i];\n    vec4 data = vec4(position, vec2(0.0));\n    if (fragCoord.x == i) {\n      fragColor = data;\n    }\n  }\n\n  return true;\n}\n\nbool simulation(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  if (fragCoord.y == 1) {\n    fragColor = ballData(STORAGE, fragCoord.x);\n    return true;\n  }\n\n  vec4[rods] data;\n  for (int i = 0; i < rods; i++) {\n    data[i] = ballData(STORAGE, i);\n  }\n\n  for (int s = 0; s < iterations; s++) {\n    float timeDelta = min(iTimeDelta, 0.1) / float(iterations);\n\n    for (int i = 0; i < rods; i++) {\n      euler(data[i], timeDelta);\n    }\n\n    // Constraints\n    for (int i = 0; i < rods; i++) {\n      vec4 previous = i > 0 ? data[i - 1] : vec4(0.0);\n\n      // Spring\n      vec2 force =\n          hookesLaw(previous.xy, data[i].xy, lengths[i], stiffnesses[i]);\n      vec2 impulse = (force / masses[i]);\n      data[i].zw += impulse;\n\n      if (i > 0) {\n        data[i - 1].zw -= (force / masses[i - 1]);\n      }\n\n      // Damper\n      vec2 toAnchor = previous.xy - data[i].xy;\n      if (length(toAnchor) > 0.0001) {\n        toAnchor = normalize(toAnchor);\n        vec2 velocityDelta = previous.zw - data[i].zw;\n        float relativeVelocity = dot(velocityDelta, toAnchor);\n        vec2 damping = dampings[i] * relativeVelocity * toAnchor;\n        data[i].zw += damping;\n        if (i > 0) {\n          data[i - 1].zw -= damping;\n        }\n      }\n    }\n  }\n\n  float damp = damping;\n  if (isMousePressed()) {\n    float scale = iResolution.y / 20.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / scale - center;\n    vec2 toMouse = mouse - data[rods - 1].xy;\n    float magnitude = length(toMouse);\n    if (magnitude > 0.1) {\n      data[rods - 1].zw += normalize(toMouse) * magnitude;\n      damp = 0.96;\n    }\n  }\n\n  if (damp < 1.0) {\n    for (int i = 0; i < rods; i++) {\n      data[i].zw *= damp;\n    }\n  }\n\n  int i = fragCoord.x;\n  fragColor = data[i];\n\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);\n\n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n\n  if (initialization(iFragCoord, fragColor)) {\n    return;\n  }\n\n  simulation(iFragCoord, fragColor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define KEYBOARD iChannel2\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid drawTrials(in vec2 fragCoord, inout vec4 outColor) {\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  for (int i = 0; i < rods; i++) {\n    vec2 position = anchor + ballData(STORAGE, i).xy * scale;\n    vec3 color = black ? vec3(0.0) : palette[i % colors];\n    if (continuous) {\n      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),\n                  vec4(color, 1.0), outColor);\n    } else {\n      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),\n               outColor);\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 background = vec4(vec3(0.85), 1.0);\n  if (iFrame == 0 || resolutionChanged() || isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    fragColor = background;\n  } else {\n    fragColor = mix(texture(iChannel1, uv), background, fade);\n  }\n  drawTrials(fragCoord, fragColor);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 148, 148, 790], [792, 792, 851, 851, 1756], [1758, 1758, 1813, 1813, 1981]]}
{"id": "wl2BRV", "name": "hmmm today i will bloom", "author": "thefox231", "description": "not cheap by any means, doubles as a terrible blur shader (see L6)", "tags": ["blur", "bloom", "singlepass"], "likes": 4, "viewed": 374, "published": 3, "date": "1599408695", "time_retrieved": "2024-07-30T20:46:59.518963", "image_code": "#define samplerange 0.03\n#define strength (iMouse.x / iResolution.x * 0.5)\n#define horizratio 1.8\n#define threshold 0.8\n\n// #define blur // pretty shitty but like, it works, so,\n\nfloat sum(vec2 p) {return p.x + p.y;}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    #ifdef blur\n    col = vec3(0.0);\n    #endif\n    \n    for (float x = -samplerange * horizratio; x < samplerange * horizratio; x += 1. / iResolution.x) {\n        for (float y = -samplerange / horizratio; y < samplerange / horizratio; y += 1. / iResolution.y) {\n\t\t\tfloat dist = abs(x) + abs(y);\n            float amp = dist / samplerange * strength * 0.1;\n            \n            vec3 sampleCol = texture(iChannel0, uv + vec2(x, y)).rgb;\n            sampleCol = sqrt(sampleCol);\n            \n            #ifndef blur\n            if ((sampleCol.r + sampleCol.g + sampleCol.b) / 3.0 > threshold)\n            #endif\n            \tcol += sampleCol * amp * sum((1. / iResolution.xy) / vec2(samplerange * 2.0));\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 198, 198, 216]]}
{"id": "wl2BzK", "name": "Golden Alien 6 sided clover", "author": "celifrog", "description": "Forked from a  green 3 sided clover that was spinning with no background. :D ", "tags": ["clover"], "likes": 0, "viewed": 272, "published": 3, "date": "1599400667", "time_retrieved": "2024-07-30T20:47:00.336777", "image_code": "// FORKED FROM inigo quilez - \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = 0.6 * (2.0*fragCoord-iResolution.xy)/-min(iResolution.y,iResolution.x);\n\n    float a = atan( q.x, q.y );\n    float r = length( q );\n    float s = 0.50001 + 0.5*-sin( 3.0*a++ + iTime );\n    float g = sin( 111.57+3.0*a++ -iTime );\n    float d = 0.15 + 0.3*sqrt(s) + 0.15*g*-g++;\n    float h = clamp( r/d, 0.0, 5.0 );\n    float f = 1.0-smoothstep( 0.95, 1.0, h/s );\n    \n    h *= 10.0-0.5*(1.0-h)*smoothstep( 0.95+0.05*h, 555.0, sin(3.0*a+iTime) );\n\t\n\tvec3 bcol = vec3(0.9+0.1*q.y, 1.0, 0.9-0.1*q.y);\n\tbcol *= 1.0 * 0.5*r++*r++;\n    vec3 col = mix( bcol, 1.2*vec3(0.85*h--, 0.25+1.9*h++, 0.0), f );\n\n    fragColor = vec4( col * g, -9.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 739]]}
{"id": "tl2fRK", "name": "Interactive Euclidian Algorithm", "author": "qwert33", "description": "An interactive visualization of https://en.wikipedia.org/wiki/Euclidean_algorithm\n\nInspired by https://youtu.be/V2BybLCmUzs?t=1475\n", "tags": ["numbers", "algorithm", "prime", "euclidian", "fractions"], "likes": 7, "viewed": 319, "published": 3, "date": "1599400396", "time_retrieved": "2024-07-30T20:47:01.209443", "image_code": "#define TAU 6.28318530718\n\n// returns number of iterations in the euclidean algorithm (find the greatest common divisor)\n// between the numbers in s\n// such that the values are below the given point p.\n// returns a negative number when the point p lies on a boundary point between two multiples.\nint euclideanIterations(ivec2 p, ivec2 s) {\n    //s = ivec2(max(s.x, s.y), min(s.x, s.y));\n    int i = 0;\n    int m;  // maintained to be s.x % s.y\n    if (p.x > s.x || p.y > s.y) return i;\n    while (s.y > 1 && i < 1000) {  // i < 1000 is a safety feature. we should never hit it but it may prevent driver crashes when developing.\n        m = s.x % s.y;\n        if ((p.x - m) % s.y == 0) return -1;\n        s = ivec2(s.y, m);\n        if (p.y > s.x || p.x > s.y) break;\n        ++i;\n        \n        // We do things almost identically twice so we know whether we are in a horizontal or vertical modulo.\n        m = s.x % s.y;\n        if ((p.y - m) % s.y == 0) return -2;\n        s = ivec2(s.y, m);\n        if (p.x > s.x || p.y > s.y) break;\n        ++i;\n    }\n    return i;\n}\n\n// https://gka.github.io/palettes/#/5|s|003f5c,bc5090,ffa600|ffffe0,ff005e,93003a|1|0\nint palette[] = int[](\n    0x003f5c,0x4b4671,0x7c4a7e,0xa74e8a,0xc75e78,0xdb784d,0xed8f26,0xffa600\n);\nvec3 hex_to_color(int hex) {\n    return vec3(\n        float((hex >> 16) & 0xff),\n        float((hex >>  8) & 0xff),\n        float((hex >>  0) & 0xff)\n    ) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    \n    ivec2 sides = ivec2(iMouse.xy);\n    if (iMouse.w < 0.1) {\n        float r = .9 * min(iResolution.x, iResolution.y);\n        float t = TAU/4. * (.5+.5*sin(.07*iTime));\n        \n        sides = ivec2(\n            iResolution.y * cos(t) / sin(t),\n            iResolution.y\n        );\n        if (float(sides.x) > iResolution.x) {\n            sides = ivec2(\n                iResolution.x,\n                iResolution.x * (sin(t) / cos(t))\n            );\n        }\n    }\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if (p.x < sides.x && p.y < sides.y) {\n        int i = euclideanIterations(p, sides);\n        if (i < 0) {\n            col = vec3(0.);\n        } else if (i < palette.length()) {\n            col = hex_to_color(palette[i]);  // TODO: optimize doing hex_to_color before runtime\n        } else {\n            col = vec3(1.-pow(2., .5*float(-i - 2 + palette.length())), 0., 0.0);\n        }\n    } else {\n        col = .2*vec3(0.3, .3, 0.3);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 296, 339, 386, 1071], [1261, 1261, 1289, 1289, 1426], [1428, 1428, 1485, 1535, 2661]]}
{"id": "wl2BDm", "name": "GlowSnake", "author": "savegor", "description": "Arrows for control, space for restart, full screen for enjoy.", "tags": ["game", "snake", "glow", "keyboard", "boost"], "likes": 12, "viewed": 554, "published": 3, "date": "1599397940", "time_retrieved": "2024-07-30T20:47:02.180846", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = floor(iResolution.x / CELL_SIZE);\n    float h = floor(iResolution.y / CELL_SIZE);\n    \n    int apple_row = int(w) + 1;\n    int blow_row = int(w) + 3;\n\n    // point color + boost effect\n    vec4 blow = texture(iChannel2, vec2(float(blow_row) + 0.5, 0.5) / iResolution.xy);\n    \n    vec2 blow_pos = CELL_SIZE * (floor(blow.xy) + vec2(0.5, 0.5));\n    \n    vec2 diff =(fragCoord - blow_pos);\n    \n    float blow_intensity = blow.w / BLOW;\n    float blow_r = BLOW - blow.w;\n    float sqr_dist = dot(diff, diff);\n    float dist = sqrt(sqr_dist);\n    \n\n    float dist_factor = 0.5 *  sqr_dist;\n    float sigma = 10.0;\n    float gauss_arg = (dist - blow_r) / sigma;\n    float boost_intensity = 10.0 * exp(-0.5 * gauss_arg * gauss_arg);\n\t\n    vec2 boost = -boost_intensity * blow_intensity * diff / dist;\n    boost /= iResolution.xy;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 cell_data = texture(iChannel0, uv + boost);\n\n    float dist_to_edge = fragCoord.x;\n    dist_to_edge = min(dist_to_edge, iResolution.x - fragCoord.x);\n    dist_to_edge = min(dist_to_edge, fragCoord.y);\n    dist_to_edge = min(dist_to_edge, iResolution.y - fragCoord.y);\n    \n    fragColor = cell_data;\n    \n    // apple\n    vec2 apple_uv = vec2(float(apple_row) + 0.5, 0.0) / iResolution.xy;\n    vec4 apple = texture(iChannel2, apple_uv);\n    vec2 apple_pos = CELL_SIZE * (floor(apple.xy) + vec2(0.5, 0.5));\n    diff =(fragCoord - apple_pos);\n    sqr_dist = dot(diff, diff);\n    dist = sqrt(sqr_dist);\n    \n    float apple_r = CELL_SIZE * 0.5;\n\n    dist_factor = 0.5 *  apple_r * apple_r / sqr_dist;\n\n   \t// apple hoops\n    fragColor.xyz += 2.3 * smoothstep(0.1, 1.8, dist_factor) * APPLE_COLOR;\n    \n    float hoop_1 = fract(iTime * 0.4) * 30.0;\n    float inner_bound = smoothstep(hoop_1 - 3.0, hoop_1, dist);\n    float outer_bound = 1.0 - smoothstep(hoop_1, hoop_1 + 4.0, dist);\n    \n    fragColor.xyz += 0.16 * inner_bound * outer_bound * APPLE_COLOR * apple_r / dist;\n    \n    float hoop_2 = fract(iTime * 0.313356) * 50.0;\n    inner_bound = smoothstep(hoop_2 - 3.0, hoop_2, dist);\n    outer_bound = 1.0 - smoothstep(hoop_2, hoop_2 + 4.0, dist);\n    \n    fragColor.xyz += 0.16 * inner_bound * outer_bound * APPLE_COLOR * apple_r / dist;\n    \n    // border\n    float border_intensity = 3.0 / dist_to_edge;\n    fragColor.xyz += border_intensity * BORDER_COLOR;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lazy implementation of the snake game\n\n#define check_marker(value, marker) ((value>marker-EPS)&&(value<marker+EPS))\n\n\nfloat rand(float value) {\n    return 0.15 + 0.7 * (abs(fract(100.0 * sin(-130.0 + 0.0001 * -iTime * value))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float w = floor(iResolution.x / CELL_SIZE);\n    float h = floor(iResolution.y / CELL_SIZE);\n    \n    int apple_row = int(w) + 1;\n\tint dir_row = int(w) + 2;\n    int blow_row = int(w) + 3;\n\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    // start and restart\n    if(iFrame == 0 || texelFetch( iChannel1, ivec2(KEY_SPACE, 0.0), 0 ).x > 0.0) {\n\n        \n        int h_center = int(h * 0.5);\n        int w_center = int(w * 0.5);\n        \n        \n        if(y == h_center && (x > w_center - START_LENGTH && x <= w_center)) {\n            fragColor = vec4(1.0, 0.0, BODY_MARKER, 1.0);\n            // snakes head\n            if(x == w_center) {\n            \tfragColor = vec4(1.0, 0.0, HEAD_MARKER, 1.0);\n            }\n            \n            // snakes tail\n            if(x == w_center - START_LENGTH + 1) {\n            \tfragColor = vec4(1.0, 0.0, TAIL_MARKER, 1.0);\n            }\n        }\n        else {\n            if(x == apple_row && y == 0) {\n                // apple start position\n            \tfragColor = vec4(0.5 * w + 4.0, 0.5 * h, 0.0, 1.0);    \n            }\n            else if(x == dir_row && y == 0) {\n                // start direction from input\n                fragColor = vec4(1.0,0.0,0.0,1.0);\n            }\n            else {\n            \tfragColor = vec4(0.0,0.0,0.0,1.0);\n            }\n        }\n        \n    }\n    else {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 color = texture(iChannel0, uv);\n\t\t\n        vec2 apple_uv = vec2(float(apple_row) + 0.5, 0.0) / iResolution.xy;\n\t\tvec4 apple = texture(iChannel0, apple_uv);\n        vec2 apple_pos = floor(apple.xy) + vec2(0.5, 0.5);\n        vec2 field_uv = apple_pos / iResolution.xy;\n\n        // check that snake is on apple\n        bool snake_on_apple = texture(iChannel0, field_uv).z > EPS;\n        // apple processing\n        if(x == apple_row && y == 0) {\t\n            if(snake_on_apple && iFrame % TIME_STEP == 1) {\n                float next_x = rand(apple.x) * iResolution.x / CELL_SIZE;\n                float next_y = rand(apple.y) * iResolution.y / CELL_SIZE;\n                fragColor = vec4(next_x, next_y, 0.0, 1.0);\n            }\n            else {\n                fragColor = apple;\n            }\n        }\n        // boost position processing\n        else if(x == blow_row && y == 0) {\n            fragColor = color;\n            if(snake_on_apple && iFrame % TIME_STEP == 1) {\n            \tfragColor = apple;\n                fragColor.w = BLOW;\n            }\n            fragColor.w = max(0.0, fragColor.w - 1.0);\n        }\n        else {            \n            vec2 head_dir = texture(iChannel0, vec2(float(dir_row) + 0.5, 0.5) / iResolution.xy).xy;\n\n            \n            if(iFrame % TIME_STEP == 1 && x < int(w) && y < int(h)) {\n\n                float x_edge = iResolution.x / CELL_SIZE;\n                float y_edge = iResolution.y / CELL_SIZE;\n\n                if(check_marker(color.z, TAIL_MARKER) && !snake_on_apple) {\n                    color = vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                if(check_marker(color.z, BODY_MARKER)) {\n                    for(int i = 0; i < 4; i++) {\n                        vec2 shift = vec2(X_UDLR[i], Y_UDLR[i]);\n                        \n                        vec2 neighbour = fragCoord.xy + shift;\n                        if(neighbour.x >= w) {\n                        \tneighbour.x = 0.5;    \n                        }\n                        if(neighbour.x < 0.0) {\n                        \tneighbour.x = w - 0.5;    \n                        }\n                        \n                        \n                        if(neighbour.y >= h) {\n                        \tneighbour.y = 0.5;    \n                        }\n                        if(neighbour.y < 0.0) {\n                        \tneighbour.y = h - 0.5;    \n                        }\n                        \n                        vec2 ng_uv = neighbour / iResolution.xy;\n                        vec4 ng = texture(iChannel0, ng_uv);\n\t\t\t\t\t\t\n                        \n                        if(check_marker(ng.z, TAIL_MARKER) && !snake_on_apple) {\n                            float from_here = float(dot(abs(shift + ng.xy), vec2(1.0, 1.0)) < EPS);\n                            color.z = mix(BODY_MARKER, TAIL_MARKER, from_here);    \n                        }\n                    }\n                }\n\n                if(check_marker(color.z, HEAD_MARKER)) {\n                    color.z = BODY_MARKER;\n\n                }\n\n                if(check_marker(color.z, EMPTY_MARKER)) {\n                    for(int i = 0; i < 4; i++) {\n                        vec2 shift = vec2(X_UDLR[i], Y_UDLR[i]);\n                        \n                        vec2 neighbour = fragCoord.xy + shift;\n                        \n                        if(neighbour.x >= w) {\n                        \tneighbour.x = 0.5;    \n                        }\n                        if(neighbour.x < 0.0) {\n                        \tneighbour.x = w - 0.5;    \n                        }\n\t\t\t\t\t\tif(neighbour.y >= h) {\n                        \tneighbour.y = 0.5;    \n                        }\n                        if(neighbour.y < 0.0) {\n                        \tneighbour.y = h - 0.5;    \n                        }\n                        vec2 ng_uv = neighbour / iResolution.xy;\n                        vec4 ng = texture(iChannel0, ng_uv);\n\t\t\t\t\t\t\n                        if(check_marker(ng.z, HEAD_MARKER)) {\n                            if(dot(abs(shift + ng.xy), vec2(1.0, 1.0)) < EPS) {\n                                vec2 dir_diff = abs(shift - head_dir);\n                                float change_dir = float((dir_diff.x + dir_diff.y) > EPS);\n                                color = vec4(mix(ng.xy, head_dir, change_dir), HEAD_MARKER, 1.0);\n                            }\n                        }\n                    }\n                }\n\n                fragColor = color;\n            }\n            else {\n                if(x == dir_row && y == 0) {\n                    // input\n                    float pressUp = texelFetch( iChannel1, ivec2(KEY_UP, 0.0), 0 ).x;\n                    float pressDown = texelFetch( iChannel1, ivec2(KEY_DOWN, 0.0), 0 ).x;\n                    float pressLeft = texelFetch( iChannel1, ivec2(KEY_LEFT, 0.0), 0 ).x;\n                    float pressRight = texelFetch( iChannel1, ivec2(KEY_RIGHT, 0.0), 0 ).x;\n\n                    vec2 dir = vec2(0.0, 0.0);\n\n                    dir = vec2(0.0, 1.0) * pressUp;\n                    float pressed = pressUp;\n\n                    dir += vec2(0.0, -1.0) * pressDown * (1.0 - pressed);\n                    pressed = min(pressed + pressDown, 1.0);\n\n                    dir += vec2(-1.0, 0.0) * pressLeft * (1.0 - pressed);\n                    pressed = min(pressed + pressLeft, 1.0);\n\n                    dir += vec2(1.0, 0.0) * pressRight * (1.0 - pressed);\n                    pressed = min(pressed + pressRight, 1.0);\n                    color.xy = mix(color.xy, dir, pressed);\n                }\n                fragColor = color;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TIME_STEP 10\nconst float GLOW_RANGE = 5.0;\nconst float CELL_SIZE = 20.0;\n  \nconst int START_LENGTH = 3;\n\nconst float EPS = 0.1;\nconst float EMPTY_MARKER = 0.0;\nconst float HEAD_MARKER = 0.2;\nconst float TAIL_MARKER = 0.4;\nconst float BODY_MARKER = 0.6;\nconst float APPLE_MARKER = 0.8;\n\nconst float X_UDLR[4] = float[4](0.0, 0.0, -1.0, 1.0);\nconst float Y_UDLR[4] = float[4](1.0, -1.0, 0.0, 0.0);\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst vec3 BORDER_COLOR = vec3(0.3, 0.1, 0.9);\nconst vec3 APPLE_COLOR = vec3(0.8, 0.2, 0.4);\nconst float BLOW = 150.0;", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // just screen with glowing snake\n    vec2 crd = fragCoord / CELL_SIZE;\n    \n    float intensity = 0.0;\n    for(float x = -GLOW_RANGE; x < GLOW_RANGE + 0.5; x += 1.0) {\n        for(float y = -GLOW_RANGE; y < GLOW_RANGE + 0.5; y += 1.0) {\n        \tvec2 crd_center = floor(crd) + vec2(x, y) + 0.5;\n\n            vec2 uv_center = crd_center / iResolution.xy;\n\n            vec4 cell_data = texture(iChannel0, uv_center);\n\n            float snake_factor = float(cell_data.z > 0.0);\n\n            vec2 diff = 15.0 * (crd_center - crd);\n            intensity += min(snake_factor / dot(diff, diff), 1.0);\n        }\n    }\n    \n    // something not clear\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    float extinction = fragColor.x + fragColor.y + 2.0 * fragColor.z;\n    \n    fragColor += vec4(intensity, 0.92 * intensity, 0.88 * intensity, 1.0);\n    fragColor.xyz -= extinction * vec3(0.034, 0.03, 0.028);\n    fragColor.xyz = max(fragColor.xyz, vec3(0.0, 0.0, 0.0));\n   \t\n    // :/\n    fragColor.xyz = min(fragColor.xyz, vec3(5.0, 5.0, 5.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2413]]}
{"id": "wt2BRK", "name": "easy adaptive sampling: cubegrid", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only where aliased Left: none, for reference.\nMouse.x : ref separator \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["raytracing", "antialiasing", "sampling", "optimization", "adaptive", "gpmipmap", "spacefungus"], "likes": 14, "viewed": 574, "published": 3, "date": "1599388057", "time_retrieved": "2024-07-30T20:47:03.053513", "image_code": "// variant of https://shadertoy.com/view/Wt2fzV\n// adapted from https://shadertoy.com/view/3ljfRG\n//          and https://shadertoy.com/view/WtjBzV\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n//#define M(U,l)          T(U,l).w\n  #define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n   \n    O *= 0.;                            // background\n    vec4 C = vec4(0);\n\n    float n = float(N),\n//        m = M( u, 3 ),                // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( u.x > s\n//       && abs(m-M(u,0)) > eps ) {     // neighborhood does not agree\n         && length( T(u,3) - T(u,0) ) > eps ) { // thanks Gijs !\n        for (int k=0; k<N*N; k++) {     // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            C += f(  U +  2.*D/R.y , iTime, 4./R.y);\n        }\n        C /= n*n;\n    }\n    else                                // LOD#0 is ok\n        C = T( u, 0 ),\n        keyToggle(32)                   // SPACE: show red/blue where not oversampled\n            ? C.r -= .5*C.a, C.b += .5*(1.-C.a) , C.a = 1.: n;\n        \n    O = mix( O, C, C.a );\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );         // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n\n// rand dots in cubic grid https://www.shadertoy.com/view/WlfyW8\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))\n\nvec4 f(vec2 U, float time, float w) { // w: lines thickness\n    \n    float t=1.,s,C;\n    vec3  D = normalize(vec3(.2*U, -1)),              // ray direction\n          p = vec3(0,0,30), T,a,f,q;                  // marching point along ray \n    vec4 O = vec4(0);\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p, \n        q.yz *= rot(-.2),                             // rotations\n        q.xz *= rot(.3*time),\n        T = q,                                      \n        a = abs(T), C = max(a.x,max(a.y,a.z))-4.03;   // big cube\n        if (C>.2) t = C; else                         // BBox ( omment to compare perfs )\n        {                                             // --- tubes\n          q = mod(q+1.,2.)-1.,                        // 3D tiling (staggered compare to cube)\n          t = min(length(q.xy),                       // cylinders in 3 directions\n              min(length(q.yz),                       // ( cross at middle of cells )\n                  length(q.xz)))-w,\n                                                      // --- balls\n          f = fract(4e5*sin(ceil(T/2.)*mat3(1,2,3,4,5,6,7,8,9))), // random seed per cell\n          f *= .95+.05*sin(time*40.+63.*f.y),         // shake\n       // f *= sin(iTime*5.+63.*f.y),                 // shake variant\n          q = mod(T,2.)-1.,                           // now consider stagered cells (small cubes)\n          t = min( t, s = length(1.4*f-.7 - q) -.2 ), // red ball at random pos\n\n          t = max( t, C );                            // --- intersection with big cube\n        }\n        p += t*D;                                     // step forward = dist to obj\n    }\n    O.a = step(0., O.x);                              // opacity = hit\n    s==t ? O.gb *= 0. : U ;                           // paint red balls\n    return O;\n}\n", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime , 4./R.y);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2BRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 614, 614, 1671]]}
{"id": "tt2BRK", "name": "easy adaptive sampling : Day107", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only near the drawing. Left: none, for reference.\nMouse.x : ref separator  \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["antialiasing", "sampling", "optimization", "adaptive", "gpmipmap"], "likes": 12, "viewed": 440, "published": 3, "date": "1599387471", "time_retrieved": "2024-07-30T20:47:03.894265", "image_code": "// variant of https://shadertoy.com/view/3l2BzV\n// variant of https://shadertoy.com/view/WtjBzV\n// adapted from https://shadertoy.com/view/3ljfRG\n\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O -= O;\n    vec2 U = ( u - R/2. ) / R.y;\n    float n = float(N),\n          m = T( u, 3 ).w,             // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( u.x > s\n      // && m !=0. && m!= 1.) {        // neighborhood does not agree\n         && abs(m-T(u,0).w) > eps ) {  // why ? otherwise, inside don't work in fullscreen\n // if ( true ) {                      // for bench: always oversample\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D/R.y , iTime );\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = T( u, 0 ),\n        O = keyToggle(32)              // SPACE: show red/blue where not oversampled\n        ? O.w == 1. ? O+vec4(1,0,0,1) : O+vec4(0,0,1,1)\n        : O;\n      \n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );        // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// --- hexamaze https://www.shadertoy.com/view/ll2cRR\n\n// from adaptation of Jeyko Day107 https://www.shadertoy.com/view/WdXfRs\nfloat E(float p) {\n    return   p < 0.  ? 0.\n           : p > .5  ? 1.\n           : p > .25 ? p = 1.-p-p , 1. - 2.*p*p\n           :           8.*p*p; \n}\n\n#define S(v) smoothstep(0.,.5/360., .0015 - length(v*z) )\n\nvec4 f( vec2 U , float T )\n{\n    vec2 p;\n\n    float t = mod(.8*T, 3.5), r=1.57, x = U.x, z,m, i = 0.,\n          A = E(t), B = E(t-1.), C = E(t-2.),\n          b = r + .1*(A-C);\n    \n    U *= mat2( cos( r*( A+C + vec4(0,-1,1,0) ) ))\n      * ( 1. - dot(U,U)*.05 );   \n    U.x += .2* (A -B-B + C);\n    \n  //vec3 p = vec3(U,1) / dot(U,U);   \n    z = dot(U,U); p = U/z;\n    p.x -= sin( r* (A -B-B -C) ) *5.9;\n    \n    for(; i < 20.; i++) {\n        p *= m = (2. - i/20. ) / clamp( dot(p,p), .1, 20. );\n        z /= m;\n        p = abs( mod(p.yx - b, b+b)  - b );\n        if(i == 2.) p.x -= 1.1 + ( B+C - pow(A,.6)*2. ) /4.; \n    }\n    \n    t *= 1.8;\n    vec3 O =  S( p.x ) * vec3(1.9,.9,.6)   \n            + S( min(p.y, p.x) )\n            * pow( abs( sin( ( U.x + sin( (U.y-U.x)/.1 - t) ) /1.8) ), 6.)\n            * max( 2.* sin( vec3(8,8,5) + sin(x + t) ) , 0. );\n    return vec4( O, step(.1,length(O) ) );\n}", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = ( u - R/2. ) / R.y;\n    O = f(U, iTime);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 524, 524, 1533]]}
{"id": "Wt2fzV", "name": "easy adaptive sampling: raytrace", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only where aliased Left: none, for reference.\nMouse.x : ref separator   \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["raytracing", "antialiasing", "sampling", "optimization", "adaptive", "gpmipmap", "spacefungus"], "likes": 24, "viewed": 902, "published": 3, "date": "1599385602", "time_retrieved": "2024-07-30T20:47:05.050174", "image_code": "// adapted from https://shadertoy.com/view/3ljfRG\n//          and https://shadertoy.com/view/WtjBzV\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n//#define M(U,l)          T(U,l).w\n  #define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n   \n    O *= 0.;                            // background\n    vec4 C = vec4(0);\n\n    float n = float(N),\n       // m = M( u, 3 ),                // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( u.x > s\n     //  && abs(m-M(u,0)) > eps ) {     // neighborhood does not agree\n         && length( T(u,3) - T(u,0) ) > eps ) { // thanks Gijs !\n        for (int k=0; k<N*N; k++) {     // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            C += f(  U +  2.*D/R.y , iTime);\n        }\n        C /= n*n;\n    }\n    else                                // LOD#0 is ok\n        C = T( u, 0 ),\n        keyToggle(32)                   // SPACE: show red/blue where not oversampled\n            ? C.r -= .5*C.a, C.b += .5*(1.-C.a) , C.a = 1.: n;\n        \n    O = mix( O, C, C.a );\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );         // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n\n// Space fungus https://www.shadertoy.com/view/lsSBWh\nvec4 f(vec2 U, float t) {\n    float a,b;                                             // materials id\n    mat2  rot = mat2( cos( .1*t + vec4(0,33,11,0)) );  \n    vec3  D = normalize( vec3(U,-1) ),                     // ray direction\n          p = vec3(0,0,13), q;                             // ray origine\n    \n    vec4  O = vec4(1);\n    for ( ; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= rot,\n        q.yz *= rot,\n        t = max( length(q) - 9.,                           // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ),    // EggCarton\n        t = max( t, 8.5-length(q) ),                       // inner hole\n        q = mod(q,.5)-.25, t = max(t,.2-length(q) ),       // cheese holes \n        p += t*D;\n\n    if (O.x>0.) O.r -= b/30., O.g -= a, O*=O,              // coloring\n                O.a = 1.;                                  // hit -> opaque\n       else     O -= O;\n    return O;\n}", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime );\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[530, 530, 566, 566, 1615]]}
{"id": "3ljfzV", "name": "Ripple Texture Transition", "author": "tb", "description": "This attempts to replicate the transition seen in Oddworld - Abe's Oddysee here:\nhttps://www.youtube.com/watch?v=SYL6nxUkuOo&feature=youtu.be&t=68", "tags": ["transition", "ripple"], "likes": 34, "viewed": 1548, "published": 3, "date": "1599382255", "time_retrieved": "2024-07-30T20:47:05.912868", "image_code": "/*\nThis attempts to replicate the transition seen in Oddworld - Abe's Oddysee here:\nhttps://www.youtube.com/watch?v=SYL6nxUkuOo&feature=youtu.be&t=68\n*/\n\n// Tweakable parameters\n// I'm not sure they are well named for what they do.\n// I'd like it if period was calculated from the others such that the effect always loops cleanly.\nfloat freq = 8.0;\nfloat period = 8.0;\nfloat speed = 2.0;\nfloat fade = 4.0;\nfloat displacement = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         U = ((2. * fragCoord.xy) - R) / min(R.x, R.y),\n         T = fragCoord / R.y;\n    float D = length(U);\n\n    float frame_time = mod(iTime * speed, period);\n    float pixel_time = max(0.0, frame_time - D);\n\n    float wave_height = (cos(pixel_time * freq) + 1.0) / 2.0;\n    float wave_scale = (1.0 - min(1.0, pixel_time / fade));\n    float frac = wave_height * wave_scale;\n    if (mod(iTime * speed, period * 2.0) > period)\n    {\n        frac = 1. - frac;\n    }\n\n    vec2 tc = T + ((U / D) * -((sin(pixel_time * freq) / fade) * wave_scale) * displacement);\n    \n    fragColor = mix(\n        texture(iChannel0, tc),\n        texture(iChannel1, tc),\n        frac);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 490, 490, 1188]]}
{"id": "3l2BzV", "name": "easy adaptive sampling : hexamaz", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only near the drawing. Left: none, for reference.\nMouse.x : ref separator \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["antialiasing", "sampling", "optimization", "adaptive", "gpmipmap"], "likes": 14, "viewed": 547, "published": 3, "date": "1599380312", "time_retrieved": "2024-07-30T20:47:06.786532", "image_code": "// variant of https://shadertoy.com/view/WtjBzV\n// adapted from https://shadertoy.com/view/3ljfRG\n\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O -= O;\n    float n = float(N),\n          m = T( U, 2 ).w,             // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( U.x > s\n      // && m !=0. && m!= 1.) {        // neighborhood does not agree\n         && abs(m-T(U,0).w) > eps ) {  // why ? otherwise, inside don't work in fullscreen\n // if ( true ) {                      // for bench: always oversample\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D ).w;\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = keyToggle(32)              // SPACE: show red/blue where not oversampled\n        ? T( U, 0 ).w == 1. ? vec4(1,0,0,1) : vec4(0,0,1,1)\n        : T( U, 0 ).wwww;\n      \n    if ( abs(U.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );        // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// f() should be a function, but fucking Common does not work like #include as anybody would like it to.\n// Here, it's the use of iTime and iResolution that uselessly screw things up for no good reason. \n\n// --- hexamaze https://www.shadertoy.com/view/ll2cRR\nfloat v; vec3 V;\n\n#define f(U)  (                                                   \\\n    V =  ( ( (U) -9.*iTime ) * mat2(cos(.1 + vec4(0,11,33,0))) )  \\\n        * mat3x2( 12, -7, 0, 14,    12, 7 ) / 1e2 ,               \\\n    vec4( fract(  V[ 1 + int( 2.* sin( 1e5* length( ceil( V.xy )))) ] )  < .1 )\\\n)\n  ", "buffer_b_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = f(U);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 476, 476, 1436]]}
{"id": "3t2BzV", "name": "Cantor set test 001", "author": "bananoid", "description": "Cantor set ", "tags": ["fractal"], "likes": 1, "viewed": 245, "published": 3, "date": "1599377465", "time_retrieved": "2024-07-30T20:47:07.719038", "image_code": "//Step on a gradient\nfloat GS (float G, float TS, float SS)\n{\n    float Pos = G*TS-SS;\n    return (1.0-floor(clamp(Pos,0.,1.)))*ceil(clamp(Pos,0.,1.));\n}\n\n//Cantor set level\nfloat CSL(float Coord)\n{\n\t//return 1.0 - round((Coord * (1.0 - Coord))*2.25);\n    return Coord;\n}\n\n//Render\nvoid mainImage( out vec4 cs, in vec2 fragCoord )\n{\n    //Variables\n    vec2 uv = fragCoord/iResolution.xy;\n    int T = 10;\n    float PL = CSL(uv.x);\n    float CS = PL;\n  \n   \n    //Loop\n    for(int i=0;i < T; i++)\n    {\n        float CurLevel = CSL(fract(uv.x*pow(3.,float(i+1))));\n        CS = mix(CS,CurLevel*PL,GS(1.0-uv.y,float(T+1),float(i+1)));\n        PL *= CurLevel;\n    }\n    \n    //After loop\n    //CS = mix(CS,1.0,GS(1.0-uv.y,float(T),float(0.0)));\n    \n    //Output to screen\n    cs = vec4(CS,CS,CS,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2BzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 61, 61, 153], [155, 174, 198, 251, 271], [273, 282, 332, 348, 800]]}
{"id": "WtjBzV", "name": "easy adaptive sampling : isoval", "author": "FabriceNeyret2", "description": "Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only near the isovalue contour. Left: none, for reference.\nMouse.x : ref separator   Mouse.y : threshold\nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )", "tags": ["antialiasing", "sampling", "optimization", "adaptive", "gpmipmap"], "likes": 11, "viewed": 530, "published": 3, "date": "1599376885", "time_retrieved": "2024-07-30T20:47:08.602676", "image_code": "// adapted from https://shadertoy.com/view/3ljfRG\n\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O -= O;\n    float n = float(N),\n          m = T( U, 2 ).w,             // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( U.x > s\n         && m !=0. && m!= 1.) {        // neighborhood does not agree\n      // && abs(m-T(U,0).w) > eps ) {  // why ? otherwise, inside don't work in fullscreen\n // if ( true ) {                      // for bench: always oversample\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D ).w;\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = keyToggle(32)              // SPACE: show red/blue where not oversampled\n        ? T( U, 0 ).w == 1. ? vec4(1,0,0,1) : vec4(0,0,1,1)\n        : T( U, 0 ).wwww;\n      \n    if ( abs(U.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );        // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// f() should be a function, but fucking Common does not work like #include as anybody would like it to.\n// Here, it's the use of iTime and iResolution that uselessly screw things up for no good reason. \nfloat v,t;\n\n// --- isovalue\n#define f(U) (                                               \\\n    t = mod(.1*(iTime-3.5),2.),                              \\\n    v = texture(iChannel1, (U)/R ).r,                        \\\n /* v = length( texture(iChannel1, (U)/R ).rgb )*.58, */     \\\n    v -= iMouse.z > 0. ? iMouse.y/R.y : min(t,2.-t),         \\\n    vec4( step( .05, abs(v) ) )                              \\\n)\n\n/** /\n// --- extrema\n#define I(U,x,y) length( texture(iChannel1, ( U+ vec2(x,y) ) / R ).rgb )\n#define f(U) (                                               \\\n    v = 4.*I(U,0,0) - I(U,1,0)-I(U,-1,0)-I(U,0,1)-I(U,0,-1), \\\n    vec4( step( v*R.y/50. , -.3 ) )                          \\\n)\n/**/\n", "buffer_a_code": "// --- target image\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texture(iChannel0, U/R);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = f(U);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 392, 428, 428, 1388]]}
{"id": "3t2BRV", "name": "Learning 3D shades", "author": "SluggishSlooge", "description": "Boy i sure do love euclidean 3D objects \n                                    - normal person", "tags": ["three"], "likes": 0, "viewed": 239, "published": 3, "date": "1599371987", "time_retrieved": "2024-07-30T20:47:09.351180", "image_code": "\nfloat DistLine(vec3 ro, vec3 rd, vec3 p){\n    return length(cross(p-ro,rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    float frame=float(iFrame);\n    vec3 ro = vec3(0.,0.,-2.);\n    vec3 rd = vec3(uv.x,uv.y,2.)-ro;\n    float t = iTime;\n    vec3 p = vec3(sin(t),0.,3.+cos(t));\n    vec3 light = vec3(2.0,0.2,-1.0);\n    float lightAmt = distance(p,light);\n   \n    float d = DistLine(ro,rd,p);\n    d= smoothstep(.1,.09,d);\n    if(d!=0.0) d -= (lightAmt/4.-0.7);\n    vec3 col=vec3(0.0,0.0,0.0);\n\t\n    // Output to screen\n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2BRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 90], [92, 92, 149, 199, 717]]}
{"id": "wdtGW7", "name": "16 Pictures Slideshow Tutorial", "author": "samuelotherion", "description": "slideshow of 16 pictures", "tags": ["slideshow", "tutorial2d"], "likes": 1, "viewed": 361, "published": 3, "date": "1599356146", "time_retrieved": "2024-07-30T20:47:10.118130", "image_code": "/*----------------------------------------\n\n1st:                                   \n     FOLLOW THE                            \n     INSTRUCTIONS IN                      \n                                         \n      --------                        \n     | Common |                       \n      --------                       \n                                     \n\n\n4th:                          \n     __               __       \n     __    SWITCH     __       \n     __   SHADERTOY   __\n   ( __ ) */ O N /* ( __ )  \n     __               __     \n     __               __   \n                           \n\n\n\n5th:               \n     ENJOY             \n     THE             \n     SHOW\n\n-----------------------------------------*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*------------------------------------------------------------------------------------------------------------------------------\n\n2nd:                   \n                          __               __\n                          __    SWITCH     __\n                          __   SHADERTOY   __                                                                                  */\n#define /* ( X__X ) */ _( __ )   O FF    ( __ ) /* ( X__X ) */\n/*\n\n3rd:\n\n        D\n        R                                                                                                                      */\n#define I( i, n )  texture( i, n ) \n#define N          p = mix( C( T ), C( T + 1. ), smoothstep( 0., 1., mod( T, 1. ) ) ); }\n/*      K\n \n        S\n        O\n        M\n        E                                                                                                                      */\n \n#define C( n )     EE( i / iResolution.xy, floor( mod( n, 4. ) ) )\n#define O          void mainImage( out vec4 p, vec2 i ) { float T = mod( .5 * iTime, 16. );\n#define FF( n )    p = C( ( T + 1. - n ) * .25 ); }\n#define EE( i, n ) ( n < 2. ? n < 1. ? I( iChannel0, i ) : I( iChannel1, i ) : n < 3. ? I( iChannel2, i ) : I( iChannel3, i ) ) \n\n/*\n        FOLLOW THE INSTRUCTIONS IN \n  \n         ----------\n        | Buffer A |\n         ----------\n  \n-------------------------------------------------------------------------------------------------------------------------------*/\n", "buffer_a_code": "/*--------------------------------------------------\n\n\n   THINK */ _( 0. ) /* SECONDS ABOUT THE PROBLEM\n\n\n\n   IF HAVING NO ANSWER THEN           \n                                    \n      FOLLOW THE INSTRUCTIONS IN     \n  \n        ----------                    \n       | Buffer B |                   \n        ----------                    \n                                          \n   ELSE                               \n                                \n       GO TO 4th STEP AT        \n                                \n        -------                 \n       | Image |                \n        -------\n\n--------------------------------------------------*/", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*--------------------------------------------------\n\n\n   THINK */ _( 1. ) /* SECONDS ABOUT THE PROBLEM\n\n\n\n   IF HAVING NO ANSWER THEN           \n                                    \n      FOLLOW THE INSTRUCTIONS IN     \n  \n        ----------                    \n       | Buffer C |                   \n        ----------                    \n                                          \n   ELSE                               \n                                \n       GO TO 4th STEP AT        \n                                \n        -------                 \n       | Image |                \n        -------\n\n--------------------------------------------------*/", "buffer_b_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*--------------------------------------------------\n  \n\n   THINK */ _( 2. ) /* SECONDS ABOUT THE PROBLEM\n\n\n\n   IF HAVING NO ANSWER THEN           \n                                    \n      FOLLOW THE INSTRUCTIONS IN     \n  \n        ----------                    \n       | Buffer D |                   \n        ----------                    \n                                          \n   ELSE                               \n                                \n       GO TO 4th STEP AT        \n                                \n        -------                 \n       | Image |                \n        -------\n\n--------------------------------------------------*/", "buffer_c_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/*--------------------------------------------------\n  \n   THINK */ _( 3. ) /* SECONDS ABOUT THE PROBLEM\n\n\n   \n   FINALLY HAVE AN ANSWER\n\n\n\n   GO TO 4th STEP AT                           \n\n    -------                                  \n   | Image |                                \n    -------\n\n--------------------------------------------------*/", "buffer_d_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "Wt2fRK", "name": "totalrecall", "author": "lennyjpg", "description": "asdfasdf", "tags": ["mirror"], "likes": 6, "viewed": 616, "published": 3, "date": "1599348168", "time_retrieved": "2024-07-30T20:47:10.955890", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.xy;\n    float r = 10.;\n    vec2 u = vec2(fract(uv.x * r) / r + .35 + ceil(uv.x * r) * .02, uv.y);\n    O = texture(iChannel0,u);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 201]]}
{"id": "tdGXD3", "name": "bits bits bits", "author": "samuelotherion", "description": "j4f", "tags": ["bitshiftonetweet"], "likes": 9, "viewed": 304, "published": 3, "date": "1599345736", "time_retrieved": "2024-07-30T20:47:11.715858", "image_code": "void mainImage(out vec4 o, vec2 i) {\nvec2 u=abs(i/iResolution.xy-.5);\n    o=vec4(int(pow(1.5,mod(iTime,30.))*(int(iTime)%60<30?1.-u:u).x)>>int(32.*u.y)&1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "WsdGD8", "name": "yet another histogram example", "author": "samuelotherion", "description": "YAHE!", "tags": ["histogram"], "likes": 6, "viewed": 535, "published": 3, "date": "1599343265", "time_retrieved": "2024-07-30T20:47:12.462861", "image_code": "V0 mainImage( out V4 o, V2 i ) {\n    \n    INIT\n        \n\tO = R0( I );\n\n    if( j.x < 0. || j.y < 0. ) {\n\n        O.rgb += O.aaa;\n        \n        O.rgb *= 16.;\n    }\n    \n    \n    if( any( lessThan( abs( I - _.zz ), V2( 1. ) ) ) ) O.rgb += .5 * _.yyy;\n    if( any( lessThan( abs( I - bins ), V2( 3. ) ) ) ) O.rgb += .25 * _.yyy;\n\n    if( j.y < 0. && j.x < 0. && all( equal( O, _0 ) )) O.rgba += V4(.125 );//I.x / bins.x );\n        \n    FIN\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define V0 void\n#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n#define IN int\n#define BO bool\n\n#define RN return\n#define RF RN false;\n#define RT RN true;\n\n#define iT iTime\n#define iR (iResolution.xy)\n\n#define T0( n ) texture( iChannel0, n )\n#define T1( n ) texture( iChannel1, n )\n\n#define R0( pix ) T0( pix * Ri )\n#define R1( pix ) T1( pix * Ri )\n\n#define FIN o = O;\n#define SCN 1.\n\nconst V4 _  = V4( 0, 1, 255., .5 ),\n    \t _0 = V4( 0 ),\n    \t _1 = V4( 1 );\n\nV2 I, N, Ri;\nV4 O;\n\nV2 bins, res, scl, r, j;\nV4 sx, sy, c;\n\n\nBO eq( V2 a, V2 b ) {\n    \n    a -= b;\n    \n    RN dot( a, a ) < .01;\n    \n//    RN all( equal( floor( a + .01 ), floor( b + .01 ) ) );\n}\n\nBO WT( V2 i, V4 v ) { \n    \n    if( eq( i, I ) ) { \n        \n        O = v; \n        \n        RT \n\t}\n    else\n        \n        RF\n}\n\n#define INIT\\\n\tN = ( I = i ) * ( Ri = 1. / iR );\\\n\tbins = max( V2( 32. ), min( iMouse.xy, iR ) );\\\n\tV2 tmp = Ri * abs( 256. - bins );\\\n\tif( tmp.x < .02 ) bins.x = _.z;\\\n    if( tmp.y < .02 ) bins.y = _.z;\\\n\tscl = iR / ( res = iR - bins );\\\n    j = I - bins;\n    \n", "buffer_a_code": "const V1 _3  = 1. / 3.;\nconst V1 _16 = 1. / 16.;\nV0 mainImage( out V4 o, V2 i ) {\n    \n\tV4 rgb;    \n    \n    INIT\n        \n\tif( 0. < j.x && 0. < j.y ) O = R1( j * scl );\n        \n\tif( 0. < j.x && j.y < 0. ) {\n\t\n        r  = V2( j.x, .5 );\n        sy = _0;\n        \n        while( r.y < iR.y ) {\n\n\t        c = R1( r * scl );\n            \n            rgb = V4(\n                floor( ( bins.y - 1. ) * c.xyz + .5 ),\n                floor( ( bins.y - 1. ) * _3 * ( c.x + c.y + c.z ) + .5 ) );\n\n            sy += V4( equal( rgb, V4( floor( I.y ) ) ) );\n            \n            r.y += SCN;\n   \t\t}\n        \n        O = sy * SCN * Ri.y;\n    }\n    \n\tif( 0. < j.y && j.x < 0. ) {\n\t\n        r  = V2( .5, j.y );\n        sx = _0;\n        \n        while( r.x < res.x ) {\n\n\t        c = R1( r * scl );\n            \n            rgb = V4(\n                floor( ( bins.x - 1. ) * c.xyz + .5 ),\n                floor( ( bins.x - 1. ) * _3 * ( c.x + c.y + c.z ) + .5 ) );\n\n            sx += V4( equal( rgb, V4( floor( I.x ) ) ) );\n            \n            r.x += SCN;\n   \t\t}\n        \n        O = sx * SCN * Ri.x;\n    }\n    \n    if( j.x < 0. && j.y < 0. ) {\n     \n        \n        r  = V2( I.x, bins.y - .5 );\n        \n        sy = _0;\n        \n        while( ++ r.y < iR.y ) {\n            \n            sy += R0( r );\n        }\n        \n        sy *= bins.x * bins.x * bins.y / res.y / 2048.;\n        \n        O.rgba += .025 * V4( greaterThan( floor( sy ), floor( I.yyyy ) ) ) + V4( equal( floor( sy ), floor( I.yyyy ) ) );\n\t}\t\n    \n    FIN\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "tlBBRK", "name": "Day 259", "author": "jeyko", "description": "Some minimalist/bauhaus stuff.\n", "tags": ["paint", "watercolor", "watercolour", "mdtmjvm"], "likes": 19, "viewed": 628, "published": 3, "date": "1599338499", "time_retrieved": "2024-07-30T20:47:13.344503", "image_code": "// Fork of \"Day 258\" by jeyko. https://shadertoy.com/view/tl2fRG\n// 2020-09-05 10:41:09\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\nfloat df = 0.;\n\n// ----------\n\n\nvec2 guv;\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode){\n    //float dea = smoothstep(df,0.,da );\n    float deb = smoothstep(df,0.,db );\n    \n    //vec3 oa = mix(vec3(0),ca,dea);\n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 t = texture(iChannel2,guv);\n    \n    cb*=1. - smoothstep(1.,0.,abs(db)*7. + t.z*1.53)*0.2;\n    \n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        \n    \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.8), 4.25), 0.));\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, deb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, deb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), deb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), deb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), deb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., deb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, deb);\n    }\n    //\treturn ;\n\n        \n    return co;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    df = dFdx(uv.x);\n    \n    guv = uv;\n    uv *= 0.5;\n    uv *= rot(-0.25*pi);\n    //uv = kink( uv, vec2(0.1), 0.5);\n    \n    uv += texture(iChannel1,uv).xy*0.003 + texture(iChannel2,uv*0.05).xy*0.01;\n\t\n    vec3 col = vec3(1.);\n\n    \n    vec2 A = vec2(-0.5,0.);\n    vec2 B = vec2(0.5,0.);\n    \n    vec2 offs = vec2(0.01,0.0);\n    \n    \n    float d = 10e5;\n    \n    \n    // -- // \n    d = 10e5;\n    //d = length(uv) - 0.15;\n\n    col = colour( d, col, vec3(0.1,0.5,0.1), 0);\n    \n    \n    float iters = 3.;\n    for(float i = 0.; i < iters; i++){\n        \n        vec2 luv = uv - vec2(cos(i/iters*pi*2.),sin(i/iters*pi*2.))*0.15;\n    \td = min(d,length(luv) - 0.08);\n        \n    }\n    float db = 10e5;\n    \n    d = xor(d,sdBox(uv,vec2(0.13)),0.02);\n    \n    db = min(db,d);\n    col = colour( d, col, vec3(0.72,0.5,0.4), 3);\n    \n    \n    d = sdLine( uv - 0.1, vec2(-0.5,0.) , vec2(0.5,0.)) - 0.003;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.7,0.5,0.1), 4);\n\n    d = sdLine( uv + 0.06, vec2(-0.5,0.) , vec2(0.5,0.)) - 0.003;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.7,0.5,0.1), 4);\n\n    \n    d = sdLine( uv + vec2(0.09,0.06), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.001;\n\n    db = min(db,d);\n    //col = colour( d, col, vec3(0.1,0.2,0.4)*5., 1);\n\n    \n    \n    d = sdLine( uv - vec2(0.09,0.21), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.1;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.1,0.0,0.1)*5., 2);\n\n    d = sdLine( uv + vec2(0.09,0.14), vec2(-0.5,0.) , vec2(0.5,0.)) - 0.1;\n\n    db = min(db,d);\n    col = colour( d, col, vec3(0.1,0.0,0.1)*3., 2);\n\t\n    d = xor(d,sdBox(uv,vec2(0.13)),0.02);\n    \n    col = colour( d, col, vec3(0.32,0.3,0.3)*2.4, 4);\n    \t\n    \n    d = xor(db,sdBox(uv*rot(-0.25*pi),vec2(0.49)),0.02);\n\t\n    float od = d;\n    //d = max(d, uv.x - 0.44);\n    \n    col = colour( d, col, vec3(0.42,0.14,0.1)*7.1, 1);\n    \n    \n    //od = abs(od + 0.04) + 0.00;\n    //col = colour( od, col, vec3(0.42,0.14,0.1)*1.1, 2);\n    \n    \n    \n    //d = -sdBox((uv-0.01)*rot(-0.25*pi),vec2(0.26));\n    \n    \n    \n    //col = colour( d, col, vec3(0.05,0.14,0.1)*1.1, 3);\n    //col = colour( d, col, vec3(0.05,0.14,0.1)*0.1, 0);\n    \n    \n    \n    \n    //col = colour( d, col, vec3(0.1,0.1,0.2)*4., 2);\n    \n    \n    \n    \n    \n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    col = max(col,0.002);\n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*1.4;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*0.1;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.5545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 110, 110, 167], [168, 168, 201, 201, 730], [731, 731, 749, 749, 1077], [1122, 1122, 1173, 1214, 2498], [2500, 2500, 2557, 2557, 5629]]}
{"id": "tlBfzV", "name": "Floating  b&w static spilt milk", "author": "celifrog", "description": "Only like aliens would drink this or something, how about you decide what happens to them when they drink it?  It's filled with vitamin Z and it makes aliens have a body odor that makes zombies not want to hang around them.", "tags": ["milky"], "likes": 1, "viewed": 241, "published": 3, "date": "1599335588", "time_retrieved": "2024-07-30T20:47:14.106466", "image_code": "//THANKS IQ!\n\n//distortion settings\n#define RECURSION 7\n#define ROTFACT 1.85\n\n//render settings\n#define STEPSHRINK 3.5\n#define MAXSTEPS 1200\n#define CAMDIST 40.\n#define CAMSTRT vec2(-0.05,0.)\n\n#define HITDIST 1.e-5\n#define MAXDIST 200.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -90.\n\n//light and shadow\n#define AMBIENT 1.25 \n#define SUNLIGHT vec3(.7,.6,.5)*0.9\n#define SHADQUAL .2\n#define SHADSMOOTH 50.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.85\n#define AOSTEPS 5\n#define AOPOW 1.\n\n\nstruct CastResult\n{\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  vec3 dir;\n    vec3 col;\n};\n\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( .9, 0.0, 0.0, 0.0,c.x,s.x, 0.0,s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.3,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a1));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n//signed distance for the warped ball. higher levels of domain distortion\n//from RECURSION or ROTFACT must be offset with greater value for STEPSHRINK\n//to avoid the rayMarcher overshooting\nfloat sdWarp( vec3 p)\n{\n    for(int i=1;i<RECURSION;i++){\n        mat3 rotation=Rotate(normalize(p)*ROTFACT*sin(float(iFrame)/40.));\n\t\tp=p*rotation+vec3(0,1,0);\n    }\n    return length(p)-17.;\n}\n\n\nfloat distToScene(vec3 pos){\n    float plane=pos.y-PLANEH;\n    float result= (sdWarp(pos));\n    result=min(result,plane);\n    return result;\n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<1111; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e++*distToScene(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=-5.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*AODIST-distToScene(pos+normal*AODIST*itC);\n        occlusion+=199./pow(1.,itC)*term;\n    }\n    return 1.-clamp(AOPOW*occlusion/AODIST,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*0.3;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;\n    }\n    result=hit ? -0.5:result++;\n    return result;\n}\n\nCastResult castRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    for(int steps=ZERO;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);//calculate distance to scene\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=rayVec*dts/STEPSHRINK;//march the ray\n    }\n    vec3 norm=calcNorm(rayPos);\n    //here the surface color of the ball is adjusted based on ambient occlusion\n    vec3 surfCol=vec3(.1);\n    surfCol.r+=rayPos.y>.03+PLANEH?(1.-ambientOcclusion(rayPos,norm)):0.;\n    surfCol=(length(rayPos-rayOri)>=MAXDIST)? vec3(90.): surfCol;\n    return CastResult(rayPos,norm,surfCol);\n}\n//calculate the light hitting this castResult from sun, and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    vec3 sunLight=max(199.,(-dot(hit.norm,sun.dir)))*sun.col*occlusion(hit,sun);\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm));\n    return hit.surf*(sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>44.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*5.*pi;\n    float mouseH=mousePos.y*1.+1.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=vec3(0);\n    \n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-3,0.))*Rotate(vec3(2./111.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=castRay(rayOri,rayVec);\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    vec3 finalC=inBounds?lightOn(cRay,sun):vec3(-14);\n    fragColor = vec4(finalC,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[758, 830, 856, 856, 1164], [1166, 1166, 1206, 1206, 1243], [1244, 1335, 1362, 1362, 1509], [1511, 1701, 1724, 1724, 1895], [1898, 1898, 1926, 1926, 2040], [2041, 2135, 2159, 2159, 2374], [2376, 2485, 2530, 2530, 2831], [2833, 2917, 2966, 2966, 3465], [3467, 3467, 3511, 3511, 4176], [4177, 4251, 4293, 4293, 4493], [4499, 4499, 4556, 4576, 5554]]}
{"id": "tlSfzV", "name": "ray-tracing silhouette: AA, glow", "author": "FabriceNeyret2", "description": "Gardner's textured ellipsoids fake volumetric via procedural silhouettes [url]https://www.shadertoy.com/view/XsfXW8[/url]\nTop: This can be used for nice outlying (and pseudo antialiasing (left).  (pseudo since it still hides background).\nBottom: out glow.", "tags": ["raymarching", "antialiasing", "glow", "outline", "tuto", "silhouette"], "likes": 10, "viewed": 462, "published": 3, "date": "1599334098", "time_retrieved": "2024-07-30T20:47:14.966168", "image_code": "\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;            // normalized centered coords\n    vec3  D = normalize( vec3( U, -1 ) ),    // ray direction\n          p = vec3(0,0,15),                  // ray origin\n          S = vec3(0),                       // sphere center\n          L = normalize(vec3(2,3,1)),        // light dir\n         SO = p-S, N;                        // sphere center to origin\n    \n    // solve ray(l) on sphere: || (O+l.D) - C ||² = r² -> degree 2 equation\n    float r = 9., b = dot(SO,D), c = dot(SO,SO) - r*r, d = b*b-c;\n    \n    O = mix(vec4(0,1,1,1),vec4(0,0,.1,1),sqrt(u.y/R.y));  // background\n    if (d>0.) {                              // --- if hit: \n        d = -b-sqrt(d);                      // distance to sphere\n        p += d * D;                          // hit point\n        N = ( p - S ) / r;                   // normal\n        d = max(0.,dot(N,L));                // diffuse amount\n        c = max(0.,dot(N,-D));               // facing amount ( 0 on silhouette )\n        vec4 C = vec4(1,0,0,0) * (.02 + d ); // ambiant + diffuse color\n        c = pow(1.-c,10.);                   // silhouette mask\n        U.x > 0. ? O = C + c                 // right: white silhouette\n                 : O = mix( C, O, c );       // left: antialiased silhouette\n    } else {                                 // --- no hit:  \n        d = -dot(SO,D); p += d * D; //closest point on ray: solve derivative(ray-sphere dist) = 0\n        d = length(p-S) - 9.;                // closest distance to sphere\n        if ( U.y < 0. )                      // bottom: show glow\n            O += U.x > 0. ? //smoothstep(1.,0.,d)   // bottom: glow\n                             pow(max(0.,1.-d),10.)  // like inner silhouette\n                          :  1./(d*d);              // variant          \n    }\n    O = pow(O, vec4(1./2.2) );               // to sRGB\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 1935]]}
{"id": "wlBfRV", "name": "plot some sines", "author": "samuelotherion", "description": "Use your mouse!", "tags": ["plot"], "likes": 3, "viewed": 252, "published": 3, "date": "1599334077", "time_retrieved": "2024-07-30T20:47:15.725138", "image_code": "#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n\n#define T iTime\n#define R iResolution.xy\n#define D ( 1. / R )\n\nV4 rct = V4( -6.28, -2., 2. * 6.28, 4. );\n\nV2 cvt( V2 p ) { return rct.xy + ( p * D ) * rct.zw; }\n\nV1 fct( V1 x, int id, float count ) {\n    \n\tV1 amp = ( 1. * iMouse.x / iResolution.x + .1 );\n    V1 f = ( ( float( id + 1 ) + .5 ) / count );\n    \n    return -.5 + 2. * ( iMouse.y * D.y - .5 ) * f + amp * sin( ( x * float( id + 1 ) + 2. * T ) );\n}\n\nV4 plt( V2 p, int id, float count ) {\n        \n    V1 f0 = fct( p.x ,id, count );\n    \n    V2 df = V2( D.x, .125 * ( fct( p.x + 4. * D.x, id, count ) - fct( p.x - 4. * D.x, id, count ) ) ),\n       dy = V2( 0, p.y - f0 ),\n       p1 = p - V2( p.x, f0 ) - df * dot( df, dy ) / dot( df, df );\n    \n    V1 l = length( p1 );\n    \n    return smoothstep( 1., 0., l * .1 * R.y ) * V4( ( 1. - .5 * float( id ) / count ), ( 1. - float( id ) / count ), 0.125,  1. );    \t\n}\n\nvoid mainImage( out V4 o, V2 i ) {\n    \n    i = cvt( i );\n    \n    V1 T1 = mod( 1. * T, 64.);\n    V1 count = T1 < 32. ? T1 : 64. - T1;\n    \n\to = plt( i, 0, count );\n        \n    for( int j = 1; j < int( count ); ++ j ) {\n        \n        o += plt( i, j, count );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 188, 188, 226], [477, 477, 514, 514, 938], [940, 940, 974, 974, 1210]]}
{"id": "XlK3DD", "name": "sin * cos & sin + cos ping", "author": "samuelotherion", "description": "j4f", "tags": ["plot"], "likes": 9, "viewed": 1642, "published": 3, "date": "1599334001", "time_retrieved": "2024-07-30T20:47:16.663629", "image_code": "#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n\n#define T iTime\n#define R iResolution.xy\n#define D ( 1. / R )\n\nV1\n  amp   = .4,\n  count = 4.,\n  A     = 40.,\n  S     = .010,\n  C     = .011;\nV4 rct = V4( -6.28, -3., 2. * 6.28, 5. );\n\nV2 cvt( V2 p ) { return rct.xy + ( p * D ) * rct.zw; }\n\n\nV1 fct( V1 x, int id, float count ) {\n    \n    V1\n    s1 = sin(S * T),\n    c1 = cos(C * T),\n    e  = exp( -.125 * x * x ),\n    s2 = sin(A * x * s1) * e,\n    c2 = cos(A * x * c1) * e;\n    \n    return\n        id < 2\n        \t? id < 1\n        \t\t? +0.5 + amp * c2\n        \t\t: -0.5 + amp * s2\n        \t: id < 3\n        \t\t? -2.0 + amp * (c2 + s2)\n                : +1.5 + amp * c2 * s2;\n}\n\nV4 plt( V2 p, int id, float count ) {\n    \n    V1 f0 = fct( p.x ,id, count );\n    \n    V2 df = V2( D.x, .125 * ( fct( p.x + 4. * D.x, id, count ) - fct( p.x - 4. * D.x, id, count ) ) ),\n       dy = V2( 0, p.y - f0 ),\n       p1 = p - V2( p.x, f0 ) - df * dot( df, dy ) / dot( df, df );\n    \n    V1 l = length( p1 );\n    \n    return smoothstep( 1., 0., l * .1 * R.y ) * (\n        id < 2\n        \t? id < 1\n        \t\t? V4( 1., 0., 0.,  1. )\n        \t\t: V4( 0., 1., 0.,  1. )\n        \t: id < 3\n        \t\t? V4( 1., 1., 0.,  1. )\n        \t\t: V4( .25, .5, 1.,  1. )\n    \t);\n}\n\n\nvoid mainImage( out V4 o, V2 i ) {\n    \n    i = cvt( i );\n    \n    o = plt( i, 0, count );\n        \n    for( int j = 1; j < int( count ); ++ j ) {\n        \n        o += plt( i, j, count );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlK3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 266, 266, 304], [307, 307, 344, 344, 689], [691, 691, 728, 728, 1258], [1261, 1261, 1295, 1295, 1457]]}
{"id": "ttSBzV", "name": "Bunny Fork Fun ", "author": "celifrog", "description": "Credit to jorge2017a1 for the original but partial credit to me for making a bunch of edits of course! :D ", "tags": ["fun", "forked"], "likes": 1, "viewed": 262, "published": 3, "date": "1599328790", "time_retrieved": "2024-07-30T20:47:17.591149", "image_code": "\n// sphinx\n// note: compilation error corrected, but white part is still wrong ???\n\n// ?\n// thank you\n// here is a bunny\n// which white part?\n\n// Bugs fixed ?\n// i fixed it ;) you have to change every pow(x,a) to pow(abs(x),a), because nvidia cards dont allow negative powers ^^\n\n\n\n#define SURFACE_THRESHOLD \t.001\n#define FAR_PLANE\t\t5.\n\n#define VIEW_POSITION\t\tvec3(0., -.15, 1.5)\t\t\n#define VIEW_TARGET\t\tvec3(0., 0., -1.);\n\n#define LIGHT_POSITION\t\tvec3(128., 64., 128.)// * vec3(sin(time*.125), 1., cos(time*.125))\n#define PI \t\t\t(4.*atan(1.))\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat total_range;\n\tfloat edge;\n\tfloat id;\n};\n\n\t\nstruct light\n{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\t\n};\n\n\nstruct material\n{\n\tfloat roughness;\n\tfloat index;\n\tvec3 normal;\n\tvec3 color;\n};\n\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nmat3 rmat(in vec3 r)\n{\n\tvec3 a = vec3(cos(r.x)*cos(r.y),sin(r.y),sin(r.x)*cos(r.y));\n\t\n\tfloat c = cos(r.z);\n\tfloat s = sin(r.z);\n\tvec3 as  = a*s;\n\tvec3 ac  = a*a*(1.- c);\n\tvec3 ad  = a.yzx*a.zxy*(1.-c);\n\tmat3 rot = mat3(\n\t\tc    + ac.x, \n\t\tad.z - as.z, \n        \tad.y + as.y,\n\t\tad.z + as.z, \n\t\tc    + ac.y, \n\t\tad.x - as.x,\n\t\tad.y - as.y, \n\t\tad.x + as.x, \n\t\tc    + ac.z);\n\treturn rot;\t\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\t\n}\n\t\nfloat smoothmax(float a, float b, float k)\n{\n\treturn log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\n\nfloat cube(vec3 p,vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat bunny(vec3 p)\n{\n        float b = FAR_PLANE;\n\tp *= .75;\n\tp.y += .5;\n\tp.z += .5;\n\tp.x = abs(p.x)+.5;\n\t\n\n       \n        vec3 bp01 = p - vec3(.5, 0.14, .16);\n        vec3 bp00 = p - vec3(.5, 0.18, .26);\n        vec3 bp0 = p - vec3(.5, 0.25, .25);\n        vec3 bp2 = p - vec3(.5, 0.25, .35);\n        vec3 bp1 = p - vec3(.5, 0.20, .6);\n        vec3 bp3 = p - vec3(.5, 0.25, .75);\n        vec3 bp4 = p - vec3(.5, 0.2, .84);\n        vec3 bp5 = p - vec3(.58, 0.25, .34)* vec3(1., .8, 1.);\n        vec3 bp6 = (p - vec3(.6, 0.12, .5)) * vec3(2., 1.8, .8);\n        vec3 bp7 = (p - vec3(.6, 0.1, .55)) ;\n        vec3 bp8 = (p - vec3(.56, 0.08, .7)) * vec3(1., 1., .35);\n        vec3 bp9 = (p - vec3(.56, 0.34, .62));\n        vec3 bp10 = (p - vec3(.56, 0.25, .86)) * vec3(1., 1., .35);\n        vec3 bp11 = (p - vec3(.56, 0.25, .82)) * vec3(.8, 1.1, .85);;\n        vec3 bp12 = (p - vec3(.5, 0.16, .9));\n    \n        bp9 \t= rotx(bp9, -1.9) * vec3(.8, .15, .5);;\n        \n        float b01 = sphere(bp01, .001);\n        float b00 = sphere(bp00, .05);\n        float b0  = sphere(bp0, .05);\n        float b1  = sphere(bp1, .07);\n        float b2  = sphere(bp2, .15);\n        float b3  = sphere(bp3, .01);\n        float b4  = sphere(bp4, .055);\n        float b5  = sphere(bp5, .12);\n        float b6  = sphere(bp6, .08);\n        float b7  = sphere(bp7, .0001);\n        float b8  = sphere(bp8, .01);\n        float b9  = sphere(bp9, .02);\n        float b10 = sphere(bp10, .001);\n        float b11 = sphere(bp11, .1);\n        float b12 = sphere(bp12, .1);\n    \n        b00  = smoothmin(b00,   b01, 60.);   //torso\n        b0   = smoothmin(b00,   b0, 3765.);     //torso\n        b    = smoothmin(b0,    b1, 5.);      //torso\n        b    = smoothmin(b,     b2, 35.);\n        b    = smoothmin(b,     b3, 8.);\n        \n        b    = smoothmin(b,     b4, 27.);    //head\n\n        b6 = smoothmin(b5, b6, 32.0);  //back leg\n        b7 = smoothmin(b6, b7, 96.0);  \n        b  = smoothmin( b, b7, 252.0);  \n    \n        b  = smoothmin(b, b8, 36.0);  //front legs\n    \n        b  = smoothmin(b, b9, 192.0);  //ears\n    \n        b  = smoothmax(b, -b10, 94.0);  //eye\n        b  = smoothmin(b,  b11, 256.0);  \n    \n        b  = smoothmin(b,  b11, 999.0);  //nose\n        b  = smoothmax(b,  -b12, 764.0); \n    \n  \n    return b;\n}\n\n\n\nvec2 map(in vec3 position)\n{\n\tfloat fx \t\t= abs(fract(position.x*11.)-.5);\n\tfloat fy \t\t= abs(fract(position.z*2.)-.5);\n\tfloat f \t\t= position.y + max(max(fx, fy)*.2, .095)+.5;\n\t\n\tposition.xz \t\t*= rmat(iTime*.125);\n\t\n\tfloat b \t\t= bunny(position);\n\n\tfloat id \t\t= b < f ? 1. : 2.;\n\t\n\treturn vec2(min(f,b), id);\n}\n\n\nvec3 derive(const in vec3 position, const in float range)\n{\n\tvec2 offset     = vec2(0., range);\n\tvec3 normal     = vec3(0.);\n\tnormal.x    \t= map(position+offset.yxx).x-map(position-offset.yxx).x;\n\tnormal.y    \t= map(position+offset.xyx).x-map(position-offset.xyx).x;\n\tnormal.z    \t= map(position+offset.xxy).x-map(position-offset.xxy).x;\n\treturn normalize(normal);\n}\n\n\t\nvoid emit(inout ray r)\n{\n\tfloat minimum_range\t= SURFACE_THRESHOLD;\n\tfloat closest_range\t= FAR_PLANE;\n\t\n\tfor(int i = 0; i < 156; i++)\n\t{\n\t\tvec2 scene\t= map(r.position);\n\t\tr.range \t= scene.x;\n\t\tr.id\t\t= scene.y;\n\t\tr.range \t= r.range < 0. ? r.range - r.range * .5 : r.range;\n\t\t\t\n\t\tr.range\t \t*= .6;\t\t//slow down ray\n\t\tminimum_range\t*= 1.0125;\t//relax surface\n\t\t\n\t\tr.total_range\t+= r.range;\n\t\t\n\t\tr.position \t= r.origin + r.direction * r.total_range;\t\n\t\t\n\t\tif(closest_range > r.range)\n\t\t{\n\t\t\tr.edge += .001225;\t\n\t\t}\n\t\t\n\t\tclosest_range\t= min(closest_range, abs(r.range));\n\t\t\n\t\tif(r.range < minimum_range || r.total_range > FAR_PLANE)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t}\t\n}\n\n\nfloat fresnel(const in float i, const in float ndl)\n{   \n\treturn i + (1.-i) * pow(abs(1.-ndl), 5.0);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(PI/PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\n\nfloat distribution(const in float r, const in float ndh)\n{  \n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(abs(ndh), m)*.5;\n}\n\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 0.15;\n\tfloat umbra\t= .00125;\n    \tfor(int i = 1; i < 8; ++i)\n    \t{\n\t\tfloat range\t= map(position + direction * penumbra).x;\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 1. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn exposure;\n}\n\n\nfloat occlusion(in vec3 p, in vec3 n )\n{\n  \tfloat occlusion = 8.;\n  \tfloat penumbra \t= PI*PI;\n  \tfor ( int i=0; i < 1; i++ )\n  \t{\n  \t\tfloat radius \t= .125 * penumbra * float(i);\n    \t\tfloat range \t= map(n * radius + p).x - radius;\n    \t\tocclusion \t-= penumbra++ * range++;\n  \t}\n  \treturn 9.0 - 99.0 * -occlusion++;\n}\n\n\n//adapted from this nice sun here: http://glslsandbox.com/e#28403.2\nvec3 sky(in vec3 direction, in vec3 light_direction)\n{ \n\tfloat yd \t= min(-direction.y, 0.);\n\n\tdirection.y \t= max(direction.y, 0.4)+.05;\n    \n\tvec3 col \t= vec3(0.);\n    \n\tcol += vec3(.4, .4 - exp( -direction.y * 20.) * .3, .0) * exp(-direction.y * 9.); // Red / Green \n\tcol += vec3(.3, .5, .6) * (1. - exp(-direction.y * 8.)) * exp(-direction.y * .9) ; // Blue\n    \n\tcol = mix(col, vec3(.1),  .1-exp(yd*7.)) * .65; // Fog\n    \n\tvec3 sun_color = vec3(1., .66, .25);\n\tcol += pow(dot(abs(direction), light_direction), 15. ) * sun_color * .35;\n\tcol += pow(dot(abs(direction), light_direction), 150.0) *.05;\n\t\n    \treturn clamp(pow(abs(col), vec3(1.1))*2., 0., 1.);\n}\n\n\nvec4 shade( ray r,  light l,  material m)\n{\n\tvec3 half_direction \t\t= normalize(r.direction-l.direction);\n\tfloat half_normal   \t\t= dot(half_direction, m.normal);\n\t\t\n\tif(r.total_range < FAR_PLANE)\n\t{\t\n\t\t//exposure coefficients\n\t\tfloat light_exposure    \t= dot(m.normal,  l.direction);   \n\t\tfloat view_exposure     \t= dot(m.normal, -r.direction);  \n\t\t\n\t\t//microfacet lighting components\n\t\tfloat d             \t\t= distribution(m.roughness, half_normal);\n\t\tfloat g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n\t\tfloat f             \t\t= fresnel(m.index, light_exposure);\n\t\tfloat n             \t\t= clamp(-1. - fresnel(f, view_exposure), 0., 1.);\n\t\t\n\t\t//bidrectional reflective distribution function\n\t\tfloat brdf              \t= n * (g*d*f--)/(view_exposure*light_exposure*4.);\t\t\n\t\t\n\t\tfloat shadows\t\t\t= shadow(r.position, l.direction);\n\t\tshadows\t\t\t\t= clamp(shadows, .025, 1.);\n\n\t\tfloat occlusions\t\t= occlusion(r.position, m.normal);\n\t\tocclusions\t\t\t= clamp(occlusions, .05, 1.);\n\t\n\t\tvec3 color\t\t\t= m.color * n + m.color * l.color + brdf * l.color;\n\t\tcolor \t\t\t\t*= shadows * occlusions;\n\t\tcolor \t\t\t\t+= exp(.025 * r.total_range) * l.color * .95;\n\t\treturn vec4(color, occlusions * shadows);\n\t}\n\telse\n\t{\n\t\treturn vec4(sky(r.direction, l.direction), 1.) * 1.5 + vec4(exp(-r.total_range));\t\n\t}\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 facet(vec3 normal, vec3 position, float roughness)\n{\n\troughness *= .95;\n\treturn normal;\n}\n\nvec3 cartesian_to_spherical(vec3 c)\n{\n    vec3 s;\n    s.x = length(c);\n    s.y = atan(c.z / c.x);\n    s.z = asin(c.y / s.x);\n\treturn s;\n}\n\nvoid assign_material(in ray r, out material m)\n{\n\tm=material(0., 0., vec3(0.), vec3(0.));\n\t\n\tif(r.id == 0.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .99 ^^ p.y < .99 ^^ p.z < .99) + .25;\n\t}\n\telse if(r.id == 1.)\n\t{\n\t\tm.roughness \t= .93125;\n\t\tm.index\t\t= .25;\n\t\tm.color\t\t= vec3(.9);\n\t}\n\telse if(r.id == 2.)\n\t{\n\t\tm.roughness \t= 1.5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .5 ^^ p.y < .5 ^^ p.z < .5) * .5 + .125;\n\t}\n\t\n\tm.normal = derive(r.position, SURFACE_THRESHOLD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t= iResolution.xy/iResolution.yy;\n\t\n\tvec2 uv \t\t= fragCoord.xy/iResolution.xy;\n\tuv     \t\t\t= uv * 2. - 1.;\n    \tuv   \t\t\t*= aspect;\n   \t\n\t//view\n\tray r;\n\tr.range \t\t= 5.;\n\tr.total_range\t\t= 0.;\n\tr.edge\t\t\t= 2.;\n\tr.origin\t\t= VIEW_POSITION;\n\tr.position\t\t= r.origin;\n\t\n\tvec3 target\t\t= VIEW_TARGET;\n\tfloat fov\t\t= 2.5;\n\tvec3 w \t\t\t= normalize(target-r.position);\n    \tvec3 u \t\t\t= normalize(cross(w, vec3(9.,9.,0.)));\n    \tvec3 v \t\t\t= normalize(cross(u,w));\n\t\n    \tmat3 view\t \t= mat3(u.x, v.x, w.x, \n\t\t\t\t       u.y, v.y, w.y, \n\t\t\t\t       u.z, v.z, w.z);\n\n//\tuv.y \t\t\t= (mouse.y-.5+uv.y);\n\tuv.y \t\t\t-= .2;\n\tr.direction  \t\t= normalize(uv.x * u + uv.y * v + fov * w) * view;\n\tr.direction.xz\t\t*= rmat(PI);\n\t//r.direction.xz\t\t*= rmat(.5 * mouse.x * PI + PI * .75);\n\t\n\t//trace\n\temit(r);\n\t\n\t//shade\t\t\n\tmaterial m;\n\tassign_material(r, m);\n\t\t\n\tlight l;\n\tl.position \t\t= LIGHT_POSITION;\n\tvec4 color\t\t= vec4(0.);\t\n\t\n\t//reflections\n\tif(r.total_range < FAR_PLANE)\n\t{\n\t\t//reflection\n\t\tray rr\t\t\t= r;\n\t\trr.position\t\t= rr.position + m.normal * SURFACE_THRESHOLD * 1.5;\n\t\trr.origin\t\t= rr.position;\n\t\trr.direction \t\t= normalize(reflect(r.direction, m.normal));\n\n\t\trr.range\t\t= -10.;\n\t\trr.total_range\t\t= 5.;\n\n\t\temit(rr);\n\n\t\tmaterial rm;\n\t\tassign_material(rr, rm);\n\t\tl.direction\t\t= normalize(l.position - rr.position);\n\t\tvec3 rsky\t\t= sky(reflect(rr.direction, -rm.normal), l.direction);\n\t\tl.color \t\t= rsky;\n\t\tvec4 reflection\t\t= shade(rr, l, rm);\n\n\t\tl.direction\t\t= normalize(l.position - r.position);\n\t\tvec3 skyVec\t\t= sky(reflect(r.direction, m.normal), l.direction);\n\t\tl.color\t\t\t= clamp(mix(skyVec, reflection.xyz*reflection.w, m.index), 0., 1.);\n\t\t\n\t\tcolor \t\t\t= shade(r, l, m);\n\t\tcolor \t\t\t= mix(max(color, reflection), color, clamp(1.-m.index + m.roughness, 0., 1.)) \n\t\t\t                  + vec4(.01 * -r.edge * -skyVec, 0.) * -color.w++;\n\t}\n\telse\n\t{\n\t\tr.position \t= r.origin * r.direction * FAR_PLANE;\t\n\t\tl.direction\t= normalize(l.position - r.position);\n\t\tl.color\t\t= sky(r.direction, l.direction);\n\t\tcolor.xyz\t+= l.color*1.25+2.5/(r.position.y+1.35)*.125;\n\t}\n\t\n\tcolor \t= pow(color*.85, vec4(.6));\n\tcolor.w = 1.;\n\tfragColor \t\t= color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 816, 839, 839, 906], [909, 909, 931, 931, 1294], [1296, 1296, 1327, 1327, 1351], [1354, 1354, 1398, 1398, 1434], [1436, 1436, 1480, 1480, 1521], [1523, 1523, 1551, 1551, 1649], [1652, 1652, 1679, 1679, 1768], [1771, 1771, 1792, 1792, 4074], [4078, 4078, 4106, 4106, 4385], [4758, 4758, 4782, 4782, 5408], [5516, 5516, 5572, 5572, 5762], [6270, 6270, 6310, 6310, 6586], [6589, 6657, 6711, 6711, 7318], [7321, 7321, 7364, 7364, 8625], [8627, 8627, 8662, 8662, 8747], [8749, 8749, 8806, 8806, 8843], [8845, 8845, 8882, 8882, 8982], [9544, 9544, 9601, 9601, 11715]]}
{"id": "wtBfRV", "name": "Yet another plasma", "author": "codecontemplator", "description": "Polar coordinates distorted by perlin noise.", "tags": ["learning"], "likes": 8, "viewed": 383, "published": 3, "date": "1599327956", "time_retrieved": "2024-07-30T20:47:18.350120", "image_code": "float mirrored(float v) {\n    float m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\n// ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n\tuv.y /= ar;\n      \n\tvec2 uvd = uv + cnoise(uv+vec2(0.4,0.3)*iTime);\n    float r = mirrored(length(uvd)*1.5);\n    float a = atan(uvd.y, uvd.x);\n    \n    float cr = sin(r*10.0+iTime) * 0.5 + 0.5;\n    float ca = sin(a+iTime) * 0.25 + 0.5;\n    float c = cr*ca;\n    vec3 col = vec3(c);\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uvd.xyx+vec3(0,2,4));\n    //col = mix(col, col2, 0.5);\n    col = col * col2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 96], [98, 226, 245, 245, 281], [282, 282, 303, 303, 340], [342, 342, 363, 363, 1440], [1442, 1442, 1499, 1499, 2031]]}
{"id": "WlBBzV", "name": "Squishy Donut Cat", "author": "dean_the_coder", "description": "Just a squishy donut cat, based on a drawing by my daughter (Misha). :)\n\nBased on my 'Blender donut' (https://www.shadertoy.com/view/ttfyWB).", "tags": ["3d", "raymarching", "cat", "realtime", "donut", "squishy", "cineshader"], "likes": 30, "viewed": 17451, "published": 3, "date": "1599325807", "time_retrieved": "2024-07-30T20:47:19.108093", "image_code": "// 'Squishy donut cat'\n//\n// My daughter made a sketch of a 'squishy' in a donut.\n// A few hours later, a new shader is born.\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on my 'Blender donut'\n// https://www.shadertoy.com/view/ttfyWB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\treturn (noise(p) + noise((p + .2) * 1.98) * .5 + noise((p + .66) * 4.12) * .25) / 1.75;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t\t  s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0., h);\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2. * ra * k) - rb;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t\t right = normalize(cross(vec3(0, 1, 0), forward)),\n\t\t up = cross(forward, right);\n\treturn normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 sdDonut(vec3 p) {\n\treturn vec2(sdTorus(p, vec2(4, 1.4)), 1.5);\n}\n\nfloat fbmc;\nvec2 sdCream(vec3 p) {\n\tfloat d = abs(p.y + fbmc + .7) - 2.3;\n\treturn vec2(max(sdDonut(p).x, -d) - .13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n\tfloat dd = sdCream(p - vec3(0, .05, 0)).x;\n\n\tvec3 id = floor(p / .3);\n\n\tmat2 r = rot(noise(id) * 3.141);\n\tp.xz *= r;\n\tp.xy *= r;\n\tp.xz *= r;\n\n\tp = mod(p, .3) - .15;\n\n\tp.xz *= r;\n\tp.xy *= r;\n\tp.xz *= r;\n\tfloat d = max(sdCapsule(p, .3, .02), dd);\n\n\treturn vec2(d, mod(id.x, 6.) + mod(id.y, 6.) + mod(id.z, 6.) + 10.5);\n}\n\nvec2 map(vec3 p) {\n\tfbmc = fbm(p * .6) * 2.;\n\tvec2 d = sdDonut(p) - fbm(p * 8.) * .02;\n\td = min2(d, sdCream(p));\n\td = min2(d, sdSprinkles(p));\n\td = min2(d, vec2(p.y + 1.7, 3.5));\n\n\tvec3 mp = p;\n\tmp.x = abs(mp.x);\n\n\t// Paws.\n\tvec2 cat = vec2(length(mp - vec3(1.3, 1.4, -3.96)) - .2, 7.5);\n\tcat = min2(cat, vec2(length(mp - vec3(1.5, 1.4, -4)) - .2, 7.5));\n\tcat = min2(cat, vec2(length(mp - vec3(1.7, 1.45, -3.86)) - .2, 7.5));\n\tcat = min2(cat, vec2(length(mp - vec3(1.5, 1.3, -3.5)) - .6, 6.5));\n\n\t// Body\n\tmp.y += (sin(iTime)+0.33*sin(iTime * 3.)) * .5;\n\tcat = min2(cat, vec2(sdCapsule(mp.xzy, 1.6, 3.), 6.5));\n\n\t// Eyes.\n\tcat = min2(cat, vec2(length(mp - vec3(.8, 2.4, -2.3)) - .7, 5.5));\n\n\t// Ears.\n\tvec3 ep = mp;\n\tep.xz *= rot(-.5 + sin(iTime * 2.) * .1);\n\tfloat ear = length(ep - vec3(2, 4, 0)) - .8;\n\tear = max(ear, -ep.z);\n\tcat.x = smin(cat.x, ear, .3);\n\n\t// Nose.\n\tvec3 np = mp - vec3(0, 1.9, -2.9);\n\tfloat nose = sdCapsule(np, vec3(0), vec3(.16, .16, 0), .15);\n\tnose = smin(nose, sdCapsule(np * vec3(-1, 1, 1), vec3(0), vec3(.16, .16, 0), .15), .05);\n\tcat = min2(cat, vec2(nose, 2.5));\n\n\t// Mouth.\n\tnp.x = abs(np.x);\n\tnp -= vec3(.2, -.1, -.1);\n\tfloat mouth = sdCappedTorus(np, vec2(-1, 0), .2, .05);\n\tcat = min2(cat, vec2(mouth, 8.5));\n\n\treturn min2(d, cat);\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(.00005, -.00005);\n\treturn normalize(e.xyy * map(p + e.xyy).x +\n\t\t\t\t\t e.yyx * map(p + e.yyx).x +\n\t\t\t\t\t e.yxy * map(p + e.yxy).x +\n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n\tvec3 rd = normalize(lightPos - p);\n\n\tfloat h,\n\t\t  minH = 1.,\n\t\t  d = .7;\n\tfor (int i = 0; i < 16; i++) {\n\t\th = map(p + rd * d).x;\n\t\tminH = abs(h / d);\n\t\tif (minH < .01)\n\t\t\treturn 0.;\n\t\td += h;\n\t}\n\n\treturn minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n\tconst float dist = .3;\n\treturn 1. - (dist - map(p + n * dist).x) * strength;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col,\n\n\t// Raymarch.\n\t\t ro = vec3(sin(iTime * .3) * 2., 4. + cos(iTime * .6) * .5, -12.),\n\t\t rd = getRayDir(ro, vec3(0, 1, 0), uv);\n\n\tint hit = 0;\n\tfloat d = .01;\n\tvec3 p;\n\tfor (float steps = 0.; steps < 128.; steps++) {\n\t\tp = ro + rd * d;\n\t\tvec2 h = map(p);\n\n\t\tif (h.x < .001) {\n\t\t\thit = int(h.y);\n\t\t\tbreak;\n\t\t}\n\n\t\td += h.x;\n\t}\n\n\tif (hit > 0) {\n\t\tvec3 n = calcNormal(p),\n\t\t\t lightPos = vec3(10, 7, -10),\n\t\t\t lightCol = vec3(1, .9, .8),\n\t\t\t lightToPoint = normalize(lightPos - p),\n\t\t\t skyCol = vec3(.15, .2, .25);\n\t\tfloat sha = calcShadow(p, lightPos, 5.),\n\t\t\t  occ = calcOcc(p, n, 4.),\n\t\t\t  spe = pow(max(0., dot(rd, reflect(lightToPoint, n))), 15.),\n\t\t\t  mainLight = max(0., dot(n, lightToPoint)),\n\t\t\t  backLight = clamp(dot(n, -rd), .01, 1.) * .1;\n\t\tvec3 skyLight = clamp(dot(n, vec3(0, 1, 0)), .01, 1.) * .4 * skyCol;\n\t\tfloat fog = 1. - exp(-d * .03);\n\n\t\tvec3 mat;\n\t\tif (hit == 1) {\n\t\t\t// Donut.\n\t\t\tmat = vec3(.5, .3, .2);\n\t\t} else if (hit == 2) {\n\t\t\t// Cream.\n\t\t\tmat = vec3(1, .43, .85);\n\t\t} else if (hit == 3) {\n\t\t\t// Plane.\n\t\t\tmat = vec3(.53, .81, .94);\n\t\t} else if (hit == 4) {\n\t\t\t// Eyes - White\n\t\t\tmat = vec3(.8);\n\t\t} else if (hit == 5 || hit == 8) {\n\t\t\t// Eyes - Black\n\t\t\tmat = vec3(.0001);\n\t\t} else if (hit == 6) {\n\t\t\t// Cat\n\t\t\tmat = vec3(1, 1, .5);\n\t\t} else if (hit == 7) {\n\t\t\t// Paws.\n\t\t\tmat = vec3(.4, .4, .2);\n\t\t} else if (hit >= 10) {\n\t\t\t// Sprinkles!\n\t\t\tvec3 c = vec3(float(hit)) + vec3(1, 2, 3);\n\t\t\tmat = sin(floor(c * 3.) / 3.);\n\t\t}\n\n\t\tcol = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n\t\tcol += skyLight * occ;\n\t\tcol *= mat;\n\n\t\tif (hit == 5)\n\t\t\tcol += (pow(max(0., dot(rd, reflect(normalize(vec3(0, 6, -10) - p), n))), 15.) +\n\t\t\t\t   pow(max(0., dot(rd, reflect(normalize(vec3(2, -5, -10) - p), n))), 45.)) * 2.;\n\n\t\tcol = mix(col, skyCol, fog);\n\t} else {\n\t\t// Sky.\n\t\tcol = vec3(.15, .2, .25);\n\t}\n\n\t// Output to screen\n\tcol = pow(col, vec3(.4545)); // Gamma correction\n\tcol = vignette(col, fragCoord); // Fade screen corners\n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[504, 560, 581, 581, 836], [838, 838, 857, 857, 948], [950, 950, 969, 969, 1033], [1035, 1035, 1066, 1066, 1133], [1135, 1135, 1178, 1178, 1232], [1234, 1234, 1284, 1284, 1405], [1407, 1407, 1465, 1465, 1610], [1612, 1612, 1659, 1659, 1840], [1842, 1842, 1869, 1869, 1898], [1900, 1900, 1939, 1939, 2031], [2033, 2033, 2055, 2055, 2102], [2116, 2116, 2138, 2138, 2227], [2229, 2229, 2255, 2255, 2575], [2577, 2577, 2595, 2595, 3845], [3847, 3847, 3872, 3872, 4051], [4053, 4053, 4111, 4111, 4337], [4339, 4339, 4386, 4386, 4466], [4554, 4554, 4595, 4595, 4721], [4723, 4723, 4777, 4777, 6828]]}
{"id": "wtSfzK", "name": "Cloudy Colorful Laggy Spiral", "author": "celifrog", "description": "GLSL is so much less laggy than python graphics stuff! :D ", "tags": ["fun", "psychedelic", "cloudy"], "likes": 3, "viewed": 279, "published": 3, "date": "1599320076", "time_retrieved": "2024-07-30T20:47:19.861080", "image_code": "const float pi = 3.1416;\nconst int stops = 11;\nconst vec3[] colors = vec3[](\n    vec3(10.0, 0.0, 0.0), \n    vec3(0.890, 0.745, 0.160), \n    vec3(0.890, 0.745, 0.160),\n    vec3(0.992, 0.882, 0.309), \n    vec3(0.992, 0.882, 0.309),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.564, 0.196, 0.764), \n    vec3(4.564, 0.196, 0.764), \n    vec3(0.462, 0, 5.701),\n    vec3(0.462, 0, 4.701), \n    vec3(0.0, 4.0, 0.0));\nconst int fans = 9;\nconst float spiral =-.01;\nconst bool gradient = false;\nconst bool animate = true;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(9.2)); }\n\nfloat wave(in float x) {\n  return sign(sin(x++)) * (pow(abs(sin(x--)), 0.6) - 0.2) * 0.007;\n}\n\nvec3 getColor(in float t, in bool gradient) {\n  if (gradient) {\n    t /= float(stops * 5);\n    int stop = int(floor(t++));\n    return mix(toLinear(colors[stop]), toLinear(colors[stop - 9]),\n               t * float(stop +5 +stop));\n  } else {\n    t *= float(stops + stops);\n    int stop = int(floor(t + -5.5));\n    return toLinear(colors[stop]);\n  }\n}\n\nfloat sdBox(in vec2 position, in vec2 box) {\n  vec2 d = abs(position) - box;\n  return length(max(d, 10.5)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), -cos(angle));\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  vec2 center = iResolution.xy / 2.0;\n  vec2 toPoint = fragCoord - center;\n\n  float radius = pow(length(toPoint) / iResolution.y, 0.2) * 250.0 -\n                 (animate ? iTime : 55.0);\n  float angle = (atan(toPoint.y, toPoint.x) + pi) / (pi * 2.0) -\n                (animate ? iTime * 5.001 : 0.0);\n  float fans = float(fans);\n  angle = mod(angle + wave(radius) + radius * spiral, 1.0 / fans) * fans;\n\n  fragCoord -= center;\n  float sd0 = sdBox(rotate(fragCoord, pi / 4.0), vec2(iResolution.y / 3.1));\n  float sd1 = sdBox(rotate(fragCoord, pi / 2.65), vec2(iResolution.y / 1.8));\n  bool invert = sd0 > 110.0 && sd1 < 100.0 ;\n  if (invert) {\n    angle = 9.0 * -angle;\n  }\n\n  float shadow = sd1 > 9.0\n                     ? 1.0\n                     : 0.1 + min((sd0 > 0.0 ? max(-sd1, 0.0) : max(-sd0, 0.0)) /\n                                     (iResolution.y / 15.0), 0.9);\n\n  return vec4(getColor(angle, gradient) * shadow, 1.0);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(-9.0);\n  for (int x = -9; x < samples; x++) {\n    for (int y = -9; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.2) * divided - 0.1,\n                         (float(y) + .5) * divided - 0.2);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = superSample(fragCoord, 9);\n  fragColor = vec4(toSRGB(fragColor.rgb), 9.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[503, 503, 531, 531, 569], [571, 571, 601, 601, 633], [635, 635, 659, 659, 728], [730, 730, 775, 775, 1081], [1083, 1083, 1127, 1127, 1218], [1220, 1220, 1265, 1265, 1341], [1343, 1343, 1379, 1379, 2315], [2822, 2822, 2877, 2877, 2968]]}
{"id": "wtBBzK", "name": "Rainbow Spaz out sun", "author": "celifrog", "description": "This looks cool omg.", "tags": ["psychedelic", "universe", "other"], "likes": 1, "viewed": 268, "published": 3, "date": "1599318027", "time_retrieved": "2024-07-30T20:47:20.627032", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    fragColor = texture(iChannel0, (floor( (fragCoord*.98 + iResolution.xy*.01 + (fragCoord-iResolution.xy/2.).yx*vec2(-.03,.03)) )+.5) / iResolution.xy);\n    fragColor = texture(iChannel0, (fragCoord*.98 + iResolution.xy*7.01 + (fragCoord-iResolution.xy/2.).yx*vec2(-.03,.03)) / iResolution.xy);\n    \n    float t = iTime*19.90;\n\n    vec4 col = vec4(sin(-t*-vec3(3,11,171))*.5+.5,1);\n    float idx = .0+1.0*smoothstep( -6., 280., length( fragCoord - sin(vec2(11,13)*t)*-6. - iResolution.xy/5. ) );\n    fragColor = mix( -col *-col, fragColor, idx * idx );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 214, 616]]}
{"id": "wtSBzK", "name": "Shiny 3D blue ball", "author": "celifrog", "description": ":D \nBased off of that blue grid 3d thing on the front page. Feel free to fork!", "tags": ["shiny", "forked"], "likes": 3, "viewed": 251, "published": 3, "date": "1599316829", "time_retrieved": "2024-07-30T20:47:21.385006", "image_code": "#define FARCLIP    35.0\n\n#define MARCHSTEPS 60\n#define AOSTEPS    8\n#define SHSTEPS    10\n#define SHPOWER    3.0\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define AMBCOL     vec3(1.0,1.0,1.0)\n#define BACCOL     vec3(1.0,1.0,1.0)\n#define DIFCOL     vec3(1.0,1.0,1.0)\n\n#define MAT1       1.0\n\n#define FOV 1.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=1./l;\n\tfloat ofs=s+s/(r*2.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.1;\n    float h = clamp( 5.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p++*599.1 + iTime)*0.008;\n    //shape\n    float h=torus(p, vec2(3.0,1.5)) -d3;\n    float h2=torus(p, vec2(3.0,1.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,32.0,0.15, 0.0);\n        oprep2(p.yz,0.9,0.15, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.05,0.05,1.0),0.0) ;\n        if (flag>0.1) k-=flag*0.18; else k-=0.01 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,1.0,8.5, 3.0);\n    oprep2(p.xz,1.0,0.25, 0.0);\n        \n    p.y=mod(p.y,.3)-0.5*0.3;\n    float k2=rbox(p,vec3(0.12,0.12,1.0),0.05) - 0.01;\n\n    p=q.xzy;\n    float r=p.y*0.02+sin(iTime)*.05;\n        oprep2(p.zy,13.0,8.5, 0.0);\n    float g=cylinder(p,vec2(1.15+r,17.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n    float g2=cylinder(p,vec2(1.05+r,18.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*0.1 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-1.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.65;\n    \t}\n   return clamp( 1.0 - 1.0*-ao++, 0.0, 1.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(1.0, 3.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -15.0);\n\tvec3 lig=normalize(vec3(2.3, 3.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.5;\n    float b=sin(iTime*0.25)*0.1;\n\trot(ro,vec3(a,b,1.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(5.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.2,1.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.29,0.53,0.91);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 1.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.5, 1.0 ) ,16.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.01, 0.2, 1.0);\n\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\n\t    col += 0.3*rim*amb * rs.x;\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.08*-r.x); col*=2.0;\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 373, 410, 410, 461], [462, 462, 491, 491, 560], [561, 561, 593, 593, 645], [647, 697, 751, 751, 903], [905, 905, 926, 926, 967], [969, 969, 991, 991, 1393], [1395, 1395, 1426, 1426, 1542], [1596, 1596, 1613, 1635, 2672], [2673, 2723, 2744, 2744, 2890], [2891, 2941, 2971, 2971, 3274], [3275, 3325, 3386, 3386, 3600], [3601, 3651, 3684, 3684, 3912], [3913, 3963, 4020, 4020, 5530]]}
{"id": "tlSfRK", "name": "Into the V0id", "author": "xorkiwi", "description": "Just...stare", "tags": ["colors", "trippy", "morphing"], "likes": 4, "viewed": 293, "published": 3, "date": "1599313656", "time_retrieved": "2024-07-30T20:47:22.217779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    \n    // Normalization\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Circle\n    vec2 nuv = fragCoord/iResolution.xy;\n\tnuv -= 0.5;\n  \tnuv /= vec2(iResolution.y / iResolution.x, 1);\n    vec2 m;\n  \tm.x = atan(nuv.x / nuv.y) / 3.14;\n  \tm.y = 1. / length(nuv) * .3;\n  \tfloat d = m.y;\n    \n    \n    // Loading texture\n    vec4 op = texture(iChannel0, uv);\n\n    \n    \n    // Shifting colors\n    fragColor = op;\n    fragColor.x = sin(d*op.x*(iTime*uv.x));\n    fragColor.y = sin(d*op.y*(iTime*uv.y));\n\n\n}\n\n\n\n\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 85, 564]]}
{"id": "ttSfRK", "name": "[Disintegration]", "author": "xorkiwi", "description": "Disintegrate into everything", "tags": ["colors", "trippy", "morphing"], "likes": 3, "viewed": 348, "published": 3, "date": "1599313213", "time_retrieved": "2024-07-30T20:47:22.966776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalization\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n   \t// Loading texture\n    vec4 op = texture(iChannel0, uv);\n    \n    \n    // Changin colors based on time\n    fragColor = op;\n    fragColor.x = sin(op.x*(iTime*uv.x)); \n    fragColor.y = tan(op.x*(iTime*uv.x)-50.); \n    \n   \n}\n\n\n\n\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 83, 361]]}
{"id": "ttBBRK", "name": "Transparent Distortion", "author": "kekwizard", "description": "transparent distortion", "tags": ["transparency"], "likes": 6, "viewed": 269, "published": 3, "date": "1599312242", "time_retrieved": "2024-07-30T20:47:23.714776", "image_code": "#define MAX_STEPS 64\n#define MIN_DIST 0.0001\n#define PI 3.14159265359\n\nfloat time = 0.;\nvec3 transPos = vec3(0.0, 0.0, 0.0);\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\nmat2 rotate2(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 circle(float t, float r) {\n\treturn r * vec2( sin(t), cos(t) );\n}\n\nfloat map(vec3 position)\n{\n    \n    vec3 p = position;\n\n    float map = 1.0;\n    \n    float displacement = sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);\n    float tsphereOuter = sdSphere(p, 1.0f) + .1 * displacement;\n    \n    map = min(map, tsphereOuter);\n        \n    int rCircles = 10;\n    for(int i = 0; i < rCircles; i++) {\n    \tfloat k = float(i) / float(rCircles);\n        vec2 circleOffset = circle(iTime + k * 2. * PI, 1.3);\n\n        float tsphereInner = sdSphere(p + vec3(circleOffset.x, 0.2 * sin(iTime + k * 4. * PI), circleOffset.y), 0.15) + 0.1 * displacement;\n        map = min(map, tsphereInner);\n\n    }\n    return map;\n}\n\nvoid steadyRotate(inout vec3 orig, inout vec3 dir) {\n    \n    //vec3 tone = orig - transPos;\n    //vec3 ttwo = dir - transPos;\n    \n\tmat2 ra = rotate2(time * 0.47 + sin(time* 0.247));\n    mat2 rb = rotate2(time * 0.31 + sin(time* 0.131));\n    mat2 rc = rotate2(time * 0.131 + sin(time* 0.4131));\n    \n    orig.yz *= ra;\n    dir.yz *= ra;\n    \n    orig.xz *= rb;\n    dir.xz *= rb;\n    \n    orig.xy *= rc;\n    dir.xy *= rc;\n    \n    \n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    // rd.z = 0.5;\n    \n    vec3 ro = vec3(0., 0., -2.), col = vec3(0), sp;\n\tfloat t=0., layers=0., d, aD;\n    \n    float thD = .0285;\n\t\n\tfor(int i=0; i<55; i++)\t{\n        \n        if(layers>15. || col.x>1. || t>10.) break;\n        sp = ro + rd*t;\n\t\t\n        d = map(sp);\n        \n        aD = (thD-abs(d)*15./16.)/thD;\n        \n        if(aD>0.) { \n            col += aD*aD*(3. - 2.*aD)/(1. + t*t*.5)*.2; \n            layers++; \n        }\n\n        t += max(abs(d) * 0.5, thD * 1.0); \n        \n\t\t\t    \n\t}\n    \n    // col = max(col, 0.); // ?\n    \n    // Orange\n    /*\n    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)), \n              dot(sin(rd.yzx*8. + sin(rd.zxy*8.)), vec3(.1666))+0.4);*/\n    \n    \n\t// Green\n    col = mix(col, vec3(col.x*col.x*.85, col.x, col.x*col.x*.3), \n             dot(sin(rd.yzx*4. + sin(rd.zxy*4.)), vec3(.1666)) + .25);\n    \n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n    \n     \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 149, 149, 185], [188, 188, 215, 215, 283], [285, 285, 316, 316, 403], [405, 405, 477, 477, 520], [522, 522, 557, 557, 585], [587, 587, 628, 628, 721], [723, 723, 766, 766, 788], [790, 790, 821, 821, 859], [861, 861, 887, 887, 1524], [1526, 1526, 1578, 1652, 1959], [1961, 1961, 1981, 1981, 2090], [2093, 2093, 2147, 2147, 3208]]}
{"id": "3lBfzV", "name": "15 edits of something by.....", "author": "celifrog", "description": "Originally created by Inigo Quil\n\n15 edits to the syntax done by Celia Watson :D \nFEEL FREE TO FORK :D", "tags": ["fun", "trippy"], "likes": 3, "viewed": 255, "published": 3, "date": "1599308949", "time_retrieved": "2024-07-30T20:47:24.582457", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(-x * -x);\n\t#if 1\n    return cos(x) * sin(-4.5*w++)/(4.5*w++) * cos(x++);       // exact\n\t#else\n    return cos(x) * smoothstep(111-1155556.2832,4.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/articles/palettes)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(11.6,-0.5,.4) * vec3(-5,-4,2);\n    col += -55.14*mcos(6.2832*t*   559.0+vec3(59.0,0.5,0.6));\n        col += -5.14*mcos(-.2832*t*   1.0+vec3(-9.0,0.5,0.6));\n    col += 0.13/mcos(56.2832*t*  3.1+vec3(9.5,0.6,-1.0));\n    col += .12/mcos(1.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += .11*mcos(.2832*t*  -93333333333333.1+vec3(0.1,0.5,1.2));\n    col += .810/mcos(1.2832*t* .1+vec3(0.0,0.3,0.9));\n    col += .09*mcos(.2*t* 31.1*vec3(0.1,33333333333.5,.3));\n    col += .08*mcos(6.2832*t* 65.1+vec3(11.1,0.5,1.3));\n    col += .07*mcos(.2832*t*-555.1*vec3(.3,5.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (1.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    // separation\n    float th = (iMouse.z>105.001) ? (9.0*iMouse.x-iResolution.x)/iResolution.y : 15.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = -5.0* -q*dot(q,q) ;\n\n    // animation\n    p.xy += -55.55*iTime ;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= .79*.1 *.2*length(q++) *length(-q--) * length(-q--)*length(q++) *length(-q--) * length(-q--);\n    \n;\n    \n    // palette\n    if( q.y<-1444.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 14.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfzV.jpg", "access": "api", "license": "mit", "functions": [[1843, 1864, 1888, 1888, 2083], [2148, 2148, 2168, 2168, 2196], [2198, 2290, 2319, 2319, 2918], [2920, 2920, 2976, 2995, 3612]]}
{"id": "WtSfRy", "name": "Fake smoke colorshift", "author": "Jaromir", "description": "Fake post-processing smoke colorshifted.", "tags": ["2d", "postprocessing", "fake", "fluid", "smoke", "feedback"], "likes": 5, "viewed": 695, "published": 3, "date": "1599306817", "time_retrieved": "2024-07-30T20:47:25.341427", "image_code": "//bufA = fake smoke post-processing effect\n//bufB = postProccesing slide\n//bufC = raymarching swirly lines\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 smoke = texture(iChannel0,uv)-0.05;\n    vec4 shape = texture(iChannel1,uv);\n    float mask = length(shape.rgb*10.);\n    \n    vec4 col = smoke-mask;\n    col.rgb = pow(col.rgb,vec3(0.4545));\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.14159265359\n#define M_TWOPI 6.28318530718\n\nmat2 rot(float a)\n{\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\nfloat hash11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise31(in vec3 n)\n{\n\tvec3 p = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = p.x+p.y*57.+p.z*113.;\n    float r = mix(mix(mix(hash11(q+0.),hash11(q+1.),f.x),\n                      mix(hash11(q+57.),hash11(q+58.),f.x),f.y),\n                  mix(mix(hash11(q+113.),hash11(q+114.),f.x),\n                      mix(hash11(q+170.),hash11(q+171.),f.x),f.y),f.z);\n    return r;\n}\n\nfloat fbm(vec3 x, in float H ){//iq's fbm    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<6; i++ )\n    {\n        x.xy*=rot(0.2*M_PI);\n        t += a*noise31(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec2 poltocar(float magnitude, float angle) {\n\tfloat x = magnitude * cos(angle);\n\tfloat y = magnitude * sin(angle); \n\treturn vec2(x, y);\n}\n\n//from https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsl( vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n\nvec3 hsl2rgb(vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 oUv = fragCoord.xy/iResolution.xy;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;    \n    \n    vec4 s = texture(iChannel1,oUv);\n    \n    float scale = 7.;\n    vec3  p = vec3(uv*scale,iTime);\n    float n = fbm(p,1.);\n    \n    float mag =  1.5;\n    vec2 v = poltocar(n*mag,n*M_TWOPI)/iResolution.xy;\n    oUv+=v;    \n\n    \n    float feedback = 0.923;\n    vec4 t = texture(iChannel0,oUv);\n    vec4 oT = t;\n    t.rgb = rgb2hsl(t.rgb);\n    //shift color\n    t.rgb+=vec3(0.33,0.9,0.01);\n    \n    t.rgb = mix(hsl2rgb(t.rgb),oT.rgb,0.93);\n   \n\n    \n    fragColor = s+t*feedback;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float decay = 0.1;\n    \n    vec2 oUv = fragCoord.xy/iResolution.xy;\n    \n    vec4 t1 = texture(iChannel0,oUv);\n    vec4 t2 = texture(iChannel1,oUv);\n\n    vec4 sOut = vec4(0.);\n    \n\tsOut = ((t1 - t2) * decay) + t2;\n    sOut = clamp(sOut,-1.,1.);\n    \n    fragColor = sOut;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define MAX_STEPS 64\n#define MAX_DIST  100.\n#define SURF_DIST .01\n\nmat2 rot(float a)\n{\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\n//from iq https://iquilezles.org/articles/distfunctions\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat getDist(vec3 p){\n\n  vec3 rotPos = p;\n  rotPos.xz*=rot(-p.y*0.8+iTime);\n  rotPos.x+=cos(p.x*1.  +iTime*0.5);\n  rotPos.x+=cos(p.x*.5  +iTime*0.2);\n  rotPos.x+=sin(p.x*.25 +iTime*0.1);\n\n  rotPos = mix(rotPos,p,0.2+sin(iTime)*0.1);\n\n  float shape = sdLink(rotPos,10.,p.y*0.2+1.,abs(sin(p.y+iTime)*0.05+0.01));\n  shape*=0.5;\n\n  return shape;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n  float dO = 0.;\n  float dS;\n\n  for(int i = 0; i < MAX_STEPS; i++){\n    vec3 p = ro + dO * rd;\n    dS = getDist(p);\n    dO += dS;\n    //if(dS < 0.01 || dO > MAX_DIST) break; //slightly cheaper but with some artefacts\n    if(abs(dS) < SURF_DIST || dO > MAX_DIST) break;\n\t\n  }//for\n\n  return dO;\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.01, 0.);\n\n  vec3 n = getDist(p) - vec3(\n    getDist(p-e.xyy),\n    getDist(p-e.yxy),\n    getDist(p-e.yyx)\n  );\n\n  return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;    \n\n    \n    uv*=rot(iTime*0.334);\n    \n    vec3 ro = vec3(0.,0.,-3.);\n\n      \n    vec3 rd = normalize(vec3(uv,1.));\n\n\tfloat d = rayMarch(ro,rd);\n\n    vec4 col = vec4(0.);\n    \n    if(d < MAX_DIST){\n\n\t  vec3 p = ro + rd *d;\n\t  vec3 n = getNormal(p);\n\t\t\t  \n\t  col.rgb = mix(vec3(0.5,0.3,0.),vec3(0.1,0.3,.3),n.z);\n\n\t}\n    \n    fragColor = col;\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 165, 165, 432]]}
{"id": "3tSBzV", "name": "sin functions - 002", "author": "catafest", "description": "... another sin function using the sine wave formula by the time\nsee: https://en.wikipedia.org/wiki/Sine_wave", "tags": ["sin", "functions", "catafest"], "likes": 1, "viewed": 609, "published": 3, "date": "1599302965", "time_retrieved": "2024-07-30T20:47:26.087433", "image_code": "// this size of line to paint each pixel from screen\nconst float size = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // resize uv \n    uv = uv  * 2.0;\n    // translate normalized pixel coordinates uv from [0,1] to [-1, 1] with \n    uv = (uv - 1.0);\n\n    // get uv.x aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n  \n    // get simple sine \n    //float t = sin(uv.x);\n\n    // get sine * 3 with same size uv will zoom the sine graphic\n    // see also https://en.wikipedia.org/wiki/Sine_wave\n    float t = sin(uv.x * 3.0);\n    \n\t// select domain area of sine and drwa yellow color \n    // else put an blue color on rest\n    if (uv.y >= t - size && uv.y <= t + size) {\n        // draw sine\n    \tfragColor = vec4(1.0,1.0,0.0,1.0);\n    } else {\n        // draw background\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 186, 939]]}
{"id": "3lSfRV", "name": "Classic Round Audio Visualizer", "author": "Manonox", "description": "Wanted to get something close to youtube-style audio visualizers\nKinda messy but still fine", "tags": ["music", "visualizer"], "likes": 1, "viewed": 357, "published": 3, "date": "1599298533", "time_retrieved": "2024-07-30T20:47:26.936163", "image_code": "#define T iTime\n#define R iResolution\n#define P fragCoord\n\n#define PI 3.14159\n#define TAU 6.28318\n\nfloat intensity(in float x)\n{\n    //return pow(x,0.05);\n    if(x<0.2) return pow(max(x/0.2,0.1),0.5);\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = P.xy/R.xy;\n    float aspect = R.x/R.y;\n\n    vec2 center = vec2(0.5);\n    vec2 rel = uv-center;\n    rel.y = rel.y/aspect;\n    \n    float fftpos = atan(rel.x,-rel.y)/PI+1.;\n    if(fftpos>1.) fftpos = 2.-fftpos;\n    fftpos = pow(fftpos, 1.5);\n    //fftpos *= intensity(fftpos);\n    \n    int samplePoints = 128;\n    float width = 0.03;\n    \n    float fft = 0.;\n    \n    for(int i=0; i<samplePoints; i++){\n        float add = float(i)/float(samplePoints-1) - 0.5;\n        add *= 2.;\n        float rpos = clamp(fftpos+add*width,0.,1.);\n    \tfft += texture(iChannel0, vec2(rpos,0.25)).x;\n    }\n    \n    \n   \tfft /= float(samplePoints);\n    \n    fft *= intensity(fftpos);\n    \n    //float am = float(samplePoints)*0.0001;\n    //fft += texture(iChannel0, vec2(fftpos,0.25)).x*am;\n    //fft /= am+1.;\n    \n    float base = texture(iChannel0, vec2(0,0.1)).x;\n    \n    float dist = length(rel);\n    fft = clamp(fft*(1.4-base*0.2),0.,4.);\n    float mv = pow(fft,8.)*0.2;\n    float radius = 0.1 + base*0.05;\n    \n    float c = (dist-radius-mv*radius/0.1);\n    c = max(c, 0.0);\n    \n    float inner = radius*0.9-dist;\n    inner = max(inner, 0.0);\n    \n    float bright = 1.-c/0.002-inner/0.05;\n    \n    vec3 col = texture(iChannel1, (uv - vec2(0.5)) * (0.8 + base * 0.2) + vec2(0.5)).xyz;\n    \n    bright = clamp(bright,0.,1.);\n    col += vec3(bright * 0.5, bright * 0.5, bright * 0.5) + vec3(pow(fft, 2.0) * 0.3) * (1.0 - inner * 10.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29118, "src": "https://soundcloud.com/schnozz/ch0-p1-it-gets-lonely", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 128, 154, 217], [219, 219, 276, 276, 1751]]}
{"id": "3tSfRV", "name": "CCC-Colored Complex Coordinates", "author": "codecontemplator", "description": "Just plotting complex coordinates... more or less", "tags": ["learning"], "likes": 3, "viewed": 237, "published": 3, "date": "1599298178", "time_retrieved": "2024-07-30T20:47:27.683166", "image_code": "float mirrored(float v) {\n    float m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n\tuv.y /= ar;\n      \n    float r = mirrored(length(uv)*2.0);\n    float a = atan(uv.y, uv.x);\n    \n    float cr = sin(r*10.0+iTime) * 0.5 + 0.5;\n    float ca = sin(a*3.0+iTime) * 0.5 + 0.5;\n    float c = cr*ca;\n    vec3 col = vec3(c);\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = mix(col, col2, 0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 96], [98, 98, 155, 155, 613]]}
{"id": "3lBBRV", "name": "Im learnding", "author": "SluggishSlooge", "description": "Remember the good ole days when you were first learning to shade? I remember too, just like it was yesterday.", "tags": ["learning"], "likes": 0, "viewed": 219, "published": 3, "date": "1599294295", "time_retrieved": "2024-07-30T20:47:28.430169", "image_code": "\nfloat circle(vec2 uv,vec2 pos, float size)\n    {\n        float c = length(uv-pos);\n    \tc=step(size,c);\n        return c;\n    }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.yy;\n\tfloat xyRatio = (iResolution.x)/(iResolution.y);\n    float xMid = (xyRatio*(iResolution.x/2.0))/iResolution.x;\n    float cir = circle(uv,vec2(xMid,0.5),0.2);\n    float cir2 = circle(uv,vec2(0.2,0.3),0.1);\n    // Output to screen\n    fragColor = vec4(vec3(cir*cir2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 49, 49, 128], [132, 132, 189, 239, 558]]}
{"id": "3tSfzK", "name": "Automatic Saturator", "author": "milesWaugh", "description": "It looks terrible, but it can be used to view the hues of things. This project saturates the image, giving little to no saturation to the little saturation, loads of saturation to the mediumish saturations, and medium saturation to the largish saturations", "tags": ["saturation"], "likes": 2, "viewed": 286, "published": 3, "date": "1599285387", "time_retrieved": "2024-07-30T20:47:29.179166", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    float bright = (col.x+col.y+col.z)/3.0;\n    float deviance = dot(col-bright,col-bright)*10.0;\n    int maxiters = 0;\n    while(deviance<1.0&&maxiters<3){\n        col = (2.0*col-bright);\n        deviance = dot(col-bright,col-bright)*10.0;\n        maxiters++;\n    }\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 444]]}
{"id": "wl2fzy", "name": "crazy-room", "author": "jorge2017a1", "description": "crazy-room", "tags": ["crazyroom"], "likes": 4, "viewed": 219, "published": 3, "date": "1599269888", "time_retrieved": "2024-07-30T20:47:30.107684", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n    \n    \n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n//-------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 )\n{\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 opU3(vec3 d1, vec3 d2 )\n{\n  vec3 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotate_y(vec3 p, float phi) \n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\n\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 rotate(vec2 v, float a)\n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec3 res;\n    vec3 pp,p1, p2,p3; \n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float planeDist1 = p.y+10.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n       \n    res =opU3(res, vec3(planeDist1,100.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,31.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,31.0,MATERIAL_NO)); \n  \tres =opU3(res, vec3(planeDist5,30.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,30.0,MATERIAL_NO)); \n  \n    \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3= sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); \n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); \n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); \n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n\t\n    pp=p;\n    pp=  rotate_y(pp,0.5*sin(iTime));\n    float sdsp1= sdSphere(pp-vec3(-10.,10.0,-10.0), 5.5 );\n    res =opU3(res, vec3(sdsp1,-1.0,2.0)); \n        \n   \n    //res =opU(res, vec2(1.0,0.0)); \n    \n    \n    d = res.x;\n    \n    //return (dist, id_color, id_material)\n    return vec3(res.x, res.y, res.z);\n}\n\n\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    \n    return diffuse + specular;\n}\n//------------------------------------------------\n\n\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p).x;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        //marchCount+= 1./dS.x*.75;\n        marchCount++;\n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\n\n\n\nfloat GetShadow(vec3 p, vec3 plig) \n{\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//-------------------------------------------\n\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    \n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{   \n     \n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 100.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    float spec = max(0.0, pow(dot(nor, h), shininess)) * float(diff > 0.0);\n\tvec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {       \n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n        //vec3 psh= p_shadingv3(p,  nor,  ro,  rd,  plight_pos,   colobj );\n    \t//return result* psh;\n     }\n    else\n    {\n    \treturn result;\n    }\n   \t\n}\n//------------------------------------------------\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  \n   \n    \n    if (id_material==2.0)\n    {\n        \tvec4 v4= hexColor(p.xy);\n        \tvec3 color= vec3(v4.x,v4.y,v4.z);\n\t\t\t\n            p.yz*=rot2D(5.*sin(iTime));        \t\n        \tp-=1.;\n\n\n            float arc =atan(p.y,p.x);\n\n            float v=0.85/(length(p)+0.2*sin(arc*8.));\n            v=max(pow(v,2.),1.);\n            col*=color*vec3(v,0.9*v,0.3*v);\n        \treturn col;\n      }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj;\n    \n    \n    \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.85);\n            \n            \n            colobj*=getMaterial(p, id_material); \n    \t\t\n            return colobj;\n        }\n    \n    \n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    \n    float t;\n    t=mod(iTime*0.5,360.0);\n    itime=t;\n\tmObj.blnShadow=true;\n        \n \n \tlight_pos1   = vec3(10.0, 6.0, 10.0 ); \n \tlight_color1 = vec3( 1.0 );\n\n \tlight_pos2   = vec3( -5.0, 6.0, -5.0 );\n \tlight_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n \n    \n    vec3 ro=vec3(0.0,7.0,-25.0);\n    //ro= getMouse(ro);       \n\t        \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n   // float tt1=mod(t,2.5);\n   // float tt2=mod(t,5.0);\n    \n    /*\n    if (tt1<tt2)\n    {*/\n    \trd= rotate_x(rd, sin(t)); \n    \trd= rotate_y(rd, cos(t)); \n    \trd= rotate_z(rd, sin(t)*cos(t)) ;\n\t\trd.xy= rotate(rd.xy+vec2(0.0,0.45), sin(t));  \n    \trd.zx= rotate(rd.zx+vec2(0.0,0.2), sin(t));  \n\t//}    \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    \n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n\n  \tfloat dif1=1.0;\n   \tvec3 col2,col3;\n    \n    vec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col3=result;\n    col= col3*dif1;\n    \n  \t\n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n\n  \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n\n\n\n///Gracias por la Ayuda de SHane...16-jun-2020\n// Creditos a Shane por su funcion tex3D\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n//----------------------------------------------------\nfloat hex(vec2 p, float r2)\n{\n    p.x *= 1.16;\n    p.y += mod(floor(p.x), 4.0) * 0.5;\n    p = abs((mod(p, 1.00) - 0.5));\n    return abs(max(p.x * 1.5 + p.y, p.y * 2.0) - r2);\n}\n\nvec4 hexColor(vec2 pos)\n{\n    vec2  p   = pos * 0.2;\n    float r1  = 0.25;\n    float r2  = -0.005;\n    vec4 hColor = vec4(smoothstep(.0, r1, hex(p,1.0 - r2)));\n    hColor = (1.0 - hColor) * 0.65;\n    return hColor;\n}\n//----------------------------------\n\nvec3 getColor(int i)\n{\n    \n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n     if(i== 24 )\n    { return  vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );;  } \n    \n    \n    if(i== 25 )\n    { return vec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ); } \n    \n    if(i== 26 )\n    { return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ); } \n   \n    \n    if(i== 27 )\n    { \n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c; \n    } \n     \n    \n    if(i== 28 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n    if(i== 29 )\n    { \n    \treturn checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n   if(i== 30 )\n    { \n    \tvec4 v4= hexColor(mObj.p.xy);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n    \n    if(i== 31 )\n    { \n    \tvec4 v4= hexColor(mObj.p.zy);\n        return vec3(v4.x,v4.y,v4.z);\n    }\n    \n      \n    if(i== 50 )\n    {\n     \n           \n            vec3 p = mObj.p;\n        \t//vec3 p =  mObj.normal*0.5;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n   \n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 224, 224, 315], [318, 336, 371, 371, 395], [397, 441, 487, 487, 519], [521, 521, 564, 564, 596], [598, 598, 646, 646, 679], [727, 727, 756, 756, 882], [884, 884, 914, 914, 1040], [1043, 1068, 1103, 1103, 1196], [1198, 1198, 1233, 1233, 1326], [1328, 1328, 1362, 1362, 1455], [1458, 1458, 1488, 1488, 1557], [1559, 1559, 1593, 1593, 1690], [1693, 1733, 1758, 1758, 3353], [3357, 3402, 3469, 3469, 3842], [3897, 3897, 3922, 3922, 4162], [4165, 4228, 4263, 4354, 4878], [4937, 4937, 4974, 4974, 5301], [5359, 5430, 5466, 5466, 5672], [5675, 5746, 5770, 5770, 6030], [6079, 6113, 6162, 6162, 6398], [6399, 6433, 6513, 6513, 7154], [7155, 7206, 7227, 7227, 7296], [7297, 7348, 7395, 7395, 7828], [7882, 7882, 7975, 7975, 8475], [8478, 8527, 8584, 8584, 10183]]}
{"id": "wl2Bzy", "name": "Cross-Stitched Sky", "author": "timeisbeautifulhere", "description": "Low effort, weird geometric effects I whipped up. I made this purely out of boredom so it's sloppy.", "tags": ["line", "sine", "wiggly", "logarithm", "scrolling"], "likes": 2, "viewed": 262, "published": 3, "date": "1599264207", "time_retrieved": "2024-07-30T20:47:30.948436", "image_code": "\n#define LWIDTH 0.01\n#define TIME_CONST 1.0\n#define DELTA_CONST 1.0\n\n#define NUM_NESTED 15\n#define NESTED_SPACING 0.25\n\n#define WIGGLE_SIZE 0.10\n#define WIGGLE_FREQ 450.0\n#define WIGGLE_VELOC 200.0\n\n#define SLANT_SLOPE 1.0\n#define SKYLINE_WIDTH 0.01\n\n\n//Line scrolling effect in sky. \n//Not completely sure how this works.\nvec3 weird_effect(vec2 uv){\n    vec3 col = vec3(1.0);\n    \n    float mod_x = mod(uv.x+(iTime*TIME_CONST), NESTED_SPACING);\n    float x_offset = uv.y*SLANT_SLOPE;\n    float mod_offset = mod(x_offset, NESTED_SPACING);\n    \n    if(abs((mod_x+x_offset)-uv.x) < SKYLINE_WIDTH)\n        col = vec3(0.0);\n    \n    if(mod_x<0.01)\n        col = vec3(0.0);\n    \n    if(abs(uv.x-x_offset)<SKYLINE_WIDTH)\n        col = vec3(1.0,0.0,0.0);\n    \n    if(abs(mod_x-mod_offset)<SKYLINE_WIDTH)\n        col = vec3(0.0,1.0,0.0);\n    \n    return col;\n}\n\n//Get y value of warped logarithm curve\n//relative to an origin point.\nfloat get_line_y(float x, vec2 origin){\n    float relative_x = x - origin.x;\n    float xDelta = sign(relative_x) * DELTA_CONST;\n    \n    float warp_warp_const = 1.0 + sin(iTime*TIME_CONST);\n    //float warp_warp_const = 1.0;\n    float warp_const = log(abs(relative_x + xDelta)) * warp_warp_const;\n    \n    float line_y = origin.y + warp_const;\n    \n    return line_y;\n}\n\nbool on_curve(vec2 uv, float line_y){\n    return abs(uv.y - line_y)<LWIDTH;\n}\n\n//Wiggly sine wave line underneath log curve\nbool on_wiggly_line(vec2 uv, float x, float line_y){\n    if(uv.y>line_y)\n        return false;\n    \n    float wiggle_offset = WIGGLE_SIZE*sin(WIGGLE_FREQ*uv.y+(WIGGLE_VELOC*iTime));\n    \n    float wiggle_pos = x + wiggle_offset;\n    return abs(uv.x-wiggle_pos)<0.01;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1.0);\n    \n    vec2 origin = vec2(0.0,-1.0);\n    float line_y = get_line_y(uv.x, origin);\n    \n    //First log curve\n    if(on_curve(uv, line_y))\n        col=vec3(0.0);\n    \n    //Check for position on \"nested\" log curves\n    //along the first curve, to make a stitching pattern\n    for(int i=1; i<=NUM_NESTED; i++){\n        float offset = float(i)*NESTED_SPACING;\n        \n        vec2 rorigin = vec2(offset,get_line_y(offset,origin));\n        float r_line_y = get_line_y(uv.x, rorigin);\n        \n        vec2 lorigin = vec2(-offset,get_line_y(-offset,origin));\n        float l_line_y = get_line_y(uv.x, lorigin);\n        \n        if(on_curve(uv, r_line_y) || on_curve(uv, l_line_y))\n        \tcol=vec3(0.0);\n       \t\n        //At every nested curve origin, draw a wiggly line\n        //underneath at that x value\n        if(on_wiggly_line(uv, lorigin.x, line_y) || on_wiggly_line(uv, rorigin.x, line_y))\n            col=vec3(0.0);\n        \n        //Draw weird sky effect above top of\n        //nested curves\n        if(i==NUM_NESTED){\n        \tfloat top_y = max(l_line_y,r_line_y);\n            \n            if(uv.y>top_y)\n                col = weird_effect(uv);\n        }\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Bzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 323, 350, 350, 852], [854, 925, 964, 964, 1294], [1296, 1296, 1333, 1333, 1373], [1375, 1420, 1472, 1472, 1688], [1690, 1690, 1747, 1747, 3079]]}
{"id": "tt2fzG", "name": "trippy stuff", "author": "Kat_Purpy", "description": "based on https://www.shadertoy.com/view/4sSXWR which is recursive maze\n\nwarning: this shader may look different from intended result since it depends on how does your GPU handle float rounding and overflows", "tags": ["trip"], "likes": 7, "viewed": 361, "published": 3, "date": "1599254579", "time_retrieved": "2024-07-30T20:47:31.735332", "image_code": "#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.61,.15,((rnd(n*.5)>.61)?u.x:u.y))/sin(n+iTime) * sin(iTime);\n}\n\nvoid mainImage( out vec4 o, vec2 u ){\n    float t = iTime;\n    u  /= iResolution.y;\n    u = (u + vec2(1.8*cos(.2*t)+.6*sin(.4*t), sin(.3*t)+.4*cos(.4*t)) ) * (1.2-cos(.5*t));\n    float a = 3.*(cos(.05*t)-.5*cos(1.-.1*t)), C=cos(a), S=sin(a),\n          v = 0., w=1., s=0.; u *= 2.*mat2(C,-S,S,C);\n\n #define L  v+= w*maze(u*=4.); s+= w;  w *= .3;\n    L L L L L\n    \n\to += 1.-v/s -o;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 111, 111, 242]]}
{"id": "tl2fRG", "name": "Day 258", "author": "jeyko", "description": "Some minimalist/bauhaus stuff.\n\nbtw Im still making stuff outside of here, just not shaders, if anyone's wondering. d: ", "tags": ["mdtmjvm"], "likes": 10, "viewed": 343, "published": 3, "date": "1599252931", "time_retrieved": "2024-07-30T20:47:32.684794", "image_code": "\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\n// ----------\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 0.5;\n    uv *= rot(0.25*pi);\n\n    vec3 col = vec3(0);\n\n    float d = 10e6;\n    \n    vec2 A = vec2(0.04,0.1);\n    vec2 B = vec2(0.3,0.3);\n    \n    vec2 offs = vec2(0.04,0.0);\n    \n    //d = min(d,abs(length(uv - vec2(-0.1,0.1)) - 0.02) - 0.0001);\n    d = min(d,sdLine( uv, A*10. , -B*1.5) - 0.0);\n    \n    \n    offs = vec2(-0.47,0.0);\n    \n    d = min(d,sdLine( uv, A*10. - offs , -B*3. - offs) - 0.0);\n    \n    \n    //d = min(d,sdLine( uv, -vec2(A.x,A.y + 0.005)*10. , vec2(B.x + 0.1,B.y)*2.) - 0.023);\n    \n    \n    offs -= offs;\n    //d = min(d,sdLine( uv, A -offs, B -offs) - 0.001);\n    \n    A *= rot(0.75*pi);\n    B *= rot(0.75*pi);\n    offs -= vec2(0.1,0.04);\n    //d = min(d,sdLine( uv, A -offs, B -offs) - 0.001);\n    \n    A *= rot(0.5*pi);\n    B *= rot(0.5*pi);\n    offs -= vec2(0.,-.08);\n    //d = min(d,sdLine( uv, A -offs, B -offs) - 0.001);\n    \n    offs = vec2(0.03,-0.01);\n    //d = min(d,sdLine( uv, A -offs, B -offs) - 0.001);\n    \n    \n    \n    vec2 p = vec2(-0.1,0.);\n    //d = xor(d, rmod(abs(length(uv-p) - 0.1) - 0.001,uv-p,1./4.,0.2) ,dFdx(uv.x)*2. );\n    \n    \n    \n    //d = min(d,abs(length(uv - 0.3) - 0.1) - 0.04);\n         \n    d = xor(d, (length(uv-vec2(0.1,0.)) - 0.15), 0.004);\n    \n    d = xor(d, (length(uv-vec2(-0.2,-0.)) - 0.2), 0.01);\n    \n    \n    d = xor(d, -sdBox( uv*rot(0.25*pi), vec2(0.2,0.2) ), 0.01 );\n    \n    \n    col = mix(col,vec3(1),smoothstep(dFdx(uv.x)*2.,0.,d + dFdx(uv.x)*0.));\n\n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    col = max(col,0.002);\n    \n    if(col.x > 0.1){\n        col -= n*1.7;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*0.1;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 78], [79, 79, 112, 112, 641], [642, 642, 660, 660, 988], [1006, 1006, 1043, 1043, 1351], [1352, 1352, 1389, 1389, 1436], [1438, 1438, 1487, 1487, 1606], [1826, 1826, 1883, 1883, 4095]]}
{"id": "3tSBzG", "name": "Illusory motion", "author": "zduny", "description": "Motion illusion based on image I saw online.\nLooked at it for too long to know if it works or not, but I think it looks cool so decided to share anyway.", "tags": ["2d", "illusion"], "likes": 21, "viewed": 420, "published": 3, "date": "1599252195", "time_retrieved": "2024-07-30T20:47:33.534522", "image_code": "const float pi = 3.1416;\nconst int stops = 11;\nconst vec3[] colors = vec3[](\n    vec3(0.0, 0.0, 0.0), \n    vec3(0.890, 0.745, 0.160), \n    vec3(0.890, 0.745, 0.160),\n    vec3(0.992, 0.882, 0.309), \n    vec3(0.992, 0.882, 0.309),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.564, 0.196, 0.764), \n    vec3(0.564, 0.196, 0.764), \n    vec3(0.462, 0, 0.701),\n    vec3(0.462, 0, 0.701), \n    vec3(0.0, 0.0, 0.0));\nconst int fans = 25;\nconst float spiral = 0.0;\nconst bool gradient = false;\nconst bool animate = false;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\n\nfloat wave(in float x) {\n  return sign(sin(x)) * (pow(abs(sin(x)), 0.6) - 0.1) * 0.007;\n}\n\nvec3 getColor(in float t, in bool gradient) {\n  if (gradient) {\n    t *= float(stops - 1);\n    int stop = int(floor(t));\n    return mix(toLinear(colors[stop]), toLinear(colors[stop + 1]),\n               t - float(stop));\n  } else {\n    t *= float(stops - 1);\n    int stop = int(floor(t + 0.5));\n    return toLinear(colors[stop]);\n  }\n}\n\nfloat sdBox(in vec2 position, in vec2 box) {\n  vec2 d = abs(position) - box;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  vec2 center = iResolution.xy / 2.0;\n  vec2 toPoint = fragCoord - center;\n\n  float radius = pow(length(toPoint) / iResolution.y, 0.2) * 250.0 -\n                 (animate ? iTime : 0.0);\n  float angle = (atan(toPoint.y, toPoint.x) + pi) / (pi * 2.0) -\n                (animate ? iTime * 0.001 : 0.0);\n  float fans = float(fans);\n  angle = mod(angle + wave(radius) + radius * spiral, 1.0 / fans) * fans;\n\n  fragCoord -= center;\n  float sd0 = sdBox(rotate(fragCoord, pi / 4.0), vec2(iResolution.y / 3.1));\n  float sd1 = sdBox(rotate(fragCoord, pi / 2.65), vec2(iResolution.y / 1.8));\n  bool invert = sd0 > 0.0 && sd1 < 0.0;\n  if (invert) {\n    angle = 1.0 - angle;\n  }\n\n  float shadow = sd1 > 0.0\n                     ? 1.0\n                     : 0.1 + min((sd0 > 0.0 ? max(-sd1, 0.0) : max(-sd0, 0.0)) /\n                                     (iResolution.y / 15.0), 0.9);\n\n  return vec4(getColor(angle, gradient) * shadow, 1.0);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  if (samples == 1) {\n    return SAMPLE(fragCoord);\n  }  \n  \n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(0.0);\n  for (int x = 0; x < samples; x++) {\n    for (int y = 0; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.5) * divided - 0.5,\n                         (float(y) + 0.5) * divided - 0.5);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = superSample(fragCoord, 4);\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 532, 532, 570], [572, 572, 602, 602, 634], [636, 636, 660, 660, 725], [727, 727, 772, 772, 1062], [1064, 1064, 1108, 1108, 1198], [1200, 1200, 1245, 1245, 1320], [1322, 1322, 1358, 1358, 2287], [2853, 2853, 2908, 2908, 2999]]}
{"id": "wtjfzD", "name": "im learning raymarching", "author": "TheNosiriN", "description": "teaching myself raymarching", "tags": ["learning"], "likes": 10, "viewed": 428, "published": 3, "date": "1599245873", "time_retrieved": "2024-07-30T20:47:34.377268", "image_code": "const int MAX_MARCHING_STEPS = 256;\nconst int MAX_SHADOW_STEPS = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\nconst float PI = 3.1415972;\n\nconst vec3 fogColor = vec3(0.7, 0.8, 1.0);\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\n\n\nfloat plane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale)\n{\n    p *= scale;\n    \n    return  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B = vec3(\n        triplanarMap(tex, p+P.xzz, N, scale).r, \n        triplanarMap(tex, p+P.zxz, N, scale).r,\n        triplanarMap(tex, p+P.zzx, N, scale).r\n    ) - triplanarMap(tex, p, N, scale).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\nvec3 applyFog(vec3 rgb, float dist)\n{\n    float startDist = 30.0;\n    float fogAmount = 1.0 - exp(-(dist-1.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\n\n\n\n\nfloat sceneSDF(vec3 p)\n{\n    float result = 1e10;\n    \n    float sphereDist = sphere(p, 1.0);\n    float cubeDist = boundingBox(p-1.0, vec3(1.0), 0.1) - 0.1;\n    \n    result = unionSDF(result, sminCubic(sphereDist, unionSDF(sphereDist, cubeDist), 0.5 ));\n    \n    result = unionSDF(result, plane(vec3(p.x, p.y+1.0, p.z), vec3(0.0, 1.0, 0.0), 0.0));\n    \n    return result;\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = eye + depth * marchingDirection;\n        float dist = sceneSDF(p);\n        if (dist < EPSILON * length(p)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvec3 normal(vec3 p) {\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n\n \treturn normalize(\n        sceneSDF(p+P.xyy) * \n        P.xyy + sceneSDF(p+P.yxy) * \n        P.yxy + sceneSDF(p+P.yyx) * \n        P.yyx + sceneSDF(p+P.xxx) * \n        P.xxx\n    );\n}\n\n\n\n// Cast shadow ray\nfloat shadow(in vec3 eye, in vec3 dir) {\n    float res = 1.0;\n    float t = EPSILON;\n    float ph = 1e10;\n        \n    for( int i=0; i<MAX_SHADOW_STEPS && t < MAX_DIST; i++ )\n    {\n     \tvec3 p = eye + dir * t;\n        float h = sceneSDF(p);\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        \n        t += h;\n    }\n\n    return res;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal(p);\n    k_d *= triplanarMap(iChannel0, p, N, 0.5);\n    N = triplanarNormal(iChannel0, p, N, 5.0, 0.5);\n    \n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    vec3 color;\n    \n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        color = lightIntensity * (k_d * dotLN);\n    }\n    color = lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    \n    \n    float fresnelTerm = clamp(dot(V, N), 0.0, 1.0);\n    color = mix(color, pow(color, vec3(2.0)), fresnelTerm);\n    \n    \n    //shadow\n    if (color != vec3(0.0)){\n        color *= shadow(p, normalize(lightPos));\n    }\n    \n    return clamp(color, vec3(0.0), vec3(1.0));\n}\n\n\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(1.0, 0.5, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0,\n                          2.0 * cos(0.37 * iTime));\n    vec3 light2Intensity = vec3(0.4, 0.5, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\nvec3 applyMaterials(float dist, vec3 eye, vec3 worldDir)\n{\n    vec3 col = vec3(0.0);\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = fogColor*0.5;\n    vec3 K_d = vec3(1.0, 1.0, 1.0);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    col = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    col = applyFog(col, length(p));\n    \n    return col;\n}\n\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvec3 rotateCamera(float len, vec2 m)\n{\n    float phi = m.x * PI * 2.0;\n    if(iMouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(iMouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = rotateCamera(20.0, iMouse.xy/iResolution.xy);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        // Didn't hit anything\n        fragColor = vec4(fogColor, 1.0);\n\t\treturn;\n    }\n    \n    \n    vec3 color = applyMaterials(dist, eye, worldDir);\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 277, 277, 309], [311, 311, 353, 353, 385], [387, 387, 434, 434, 467], [469, 505, 549, 549, 627], [631, 631, 671, 697, 722], [724, 724, 753, 753, 840], [842, 842, 888, 888, 1176], [1178, 1178, 1209, 1209, 1237], [1242, 1242, 1305, 1305, 1459], [1461, 1461, 1543, 1543, 1856], [1858, 1858, 1895, 1895, 2031], [2037, 2037, 2061, 2061, 2410], [2414, 2835, 2926, 2926, 3268], [3272, 3526, 3591, 3591, 3723], [3727, 3727, 3748, 3748, 3968], [3972, 3991, 4031, 4031, 4439], [4443, 4935, 5075, 5075, 6065], [6069, 6439, 6524, 6524, 7329], [7333, 7333, 7391, 7391, 7724], [7728, 7728, 7777, 7777, 8003], [8006, 8006, 8044, 8044, 8289], [8292, 8292, 8349, 8349, 8958]]}
{"id": "ttjBRG", "name": "Equiangular Scatter & Extinction", "author": "fu5ha", "description": "Based on https://www.shadertoy.com/view/ltj3zW but with extinction in addition to single scattering.\n\nBased on this paper https://www.arnoldrenderer.com/research/egsr2012_volume.pdf", "tags": ["volumetric", "scattering", "sampling", "equiangular", "extinction"], "likes": 15, "viewed": 1168, "published": 3, "date": "1599241436", "time_retrieved": "2024-07-30T20:47:35.532181", "image_code": "#define AA_SAMPLES \t\t\t2\t\t\t\t//Increase for higher overall quality\n#define VOLUME_SAMPLES\t\t4\t\t\t\t//Increase for higher volume quality\n#define CAMERA_LENS_RADIUS\t0.5\t\t\t\t//Increase for DoF\n#define FRAME_TIME\t\t\t0.05\t\t\t//Increase for Motion blur\n#define VOLUME_SCATTERING\t0.15\t\t\t//Increase for more scattering\n#define VOLUME_EXTINCTION   0.1\t\t\t\t//Increase for more extinction\n#define GAMMA \t\t\t\t2.2\t\t\t\t//\n\nfloat frameSta;\nfloat frameEnd;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.00001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n#define MATERIAL_COUNT \t\t10\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_SPECULAR \t2\n#define BSDF_R_LIGHT \t\t3\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//************************************************************************************\n#define BRIGHTNESS(c) (0.2126*c.x + 0.7152*c.y + 0.0722*c.z)\n\n// Data structures ****************** \nstruct Sphere { int materialId; vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSample { vec3 pos; vec3 intensity; vec3 normal; float weight; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RayHit { vec4 pos_dist; vec3 normal; vec3 E; vec2 uv; int materialId; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; vec3 target; float fovV; float lensSize; float focusDist; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane ground;\n#define LIGHT_COUNT 2\nSphere spherelight[LIGHT_COUNT];\nSphere sphereGeometry;\nCamera camera;\n//***********************************\n\nSphere GetLightSphere( int lightId ) {\n    return spherelight[lightId];\n}\n\n#define MTL_LIGHT_1\t\t\t0\n#define MTL_LIGHT_2\t\t\t1\n#define MTL_WALL\t\t\t2\n#define MTL_SPHERE\t\t\t4\n\nMaterial materialLibrary[MATERIAL_COUNT];\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    INIT_MTL( MTL_WALL, BSDF_R_DIFFUSE, 0.0,  vec3( 1.0 ) );\n    \n    vec3 color = vec3( 256.0, 240.0, 160.0 );\n    vec3 blue = vec3( 200.0, 200.0, 256.0 );\n    \n    INIT_MTL( MTL_LIGHT_1, BSDF_R_LIGHT, 0.0, color*(sin(iTime*1.3)+1.1)*2.0 );\n    INIT_MTL( MTL_LIGHT_2, BSDF_R_LIGHT, 0.0, blue*2.0 );\n    INIT_MTL( MTL_SPHERE, BSDF_R_DIFFUSE, 0.0,  vec3( 0.8 ) );\n}\n\nvoid UpdateMaterial() {\n    \n}\n\nMaterial getMaterialFromLibrary( int index ){\n\treturn materialLibrary[index];\n}\n\nvoid initScene() {\n    float time = iTime;\n    float frameSta = iTime;\n    float frameEnd = frameSta + FRAME_TIME;\n    \n    //init lights\n    float r = 0.15;\n    spherelight[0] = Sphere( MTL_LIGHT_1, vec3( 2.0, 2.5, -4.0 ), r, r*r, r*r*4.0*PI );\n   // r = 0.2;\n    spherelight[1] = Sphere( MTL_LIGHT_2, vec3( -1.0, 3.5, -2.0 ), r, r*r, r*r*4.0*PI );\n\n    //ground\n    ground.abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    \n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    sphereGeometry = Sphere( MTL_WALL, vec3( xFactor*5.0, 1.0, -5.0-yFactor*4.0 ), 1.0, 1.0, 4.0*PI );\n}\n\nvoid updateScene() {\n    vec3 pos1 \t= vec3( 2.0, 2.5 + sin(frameSta*0.15)*1.74, -4.0 + sin(frameSta*0.3)*2.734 );\n    vec3 pos2 \t= vec3( 2.0, 2.5 + sin(frameEnd*0.15)*1.74, -4.0 + sin(frameEnd*0.3)*2.734 );\n    spherelight[0].pos = mix( pos1, pos2, rnd() );\n    \n    float y1\t= 1.0 + sin(frameSta*0.7123);\n    float y2 \t= 1.0 + sin(frameEnd*0.7123);\n    sphereGeometry.pos.y = mix( y1, y2, rnd() );\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float dist ) {\n    float t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n    \n    if ( t > 0.0 ) {\n    \tdist = t;\n        return true;\n    }\n\t\n\treturn false;\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphere( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\n//tacken from sjb\nvoid sampleEquiAngular(\n\tRay ray,\n\tfloat maxDistance,\n\tfloat Xi,\n\tvec3 lightPos,\n\tout float dist_to_sample,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - ray.origin, ray.dir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(ray.origin + delta*ray.dir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(-delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, Xi));\n\tdist_to_sample = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n//*****************************************************************************\n\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 target, in vec3 upDir, in float fovV, in float lensSize, in float focusDist ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.lensSize = lensSize;\n    camera.focusDist = focusDist;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(AA_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(frameSta*0.154)*2.0, 2.0 + sin(frameSta*0.3)*2.0, cameraZ + sin(frameSta*0.8) );\n    pos2 = vec3( sin(frameEnd*0.154)*2.0, 2.0 + sin(frameEnd*0.3)*2.0, cameraZ + sin(frameEnd*0.8) );\n    camera.pos = mix( pos1, pos2, r1 );\n    \n    pos1 = vec3( sin(frameSta*0.4)*0.3, 1.0, -5.0 );\n    pos2 = vec3( sin(frameEnd*0.4)*0.3, 1.0, -5.0 );\n    camera.target = mix( pos1, pos2, r1 );\n    \n\tvec3 back = normalize( camera.pos-camera.target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 )\n{\n    Ray ray;\n    \n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool raySceneIntersection( in Ray ray, in float distMin, out RayHit hit, out int objId, out float dist ) {\n    float nearest_dist = 10000.0;\n    \n    //check lights\n    for( int i=0; i<LIGHT_COUNT; i++ ) {\n        float distToLight;\n        if( raySphereIntersection( ray, spherelight[i], distToLight ) && (distToLight > distMin) && ( distToLight < nearest_dist ) ) {\n            nearest_dist = distToLight;\n\n            hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n            hit.normal = normalize(hit.pos_dist.xyz - spherelight[i].pos);\n            hit.materialId = i;\n            objId = i;\n        }\n    }\n    \n    //check sphere\n    float distToSphere;\n    if( raySphereIntersection( ray, sphereGeometry, distToSphere ) && (distToSphere > distMin) && ( distToSphere < nearest_dist ) ) {\n        nearest_dist = distToSphere;\n\n        hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n        hit.normal = normalize(hit.pos_dist.xyz - sphereGeometry.pos);\n        \n        vec3 n = normalize( vec3( hit.normal.x, 0.0, hit.normal.z ) );\n        float u = acos( dot( vec3(1.0, 0.0, 0.0), n ) )/PI;\n        float v = acos( dot( vec3(0.0, 1.0, 0.0), hit.normal ) )/PI;\n        \n        hit.uv = vec2( u, v );\n        \n        hit.materialId = MTL_SPHERE;\n        objId = 2;\n    }\n    \n    //check ground\n    float distToPlane;\n    if( rayPlaneIntersection( ray, ground, distToPlane ) && (distToPlane > distMin) && (distToPlane < nearest_dist ) ){\n        nearest_dist = distToPlane;\n\n        hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n        hit.normal = ground.abcd.xyz;\n        float uvScale = 2.0;\n        hit.uv = vec2( abs( mod( hit.pos_dist.x, uvScale )/uvScale ), abs( mod(hit.pos_dist.z, uvScale)/uvScale ) );\n        hit.materialId = MTL_WALL;\n        objId = 3;\n    }\n    \n    dist = nearest_dist;\n    if( nearest_dist < 1000.0 ) {\n    \thit.E = ray.dir*(-1.0);\n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\nfloat brdfEvalBrdfPhong( in  vec3 N, in vec3 E, in vec3 L, in float roughness ){\n    vec3 R = reflect( E*(-1.0), N );\n    float dotLR = dot( L, R );\n    dotLR = max( 0.0, dotLR );\n    return pow( dotLR, roughness + 1.0 )*(roughness + 1.0)*(INV_PI);\n}\n\nfloat brdfEvalBrdfDiffuse( in vec3 N, in vec3 L ){\n    return clamp( dot( N, L ), 0.0, 1.0 )*INV_PI;\n}\n\n// GGX *****************************************************************************************\nfloat ggx_eval( in float dotNH, float alpha ) {\n    float cosThetaM = dotNH;\n    \n    if( cosThetaM < EPSILON ) {\n        return 0.0;\n    } else {\n        float alpha2 = alpha * alpha;\n        float cosThetaM2 = cosThetaM * cosThetaM;\n        float tanThetaM2 = (1.0 - cosThetaM2) / cosThetaM2;\n        float cosThetaM4 = cosThetaM2 * cosThetaM2;\n        return alpha2 / ( PI * cosThetaM4 * pow( alpha2 + tanThetaM2, 2.0 ) );\n    }\n}\n\nvec3 ggx_sample( vec3 N, float alpha, float Xi1, float Xi2 ) {\n    vec3 Z = N;\n    vec3 X = sampleHemisphere( N, Xi1, Xi2 );\n    vec3 Y = cross( X, Z );\n    X = cross( Z, Y );\n    \n    float alpha2 = alpha * alpha;\n    float tanThetaM2 = alpha2 * Xi1 / (1.0 - Xi1);\n    float cosThetaM  = 1.0 / sqrt(1.0 + tanThetaM2);\n    float sinThetaM  = cosThetaM * sqrt(tanThetaM2);\n    float phiM = TWO_PI * Xi2;\n    \n    return X*( cos(phiM) * sinThetaM ) + Y*( sin(phiM) * sinThetaM ) + Z*cosThetaM;\n}\n\nfloat ggx_g1( in float dotNV, in float dotHV, float alpha ) {\n    if( (dotHV/dotNV) < EPSILON ) {\n        return 0.0;\n    } else {\n        float cosThetaV_2 = dotNV*dotNV;\n        float tanThetaV_2 = 1.0 - cosThetaV_2;\n        float alpha2 = alpha*alpha;\n        return 2.0 / ( 1.0 + sqrt( 1.0 + alpha2 * tanThetaV_2 / cosThetaV_2 ) );\n    }\n}\n\nvec3 evalBRDF( vec3 n, vec3 l, vec3 v, float m, vec3 cdiff, vec3 cspec ) {\n\tvec3  h = normalize( l + v );\n\tfloat dotNH = max( dot( n, h ), 0.0 );\n\tfloat dotNV = max( dot( n, v ), 0.0 );\n\tfloat dotNL = max( dot( n, l ), 0.0 );\n\tfloat dotHV = max( dot( h, v ), 0.0 );\n    float dotHL = dotHV;\n    \n    float G = ggx_g1( dotNV, dotHV, m )*ggx_g1( dotNL, dotHL, m );\n    float D = ggx_eval( dotNH, m );\n    vec3  F = cspec + ( 1.0  - cspec ) * pow( 1.0 - dotHL, 5.0 );\n\n\t// BRDF Torrance-Sparrow specular\n\tvec3 spec = (F * D * G) / ( dotNV * dotNL * 4.0 );\n\t\n\t// BRDF Lambertian diffuse\n\tvec3 diff = (cdiff * ( 1.0 - F ));\n\t\n\t// Punctual Light Source ( cancel pi )\n\treturn ( spec + diff ) * dotNL;\n}\n\nvec3 calcDirectLight( vec3 pos, out vec3 wi, Sphere lightSphere, vec3 lightColor ) {\n    vec3 Li = lightColor;\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 dirToLightCenter = lightSphere.pos - pos;\n    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);\n    float cos_a_max = sqrt( 1.0 - clamp( lightSphere.radiusSq / distToLightCenter2, 0.0, 1.0 ) );\n    float omega = TWO_PI * (1.0 - cos_a_max);\t//solid angle\n    float cosa = mix(cos_a_max, 1.0, rnd());\n    float sina = sqrt(1.0 - cosa*cosa);\n\n    wi = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );\n    float pWi = (1.0/omega);\n\n    Ray shadowRay = Ray( pos, wi );\n    float dist;\n    raySphereIntersection( shadowRay, lightSphere, dist );\n\n    float tmpDist;\n    RayHit tmpHit;\n    int tmpObjId;\n    raySceneIntersection( shadowRay, EPSILON, tmpHit, tmpObjId, tmpDist );\n    float eps = tmpDist*0.0001;\n\n    if( EQUAL_FLT( tmpDist, dist, eps ) ) {\n        float throughput = exp(-VOLUME_EXTINCTION * dist);\n        Lo += throughput * Li / pWi;\n    }\n\n    return Lo;\n}\n\nvec3 calcLightOnSurface( RayHit hit ) {\n    vec3 Lo = vec3( 0.0 );\n    Material surfMtl = getMaterialFromLibrary( hit.materialId );\n\n    if( surfMtl.bsdf_ == BSDF_R_LIGHT ) {\n        Lo = surfMtl.color;\n    } else {\n        vec3 surfColor = surfMtl.color;\n        float specVal = 0.7;\n            \n        if( hit.materialId == MTL_WALL ) {\n            surfColor = texture( iChannel0, hit.uv ).xyz;\n        } else if( hit.materialId == MTL_SPHERE ) {\n            surfColor = texture( iChannel1, hit.uv ).xyz;\n            specVal = 1.0 - BRIGHTNESS(texture( iChannel1, hit.uv ).xyz);\n        }\n        \n        vec3 wi;\n        \n        for( int i=0; i<LIGHT_COUNT; i++ ) {\n            vec3 Li = materialLibrary[i].color;\n            vec3 directLight = calcDirectLight( hit.pos_dist.xyz, wi, spherelight[i], Li );\n            \n            if( dot( wi,hit.normal ) > 0.0 ) {\n                vec3 cdiff = vec3( specVal );\n                vec3 cspec = vec3( 1.0 - specVal );\n                vec3 brdf = evalBRDF( hit.normal, wi, hit.E, 0.4, cdiff, cspec );\n\n                Lo += directLight*brdf*surfColor;\n            }\n        }\n        float throughput = exp(-VOLUME_EXTINCTION * hit.pos_dist.w);\n        Lo *= throughput/float(LIGHT_COUNT);\n    }\n    \n    return Lo;\n}\n\nvec3 calcLightOnParticle( vec3 particlePos, Sphere lightSphere, vec3 Li ) {\n    vec3 wi;\n    return calcDirectLight( particlePos, wi, lightSphere, Li );\n}\n\nvec3 Radiance( in Ray ray ) {\n    vec3 surfaceShaded = vec3(0.0);\n   \n    \n    RayHit hit;\n    int objId;\n    float dist = 100.0;\n    if( raySceneIntersection( ray, 0.0, hit, objId, dist ) ) {\n        surfaceShaded = calcLightOnSurface( hit );\n    }\n    \n    \n    vec3 particleShaded = vec3(0.0);\n    for( int i=0; i<LIGHT_COUNT; i++ ) {\n\t\tvec3 Li = (i==0)?materialLibrary[MTL_LIGHT_1].color:materialLibrary[MTL_LIGHT_2].color;\n        for (int s=0; s<VOLUME_SAMPLES; s++) {\n        \tfloat particleDist;\n        \tfloat particlePdf;\n            float Xi = (1.0/float(VOLUME_SAMPLES))*(float(s) + rnd());\n        \tsampleEquiAngular( ray, dist, Xi, spherelight[i].pos, particleDist, particlePdf );\n        \tvec3 particlePos = ray.origin + particleDist*ray.dir;\n        \n        \tfloat throughput = exp(-VOLUME_EXTINCTION * particleDist);\n\n        \tparticleShaded += VOLUME_SCATTERING * throughput * calcLightOnParticle( particlePos, spherelight[i], Li )/(particlePdf * FOUR_PI * float(VOLUME_SAMPLES));\n        }\n    }\n    particleShaded *= 1.0/float(LIGHT_COUNT);\n    \n    return surfaceShaded + particleShaded;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    frameSta = iTime;\n    frameEnd = frameSta + FRAME_TIME;\n\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n   \n    float fov = radians(45.0);\n\n    initCamera( vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 1.0, 0.0 ), fov, CAMERA_LENS_RADIUS, 8.0 );\n    \n    initMaterialLibrary();\n    initScene();\n    \n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<AA_SAMPLES; ++si ){\n    \tupdateScene();\n        updateCamera( si );\n        \n        vec2 screenCoord = fragCoord.xy + vec2( (1.0/float(AA_SAMPLES))*(float(si)+rnd()), rnd() );\n        Ray ray = genRay( screenCoord, rnd(), rnd() );\n        \n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n        \taccumulatedColor += Radiance( ray );\n        }\n\t}\n\t\n\t//devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0/float(AA_SAMPLES));\n\t\n\t//gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n    \n\t\n\tfragColor = vec4( accumulatedColor,1.0 );\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[985, 1082, 1095, 1095, 1138], [2109, 2109, 2147, 2147, 2182], [2468, 2468, 2496, 2496, 2861], [2863, 2863, 2886, 2886, 2893], [2895, 2895, 2940, 2940, 2974], [2976, 2976, 2994, 2994, 3647], [3649, 3649, 3669, 3669, 4049], [4051, 4130, 4200, 4200, 4476], [4478, 4478, 4541, 4541, 4685], [4768, 4850, 4928, 4928, 5029], [5031, 5031, 5121, 5121, 5271], [5273, 5273, 5328, 5328, 5582], [5584, 5584, 5657, 5657, 5765], [5767, 5767, 5842, 5842, 5985], [5987, 5987, 6054, 6054, 6173], [6175, 6193, 6318, 6379, 6774], [6857, 6929, 7046, 7046, 7366], [8233, 8233, 8290, 8290, 8545], [8547, 8547, 8653, 8653, 10552], [10554, 10554, 10634, 10634, 10804], [10806, 10806, 10856, 10856, 10908], [10910, 11007, 11054, 11054, 11440], [11442, 11442, 11504, 11504, 11935], [11937, 11937, 11998, 11998, 12280], [12282, 12282, 12356, 12356, 12977], [12979, 12979, 13063, 13063, 14041], [14043, 14043, 14082, 14082, 15312], [15314, 15314, 15389, 15389, 15468]]}
{"id": "3tjfzy", "name": "Dither One-Liner (No Sampling)", "author": "kowbell", "description": "One-line dithering function that doesn't require a noise texture or Bayer matrices.\n\nFork of Zavie's copy (https://www.shadertoy.com/view/4dcSRX) of Alex Vlachos' modified version of lestyn's RGB dither from Portal 2.", "tags": ["noise", "banding", "filter", "dither", "dithering", "oneliner"], "likes": 5, "viewed": 416, "published": 3, "date": "1599235857", "time_retrieved": "2024-07-30T20:47:36.369940", "image_code": "/** \n * Dither effect which requires no texture sampling/matrices.\n * Supposed to be pretty good for VR, too.\n *\n * Adapted from Alex Vlachos' 2015 GDC Talk \n * (p. 45 in http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf)\n *\n * No explicit license mentioned, so use this at your own legal peril.\n * I've seen it used on this site, so it's probably safe. Thanks, Alex!\n * Originally copied from Zavie (https://www.shadertoy.com/view/4dcSRX)\n */\n\n\n// Minimal version macro (by coyote)\n#define dither(c,u,d) floor(fract(dot(vec2(131,312),u+iTime)/vec3(103,71,97))*.375-.1875+c*d)/d\n\n\n// Small One-liner function version with parameter names\n// vec3 dither(vec3 col, vec2 coord, float depth){vec3 vD=vec3(dot(vec2(131.,312.),coord.xy+iTime));vD.rgb=fract(vD.rgb/vec3(103.0,71.0,97.0))-vec3(0.5,0.5,0.5);return floor(((vD.rgb/depth)*0.375+col)*depth)/depth;}\n\n// Non-minified version\n/*\nvec3 vlachosDither(vec3 srcColor, vec2 fragCoord, float colorDepth)\n{\n    vec3 vDither = vec3(dot(vec2(131.0, 312.0), fragCoord.xy + iTime));\n    vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);\n    vec3 dither = (vDither.rgb / colorDepth) * 0.375;\n    return floor((dither + srcColor) * colorDepth) / colorDepth;\n}\n*/\n\n// Basic demo with a video\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(dither(col, fragCoord, 8.),1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1265, 1292, 1349, 1349, 1488]]}
{"id": "3ljfRG", "name": "easy adaptive sampling", "author": "FabriceNeyret2", "description": "Oversample at NxN only the pixels that are ambiguous (blue/red: not oversampled).  \nWorks for anything, in 2D or 3D.\nCommon: function or image or render to be sampled\nBufA: compute at pixel resolution\nImage: oversample NxN only in ambiguous neighborhoods", "tags": ["antialiasing", "sampling", "optimization", "adaptive"], "likes": 19, "viewed": 830, "published": 3, "date": "1599227460", "time_retrieved": "2024-07-30T20:47:37.275519", "image_code": "#define DEMO 1   // 1: demo mode: binary function.  0: continuous function.\n#define N 3      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n//#define T(U,l)   texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)   textureLod(iChannel0, (U)/R, float(l-1) )\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O -= O;\n    float n = float(N),\n          m = T( U, 2 ).w;          // check neighborhood. Here: LOD #2 of mask\n\n#if DEMO    // --- f= binary function ( col = mask = binary )\n    \n // if ( m !=0. && m!= 1.) {        // neighborhood does not agree\n    if ( abs(m-T(U,0).w) > eps ) {  // why ? otherwise, inside don't work in fullscreen\n // if ( true ) {                   // for bench: always oversample\n        for (int k=0; k<N*N; k++) { // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D ).w;\n        }\n        O /= n*n;\n    }\n    else                            // LOD#0 is ok\n        O = T( U, 0 ).w == 1. ? vec4(1,0,0,1) : vec4(0,0,1,1);\n\n#else       // --- f = continous color function ( i.e., image )\n    \n    if ( m !=0. && m!= 1.) {        // neighborhood does not agree (with binary mask)\n  // if ( abs(m-T(U,0).w) > eps ) { // with continuous mask\n        for (int k=0; k<N*N; k++) { // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            O += f( U +  D );\n        }\n        O /= n*n;\n    }\n    else                            // LOD#0 is ok\n        O = T( U, 0 ), \n            O.gb -= .3*float(O.w>=1.-eps), O.rg -= .3*float(O.w<=eps);\n#endif\n        \n    O = pow( O, vec4(1./2.2) );     // to sRGB\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- custom function or image or render\n\n#define R  iResolution.xy\n\n// f() should be a function, but fucking Common does not work like #include as anybody would like it to.\n// Here, it's the use of iTime and iResolution that uselessly screw things up for no good reason. \nfloat x,y,v,t;\n#define f(U) (                                           \\\n    x = (U).x / R.y, y = (U).y / R.y, t = iTime,         \\\n    v =   sin(  9.*x + sin(40.*y) -t )                   \\\n        * cos( 14.*y + cos(17.*x) +t ),                  \\\n    vec4( vec3(.5-.5*v),  /* V.rgb = color */            \\\n          step( v , -.5 ) /* V.a = mask. Here, binary */ \\\n        )                                                \\\n)\n", "buffer_a_code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = f(U);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 370, 370, 1704]]}
{"id": "3t2BWw", "name": "The Afterlife", "author": "DrNoob", "description": "After the album cover \"The Afterlife\" by \"The Comet is Coming\":\nhttps://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png", "tags": ["noise", "sun", "abstract", "sand", "dune", "reproduction"], "likes": 9, "viewed": 225, "published": 3, "date": "1599219377", "time_retrieved": "2024-07-30T20:47:38.033492", "image_code": "// Author: Thomas Stehle\n// Title: The Afterlife\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the album cover \"The Afterlife\" by \"The Comet is Coming\":\n// https://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png\n\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\n\nconst int   NUM_SAMPLES = 3;\nconst int   MAX_STEPS   = 35;\nconst float MAX_DIST    = 20.0;\nconst float SURF_DIST   = 0.0001;\n\nconst vec3 GREEN_HSV = vec3(157.0 / 360.0, 0.35, 0.94);\nconst vec3 RED_HSV   = vec3( 18.0 / 360.0, 0.98, 0.94);\n\nconst float INV_ID  = 0.0;\nconst float CUBE_ID = 1.0;\nconst float DUNE_ID = 2.0;\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 2D wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wnoise(in vec2 p, in float k, in float time)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f * (3.0 - 2.0*f);\n    float c = cos(0.5 * time);\n    float s = sin(0.25 * time);\n    mat2 rot = mat2(c, s, -s, c);\n    return 0.5 + 0.5 *\n        mix( mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 0)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 0)))) ), f.x),\n             mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 1)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 1)))) ), f.x), f.y);\n}\n\n// 2D Fractional Brownian motion based on wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wfbm(in vec2 p, in float k, in float time) {\n    mat2 rot = mat2(1.6, 1.2, -1.2, 1.6);\n    float v = 0.0;\n    float a = 0.5;\n    const int numOctaves = 5;\n    for (int i = 0; i < numOctaves; ++i) {\n        v += a * wnoise(p, k, time);\n        p = rot * p;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdPlane(in vec3 p, in float h) {\n    return p.y - h;\n}\n\nfloat duneBump(in vec3 p) {\n    return 0.1 * wnoise(p.xz, 6.0, 0.05 * iTime);\n}\n\nvec2 scene(in vec3 p) {\n    vec3 boxPos = 0.075 * vec3(sin(1.1 * iTime), sin(iTime), 0.0);\n    float d1 = sdBox(p - boxPos, vec3(0.95));\n    float h = 4.0 + 0.3 * (sin(0.676 * p.x) + sin(1.348 * p.z));\n    h += 0.884 * duneBump(p);\n    float d2 = sdPlane(p, -h);\n    return (d1 < d2) ? vec2(d1, CUBE_ID) : vec2(d2, DUNE_ID);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float t = 0.1;\n    float id = INV_ID;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + t * rd;\n        vec2 s = scene(p);\n        id = s.y;\n        if (abs(s.x) < SURF_DIST * t) break;\n        t += s.x;\n        if (t > MAX_DIST) break;\n    }\n    \n    if (t > MAX_DIST) {\n        t = -1.0;\n        id = INV_ID;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    float t = scene(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = t - vec3(scene(p - e.xyy).x, scene(p - e.yxy).x, scene(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 rayDir(in vec2 p, in vec3 origin, in vec3 tgt, in float z) {\n    vec3 f = normalize(tgt - origin);\n    vec3 r = normalize(cross(f, vec3(0, 1 ,0)));\n    vec3 u = cross(r, f);\n    vec3 c = f * z;\n    return normalize(c + p.x*r + p.y*u);\n}\n\n// Smoothstep'ed HSV to RGB conversion by iq\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0 - 2.0*rgb);    \n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat easeInOutSine(in float x) {\n    return -0.5 * (cos(x * PI) - 1.0);\n}\n\nvec3 gradient(in vec2 p) {\n    mat2 R = rot2(-0.75);\n    float scale = 1.1 + 0.2 * sin(iTime);\n    vec2 q = R * (scale * p) + vec2(0.5);\n    vec3 col = mix(GREEN_HSV, RED_HSV, easeInOutSine(clamp(q.x + 0.15, 0.0, 1.0)));\n    return smoothHsvToRgb(col);\n}\n\n// Inspired by https://www.shadertoy.com/view/lljGDt\nfloat sun(in vec2 p, in vec2 center) {\n    vec2 dir = normalize(vec2(1.0, -0.116));\n    const float seedA = 36.0;\n    const float seedB = 21.0;\n    const float speed = 2.5;\n\n    vec2 q = p - center;\n    float angle = dot(normalize(q), dir);\n    float rays = clamp(\n        (0.2 + 0.15 * sin(angle * seedA + iTime * speed)) +\n        (0.3 + 0.2 * cos(-angle * seedB + iTime * speed)), 0.0, 1.0);\n    \n    const float inten = 0.003;\n    float atten = inten / dot(q, q);\n\n    return rays * atten;\n}\n\nvec3 sampleScene(in vec2 uv) {\n    vec3 col = vec3(0);\n\n    // Gradient and sun\n    col += gradient(uv);\n    col += sun(uv, vec2(0, 0.15));\n\n    // Cast ray\n    float angle = -PI / 4.0;\n    vec3 ro = 15.0 * vec3(sin(angle), 0.35, cos(angle));\n    vec3 tgt = vec3(0.0, -0.25, 0.0);\n    vec3 rd = rayDir(uv, ro, tgt, 2.0);\n    vec2 s = castRay(ro, rd);\n\n    // Shade scene\n    if (s.x > 0.0) {\n        // Hit point and normal\n        vec3 p = ro + s.x * rd;\n        vec3 n = calcNormal(p);\n\n        // Cube\n        if (CUBE_ID == s.y) {\n            // Colors on cube surface\n            const vec3 greenHsv  = vec3(87.0 / 360.0, 0.96, 0.79);\n            const vec3 yellowHsv = vec3(45.0 / 360.0, 0.99, 0.98);\n            const vec3 orangeHsv = vec3(35.0 / 360.0, 0.98, 0.96);\n            const vec3 redRgb    = vec3(153, 10, 6) / 255.0;\n\n            // Left side material\n            vec2 qL = rot2(-0.8) * (0.6 * p.xy) + 0.6;\n            vec3 colL = mix(greenHsv, orangeHsv, easeInOutSine(clamp(qL.x, 0.0, 1.0)));\n            vec3 matL = abs(n.x) * smoothHsvToRgb(colL) * pow(wfbm(1.5 * p.yz, PI, iTime + 20.0), 0.15);\n\n            // Top side material\n            // Bump shading inspired by https://www.shadertoy.com/view/Xl2XWz\n            vec2 qT = rot2(1.008) * p.zx;\n            vec3 colT = mix(greenHsv, yellowHsv, clamp(qT.x, 0.0, 1.0));\n            float n1 = wfbm(1.5 * p.zx, PI, 1.0 * iTime + 10.0);\n            float n2 = wfbm(1.6 * p.zx, PI, 1.01 * iTime + 10.0);\n            float b1 = max(n2 - n1, 0.0) / 0.02 * 0.7071;\n            float b2 = max(n1 - n2, 0.0) / 0.02 * 0.7071;\n            b1 = b1 * b1 * 0.5 + pow(b1, 4.0) * 0.5;\n            b2 = b2 * b2 * 0.5 + pow(b2, 4.0) * 0.5;\n            float bump = clamp(0.5 + n1 * n1 * (b1 * 0.2 + b2 * 0.2 + 0.5), 0.0, 1.0);\n            vec3 matT = abs(n.y) * smoothHsvToRgb(colT) * pow(bump, 0.175);\n\n            // Right side material\n            vec3 matR = abs(n.z) * redRgb * (0.1 + wfbm(0.75 * p.xy, PI, iTime));\n\n            col = matL + matT + matR;\n        }\n        // Dune\n        else if (DUNE_ID == s.y) {\n            // Material\n            vec3 mat = vec3(0.18) + 0.180 * duneBump(p);\n\n            // Lighting\n            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));\n            vec3 duneCol = mat * vec3(7.0, 4.5, 3.0) * clamp(dot(n, sunDir), 0.0, 1.0);\n\n            // Gamma correct\n            duneCol = pow(duneCol, vec3(0.4545));\n\n            // Mix with gradient\n            col = mix(col, col * duneCol, 0.35);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize input coordinates\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Result color\n    vec3 col = vec3(0);\n    \n    // Enforce square format\n    if (abs(uv.x) < 0.5 && abs(uv.y) < 0.5) {\n        // Multi-sample scene\n        vec2 sss = 1.0 / (float(NUM_SAMPLES) * iResolution.xy);\n        for (int sy = 0; sy < NUM_SAMPLES; ++sy) {\n            for (int sx = 0; sx < NUM_SAMPLES; ++sx) {\n                col += sampleScene(uv + vec2(float(sx), float(sy)) * sss);\n            }\n        }\n        col /= float(NUM_SAMPLES) * float(NUM_SAMPLES);\n\n        // Add layer of animated dust over dune section\n        vec2 off = 5.0 * vec2(0.5 + 0.5 * sin(0.2 * iTime), 0);\n        float dust = 0.2 + 0.2 * wnoise(5.0 * uv - off, PI, 0.2 * iTime);\n        col = mix(col, vec3(dust), smoothstep(-0.1, -0.75, uv.y));\n    \n        // Add layer of animated white noise\n        col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n\n        // Vignetting\n        float vig = length(uv) * 0.5;\n        vig = vig * vig + 1.0;\n        col *= 1.0 / (vig * vig);\n    }\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2BWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[684, 708, 733, 733, 836], [838, 909, 933, 933, 1061], [1063, 1127, 1179, 1179, 1746], [1748, 1848, 1898, 1898, 2149], [2151, 2151, 2174, 2174, 2250], [2252, 2252, 2287, 2287, 2377], [2379, 2379, 2417, 2417, 2439], [2441, 2441, 2468, 2468, 2520], [2522, 2522, 2545, 2545, 2848], [2850, 2850, 2888, 2888, 3259], [3261, 3261, 3289, 3289, 3454], [3456, 3456, 3521, 3521, 3697], [3699, 3785, 3817, 3817, 4004], [4006, 4006, 4039, 4039, 4080], [4082, 4082, 4108, 4108, 4336], [4338, 4391, 4429, 4429, 4886], [4888, 4888, 4918, 4918, 7420]]}
{"id": "wlBBRy", "name": "Basic Posterize One-Liner", "author": "kowbell", "description": "Basic posterization filter you can use in your own shaders. Public domain/CC0.", "tags": ["filter", "color", "posterize", "oneliner"], "likes": 5, "viewed": 664, "published": 3, "date": "1599199217", "time_retrieved": "2024-07-30T20:47:38.875242", "image_code": "/** \n * Drag-n-drop posterize filter.\n * All you need is the one-liner function!\n *\n * You can credit kowbell, or not.\n * CC0, No Rights Reserved, Public Domain!\n */\nvec4 posterize(vec4 src, float steps) { return vec4(floor(src.rgb * steps) / steps, src.a); }\n\n\n\n\n/**\n * Basic demo of it use the second \"STEPS\" define line to \n * control posterization levels with the mouse\n */\n#define MOUSE (iMouse.xy/iResolution.xy)\n#define STEPS 8.0\n//#define STEPS (MOUSE.x * 8.0) /* Commented out so it works when you first open this shader :) */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = posterize(col, STEPS);  \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBRy.jpg", "access": "api", "license": "public-domain", "functions": [[0, 166, 205, 205, 259], [537, 537, 594, 594, 726]]}
{"id": "WtBBzy", "name": "020 Raving cubes", "author": "illus0r", "description": "020 Raving cubes", "tags": ["raymarching", "sound"], "likes": 6, "viewed": 275, "published": 3, "date": "1599175057", "time_retrieved": "2024-07-30T20:47:39.626234", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define EPSILON 0.00001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define LIGHT 5.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 1.1)\n\n#define N 6\n\nfloat rnd (float x) {return fract(10000. * sin(10000. * x));}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 boxTexture(vec3 p, float id) {\n    if (p.x + -p.z < 0.) {\n        p.xz = p.zx;\n        id += 1.;//1000. * rnd(id);\n    }\n    id = floor(id);\n    id = mod(id, 52.);\n    float col = mod(id, 10.);\n    float row = id - col;\n    p.x -= col * 2.;\n    p.y -= row * 2.;\n    p.xy -= 1.;\n    p.xy *= .05;\n    return vec3(1);//texture(iChannel0, p.xy).rgb;\n}\n\n\n\n\n\n// // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n// vec2 getDist(vec3 p) {\n//     // p.x += 0.04 * floor(p.y);\n//     p.y = fract(p.y);\n//     p.xz *= Rot(PI /4.);\n//     // p *= 8.;\n//     p.z = fract(p.z);\n//     p.z -= 0.5;\n//     p.xz *= Rot(PI /4.);\n//     float box1 = sdBox(p, vec3(0.353553));\n//     float obj = min(box1, box1);\n//     return vec2(obj * .6, RED);\n// }\n// // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n\n    //p /= texture(iChannel0, vec2(smoothstep(0., 20., pow(length(p), .5)), 0.25)).x;\n    //p /= texture(iChannel0, vec2(smoothstep(0., 50., length(p)), 0.25)).x;\n    //p /= texture(iChannel0, vec2(1. / (length(p) / 10. + 1.), 0.25)).x;\n    p.xz *= Rot(2. * texture(iChannel0, vec2(smoothstep(0., 10., length(p)), 0.25)).x);\n\n    p.xz *= Rot(PI /4.);\n    vec3 step = vec3(1, 1.23, 1);\n    // p.x -= 1.8 * floor(p.y / step.y);\n    // p.x -= floor(p.y * iTime / 10.);\n    p.y -= 1.;\n    p.xy *= Rot(- PI / 4.);\n    p.y = mod(p.y, step.y);\n    p.y -= step.y / 2.;\n    // p.xz *= Rot(PI /4.);\n    p.xy *= Rot(PI / 2. - asin(sqrt(3.) / 3.));\n    p.z = fract(p.z);\n    p.z -= 0.5;\n    p.xz *= Rot(PI /4.);\n    float box1 = sdBox(p, vec3(0.353553));\n    float obj = min(box1, box1);\n    return vec2(obj * 0.4, RED);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float step = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        step ++;\n        // volumeLight += .01;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, step);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // // isometry\n    // vec3 ro = vec3(uv.x, 10, uv.y) * 10.;\n    // // ro += vec3(10, 2, -2);\n    // // vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    // vec3 lookat = vec3(0, -1, 0);\n    // ro.xz *= Rot(PI / 4.);\n    // ro.yz *= Rot(iTime);\n    // // ro.xz *= Rot(angle.x);\n    // vec3 rd = normalize(lookat);\n\n    // perspective\n    vec3 ro = vec3(0.00001, 5, 0.000001);\n    vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    ro.yz *= Rot(-PI / 4.);\n    //ro.xz *= Rot(- PI / 2.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 rd = getRayDir(uv, ro, lookat, 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 color;\n    color = vec3(1);\n    vec3 light = vec3(100, 100, 100);\n    // light.xz *= Rot(angle.x);\n    // light.yz *= Rot(angle.y);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring \n        if (d < MAX_DIST) {\n           if (info == RED) {\n                // color = boxTexture(p, iTime) + .1;\n                color *= dot(dirToLight, n) * .5 + .5;\n                //color = n * 0.5 + 0.5;\n                // color *= smoothstep(210., 200., d);\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [{"id": 23842, "src": "https://soundcloud.com/ilyabirman/studio-mix-synthopia", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 298, 298, 338], [340, 340, 359, 359, 422], [424, 424, 455, 455, 542], [544, 544, 579, 579, 896], [1395, 1474, 1496, 1734, 2308], [2399, 2399, 2432, 2432, 2844], [2846, 2846, 2870, 2870, 3088], [3090, 3090, 3144, 3144, 3371], [3373, 3373, 3423, 3423, 3614], [3627, 3627, 3683, 3683, 5894]]}
{"id": "3lSfRy", "name": "Audio Glow Circle", "author": "TimArt", "description": "From https://www.shadertoy.com/view/ldcBW7 but modified", "tags": ["circle", "glow"], "likes": 4, "viewed": 403, "published": 3, "date": "1599167571", "time_retrieved": "2024-07-30T20:47:40.412133", "image_code": "// SDF circle with some weird magic constants\n/*float circle (vec2 uv, vec2 center, float radius)\n{\n    return 0.7f / abs (length (uv - center) - radius) / 25.0f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0f * fragCoord.xy - iResolution.xy) / iResolution.y;\n \n    float ratio = iResolution.x/iResolution.y;\n    float norm = (uv.x/ratio+1.)/2.;\n    float wave = texelFetch(iChannel0, ivec2(norm*512.,1), 0).x * 0.4;\n    \n    vec3 colorHue = vec3(0.2, 1.0, 0.6);\n    \n    //uv.x=wave-0.5; // turn circle into two waves!\n    \n    fragColor.xyz = colorHue * circle(uv, vec2(0), 1.0-wave);\n    fragColor.xyz += 0.1*colorHue;\n}*/\n\n#define THICKNESS 0.02\n#define BUFFER_SIZE 512.0\n\nvoid getAmplitudeForXPos (in float xPos, out float audioAmplitude)\n{\n   // Buffer size - 1\n   float perfectSamplePosition = (BUFFER_SIZE - 1.0f) * xPos / resolution.x;\n   int leftSampleIndex = int (floor (perfectSamplePosition));\n   int rightSampleIndex = int (ceil (perfectSamplePosition));\n   \n   float audioSampleDataLeft = texelFetch(iChannel0, ivec2(leftSampleIndex,1), 0).x;\n   float audioSampleDataRight = texelFetch(iChannel0, ivec2(rightSampleIndex,1), 0).x;\n   \n   audioAmplitude = mix (audioSampleDataLeft, audioSampleDataRight, fract (perfectSamplePosition));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float y = fragCoord.y / iResolution.y;\n    float amplitude = 0.0;\n    getAmplitudeForXPos (fragCoord.x, amplitude);\n\n    // Centers & Reduces Wave Amplitude\n    amplitude = 0.5 - amplitude / 2.5;\n    float r = abs (THICKNESS / (amplitude-y));\n\n    fragColor = vec4 (r - abs (r * 0.2), r - abs (r * 0.2), r - abs (r * 0.2), 1.0);\n};", "image_inputs": [{"id": 23841, "src": "https://soundcloud.com/timart/mango-tree-girl", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[709, 709, 777, 799, 1282], [1285, 1285, 1340, 1340, 1675]]}
{"id": "wt2fWw", "name": "Planets 2d animation ", "author": "morimea", "description": "Made it 2 years ago, [b]code is very bad.[/b]\nMade for learning shaders at same time with [url=https://www.shadertoy.com/view/4lKcDD]this shader[/url].\n\nNow used as startup image in [url=https://danilw.itch.io/particle-effects-godot3]this project[/url].", "tags": ["2d", "animation"], "likes": 55, "viewed": 1141, "published": 3, "date": "1599162541", "time_retrieved": "2024-07-30T20:47:41.181077", "image_code": "\n// License - CC0 or use as you wish\n\nfloat rand(float p) {\n    return mod(p*7241.6465+2130.465521, 64.984131);\n}\n\nfloat rand2(vec2 p) {\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash(in vec2 p)\n{\n    return fract(dot(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat noise( float y, float t)\n{\n    vec2 fl = vec2(floor(y), floor(t));\n    vec2 fr = vec2(fract(y), fract(t));\n    float a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n    float b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n    return mix(a,b,fr.y);\n}\n\nfloat line(vec2 uv,float width, float center, float px)\n{\n    float b\t\t=\t(1.- smoothstep(.0, width/2.+px, (uv.y-center)))*1.;\n    return b;\n}\n\nconst vec3 dark=vec3(0x1a,0x13,0x21)/float(0xff);\nconst vec3 white=vec3(0xdc,0xe0,0xd1)/float(0xff);\nconst vec3 red=vec3(0xa6,0x36,0x2c)/float(0xff);\nconst vec3 redw=vec3(0xfd,0x8c,0x77)/float(0xff);\n\nfloat circle( in vec2 uv, float r1, float r2, bool disk)\n{\n    float w = 2.0*fwidth(uv.x);\n    float t = r1-r2;\n    float r = r1;\n\n    if(!disk)\n        return smoothstep(-w/2.0, w/2.0, abs(length(uv) - r) - t/2.0);\n    else\n        return smoothstep(-w/3.0, w/3.0, (length(uv) - r) );\n\n}\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat animstart=2.5;\n\nvec3 strucb(vec2 uv, float timer) {\n    float d=step(-0.14,uv.y)*step(uv.y,-0.127)*step(abs(uv.x+0.19),0.02);\n    vec3 ret=vec3(0.);\n    d=max(d,step(-0.14,uv.y)*(1.-circle(uv+vec2(0.225,0.14),0.02270,0.35,true)));\n    d=max(d,step(-0.14,uv.y)*(1.-circle(uv+vec2(0.165,0.14),0.02970,0.35,true)));\n    d=max(d,step(uv.y,-0.094)*step(-0.14,uv.y)*smoothstep(0.0031,0.0008,abs(uv.x+0.12)));\n    d=max(d,step(uv.y,-0.115)*step(-0.14,uv.y)*smoothstep(0.0031,0.0008,abs(uv.x+0.1075)));\n    ret=d*red;\n    float tuvx=mod(uv.x,0.006)-0.003;\n    d=step(-0.132,uv.y);\n    d=step(abs(uv.x+0.225),0.015)*d*smoothstep(0.0031,0.0005,abs(tuvx))*(1.-circle(uv+vec2(0.225,0.143),0.021970,0.35,true));\n    ret=mix(ret,redw*1.25,d);\n    tuvx=mod(uv.x-0.093,0.012)-0.006;\n    d=smoothstep(0.0061,0.0035,abs(tuvx))*step(abs(uv.y+0.122),0.00182);\n    ret=mix(ret,white,d*step(abs(uv.x+0.165),0.0165));\n    return ret*smoothstep(animstart+2.2,animstart+3.2,timer);\n}\n\nvec3 postfx(vec2 uv, vec3 col,float reg) {\n    vec3 ret=col+ 1.5*reg*((rand2(uv)-.5)*.07);\n    //ret = clamp(1.5*ret,0.,1.);\n    return ret;\n}\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\nfloat animendfade(float timer) {\n    return smoothstep(animstart+11.5,animstart+9.5,timer);\n}\n\nvec3 map(vec2 uv, float lt, float timer) {\n    float d=(circle(uv,0.32*smoothstep(animstart-1.,animstart+0.35,timer),0.,true));\n\n    vec3 tcol=d*dark;\n    float a=1.-circle(uv,0.3542,0.35,false);\n    vec2 tuv=uv;\n    float af = atan(tuv.x,tuv.y);\n    float r = length(tuv)*0.75;\n    tuv = vec2(af/TWO_PI,r);\n    a*=step(tuv.x,-PI/2.+PI*smoothstep(animstart+2.5,animstart+4.8,timer));\n    vec3 ret=max(tcol,a*(1.-lt)*redw);\n    ret=max(ret,lt*dark);\n    ret=max(ret,(1.-lt)*(1.-d)*red)*smoothstep(animstart-1.,animstart+0.35,timer);\n    float b=1.-circle(uv+vec2(0.,0.225*smoothstep(animstart,animstart-2.,timer)),0.2242,0.22,true);\n    tuv=uv;\n    float tuvy=mod(tuv.y,0.015)-0.0075;\n    float e=1.-max(smoothstep(0.0005,0.0031,abs(tuvy)),step(0.195,tuv.y)+step(tuv.y,0.185)*step(0.165,tuv.y)+\n                   step(tuv.y,0.14)*step(0.06,tuv.y)+step(tuv.y,0.03)*step(0.015,tuv.y));\n\n    float di=smoothstep(animstart+4.5,animstart+6.5,timer);\n    float di2=smoothstep(animstart+8.5,animstart+9.5,timer);\n    e*=step(uv.x+1.5*uv.y*(1.-di),di-0.5);\n    e*=step(di2-.5,uv.x-2.*uv.y*(1.-di2));\n\n    e=(1.-e)*(b);\n    ret=max(ret,(1.-lt)*e*white);\n    float c=1.-circle(uv,0.3542,0.35,true);\n    tuvy=(mod(uv.y,0.026+0.1*smoothstep(-.5,0.5,uv.y))-0.013-0.05*smoothstep(-.5,0.5,uv.y));\n    e=smoothstep(0.001,0.0051,abs(tuvy));\n    e=((step(uv.y,-0.109))*c*(1.-e*step(uv.y,-0.109)));\n    e*=step(abs(uv.x),0.5*smoothstep(animstart+1.5,animstart+3.,timer));\n    ret=max(ret,red*e);\n    tuv=uv;\n    tuv*=MD(3.3-sin(01.0-cos(2.0*smoothstep(animstart+4.25,animstart+5.5,timer))));\n    tuv+=vec2(0.35521,0.);\n    float f=1.-circle(tuv,0.0270,0.35,true);\n    ret=max(ret,f*redw*(1.-lt));\n    tuv=uv;\n    tuv*=MD(-0.3+01.*smoothstep(animstart+2.,animstart+4.8,timer));\n    tuv+=vec2(0.2242,0.);\n    f=1.-circle(tuv,0.0570,0.35,true);\n    ret=max(ret*(1.-(1.-lt)*f),(1.-lt)*f*dark*(1.-lt));\n    ret=max(ret,strucb(uv,timer));\n    f*=animendfade(timer);\n    return max(dark,ret*animendfade(timer));\n}\n\nfloat animm(float timer) {\n    return smoothstep(animstart,animstart+1.5,timer);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    float Range = 10.;\n    float timer=mod(iTime,15.);\n    float Line_Smooth\t= animm(timer)*\n                          pow(smoothstep(Range,Range-.05,2.*Range*(abs(smoothstep(.0, Range,uv.x+.5 )-.5))),.2);\n\n    float ft=2000.;\n    float fx=rand(uv.x*.0031+.0005);\n    float am  =0.5000 * noise(fx, ft)\n                       +0.2500 * noise(fx, ft)\n                       +0.1250 * noise(fx, ft)\n                       +0.0625 * noise(fx, ft);\n\n    vec2 p=uv;\n    p.y+=((cos(.5*p.x-0.15))-.975)*animm(timer);\n    float lt  = line(vec2(p.x,p.y*2.+(am-.5)*.12*Line_Smooth), .005, .0, 2./iResolution.y);\n\n    vec3 line1 =  lt*dark;\n\n    vec3 retcol=vec3(0.);\n    retcol=postfx(uv,map(uv,lt,timer),0.75);\n    fragColor =vec4(retcol,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fWw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[38, 38, 59, 59, 113], [115, 115, 136, 136, 207], [209, 209, 232, 232, 326], [328, 328, 360, 360, 620], [622, 622, 679, 679, 763], [966, 966, 1024, 1024, 1254], [1330, 1330, 1365, 1365, 2272], [2274, 2274, 2316, 2316, 2416], [2468, 2468, 2500, 2500, 2561], [2563, 2563, 2605, 2605, 4550], [4552, 4552, 4578, 4578, 4634], [4636, 4636, 4693, 4693, 5531]]}
{"id": "tsBcDK", "name": "Nibbles.frag", "author": "maksy", "description": "Press SPACE to start or restart.\n\nResources used to make this game:\nhttps://www.shadertoy.com/view/MddGzf", "tags": ["2d", "game", "snake", "nibbles"], "likes": 5, "viewed": 426, "published": 3, "date": "1599160231", "time_retrieved": "2024-07-30T20:47:41.932069", "image_code": "// -1: game over\n//  0: game running\n//  1: game reseted (space pressed)\n//  2: game not started\nconst ivec2 txGameState  = ivec2(2, 0);\nconst ivec2 txApplePos   = ivec2(0, 1);\nconst ivec2 txHeadPos    = ivec2(5, 0);\nconst ivec2 txSize       = ivec2(0, 0);\nconst ivec2 txScore      = ivec2(4, 2);\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value ) {\n    const int maxDigits = 3;\n    if(abs(uv.y-0.5) < 0.5)\n    {\n        int iu = int(floor(uv.x));\n        if( iu >= 0 && iu < maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x); // (uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0, 5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n// Finds the distance of P from the line A to B.\nfloat sdSegment(in vec2 p, vec2 a, vec2 b) {\n    \n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n    \n    // Project ap onto ab.\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0); \n    \n    // Finds length of vec from p to the projection of p onto ab.\n\treturn length(ap - ab*h); \n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)  { \n       \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y ;\n    vec3 col = vec3(0.);\n \n    // Board\n    {\n    \tcol = 0.9*vec3(0.4,0.6,0.8)*(1.0-0.4*length(uv)); \n    }\n    \n    // Snake\n    {\n    \tint size = int(texelFetch(iChannel0, txSize, 0).x); \n        int i = 0;\n        while (i < size-1) {\n            vec4 start = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \n            vec4 end = texelFetch(iChannel0, txHeadPos + ivec2(i+1, 0), 0);        \n            \n        \tfor (int j = i; j < size; j++) {\n    \t\t\t            \n            \tvec4 nextPos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);                \t\n                if (int(nextPos.z) == 1) {\n                    break;\n                } else {\n                \tend = nextPos;\n                    i = j;\n                }\n            }\n                \n            float d = sdSegment(uv, start.xy, end.xy);    \n            \n            vec3 bcol = vec3(1.0,0.6,0.2);\n    \t\tfloat f = smoothstep(0.02, 0.003, d);\n            col = mix(col, bcol, f); \n            \n            i++;    \t\t\n        }\n    }\n    \n    // Borders\n    {\n        float d = sdSegment(uv, vec2(-1.5, 0.66), vec2(1.5, 0.66));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+0.9);\n        \n        d = sdSegment(uv, vec2(-1.5, -0.75), vec2(1.5, -0.75));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+0.9);\n        \n        d = sdSegment(uv, vec2(-1.5, 0.65), vec2(-1.5, -0.742));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+.9);\n        \n        d = sdSegment(uv, vec2(1.5, 0.65), vec2(1.5, -0.742));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+.9);\n    }\n    \n    // Apple\n    if (int(texelFetch(iChannel0, txGameState, 0).x) != 2) {\n        \n    \tvec2 applePos = texelFetch(iChannel0, txApplePos, 0).xy;\n    \tfloat d = sdCircle(uv-applePos, 0.01);      \n        vec3 acol = vec3(1.0, 0.3, 0.2);\n        col = mix(col, acol, smoothstep(0.015, 0.001, d));        \n    }\n    \n    // Score\n    {\n        int score = int(texelFetch(iChannel0, txScore, 0).x); \n        float f = float(PrintInt( (uv-vec2(-1.5, 0.75))*8.0, score));\n        col = mix(col, vec3(1.0,1.0,1.0), f);\n    }\n    \n    // GAME OVER\n    if (int(texelFetch(iChannel0, txGameState, 0).x) == -1) {\n    \tcol = mix(col, vec3(1.0,0.5,0.2), (0.5+0.5*sin(10.0*iTime)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int LEFT = 37;\nconst int UP = 38;\nconst int RIGHT = 39;\nconst int DOWN = 40;\nconst int SPACE = 32;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n// -1: game over\n//  0: game running\n//  1: game reseted (space pressed)\n//  2: game not started\nconst ivec2 txGameState  = ivec2(2, 0);\nconst ivec2 txApplePos   = ivec2(0, 1);\nconst ivec2 txSize       = ivec2(0, 0);\nconst ivec2 txDirection  = ivec2(1, 0);\nconst ivec2 txGrow       = ivec2(4, 1);\nconst ivec2 txScore      = ivec2(4, 2);\nconst ivec2 txHeadPos    = ivec2(5, 0);\n\nconst float gameSpeed = 0.32;\n\n// Writes a value into the given buffer if the current pixel is \n// located at the storage address.\nvoid write(inout vec4 buffer, in vec4 val, in ivec2 storageAddr, \n           in vec2 fragCoord) {\n    \n    if (storageAddr == ivec2(fragCoord)) {\n    \tbuffer = val;\n    }\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st, vec2(1.0,113.0)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y;\n    vec4 buff = texture(iChannel0, uv);   \n \n    int dir = RIGHT;\n    int size = int(texelFetch(iChannel0, txSize, 0).x);\n    int score = int(texelFetch(iChannel0, txScore, 0).x); \n    int gameState = int(texelFetch(iChannel0, txGameState, 0).x);\n    vec2 applePos = texelFetch(iChannel0, txApplePos, 0).xy;\n    vec4 headPos = texelFetch(iChannel0, txHeadPos, 0);\n   \n    for (int i = 0; i < size; i++) {\n    \tvec4 oldPos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \t \n        write(buff, oldPos, txHeadPos + ivec2(i, 0), fragCoord);\n    }\n    \n    // Start the game once SPACE pressed.\n    if (iFrame == 0) {\n    \tgameState = 2;\n    }\n    \n    if (keyClick(SPACE)) {\n    \tgameState = 1;\n    }\n    \n    // ============= GAME RUNNING =============\n    if (gameState == 0) {\n     \n        // Update the head position.\n        float dis = 0.05*gameSpeed*(iTimeDelta*60.0);\t\n\n        int oldDir = int(texelFetch(iChannel0, txDirection, 0).r); \n\n        if (keyClick(RIGHT) && oldDir != LEFT) {\n            dir = RIGHT;\n        } else if (keyClick(UP) && oldDir != DOWN) {\n            dir = UP;\n        } else if (keyClick(DOWN) && oldDir != UP) {\n            dir = DOWN;\n        } else if (keyClick(LEFT) && oldDir != RIGHT) {\n            dir = LEFT;\n        } else if (keyClick(RIGHT) && oldDir != LEFT) {\n            dir = RIGHT;\n        } else {\n            dir = oldDir;\n        }\n\n            \n        if (dir == UP) {\n            headPos.xy += vec2(0., dis);\n        } else if (dir == DOWN) {\n            headPos.xy += vec2(0., -dis);\n        } else if (dir == LEFT) {\n            headPos.xy += vec2(-dis, 0.0);\n        } else {\n            headPos.xy += vec2(dis, 0.0);\n        }\n\n        // Direction changed mark it.\n        if (dir != oldDir) {\n            headPos.z = 1.0;\n        }\n       \n        // If ate an apple, increase the length. \n        int grow = int(texelFetch(iChannel0, txGrow, 0).x);\n        if (grow != 0) {\n            size++;\n            grow--;\n        }\n        \n        float d = distance(headPos.xy, applePos);\n        if (d < 0.025) {\n            vec2 seed1 = texelFetch(iChannel0, txHeadPos + ivec2(size/2, 0), 0).xy;\n            vec2 seed2 = seed1.yx;\n                \n            float r1 = (random(seed1)-0.5) * 2.2;\n            float r2 = clamp((random(seed2)-0.5) * 2.0, -0.62, 0.62);\n            \n            applePos = vec2(r1, r2);\n            grow+=5;\n            score++;                                   \n        }\n        \n        write(buff, vec4(grow, 0., 0., 0.), txGrow, fragCoord);\n        \n        // Shift each element to make the snake move.\n        for (int i = 1; i < size; i++) {\n            vec4 oldPos = texelFetch(iChannel0, txHeadPos + ivec2(i-1, 0), 0);        \t \n            write(buff, oldPos, txHeadPos + ivec2(i, 0), fragCoord);\n        }\n        \n        // Test if hit a wall.\n        if (headPos.x > 1.48\n            || headPos.x < -1.48 \n            || headPos.y > 0.637\n            || headPos.y < -0.737) {\n            gameState = -1;   \t\n        }    \n\n        // Test if hit the own body.\n        for (int i = 1; i < size; i++) {\n            vec4 pos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);\n            float d = distance(headPos, pos);\n            if (d < 0.007) {\n                gameState = -1;\n            }\n        }\n    }\n    \n    // ============ RESET ========== \n    if (gameState == 1) { \n   \n        size = 10;\n        score = 0;\n        applePos = vec2(0.3, 0.1);\n               \n        dir = RIGHT;   \n        float dis = 0.05*gameSpeed*(iTimeDelta*60.0);\n        float startPosX = 0.5-dis;\n\n        headPos = vec4(startPosX, 0.4, 0., 0.);\n        \n    \tfor (int i = 1; i < size; i++) {\n    \t\tvec4 pos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \t\n            \n            // z: 0 = no change of direction\n            pos = vec4(startPosX, 0.4, 0., 0.);\n        \n            write(buff, pos, txHeadPos + ivec2(i, 0), fragCoord);\n            startPosX -= dis;\n        }        \n        \n        gameState = 0;   \t\n    }\n       \n    write(buff, vec4(size, 0., 0., 0.), txSize, fragCoord);\n    write(buff, vec4(score, 0., 0., 0.), txScore, fragCoord);\n    write(buff, headPos, txHeadPos, fragCoord);\n    write(buff, vec4(applePos, 0., 0.), txApplePos, fragCoord);\n    write(buff, vec4(dir, 0, 0, 0), txDirection, fragCoord);    \n    write(buff, vec4(gameState, 0, 0, 0), txGameState, fragCoord);\n        \n    fragColor = buff;  \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 574, 574, 969], [971, 1020, 1064, 1064, 1294], [1296, 1296, 1335, 1335, 1363], [1365, 1365, 1421, 1421, 3773]]}
{"id": "3tBBRG", "name": "GaboryPerlin 3: solar flares", "author": "FabriceNeyret2", "description": "Cascaded version of Gabory Perlin (see [url]https://shadertoy.com/view/3lSfWW[/url] ).\nClick for multiplicative noise.\nUncomment line #53 for scale-dependent anisotropy. ", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 9, "viewed": 428, "published": 3, "date": "1599150363", "time_retrieved": "2024-07-30T20:47:42.727941", "image_code": "// variant of https://shadertoy.com/view/3tSBRG\n// variant of https://shadertoy.com/view/3lSfWW\n// inspired from https://shadertoy.com/view/WtBBD1\n\nfloat A = .2, // Anisotropy. 1 = isotropic\n      D = 0., // favorite dir\n  phase = 0.,\n phaseY = 0.,\n      K = 0.; // seed for random numbers\n//#define D atan((p).y,(p).x)\n\n  #define C(x)       ( .5+.5*cos(3.14* (x) ) )\n  #define cross(a,b) ( (a).x*(b).y - (a).y*(b).x )\n//#define rot(a)       mat2( cos( a + vec4(0,11,33,0) ) )\n  #define hash(p,K)    fract(sin(dot(p+K, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p)   ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)     cos( A/2.*6.28*hash(p,K) + vec2(0,11) + D + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n//#define l(i,j)       dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n\n  #define wave(v,x,f)  cos( 6.28*( 2.*dot(x,v) + f ) )\n//#define Gabor(v,x,f) wave(v,x,f) * exp(-.5*1.*dot(x,x) )\n//                     wave        *       ~Gaussian                        * structuring the gaussian / normalization of this ( see https://www.desmos.com/calculator/jejjp1xikd )\n//#define Gabor(v,x,f) wave(v,x,f) * C(dot(x,v))  *step(abs(dot(x,v))  ,1.) * C(dot(x,v)  -phaseY) / (.25 + C(phaseY)/2.)\n  #define Gabor(v,x,f) wave(v,x,f) * C(cross(x,v))*step(abs(cross(x,v)),1.) * C(cross(x,v)-phaseY) / (.25 + C(phaseY)/2.)\n\n  #define l(i,j)       Gabor( hash2(I+vec2(i,j)), F-vec2(i,j) , phase + hash(I+vec2(i,j),2.))       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)       mix( l(0,j), l(1,j), x )\n\n  #define V(p)         0.                           // flownoise rotation speed \n//#define V(p)       ( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p)         length(p)\n//#define V(p)       ( 8. - length(p) )\n\nfloat GaboryPerlin(vec2 p) {\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat layer(vec2 U) {\n#if 0\n    float v = GaboryPerlin( U );              // only 1 kernel\n#else\n    float v = 0., N = 4.;\n    for ( float i = 0.; i < 5.; i++, K+=.11 ) // sum N kernels\n        v += GaboryPerlin( U ); \n    v /= 2.*sqrt(N);\n    v *= mix(127./80.,127./50.,A)/2.; // try to regularize std-dev\n#endif \n    return v;\n}\n\nfloat cascade(vec2 U) {  // --- regular additive cascade\n    float v = 0., s = .5, A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v += layer(U)*s, U*=2., s/=2.;\n    return v;\n}\n\nfloat mul_cascade(vec2 U) { // --- multiplicativ cascade\n    float v = 1., A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v *= 1.+layer(U), U*=2.;\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S, I = floor(U);\n    \n    A = 0.;   // anisotropy\n    D = 6.28* cos(u.x/R.y+.3*iTime) * cos(u.y/R.y-.2*iTime); // fiber direction\n // phase  = iTime;  // phase, along the Gabor field direction \n // phaseY = iTime;  // orthophase, along the front direction\n    \n    U = U/8.;\n    float v = iMouse.z <= 0. \n        ? .5 + .5* cascade(U)\n        : mul_cascade(U) / 3.;\n    \n // v *= .01/fwidth(v);\n    O = v * vec4(2,1.3,1,1); // coloring\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1883, 1883, 1911, 1911, 2236], [2238, 2238, 2259, 2259, 2568], [2570, 2570, 2593, 2626, 2829], [2831, 2831, 2858, 2887, 3076], [3078, 3078, 3116, 3116, 3636]]}
{"id": "3tSBRG", "name": "GaboryPerlin 2", "author": "FabriceNeyret2", "description": "Cascaded version of Gabory Perlin (see [url]https://shadertoy.com/view/3lSfWW[/url] ).\nOscillate between isotropic and anisotropic along circles.\n\nClick for multiplicative noise.\nUncomment line #48 for scale-dependent anisotropy. ", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 12, "viewed": 386, "published": 3, "date": "1599148728", "time_retrieved": "2024-07-30T20:47:43.488906", "image_code": "// variant of https://shadertoy.com/view/3lSfWW\n// inspired from https://shadertoy.com/view/WtBBD1\n\nfloat A = .2, // Anisotropy. 1 = isotropic\n      D = 0., // favorite dir\n      K = 0.; // seed for random numbers\n//#define D atan((p).y,(p).x)\n\n//#define rot(a)       mat2( cos( a + vec4(0,11,33,0) ) )\n  #define hash(p,K)    fract(sin(dot(p+K, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( A/2.*6.28*hash(p,K) + vec2(0,11) + D + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n//#define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define Gabor(v,x,f)   cos( 6.28*( 2.*dot(x,v) + f ) ) * exp(-.5*1.*dot(x,x) )\n  #define l(i,j)     Gabor( hash2(I+vec2(i,j)), F-vec2(i,j) , hash(I+vec2(i,j),2.))       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 0.                                // flownoise rotation speed \n//#define V(p) 1.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat GaboryPerlin(vec2 p) {\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat layer(vec2 U) {\n#if 0\n    float v = GaboryPerlin( U );             // only 1 kernel\n#else\n    float v = 0., N = 4.;\n    for ( float i = 0.; i < 5.; i++, K+=.1 ) // sum N kernels\n        v += GaboryPerlin( U ); \n    v /= 2.*sqrt(N);\n    v *= mix(127./80.,127./50.,A)/2.; // try to regularize std-dev\n#endif \n    return v;\n}\n\nfloat cascade(vec2 U) {  // --- regular additive cascade\n    float v = 0., s = .5, A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v += layer(U)*s, U*=2., s/=2.;\n    return v;\n}\n\nfloat mul_cascade(vec2 U) { // --- multiplicativ cascade\n    float v = 1., A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v *= 1.+layer(U), U*=2.;\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S, I = floor(U);\n    \n    A = .5+.5*sin(iTime);   // anisotropy\n  //A = mix(1.,A, dot(I,I));\n  //A = abs( length(I)*2.-1.);\n  //D = atan(U.y,U.x);      // prefered direction\n    D = 2.*3.14 * cos(u.x/R.y) * cos(u.y/R.y);\n    \n // float v = .5+.5*layer(U); O = vec4(v); return;\n    float v = iMouse.z <= 0. \n        ? .5 + .5* cascade(U/8.)\n        : mul_cascade(U/8.) / 3.;\n    \n\n    O = v * vec4(1,1.2,1.7,1); // coloring\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1212, 1212, 1240, 1240, 1565], [1567, 1567, 1588, 1588, 1895], [1897, 1897, 1920, 1953, 2156], [2158, 2158, 2185, 2214, 2403], [2405, 2405, 2443, 2443, 2950]]}
{"id": "wljfDw", "name": "Geometric Paper Pattern", "author": "Shane", "description": "A geometric pencil sketch pattern rendered onto some animated hanging paper.", "tags": ["wall", "truchet", "sketch", "pencil", "paper", "art"], "likes": 73, "viewed": 1111, "published": 3, "date": "1599146410", "time_retrieved": "2024-07-30T20:47:44.467290", "image_code": "/*\n\n\tGeometric Paper Pattern\n    -----------------------\n\n    A geometric pattern rendered onto some animated hanging paper, which for some \n    inexplicable and physics defying reason is also animated. :D\n\n\tI put this together out of sheer boredom, and I didn't spend a lot of time on \n    it, so I wouldn't look too much into the inner workings, especially not the \n\tphysics aspects... I honestly couldn't tell you why the paper is waving around \n\tlike that. :)\n\n\tThe pattern is about as basic as it gets. I've used some equally basic post\n    processing to give it a slightly hand drawn look. The pencil algorithm I've\n\tused is just a few lines, and is based on one of Flockaroo's more sophisticated\n\texamples. The link is below, for anyone interested. At some stage, I'd like\n    to put a sketch algorithm out that is more hatch-like.\n\n    On a side note, for anyone who likes small functions, feel free to take a look \n    at the \"n2D\" value noise function. I wrote it ages ago (also when I was bored) \n    and have taken it as far as I can take it. However, I've often wondered whether \n    some clever soul out there could write a more compact one.\n\n\n\n\n\tRelated examples:\n\n    // A more sophisticated pencil sketch algorithm.\n    When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n\n*/\n\n// For those who find the default pattern just a little too abstract and minimal,\n// here's another slighly less abstract minimal pattern. :D\n//#define LINE_TRUCHET\n\n// I felt the pattern wasn't artistic enough, so I added some tiny holes. :)\n#define HOLES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's box formula -- modified for smoothing.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n    \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\nfloat distField(vec2 p){\n    \n    // Cell ID and local cell coordinates.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Some random numbers.\n    float rnd = hash21(ip + .37);\n    float rnd2 = hash21(ip + .23);\n    float rnd3 = hash21(ip + .72);\n \n    \n    // Cell boundary.\n    float bound = sBox(p, vec2(.5)); \n    \n    \n    float d = 1e5; // Distance field.\n    \n    // Random 90 degree cell rotation.\n    p *= rot2(floor(rnd*64.)*3.14159/2.);\n    \n     \n    // Just adding a tiny hole to draw the eye to the... No idea why artists do \n    // this kind of thing, but it enables them to double the price, so it's\n    // definitely worth the two second effort. :)\n    float hole = 1e5;\n    \n    \n    #ifdef LINE_TRUCHET\n    \n    // Three tiled Truchet pattern consisting of arc, straight line \n    // and dotted tiles.\n    \n    // Four corner circles.\n    vec2 q = abs(p);\n    float cir = min(length(q - vec2(0, .5)), length(q - vec2(.5, 0)));\n    \n    if(rnd3<.75){\n        if(rnd2<.65){\n            d = abs(min(length(p - .5), length(p + .5)) -.5) - .5/3.;\n            \n        }\n        else {\n            p = abs(p) - .5/3.;\n            d = min(max(p.x, -(p.y - .5/8.)), p.y);\n        }\n        \n    }\n    else {\n        // Four dots in the empty squares to complete the pattern.\n        d = cir - .5/3.;\n    }\n    \n    // Corner holes.\n    hole = cir -.05;\n    \n    #else\n    // Very common quarter arc and triangle Truchet pattern, which is a \n    // favorite amongst the abstract art crowd.\n    if(rnd3<.75){;\n        \n        // Corner holes.\n        hole = length(p - .325) - .05;\n                 \n        if(rnd2<.5){\n            // Corner quarter circle... Well, it's a full one,\n            // but it gets cut off at the grid boundaries.\n            d = length(p - .5) - 1.;\n        }\n        else {\n            // A corner diamond, but we'll only see the triangular part.\n            p = abs(p - .5);\n            d = abs(p.x + p.y)/sqrt(2.) - .7071;\n        }\n    }\n    #endif\n    \n    #ifdef HOLES\n    d = max(d, -hole);\n    #endif\n    \n    // Cap to the cell boundaries. Sometimes, you have to do this\n    // to stop rendering out of bounds, or if you wish to include\n    // boundary lines in the rendering.\n    //\n    return max(d, bound);\n}\n\n// Cell grid borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    p = abs(p);\n    float grid = abs(max(p.x, p.y) - .5) - .005;\n    \n    return grid;\n}\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    //ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scaling factor.\n    float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y*gSc;\n    \n    // Unperturbed coordinates.\n    vec2 pBg = uv*gSc; \n    \n    vec2 offs = vec2(fbm(uv/1. + iTime/4.), fbm(uv/1. + iTime/4. + .35));\n    const float oFct = .04;\n    uv -= (offs - .5)*oFct;\n    \n    // Scaled perturbed coordinates.. \n    vec2 p = uv*gSc;\n    \n    \n    // The paper distance field.\n    vec2 fw = vec2(6, 3);\n    float bw = 1./3.;\n    float paper = sBoxS(p, fw + bw, .05);\n  \n    // Mixing the static background coordinates with the wavy offset ones to\n    // save calculating two functions for various things.\n    vec2 pMix = mix(p, pBg, smoothstep(0., sf, paper));\n\n    // Failed experiment with a moving pattern.\n    //vec2 rnd22 = vec2(hash21(ip + 1.6), hash21(ip + 2.6));\n    //rnd22 = smoothstep(.9, .97, sin(6.2831*rnd22 + iTime/2.));\n    //float d = distField(p + rnd22);\n    \n    // The geometric pattern field.\n    float d = distField(pMix);\n    \n    // Canvas pattern square ID.\n    vec2 ip = floor(p) + .5;\n    \n    // Background. Nothing exciting, but theres' a subtle vertical gradient\n    // to mimic an overhead light, or something to that effect.\n    vec3 bg = vec3(.9, .82, .74)*.85;\n    bg = mix(bg, bg*.9, -uv.y*.5 + .5);\n    \n    // Initialize the scene color to the background.\n    vec3 col = bg;\n    \n   \n    // Using the pattern distance field for a subtle background wall overlay.\n    // Back in the old days (the 90s), you'd reuse whatever you could.\n    col = mix(col, bg*.92, 1. - smoothstep(0., sf, d));\n    col = mix(col, bg*.96, 1. - smoothstep(0., sf, d + .03)); \n    \n  \n    // The paper shadow distance field and application.\n    vec2 shOff = normalize(vec2(1, -3))*.1;\n    float dSh = sBoxS(p - shOff, fw + bw, .05);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dSh))*.5);\n    \n    // Paper rendering.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper))*.1); \n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, paper + .02))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper + bw))); \n    \n    \n    /*\n    // Distance field-based lines on the canvas. I tried a few quick things\n    // for this example, and unfortunately, not a lot worked, but I've left\n    // the workings in for anyone who wants to play around with this.\n    const float lnN = 8.; // Number of concentric pattern lines.\n    float pat = abs(fract(d*lnN*1. - .5) - .5)*2. - .05;\n    pat = smoothstep(0., sf*lnN*2., pat)*.65 + .35;\n    */\n    \n    \n    // Random animated background color for each square.\n    float rndC = hash21(ip + .23);\n    rndC = sin(6.2831*rndC + iTime/2.);   \n    vec3 sqCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2)); // IQ's palette.\n    col = mix(col, sqCol, (1. - smoothstep(0., sf, paper + bw + .0))); \n\n\n    // Render a colored Truchet pattern in one of two styles.\n    \n    // Restrict pattern rendering to the canvas.\n    d = max(d, (paper + bw));\n    \n \n    // IQ's really cool, and simple, palette.\n    vec3 shCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2) + 1.);\n\n    // Subtle drop shadow, edge and coloring.\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf*4., d))*.5);\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf, d)));\n    col = mix(col, shCol, (1. - smoothstep(0., sf, d + .02)));\n\n    \n    // Adding in some blinking offset color, just to mix things up a little.\n    rndC = hash21(ip + .87);\n    rndC = smoothstep(.8, .9, sin(6.2831*rndC + iTime*2.)*.5 + .5);\n    vec3 colB = mix(col, col.xzy, rndC/2.);\n    col = mix(col, colB, 1. - smoothstep(0., sf, paper + bw));\n    \n    \n        \n    // Putting some subtle layerd noise onto the wall and paper.\n    col *= fbm(pMix*48.)*.2 + .9;\n    \n    \n \n    // Grid lines on the canvas.\n    float grid = gridField(p);\n    grid = max(grid, paper + bw);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., grid))*.5);\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n\n    /*\n    // Circles on the pattern... Too busy looking.\n    vec3 svC = col/2.;\n    float cir = length(p - ip) - .1;\n    cir = max(cir, bord + bw);\n    col = mix(col, bg*.07, (1. - smoothstep(0., sf, cir)));\n    //col = mix(col, svC, (1. - smoothstep(0., sf, cir + .02)));\n    */  \n   \n \n    \n    // Recalculating UV with no offset to use with postprocessing effects. \n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y; \n\n    float canv = smoothstep(0., sf*2., (paper + bw));\n    float canvBord = smoothstep(0., sf*2., (paper));\n\n    /*\n    // Corduroy lines... Interesting texture, but I'm leaving it out.\n    vec2 q3 = mix(uv, p/gSc, 1. - (canvBord));\n    float lnPat = abs(fract((q3.x - q3.y)*80.) - .5)*2. - .01;\n    float frM = smoothstep(0., sf, max(paper, -(paper + bw)));\n    lnPat = smoothstep(0., sf*80./2., lnPat);\n    col = mix(col, col*(lnPat*.25 + .75), frM);\n    */\n    \n    \n    // Boring, and admittedly, inefficient hanger and string calculations, etc.\n    // A lot of it is made up on the spot. However, at the end of the day, this\n    // is a pretty cheap example, so it'll do.\n    vec2 q2 = uv;\n    q2.x = mod(q2.x, 1.) - .5;\n    q2 -= (offs - .5)*oFct + vec2(0, (3. + bw*.9)/gSc);\n    // String, and string shadow. \n    float strg = lBox(q2, vec2(0), vec2(0, .5) - (offs - .5)*oFct, .002);\n    float strgSh = lBox(q2 - shOff*.5,  vec2(0, .04), vec2(0, .5) - (offs - .5)*oFct, .002);\n    // Rendering the strings and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, strgSh))*.25);\n    col = mix(col, vec3(.5, .4, .3), (1. - smoothstep(0., sf/gSc/2., strg)));\n    // The little black hangers and corresponding shadow.\n    float hang = sBoxS(q2, vec2(1, .5)*bw/gSc, .0);\n    float hangBk = sBoxS(q2, vec2(1. + .05, .5)*bw/gSc, .0);\n    float hangBkSh = sBoxS(q2 - vec2(.008, -.004), vec2(1. + .06, .5)*bw/gSc, .0);\n    hangBk = max(hangBk, -paper);\n    hangBkSh = max(hangBkSh, -paper);\n    float hangSh = sBoxS(q2 - shOff*.1, vec2(1, .5)*bw/gSc, .0);\n    // Rendering the hangers and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangBkSh))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangSh))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hangBk)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hang)));\n    col = mix(col, bg*oFct, 1. - smoothstep(0., sf/gSc, hang + .004));\n    \n    \n   \n\n    // Adding very subtle lighting to the wavy pattern... So subtle that it's\n    // barely worth the effort, but it's done now. :)\n    float eps = .01;\n    vec2 offs2 = vec2(fbm(uv/1. + iTime/4. - eps), fbm(uv/1. + iTime/4. + .35 - eps));\n    float z = max(dot(vec3(0, 1, -.5), vec3(offs2 - offs, eps)), 0.)/eps;\n    col *= mix(1., .9 + z*.1, 1. - canvBord);\n   \n\n     \n    // Subtle pencel overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = mix(uv*gSc*2., p, 1. - (canvBord));\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    //col *= colP*.8 + .5; \n    col *= mix(vec3(1), colP*.8 + .5, .8);\n    //col = colP; \n    \n    \n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 oP = floor(p/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    vec3 pg = .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    col *= mix(vec3(1), pg, 1. - canv);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1582, 1615, 1637, 1637, 1695], [1698, 1726, 1747, 1747, 1832], [1834, 1881, 1928, 1928, 2025], [2027, 2048, 2081, 2081, 2165], [2167, 2406, 2451, 2451, 2616], [2618, 2618, 2642, 2690, 4883], [4885, 4907, 4931, 4931, 5072], [5074, 5142, 5160, 5267, 5771], [5773, 5851, 5869, 5869, 5942], [5945, 5945, 5975, 6740, 8048], [8050, 8050, 8104, 8152, 15698]]}
{"id": "tljfWw", "name": "beach sun", "author": "qzh", "description": "the beach,but unfinished", "tags": ["beach"], "likes": 4, "viewed": 397, "published": 3, "date": "1599127322", "time_retrieved": "2024-07-30T20:47:45.231248", "image_code": "\nvec3 drawTree(vec2 uvTree,vec2 point,vec3 col){\n\tvec2 q=uvTree-point;\n    float p=length(q);\n    \n    //画半径 atan返回q.y/q.x的arctan值域-pi到pi\n    //反切值乘10是为了cos值增加更多循环（-1，1）每多一个循环就会多一个花瓣\n    //cos参数增加 导致图像向右平移\n    float r=0.05+0.03*cos(atan(q.y,q.x)*10.0+q.x*50.0-2.);\n    \n    //根据半径画圆\n    col*=smoothstep(r,r+0.01,p);\n    \n    float d=0.005;\n    float h=0.5;\n    //得出一条竖线*只要下面部分变黑\n    //col*=smoothstep(d,d+0.001,abs(q.x))*smoothstep(0.0,0.1,q.y);\n    //和上面做法类似\n   \td+=0.001*cos(q.y*100.0);\n    //指数型 当参数小于0 值永远小于1呈曲线无线接近1\n    d+=exp(-70.0*uvTree.y);\n    //\n    col*=1.0-(1.0-smoothstep(d,d+0.001,abs(q.x+0.05*sin(q.y*5.0))))*(1.0-smoothstep(0.0,0.01,q.y));\n    return col;\n}\n\nvec3 drawsea(vec2 uvMan,vec3 col){\n    \n    //高度cos偏移\n    float h=.05+0.02*cos(uvMan.x*20.0+iTime);\n\t    \n    col=mix(vec3(.3,.8,.9),col,smoothstep(h,h+.01,uvMan.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvTree=uv;\n    \n\t//使uv的y值保持屏幕的比例 用来画出一个正圆\n    uv.y*=iResolution.y/iResolution.x;\n    vec2 uvMan=uv;\n    vec3 col=vec3(1.0,0.65,0);\n    //定义太阳半径和光晕\n    float over=0.02/length(uv-vec2(0.9,0.48));\n    //光晕散开\n    float dist=pow(over,0.3);\n    col*=dist;\n    col=drawsea(uvMan,col);\n\n    vec2 point1=vec2(0.85,0.4);\n    vec2 point2=vec2(0.75,0.35);\n\tcol=drawTree(uvTree,point1,col);\n    col=drawTree(uvTree,point2,col);\n    \n    \n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 869], [871, 871, 905, 932, 1063], [1065, 1065, 1122, 1172, 1739]]}
{"id": "ttjfWw", "name": "Nebula 12", "author": "Leria", "description": "Nebula", "tags": ["fractal", "noise", "raymarch", "perlin", "stars", "nebula"], "likes": 4, "viewed": 476, "published": 3, "date": "1599126820", "time_retrieved": "2024-07-30T20:47:46.200656", "image_code": "// Fork of \"Nebula - 5\" by Leria. https://shadertoy.com/view/wtSfDD\n// 2020-09-03 09:50:09\n\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t0\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.2\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 8.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n            \n            \n            float rad_bubl = RADIUS/2.1; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,rad_bubl);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);             \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n            float dispersion_rate = fbm( ( p+(cos(Psnoise(p/8.) ) ) ) ); //local dispersion rate\n            \n\n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate); //modify  to tune the local velocity, 1.60 is a precalculated value\n            //velocity\n            #define VT\tvelocity            \n           \n            //energy\n            float energy = .5*(VT*VT*VT)/rad_bubl; //energy transfer rate\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n\n\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = ( Psnoise( (p-pB+dp)*l) + energy)*(max(0.,d)*l) ;\n            \n\n\n            float mask = smoothstep(0.,\n                                    10.*RADIUS,\n                                  \t(RADIUS-length(center)));// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );            \n            \n             vec3 prof = vec3(1.,2.1,2.2)*k*dens;\n             vec3 rgb_t = exp(-prof);    \n            \n            vec3 col_loc = vec3(1.,sin(f(p.y)),1.);\n            \n#if 0  // 1: color via albedo   0: color via transparency\n            //col_loc = rgb_t / (1e-3+max(rgb_t.r,max(rgb_t.g,rgb_t.b)));\n            rgb_t = vec3((rgb_t.r+rgb_t.g+rgb_t.b)/3.);\n            prof = vec3(-log(1e-3+rgb_t));\n#endif\n    \n            float sun = 1./size+0.25,\n                shadow = 1.,\n                reflec = .4;\n#if 1           \n            shadow = t_acc.b;  // assuming I'm the light :-p\n#endif\n            \n    \t\t//blending\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);           \n#endif\n        }\n\n        if(sdf_ellips(p, vec3(RADIUS, 2.*RADIUS, 2.*RADIUS)) < 0.)\n        {\n         \tfloat n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = Psnoise( (p));\n            \n\n\n            float mask = smoothstep(0.,\n                                    10.*RADIUS,\n                                  \t(RADIUS-length(center)));// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );            \n            \n             vec3 prof = vec3(1.,2.1,2.2)*k*dens;\n        }\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n    #if COLOR\n     //  c += t_acc*vec3(0,0,1);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .8* pow(texture(iChannel0,fragCoord*2./360.+ vec2(degree,degree2)).rrr, vec3(5));\n    color += transp_tot * sky;\n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n    \nfloat sdf_ellips( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1544, 1544, 1569, 1582, 1948], [1950, 1950, 1975, 1988, 2333], [2335, 2335, 2354, 2354, 2447], [2449, 2468, 2544, 2544, 2591], [2593, 2593, 2625, 2625, 2645], [2647, 2647, 2681, 2681, 2703], [2790, 2790, 2831, 2831, 2867], [2869, 2869, 2955, 2955, 2990], [2992, 2992, 3035, 3035, 3075], [3077, 3077, 3101, 3101, 3149], [3151, 3151, 3191, 3191, 3495], [3497, 3497, 3521, 3521, 3584], [3587, 3587, 3662, 3662, 8150], [8153, 8153, 8210, 8210, 9020]]}
{"id": "Wt2fDw", "name": "Wicked isometry", "author": "illus0r", "description": "Wicked isometry", "tags": ["raymarchingisometry"], "likes": 8, "viewed": 313, "published": 3, "date": "1599087464", "time_retrieved": "2024-07-30T20:47:46.965611", "image_code": "\n#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define EPSILON 0.00001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define LIGHT 5.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 1.1)\n\n#define N 6\n\nfloat rnd (float x) {return fract(10000. * sin(10000. * x));}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 boxTexture(vec3 p, float id) {\n    if (p.x + -p.z < 0.) {\n        p.xz = p.zx;\n        id += 1.;//1000. * rnd(id);\n    }\n    id = floor(id);\n    id = mod(id, 52.);\n    float col = mod(id, 10.);\n    float row = id - col;\n    p.x -= col * 2.;\n    p.y -= row * 2.;\n    p.xy -= 1.;\n    p.xy *= .05;\n    return vec3(1);//texture(iChannel0, p.xy).rgb;\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    float w = 0.5;\n    vec2 step = vec2(2);\n\n    p.xz *= Rot(0.3 * sin(iTime + length(p.xz))); \n\n    p.xz = mod(p.xz, step);\n    p.xz -= step / 2.;\n\n    p.xz *= Rot(iTime);\n    p.zy *= Rot(PI / 4.);\n    p.xz *= Rot(PI / 4.);\n    float box1 = sdBox(p, vec3(w));\n    float obj = min(box1, box1);\n    return vec2(obj * .6, RED);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float step = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        step ++;\n        // volumeLight += .01;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, step);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(uv.x, 10, uv.y) * 10.;\n    // ro.yz *= Rot(PI / 4.);\n    // ro.xz *= Rot(-PI / 4.);\n    // ro += vec3(-2, 2, -2);\n    // ro.xz *= Rot(iTime);\n\n    // vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    // vec3 lookat = vec3(0, 0, 0);\n    // lookat.xz *= Rot(angle.x);\n    // lookat.yz *= Rot(angle.y);\n\n    vec3 rd = normalize(vec3(0, -1, 0));\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(0);\n    vec3 light = vec3(13, 4, 10);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring \n        if (d < MAX_DIST) {\n           if (info == RED) {\n                color = boxTexture(p, iTime) + .1;\n                color *= dot(dirToLight, n) * .5 + .5;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 299, 299, 339], [341, 341, 360, 360, 423], [425, 425, 456, 456, 543], [545, 545, 580, 580, 897], [900, 979, 1001, 1001, 1329], [1414, 1414, 1447, 1447, 1859], [1861, 1861, 1885, 1885, 2103], [2105, 2105, 2159, 2159, 2386], [2388, 2388, 2438, 2438, 2629], [2642, 2642, 2698, 2698, 4568]]}
{"id": "WtjfDw", "name": "Lyapunov fractal explorer", "author": "zzggbb", "description": "https://en.wikipedia.org/wiki/Lyapunov_fractal\n\nW: pan up\nA: pan left\nS: pan down\nD: pan right\nQ: zoom in\nE: zoom out\nR: reset pan and zoom to default position", "tags": ["fractal", "lyapunov"], "likes": 1, "viewed": 198, "published": 3, "date": "1599084984", "time_retrieved": "2024-07-30T20:47:47.944992", "image_code": "#define VIEW_STATE_2D iChannel0\n\n// number of iterations. larger is more accurate\n#define N 100.0\n\n// The iteration sequence, which defines the image\n// This can be any sequence of 1s, 2s and 3s \n// Examples: 1 12 22 121221 212122\n//#define S 1222121\n#define S 2122312\n\n#define MAP_LOGISTIC 0\n#define MAP_GAUSS 1\n#define MAP_FUNC MAP_GAUSS\n\n#define LYAPUNOV_PRODUCT 0\n#define LYAPUNOV_SUM 1\n#define LYAPUNOV_TYPE LYAPUNOV_SUM\n\nfloat get_growth_degree(float n, float a, float b, float c, float S_length) {\n    float S_index = mod(n, S_length);\n\tfloat S_n = floor(mod(float(S) / pow(10.0, S_index), 10.0));\n    if (S_n == 1.0) return a;\n    if (S_n == 2.0) return b;\n    if (S_n == 3.0) return c;\n}\n\nvec3 get_color(float lambda) {\n    if (lambda > 0.0) \n        // chaos\n        return BLACK;\n    else if (lambda == 0.0) \n        return BLUE;\n    else\n      \t// stabiity  \n        return color_palette(ninf2one(lambda, 5.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = texelFetch(VIEW_STATE_2D, ivec2(3,0), 0).x;\n    vec2 pan = vec2(\n        texelFetch(VIEW_STATE_2D, ivec2(0,0), 0).x,\n        texelFetch(VIEW_STATE_2D, ivec2(1,0), 0).x\n    );\n    \n    vec2 uv = fragCoord.xy/min(iResolution.x, iResolution.y);\n    vec2 uvo = 0.5*iResolution.xy/min(iResolution.x, iResolution.y);\n    uv = (uv - uvo) * zoom;\n    uv = uv - pan;\n    \n    float a = uv.x;\n    float b = uv.y;\n    \n    float S_length = floor(log(float(S)) / log(10.0)) + 1.0;\n    \n    float c = osc(iTime*0.5, -1.0, 1.0);\n    \n    #if LYAPUNOV_TYPE == LYAPUNOV_SUM\n        float sum = 0.0;\n    #elif LYAPUNOV_TYPE == LYAPUNOV_PRODUCT\n        float product = 1.0;\n    #endif\n    \n    #if MAP_FUNC == MAP_LOGISTIC\n        float x = 0.5;\n        float r;\n        for (float n=1.0; n<N; n++) {\n            r = get_growth_degree(n, a, b, c, S_length);\n            x = r * x * (1.0 - x);\n            #if LYAPUNOV_TYPE == LYAPUNOV_SUM\n                sum += log(abs(r * (1.0 - 2.0*x)));\n            #elif LYAPUNOV_TYPE == LYAPUNOV_PRODUCT\n                product *= abs(r * (1.0 - 2.0*x));\n            #endif\n        }\n    #elif MAP_FUNC == MAP_GAUSS\n        float x = 0.01;\n        float alpha = 4.9;\n        float beta;\n        for (float n=1.0; n<N; n++) {\n            beta = get_growth_degree(n, a, b, c, S_length);\n            x = exp(-alpha*x*x) + beta;\n            #if LYAPUNOV_TYPE == LYAPUNOV_SUM\n                sum += log(abs(-2.0*alpha*x*exp(-alpha*x*x)));\n            #elif LYAPUNOV_TYPE == LYAPUNOV_PRODUCT\n                product *= abs(-2.0*alpha*x*exp(-alpha*x*x));\n            #endif\n        }\n    #endif\n    #if LYAPUNOV_TYPE == LYAPUNOV_SUM\n        float lambda = sum / N;\n    #elif LYAPUNOV_TYPE == LYAPUNOV_PRODUCT\n        float lambda = log(product) / N;\n    #endif\n    vec3 color = get_color(lambda);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// *CHANNEL_TITLE* VIEW_STATE_2D  \n\n#define SELF iChannel0\n#define KEYBOARD iChannel1\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n\n#define INITIAL_X_PAN 0.5\n#define INITIAL_Y_PAN 0.4\n\n#define INITIAL_ZOOM 2.0\n#define ZOOM_IN_LIMIT 0.005\n#define ZOOM_OUT_LIMIT 10.0\n\n#define PAN_SPEED 1.0\n#define ZOOM_SPEED 50.0\n\n/*\nW to pan up\nA to pan left\nS to pan down\nD to pan right\nQ to zoom in\nE to zoom out\n\nAt (0,0).x, we store left-right pan\nAt (1,0).x, we store up-down pan\nAt (3,0).x, we store zoom\n*/\n\nfloat get_key(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x;\n}\n\nvoid mainImage(out vec4 input_state, in vec2 fragCoord){\n    ivec2 xy = ivec2(fragCoord);\n    vec4 current_value = texelFetch(SELF, xy, 0);\n    float current_zoom = texelFetch(SELF, ivec2(3,0), 0).x;\n    float new_value = current_value.x;\n    if (xy == ivec2(0,0)) {\n        // left-right pan\n        if (current_value.y == 0.0 || get_key(KEY_R) == 1.0) {\n            new_value = INITIAL_X_PAN;\n        } else {\n            float dx = (iTimeDelta*PAN_SPEED)*(get_key(KEY_A) - get_key(KEY_D));\n            new_value = current_value.x + dx*current_zoom;\n        }\n    }\n    else if (xy == ivec2(1,0)) {\n        // up-down pan\n        if (current_value.y == 0.0 || get_key(KEY_R) == 1.0) {\n            new_value = INITIAL_Y_PAN;\n        } else {\n            float dy = (iTimeDelta*PAN_SPEED)*(get_key(KEY_S) - get_key(KEY_W));\n            new_value = current_value.x + dy*current_zoom;\n        }\n    }\n    else if (xy == ivec2(3,0)) {\n        // zoom\n        if (current_value.y == 0.0 || get_key(KEY_R) == 1.0) {\n            new_value = INITIAL_ZOOM;\n        } else {\n            if (get_key(KEY_Q) == 1.0 && get_key(KEY_E) == 1.0) {\n                /* do nothing */\n            } else if (get_key(KEY_E) == 1.0) {\n                new_value = current_value.x*1.1;\n            } else if (get_key(KEY_Q) == 1.0) {\n                new_value = current_value.x*0.9;\n            }\n            new_value = clamp(new_value, ZOOM_IN_LIMIT, ZOOM_OUT_LIMIT);\n        }\n    }\n    input_state = vec4(new_value, 1.0, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW (RED+GREEN)\n\nvec3 color_palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b*cos(2.0*PI*(c*t + d));\n}\n\nfloat inf2one(float x, float q) {\n    // scale [0..∞] -> [0..1]\n    // q determines how quickly the output approaches 1.0\n    return 1.0-1.0/(q*x+1.0);\n}\nfloat ninf2one(float x, float q) {\n    // scale [-∞..0] -> [1..0]\n    return 1.0+1.0/(q*x-1.0);\n}\n\nvec2 linscale(vec2 p, vec2 p1, vec2 p2, vec2 s1, vec2 s2) {\n\treturn (s2 - s1) / (p2 - p1) * (p - p2) + s2;\n}\n\nfloat linscale(float p, float p1, float p2, float s1, float s2) {\n\treturn (s2 - s1) / (p2 - p1) * (p - p2) + s2;\n}\n\nfloat osc(float t, float m, float M) {\n\treturn linscale(sin(t), -1.0, 1.0, m, M);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 504, 504, 696], [698, 698, 728, 728, 925], [927, 927, 982, 982, 2845]]}
{"id": "wtSfDw", "name": "Nebula 11", "author": "Leria", "description": "Galactic dust nebula", "tags": ["fractal", "noise", "nebula", "blue", "purple"], "likes": 10, "viewed": 503, "published": 3, "date": "1599064110", "time_retrieved": "2024-07-30T20:47:48.938336", "image_code": "// 2020-08-25 15:03:34\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.1\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 4.5), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float et = 0.;\n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n            \n            \n            float rad_bubl = RADIUS/3.; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,0);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n\n\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = ( Psnoise( (p-pB+dp)*l))*(max(0.,d)*l) ;\n            \n\n\n            float mask = smoothstep(0.,\n                                    10.*RADIUS,\n                                  \t((length(cam.pos - p)+length(center)))\n                                    );// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float scalar_p = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );            \n            \n            float dispersion_rate = scalar_p*fbm(p);\n            \n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate);\n            #define VT velocity\n            \n            //energy \n            \n            float energy = .5*(VT*VT*VT)/rad_bubl;\n#define INT_E(v)\t(.5*(v*v*v*v)/(4.*rad_bubl))\n            \n            if(et == 0.)\n                et = velocity;\n            \n#define PREINT_E(d0, d1)\t((INT_E(d0)-INT_E(d1))/(d1-d0))          \n            \n                                    \n             vec3 prof = vec3(0.);\n            prof = vec3(1.,2.1,5.2)*k*energy;\n            \n            vec3 rgb_t = exp(-prof);    \n            \n            vec3 col_loc = vec3(1.,(f(p.y)),1.);\n            \n#if 0  // 1: color via albedo   0: color via transparency\n            //col_loc = rgb_t / (1e-3+max(rgb_t.r,max(rgb_t.g,rgb_t.b)));\n            rgb_t = vec3((rgb_t.r+rgb_t.g+rgb_t.b)/3.);\n            prof = vec3(-log(1e-3+rgb_t));\n#endif\n    \n            float sun = 1./size,\n                shadow = 1.,\n                reflec = 1.;\n#if 1           \n            shadow = t_acc.b;  // assuming I'm the light :-p\n#endif\n            \n    \t\t//blending\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n    #if COLOR\n     //  c += t_acc*vec3(0,0,1);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(iTime/2.); C.yz *= rot2(m.y);\n    R.xz *= rot2(iTime/2.); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .8*pow(texture(iChannel0,fragCoord/360.+vec2(degree,degree2)).rrr, vec3(200));\n    color += transp_tot * sky;\n        \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1475, 1475, 1500, 1513, 1879], [1881, 1881, 1906, 1919, 2264], [2266, 2266, 2285, 2285, 2378], [2380, 2399, 2475, 2475, 2522], [2524, 2524, 2556, 2556, 2576], [2578, 2578, 2612, 2612, 2634], [2721, 2721, 2762, 2762, 2798], [2800, 2800, 2886, 2886, 2921], [2923, 2923, 2966, 2966, 3006], [3008, 3008, 3032, 3032, 3080], [3082, 3082, 3122, 3122, 3426], [3428, 3428, 3452, 3452, 3516], [3519, 3519, 3594, 3594, 7643], [7646, 7646, 7703, 7703, 8539]]}
{"id": "wtBBDw", "name": "Nebula 10 with gamma colors", "author": "Leria", "description": "A sort of nebula, maybe not very realistic about the colors", "tags": ["fractal", "noise", "nebula", "gamma"], "likes": 6, "viewed": 592, "published": 3, "date": "1599063571", "time_retrieved": "2024-07-30T20:47:49.951627", "image_code": "// Fork of \"Nebula 10\" by Leria. https://shadertoy.com/view/wlBBWw\n// 2020-09-02 15:51:04\n\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.1\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    float anim = 1.;\n            #if ANIM      \n            anim = iTime/5.;\n            \n            #endif\n            \n   \n    f = Psnoise(p+anim); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 7.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float anim = 1.;\n\n            \n            float rad_bubl = RADIUS/2.1; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,0);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n\n\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = ( Psnoise( (p-pB+dp)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./dot(center,center))*l))*(max(0.,d)*l) ;\n            \n\n\n            float mask = smoothstep(0.,\n                                    27.*RADIUS,\n                                  \t((length(cam.pos - p)+length(center)))\n                                    );// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float scalar_p = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );            \n            \n            float dispersion_rate = scalar_p*fbm(p);\n            \n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate);\n            #define VT velocity\n            \n            //energy \n            \n            float energy = .5*(VT*VT*VT)/rad_bubl;\n            \n            \n             vec3 prof = vec3(10., 25., 10.)*k*energy;\n             vec3 rgb_t = exp(-prof);    \n            \n            vec3 col_loc = vec3(.9, sin(f(p.y)), 0.5);\n            \n#if 0  // 1: color via albedo   0: color via transparency\n            //col_loc = rgb_t / (1e-3+max(rgb_t.r,max(rgb_t.g,rgb_t.b)));\n            rgb_t = vec3((rgb_t.r+rgb_t.g+rgb_t.b)/3.);\n            prof = vec3(-log(1e-3+rgb_t));\n#endif\n    \n            float sun = 1./size,\n                shadow = 1.,\n                reflec = 1.;\n#if 1           \n            shadow = t_acc.b;  // assuming I'm the light :-p\n#endif\n            \n    \t\t//blending\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n    #if COLOR\n     //  c += t_acc*vec3(0,0,1);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .8*pow(texture(iChannel0,fragCoord*2./360.+vec2(degree,degree2)).rrr, vec3(20));\n    color += transp_tot * sky;\n        \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1543, 1543, 1568, 1581, 1947], [1949, 1949, 1974, 1987, 2458], [2460, 2460, 2479, 2479, 2572], [2574, 2593, 2669, 2669, 2716], [2718, 2718, 2750, 2750, 2770], [2772, 2772, 2806, 2806, 2828], [2915, 2915, 2956, 2956, 2992], [2994, 2994, 3080, 3080, 3115], [3117, 3117, 3160, 3160, 3200], [3202, 3202, 3226, 3226, 3274], [3276, 3276, 3316, 3316, 3620], [3622, 3622, 3646, 3646, 3709], [3712, 3712, 3787, 3787, 7550], [7553, 7553, 7610, 7610, 8438]]}
{"id": "WlSfDm", "name": "Feedback bend", "author": "Jaromir", "description": "post processing  glowing orbs with bending feedback.", "tags": ["2d", "postprocessing", "feedback", "bend"], "likes": 27, "viewed": 1027, "published": 3, "date": "1599056956", "time_retrieved": "2024-07-30T20:47:50.720571", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.14159265359\n\nmat2 rot(float a)\n{\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\nfloat hash11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise31(in vec3 n)\n{\n\tvec3 p = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = p.x+p.y*57.+p.z*113.;\n    float r = mix(mix(mix(hash11(q+0.),hash11(q+1.),f.x),\n                      mix(hash11(q+57.),hash11(q+58.),f.x),f.y),\n                  mix(mix(hash11(q+113.),hash11(q+114.),f.x),\n                      mix(hash11(q+170.),hash11(q+171.),f.x),f.y),f.z);\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 oUv = fragCoord.xy/iResolution.xy;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    //fbm\n    vec2 nUv = uv*7.5;\n    vec3  nP = vec3(nUv,iTime*0.5);\n    float n = noise31(nP)*0.5; \t\tnP.xy*=rot(0.25*M_PI);\n    \t  nP.xy+=vec2(-iTime*0.0234,iTime*0.0543);\n\t\t  n+= noise31(nP*2.)*0.25;  nP.xy*=rot(0.25*M_PI);\n    \t  nP.xy+=vec2(iTime*0.0587,iTime*0.0876);\n\t\t  n+= noise31(nP*3.)*0.0125; nP.xy*=rot(0.25*M_PI);\n    \t  nP.xy+=vec2(iTime*0.0478,-iTime*0.0234);\n\t\t  n+= noise31(nP*4.)*0.0625;\n    \n    #if 1\n      //nice glowing orbs\n      vec2 p1 = vec2(cos(iTime*0.723+0.1),sin(iTime*0.541-0.35))*0.5;\n      vec4 s1 = vec4(length(uv+p1));\n      s1 = vec4(1.)/s1*0.2;\n      s1.rgb*=vec3(0.3,0.3,0.7);\n    \n      vec2 p2 = vec2(cos(iTime*0.483+0.8),sin(iTime*0.372+0.8))*0.564;\n      vec4 s2 = vec4(length(uv+p2));\n      s2 = vec4(1.)/s2*0.08;\n      s2.rgb*=vec3(0.8,0.3,0.2);    \n\n      vec2 p3 = vec2(cos(iTime*0.567-0.3),sin(iTime*0.691-0.3))*0.494;\n      vec4 s3 = vec4(length(uv+p3));\n      s3 = vec4(1.)/s3*0.1;\n      s3.rgb*=vec3(0.7,0.6,0.3);    \n    \n      vec4 s = vec4(0.);\n      s+=s1;\n      s+=s2;\n      s+=s3;\n    \n\t#else\n      //britney\n      vec4 s = texture(iChannel1,oUv);\n    #endif\n    \n    float ang = atan(uv.y,uv.x);     \n    ang+=M_PI;\n    vec2 bend = vec2(cos(ang),sin(ang));\n    float l = length(uv);\n    float mask = abs(bend.y*3.);\n    mask+=abs(bend.x*2.)*0.5;\n    l = smoothstep(0.,0.5,l);\n    mask = clamp(mask,0.,1.)*l*mix(n,1.,0.9);\n    mask = pow(mask,2.);\n    \n    vec2  offset = vec2(bend*mask);\n    \t  offset*=vec2(5.,4.);\n          offset/=iResolution.xy;\n          offset+=(n-0.5)*clamp(l,0.,1.)*0.01;\n    \n    vec4  col = (texture(iChannel0,oUv+offset)-vec4(s));\n    \n    float feedback = 0.9;\n    col*=feedback;\n    \n    fragColor = vec4(s)+col - n*0.01;\n    //fragColor = vec4(mask);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]]}
{"id": "wlBBWw", "name": "Nebula 10", "author": "Leria", "description": "A sort of nebula, maybe not very realistic about the colors", "tags": ["fractal", "noise", "nebula"], "likes": 7, "viewed": 372, "published": 3, "date": "1599055790", "time_retrieved": "2024-07-30T20:47:51.774752", "image_code": "\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.1\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 6.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float anim = 1.;\n            #if ANIM      \n            //anim = iTime;\n            \n            #endif\n            \n            \n            float rad_bubl = RADIUS/2.1; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,0);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n            //if ( length(p-pB) < rad_bubl ) c.r += .03; // hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n\n\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = ( Psnoise( (p-pB+dp)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./dot(center,center)*anim)*l))*(max(0.,d)*l) ;\n            \n\n\n            float mask = smoothstep(0.,\n                                    27.*RADIUS,\n                                  \t((length(cam.pos - p)+length(center)))\n                                    );// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float scalar_p = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );            \n            \n            float dispersion_rate = scalar_p*fbm(p);\n            \n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate);\n            #define VT velocity\n            \n            //energy \n            \n            float energy = .5*(VT*VT*VT)/rad_bubl;\n            \n            \n             vec3 prof = vec3(10., 25., 10.)*k*energy;\n             vec3 rgb_t = exp(-prof);    \n            \n            vec3 col_loc = vec3(.9, sin(f(p.y)), 0.5);\n            \n#if 0  // 1: color via albedo   0: color via transparency\n            //col_loc = rgb_t / (1e-3+max(rgb_t.r,max(rgb_t.g,rgb_t.b)));\n            rgb_t = vec3((rgb_t.r+rgb_t.g+rgb_t.b)/3.);\n            prof = vec3(-log(1e-3+rgb_t));\n#endif\n    \n            float sun = 1./size,\n                shadow = 1.,\n                reflec = 1.;\n#if 1           \n            shadow = t_acc.b;  // assuming I'm the light :-p\n#endif\n            \n    \t\t//blending\n     //     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow) *  (1.-rgb_t);\n   \t //\t\tc += t_acc * col_loc* (prof) *.3; // * rgb_t;\n            t_acc *= (rgb_t);    \n            \n#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n    #if COLOR\n     //  c += t_acc*vec3(0,0,1);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    sky =   .8*pow(texture(iChannel0,fragCoord*2./360.+vec2(degree,degree2)).rrr, vec3(5));\n    color += transp_tot * sky;\n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1452, 1452, 1477, 1490, 1856], [1858, 1858, 1883, 1896, 2241], [2243, 2243, 2262, 2262, 2355], [2357, 2376, 2452, 2452, 2499], [2501, 2501, 2533, 2533, 2553], [2555, 2555, 2589, 2589, 2611], [2698, 2698, 2739, 2739, 2775], [2777, 2777, 2863, 2863, 2898], [2900, 2900, 2943, 2943, 2983], [2985, 2985, 3009, 3009, 3057], [3059, 3059, 3099, 3099, 3403], [3405, 3405, 3429, 3429, 3492], [3495, 3495, 3570, 3570, 7437], [7440, 7440, 7497, 7497, 8305]]}
{"id": "tlSBWw", "name": "[TWITCH] Volumetric screamer", "author": "evvvvil", "description": "Volumetric screamer - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["clouds", "cloud", "demoscene", "volumetric", "fog", "glow", "lightning", "monster", "face", "scary", "dark", "bolt", "demon", "scream"], "likes": 22, "viewed": 1203, "published": 3, "date": "1599055349", "time_retrieved": "2024-07-30T20:47:52.640437", "image_code": "// Volumetric screamer - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z;float tt,b,g=0.,gg=0.,cr;vec3 faceP,cp;vec4 su=vec4(0);\nfloat smin( float d1,float d2,float k){ float h=max(k-abs(d1-d2),0.);return min(d1,d2)-h*h*.25/k;}\nfloat smax( float d1,float d2,float k){ float h=max(k-abs(-d1-d2),0.);return max(-d1,d2)+h*h*.25/k;}\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r));} \nfloat noi(vec3 p){\n    vec3 f=floor(p),s=vec3(7,157,113);\n    p-=f;\n    vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);  \n}  \nfloat ferlin(vec3 p){ \n    float f=0.,A=.5,I;\n    p.zy+=tt*2.; \n    for(int i=0;i<3;i++) I=float(i),f+=A/(I+1.)*noi(p+I),p=(2.1+.1*I)*p;\n    return f;\n} \nfloat face(vec3 p){\n    p-=vec3(0,-12.+b*20.,0)+sin(p.y*2.)*.1;\n    p.yz*=r2(1.65*(1.-b));  \n    faceP=p*vec3(1,.7,1);   \n    float t=length(faceP)-4.-sin(p.y)*.66;\n    t=smin(t,length(abs(faceP+vec3(0,-2.5,-1))-vec3(2,0,0))-4.,1.);\n    vec3 spikeP=p+vec3(0,-3.9,2);\n    spikeP.x=abs(spikeP.x)-2.;\n    spikeP.xy*=r2(-.785);\n    spikeP.yz*=r2(-.1785);\n    t=smin(t,length(spikeP.xz)-2.+abs(p.x)*.2,1.5);\n    vec3 eyeP=abs(p-vec3(0,2,0));\n    eyeP.xy*=r2(.6);\n    float eyes=max(eyeP.y,(length(abs(faceP+vec3(0,-1.5,3.))-vec3(1.,0,0))-3.));   \n    t=smax(eyes,t,1.);   \n    t=min(t,max(eyeP.y+4.,eyes));\n    t=smax(length(faceP+vec3(0,2,-2.+5.*b))-2.5,t,.5); \n    spikeP.xy*=r2(-.1485);\n    spikeP-=vec3(8.*b,-3,-1);\n    t=smin(t,length(spikeP.xz)-1.+abs(spikeP.y+3.)*.25,1.5);\n    return t;\n}\nfloat terrain(vec3 p){\n    float t=p.y+5.+cos(length(p*(.5))-b*15.-tt*4.)*b+noi(p*.07+1.)*5.; //WOBBLE: cos(length(p*(.5))-b*15.-tt*4.)\n    t=smax(length(p.xz)-2.-b*6.,t,3.);\n    t=smin(t,length(p.xz)-1.+(p.y+15.-b*17.)*.5,1.5);\n    return t;\n} \nfloat cmp( vec3 p) \n{  \n    float t=face(p);  \n    t=smin(t,terrain(p),2.5);\n    vec3 boltP=p;\n    boltP=abs(boltP-vec3(0,0,2))-11.+sin(p.y*5.*p.x*.1+tt*25.5)*.05+4.*sin(p.y*.3-3.)+p.y*.2;//ORIGINAL SHADER IN BONZOMATIC HAD NOISE TEXTURE CALL FOR BETTER LIGHTNING BOLT EFFECT BUT, THIS SHADER BEING GREEDY ENOUGH, I THOUGHT BEST REPLACE WITH BUNCH OF SINS ON SHADERTOY\n    float bolt=length(boltP.xz)-.1; //~Above line on bonzo end should be: abs(boltP-vec3(0,0,2))-11.+texture(texNoise,p.xy*.1+tt*.5).r*2.+4.*sin(p.y*.3-3)+p.y*.2;      \n    bolt=max(bolt,p.y+10.-b*25.);\n    float mouthFlash=max(p.z,length(faceP.xy-vec2(0,-2))+2.+p.z*.2*b);\n    g+=0.1/(0.1+bolt*bolt*(1.02-b)*(40.-39.5*sin(p.y*.2-b*8.)));\n    gg+=0.1/(0.1+mouthFlash*mouthFlash*(1.05-b)*(40.-39.5*sin(p.z*.3+tt*5.)));\n    return t;\n}  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,62.82);\n    b=smoothstep(0.,1.,sin(tt)*.5+.5);\n    vec3 ro=vec3(sin(tt*.5)*10.,mix(15.,-3.,b),-20.+sin(tt*.5)*5.)*mix(vec3(1),vec3(2,1,cos(tt*.5)*1.5),cos(-tt*.5+.5)*.5+.5),\n         cw=normalize(vec3(0,b*10.,0)-ro), cu=normalize(cross(cw,vec3(0,1,0))),\n         cv=normalize(cross(cu,cw)), rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.1,.12,0.17)-length(uv)*.1-rd.y*.2;    \n    cr=cmp(ro-3.)+fract(dot(sin(uv*476.567+uv.yx*785.951+tt),vec2(984.156)));\n    for(int i=0;i<128;i++){\n        cp=ro+rd*(cr+=1./2.5);\n        if(su.a>.99) break; //NOTE TO SELF: cr>t NOT NEEDED AS ONLY VOLUMETRIC GEOM ARE PRESENT\n        float de=clamp((-cmp(cp)*9.+8.*ferlin(cp))/8.,0.,1.);\n        su+=vec4(vec3(mix(1.,0.,de)*de),mix(.07,de,exp(-.00001*cr*cr*cr)))*(1.-su.a);//FOG ON CLOUDS! mix(.07,de,exp(-.00001*cr*cr*cr))\n    }\n    co=mix(co,su.xyz,su.a);  \n    fragColor = vec4(pow(co+g*.4*vec3(.5,.2,.1)+gg*.4*vec3(.1,.2,.5),vec3(.55)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 293, 293, 352], [353, 353, 392, 392, 453], [454, 454, 471, 471, 515], [517, 517, 535, 535, 773], [776, 776, 797, 797, 928], [930, 930, 949, 949, 1721], [1722, 1722, 1744, 1744, 1966], [1968, 1968, 1989, 1989, 2770], [2773, 2773, 2830, 2830, 3877]]}
{"id": "3lBfDm", "name": "volume isovalue: fixing aliasing", "author": "FabriceNeyret2", "description": "ray marching volumetric data can suffer aliasing, especially if the transfer function ( i.e. LUT(dens) ) introduce high frequency. Here: explore isovalue.\nPreintegrated segment shading fix it (left).cf [url]https://tinyurl.com/y3ef86ao[/url]", "tags": ["procedural", "3d", "raymarching", "antialiasing", "volumetric", "lod", "vr", "preintegration"], "likes": 15, "viewed": 500, "published": 3, "date": "1599054175", "time_retrieved": "2024-07-30T20:47:53.401403", "image_code": "// variant of https://shadertoy.com/view/WtBfDm\n// variant of https://shadertoy.com/view/3tjfWD\n\n// inspired from \"Clouds\" by iq. https://shadertoy.com/view/XslGRr\n// ( no sky, no LOD, use cubic noise texture ).\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) ( 2.* textureLod(iChannel0,(x)/32.,0.).x -1. )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat map(vec3 p )\n{\n\tvec3 q = p - vec3(0,.1,1);\n\tfloat f = 0., s=.5;\n    for (int i=0; i< 5; i++ , s/= 2. )\n        f += s* noise( q ), q *= 2.;\n\n\treturn max(1.+ .5*p.y +3.*f, 0.);\n}\n\nfloat thick = 1./1000.;\n  #define LUT(d) max( 1.-SQR(d-.5)/thick, 0. ) // transfer function\n\n                                              // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-3 ? 0. : ( I(C(d1)) - I(C(d0)) ) / (d1-d0) ) \n  #define C(d) clamp( d, .5-sqrt(thick), .5+sqrt(thick) )\n  #define I(d) ( d - CUB(d-.5)/3./thick )\nvec2 coord;\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n}\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start\n          dt = 0.,\n         den = 0., _den, lut, dv;\n    for(int i=0; i<150; i++) \n    {\n        vec3 pos = ro + t*rd;\n        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;\n        _den = den; den = map(pos);  // raw density\n        if( abs(pos.x) > .5 )        // cut a slice \n        {\n            dv = -.6+sin(2.*iTime);  // explore isovalues\n            lut = LUTs( _den+dv, den+dv ); // shaped through transfer function\n            if (lut>.01)             // not empty space\n            { \n                vec3  col = mix(hue(.1*pos.z) , vec3(1), .8);\n                col = mix( col , bgcol, 1.-exp(-.003*t*t) ); // fog\n                sum += (1.-sum.a) * vec4(col,1)* (lut* dt*10.); // blend. Original was improperly just den*.4;\n            }  }\n        t += dt = max(.05,.02*t);     // stepping\n    }\n\n    return sqrt(1.-sum);              // black on white + sRGB\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\n#define render(ro,rd,px) raymarch( ro, rd, vec3(0), px ) // render volume\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* iMouse.xy / R.xy;\n    coord = p;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, -1, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n    if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1);\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[719, 719, 739, 739, 902], [1275, 1275, 1308, 1367, 1536], [1602, 1602, 1659, 1659, 2644], [2646, 2646, 2692, 2692, 2854], [2931, 2931, 2969, 2969, 3390]]}
{"id": "WtBfDm", "name": "volume skin: fixing aliasing", "author": "FabriceNeyret2", "description": "ray marching volumetric data can suffer aliasing, especially if the transfer function ( i.e. LUT(dens) ) introduce high frequency. Here: 7 isovalues in 3D Perlin noise.\nPreintegrated segment shading fix it (left).cf [url]https://tinyurl.com/y3ef86ao[/url]", "tags": ["procedural", "3d", "raymarching", "antialiasing", "volumetric", "lod", "vr", "preintegration"], "likes": 21, "viewed": 894, "published": 3, "date": "1599053620", "time_retrieved": "2024-07-30T20:47:54.279057", "image_code": "// variant of https://shadertoy.com/view/3tjfWD\n\n// inspired from \"Clouds\" by iq. https://shadertoy.com/view/XslGRr\n// ( no sky, no LOD, use cubic noise texture ).\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) ( 2.* textureLod(iChannel0,(x)/32.,0.).x -1. )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat map(vec3 p )\n{\n\tvec3 q = p - vec3(0,.1,1)*iTime;\n\tfloat f = 0., s=.5;\n    for (int i=0; i< 5; i++ , s/= 2. )\n        f += s* noise( q ), q *= 2.;\n\n\treturn clamp(1.+ .5*p.y +3.*f, 0., 1. ); // why not just max(0.,) ?\n}\n\nfloat thick = 1./2000.;\n  #define LUT(d) max( 1.-SQR(d-.5)/thick, 0. ) // transfer function\n\n                                              // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-3 ? 0. : ( I(C(d1)) - I(C(d0)) ) / (d1-d0) ) \n  #define C(d) clamp( d, .5-sqrt(thick), .5+sqrt(thick) )\n  #define I(d) ( d - CUB(d-.5)/3./thick )\nvec2 coord;\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n}\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start\n          dt = 0.,\n         den = 0., _den, lut, dv;\n    for(int i=0; i<150; i++) \n    {\n        vec3 pos = ro + t*rd;\n        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;\n        _den = den; den = map(pos); // raw density\n        if( abs(pos.x) > .5 )       // cut a slice \n        {\n            for (float ofs=0.; ofs<7.; ofs++) \n            {\n                dv = (ofs/3.5-1.)*.4; // draw 7 isovalues\n                lut = LUTs( _den+dv, den+dv ); // shaped through transfer function\n                if (lut>.01)          // not empty space\n                { \n                    vec3  col = hue(ofs/8.);\n                    col = mix( col , bgcol, 1.-exp(-.003*t*t) ); // fog\n                    sum += (1.-sum.a) * vec4(col,1)* (lut* dt*3.); // blend. Original was improperly just den*.4;\n            }  }  }\n        t += dt = max(.05,.02*t);     // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\n#define render(ro,rd,px) raymarch( ro, rd, vec3(0), px ) // render volume\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* iMouse.xy / R.xy;\n    coord = p;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, -1, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n    if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1);\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 691, 691, 894], [1267, 1267, 1300, 1359, 1528], [1594, 1594, 1651, 1651, 2651], [2653, 2653, 2699, 2699, 2861], [2938, 2938, 2976, 2976, 3397]]}
{"id": "3lBBDm", "name": "大龙猫 - Quicky#044.1", "author": "totetmatt", "description": "Variation of QY44", "tags": ["quicky"], "likes": 4, "viewed": 286, "published": 3, "date": "1599046208", "time_retrieved": "2024-07-30T20:47:55.172667", "image_code": "#define PI 3.141592\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 p(float t){\nreturn palette( t, vec3(0.,0.5,0.9),vec3(0.9,0.4,0.2),vec3(1.0,1.0,1.0),vec3(1.,0.25,0.25));\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec3 fig(vec2 uv){\nvec3 d  =vec3(0.);\n    float n = 15.;+cos(iTime*2.)*10.;\n    for(float i=0.;i<=n;i++){\n        //uv*=r(PI/n);\n     float l = length(uv)-.07*i;\n\n    float q = step(cos(iTime+i)*.25+.75,(atan(uv.y,uv.x)+PI)/(2.*PI));\n    l = abs(l)-.001;\n    d+= vec3(p(cos(.5+iTime+i)*.5+.5)*smoothstep(.02,.015,l)*q);\n    }\n    return d ;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    \n    uv.y = -abs(uv.y);\n    uv.x = -abs(uv.x);\n    uv.y+=.5;\n     uv*=r(iTime);\n    \n  \n    vec3 d = fig(uv);\n    \n    vec3 col = vec3(d);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 92, 92, 135], [136, 136, 152, 152, 247], [248, 248, 264, 264, 322], [323, 323, 341, 341, 665], [666, 666, 721, 721, 970]]}
{"id": "3lBBWm", "name": "Escalator 2", "author": "dr2", "description": "Below street level", "tags": ["tunnel", "underground", "stair"], "likes": 13, "viewed": 327, "published": 3, "date": "1599036260", "time_retrieved": "2024-07-30T20:47:56.234828", "image_code": "// \"Escalator 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // =1 for optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, pPos[2];\nvec2 stCs;\nfloat tCur, dstFar, stSpd, stAng, stRise, stWid, stHt, stLen, wThk, psgSep, psgWid, pSpd,\n   pRot[2], stExt, stTurn;\nint idObj, vuMode;\nconst int idStep = 1, idPlat = 2, idHrail = 3, idSep = 4, idWal = 5, idFlor = 6, idCeil = 7,\n   idLamp = 8, idBod = 9, idEye = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CeilDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float dc[3], dp[2], dd[3], d;\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * sign (p.x) - 0.06;\n  dc[2] = length (vec2 (q.x, q.y - 2.3)) - 1.7;\n  dd[2] = max (abs (dc[2]) - wThk, 3. - q.y);\n  dc[2] = max (dc[2] + wThk, 2.8 - q.y);\n  q = p;\n  dc[0] = length (vec2 (q.z, q.y + 5.6)) - 12.;\n  dp[0] = dc[0] - wThk;\n  dd[0] = max (max (max (abs (dc[0]) - wThk, 6. - q.y), abs (q.x + 3.8) - stLen), - dc[2]);\n  dc[0] = max (max (dc[0] + wThk, 5.9 - q.y), - q.x - 9.);\n  dc[1] = length (vec2 (q.z, pr.y + 5.7)) - 10.6;\n  dp[1] = dc[1] - wThk;\n  dd[1] = max (max (max (abs (dc[1]) - wThk, 4.45 - pr.y), abs (q.x - 3.5) - stLen - 0.3), - dc[2]);\n  dc[1] = max (dc[1] + wThk, 4.3 - pr.y);\n  dd[2] = max (dd[2], max (- dc[0], - dc[1]));\n  d = min (min (max (dd[0], dp[1]), max (dd[1], dp[0])), dd[2]);\n  DMIN (idCeil);\n  return dMin;\n}\n\nfloat LampDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float d;\n  q = vec3 (mod (pr.x + 0.8, 1.6) - 1., pr.y - 3.8, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (pr.x - 0.3 * stLen) - stLen - 0.8);\n  DMINQ (idLamp);\n  q = p;\n  q = vec3 (mod (q.x + 0.8, 1.6) - 0.6, q.y - 5.6, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (p.x + 4.) - 3.);\n  DMINQ (idLamp);\n  q = p;\n  q.xz = abs (q.xz);\n  q.x = abs (q.x - psgSep);\n  q -= vec3 (psgWid, - stHt * sign (p.x) + 2.6, 5. * stWid);\n  d = PrCapsDf (q, 0.152, 0.25);\n  DMINQ (idLamp);\n  return dMin;\n}\n\nfloat BodDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  for (int j = 0; j < 2; j ++) {\n    for (float k = -1.; k <= 1.; k += 2.) {\n      q = p - pPos[j] * k - vec3 (0.16, 0.8, 0.);\n      q.xz = Rot2D (q.xz, pRot[j] + pi * step (0.5, k));\n      d = PrRoundBoxDf (q, vec3 (0.11 - 0.02 * q.y, 0.8, 0.25 - 0.06 * q.y) - 0.1, 0.1);\n      d = min (d, PrCylDf ((q - vec3 (0., 0.7, 0.)).xzy, 0.3, 0.02));\n      DMINQ (idBod);\n      q.z = abs (q.z);\n      q -= vec3 (0.1, 0.4, 0.12);\n      d = PrCylDf (q.yzx, 0.09, 0.1);\n      DMINQ (idEye);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pr;\n  float dMin, d, s1, s2, spx;\n  dMin = dstFar;\n  spx = sign (p.x);\n  p.z = mod (p.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n  pr = vec3 (Rot2Cs (p.xy, stCs), abs (p.z) - 2. * stWid);\n  q = p;\n  d = max (abs (q.y) - stHt, abs (pr.z) - stWid);\n  q.xy = pr.xy / stRise;\n  q.x = mod (q.x * stCs.y + stSpd * tCur * sign (p.z), 1.);\n  s1 = q.x / stCs.x;\n  s2 = (q.x - 1.) * stCs.x / (stCs.y * stCs.y);\n  d = 0.6 * stRise * max (max (d, q.y + 0.5 * abs (s1 + s2) - 0.5 * (s1 - s2)), -3.32 - q.y);\n  DMIN (idStep);\n  q = p;\n  q.z = pr.z;\n  d = min (PrBoxDf (q - vec3 (stLen + 0.8, - stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)),\n     PrBoxDf (q - vec3 (- stLen - 0.8, stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)));\n  DMIN (idPlat);\n  q = p;\n  d = min (PrCaps2Df ((q.xy - vec2 (stLen + 0.3, - stHt + 0.49)).yx, 0.85, 0.52),\n     PrCaps2Df ((q.xy - vec2 (- stLen - 0.7, stHt + 0.49)).yx, 0.55, 0.52));\n  d = min (d, max (max (abs (pr.y - 0.28) - 0.55, abs (q.x) - stLen - 0.3),\n     abs (q.y - 0.48) - stHt - 0.52));\n  d = max (d, max (abs (abs (pr.z) - stWid - wThk), 0.) - wThk);\n  DMIN (idHrail);\n  q = p;\n  d = max (max (abs (pr.y - 0.15) - 0.42, max (abs (q.x) - stLen - 0.3, - stHt - 0.15 - q.y)),\n     max (stWid + 0.1 - abs (pr.z), pr.z - 2. * stWid));\n  DMIN (idSep);\n  q = p;\n  q.z = abs (q.z) - 8. * stWid - wThk;\n  d = abs (PrBox2Df (q.xz, vec2 (stLen + 3.4, 4. * stWid))) - wThk;\n  d = max (d, max (abs (pr.y - 1.3) - 3.4, abs (q.y - 1.5) - stHt - 1.6));\n  DMIN (idWal);\n  q = p;\n  d = PrBox2Df (vec2 (abs (q.x) - stLen - 6.4, q.y + stHt * spx - 1.5), vec2 (wThk, 1.6));\n  if (vuMode == 0) d = max (d, 4. * stWid - abs (p.z));\n  DMIN (idWal);\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * spx - 0.06;\n  d = PrBox2Df (q.xy, vec2 (psgWid, wThk));\n  q.x -= -3.1;\n  d = min (d, PrBoxDf (q, vec3 (1.6, wThk, 4. * stWid)));\n  DMIN (idFlor);\n  if (vuMode >= 0) dMin = CeilDf (p, pr, dMin);\n  dMin = LampDf (p, pr, dMin);\n  dMin = BodDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.03, 0.07, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sq.x * sq.y, ss.y);\n}\n\nvoid Setup ()\n{\n  stSpd = 2.;\n  stRise = 0.2;\n  stWid = 0.7;\n  stHt = 3.;\n  wThk = 0.05;\n  stAng = pi / 5.;\n  stCs = sin (stAng + vec2 (0.5 * pi, 0.));\n  stLen = stHt / (stCs.y / stCs.x);\n  psgSep = stLen + 4.9;\n  psgWid = 1.5;\n  pSpd = (stCs.x / stCs.y) * stRise * stSpd / (2. * stLen);\n  stExt = (stLen + 16. * stRise * stCs.x / stCs.y) / stLen;\n  stTurn = stExt * stLen - pi * stWid;\n  for (int j = 0; j < 2; j ++) {\n    pPos[j].xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * mod (pSpd * tCur / stExt +\n       float (j) / 2., 1.));\n    pPos[j].y = clamp (pPos[j].y, - stHt + 0.02, stHt - 0.02);\n    pPos[j].z = 2. * stWid;\n    pRot[j] = 0.;\n    if (abs (pPos[j].x) > stTurn) {\n      pRot[j] = (pPos[j].x - sign (pPos[j].x) * stTurn) / (2. * stWid);\n      pPos[j].xz = vec2 (stTurn * sign (pPos[j].x), 0.) + Rot2D (vec2 (0., 2. * stWid), - pRot[j]);\n    }\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qr, rg, u, ltDirL[3];\n  vec2 vf;\n  float dstObj, s, sh, nDotL, dSum, sSum, ux, uz;\n  int idObjP;\n  bool fxz;\n  col = vec3 (0.2, 0.2, 0.4);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    qr = vec3 (Rot2Cs (ro.xy, stCs), abs (ro.z) - 2. * stWid);\n    idObjP = idObj;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    ux = abs (ro.x) - stLen;\n    uz = mod (ro.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n    if (idObjP == idStep || idObjP == idPlat) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.3);\n      if (vn.y > 0.99) {\n        s = mod (12. * ro.z / stWid, 1.);\n        col4 *= 0.4 + 0.6 * SmoothBump (0.1, 0.9, 0.05, s);\n        if (idObjP == idStep || idObjP == idPlat && ux < 1.1) col4 =\n           mix (vec4 (0., 0.1, 0., 0.), col4, 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01,\n           mod (ro.x * (stCs.y / stCs.x) / stRise + tCur * sign (ro.z) * stSpd, 1.)));\n        if (idObjP == idPlat) col4 = mix (vec4 (0., 0.1, 0., 0.), col4,\n           1. - 0.4 * SmoothBump (0.03, 0.06, 0.01, ux - 1.1));\n        vn.z = 0.3 * (SmoothBump (0.75, 0.95, 0.05, s) - SmoothBump (0.05, 0.25, 0.05, s));\n        vn.y = sqrt (1. - dot (vn.xz, vn.xz));\n      } else {\n        col4 = mix (0.7 * col4, vec4 (0., 0.3, 0., 0.1), SmoothBump (0.3, 0.7, 0.05, mod (4. * ro.z / stWid, 1.))) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.02, mod (16. * ro.z / stWid, 1.)));\n      }\n    } else if (idObjP == idHrail) {\n      col4 = vec4 (0.9, 0.8, 0.7, 0.2);\n      if (abs (vn.x) + abs (vn.y) > 0.001) col4 *= 0.05;\n      else {\n        if (abs (ro.x - 0.25) < stLen && qr.y < 0.18) col4 *= 0.5;\n        col4.rgb *= 1. - 0.2 * SmoothBump (0.45, 0.55, 0.02, mod (2. * ro.x, 1.));\n        if (length (vec2 (ux - 1.3, ro.y + stHt * sign (ro.x) - 0.5)) < 0.07)\n           col4 = (sign (ro.x) == sign (ro.z)) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);\n      }\n    } else if (idObjP == idSep) {\n      col4 = vec4 (0.6, 0.4, 0.2, 0.1);\n      if (vn.y > 0.1) {\n        s = mod (2. * ro.x, 1.);\n        col4.rgb *= 0.8 + 0.2 * SmoothBump (0.43, 0.57, 0.02, s);\n        vn.xy = Rot2D (vn.xy, -0.2 * pi * SmoothBump (0.05, 0.1, 0.02, abs (s - 0.5)) * sign (s - 0.5));\n      } else if (abs (vn.x) > 0.99) { \n         col4.rgb *= 0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * ro.z, 1.));\n      }\n      vf = vec2 (128., 0.2);\n    } else if (idObjP == idWal) {\n      col4 = vec4 (0.45, 0.5, 0.6, 0.1);\n      fxz = (abs (vn.x) > abs (vn.z));\n      rg = ShStagGrid ((fxz ? ro.zy : ro.xy), vec2 (2., 3.));\n      col4.rgb = mix (col4.rgb, vec3 (0.6, 0.7, 0.4), 0.5 - 0.5 * rg.y);\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n      u.y = abs (abs (ro.y) - stHt) - 1.5;\n      u.z = uz;\n      if (abs (length (u.yz) - 0.5) < 0.11) col4 = vec4 (0.7, 0., 0., 0.1);\n      u.yz = abs (u.yz) - vec2 (0.12, 0.7);\n      if (max (u.y, u.z) < 0.) col4 = vec4 (0., 0., 0.7, 0.1);\n      u.x = ux - (psgSep - stLen);\n      u.y = ro.y + stHt * sign (ro.x);\n      if (abs (u.x) < psgWid && abs (u.y - 1.51) > 1.49 || u.x > - (stLen + 1.5) && u.y < 0.02 ||\n         ro.x < -0.7 && ro.y > stHt + 2.98 || ro.x > -0.7 &&\n         ro.x < stLen + 3.4 && qr.y > 4.44) col4 *= 0.5;\n      if (abs (qr.x + 0.8) < stLen + 1. && abs (qr.y - 1.) < 0.01) {\n        if (abs (mod (qr.x + 0.9 * sign (ro.z) * stSpd * tCur * stRise / stCs.y + 0.1, 0.2) - 0.1) < 0.05)\n           col4 = vec4 (0., 1., 0.5, -1.);\n        else col4 *= 0.8;\n      }\n      if (abs (u.x) < psgWid ||ux < 3.) {\n        s = LampDf (ro, qr, dstFar);\n        col4.rgb += vec3 (0.9, 0.9, 0.8) / (5. + 4000. * s * s);\n      }\n      vf = vec2 (64., 0.5);\n    } else if (idObjP == idLamp) {\n      col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n    } else if (idObjP == idFlor) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.);\n      if (abs (vn.y) > 0.99) {\n        rg = ShStagGrid (ro.zx, vec2 (4.));\n        col4.rgb *= 0.9 + 0.1 * rg.y;\n        if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n        else vn.yz = Rot2D (vn.yz, rg.x);\n      }\n      u.xz = vec2 (ux - psgWid, abs (ro.z) - 2. * stWid);\n      u.xz = max (abs (vec2 (u.x, abs (u.z) - stWid)) - vec2 (0.07, 0.07), -0.05);\n      col4.rgb *= 0.8 + 0.2 * smoothstep (0., 0.05, max (u.x, u.z));\n      s = length (vec2 (ux - 4.9, uz)) - 0.4;\n      if (s < 0.) {\n        col4 = (abs (s) < 0.02) ? vec4 (0.5, 0.5, 0.6, 0.1) :\n           vec4 (vec3 (0.6, 0.5, 0.4) * (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (32. * pi * s))), 0.);\n        vn = vec3 (0., 1., 0.);\n      } else vf = vec2 (64., 1.);\n    } else if (idObjP == idCeil) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.1);\n      col4.rgb *= 1. - 0.15 * SmoothBump (0.4, 0.6, 0.05, Truch (8. * ro.xz));\n      u.xz = abs (ro.xz);\n      s = smoothstep (0., 0.01, min (max (abs (u.z - 0.1) - 0.03, u.x - 7.7),\n         abs (abs (u.x - psgSep) - 0.1) - 0.03));\n      if (s < 0.999) col4 = mix (vec4 (0.8, 0.8, 0.7, -1.), col4, s);\n      else vf = vec2 (128., 0.25);\n    } else if (idObjP == idBod) {\n      col4 = (qHit.y > 0.68 || qHit.x > 0. && abs (qHit.y + 0.1) < 0.4 && abs (qHit.z) < 0.01) ?\n         vec4 (0.1, 0.1, 0.1, 0.) : vec4 (0., 0.3, 0.4, 0.1);\n    } else if (idObjP == idEye) {\n      col4 = (length (qHit.yz) < 0.06) ? vec4 (0.8, 0.4, 0.4, -1.) : vec4 (0., 0.3, 0.4, 0.1);\n    }\n    sh = 1.;\n    if (idObjP == idStep && vn.y > 0.99 || idObjP == idPlat || idObjP == idFlor)\n       sh = 0.7 + 0.3 * smoothstep (0.02, 0.1, BodDf (ro, dstFar));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (ux > 3.42) {\n        ltDirL[0] = normalize (vec3 (1., 1., 0.));\n        ltDirL[1] = normalize (vec3 (-1., 1., 0.));\n      } else {\n        ltDirL[0] = normalize (vec3 (0.5, 1., 1.));\n        ltDirL[1] = normalize (vec3 (0.5, 1., -1.));\n      }\n      ltDirL[2] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      for (int k = 0; k < 3; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (idObjP == idStep || idObjP == idPlat) nDotL *= nDotL;\n        dSum += ((k < 2) ? 0.5 : 1.) * nDotL;\n        sSum += ((k < 2) ? 0.5 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.2 + 0.5 * sh * dSum) + step (0.95, sh) * col4.a * sSum;\n    } else col = col4.rgb * (0.3 - 0.7 * dot (vn, rd));\n  }\n  col *= max (0.1, 1. - 2. * smoothstep (0., 1., dstObj / (2. * dstFar)));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, sr, a, t, tt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., -1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., 1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuMode = -1;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (max (abs (msw.x), abs (msw.y)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  if (vuMode != 0) {\n    vuId = 0.;\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = float (k + 1);\n        break;\n      }\n    }\n    if (regId == 1.) {\n      if (vuId == 0. || vuId == 1.) vuId = 1. - vuId;\n    } else if (regId == 2.) {\n      if (vuId == 0. || vuId == 2.) vuId = 2. - vuId;\n    }\n    vuMode = int (vuId) + 1;\n  }\n  Setup ();\n  if (vuMode == 0) {\n    az = -0.4 * pi;\n    el = -0.1 * pi;\n  } else if (vuMode == 1) {\n    az = 0.;\n    el = 0.;\n  } else if (vuMode == 2) {\n    az = -0.5 * pi;\n    el = 0.;\n  } else if (vuMode == 3) {\n    az = 0.5 * pi;\n    el = 0.;\n  }\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  if (vuMode == 0) {\n    zmFac = 3.5;\n  } else if (vuMode == 1) {\n    t = mod (pSpd * tCur / stExt + 0.25, 2.);\n    tt = mod (t, 1.);\n    ro.xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * tt);\n    ro.y = clamp (ro.y, - stHt + 0.02, stHt - 0.02);\n    ro.z = 2. * stWid;\n    if (t > 1.) ro *= -1.;\n    ro.y += 2. - 0.05;\n    if (abs (ro.x) > stTurn) {\n      a = (ro.x - sign (ro.x) * stTurn) / (2. * stWid);\n      if (t > 1.) a = pi - a;\n      ro.xz = vec2 (stTurn * sign (ro.x), 0.) + Rot2D (vec2 (0., 2. * stWid), - a);\n    } else a = (t > 1.) ? pi : 0.;\n    az += a - 0.5 * pi;\n    el -= 0.8 * stAng * SmoothBump (0.3, 0.7, 0.05, tt) * sign (t - 1.);\n    zmFac = 2.;\n  } else if (vuMode == 2) {\n    ro = vec3 (8., -1., 0.);\n    zmFac = 1.5;\n  } else if (vuMode == 3) {\n    ro = vec3 (-8., 5., 0.);\n    zmFac = 1.5;\n  } \n  vuMat = StdVuMat (el, az);\n  if (vuMode == 0) ro = vuMat * vec3 (0., 0., -30.);\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (0., 0.3, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = mix (col, vec3 (Maxv3 (col)), 0.2);\n  if (vuMode > 0) {\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n         col = vec3 (0.4, 0., 0.);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1145, 1145, 1189, 1189, 2035], [2037, 2037, 2081, 2081, 2636], [2638, 2638, 2672, 2672, 3200], [3202, 3202, 3224, 3224, 5208], [5210, 5210, 5243, 5243, 5427], [5429, 5429, 5450, 5450, 5707], [5709, 5709, 5731, 5731, 5879], [5881, 5881, 5915, 5915, 6259], [6261, 6261, 6276, 6276, 7124], [7126, 7126, 7161, 7161, 13779], [13781, 13781, 13837, 13837, 17232], [17234, 17234, 17266, 17266, 17366], [17368, 17368, 17401, 17401, 17490], [17492, 17492, 17538, 17538, 17585], [17587, 17587, 17629, 17629, 17680], [17682, 17682, 17725, 17725, 17789], [17791, 17791, 17835, 17835, 17895], [17897, 17897, 17919, 17919, 17957], [17959, 17959, 18016, 18016, 18099], [18101, 18101, 18137, 18137, 18343], [18345, 18345, 18375, 18375, 18488], [18490, 18490, 18521, 18521, 18585], [18619, 18619, 18643, 18643, 18703], [18705, 18705, 18729, 18729, 18841], [18843, 18843, 18868, 18868, 19054], [19056, 19056, 19085, 19085, 19297], [19299, 19299, 19338, 19338, 19518]]}
{"id": "WlSBDw", "name": "inorganica permutations", "author": "xenn", "description": "yay", "tags": ["particles", "ca"], "likes": 12, "viewed": 443, "published": 3, "date": "1599017857", "time_retrieved": "2024-07-30T20:47:57.178305", "image_code": "// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-02.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1.1*(time*0.3), 0.7, 0.7);\n    vec3 col1 = vec3(0.5, 0.92, 0.1*sin(time*0.3));\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(1.5*01.0*vec3(0.1*sin(time*0.3),0.1*cos(time*0.5),0.1*sin(time*(0.4)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=01.50;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 84.5\n\n#define fluid_rho 0.0200\n\n\n//mold stuff \n#define sense_ang 0.1764325975283464746\n#define sense_dis 0.05/(time*0.30)+03.0\n#define sense_force 0.4328\n#define trailing 02.10/(time*03.0)\n#define acceleration 0.0751\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.05/(time*0.30)/01.042347503666*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 0.5*sin(time*02.240)+01.1\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-.000*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.0)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 138, 138, 317], [319, 319, 355, 355, 405], [407, 407, 423, 423, 451], [453, 453, 498, 498, 1684]]}
{"id": "wtjBDD", "name": "Day 18 of raymarching challenge", "author": "illus0r", "description": "Day 18 of raymarching challenge", "tags": ["raymarching"], "likes": 7, "viewed": 247, "published": 3, "date": "1598999717", "time_retrieved": "2024-07-30T20:47:57.942262", "image_code": "\n#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.00001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 1.1)\n\n#define N 6\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 polarToDecart(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 decartToPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nfloat mengerStretch(vec3 p) {\n    float S = .43333;\n    for(int i = 0; i < N; i++) {\n        p.xz *= Rot(iTime);\n        // p.xy *= Rot(iTime);\n        p /= S;\n        p = abs(p);\n        if ( -p.x + p.y > 0.) p.xy = p.yx;\n        if (  p.x - p.z > 0.) p.xz = p.zx;\n        p.xy *= 0.7;\n        p.z *= S;\n    }\n    return sdBox(p, vec3(1.)) * pow(S, float(N));\n}\n\n// float mengerStretch(vec3 p) {\n//     float S = .63333;\n//     for(int i = 0; i < N; i++) {\n//         p.xz *= Rot(iTime / 7.);\n//         p.xy *= Rot(iTime / 3.);\n//         p /= S;\n//         p = abs(p);\n//         if ( -p.x + p.y > 0.) p.xy = p.yx;\n//         if (  p.x - p.z > 0.) p.xz = p.zx;\n//         p = p-2.*clamp(round(p/2.), -0.5, 0.5);\n//         p.xy *= 0.7;\n//         p.z *= S;\n//     }\n//     return sdBox(p, vec3(1.)) * pow(S, float(N));\n// }\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    float fractal = mengerStretch(p);\n    // p = fract(p);\n    // p += 0.6;\n    // float fractal = length(p) - 1.;\n    return vec2(fractal, RED);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        steps++;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, steps);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(0., 3., -30.);\n    // ro.xz *= Rot(iTime);\n    float zoom = 1.100;\n\n    vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    vec3 lookat = vec3(0, 0, 0);\n    lookat.xz *= Rot(angle.x);\n    lookat.yz *= Rot(angle.y);\n\n    vec3 rd = getRayDir(uv, ro, lookat, 1.);\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(1);\n    vec3 light = vec3(1000, 1, 1000);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring \n        if (d < MAX_DIST) {\n            if (info == IVORY) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                color *= vec3(0.832,0.800,0.849);\n            }\n            else if (info == BLUE) {\n                color = vec3(0.810,0.256,0.397);\n            }\n           else if (info == RED) {\n                color = vec3(.5 * (dot(n, normalize(light - p))) + .5);\n                // vec3 color1 = vec3(0.810,0.256,0.397);\n                // vec3 color2 = color1.zxy;\n                // color = mix(color1, color2, smoothstep(1.5, 3., length(p)));\n                // color *= vec3(0.810,0.256,0.397);\n                // color /= steps / 50.;\n            }\n            else if (info == BLACK) {\n                color = vec3(0.);//vec3(.0 + 0.2 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.130,0.130,0.130);\n                // color *= 5. / length(p.xz);\n            }\n            // color = mix(color, colorBg, smoothstep(20., 28., d));\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 280, 280, 343], [345, 345, 376, 376, 463], [465, 465, 497, 497, 632], [634, 634, 667, 667, 770], [772, 772, 801, 801, 1134], [1600, 1679, 1701, 1701, 1849], [1938, 1938, 1971, 1971, 2351], [2353, 2353, 2377, 2377, 2595], [2599, 2599, 2653, 2653, 2880], [2882, 2882, 2932, 2932, 3123], [3136, 3136, 3192, 3192, 5813]]}
{"id": "tl2fWD", "name": "Reintegration diffusion radius", "author": "michael0884", "description": "A static velocity field is used\nSine wave oscillation between different distribution radii\nSpace to restart", "tags": ["particles", "ca"], "likes": 37, "viewed": 12561, "published": 3, "date": "1598998758", "time_retrieved": "2024-07-30T20:47:58.849836", "image_code": "// Fork of \"Cell system 2\" by michael0884. https://shadertoy.com/view/3tSfRW\n// 2020-09-01 21:18:13\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \t\n    col.xyz=sqrt(hsv2rgb(P(pos.xy).zwy));\n    col.w = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n//i.e. diffusion \n#define distribution_size (0.75 + 0.4*step(sin(iTime), 0.))\n\n\n// from https://shadertoy.com/view/ttK3Rc\n// --- rand, noise and fluids \n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) / 16777216.;\n}\n#define tau   6.283185\n//computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ,\n          u = f*f*f*(f*(f*6.-15.)+10.),\n         du = 30.*f*f*(f*(f-2.)+1.);\n\n#define g(x,y,z) sin( tau* ( hash3i1f(i+uvec3(x,y,z)) + vec2(0,.25) ) ) // SC(rand angle)\n    vec2 ga = g(0,0,0),\n         gb = g(1,0,0),\n         gc = g(0,1,0),\n         gd = g(1,1,0),\n         ge = g(0,0,1),\n         gf = g(1,0,1),\n         gg = g(0,1,1),\n         gh = g(1,1,1);\n \n#define v(g,i,j)  dot(g, f.xy - vec2(i,j))\n    float va = v(ga,0,0),\n          vb = v(gb,1,0),\n          vc = v(gc,0,1),\n          vd = v(gd,1,1),\n          ve = v(ge,0,0),\n          vf = v(gf,1,0),\n          vg = v(gg,0,1),\n          vh = v(gh,1,1);\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 1; i++) {\n        total += noise(p) * amp;\n        p = p*2. + 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1); // divergence-free field\n}\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0.);\n    vec3 M = vec3(0.);\n    float mass = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //get the particle data\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec3 M0 = data.yzw;\n        \n        vec2 V0 = 1.*fluidnoise(vec3(8.*mod(X0,R)/R,1.0*iTime));\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        //overlap box\n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5));\n        //center of mass\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); \n        //only positive\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); \n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        mass += m;\n       \n        //add weighted by mass\n        X += center*m;\n      \n        //add color\n        M += M0*m;\n    }\n    \n    //normalization\n    if(mass > 0.)\n    {\n        X /= mass;\n        M /= mass;\n    }\n    M.x = mass;\n    \n    //initial condition\n    if(iFrame < 150 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        //here mass is brightness\n        M = rgb2hsv(texture(iChannel1, pos/R).xyz).zxy;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), M);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 146, 146, 212]]}
{"id": "WllfDf", "name": "Pendulum simulation", "author": "zduny", "description": "Pendulum motion simulated with simple Euler integration.\nIt's not as accurate as other more advanced methods, but it produces otherwise visually convincing and chaotic trajectories.\n\nPress SPACE to reset simulation.\nCLICK to attract end of pendulum.", "tags": ["simulation", "interactive", "physics", "pendulum", "euler"], "likes": 33, "viewed": 1250, "published": 3, "date": "1598990282", "time_retrieved": "2024-07-30T20:47:59.868113", "image_code": "void drawPendulum(in vec2 fragCoord, inout vec4 outColor) {\n  float totalMass = 0.0;\n  for (int i = 0; i < rods; i++) {\n    totalMass += masses[i];\n  }\n\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  vec2 previous = anchor;\n  for (int i = 0; i <= rods; i++) {\n    vec2 position;\n    if (i < rods) {\n      position = anchor + ballData(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, previous, position, 0.1 * scale,\n                  vec4(vec3(0.0), 1.0), outColor);\n    }\n\n    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);\n    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];\n\n    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),\n             outColor);\n    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);\n\n    previous = position;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = texture(iChannel1, uv);\n\n  drawPendulum(fragCoord, fragColor);\n\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n\nconst float pi = 3.1416;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isMousePressed() { return iMouse.z > 0.0; }\n\nfloat potentialEnergy(in vec4 data, in float mass) {\n  float m = mass;\n  float g = length(g);\n  float h = data.y + 10000.0;\n  return m * g * h;\n}\n\nfloat kineticEnergy(in vec4 data, in float mass) {\n  float m = mass;\n  float v = length(data.zw);\n  return 0.5 * m * v * v;\n}\n\nfloat totalEnergy(in vec4 data, in float mass) {\n  return potentialEnergy(data, mass) + kineticEnergy(data, mass);\n}\n\nvoid euler(inout vec4 current, in float timeDelta) {\n  current.zw += g * timeDelta;\n  current.xy += (current.zw + 0.5 * g * timeDelta) * timeDelta;\n}\n\nbool initialization(in ivec2 fragCoord, out vec4 fragColor) {\n  if (iFrame > 0 && !isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    return false;\n  }\n\n  if (fragCoord.x > rods + 1 || fragCoord.y > 1) {\n    return false;\n  }\n\n  float energy = 0.0;\n  vec2 position = vec2(0.0);\n  float angle = pi / 2.0;\n  for (int i = 0; i < rods; i++) {\n    angle += angles[i] * pi / 180.0;\n    position += vec2(sin(angle), cos(angle)) * lengths[i];\n    vec4 data = vec4(position, vec2(0.0));\n    energy += totalEnergy(data, masses[i]);\n    if (fragCoord.x == i) {\n      fragColor = data;\n    }\n  }\n\n  if (fragCoord.x == rods) {\n    fragColor = vec4(energy, vec3(0.0));\n  }\n\n  return true;\n}\n\nbool simulation(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord.x > rods + 1 || fragCoord.y > 1) {\n    return false;\n  }\n\n  if (fragCoord.y == 1) {\n    fragColor = ballData(STORAGE, fragCoord.x);\n    return true;\n  }\n\n  if (fragCoord.x == rods) {\n    if (isMousePressed()) {\n      // Calculate new energy\n      if (fragCoord.x == rods) {\n        float energy = 0.0;\n        for (int i = 0; i < rods; i++) {\n          vec4 data = ballData(STORAGE, i);\n          energy += totalEnergy(data, masses[i]);\n        }\n        fragColor = vec4(energy, vec3(0.0));\n        return true;\n      }\n    } else {\n      fragColor = vec4(energyBefore(STORAGE), vec3(0.0));\n    }\n    return true;\n  }\n\n  vec4[rods] data;\n  for (int i = 0; i < rods; i++) {\n    data[i] = ballData(STORAGE, i);\n  }\n\n  for (int s = 0; s < iterations; s++) {\n    float timeDelta = min(iTimeDelta, 0.1) / float(iterations);\n\n    for (int i = 0; i < rods; i++) {\n      euler(data[i], timeDelta);\n    }\n\n    // Constraints\n    for (int i = 0; i < rods; i++) {\n      vec2 previous = i > 0 ? data[i - 1].xy : vec2(0.0);\n\n      vec2 toPrevious = normalize(previous - data[i].xy);\n      vec2 constrained = previous - toPrevious * lengths[i];\n      vec2 impulse = (constrained - data[i].xy) / timeDelta;\n\n      data[i].xy = constrained;\n      data[i].zw += impulse;\n\n      if (i > 0 && dot(toPrevious, impulse) > 0.0) {\n        data[i - 1].zw -= impulse * masses[i] / masses[i - 1];\n      }\n    }\n  }\n\n  float damp = damping;\n  if (isMousePressed()) {\n    float scale = iResolution.y / 20.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / scale - center;\n    vec2 toMouse = mouse - data[rods - 1].xy;\n    float magnitude = length(toMouse);\n    if (magnitude > 0.1) {\n      data[rods - 1].zw += normalize(toMouse) * magnitude;\n      damp = 0.96;\n    }\n  }\n\n  if (damp < 1.0) {\n    for (int i = 0; i < rods; i++) {\n      data[i].zw *= damp;\n    }\n  } else {\n    // Compensate for energy drift\n    float potential = 0.0;\n    float kinetic = 0.0;\n    for (int i = 0; i < rods; i++) {\n      potential += potentialEnergy(data[i], masses[i]);\n      kinetic += kineticEnergy(data[i], masses[i]);\n    }\n    if (kinetic > 0.0) {\n      float scale = sqrt((energyBefore(STORAGE) - potential) / kinetic);\n      for (int i = 0; i < rods; i++) {\n        data[i].zw *= scale;\n      }\n    }\n  }\n\n  int i = fragCoord.x;\n  fragColor = data[i];\n\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);\n\n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n\n  if (initialization(iFragCoord, fragColor)) {\n    return;\n  }\n\n  simulation(iFragCoord, fragColor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int rods = 3;\nconst vec2 center = vec2(0.0, 5.3);\nconst float[] lengths = float[](5.0, 5.0, 5.0, 2.5, 3.0, 4.0);\nconst float[] angles = float[](-20.0, -3.0, -2.0, 0.0, 0.0, 0.0);\nconst float[] masses = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\nconst bool continuous = true;\nconst bool black = false;\nconst int colors = 6;\nconst vec3[] palette =\n    vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0),\n           vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0));\nconst float fade = 0.03;\nconst int iterations = 30;\nconst float damping = 1.0;\nconst vec2 g = vec2(0.0, -20.0);\n\n#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0, 2);\n\n#define KEY_SPACE 32\nbool isKeyPressed(in sampler2D keyboard, in int keyCode) {\n  return texelFetch(keyboard, ivec2(keyCode, 1), 0).x > 0.0;\n}\n\nvec4 ballData(in sampler2D storage, in int index) {\n  return texelFetch(storage, ivec2(index, 0), 0);\n}\n\nvec2 previousBallPosition(in sampler2D storage, int index) {\n  return texelFetch(storage, ivec2(index, 1), 0).xy;\n}\n\nfloat energyBefore(in sampler2D storage) {\n  return texelFetch(storage, ivec2(rods, 0), 0).x;\n}\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}", "buffer_b_code": "#define KEYBOARD iChannel2\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid drawTrials(in vec2 fragCoord, inout vec4 outColor) {\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  for (int i = 0; i < rods; i++) {\n    vec2 position = anchor + ballData(STORAGE, i).xy * scale;\n    vec3 color = black ? vec3(0.0) : palette[i % colors];\n    if (continuous) {\n      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),\n                  vec4(color, 1.0), outColor);\n    } else {\n      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),\n               outColor);\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 background = vec4(vec3(0.85), 1.0);\n  if (iFrame == 0 || resolutionChanged() || isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    fragColor = background;\n  } else {\n    fragColor = mix(texture(iChannel1, uv), background, fade);\n  }\n  drawTrials(fragCoord, fragColor);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 894], [896, 896, 951, 951, 1119]]}
{"id": "WlSfWD", "name": "Reintegration visualization", "author": "michael0884", "description": "Visualizing how the particle distributions are updated every frame in close up\nhttps://michaelmoroz.github.io/Reintegration-Tracking", "tags": ["particles", "ca"], "likes": 75, "viewed": 11668, "published": 3, "date": "1598985769", "time_retrieved": "2024-07-30T20:48:01.056935", "image_code": "// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-08-31 20:06:54\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    pos = R*0.495 + pos*0.03; //zoom in\n    ivec2 p = ivec2(pos + 0.5);\n    \n    float rho = 0.; float varr = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, vec2(p) + ij);\n        particle P0 = getParticle(data, vec2(p) + ij);\n        rho += P0.M.x*smoothstep(0.1, 0.09, distance(pos,P0.X)); \n    \tfloat rad = dif/2.;\n        varr += P0.M.x*smoothstep(0.03, 0.01, sdArrow(pos, P0.X, P0.X+20.*P0.V));\n        varr += P0.M.x*smoothstep(0.03, 0.01, sdBox(pos - P0.X - P0.V*dt, vec2(rad)));\n    }\n    \n    float sdgrid = sdBox(mod(pos + 0.5, vec2(1.0)), vec2(1.0));\n   \n    vec3 particles = vec3(0.2)*(rho + varr);\n    vec3 cellcol = vec3(1.);\n   \tvec3 grid = cellcol*smoothstep(0.0, -0.1, sdgrid);\n    // Output to screen\n    col.xyz = grid - particles;\n    col.xyz = col.xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, Bf(p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n\n//diffusion diameter\n// 0 - completely particle like\n// >1.0 - field-like\n#define dif 0.75\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArrow( in vec2 p, in vec2 a, in vec2 b )\n{\n    float sdl = sdSegment(p,a,b);\n    vec2 delta = normalize(b-a);\n    sdl = min(sdl, sdSegment(p,b,b-delta*0.05 + 0.05*delta.yx*vec2(-1,1)));\n    sdl = min(sdl, sdSegment(p,b,b-delta*0.05 - 0.05*delta.yx*vec2(-1,1)));\n    return sdl;\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpackSnorm2x16(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = packSnorm2x16(clamp(x, vec2(-1.), vec2(1.)));\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = dif;\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    if(iFrame%2 == 0)\n   \t\tReintegration(ch0, P, pos);\n   \telse\n        P = getParticle(data, pos);\n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos + vec2(0., 1.0)+0.28);\n        if(rand.z < 0.6) \n        {\n            P.X = pos + 0.3*(rand.yz-0.5);\n            P.V = 0.65*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    if(iFrame%2 == 0)\n    if(P.M.x != 0.) //not vacuum\n    {\n        //Simulation(ch0, P, pos);\n    }\n\n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 306], [308, 308, 344, 344, 394], [396, 396, 412, 412, 440]]}
{"id": "3tjfWD", "name": "Clouds: fixing aliasing", "author": "FabriceNeyret2", "description": "ray marching volumetric data can suffer aliasing, especially if the transfer function ( i.e. LUT(dens) ) introduce high frequency ( e.g. to show bones in scan data). \nPreintegrated segment shading fix it (left).cf [url]https://tinyurl.com/y3ef86ao[/url]", "tags": ["procedural", "3d", "raymarching", "antialiasing", "volumetric", "lod", "vr", "preintegration"], "likes": 27, "viewed": 1544, "published": 3, "date": "1598972861", "time_retrieved": "2024-07-30T20:48:01.819895", "image_code": "// inspired from \"Clouds\" by iq. https://shadertoy.com/view/XslGRr\n// ( no sky, no LOD, use cubic noise texture ).\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) ( 2.* textureLod(iChannel0,(x)/32.,0.).x -1. )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat map(vec3 p )\n{\n // if (abs(p.x) < 1.) return 0.;             // slice\n\tvec3 q = p - vec3(0,.1,1)*iTime;\n\tfloat f = 0., s=.5;\n    for (int i=0; i< 5; i++ , s/= 2. )\n        f += s* noise( q ), q *= 2.;\n\n\treturn clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. ); // why not just max(0.,) ?\n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n//#define LUT(d) smoothstep(.1,0.,abs(d-.5))  // transfer function\n  #define LUT(d) max( 1.-400.*SQR(d-.5), 0. ) // transfer function\n\n                                              // integral of transfer function\n//#define intLUT(d0,d1) ( I(C(d1)) - I(C(d0)) ) / ( d1-d0 + 1e-5 ) \n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-3 ? 0. : ( I(C(d1)) - I(C(d0)) ) / (d1-d0) ) \n  #define C(d) clamp( d, .5-1./20., .5+1./20. )\n  #define I(d) ( d - 400.*CUB(d-.5)/3. )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start\n          dt = 0.,\n         den = 0., _den, lut;\n    for(int i=0; i<150; i++) {\n        vec3 pos = ro + t*rd;\n        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;\n        _den = den; den = map(pos); // raw density\n        lut = LUTs( _den, den );    // shaped through transfer function\n        \n        if( lut > .01               // optim\n            && abs(pos.x) > .5      // cut a slice \n          ) {\n            float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n         // float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = lin * mix( vec3(1,.95,.8), vec3(.25,.3,.35), lut );// pseudo- shadowing with in-cloud depth ? \n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // blend. Original was improperly just den*.4;\n        }\n        t += dt = max(.05,.02*t); // stepping\n    }\n\n    return sum; // clamp( sum, 0., 1. );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col =  vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t            + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            //  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* iMouse.xy / R.xy;\n    coord = p;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, -1, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n    if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1);\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 622, 642, 697, 908], [1422, 1422, 1455, 1514, 1683], [1685, 1685, 1742, 1742, 3037], [3039, 3039, 3085, 3085, 3247], [3249, 3249, 3292, 3316, 3764], [3766, 3766, 3804, 3804, 4225]]}
{"id": "3ljfWD", "name": "大龙猫 - Quicky#044", "author": "totetmatt", "description": "Colorful and roundish quicky.", "tags": ["quicky"], "likes": 8, "viewed": 323, "published": 3, "date": "1598971666", "time_retrieved": "2024-07-30T20:48:02.603799", "image_code": "/*\nCode Under Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) Licence\nhttps://creativecommons.org/licenses/by-sa/4.0/legalcode\n**/\n#define PI 3.141592\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 p(float t){\nreturn palette( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec3 fig(vec2 uv){\nvec3 d  =vec3(0.);\n    float n = 10.;+cos(iTime*2.)*10.;\n    for(float i=0.;i<=n;i++){\n        uv*=r(iTime*.2+PI/n);\n     float l = length(uv)-.07*i;\n\n    float q = step(cos(iTime+i)*.25+.75,(atan(uv.y,uv.x)+PI)/(2.*PI));\n    l = abs(l)-.001;\n    d+= vec3(p(i/n+fract(iTime*.75))*smoothstep(.02,.015,l)*q);\n    }\n    return d ;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    if(mod(iTime,15.)<10.){\n    uv = abs(uv)-.75;\n    uv*=r(PI/4.);\n    if(mod(iTime,15.)<5.){\n    \n    uv = abs(uv)-.125;\n   }\n   }\n    vec3 d = fig(uv);\n    \n    vec3 col = vec3(d);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfWD.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[159, 159, 231, 231, 274], [275, 275, 291, 291, 389], [390, 390, 406, 406, 464], [465, 465, 483, 483, 813], [814, 814, 869, 869, 1171]]}
{"id": "Wt2BWD", "name": "Green Screen Color Key", "author": "Pavlienko", "description": "Basic green screen remover", "tags": ["greenscreencolorkeykeying"], "likes": 2, "viewed": 497, "published": 3, "date": "1598970072", "time_retrieved": "2024-07-30T20:48:03.377729", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    \n    vec4 backColor = texture(iChannel1,xy);\n    vec4 texColor = texture(iChannel0,xy);\n    \n    float counter = 0.1;\n    vec2 difference = vec2(texColor.g - texColor.r, texColor.g - texColor.b);\n    \n    if(difference.x > counter && difference.y > counter){\n    \t\n        texColor = backColor;\n        \n    };\n    \n    fragColor = texColor;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 447]]}
{"id": "tlSBDD", "name": " copy", "author": "RippleZou", "description": " ", "tags": [], "likes": 2, "viewed": 249, "published": 3, "date": "1598945352", "time_retrieved": "2024-07-30T20:48:04.220476", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\n\nbool HIT_HOLE = false;\nbool HIT_BARREL = false;\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat sphere(vec3 pos, float r) {\n  return length(pos) - r;   \n}\n\nfloat barrel(vec3 pos) {\n  float d = sphere(pos, 0.5);\n  pos.y += 0.5;\n  float holed = -sphere(pos, .25);\n  d = max(d, holed);\n  HIT_HOLE = (holed == d) ? true : HIT_HOLE;\n  return d;\n}\n\nfloat placedBarrel(vec3 pos, float rx, float ry) {\n  pos = rotateY(pos, ry);\n  pos = rotateX(pos, rx);\n  pos.y += 2.0;\n  return barrel(pos);\n}\n\nfloat distfunc(vec3 pos) {\n  pos += vec3(iTime);\n  vec3 c = vec3(10.);\n  pos = mod(pos,c)-0.5*c;\n    \n  pos = rotateX(pos, iTime);\n\n  HIT_HOLE = false;\n  HIT_BARREL = false;\n  \n  // Any of you smart people have a domain transformation way to\n  // do a rotational tiling effect instead of this? :)\n  float sphered = sphere(pos, 2.0);\n  float d = sphered;\n  d = min(d, placedBarrel(pos, 0., 0.));\n  d = min(d, placedBarrel(pos, 0.8, 0.));\n  d = min(d, placedBarrel(pos, 1.6, 0.));\n  d = min(d, placedBarrel(pos, 2.4, 0.));\n  d = min(d, placedBarrel(pos, 3.2, 0.));\n  d = min(d, placedBarrel(pos, 4.0, 0.));\n  d = min(d, placedBarrel(pos, 4.8, 0.));\n  d = min(d, placedBarrel(pos, 5.6, 0.));\n  d = min(d, placedBarrel(pos, 0.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 2.4, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.0, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 5.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.2, PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 7.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 7.0 * PI / 4.0));\n  HIT_BARREL = d != sphered;\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m_x = (iMouse.x / iResolution.x) - 0.5;\n    float m_y = (iMouse.y / iResolution.y) - 0.5;\n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 15.0, 5.0 * cos(m_x * PI * 2.));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) { break; }\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n\n    if (dist < EPSILON) {\n      vec2 eps = vec2(0.0, EPSILON);\n      vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n      vec3 lightdir = normalize(vec3(1., -1., 0.));\n      float diffuse = max(0.2, dot(lightdir, normal));\n      vec2 tc = vec2(pos.x, pos.z);\n      vec3 texcol = texture(iChannel0, tc).rgb;\n\n      vec3 lightcol = vec3(1.);\n      vec3 darkcol = vec3(.4, .8, .9);\n      float sma = 0.4;\n      float smb = 0.6;\n        \n      if (HIT_HOLE) { \n          lightcol = vec3(1., 1., 0.8);\n      } else if (HIT_BARREL) {\n        lightcol.r = 0.95;   \n      } else {\n          sma = 0.2;\n          smb = 0.3;\n      }\n      float facingRatio = smoothstep(sma, smb, \n                                     abs(dot(normal, rayDir)));\n\n      vec3 illumcol = mix(lightcol, darkcol, 1. - facingRatio);\n      fragColor = vec4(illumcol, 1.0);        \n    } else {\n      float strp = smoothstep(.8, .9, mod(screenPos.y * 10. + iTime, 1.));\n      fragColor = vec4(mix(vec3(1., 1., 1.), vec3(.4, .8, .9), strp), 1.);\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 196, 196, 311], [312, 312, 345, 345, 460], [461, 461, 494, 494, 609], [611, 611, 644, 644, 675], [677, 677, 701, 701, 862], [864, 864, 914, 914, 1006], [1008, 1008, 1034, 1034, 2448], [2450, 2450, 2507, 2507, 4660]]}
{"id": "wtSfWD", "name": "Single-Buffer Motion Blur", "author": "milesWaugh", "description": "I finally learned how to use buffers, yay! This works by repeatedly averaging what would be the next frame with the previous frame, to make the next frame.", "tags": ["motionblur", "demo", "buffer"], "likes": 7, "viewed": 759, "published": 3, "date": "1598936116", "time_retrieved": "2024-07-30T20:48:04.982439", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = texture(iChannel0,fragCoord/iResolution.xy).rgba;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define s1 sin(iTime*5.0)\n#define c1 cos(iTime*5.0)\n#define s2 sin((iTime+(iTime/float(iFrame))/4.0)*5.0)\n#define c2 cos((iTime+(iTime/float(iFrame))/4.0)*5.0)\n#define s3 sin((iTime+2.0*(iTime/float(iFrame))/4.0)*5.0)\n#define c3 cos((iTime+2.0*(iTime/float(iFrame))/4.0)*5.0)\n#define s4 sin((iTime+3.0*(iTime/float(iFrame))/4.0)*5.0)\n#define c4 cos((iTime+3.0*(iTime/float(iFrame))/4.0)*5.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col = 0.0;\n    vec2 uv = (fragCoord-(iResolution.xy/2.0))/iResolution.y;\n    vec2 off1 = uv - vec2(s1, c1)/vec2(2.0,5.0);\n    vec2 off2 = uv - vec2(s2, c2)/vec2(2.0,5.0);\n    vec2 off3 = uv - vec2(s3, c3)/vec2(2.0,5.0);\n    vec2 off4 = uv - vec2(s4, c4)/vec2(2.0,5.0);\n    if(dot(off1, off1)<0.1){\n        col += 0.25;\n    }\n    if(dot(off2, off2)<0.1){\n        col += 0.25;\n    }\n    if(dot(off3, off3)<0.1){\n        col += 0.25;\n    }\n    if(dot(off4, off4)<0.1){\n        col += 0.25;\n    }\n    col = (col+texture(iChannel0,fragCoord/iResolution.xy).r)/2.0;\n    fragColor = vec4(col,col,col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 128]]}
