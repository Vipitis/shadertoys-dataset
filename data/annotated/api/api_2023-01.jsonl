{"id": "DtlXRl", "name": "Pop Baby", "author": "QuantumSuper", "description": "Best with music ", "tags": ["2d", "music"], "likes": 18, "viewed": 576, "published": 3, "date": "1675203589", "time_retrieved": "2024-07-30T18:12:43.800404", "image_code": "// PopBaby 0.76.230131\n// auto-vj bufferless\n//\n// - use with music in iChannel0 -\n\n\n#define PI 3.14159265359 \nfloat animTime;\nvec4 fft, ffts;\n\nvoid compressFft(){  \n\t// Sound (see shadertoy.com/view/Xds3Rr, assume? sound texture with 44.1kHz in 512 texels)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n \n    //fft.x *= fft.x; //weaken weaker sounds, soft limit\n    //fft.x = smoothstep(.8,.9,fft.x); //weaken weaker sounds, semi hard limit\n    fft.x = step(.9,fft.x); //weaken weaker sounds, hard limit\n}\n\nfloat hash21(vec2 p){ //see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nmat2 rotM(float deg){\n    deg /= 180./PI;\n    return mat2(cos(deg),-sin(deg),sin(deg),cos(deg));\n}\n\nfloat circ(vec2 p, float d){\n    return .05/abs(length(p)-d);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 ab = b-a;\n\treturn .05/length(a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.)-p);\n}\n\nfloat lines(vec2 p, vec2[4] coord, int maxCoord){ //maxCoord<=coord.length() (funs in glsl unfortunately dont take sizeless arrays)\n    float amp = 0.;\n    for (int n=0;n<maxCoord; n++){\n        amp += line(p, coord[n], coord[(n+1)%maxCoord]); //closed loop\n    }\n    return amp;\n}\n\nfloat particle(vec2 p){\n    return smoothstep(.1,.0,length(p)) * smoothstep(.1,.06,length(p-vec2(0.,.02)));\n}\n\nfloat dustLayer(vec2 p){\n    float id = hash21(floor(p));\n    return smoothstep(0.,1.,id)*particle((fract(p)-vec2(.5+.4*cos(id*animTime),.5+.4*sin(.8*id*animTime)))*rotM(id*360.)/vec2(cos(.5*id*animTime),1)); //...is there performance gain in doing this rather than via sub steps?\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = (2.*fragCoord-iResolution.xy) / maxRes; //-1..1 on longer side\n    vec3 col; float aFrac, amp = 0.; \n    animTime = 2.133333*iTime;\n    fft  = vec4(0), ffts = vec4(0);\n    compressFft();\n\n    // Dust layers \n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*animTime+.25*n)-.02*fft.w*fft.w*fft.w;\n        amp += 1.4*(.2+.8*fft.z)*dustLayer((uv+n*vec2(.1,.05))*25.*aFrac)*smoothstep(1.,.33,aFrac);\n    }\n    amp *= (.7+.5*length(uv)); //anti-vignette \n    \n    // Symbols\n    vec2[] myBox = vec2[](\n        vec2( 1, 1),\n        vec2( 1,-1),\n        vec2(-1,-1),\n        vec2(-1, 1)\n    );\n    vec2[] myTri = vec2[](\n        vec2(          0, 1),\n        vec2( cos(PI/6.), -sin(PI/6.)),\n        vec2(-cos(PI/6.), -sin(PI/6.)),\n        vec2(0)\n    );\n    aFrac = fract(.5*animTime+4.*cos(.04*animTime));\n    if (aFrac<1./3.){ //square\n        amp += fft.y*lines(5.*uv/(.8+.4*ffts.w), myBox, 4); //relative normalized to area h*w\n    } else if (aFrac<2./3.){ //triangle\n        amp += fft.y*lines(5.*sqrt((1.+sin(PI/6.))*cos(PI/6.)/4.)*uv*rotM(-5.*animTime)/(.8+.4*ffts.w), myTri, 3); //relative normalized to area h*l/2. = r2*(1.+sin(PI/6.))*cos(PI/6.)\n    } else {//circle\n        amp += fft.y*circ(5.*sqrt(PI/4.)*uv/(.8+.4*ffts.w), 1.); //relative normalized to area PI*r2\n    }\n    col = vec3(amp*amp); //light falloff correction\n    col *= vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x); //colors\n    \n    // Flash bars\n    float maxY = (maxRes == iResolution.x) ? 1. : iResolution.y/maxRes;\n    amp = fft.x*.03/abs(abs(uv.y)-2.*maxY*fract(animTime));\n    col += amp*amp; //light falloff correction\n    \n    // Utility\n    //amp = dot(fft,vec4(step(.5,-uv.x),step(0.,-uv.x)*step(-uv.x,.5),step(0.,uv.x)*step(uv.x,.5),step(.5,uv.x))); //compression bars, fft\n    //amp = dot(ffts,vec4(step(.5,-uv.x),step(0.,-uv.x)*step(-uv.x,.5),step(0.,uv.x)*step(uv.x,.5),step(.5,uv.x))); //compression bars, ffts\n    //amp = hash21(uv); //noise function\n    //col = vec3(amp);\n    \n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 32168, "src": "https://soundcloud.com/darklightrec/fedde-le-grand-let-the-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 163, 257, 1314], [1316, 1316, 1337, 1383, 1476], [1478, 1478, 1499, 1499, 1576], [1578, 1578, 1606, 1606, 1641], [1643, 1643, 1678, 1718, 1802], [2087, 2087, 2110, 2110, 2196], [2198, 2198, 2222, 2222, 2480]], "test": "untested"}
{"id": "mtfXzs", "name": "range slider", "author": "jonasfrey", "description": "this is just a small example on how to store multiple mouse position values in a buffer\n\nuse the mouse to change the sliders ", "tags": ["example", "simple", "ui", "slider"], "likes": 6, "viewed": 199, "published": 3, "date": "1675199787", "time_retrieved": "2024-07-30T18:12:44.576329", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc_nooff = fragCoord.xy/ iResolution.xy;\n\n    \n    float n_it_one_nor = 1./n_its;\n    vec2 o_it = floor(o_fc_nooff/n_it_one_nor);\n\n    vec4 o_data_mouse = texelFetch(iChannel0, ivec2(o_it.x, 0), 0);\n    float n_d = float(o_fc_nooff.y > o_data_mouse.y);\n    \n    fragColor = vec4(n_d);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float b_mousedown = iMouse.z;\n    \n    vec2 o_fc = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nooff = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_mc = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_mc_nooff = (iMouse.xy )/ iResolution.xy;\n\n\n    if(iMouse.w == 0.){\n        o_mc_nooff = vec2(sin(iTime)*0.5+0.5, cos(iTime)*0.5+0.5);\n    }\n    vec4 o_col_last = texture(iChannel0, o_fc_nooff);\n    \n\n    float n_it_one_nor = 1./n_its;\n    vec2 o_it = floor(o_fc_nooff/n_it_one_nor);\n    vec2 o_itm = floor(o_mc_nooff/n_it_one_nor);\n\n    ivec2 o_iMouse_location = ivec2(o_itm.x, 0);\n    \n    \n    fragColor = o_col_last;    \n    \n    if(ivec2(fragCoord.xy) == ivec2(o_iMouse_location)){\n        fragColor = o_mc_nooff.xyxy;\n    }\n    //fragColor = vec4(o_itm.x/n_its);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float n_its = 33.;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 355]], "test": "untested"}
{"id": "dtfSzs", "name": "Techno-plankton in alien ocean", "author": "mrange", "description": "CC0: Techno-plankton in alien ocean\nRethemed the colors of an earlier shader. \nOriginal shader: https://www.shadertoy.com/view/dtSGWh\nI suppose some like this better and others like the others better :)", "tags": ["2d"], "likes": 59, "viewed": 806, "published": 3, "date": "1675196263", "time_retrieved": "2024-07-30T18:12:45.364728", "image_code": "// CC0: Techno-plankton in alien ocean\n//  Rethemed the colors of an earlier shader. \n//  Original shader: https://www.shadertoy.com/view/dtSGWh\n//  I suppose some like this better and others like the others better :)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float rep   = 32.0;\nconst float over  = 4.0;\nconst float nstep = 1.0/(rep*over);\nconst float astep = TAU*nstep;\nconst float pm    = 17.0;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float aa) {\n  const float angle = 2.0*PI/rep;\n  float a = aa + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (rep/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat segmentx(vec2 p, float l, float w) {\n  p = abs(p);\n  p.x -= l*0.5-w;\n  float d0 = length(p)-w;\n  float d1 = p.y-w;\n  float d = p.x > 0.0 ? d0 : d1;\n  return d;\n}\n\nvec2 df(vec2 p, float noff, float a, out float n) {\n  const float ll  = 0.5;\n  const float ss = 0.0015;\n  const float bb = ss*4.0;\n  n = modPolar(p, a)/rep+noff;\n  float m = 16.0*sin(TIME*TAU);\n  float anim = sin(TAU*TIME/10.0+pm*noff*TAU);\n  p.x -= 0.75+0.25*anim;\n  float l = ll*mix(0.5, 1.0, smoothstep(-0.9, 0.9, anim));\n  float s = ss;\n  float b = bb;\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x = abs(p1.x);\n  p1.x -= l*0.5-s;\n  float d0 = segmentx(p0, l, s);\n  float d1 = length(p1)-b;\n  return vec2(d0, d1);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\nvec3 effect0(vec2 p, float aa) {\n  const float zz = 2.75;\n  p /= zz;\n  vec2 hn = hextile(p);\n  float hh = hash(hn);\n  p *= zz;\n  float n;\n  vec3 col = vec3(0.0);\n  const mat2 rr = ROT(TAU/(rep*over));\n  vec2 pp = p;\n  float a = atan(p.y, p.x);\n  float ll = length(p);\n  for (float i = 0.0; i < over; ++i) {\n    float noff = i*nstep;\n    float aoff = i*astep;\n    vec2 d = df(p, noff, a-aoff, n);\n    d /= aa;\n\n    float g0 = 2.0/max(max(d.x, 0.0), 0.001);\n    float g1 = 8.0/max((d.y*d.y), 0.000001);\n    \n    vec3 a3 = TAU*hh+vec3(0.0, 1.0, 2.0)+0.5*ll+0.5*PI*abs(n)-0.1*TIME;\n    vec3 ccol = 0.5*(1.0+cos(a3));\n    col += 2.0*ccol*ccol*g0;\n    col += 4.0*ccol*g1;\n    p *= rr;\n  }\n  \n  col *= smoothstep(0.5*zz, 0.25*zz, ll);\n  const vec3 gcol0 = 10000.0*vec3(0.0, 0.5, 1.0);\n  const vec3 gcol1 = 0.025*vec3(0.0, 0.25, 1.0);\n  col += gcol0*aa*aa+gcol1/dot(p, p);\n  col /= (600.0*aa);\n  return col;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 transform(vec2 p) {\n  vec2 off0 = sin(vec2(1.0, sqrt(0.5))*0.23*TIME);\n  vec2 off1 = sin(vec2(1.0, sqrt(0.5))*0.13*TIME);\n  vec2 sp0 = toSmith(p);\n  vec2 sp1 = toSmith(p+off0);\n  vec2 sp2 = toSmith(p-off1);\n  vec2 pp = fromSmith(sp0+sp1-sp2);\n  pp += 0.1*TIME;\n  return pp;\n}\n\nvec3 effect(vec2 p, vec2 np, vec2 pp) {\n  p = transform(p);\n  np = transform(np);\n  float aa = distance(p, np)*sqrt(2.0); \n  vec3 col = effect0(p, aa);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p + 1.0/RESOLUTION.y;\n  vec3 col = effect(p, np, pp);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[571, 657, 697, 697, 1077], [1079, 1179, 1198, 1198, 1285], [1287, 1394, 1420, 1420, 1604], [1606, 1606, 1648, 1648, 1773], [1775, 1775, 1826, 1826, 2285], [2287, 2388, 2416, 2515, 2842], [2844, 2904, 2925, 2925, 2995], [2996, 2996, 3028, 3028, 3897], [3900, 3900, 3923, 4003, 4142], [4144, 4144, 4169, 4248, 4387], [4389, 4389, 4413, 4413, 4669], [4671, 4671, 4710, 4710, 4838], [4840, 4840, 4897, 4897, 5153]], "test": "untested"}
{"id": "mtXXzf", "name": "Spherical Lens Simulation", "author": "AudibleAud", "description": "This's a simulation of a clear sphere. Move it around with the mouse. It gets farther out over time. There are variables for radius 'n refractive index at the top if you wanna mess with it.", "tags": ["orb"], "likes": 3, "viewed": 219, "published": 3, "date": "1675192533", "time_retrieved": "2024-07-30T18:12:46.199496", "image_code": "//This is isometric so it's not perfect but it is way easier\n//it's a clear sphere\n//crazy that\n\nconst float pi = radians(180.0);\n\n//the unit for these next few is pixels\nconst float lRad = 100.0; //lens' radius\n\nconst float lIndex = 1.2; //refractive index of the lens. everything else's in a vacuum\n//const float cHeight = 128.0; camera's height doesn't matter 'cause isometric\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 lPos = vec3(iMouse.xy, lRad + iTime * 10.0); //position of the (center of the) lens\n    vec4 col = vec4(0,0,0,1);\n    \n    vec2 relPos = fragCoord - lPos.xy; //position relative to the lens\n    float x = length(relPos); //yea ik bad variable name. distance from the z axis of the lens\n    \n    if(x >= lRad) {\n        col = texture(iChannel0, fragCoord / iResolution.xy);\n    } else {\n    \n    vec2 vDir = normalize(relPos); //direction from the center\n    float theta1 = asin(x / lRad); //angles of incidence\n    float theta2 = asin(x / (lRad * lIndex)); //and refraction\n    \n    vec3 ePos = vec3(sin(theta1 + pi - theta2 * 2.0) * lRad * vDir + lPos.xy, lPos.z + cos(theta1 + pi - theta2 * 2.0) * lRad);\n    //where the light enters the lens\n    float eDist = tan(2.0 * (theta1 - theta2)) * ePos.z;//distance the ray travels to the lens (in the xy plane)\n    \n    vec2 fPos = ePos.xy - vDir * eDist;\n    \n    col = texture(iChannel0, fPos / iResolution.xy);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[381, 381, 436, 436, 1439]], "test": "untested"}
{"id": "dtfSRs", "name": "Simplest antialiased graph", "author": "fishy", "description": "This is a very simple way of graphing functions. If the thickness is set too high you get artifacts. It uses dFdx to try and ensure a consistent line thickness, which works well for thin lines. Uncomment BETTER_APPROX to see without it.", "tags": ["graph", "derivative", "dfdx", "fwidth"], "likes": 5, "viewed": 174, "published": 3, "date": "1675190446", "time_retrieved": "2024-07-30T18:12:46.964451", "image_code": "#define BETTER_APPROX\n#define THICKNESS 0.01\n\n// Put your function here\nfloat f(float x)\n{\n    int s = int(mod(iTime*0.5, 4.));\n    switch(s)\n    {\n    case 0:\n        return sin(x*5.+iTime)*0.5;\n        break;\n    case 1:\n         x -= 0.3;\n        return -x*x-x*x*x;\n        break;\n    case 2:\n        x += 0.5;\n        return 3.*x*x-2.*x*x*x-0.5;\n        break;\n    case 3:\n        return (sin(x*5.)+cos(x*10.+iTime))*0.25;\n        break;\n    }\n}\n\nfloat graph(vec2 p)\n{\n    float f = f(p.x);\n    return abs(p.y-f)\n    #ifdef BETTER_APPROX\n    -abs(dFdx(f))\n    #endif\n    ;\n}\n\nfloat map(vec2 uv)\n{\n    return graph(uv);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m, float px)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.005\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float md = map(m.xy);\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = (iMouse*2.-iResolution.xyxy)/iResolution.y;\n    float px = 2./iResolution.y;\n\n    float g = graph(uv);\n    float fw = fwidth(g);\n    vec3 col = vec3(smoothstep(THICKNESS+fw, THICKNESS-fw, g));\n\n    // Output to screen\n    fragColor = vec4(mix(col, colorSdf(uv, m, px), clamp(iMouse.z, 0., 1.)),1.0);\n}\n\n\n\n\n\n\n\n// Alias: return of the jaggies", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 72, 90, 90, 449], [580, 580, 600, 600, 624], [626, 626, 668, 668, 1315], [1317, 1317, 1374, 1374, 1748]], "test": "untested"}
{"id": "ctfXRs", "name": "Torus Grid Distorter", "author": "SnoopethDuckDuck", "description": "h", "tags": ["grid", "torus", "funkytunes"], "likes": 40, "viewed": 420, "published": 3, "date": "1675179021", "time_retrieved": "2024-07-30T18:12:47.797224", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define t iTime\n#define TEST 8.\n\n//https://www.shadertoy.com/view/sslGzN\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(float n){\n    return pow(Semitone,(n-8.))*440./48000.;\n}\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = mix(100., 12., tanh(.2*t));\n    vec3 ro = vec3(r*cos(.8*t), cos(1.7 * t), r*sin(.8*t));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {\n\n    // Torus (thin)\n    vec3 p1 = p;\n    p1.xy *= rot(0.5 * t);\n    p1.yz *= rot(0.215 * t);\n    float d1 = length(p1.xy) - 0.5;\n    float td = length(vec2(p1.z,d1));\n   \n    // Sphere\n    float sd = length(p) - 1.25;\n \n    // Mix between stuff\n    float mx = .5 + .5 * thc(5., 0. * length(p) + 0.5 * t);\n    float mx2 = .5 + .5 * thc(5., 0. * length(p) + 0.4 * t);\n    \n    // Scale a grid using distance functions\n    // (this is a mess and I don't understand it)\n    // sc also used for color\n    float sc = smin(td, sd, 1.).y;\n    sc *= 0.25 * TEST;\n    sc -= 0.5 * mix(td, sd, mix(0., 2., mx2));    \n    \n    p.yz *= rot(0.4 * t);\n    \n    // Mix between 3D sphere grid and 2D column grid\n    vec3 p2 = mod(p - 0.5 * sc, sc) - 0.5 * sc;    \n    float d = mix(length(p2) + 0.2 * sc, \n                  length(p2.xz) + 0.12 * sc, \n                  mx);\n    \n    // Oscillate sphere in centre\n    // float band = KeyToFrequency(14.); //<- was supposed to use this\n    float s = texture(iChannel1, vec2(14., 0.25)).x;\n    d = min(d, length(p) - 2. * s);\n    \n    // Restrict shape to sphere\n    d = smax(d, length(p) - 10., 1.);\n\n    // Cut out sphere around camera (didnt work for hollow shapes)\n    //float camd = length(p - ori()) - 2.2;\n    //d = -smin(-d, camd, 0.5).x;\n    \n    return vec2(d, sc);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        // use hash to hide artifacts\n        m.x *= 0.7 + 0.3 * hash(hash(p.x,p.z), p.y);\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0), 1.6);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    float l = length(p);\n    \n    vec3 bg = vec3(244,242,199)/255.;\n    \n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);        \n\n        vec3 ld = -normalize(p);\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 40.);\n        float fres = pow(1. + dot(rd,n),  5.);\n    \n        // Texture (maybe looks better without)\n        vec3 an = abs(n);\n        vec3 c1 = texture(iChannel0, 0.14 * p.xy).rgb;\n        vec3 c2 = texture(iChannel0, 0.14 * p.yz).rgb;\n        vec3 c3 = texture(iChannel0, 0.14 * p.zx).rgb;\n        col = an.z*c1+an.x*c2+an.y*c3;\n\n        // Shadow\n        float sd = shadow(p + 10. * SURF_DIST * n, ld);\n        col *= .5+.5*sd;\n        \n        // Specular\n        col = clamp(col + spec, 0., 1.);\n        \n        // Ambient occlusion (used incorrectly)\n        float ao = AO(p + 10. * SURF_DIST * n, n);\n        col = mix(col, vec3(1,0.5,0), .2+.2*thc(4.,8.*ao));\n        \n        // Fresnel (within 3.9-20. length from origin, was buggy)\n        float s = smoothstep(3.9, 5., l);// * (1.-smoothstep(14.,20., l));\n        col = mix(col, bg, s * fres);\n    }\n    else \n       col = bg;\n   \n    float xp = exp(-0.077 * l);\n    vec3 pl = pal(.5*log(l) + .73 + xp*m.z + (1.-xp)*vec3(.5,1,2)/3.);\n    col = mix(col, pl, xp);\n    col = 1. - col;\n    col = pow(col, vec3(1./2.2)); // gamma correction\n    col = 1. - col;  \n\n    // tanh causes artifacts\n    float o = 2.*pi/3.;\n    vec3 off = 0.4 * tanh(0.2 * t) * cos(t + vec3(-o,o,0));\n    col = tanh(vec3(.1,0,0) + (vec3(3.5,3.35,2.5)+off)*col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32134, "src": "https://soundcloud.com/floatingpoints/lesalpx-extended?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//        Tater - raymarching\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n//#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define pal(a) .5+.5*cos(2.*pi*(a))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nvec2 smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return vec2(mix(b, a, h) - k * h * (1. - h), h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 280, 280, 327], [329, 329, 341, 341, 566], [568, 568, 586, 607, 1895], [1897, 1897, 1936, 1936, 2470], [2472, 2472, 2491, 2491, 2673], [2675, 2675, 2719, 2719, 2910], [2912, 2912, 2944, 2944, 3179], [3181, 3181, 3219, 3219, 3562], [3564, 3564, 3621, 3621, 5436]], "test": "untested"}
{"id": "DtXSzs", "name": "Cheap parallax & shadows", "author": "djancool", "description": "Simple cheap parallax and shadows based on heightmap\nLots of artifacts with big parallax values\n\nYou can disable shadows with the \"SHADOWS\" define", "tags": ["simple", "parallax", "cheap"], "likes": 21, "viewed": 382, "published": 3, "date": "1675176420", "time_retrieved": "2024-07-30T18:12:48.655928", "image_code": "#define PARALLAX_INTENSITY 0.15\n#define SHADOWS\n//#define POINT_LIGHT\n\nvec3 reinhard(vec3 x)\n{\n    return x / (1.0 + x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV\n    vec2 uv = fragCoord/iResolution.x;\n    // Camera movement\n    vec2 cam = vec2(sin(iTime * 0.8), cos(iTime * 0.4)) * 0.3;\n    // Heightmap sample\n    float heightmap = texture(iChannel0, uv + cam).r;\n    // Tangent space view direction\n    vec3 viewDir_ts = vec3(0.0);\n    viewDir_ts.z = 1.0 - distance(uv, vec2(0.5));\n    viewDir_ts.xy = uv - vec2(0.5);\n    viewDir_ts = normalize(viewDir_ts);\n    // Parallax\n    vec2 parallax = viewDir_ts.xy * viewDir_ts.z * (heightmap - 0.5) * PARALLAX_INTENSITY;\n    // New texture with parallax\n    float tex = texture(iChannel0, uv - parallax + cam).r;\n    \n    vec2 tex_res = vec2(textureSize(iChannel0, 0));\n    \n    // Lighting\n    float tex_x1 = texture(iChannel0, uv - parallax + cam + vec2(1.0/tex_res.x, 0.0)).r;\n    float tex_y1 = texture(iChannel0, uv - parallax + cam + vec2(0.0, 1.0/tex_res.y)).r;\n    \n    float tex_ddx = tex - tex_x1;\n    float tex_ddy = tex - tex_y1;\n    \n    vec3 normal = normalize(vec3(tex_ddx, tex_ddy, 0.004));\n    #ifdef POINT_LIGHT\n    vec3 lightDir = normalize(vec3((iMouse.xy/iResolution.xy) - uv, 1.0));\n    #else\n    vec3 lightDir = normalize(vec3((iMouse.xy/iResolution.xy) - vec2(0.5), 1.0));\n    #endif\n    vec3 light_direct = max(0.0, dot(normal, lightDir)) * vec3(1.0, 0.89, 0.81);\n\n    #ifdef SHADOWS\n    float tex_shadow = texture(iChannel0, uv + cam - parallax + lightDir.xy * lightDir.z * heightmap *  0.5).r;\n    float shadow = pow(max(heightmap - tex_shadow, 0.0), 0.25);\n    #else\n    float shadow = 1.0;\n    #endif\n\n    vec3 fake_gi = tex * vec3(0.8,0.9,1.0) * 1.0;\n    \n    vec3 col = light_direct * 10.0 * shadow + fake_gi;\n    col = reinhard(col);\n\n    col *= pow(sin(uv.x * 3.141592) * sin(uv.y * 3.141592), 0.1);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 94, 94, 122], [124, 124, 181, 191, 1943]], "test": "untested"}
{"id": "DtfSRs", "name": "2D Voronoi testje", "author": "djancool", "description": "Voronoi test", "tags": ["voronoi"], "likes": 4, "viewed": 147, "published": 3, "date": "1675174441", "time_retrieved": "2024-07-30T18:12:49.421880", "image_code": "// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y + iTime * 0.3;\n    uv *= 15.0;\n\n    vec2 cellIndex = floor(uv);\n    vec2 cellUV = fract(uv);\n    float sum = 1000.0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            vec2 sampleIndex = vec2(i,j);\n            float dst = distance(cellUV, hash22(cellIndex + sampleIndex) + sampleIndex);\n            sum = min(dst, sum);\n        }\n    }\n        \n    fragColor = vec4(vec3(1.0-sum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 62, 62, 196], [198, 198, 255, 255, 754]], "test": "untested"}
{"id": "DtfSRl", "name": "Raytracer  (Release)", "author": "raymarchingenthusiast", "description": "A raytracer.", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 4, "viewed": 185, "published": 3, "date": "1675174053", "time_retrieved": "2024-07-30T18:12:50.183843", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n    irand(float(iFrame),i);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(a) clamp(a,0.,1.)\nstruct Material {\n    float roughness;\n    float shininess;\n    float glossiness;\n    vec3 color;\n};\n\nstruct PLight {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};\n\n#define A vec3(29.,11.,17.)\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*A.x+A.y,A.z)/A.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*A.x+A.y,A.z)/A.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}", "buffer_a_code": "#define R iResolution.xy\n#define F float(iFrame)\n#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 rd,float t) {\n    return vec3(.7,.9,1.);\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd,int lId,float t) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    float d2 = sphInt(ro,rd,vec3(-2.5,0.,2.5),1.).x;\n    if(d2 < 0.) d2 = Inf;\n    float d3 = sphInt(ro,rd,vec3(2.5,0.,3.5),1.).x;\n    if(d3 < 0.) d3 = Inf;\n    \n    float d = min(min(min(d3,d2),d0),d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d2) m = 1.;\n    if(d==d3) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nPLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return PLight(i,c,p+o);\n}\n\nvec3 getCam(float t,out vec3 uu,out vec3 vv,out vec3 ww) {\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n    //Keep above\n    \n    //Write below\n    \n    \n    \n    //Keep below\n    uu = normalize(uu);\n    vv = normalize(vv);\n    ww = normalize(ww);\n    return vec3(0.,1.,0.);\n}\n\nvec3 getObjectNorm(vec3 p, float id,float t) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id,float t) {\n    if(id==1.) return Material(.85,35.,.05,vec3(.2,.2,.2));\n    if(id==2.) return Material(.1,15.,.05,vec3(.2,.2,.2));\n}\n//Glossiness (3rd comp) and Roughness (1st comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,float s,vec3 p,vec3 n){\n    ro = p;\n    if(rand()<r){\n        rd = cosDir(n);\n    }else{\n        rd = normalize(reflect(rd,n)+uniformVector()*s);\n    }\n}\n\nbool inLight(vec3 ro,vec4 ld,int lID,float t){\n    vec2 tres = worldInt(ro,-ld.xyz,lID,t);\n    return tres.x>=ld.w||tres.y<1.;\n    return true;\n}\n\n//Lower this if rt is false?\n#define spp 1.\n#define rt false\n//Set to true if the camera or \n//objects can move\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    float ftime = rt?iTime:0.;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    //.6 is shutter aperture\n    float ctime = ftime + (.6/24.)*rand();\n    \n    vec3 uu;vec3 vv;vec3 ww;\n    vec3 ro = getCam(ctime,uu,vv,ww);\n    \n    vec3 er = normalize(vec3( p.xy, 1. ));\n    vec3 rd = er.x*uu+er.y*vv+er.z*ww;\n    \n    //.0015 is blur amount\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    //1.3 is focus distance\n    vec3 gd = normalize( er*1.3 - go );\n    \n    ro += go.x*uu+go.y*vv;\n    rd += gd.x*uu+gd.y*vv;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    //3 is number of levels\n    for(int i = 0; i < 10; i++){\n        vec2 tres = worldInt(ro,rd,-1,ctime);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd,ctime);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y,ctime);\n        vec3 ofp     = pos - nor*.001;\n        Material dat = getObjectData(pos,tres.y,ctime);\n        dat.shininess = 2./(dat.glossiness*(1.-dat.roughness));\n        \n        vec3 color = vec3(0.);\n        {\n            PLight l = genLight(1100.,vec3(1.,0.,0.),vec3(-10.,15.,.0),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,0,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        {\n            PLight l = genLight(1100.,vec3(0.,1.,0.),vec3(0.,15.,.5),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,1,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        {\n            PLight l = genLight(1100.,vec3(0.,0.,1.),vec3(10.,15.,1.),1.1);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld,2,ctime)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,1./dat.shininess,dat.glossiness,pos,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 123]], "test": "untested"}
{"id": "DlfXzl", "name": "minimal Modular Flow - big disks", "author": "FabriceNeyret2", "description": "variant with disks in contact. Mouse show tiling.\nCould it be possible to have a denser packing ?\n( tempting to offset one every two lines by .5 ( ~ hexa packing ), but this isn't compatible with the regular change of tilling. )", "tags": ["flow", "2tweets", "golf", "modular", "eigenvector", "eigenvalue"], "likes": 27, "viewed": 314, "published": 3, "date": "1675172098", "time_retrieved": "2024-07-30T18:12:51.061496", "image_code": "// big disks variant of https://www.shadertoy.com/view/cll3Rj\n// minimal variant of  https://shadertoy.com/view/ctlGRj\n// golfing 2041 chars \"Modular Flow\" by mla. https://shadertoy.com/view/dlXGRN\n\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, q, V,I,\n         U =   ( 8.* ( u+u - R ) / R.y  + 2. )                         // normalized coords\n             * mat2(cos( .1*iTime + vec4(0,33,11,0)))                  // rotation\n             - 2.;\n    float w = 16./R.y,                                                 // pixel width, for AA\n    \n          k = exp( log(2.618)* fract(iTime/4.) - .5 );                 // --- the heart of the transform\n    mat2  P = mat2( vec2(1,-1.618) / 1.9 ,                             // ( see mla original : https://shadertoy.com/view/dlXGRN )\n                    vec2(1,  .618) / 1.176 );                          // NB: P is orthonormal ( i.e. rotation )\n    q = vec2(k,1./k);                                                  // volume conservative shear. k: .6 → .92\n    V = P * ( U * q );                                                 // shear and rotate up to the next shear axis\n    \n    O *= 0.;\n    for( int i=0; i<9; i++ )                                           // visit neighborhood to complete disk footprint (shouldn't 4 be enough ? )\n        I = round(V) + vec2(i%3,i/3) - 1.,                             // neighbor Id. V-I = local coord\n        O += smoothstep( w, -w,  length( ( V - I ) * P / q ) - .48 )   // draw disks via back-transform\n             * ( iMouse.z>0. ? hue( ( I.x+17.*I.y)/12. ) : vec4(1) );  // mouse: color disks\n          // * ( ( mod(I.x+I.y,2.) < 1. ) ? .5 : 1. ) ;                // checker\n     // O += sin( 30. * length( ( V - round(V) ) * P / q ) ) -O;       \n     // O += .05/ dot( u = ( V - I ) * P / q , u );\n        \n  // O = sin(30.*O);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 295, 295, 1912]], "test": "untested"}
{"id": "ctfSRl", "name": "my voronoi of the day", "author": "jonasfrey", "description": "voronoi, use the mouse to have fun", "tags": ["voronoi"], "likes": 8, "viewed": 176, "published": 3, "date": "1675164136", "time_retrieved": "2024-07-30T18:12:51.837422", "image_code": "float f_n_rnd(float n){\n\n    n = fract(n*.1031);\n    n *= n+33.33;\n    n *= n+n;\n    return fract(n);\n    \n}\nvec2 f_o_rnd(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 o_fccp = o_fc;\n    vec2 o_mc = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    if(iMouse.z == 0.){\n        float n_amp = sin(iTime*0.2);\n        o_mc = vec2(sin(iTime), cos(iTime))*n_amp;\n    }\n    vec2 o_mccp = o_mc;\n\n    o_fc *= 18.;\n    o_mc *= 18.;\n    float n_tau =6.2831;\n    float n_amp = 2.;\n    float n_dmin = 1.;\n\n    vec2 o_fcmcdlt = o_fc-o_mc;\n    float n_ang = fract(atan(o_fcmcdlt.y, o_fcmcdlt.x)/n_tau);\n    float n_intensity = clamp(length(o_fccp - o_mccp), 0., 1.);\n    vec2 o_fcf = fract(o_fc)-.5;\n    vec2 o_sclk = vec2(9.);\n    float n_min = floor(o_sclk.x/2.);\n    for(float n_x = -n_min; n_x <= n_min; n_x+=1.){\n        for(float n_y = -n_min; n_y <= n_min; n_y+=1.){\n            vec2 o_fck = vec2(n_x, n_y);\n            vec2 o_rnd = f_o_rnd(floor(o_fc)+o_fck);\n            vec2 o_amp_rnd = n_amp*o_rnd;\n            n_intensity = n_ang*(1.-length(o_fcmcdlt));\n            vec2 o_dlt = (floor(o_fc)+o_fck)-o_mc;\n            float n_ang = atan(o_dlt.x, o_dlt.y);\n            vec2 o_off = vec2(\n                    sin(n_ang)*n_amp,//sin(iTime+(o_fc.x/2.)),//sin(iTime+o_rnd.x)*o_amp_rnd.x, \n                    cos(n_ang)*n_amp//sin(iTime+(o_fc.y/2.))//0.//cos(iTime+o_rnd.y)*o_amp_rnd.y \n            );\n            \n            o_fck += o_off;\n\n            float n = length(o_fcf-o_fck);\n            if(n < n_dmin ){\n                n_dmin = n;\n            }\n        }\n    }\n    fragColor = vec4(sqrt(n_dmin));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 108], [109, 109, 131, 131, 265], [266, 266, 323, 323, 1835]], "test": "untested"}
{"id": "mllSRf", "name": "Raytracer  (Beta)", "author": "raymarchingenthusiast", "description": "A raytracer.\nFixed issue involving plane and shadows.", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 1, "viewed": 177, "published": 3, "date": "1675153714", "time_retrieved": "2024-07-30T18:12:52.610355", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(a) clamp(a,0.,1.)\nstruct Object {\n    vec3 a; //Position\n    vec3 b; //Size/Normal/x=Raidus\n    vec2 r; //Roatation\n    \n    int type;\n    //0 -> Sphere\n    //1 -> Box\n    //2 -> Plane\n};\n\nstruct Material {\n    float roughness;\n    float shininess;\n    float glossiness;\n    vec3 color;\n};\n\nstruct PLight {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};", "buffer_a_code": "#define R iResolution.xy\n#define F float(iFrame)\n#define A vec3(23.,7.,11.)\n#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*A.x+A.y,A.z)/A.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*A.x+A.y,A.z)/A.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 rd) {\n    return max(.25+.75*rd,0.);\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    \n    float d = min(d0,d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nPLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return PLight(i,c,p+o);\n}\n\nvec3 getObjectNorm(vec3 p, float id) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id) {\n    if(id==1.) return Material(.8,35.,.15,vec3(.2,.2,.2));\n    if(id==2.) return Material(.4,15.,.01,vec3(.025,.2,.075));\n}\n//Glossiness (3rd comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,float s,vec3 p,vec3 n){\n    ro = p;\n    if(rand()<r){\n        rd = cosDir(n);\n    }else{\n        rd = normalize(reflect(rd,n)+uniformVector()*s);\n    }\n}\n\nbool inLight(vec3 ro,vec4 ld){\n    vec2 tres = worldInt(ro,-ld.xyz);\n    return tres.x>=ld.w||tres.y<1.;\n    return true;\n}\n\n//Lower this if rt is false?\n#define spp 4.\n#define rt true\n//Set to true if the camera or \n//objects can move\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    vec3 rd = normalize( vec3( p.xy, 1. ) );\n\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    vec3 gd = normalize( rd*1.3 - go );\n    vec3 ro = vec3(go.xy,0.);\n    rd.xy += gd.xy;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < 2; i++){\n        vec2 tres = worldInt(ro,rd);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y);\n        vec3 ofp     = pos - nor*.001;\n        Material dat = getObjectData(pos,tres.y);\n        dat.shininess = 1./(.5*dat.glossiness*(1.-dat.roughness));\n        \n        vec3 color = vec3(0.);\n        {\n            PLight l = genLight(250.,vec3(1.),vec3(-5.,5.,-5.),.9);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,1./dat.shininess,dat.glossiness,pos,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n    //O.xyz /= O.w;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 95]], "test": "untested"}
{"id": "ctlXRX", "name": "Raytracer (Alpha 2)", "author": "raymarchingenthusiast", "description": "A raytracer.\nFixed issue involving plane and shadows.", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 0, "viewed": 141, "published": 3, "date": "1675151981", "time_retrieved": "2024-07-30T18:12:53.590734", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(a) clamp(a,0.,1.)\nstruct Object {\n    vec3 a; //Position\n    vec3 b; //Size/Normal/x=Raidus\n    vec2 r; //Roatation\n    \n    int type;\n    //0 -> Sphere\n    //1 -> Box\n    //2 -> Plane\n};\n\nstruct Material {\n    float roughness;\n    float shininess;\n    vec3 color;\n};\n\nstruct PLight {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};", "buffer_a_code": "#define R iResolution.xy\n#define F float(iFrame)\n#define A vec3(23.,7.,11.)\n#define Inf 9999.\n#define G 1./2.2\n\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*A.x+A.y,A.z)/A.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*A.x+A.y,A.z)/A.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}\n\nvec3 cosineDirection(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector( in float seed)\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 rd) {\n    return max(.25+.75*rd,0.);\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    \n    float d = min(d0,d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nPLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return PLight(i,c,p+o);\n}\n\nvec3 getObjectNorm(vec3 p, float id) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id) {\n    if(id==1.) return Material(1.,15.,vec3(.2,.2,.2));\n    if(id==2.) return Material(1.,60.,vec3(.025,.2,.075));\n}\n\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = reflect(rd,n);\n}\n\nbool inLight(vec3 ro,vec4 ld){\n    vec2 tres = worldInt(ro,-ld.xyz);\n    return tres.x>=ld.w||tres.y<1.;\n    return true;\n}\n\n//Lower this if rt is false?\n#define spp 4.\n#define rt true\n//Set to true if the camera or \n//objects can move\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    vec3 rd = normalize( vec3( p.xy, 1. ) );\n\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    vec3 gd = normalize( rd*1.3 - go );\n    vec3 ro = vec3(go.xy,0.);\n    rd.xy += gd.xy;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < 2; i++){\n        vec2 tres = worldInt(ro,rd);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n    \n        vec3 nor     = getObjectNorm(pos,tres.y);\n        vec3 ofp     = pos - nor*.001;\n        Material dat = getObjectData(pos,tres.y);\n        \n        vec3 color = vec3(0.);\n        {\n            PLight l = genLight(250.,vec3(1.),vec3(-5.,5.,-5.),.9);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(ofp,ld)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,pos,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n    //O.xyz /= O.w;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 95]], "test": "untested"}
{"id": "dtlSRf", "name": " fbmnoise and color test 01 ", "author": "tianluo97", "description": " fbmnoise and color test 01 ", "tags": ["fbmnoiseandcolortest01"], "likes": 0, "viewed": 138, "published": 3, "date": "1675149093", "time_retrieved": "2024-07-30T18:12:54.382616", "image_code": "vec2 hash( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Copied from the book of shaders: https://thebookofshaders.com/13/\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(44.0));\t\n}\n\n//Copied from the same book of shaders chapter\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat gain( float edge0, float edge1,float x, float k )\n{\n  float t = clamp((x - edge0) / (edge1 - edge0), 0., 1.0); \n  float s = sign(t-0.5);\n  float o = (1.0+s)/2.0;\n  return o - 0.5*s*pow(2.0*(o-s*t),k);\n}\n\nvec4 gmix(vec4 x, vec4 y, float t){\n    float gamma=iMouse.y/ iResolution.y+1.0;\n    gamma=0.92;\n    vec4 cout= vec4(0.0);\n    cout.a= (1.0-t)*x.a + t*y.a;\n    cout.r= pow(  pow((1.0-t)*x.r,  gamma) +  pow(t*y.r,gamma), 1.0/gamma);\n    cout.g= pow(  pow((1.0-t)*x.g,  gamma) +  pow(t*y.g,gamma), 1.0/gamma);\n    cout.b= pow(  pow((1.0-t)*x.b,  gamma) +  pow(t*y.b,gamma), 1.0/gamma);\n    return cout;  \n}\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(938, 384);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3均为可调参数\n    vec4 color1 = vec4(0.71373,0.85882,0.92157,1.0); \n    vec4 color2 = vec4(0.576,0.412,0.969,1.0);\n    vec4 color3 = vec4(0.0,0.0,1.0,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.3; \n    \n    //scale为可调参数\n    float scale = 1.0;\n    //colorStep1为可调参数\n    float colorStep1 = 0.33333;\n    //colorStep2为可调参数\n    float colorStep2 = 0.66666;\n\n    float ease[3];\n    ease[0] = -(cos(PI * fract(time/scale)) - 1.0)/2.0 * scale;  \n    ease[1] = fract(time/scale)*scale;\n    ease[2] = (1.0 - pow(1.0 - fract(time/scale),3.0))*scale;\n    \n    float easeChoice = mod(time/scale,4.0);\n    int i = int(easeChoice);\n    float offset  = ease[i] + floor(time/scale)*scale;\n    offset = uv.y - offset;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    float wid= 0.001;\n    float k=0.7;\n    if (y < step1) {\n    \n      if (texCoord.x<0.5){\n      // float dist1 = gain(0.0+wid, step1-wid, y, k);\n  \n    //dist1 = powdist(dist1);\n        float dist1 = smoothstep(0.0+wid, step1-wid, y); \n        fragColor =  mix(color1, color2, dist1);\n      }\n       else{\n      //float dist1 = smoothstep(0.0+wid, step1-wid, y);\n       float dist1 = gain(0.0+wid, step1-wid, y, k);\n         fragColor =  gmix(color1, color2, dist1);\n       }\n    }\n    \n    //绿到蓝 step1 - step2\n    else if (y > step1 && y < step2) {\n   // float dist2 =  gain(step1+wid, step2-wid, y, k);\n    \n     if (texCoord.x<0.5){\n     float dist2 = smoothstep( step1+wid, step2-wid, y);\n     fragColor =  mix(color2, color3, dist2);\n     }\n      else{\n      //float dist2 = smoothstep( step1+wid, step2-wid, y);\n       float dist2 =  gain(step1+wid, step2-wid, y, k);\n       fragColor =  gmix(color2, color3, dist2);\n       }\n    //fragColor = vec4(dist2,dist2,dist2,1.0);\n     \n    // fragColor =  vec4(dist2,dist2,dist2,1.0);\n    }\n    \n    //蓝到红 step2 - 1.0\n    else{\n   // float dist3 =  gain(step2 + wid, (1.0-wid) * scale, y, k);\n     \n    if (texCoord.x<0.5){\n    float dist3 = smoothstep( step2 + wid, (1.0-wid) * scale, y);\n     fragColor = mix(color3, color1, dist3);\n    }else{\n    //float dist3 = smoothstep( step2 + wid, (1.0-wid) * scale, y);\n float dist3 =  gain(step2 + wid, (1.0-wid) * scale, y, k);\n     \n     fragColor = gmix(color3, color1, dist3);\n    }\n    //dist3= powdist(dist3);\n   // fragColor = vec4 (dist3,dist3,dist3,1.0);\n   \n    }\n    \n    //fbm color\n    vec2 uv2 = uv;\n\tuv2.x *= 4.0;\n\tuv2.y *= 1.0; \n    uv2.x += time * 0.4;\n    uv2.y -= time;\n\tvec3 col = mix(vec3(0.0,0.0,0.), vec3(1.), fbm(uv2 - vec2(2.0*iTime)));\n\tvec3 color = vec3(0.0);\n  \n    //第一层基础fbm的流动 uv+time\n\tvec2 q = vec2(0.);\n    q.x = fbm(uv2 - .4 * iTime);\n    q.y = fbm(uv2 - vec2(1.0));\n\n    //在第一层fbm的基础上再进行一次fbm，uv+ r + time, time可以改变流速\n\tvec2 g = vec2(0.);\n    g.x = fbm( uv2 - 1.0*q + vec2(1.7,9.2) -  .5 * iTime );\n    g.y = fbm( uv2 - 1.0*q + vec2(8.3,2.8) -  .26 * iTime);\n\n    //得到基础的fbm\n\tfloat f = fbm(uv2+g);\n  \n    color = mix(vec3(0.0,0.0,0.0),\n                vec3(.2,.2,.2),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.7,0.7,0.7),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(1.0,1.0,1.0),\n                clamp(length(g.x),0.0,1.0));\n\n    //提升黑白区的对比度\n    vec4 fbmColor = vec4((f*f*f+.6*f*f+.5*f)*vec3(1.),1.);\n\t//fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),color.r);\n      \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 137], [139, 139, 158, 158, 234], [236, 383, 409, 409, 933], [1005, 1005, 1031, 1031, 1369], [1371, 1371, 1428, 1428, 1579], [1581, 1581, 1616, 1616, 1985], [2136, 2136, 2193, 2230, 6409]], "test": "untested"}
{"id": "dtsXzX", "name": "fbmnoise test 02", "author": "tianluo97", "description": "perlin noise", "tags": ["fbmnoisetest02"], "likes": 0, "viewed": 145, "published": 3, "date": "1675148039", "time_retrieved": "2024-07-30T18:12:55.152558", "image_code": "\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec2 P)\n{\n\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n//Copied from the same book of shaders chapter\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * cnoise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(938, 84);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3均为可调参数\n    vec4 color1 = vec4(0.71373,0.85882,0.92157,1.0); \n    vec4 color2 = vec4(0.60000,0.67843,1.0,1.0);\n    vec4 color3 = vec4(0.200,0.200,1.000,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.1; \n    \n    //scale为可调参数\n    float scale = 3.0;\n    //colorStep1为可调参数\n    float colorStep1 = 0.33333;\n    //colorStep2为可调参数\n    float colorStep2 = 0.66666;\n\n    float ease[3];\n    ease[0] = -(cos(PI * fract(time/scale)) - 1.0)/2.0 * scale;  \n    ease[1] = fract(time/scale)*scale;\n    ease[2] = (1.0 - pow(1.0 - fract(time/scale),3.0))*scale;\n    \n    float easeChoice = mod(time/scale,4.0);\n    int i = int(easeChoice);\n    float offset  = ease[i] + floor(time/scale)*scale;\n    offset = uv.y - offset;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n    fragColor = mix(color3, color1, dist1);\n    }\n    \n    //红到蓝 step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color1, color2, dist2);\n    }\n    \n    //蓝到绿 step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = mix(color2, color3, dist3);\n    }\n    \n    //fbm color\n    vec2 uv2 = uv;\n\tuv2.x *= 4.0;\n\tuv2.y *= 1.0; \n    uv2.x += time * 0.4;\n    uv2.y -= time;\n\tvec3 col = mix(vec3(0.0,0.0,0.), vec3(1.), fbm(uv2 - vec2(2.0*iTime)));\n\tvec3 color = vec3(0.0);\n  \n    //第一层基础fbm的流动 uv+time\n\tvec2 q = vec2(0.);\n    q.x = fbm(uv2 - .4 * iTime);\n    q.y = fbm(uv2 - vec2(1.0));\n\n    //在第一层fbm的基础上再进行一次fbm，uv+ r + time, time可以改变流速\n\tvec2 g = vec2(0.);\n    g.x = fbm( uv2 - 1.0*q + vec2(1.7,9.2) -  .5 * iTime );\n    g.y = fbm( uv2 - 1.0*q + vec2(8.3,2.8) -  .26 * iTime);\n\n    //得到基础的fbm\n\tfloat f = fbm(uv2+g);\n  \n    color = mix(vec3(0.0,0.0,0.0),\n                vec3(.2,.2,.2),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.7,0.7,0.7),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(1.0,1.0,1.0),\n                clamp(length(g.x),0.0,1.0));\n\n    //提升黑白区的对比度\n    vec4 fbmColor = vec4((f*f*f+.6*f*f+.5*f)*vec3(1.),1.);\n\tfragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),color.r);\n      \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 72], [74, 74, 96, 96, 133], [135, 135, 163, 163, 215], [217, 217, 236, 236, 276], [278, 278, 300, 300, 1343], [1415, 1415, 1441, 1441, 1780], [1931, 1931, 1988, 2025, 5152]], "test": "untested"}
{"id": "dllXzX", "name": "fbmnoise test 01", "author": "tianluo97", "description": "td noise", "tags": ["fbmnoisenoisetest01"], "likes": 0, "viewed": 112, "published": 3, "date": "1675147346", "time_retrieved": "2024-07-30T18:12:55.941448", "image_code": "\n\nvec2 hash( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Copied from the book of shaders: https://thebookofshaders.com/13/\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(44.0));\t\n}\n\n//Copied from the same book of shaders chapter\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(938, 84);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3均为可调参数\n    vec4 color1 = vec4(0.71373,0.85882,0.92157,1.0); \n    vec4 color2 = vec4(0.60000,0.67843,1.0,1.0);\n    vec4 color3 = vec4(0.180,0.180,1.000,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.3; \n    \n    //scale为可调参数\n    float scale = 3.0;\n    //colorStep1为可调参数\n    float colorStep1 = 0.33333;\n    //colorStep2为可调参数\n    float colorStep2 = 0.66666;\n\n    float ease[3];\n    ease[0] = -(cos(PI * fract(time/scale)) - 1.0)/2.0 * scale;  \n    ease[1] = fract(time/scale)*scale;\n    ease[2] = (1.0 - pow(1.0 - fract(time/scale),3.0))*scale;\n    \n    float easeChoice = mod(time/scale,4.0);\n    int i = int(easeChoice);\n    float offset  = ease[i] + floor(time/scale)*scale;\n    offset = uv.y - offset;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n    fragColor = mix(color3, color1, dist1);\n    }\n    \n    //红到蓝 step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color1, color2, dist2);\n    }\n    \n    //蓝到绿 step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = mix(color2, color3, dist3);\n    }\n    \n    //fbm color\n    vec2 uv2 = uv;\n\tuv2.x *= 4.0;\n\tuv2.y *= 1.0; \n    uv2.x += time * 0.4;\n    uv2.y -= time;\n\tvec3 col = mix(vec3(0.0,0.0,0.), vec3(1.), fbm(uv2 - vec2(2.0*iTime)));\n\tvec3 color = vec3(0.0);\n  \n    //第一层基础fbm的流动 uv+time\n\tvec2 q = vec2(0.);\n    q.x = fbm(uv2 - .4 * iTime);\n    q.y = fbm(uv2 - vec2(1.0));\n\n    //在第一层fbm的基础上再进行一次fbm，uv+ r + time, time可以改变流速\n\tvec2 g = vec2(0.);\n    g.x = fbm( uv2 - 1.0*q + vec2(1.7,9.2) -  .5 * iTime );\n    g.y = fbm( uv2 - 1.0*q + vec2(8.3,2.8) -  .26 * iTime);\n\n    //得到基础的fbm\n\tfloat f = fbm(uv2+g);\n  \n    color = mix(vec3(0.0,0.0,0.0),\n                vec3(.2,.2,.2),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.7,0.7,0.7),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(1.0,1.0,1.0),\n                clamp(length(g.x),0.0,1.0));\n\n    //提升黑白区的对比度\n    vec4 fbmColor = vec4((f*f*f+.6*f*f+.5*f)*vec3(1.),1.);\n\tfragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),color.r);\n      \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 139], [141, 141, 160, 160, 236], [238, 385, 411, 411, 935], [1007, 1007, 1033, 1033, 1371], [1522, 1522, 1579, 1616, 4743]], "test": "untested"}
{"id": "mtlXRX", "name": "test gradient demo", "author": "tianluo97", "description": "test gradient demo", "tags": ["testgradientdemo"], "likes": 1, "viewed": 171, "published": 3, "date": "1675135912", "time_retrieved": "2024-07-30T18:12:56.782200", "image_code": "float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n// Copied from the book of shaders: https://thebookofshaders.com/13/\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//Copied from the same book of shaders chapter\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(938, 84);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3均为可调参数\n    vec4 color1 = vec4(1.0,0.,0.,1.0); \n    vec4 color2 = vec4(0.,1.,0.0,1.0);\n    vec4 color3 = vec4(0.0,0.0,1.0,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.0; \n    \n    //scale为可调参数\n    float scale = 1.0;\n    //colorStep1为可调参数\n    float colorStep1 = 0.33333;\n    //colorStep2为可调参数\n    float colorStep2 = 0.66666;\n\n    float ease[3];\n    ease[0] = -(cos(PI * fract(time/scale)) - 1.0)/2.0 * scale;  \n    ease[1] = fract(time/scale)*scale;\n    ease[2] = (1.0 - pow(1.0 - fract(time/scale),3.0))*scale;\n    \n    float easeChoice = mod(time/scale,4.0);\n    int i = int(easeChoice);\n    float offset  = ease[i] + floor(time/scale)*scale;\n    offset = uv.y - offset;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    //红到绿 step0 - step1\n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    //绿到蓝 step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    //fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color3, dist2);\n    }\n    \n    //蓝到红 step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = mix(color3, color1, dist3);\n    }\n    \n    fragColor = pow(fragColor,vec4(1./2.2));\n    \n    \n    //fbm color\n    vec2 uv2 = uv;\n\tuv2.x *= 20.0;\n\tuv2.y *= 4.0; \n    uv2.x += time * 0.4;\n    uv2.y -= time;\n\tvec3 col = mix(vec3(0.0,0.0,0.), vec3(1.), fbm(uv2 - vec2(2.0*iTime)));\n\tvec3 color = vec3(0.0);\n  \n    //第一层基础fbm的流动 uv+time\n\tvec2 q = vec2(0.);\n    q.x = fbm(uv2 - .4 * iTime);\n    q.y = fbm(uv2 - vec2(1.0));\n\n    //在第一层fbm的基础上再进行一次fbm，uv+ r + time, time可以改变流速\n\tvec2 g = vec2(0.);\n    g.x = fbm( uv2 - 1.0*q + vec2(1.7,9.2) -  .5 * iTime );\n    g.y = fbm( uv2 - 1.0*q + vec2(8.3,2.8) -  .26 * iTime);\n\n    //得到基础的fbm\n\tfloat f = fbm(uv2+g);\n  \n    color = mix(vec3(0.0,0.0,0.0),\n                vec3(.2,.2,.2),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.7,0.7,0.7),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(1.0,1.0,1.0),\n                clamp(length(g.x),0.0,1.0));\n\n    //提升黑白区的对比度\n    vec4 fbmColor = vec4((f*f*f+.6*f*f+.5*f)*vec3(1.),1.);\n\t//fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),fbmColor.r * 0.5);\n      \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [224, 371, 397, 397, 777], [849, 849, 875, 875, 1213], [1365, 1365, 1422, 1459, 4655]], "test": "untested"}
{"id": "DlsXzX", "name": "sound pendulum", "author": "jonasfrey", "description": "pendulum, \ninspired by this https://www.youtube.com/watch?v=4GaGnU8Ij2Y&t=623s", "tags": ["sound", "audio", "sine", "pendulum"], "likes": 23, "viewed": 507, "published": 3, "date": "1675128693", "time_retrieved": "2024-07-30T18:12:57.672819", "image_code": "\nvec3 f_hsl2rgb( in vec3 c )\n{\n    // from here https://www.shadertoy.com/view/XljGzV\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    o_fc*=1.32;\n    o_fc+=vec2(0.,0.5);\n    float n_t = iTime;\n    vec4 o_col = vec4(0.);\n    vec2 o_freq;\n    float n_its = 33.;\n    float n_one_it = 1./n_its;\n    \n    float n_hz_start = 60.;\n    float n_hz = n_hz_start;\n    //n_ampfade = pow(n_ampfade,2.);\n    float n_offset = sin(n_t*0.1)*2.;\n    \n    float n_dmin = 1.;\n    float n_tau = 6.283185;\n    float n_ang_ball_nor = 0.;\n    \n    for(float n_it=0.; n_it<n_its;n_it+=1.){\n        float n_it_nor = n_it/n_its;\n        float n_radius = n_it_nor;\n        float n_ang = -(n_t+n_it_nor*n_offset)*(n_tau/2.)-n_tau/4.;\n        float n_ampfade = n_one_it-fract(n_t+n_it_nor*n_offset)*n_one_it;\n \n        n_hz += n_hz/2.;\n        \n        vec2 o_p = vec2(\n            sin(sin(n_ang)*(n_tau/4.))*n_radius,\n            cos(sin(n_ang)*(n_tau/4.))*n_radius\n        );\n        float n_d = length(o_p-o_fc);\n        if(n_d < n_dmin){\n            if(mod(floor(n_t+n_it_nor*n_offset),2.)== 0.){\n                n_ang_ball_nor = (sin(n_ang)*(n_tau/4.))/(n_tau/2.);\n            }else{\n                n_ang_ball_nor = 1.-(sin(n_ang)*(n_tau/4.))/(n_tau/2.);\n            }\n            n_ang_ball_nor = abs(fract(-1.*n_ang_ball_nor-.5));\n            \n            n_dmin = n_d;\n        }\n    }\n    float n_rball = 1./n_its*.5;\n    float n_aa = (1./iResolution.x)*10.;\n    float n_dball = smoothstep(n_rball+n_aa, n_rball, n_dmin);\n    float n_dballoutline = smoothstep(\n        0.+n_aa,\n        0.,\n        abs(n_dmin-n_rball)\n    );\n    \n    float n_dcntr = length(o_fc);\n    float n_it = ((n_dcntr-n_one_it*.5) / n_one_it);\n    float n_itnor = floor(n_it)/ n_its;\n    float n_itnor2 = sin((clamp(n_dcntr,0.,1.))*n_tau*n_its+n_tau/4.);\n    n_itnor = clamp(n_itnor, 0., 1.-n_one_it);\n    n_itnor2 = clamp(n_itnor2, 0., 1.);\n    n_it = clamp(n_it, 0.,n_its-1.);\n    float n_dorbitoutline = smoothstep(\n        .05+n_aa*10.,\n        .0,\n        abs(fract(n_it)-.5)\n    );\n    float n_rline = 0.01;\n    //n_dorbitoutline = n_itnor2;\n\n    float n_dlinebot = smoothstep(\n        n_aa,\n        0.0,\n        abs(o_fc.y+n_rball)\n    );\n    float n_dlinebelowbot = float(o_fc.y > 0.-n_rball);\n    //o_col += clamp(n_dballoutline,0.,1.)-(n_dball*n_ang_ball_nor);\n    o_col += (n_dball*n_ang_ball_nor)+n_dballoutline;\n    o_col += vec4(n_dorbitoutline);\n    o_col += n_dlinebot;\n    vec3 o_col_orbit = f_hsl2rgb(vec3(n_itnor, .5, .5));\n    \n    o_col *= n_dlinebelowbot;\n    o_col = o_col*vec4(o_col_orbit, 1.);\n\n    fragColor = o_col;\n    //fragColor += vec4(n_itnor);\n    \n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n   \n    float n_t = time*1.;\n    \n    vec2 o_amp;\n    float n_its = 33.;\n    float n_one_it = 1./n_its;\n    \n    float n_hz_start = 60.;\n    float n_hz = n_hz_start;\n    float n_tau = 6.283185;\n    //n_ampfade = pow(n_ampfade,2.);\n    float n_offset = sin(n_t*0.1)*2.;\n    for(float n_it=0.; n_it<n_its;n_it+=1.){\n        float n_it_nor = n_it/n_its;\n\n        float n_ampfade = n_one_it-fract(n_t+n_it_nor*n_offset)*n_one_it;\n        float n_amp = sin(n_tau*n_hz*time)*n_ampfade;\n        if(mod(floor(n_t+n_it_nor*n_offset),2.)== 0.){\n            o_amp.x += n_amp;\n        }else{\n            o_amp.y += n_amp;\n        }\n            \n        n_hz = n_hz_start * n_it;\n    }\n    //n_freq += sin(6.2831*220.0*time)*exp(-n_t);\n    // A 440 Hz wave that attenuates quickly overt time\n    \n    return o_amp*0.5;//loudness reduction\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 85, 228], [231, 231, 288, 288, 2860]], "test": "untested"}
{"id": "mllSzj", "name": "Raytracer (Alpha)", "author": "raymarchingenthusiast", "description": "A raytracer.\nKnown issue involving the plane.", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 1, "viewed": 123, "published": 3, "date": "1675116866", "time_retrieved": "2024-07-30T18:12:58.445753", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(a) clamp(a,0.,1.)\nstruct Object {\n    vec3 a; //Position\n    vec3 b; //Size/Normal/x=Raidus\n    vec2 r; //Roatation\n    \n    int type;\n    //0 -> Sphere\n    //1 -> Box\n    //2 -> Plane\n};\n\nstruct Material {\n    float roughness;\n    float shininess;\n    vec3 color;\n};\n\nstruct Light {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};", "buffer_a_code": "#define R iResolution.xy\n#define F float(iFrame)\n#define a vec3(23.,7.,11.)\n#define Inf 9999.\n#define G 1./2.2\n\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*a.x+a.y,a.z)/a.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*a.x+a.y,a.z)/a.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}\n\nvec3 getSky(vec3 rd) {\n    return .5+.5*rd;\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    \n    float d = min(d0,d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return Light(i,c,p+o);\n}\n\nvec3 getObjectNorm(vec3 p, float id) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id) {\n    if(id==1.) return Material(1.,15.,vec3(.2,.2,.2));\n    if(id==2.) return Material(1.,60.,vec3(.025,.2,.075));\n}\n\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = reflect(rd,n);\n}\n\nbool inLight(vec3 ro,vec4 ld){\n    vec2 tres = worldInt(ro,-ld.xyz);\n    return tres.x>=ld.w||tres.y==0.;\n    return true;\n}\n\nvec3 getPixCol(vec2 I) {\n    irand(F,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    vec3 rd = normalize( vec3( p.xy, 1. ) );\n\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    vec3 gd = normalize( rd*1.3 - go );\n    vec3 ro = vec3(go.xy,0.);\n    rd.xy += gd.xy;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < 2; i++){\n        vec2 tres = worldInt(ro,rd);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n    \n        vec3 nor     = getObjectNorm(pos,tres.y);\n        //vec3 ofp     = pos + nor*.001;\n        Material dat = getObjectData(pos,tres.y);\n        \n        vec3 color = vec3(0.);\n        {\n            Light l = genLight(250.,vec3(1.),vec3(-5.,5.,-5.),.9);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(pos,ld)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,pos,nor);\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0) O += texelFetch(iChannel0,ivec2(I),0);\n    //O.xyz /= O.w;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 95]], "test": "untested"}
{"id": "dlXXzf", "name": "Noise SDF #2", "author": "larserik", "description": "Raymarched noise ground", "tags": ["noise", "raymarch", "sdf"], "likes": 8, "viewed": 259, "published": 3, "date": "1675114029", "time_retrieved": "2024-07-30T18:12:59.293486", "image_code": "// Made using https://www.shadertoy.com/view/WtGXDD by Martijn Steinrucken as a starting point\n\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define SURF_DIST .01\n\n#define PI 3.1415\n#define TAU 6.2831\n\nfloat speed = .02;\nfloat scale = .01;\nint octaves = 8;\nint repeats = 0;\nfloat height = 20.;\nvec3 sky = vec3(.9, .93, .99);\nvec3 lp = vec3(100, 50, -100);\n\nfloat fbm (in vec3 st) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 sdFloor(vec3 uv) {\n\n    float time = iTime * speed;\n    vec2 scaled = uv.xz * scale;\n    scaled -= time;\n    \n    float n = fbm(vec3(scaled, 1.));\n\n    for (int i = 0; i<repeats; i++) {\n      float ang = n * PI;\n      n = fbm(vec3(scaled + vec2(cos(ang), sin(ang)) * n, 1.));\n    }\n    \n    n = n;\n        \n    return vec2(uv.y + 10. - n * height, n);\n}\n\n\nvec2 GetDist(vec3 p) {\n    vec2 d = sdFloor(p);\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO=vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        float j = 1. - length(dO.x) / MAX_DIST;\n        octaves = 2 + int(8. * pow(j, .25));\n    \n    \tvec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 lp, vec3 p, vec3 n) {\n    vec3 l = normalize(lp - p);\n    float dif = clamp(dot(n, l)*.4+.39, 0., 1.);\n    \n    vec2 dh = RayMarch(p + n*SURF_DIST*6., l);\n    float d = dh.x;\n    \n    if (d < length(lp)) {\n        dif *= .5;\n    }\n\n    return dif;\n    //return dot(n, normalize(vec3(1,2,4)))*.5+.5\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 20.5, 0);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    ro.y = max(.01, ro.y);\n    \n    vec3 la = vec3(0, 3.5, 0);\n    \n    vec3 rd = GetRayDir(uv, ro, la, 1.);\n    vec3 col = vec3(.9, .93, .99);\n   \n    vec2 d = RayMarch(ro, rd);\n\n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n    \n        col = mix(\n            vec3(.05, .53, .17),\n            vec3(.73, .77, .71),\n            d.y * 2.\n        );\n    \n        //float dif = dot(n, normalize(vec3(1,2,4)))*.5+.5;\n        float dif = GetLight(lp, p, n);\n        col *= vec3(dif);\n                \n        float off =  pow(1. - (d.x / MAX_DIST), .4);\n        col = mix(sky, col, off);\n    }\n    \n    col = pow(col, vec3(.9545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 380, 380, 640], [642, 642, 661, 661, 723], [725, 725, 748, 748, 1083], [1086, 1086, 1108, 1108, 1154], [1156, 1156, 1189, 1189, 1533], [1535, 1535, 1559, 1559, 1757], [1759, 1759, 1809, 1809, 2000], [2002, 2002, 2043, 2043, 2321], [2323, 2323, 2380, 2380, 3329]], "test": "untested"}
{"id": "clXXzf", "name": "Noise SDF #1", "author": "larserik", "description": "Raymarched noise ground, Alien waters. :)", "tags": ["noise", "raymarch", "sdf", "fluid"], "likes": 6, "viewed": 320, "published": 3, "date": "1675108708", "time_retrieved": "2024-07-30T18:13:00.232974", "image_code": "// Made using https://www.shadertoy.com/view/WtGXDD by Martijn Steinrucken as a starting point\n\n#define MAX_STEPS 50\n#define MAX_DIST 150.\n#define SURF_DIST .05\n\n#define PI 3.1415\n#define TAU 6.2831\n\nfloat speed = .05;\nfloat scale = .01;\nint octaves = 3;\nint repeats = 1;\nfloat height = 4.;\n\nfloat fbm (in vec3 st) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 sdFloor(vec3 uv) {\n\n    float time = iTime * speed;\n    vec2 scaled = uv.xz * scale;\n    \n    float n = fbm(vec3(scaled - time, time));\n\n    for (int i = 0; i<repeats; i++) {\n      float ang = n * PI;\n      n = fbm(vec3(scaled + vec2(cos(ang), sin(ang)) * n * .5, time));\n    }\n    \n    n = 1.-abs(n);\n    n = mix(n, smoothstep(1., 0., n), .15);\n        \n    return vec2(uv.y - n * height, n);\n}\n\n\nvec2 GetDist(vec3 p) {\n    vec2 d = sdFloor(p);\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO=vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 20.5, 0);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    ro.y = max(.01, ro.y);\n    \n    vec3 la = vec3(0, 3.5, 0);\n        \n    vec3 rd = GetRayDir(uv, ro, la, 1.);\n    vec3 col = vec3(0);\n   \n    vec2 d = RayMarch(ro, rd);\n\n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n    \n        col = vec3(.06, .48, .73);\n        col *= .5 + pow(d.y, 15.) * 25.;\n        float dif = dot(n, normalize(vec3(1,2,4)))*.5+.5;\n        col *= vec3(dif);\n        \n        float off = pow(1. - (d.x / MAX_DIST), .25);\n        col *= off;\n    }\n    \n    col = pow(col, vec3(.8545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 316, 316, 576], [578, 578, 597, 597, 659], [661, 661, 684, 684, 1061], [1064, 1064, 1086, 1086, 1132], [1134, 1134, 1167, 1167, 1413], [1415, 1415, 1439, 1439, 1637], [1639, 1639, 1689, 1689, 1880], [1882, 1882, 1939, 1939, 2771]], "test": "untested"}
{"id": "ctXXzX", "name": "Simple Black Noise ", "author": "Ridah", "description": "SIMPLE NOISE FOR STUDY", "tags": ["2dsnoiseperlinnoise"], "likes": 4, "viewed": 254, "published": 3, "date": "1675090438", "time_retrieved": "2024-07-30T18:13:01.325055", "image_code": "// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat lerp(float a,float b, float t)\n    {\nreturn (1.-t)*a+t*b;\n}\nfloat hash(float x, float y) {\n\treturn fract(abs(sin(sin(123.321 + x) * (y + 321.123)) * 456.654));\n}\nfloat perlin(float x, float y){\n\tfloat col = 0.0;\n\tfor (int i = 0; i < 8; i++) \n\t{\n\t\tfloat fx = floor(x);\n\t\tfloat fy = floor(y);\n\t\tfloat cx = ceil(x);\n\t\tfloat cy = ceil(y);\n\t\tfloat a = hash(fx, fy);\n\t\tfloat b = hash(fx, cy);\n\t\tfloat c = hash(cx, fy);\n\t\tfloat d = hash(cx, cy);\n\t\tcol += lerp(lerp(a, b, fract(y)), lerp(c, d, fract(y)), fract(x));\n\t\tcol /= 2.0;\n\t\tx /= 2.0;\n\t\ty /= 2.0;\n\t}\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    float scale = 2.;\n    vec3 color;\n    float noise;\n\n    pos *= scale;\n\n        float d = snoise(pos.xy) * scale; \n        float u = (pos.x + d);\n        float v = (pos.y + d);\n        d = snoise(vec2(u, v)) * scale;\n        noise = snoise(pos.xy*sin(pos.y) + vec2(d*sin(iTime)+iTime*1.));\n        color = vec3(.6* (vec3(2.) * noise - vec3(noise * .1, noise * .2 - sin(u / 30.) * .1, noise * .3 + sin(v / 40.) * .2)));\n    \n    fragColor = vec4( color, 1.0 );\n    //marble texture\n    /*vec2 pos = fragCoord.xy / iResolution.xy;\n    float scale = 800.;\n    vec3 color;\n    float noise;\n\n    pos *= scale;\n\n        float d = perlin(pos.x,pos.y) * scale; \n        float u = pos.x + d;\n        float v = pos.y + d;\n        d = perlin(u, v) * scale;\n        noise = perlin(pos.x+d,pos.y+d );\n        color = vec3(0.6 * (vec3(2,2,2) * noise - vec3(noise * 0.1, noise * 0.2 - sin(u / 30.0) * 0.1, noise * 0.3 + sin(v / 40.0) * 0.2)));\n    \n\n    fragColor = vec4( color, 1.0 );*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 177, 177, 224], [225, 225, 246, 246, 293], [294, 294, 316, 316, 351], [353, 353, 375, 375, 1423], [1424, 1424, 1466, 1466, 1489], [1490, 1490, 1520, 1520, 1591], [1592, 1592, 1623, 1623, 1993], [1994, 1994, 2050, 2050, 3074]], "test": "untested"}
{"id": "mllXz2", "name": "first try------1", "author": "Kiw1", "description": "triyng to figure out how it works", "tags": ["1"], "likes": 6, "viewed": 242, "published": 3, "date": "1675084416", "time_retrieved": "2024-07-30T18:13:02.436084", "image_code": "void mainImage(out vec4 O, vec2 F){\n\tfloat p, s, y, c, h=3.,\n\t\t\t\t\t  e=iTime*.4+.8;\n\t\t\t\t\t  \n\tvec2 r = iResolution.xy,\n\t\t v = (F*2.-r)/r.y;\n\t\t \n\tfor(s = 0.; s < 2e2 && abs(h) > .001 && p < 40.; s++){\n\t\tvec3 o\t= p*normalize(vec3(1., v));\n\t\tc\t\t= sin(e + p*.5)*.25;\n\t\ty \t\t= c + .25;\n\t\to.x\t+= e;\n\t\to.y\t= abs(o.y);\n\t\to\t\t= fract(o) - .5;\n\t\to.xy\t*= mat2(cos(e + vec4(0,33,11,0)));\n\t\to.y\t+= y/2.;\n\t\to.y\t-= clamp(o.y, 0., y);\n\t\tp += h\t= (length(o) - .1*(.75 + p*.1 + c))*.8;\n\t}\n\tO.rgb = exp(-p*.15 - .5*length(v)) * (cos(p*(8.4 + 0.16*vec3(0,1,2)))*1.2+1.2);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 549]], "test": "untested"}
{"id": "dlsSz2", "name": "Low Quality Amogus", "author": "GetItemFromBlock", "description": "A sussy shader", "tags": ["red", "amongus", "sus", "amogus", "impostor", "sussy", "crewmate"], "likes": 6, "viewed": 193, "published": 3, "date": "1675082545", "time_retrieved": "2024-07-30T18:13:03.442393", "image_code": "float smin(float a, float b, float delta) {\n    float h = clamp(0.5 + 0.5 * (a - b) / delta, 0.0, 1.0);\n    return mix(a, b, h) - delta * h * (1.0 - h);\n}\n\nfloat circle(vec2 pos, vec2 center, float diameter)\n{\n    return length(pos-center) > diameter ? 0. : 1.;\n}\n\nfloat circle2(vec2 pos, vec2 centerA, vec2 centerB, float diameter, float delta)\n{\n    float a = length(pos-centerA) - diameter;\n    float b = length(pos-centerB) - diameter;\n    return smin(a,b,delta) < 0. ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n    col = mix(col, vec3(0.9,0.15,0.15), circle2(uv, vec2(0.58,0.35), vec2(0.58,0.15), 0.03, 0.37));\n    col = mix(col, vec3(0.9,0.15,0.15), circle2(uv, vec2(0.35,0.65), vec2(0.35,0.45), 0.04, 0.35));\n    col = mix(col, vec3(1.0,0.2,0.2), circle2(uv, vec2(0.5,0.7), vec2(0.5,0.4), 0.15, 0.3));\n    col = mix(col, vec3(1.0,0.2,0.2), circle2(uv, vec2(0.42,0.35), vec2(0.42,0.15), 0.03, 0.37));\n    col = mix(col, vec3(0.1,0.1,1.0), circle(uv, vec2(0.6,0.65), 0.1));\n    col = mix(col, vec3(0.5,0.5,1.0), circle(uv, vec2(0.55,0.7), 0.015));\n    col = mix(col, vec3(1.0,1.0,1.0), circle(uv, vec2(0.55,0.7), 0.01));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 154], [156, 156, 209, 209, 263], [265, 265, 347, 347, 486], [488, 488, 545, 595, 1328]], "test": "untested"}
{"id": "mlsXR2", "name": "La fabrique a cookie #04", "author": "z0rg", "description": "Bleep", "tags": ["raymarch", "cookie", "collective", "fabrique"], "likes": 6, "viewed": 336, "published": 3, "date": "1675080573", "time_retrieved": "2024-07-30T18:13:04.446708", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n// Converted from bonzomatic to shadertoy with\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, ouv).xyz;\n     out_color = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n// Converted from bonzomatic to shadertoy with\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\n\nfloat _seed = 0.0;\nvec3 accCol = vec3(0.0);\n\nfloat hash(float seed)\n{\n    return fract(sin(seed * 123.456) * 123.456);\n}\n\nfloat rand()\n{\n    float _74 = _seed;\n    _seed = _74 + 1.0;\n    float param = _74;\n    return hash(param);\n}\n\nvec3 getCam(vec3 rd, inout vec2 uv)\n{\n    uv *= (1.0 - clamp(length(uv) * 0.5, 0.0, 1.0));\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize((rd + (r * uv.x)) + (u * uv.y));\n}\n\nfloat truchet(inout vec2 uv)\n{\n    vec2 id = floor(uv);\n    uv = fract(uv) - vec2(0.5);\n    if (fract(sin(dot(vec2(232.1, 314.7), id * 0.2)) * 167.5) < 0.5)\n    {\n        uv.x *= (-1.0);\n    }\n    float s = (uv.x > (-uv.y)) ? 1.0 : (-1.0);\n    uv -= vec2(s * 0.5);\n    return abs(length(uv) - 0.5);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n    {\n        return a;\n    }\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p) - s;\n    float c = max(l.x, max(l.y, l.z));\n    l = abs(l) - (s * th);\n    float x = max(max(l.x, c), l.y);\n    float y = max(max(l.z, c), l.y);\n    float z = max(max(l.x, c), l.z);\n    return min(min(x, y), z);\n}\n\nvec2 SDF(inout vec3 p)\n{\n    vec2 acc = vec2(1000.0, -1.0);\n    vec3 op = p;\n    p.z += iTime;\n    vec3 pg = (p * 1.0) - vec3(0.0, -iTime, 0.0);\n    float gyr = (dot(sin(pg), cos(pg.yzx)) + 1.2) + pow(clamp(texture(iChannel0, vec2(0.5)).x * 500.0, 0.0, 1.0), 0.5);\n    gyr = max(gyr, abs(p.x) - 3.0);\n    float shape = max(gyr, length(op) - 10.0);\n    vec2 param = acc;\n    vec2 param_1 = vec2(shape, 0.0);\n    acc = _min(param, param_1);\n    float ground = (-p.y) + ((((sin(p.x + iTime) * 0.2) + (sin(p.z + iTime) * 0.2)) + (sin(length(p.xz) + iTime) * 0.5)) * 0.2);\n    vec2 param_2 = acc;\n    vec2 param_3 = vec2(ground, 1.0);\n    acc = _min(param_2, param_3);\n    vec3 param_4 = op;\n    vec3 param_5 = vec3(5.0);\n    vec3 param_6 = vec3(0.1);\n    float cucube = _cucube(param_4, param_5, param_6);\n    vec2 param_7 = acc;\n    vec2 param_8 = vec2(cucube, 2.0);\n    acc = _min(param_7, param_8);\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.0);\n    vec3 p = ro;\n    int i = 0;\n    for (;;)\n    {\n        bool _362 = i < steps;\n        bool _370 = false;\n        if (_362)\n        {\n            _370 = distance(p, ro) < 20.0;\n        }\n        else\n        {\n            _370 = _362;\n        }\n        if (_370)\n        {\n            vec3 param = p;\n            vec2 _374 = SDF(param);\n            vec2 res = _374;\n            if (res.x < 0.01)\n            {\n                return vec3(res.x, distance(p, ro), res.y);\n            }\n            p += (rd * res.x);\n            accCol += ((vec3(1.0, 0.3, 0.5) * (1.0 - clamp(res.x / 1.5, 0.0, 1.0))) * 0.01);\n            i++;\n            continue;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return vec3(-1.0);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.0);\n    vec3 param = p - e.xyy;\n    vec2 _423 = SDF(param);\n    vec3 param_1 = p - e.yxy;\n    vec2 _430 = SDF(param_1);\n    vec3 param_2 = p - e.yyx;\n    vec2 _437 = SDF(param_2);\n    return normalize(vec3(d) - vec3(_423.x, _430.x, _437.x));\n}\n\nvec3 getmat(vec3 p)\n{\n    vec3 col = vec3(0.8, 0.4, 0.6);\n    vec3 _470 = col;\n    vec2 _472 = _470.xy * mat2(vec2(cos(p.z * 5.0), sin(p.z * 5.0)), vec2(-sin(p.z * 5.0), cos(p.z * 5.0)));\n    col.x = _472.x;\n    col.y = _472.y;\n    col = abs(col);\n    return col;\n}\n\nvec3 rdr(inout vec2 uv)\n{\n    uv *= mat2(vec2(cos(iTime * 0.1), sin(iTime * 0.1)), vec2(-sin(iTime * 0.1), cos(iTime * 0.1)));\n    float t = iTime * 0.2;\n    float d = 15.0;\n    vec3 ro = vec3(0.01 + (sin(t) * d), -2.0, cos(t) * d);\n    float _515 = rand();\n    float _516 = rand();\n    vec3 _521 = ro;\n    vec2 _523 = _521.xy + ((vec2(_515, _516) - vec2(0.5)) * 0.2);\n    ro.x = _523.x;\n    ro.y = _523.y;\n    vec3 ta = vec3(0.0, -2.0, 0.0);\n    vec3 rd = normalize(ta - ro);\n    vec3 param = rd;\n    vec2 param_1 = uv;\n    vec3 _539 = getCam(param, param_1);\n    rd = _539;\n    vec2 param_2 = uv;\n    float _543 = truchet(param_2);\n    vec3 col = vec3(_543) * 0.0;\n    float depth = 100.0;\n    vec3 param_3 = ro;\n    vec3 param_4 = rd;\n    int param_5 = 64;\n    vec3 _555 = trace(param_3, param_4, param_5);\n    vec3 res = _555;\n    if (res.y > 0.0)\n    {\n        vec3 p = ro + (rd * res.y);\n        vec3 param_6 = p;\n        float param_7 = res.x;\n        vec3 norm = getNorm(param_6, param_7);\n        depth = res.y;\n        if (res.z == 0.0)\n        {\n            vec3 param_8 = p;\n            col = getmat(param_8);\n        }\n        if (res.z == 1.0)\n        {\n            vec3 refl = normalize(reflect(rd, norm));\n            vec3 param_9 = p + (norm * 0.01);\n            vec3 param_10 = refl;\n            int param_11 = 64;\n            vec3 _604 = trace(param_9, param_10, param_11);\n            vec3 resrefl = _604;\n            if (resrefl.y > 0.0)\n            {\n                vec3 prefl = (p + (norm * 0.01)) + (refl * resrefl.y);\n                vec3 param_12 = prefl;\n                col += getmat(param_12).zxy;\n            }\n        }\n    }\n    col = mix(col, vec3(0.18, 0.02, 0.02), vec3(1.0 - clamp(exp(0.2 * depth), 0.0, 1.0)));\n    col += accCol;\n    return col;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ((fragCoord.xy * 2.0) - iResolution.xy) / vec2(iResolution.xy.y);\n    _seed = texture(iChannel2, uv).x + iTime;\n    float stp = 0.05;\n    if (abs(uv.x) > 0.5)\n    {\n        uv = floor(uv / vec2(stp)) * stp;\n    }\n    vec2 param = uv;\n    vec3 _690 = rdr(param);\n    vec3 col = _690;\n    float _692 = rand();\n    float _693 = rand();\n    vec2 off = (vec2(_692, _693) - vec2(0.5)) * 0.05;\n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col = mix(col, texture(iChannel1, ouv + off).xyz * 1.5, vec3(0.5));\n    out_color = vec4(col, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsXR2.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[497, 497, 554, 554, 679]], "test": "untested"}
{"id": "mllXRj", "name": "Fork Fork Fract manivel 419", "author": "manivel", "description": "A mashup of [url=https://www.shadertoy.com/view/WsBfWt]Crystal Tetrahedron[/url] and [url=https://www.shadertoy.com/view/WlKyzW]Buckyball Fracture[/url]", "tags": ["refraction", "explode", "dispersion", "bluenoise", "polyhedra"], "likes": 18, "viewed": 451, "published": 3, "date": "1675075441", "time_retrieved": "2024-07-30T18:13:05.684399", "image_code": "/*\n\n    Fractured Orb\n    -------------\n\n    A mashup of 'Crystal Tetrahedron' https://www.shadertoy.com/view/WsBfWt\n    and 'Buckyball Fracture' https://www.shadertoy.com/view/WlKyzW\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 10.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture(iChannel0, uv).rgb, 1); return;\n\n    vec3 col = depthOfField(uv, .65, 1.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//#define WOBBLE\n\n//#define DARK_MODE\n\n\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 10.;\n#else\n    const float MAX_DISPERSE = 3.;\n    const float MAX_BOUNCE = 4.;\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nmat3 rotY(float a) {\n\treturn mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 rotZ(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat boolSign(float v) {\n    return max(0., sign(v)) * 2. - 1.;\n}\n\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\n#if 0\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3                           v = vec3(PHI,1,0);\n    if (ap.x+ap.z*PHI > dot(ap,v)) v = vec3(1,0,PHI);\n    if (ap.z+ap.y*PHI > dot(ap,v)) v = vec3(0,PHI,1);\n    return v*0.52573111*boolSign(p);\n}\n#endif\n\n// Closest dodecahedron vertex\n#if 0\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI);\n    vec3 v2 = vec3(0, 1, PHI + 1.);\n    vec3 v3 = v2.yzx;\n    vec3 v4 = v2.zxy;\n    if (dot(ap,v2) > dot(ap,v)) v = v2;\n    if (dot(ap,v3) > dot(ap,v)) v = v3;\n    if (dot(ap,v4) > dot(ap,v)) v = v4;\n    return v*0.35682209*boolSign(p);\n}\n#endif\n\n\nfloat OUTER = .35;\nfloat INNER = .24;\n\nfloat object(vec3 p) {\n    float d = length(p) - OUTER;\n    d = max(d, -d - (OUTER - INNER));\n    return d;\n}\n\nfloat animT;\nfloat time;\n\nvec2 map(vec3 p) {\n\n    float scale = 2.5;\n    p /= scale;\n\n    float outerBound = length(p) - OUTER;\n\n    #ifdef WOBBLE\n        float bound = outerBound - .05;\n        bound *= scale;\n        if (bound > .002) {\n            return vec2(bound, 0.);\n        }\n    #endif\n\n    #ifdef WOBBLE\n        float spin = time * (PI*2.) * (1./5.);\n        mat3 trs = rotX(atan(1./PHI)) * rotY(-spin);\n        p = trs * p;\n    #else\n        float spin = time * (PI/2.) - .15;\n        pR(p.xz, spin);\n    #endif\n\n\n\n    // Buckyball faces\n    // ---------------\n\n    // Four closest vertices of a spherical pentakis dodecahedron\n    // or, four closest faces of a buckyball\n    \n    vec3 va = icosahedronVertex(p);\n    vec3 vb = dodecahedronVertex(p);\n\n    // Second closest dodecahedron vertex\n    float side = boolSign(dot(p, cross(va, vb)));\n    float r = PI * 2. / 5. * side;\n    vec3 vc = erot(vb, va, r);\n\n    // Third closest dodecahedron vertex\n    vec3 vd = erot(vb, va, -r);\n    \n    \n    \n    float d = 1e12;\n    vec3 pp = p;\n    \n    // Render the nearest four fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 4; i++) {\n\n        // Offset space\n        #ifdef WOBBLE\n            vec3 dir = normalize(vec3(1,1,0));\n            dir = dir * transpose(trs);\n            float sp = 2.;\n            float t = mod((time - dot(va, dir) / (.5 * sp)), 1.);\n            float anim = sin(t * PI * 1. * sp) * .5 + .5;\n            anim = mix(.0, .05, anim);\n            p -= va * anim;\n        #else\n            float t = mod(time * 2./3. + .25 - dot(va.xy, vec2(1,-1)) / 30., 1.);\n            float t2 = clamp(t * 5. - 1.7, 0., 1.);\n            float explode = 1. - pow(1. - t2, 10.); // expand\n            explode *= 1. - pow(t2, 5.); // contract\n            explode += (smoothstep(.32, .34, t) - smoothstep(.34, .5, t)) * .05;\n            explode *= 1.4;\n            t2 = max(t - .53, 0.) * 1.2;\n            float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .2;\n            float anim = wobble + explode;\n            p -= va * anim / 2.8;\n        #endif       \n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(vb - va));\n        float edgeB = dot(p, normalize(vc - va));\n        float edgeC = dot(p, normalize(vd - va));\n        float edge = max(max(edgeA, edgeB), edgeC);\n        #ifndef WOBBLE\n            edge -= .005;\n        #endif\n        \n        // Intersect with object\n        d = min(d, smax(object(p), edge, .002));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 va2 = va;\n        va = vb;\n        vb = vc;\n        vc = vd;\n        vd = va2;\n    }\n    \n    #ifndef WOBBLE\n        // Slow down ray as we approach non-exploded object\n        float bound = outerBound - .002;\n        if (bound * scale > .002) {\n            d = min(d, bound);\n        }\n    #endif\n    \n    return vec2(d * scale, 1.);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.9,.83,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n\n    for (float i = 0.; i < 300.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        res = candidate;\n        if (dist < .001) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float duration = 10./3.;\n    #ifdef WOBBLE\n        duration = 2.;\n    #endif\n    time = mod(iTime / duration, 1.);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = BGCOL * .22;\n\n    invert = 1.;\n    maxDist = 15.; \n    \n\tcamOrigin = vec3(0,0,9.5);\n   \tcamDir = normalize(vec3(uv * .168, -1.));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .8);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.5,.5,.5) * .0;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.25);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n        \n    fragColor = vec4(col, range(4., 12., firstLen));\n}\n", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 583, 583, 701], [703, 703, 773, 773, 1972], [1975, 2037, 2067, 2067, 2234], [2236, 2236, 2291, 2291, 2608]], "test": "untested"}
{"id": "DlfSRS", "name": "unzooming circles", "author": "cruelio", "description": "equation of a circle", "tags": ["beginner"], "likes": 0, "viewed": 109, "published": 3, "date": "1675072327", "time_retrieved": "2024-07-30T18:13:06.487252", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n     float cy  = 0.5-(sin(iTime)/3.0);\n     float cx = 0.5 -(sin(sin(iTime))/8.0);\n   ;\n    float r3 = 13.0;\n    float r2 = 50.0*iTime*iTime;\n    float x = uv.x-cx;\n    float y = uv.y-cy;\n    float ci = x*x+y*y;\n\n    if( (ci <= (r3*r3)*1.0005) && ci >=(r3*r2)*-1.0005)\n    {\n    float xa =(uv.x-cx)*(uv.x-cx);\n    float yb = (uv.y-cy)*(uv.y-cy);\n    float r = sqrt(xa+yb);\n        fragColor = vec4(0.0,sin(iTime*r),cos(r*iTime),1.0);\n        }\n        \n     else\n         fragColor = vec4(0.0,0.0,0.0,1.0);\n         \n        \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 685]], "test": "untested"}
{"id": "DtsXR2", "name": "_UNDERSCORE_", "author": "oneshade", "description": "_ _______ _______ ________ ________ ____ ____________\n___ _____ __ __ ___ ________\n__________ ___ __ ___ _______________ ____ __ ___ _ _________ _________", "tags": ["underscore"], "likes": 47, "viewed": 419, "published": 3, "date": "1675067946", "time_retrieved": "2024-07-30T18:13:07.264175", "image_code": "_ __ ___ ____ _____ ______ _______ ________ _________ _______ ____ __________ \n___________ _______ ____________ _____________ ______________ _______________ \n_________ ________________ ___ _________ _________________ ________ ___ ___________ \n_______ __________________ ______________ ______________ ___________________ \n____________________ _____________________ ______________________ \n_______________________ ________ ________________________ ________________ _________ \n_________________________ __________________________ _______ \n___________________________ ________________ ____________________________ ___ \n________________________ ______________ _______ _____________________________ \n________________ ______________________________ ___ ________________________ \n______________ _______________________ _______________________________ ___ \n________________________________ ___ _________________________________ ___ \n__________________________________ ___ _________ _________________ \n______________________ ______________ _______ ________ ___ ______________________ \n______________ ______________ ______________ ______________ _______________ ______ \n___________________________________ ____________________________________ ___ \n_____________________________________ _______ ________________________ \n_____________________ ______________________________________ ___ ________ ___ \n_____________ _______ _______________________________________ _________________ \n_____________ _________________________ ____________ ___ __________________________ \n______________ ______________ _________________________ __________________________ \n______________ _______ ___________________________ _______ \n_____________________________ ______________ \n________________________________________ _________________________________________ \n_______________________ __________________________________________ ___________ \n___________________________________ ___________________________________________ \n_______________________ __________________________________________ _ \n____________________________________________ ___ \n_____________________________________________ \n______________________________________________ \n_______________________________________________ _______ ________ \n________________________________________________ ______________ _______________ \n________ _________ ________________ ___ \n________________________________________________ _________________ \n______________________ ___________________ \n_________________________________________________ \n________________________________________ \n__________________________________________________ ______________ \n_________________________ _________________________________________________ \n________________________________________ \n___________________________________________________ _______________________ \n_______________________________________________ ________________ \n______________________________________________ ___ __________________ ______________ \n_______________________ __________ ___________ ________________ \n____________________________________________________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ______________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ _______________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ _________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ __________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ___________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ____________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ _____________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ______________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ___________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ __________________________________________________________ \n______________ _______________________ __ ___ \n_______________________________________________ \n________________________________________ \n_____________________________________________________ _______ _________ _______ \n___________ _______ ______________________________________________________ \n______________ _______________________ __________________________________________", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define _ void\n#define __ drawChar\n#define ___ (\n#define ____ inout\n#define _____ vec3\n#define ______ color\n#define _______ ,\n#define ________ vec2\n#define _________ uv\n#define __________ float\n#define ___________ pos\n#define ____________ int\n#define _____________ char\n#define ______________ )\n#define _______________ {\n#define ________________ =\n#define _________________ -\n#define __________________ 0\n#define ___________________ *\n#define ____________________ 4.\n#define _____________________ +\n#define ______________________ .5\n#define _______________________ ;\n#define ________________________ charUv\n#define _________________________ /\n#define __________________________ 16.\n#define ___________________________ dfdx\n#define ____________________________ dFdx\n#define _____________________________ dfdy\n#define ______________________________ dFdy\n#define _______________________________ if\n#define ________________________________ all\n#define _________________________________ lessThan\n#define __________________________________ abs\n#define ___________________________________ +=\n#define ____________________________________ textureGrad\n#define _____________________________________ iChannel0\n#define ______________________________________ fract\n#define _______________________________________ 15\n#define ________________________________________ .\n#define _________________________________________ r\n#define __________________________________________ }\n#define ___________________________________________ .125\n#define ____________________________________________ mainImage\n#define _____________________________________________ out\n#define ______________________________________________ vec4\n#define _______________________________________________ fragColor\n#define ________________________________________________ fragCoord\n#define _________________________________________________ iResolution\n#define __________________________________________________ xy\n#define ___________________________________________________ y\n#define ____________________________________________________ -.6875\n#define _____________________________________________________ rgb\n#define ______________________________________________________ 95\n#define _______________________________________________________ 85\n#define ________________________________________________________ 78\n#define _________________________________________________________ 68\n#define __________________________________________________________ 69\n#define ___________________________________________________________ 82\n#define ____________________________________________________________ 83\n#define _____________________________________________________________ 67\n#define ______________________________________________________________ 79", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtfXD4", "name": "Smoking Duck", "author": "xjorma", "description": "A shader after a very long pause.", "tags": ["simulation", "water", "fluid", "volumetric", "fog", "smoke", "advection", "duck", "incompressible", "incompressible", "navier", "stokes", "jos", "stam"], "likes": 71, "viewed": 1833, "published": 3, "date": "1675032677", "time_retrieved": "2024-07-30T18:13:08.457983", "image_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int bloomKernel = 5;\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n// No miracle can be done in only one pass.\nvec3 Bloom( in vec2 uv, int radius, float lod)\n{\n    float scale = pow(2.0, lod);\n    vec3  bloom = vec3(0);\n\tfor (int x = -radius; x <= radius; x++)\n\t{\n\t\tfor (int y = -radius; y <= radius; y++)\n\t\t{\n            vec2 off = vec2(x, y);\n            vec2  v = vec2(off) / float(radius);\n            float w = exp(-4.0  * (dot(v, v)));\n            //float c = dot(texture(iChannel1, (uv + off * scale) / iResolution.xy, lod).rgb, vec3(1.0 / 3.0));\n            float c = dot(texelFetch(iChannel1, ivec2(uv / scale + off), int(lod)).rgb, vec3(1.0 / 3.0));\n            bloom += pow(c, 5.0) * w;\n\t\t}\n\t}\n    return bloom / (0.25 * float(radius * radius) * pi);   // Gaussian integral\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    \n    float w = 0.5;\n    vec3 b = vec3(0);\n    for(int lod = 0; lod < 4; lod++)\n    {\n        b += Bloom(fragCoord, bloomKernel, float(lod)) * w;\n        w *= 0.54;\n    }\n    c += b;\n    fragColor = vec4(aces_tonemap(c), 1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec2 fbm(vec3 p, int octaveNum)\n{\n\tvec2 acc = vec2(0);\t\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n    vec3 shift = vec3(100);\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tacc += vec2(noise(p), noise(p + vec3(0,0,10))) * amp;\n        p = p * 2.0 + shift;\n        amp *= 0.5;\n\t}\n\treturn acc;\n}\n\n\nvec3 sampleMinusGradient(vec2 coord)\n{\n    vec3\tveld\t= texture(iChannel1, coord / iResolution.xy).xyz;\n    float\tleft\t= texture(iChannel0,(coord + vec2(-1, 0)) / iResolution.xy).w;\n    float\tright\t= texture(iChannel0,(coord + vec2( 1, 0)) / iResolution.xy).w;\n    float\tbottom\t= texture(iChannel0,(coord + vec2( 0,-1)) / iResolution.xy).w;\n    float\ttop \t= texture(iChannel0,(coord + vec2( 0, 1)) / iResolution.xy).w;\n    vec2\tgrad \t= vec2(right - left,top - bottom) * 0.5;\n    return\tvec3(veld.xy - grad, veld.z);\n}\n\nfloat vignette(vec2 q, float v)\n{\n    return pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vig = vignette(fragCoord / iResolution.xy, 0.6);\n\t// Euler advection\n    vec2\tvelocity = sampleMinusGradient(fragCoord).xy;\n    vec3\tveld = sampleMinusGradient(fragCoord - dissipation * velocity).xyz;\n    float\tdensity = veld.z;\n    velocity = veld.xy;\n\n    vec2\tuv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Small perturbation\n    vec2 detailNoise = fbm(vec3(uv*25., iTime + 30.), 7) - 0.5;\n    \n    // Injection\n    vec2 injectionNoise = fbm(vec3(uv *1.5, iTime * 0.1 + 30.), 7) - 0.5;\n    //velocity += injectionNoise * 0.1;\n    density += (length(injectionNoise) * 0.004) * mix(1., vig, 1.0);\n    velocity += injectionNoise * 0.01;\n\n    // Inject emiter\n    float influenceRadius = ballRadius * 2.;\n    vec2 p = duckPosition(iFrame, iResolution.x / iResolution.y);\n    float dist = distance(uv, p);\n    if(dist < influenceRadius)\n    {\n        vec2 op = duckPosition(iFrame + 1, iResolution.x / iResolution.y);\n        vec2 ballVelocity = p - op;\n        float infuence = (influenceRadius - dist) / influenceRadius;\n        density += infuence * length(ballVelocity) * 4.0;\n        density = max(0., density);\n        velocity += infuence * (ballVelocity * 40. + detailNoise * 4.);   \n    }\n        \n    density = min(1., density);\n    density *= 0.995;     // damp\n    veld = vec3(velocity, density);\n    veld *=  mix(1., vig, 0.02);\n    fragColor = vec4(veld, texture(iChannel0,fragCoord / iResolution.xy).w);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Divergence\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n    float vel_x_left\t= texelFetch(iChannel0, icoord + ivec2(-1,  0) , 0).x;\n    float vel_x_right\t= texelFetch(iChannel0, icoord + ivec2( 1,  0) , 0).x;\n    float vel_y_bottom\t= texelFetch(iChannel0, icoord + ivec2( 0, -1) , 0).y;\n    float vel_y_top\t\t= texelFetch(iChannel0, icoord + ivec2( 0,  1) , 0).y;\n    float divergence\t= (vel_x_right - vel_x_left + vel_y_top - vel_y_bottom) * 0.5;\n    fragColor = vec4(divergence,vec3(1)); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 1st interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless pass we need to do many pass at once.\n\n\n// code generated by :\n/*\n#include <iostream>\n\nconst int tabSize = 48;\n\nstd::int64_t divTab[tabSize][tabSize];\nstd::int64_t preTab[tabSize][tabSize];\n\n\nvoid recurse(int x, int y, int level)\n{\n    level--;\n    divTab[x][y] += std::int64_t(1) << std::int64_t(level * 2);\n    if (level)\n    {\n        recurse(x - 1, y, level);\n        recurse(x + 1, y, level);\n        recurse(x, y - 1, level);\n        recurse(x, y + 1, level);\n    }\n    else\n    {\n        preTab[x - 1][y]++;\n        preTab[x + 1][y]++;\n        preTab[x][y - 1]++;\n        preTab[x][y + 1]++;\n    }\n}\n\nvoid clear(std::int64_t (&tab)[tabSize][tabSize])\n{\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            tab[x][y] = 0;\n        }\n    }\n}\n\nvoid output(const char *functionName, std::int64_t(&tab)[tabSize][tabSize], std::int64_t multiplier)\n{\n    std::int64_t total = 0;\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            if (tab[x][y])\n            {\n                total += tab[x][y];\n                std::cout << \"\\tp += \" << tab[x][y] << \".*\" << functionName << \"(\" << x - tabSize / 2 << \", \" << y - tabSize / 2 << \");\\n\";\n            }\n        }\n    }\n    total *= multiplier;\n    std::cout << \"\\treturn\\tp / \" << total << \".;\\n\";\n}\n\nint main()\n{\n    clear(divTab);\n    clear(preTab);\n    recurse(tabSize / 2, tabSize / 2, 10);\n    output(\"div\", divTab, 2);\n    output(\"pre\", preTab, 1);\n}\n*/\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getDiv( void )\n{\n    float p = 0.;\n    p += 1.*div(-9, 0);\n    p += 9.*div(-8, -1);\n    p += 4.*div(-8, 0);\n    p += 9.*div(-8, 1);\n    p += 36.*div(-7, -2);\n    p += 32.*div(-7, -1);\n    p += 97.*div(-7, 0);\n    p += 32.*div(-7, 1);\n    p += 36.*div(-7, 2);\n    p += 84.*div(-6, -3);\n    p += 112.*div(-6, -2);\n    p += 436.*div(-6, -1);\n    p += 320.*div(-6, 0);\n    p += 436.*div(-6, 1);\n    p += 112.*div(-6, 2);\n    p += 84.*div(-6, 3);\n    p += 126.*div(-5, -4);\n    p += 224.*div(-5, -3);\n    p += 1092.*div(-5, -2);\n    p += 1280.*div(-5, -1);\n    p += 2336.*div(-5, 0);\n    p += 1280.*div(-5, 1);\n    p += 1092.*div(-5, 2);\n    p += 224.*div(-5, 3);\n    p += 126.*div(-5, 4);\n    p += 126.*div(-4, -5);\n    p += 280.*div(-4, -4);\n    p += 1694.*div(-4, -3);\n    p += 2752.*div(-4, -2);\n    p += 6656.*div(-4, -1);\n    p += 6464.*div(-4, 0);\n    p += 6656.*div(-4, 1);\n    p += 2752.*div(-4, 2);\n    p += 1694.*div(-4, 3);\n    p += 280.*div(-4, 4);\n    p += 126.*div(-4, 5);\n    p += 84.*div(-3, -6);\n    p += 224.*div(-3, -5);\n    p += 1694.*div(-3, -4);\n    p += 3520.*div(-3, -3);\n    p += 11016.*div(-3, -2);\n    p += 16128.*div(-3, -1);\n    p += 24608.*div(-3, 0);\n    p += 16128.*div(-3, 1);\n    p += 11016.*div(-3, 2);\n    p += 3520.*div(-3, 3);\n    p += 1694.*div(-3, 4);\n    p += 224.*div(-3, 5);\n    p += 84.*div(-3, 6);\n    p += 36.*div(-2, -7);\n    p += 112.*div(-2, -6);\n    p += 1092.*div(-2, -5);\n    p += 2752.*div(-2, -4);\n    p += 11016.*div(-2, -3);\n    p += 21664.*div(-2, -2);\n    p += 47432.*div(-2, -1);\n    p += 59712.*div(-2, 0);\n    p += 47432.*div(-2, 1);\n    p += 21664.*div(-2, 2);\n    p += 11016.*div(-2, 3);\n    p += 2752.*div(-2, 4);\n    p += 1092.*div(-2, 5);\n    p += 112.*div(-2, 6);\n    p += 36.*div(-2, 7);\n    p += 9.*div(-1, -8);\n    p += 32.*div(-1, -7);\n    p += 436.*div(-1, -6);\n    p += 1280.*div(-1, -5);\n    p += 6656.*div(-1, -4);\n    p += 16128.*div(-1, -3);\n    p += 47432.*div(-1, -2);\n    p += 92224.*div(-1, -1);\n    p += 163476.*div(-1, 0);\n    p += 92224.*div(-1, 1);\n    p += 47432.*div(-1, 2);\n    p += 16128.*div(-1, 3);\n    p += 6656.*div(-1, 4);\n    p += 1280.*div(-1, 5);\n    p += 436.*div(-1, 6);\n    p += 32.*div(-1, 7);\n    p += 9.*div(-1, 8);\n    p += 1.*div(0, -9);\n    p += 4.*div(0, -8);\n    p += 97.*div(0, -7);\n    p += 320.*div(0, -6);\n    p += 2336.*div(0, -5);\n    p += 6464.*div(0, -4);\n    p += 24608.*div(0, -3);\n    p += 59712.*div(0, -2);\n    p += 163476.*div(0, -1);\n    p += 409744.*div(0, 0);\n    p += 163476.*div(0, 1);\n    p += 59712.*div(0, 2);\n    p += 24608.*div(0, 3);\n    p += 6464.*div(0, 4);\n    p += 2336.*div(0, 5);\n    p += 320.*div(0, 6);\n    p += 97.*div(0, 7);\n    p += 4.*div(0, 8);\n    p += 1.*div(0, 9);\n    p += 9.*div(1, -8);\n    p += 32.*div(1, -7);\n    p += 436.*div(1, -6);\n    p += 1280.*div(1, -5);\n    p += 6656.*div(1, -4);\n    p += 16128.*div(1, -3);\n    p += 47432.*div(1, -2);\n    p += 92224.*div(1, -1);\n    p += 163476.*div(1, 0);\n    p += 92224.*div(1, 1);\n    p += 47432.*div(1, 2);\n    p += 16128.*div(1, 3);\n    p += 6656.*div(1, 4);\n    p += 1280.*div(1, 5);\n    p += 436.*div(1, 6);\n    p += 32.*div(1, 7);\n    p += 9.*div(1, 8);\n    p += 36.*div(2, -7);\n    p += 112.*div(2, -6);\n    p += 1092.*div(2, -5);\n    p += 2752.*div(2, -4);\n    p += 11016.*div(2, -3);\n    p += 21664.*div(2, -2);\n    p += 47432.*div(2, -1);\n    p += 59712.*div(2, 0);\n    p += 47432.*div(2, 1);\n    p += 21664.*div(2, 2);\n    p += 11016.*div(2, 3);\n    p += 2752.*div(2, 4);\n    p += 1092.*div(2, 5);\n    p += 112.*div(2, 6);\n    p += 36.*div(2, 7);\n    p += 84.*div(3, -6);\n    p += 224.*div(3, -5);\n    p += 1694.*div(3, -4);\n    p += 3520.*div(3, -3);\n    p += 11016.*div(3, -2);\n    p += 16128.*div(3, -1);\n    p += 24608.*div(3, 0);\n    p += 16128.*div(3, 1);\n    p += 11016.*div(3, 2);\n    p += 3520.*div(3, 3);\n    p += 1694.*div(3, 4);\n    p += 224.*div(3, 5);\n    p += 84.*div(3, 6);\n    p += 126.*div(4, -5);\n    p += 280.*div(4, -4);\n    p += 1694.*div(4, -3);\n    p += 2752.*div(4, -2);\n    p += 6656.*div(4, -1);\n    p += 6464.*div(4, 0);\n    p += 6656.*div(4, 1);\n    p += 2752.*div(4, 2);\n    p += 1694.*div(4, 3);\n    p += 280.*div(4, 4);\n    p += 126.*div(4, 5);\n    p += 126.*div(5, -4);\n    p += 224.*div(5, -3);\n    p += 1092.*div(5, -2);\n    p += 1280.*div(5, -1);\n    p += 2336.*div(5, 0);\n    p += 1280.*div(5, 1);\n    p += 1092.*div(5, 2);\n    p += 224.*div(5, 3);\n    p += 126.*div(5, 4);\n    p += 84.*div(6, -3);\n    p += 112.*div(6, -2);\n    p += 436.*div(6, -1);\n    p += 320.*div(6, 0);\n    p += 436.*div(6, 1);\n    p += 112.*div(6, 2);\n    p += 84.*div(6, 3);\n    p += 36.*div(7, -2);\n    p += 32.*div(7, -1);\n    p += 97.*div(7, 0);\n    p += 32.*div(7, 1);\n    p += 36.*div(7, 2);\n    p += 9.*div(8, -1);\n    p += 4.*div(8, 0);\n    p += 9.*div(8, 1);\n    p += 1.*div(9, 0);\n    return  p / 1048576.;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).w;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    float div = getDiv();\n    float p = getPre() - div;\n    fragColor = vec4(p, div, vec3(1));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst float dissipation \t= 0.95;\n\nconst float ballRadius\t\t= 0.09;\nconst float fogHeigth\t\t= ballRadius * 3.;\nconst int\tnbSlice\t\t\t= 24;\nconst float fogSlice\t\t= fogHeigth / float(nbSlice);\nconst int\tnbSphere \t\t= 1;\nconst float shadowDensity \t= 15.;\nconst float fogDensity \t\t= 5.;\nconst float lightHeight     = 2.0;\nconst float waterHeight     = 0.2;\nconst float waterScale      = 0.025;\nconst float duckScale       = 0.25;\nconst vec3  lightPos        = vec3(0.5, lightHeight, 0.5);\n\nconst float tau =  radians(360.0);\nconst float pi =  radians(180.0);\n\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nbool floorIntersect(in vec3 ro, in vec3 rd, in float floorHeight, out float t) \n{\n    ro.y -= floorHeight;\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n// https://iquilezles.org/articles/intersectors\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 center,out vec3 oN ) \n{\n    ro -= center;\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\nvec2 duckPosition(int frame, float aspectRatio)\n{\n    float fframe = float(frame);\n    float s = 0.02;\n    return vec2(cos(fframe * s * 0.5) * aspectRatio, sin(fframe * s)) * 0.7;\n}\n\n\nfloat dist2(vec3 v)\n{\n    return dot(v, v);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Duck model from Jimmi: https://www.shadertoy.com/view/4lsSDl\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    //p.x = abs(p.x);\n    \n    a += exp(-k * sdSphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sdSphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sdSphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sdSphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p)\n{\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nfloat duckMap(in vec3 p)\n{\n    p /= duckScale;\n    return min(duckBody(p), duckBeak(p)) * duckScale;\n}\n\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 duckMapColor(vec3 p)\n{\n    p /= duckScale;\n    p.x = abs(p.x);\n    vec4 res = vec4(duckBody(p), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(p), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sdSphere(p-vec3(0.09, 0.62, 0.14), 0.06), vec3(0.0, 0, 0.3)));\n    res.x *= duckScale;\n    return res;\n}\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\nNORMALFUNC(calcNormalDuck,duckMap, 0.0001)\n\n// Fog by IQ https://iquilezles.org/articles/fog\n\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}", "buffer_d_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 2nd interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless passed we need to do many pass at once.\n\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).y;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nfloat sceneIntersection(in vec3 ro,in vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, in float far)\n{\n    float d = far;\n    inter = vec3(0);\n    normal = vec3(0);\n    color = vec3(0);\n\n\n   \t// Duck\n    vec2 p = duckPosition(iFrame, iResolution.x / iResolution.y);\n    vec2 op = duckPosition(iFrame + 1, iResolution.x / iResolution.y);\n    vec2 dir = normalize(p - op);\n    vec3 y = vec3(0, 1, 0);\n    vec3 z = vec3(-dir.x, 0, -dir.y);\n    vec3 x = cross(z, y);\n\n    mat4 mr = mat4(\n    x.x,\t\ty.x,\t\tz.x,         0,\n    x.y,\t\ty.y,\t\tz.y,         0,\n    x.z,\t\ty.z,\t\tz.z,         0,\n    0,\t        0,\t        0,           1.0 );\n\n    mat4 mt = mat4(\n    1.0,\t\t0.0,\t\t0.0,         0.0,\n    0.0,\t\t1.0,\t\t0.0,         0.0,\n    0.0,\t\t0.0,\t\t1.0,         0.0,\n    -p.x,\t0,\t-p.y,     1.0 );\n\n    mat4 tr= mr * mt;\n\n    float t = 0.0;\n    vec3 tp;\n    for( int j = 0; j < 32; j++ )\n    {\n        vec3\tp = ro + t*rd;\n        tp = vec3(tr * vec4(p, 1.0));\n        float\th = duckMap(tp);\n        if( abs(h) < 0.001)\n        {\n            break;\n        }\n        t += h;\n    }\n    if(t < d)\n    {\n        d = t;\n        normal = (inverse(tr) * vec4(calcNormalDuck(tp), 0)).xyz;\n        color = duckMapColor(tp).yzw;\n    }\n    \n    // Plane\n    \n\treturn d;\n}\n\nfloat sampleFog(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    if(max(uv.x, uv.y) > 1. || min(uv.x, uv.y) < 0.)\n    {\n        return 0.;\n    }\n    return texture(iChannel0, uv).z;\n}\n\nfloat height(in float y)\n{\n    y = clamp(y / fogHeigth, 0.0, 1.0);\n    return (1.0 - sin(acos(abs(y) * 2.0 - 1.0))) * fogHeigth;\n}\n\nfloat getWaterHeight(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    uv = clamp(uv, 0.0, 1.0);\n    return texture(iChannel0, uv).w * waterScale;\n}\n\nvec3 getWaterNormal(in vec3 p)\n{\n    vec2 d = 1.0 / iResolution.xy;\n    float hMid = getWaterHeight(p);\n    float hRight = getWaterHeight(p + vec3(d.x, 0, 0));\n    float hTop = getWaterHeight(p + vec3(0, 0, d.y));\n    return normalize(cross(vec3(0, hTop - hMid, d.y), vec3(d.x, hRight - hMid, 0)));\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 blue = smoothstep(.2, 1., rd.y) * vec3(0, 0, .5);\n    vec3 highlight = vec3(pow(clamp(dot(rd, normalize(vec3(1, 1, 0))), 0., 1.), 100.) * 2.0)\n                   + vec3(pow(clamp(dot(rd, normalize(vec3(-0.5, 1, 0.5))), 0., 1.), 100.) * 2.0);\n    return blue + highlight;\n}\n\n// Caustic inspired by Dave Hoskins https://www.shadertoy.com/view/MdKXDm\n\nfloat F(inout vec3 key, in float R)\n{\n    key *=mat3(-2,-1,2, 3,-2,1, 1,2,2) * R;\n    return length(.5-fract(key));\n}\n\nfloat caustic(vec3 p)\n{\n    vec3 key = vec3(p * 2.0) + iTime * 0.2;\n    return pow(min(min(F(key,.5),F(key,.4)),F(key,.3)), 7.)*25.0;\n}\n\nvec3 Render(in vec3 ro,in vec3 rd,in float far, float fudge)\n{\n    vec3  inter;\n    vec3  normal;\n    vec3  baseColor; \n    float mint = sceneIntersection(ro, rd, inter, normal, baseColor, far);\n    \n    vec3 color = mint != far ? baseColor * (0.2 + 0.8 * max(0.0, dot(normal, normalize(ro * mint - lightPos)))) +  getSkyColor(reflect(rd, normal)) : vec3(0.25);\n        \n    vec3 n;\n    float aspecRatio = iResolution.x / iResolution.y;  \n\n    vec2 ret = boxIntersection(ro, rd, vec3(aspecRatio, waterHeight * 2.0, 1), vec3(0, 0, 0), n);\n    if(ret.x > 0.0 && ret.x < mint)\n    {\n        vec3 pi = ro + rd * ret.x;\n        float wt = ret.x;\n        float h = getWaterHeight(pi);\n        vec3 waterNormal;\n        if(pi.y < h)\n        {\n            waterNormal = n;\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * wt;\n                float h = p.y - getWaterHeight(p);\n                if (h < 0.0002 || wt > min(mint, ret.y))\n                    break;\n                wt += h * 0.5;\n            }\n            waterNormal = getWaterNormal(ro + rd * wt);\n        }\n        \n        if(wt < ret.y && wt < mint)\n        {\n            // refract\n            vec3 enter = ro + rd * wt;\n            vec3 refr = -refract(rd, waterNormal, 0.8);\n            vec3 refn;\n            vec2 ret2 = boxIntersection(enter, refr, vec3(aspecRatio, waterHeight * 2.0, 1), vec3(0, 0, 0), refn);\n            vec3 exit = enter + refr * ret2.x;\n            float dist = distance(enter, exit);\n            color = vec3(1) * (0.2 + 0.8 * max(0.0, dot(-refn, normalize(ro * dist - lightPos))));\n            color += caustic(exit + getWaterNormal(exit)) * 0.7;\n            color = applyFog( color, vec3(0, 0, 1), dist * 3.0);\n            color += getSkyColor(reflect(rd, waterNormal));\n        }  \n    }\n    \n    // Compute Fog\n\tfloat t;\n    if(floorIntersect(ro, rd, fogHeigth, t))\n    {\n        vec3 curPos = ro + rd * t;\n        vec3 fogStep = (fogHeigth / float(nbSlice)) * rd / abs(rd.y);\n        curPos += fudge * fogStep;  // fix banding issue\n        float stepLen = length(fogStep);\n        float curDensity = 0.;\n        float transmittance = 1.;\n        float lightEnergy = 0.;\n        for(int i = 0; i < nbSlice; i++)\n        {\n            if( dot(curPos - ro, rd) > mint)\n                break;\n            float curHeigth = sampleFog(curPos) * fogHeigth;\n            float curSample = min(max(0., curHeigth - height(curPos.y)), fogSlice) * stepLen / fogSlice;\n            if(curSample > 0.001)\n            {\n                vec3 lightDir = normalize(lightPos - curPos);\n                vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;\n                float lightDist2 = dist2(lightPos - curPos);\n                vec3 shadowPos = curPos + shadowStep * fudge;\n                float shadowDist = 0.;\n\n                for (int j = 0; j < nbSlice; j++)\n                {\n                    shadowPos += shadowStep;\n                    float curHeight = sampleFog(shadowPos) * fogHeigth;\n             \t\tshadowDist += min(max(0., curHeight - height(shadowPos.y)), fogSlice) * length(shadowStep) / fogSlice;\n               }\n\n                \n            \tfloat shadowFactor = exp(-shadowDist * shadowDensity);\n                curDensity = curSample * fogDensity;\n                float absorbedlight =  shadowFactor * (1. * curDensity);\n                lightEnergy += absorbedlight * transmittance;\n                transmittance *= 1. - curDensity;\t\n            }\n            curPos+= fogStep;       \n        }\n        color = mix(color, vec3(lightEnergy * 1.8), 1. - transmittance);\n    }  \n    \n    \n    return color;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera       \n    float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(90.);\n    float phi\t= - radians(45.);\n    vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n    vec3 ta = vec3( 0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta );\n\n    vec3 rd =  ca*normalize(vec3(p,1.5));        \n\n    vec3 col = Render(ro ,rd, 6., hash12(fragCoord + iTime));\n\n\n    tot += col;\n            \n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    \n    float pr = getPre() - div(0,0);\n\tfragColor = vec4( tot, pr );\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfXD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[142, 142, 172, 172, 619], [621, 665, 713, 713, 1340], [1343, 1343, 1400, 1400, 1693]], "test": "untested"}
{"id": "ctXXR2", "name": "Fractal - Passes", "author": "Meleshin", "description": "Animation for my music track: https://www.youtube.com/watch?v=iQ-OqHmJKmI", "tags": ["raymarching", "fractal", "visualizer", "visualiser", "sequence", "vj"], "likes": 15, "viewed": 423, "published": 3, "date": "1675022961", "time_retrieved": "2024-07-30T18:13:09.466287", "image_code": "// Code of animation for my music track:\n// https://www.youtube.com/watch?v=iQ-OqHmJKmI\n//\n// Roman Meleshin - Passes\n//---------------------------------------------\n// http://romanmeleshin.art/\n// \n// The code is distributed under the MIT license.\n// Inspired by https://www.shadertoy.com/view/wtGfRy\n\n//#define PULSE\n#define AA 1 // Antialias. 1 or more, 1 for fast.\n#define MARCH_MAX_STEPS 100\n#define BAR 3. // Beats per bar.\n#define SEQ_BPM 210. // Beats per minute.\n\nvec3 ro0;\nvec3 ro;\n#if defined(PULSE)\n\tfloat barPulse;\n#endif\n\nstruct varsStruct{\n\tfloat iTime;\n\tfloat eA;\n\tfloat eB;\n\tfloat pA;\n\tfloat pD;\n\tfloat it;\n\tfloat s0;\n\tfloat pB;\n\tfloat pC;\n\tvec3 colBase;\n\tfloat colFactA;\n\tfloat colFactB;\n\tfloat fadeIn;\n\tfloat fadeOut;\n\tfloat fade;\n\tfloat clipTime;\n};\nvarsStruct varsSeq[] = varsStruct[](\n\tvarsStruct(\n\t\t/*iTime*/ 0., \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 23.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 23.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 47.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 47.75, \n\t\t/*eA*/ -3.8, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 71.75, \n\t\t/*eA*/ -3.8, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 71.75, \n\t\t/*eA*/ -2., \n\t\t/*eB*/ 25., \n\t\t/*pA*/ -1.9, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 12., \n\t\t/*s0*/ 2.5, \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 95.75, \n\t\t/*eA*/ -2., \n\t\t/*eB*/ 25., \n\t\t/*pA*/ -1.9, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 12., \n\t\t/*s0*/ 2.5, \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 95.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 119.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 119.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 143.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 143.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 167.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.8, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 167.75, \n\t\t/*eA*/ 1.9, \n\t\t/*eB*/ 11., \n\t\t/*pA*/ -1.7, \n\t\t/*pD*/ 0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 191.75, \n\t\t/*eA*/ 1.9, \n\t\t/*eB*/ 11., \n\t\t/*pA*/ -1.7, \n\t\t/*pD*/ 0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 191.75, \n\t\t/*eA*/ 1.9, \n\t\t/*eB*/ 8., \n\t\t/*pA*/ 1.7, \n\t\t/*pD*/ 0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 215.75, \n\t\t/*eA*/ 1.9, \n\t\t/*eB*/ 8., \n\t\t/*pA*/ 1.7, \n\t\t/*pD*/ 0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 215.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ 1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 233.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ 1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 233.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.62, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 251.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.62, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 3., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 251.75, \n\t\t/*eA*/ -2.3, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 275.75, \n\t\t/*eA*/ -2.3, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 275.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 299.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0., \n\t\t/*pC*/ 0., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 299.75, \n\t\t/*eA*/ -3.8, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 323.75, \n\t\t/*eA*/ -3.8, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -1., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 10., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 1., \n\t\t/*pC*/ 1., \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 323.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 347.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 347.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 365.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 2., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 365.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 389.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 6., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 389.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 413.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -1.5, \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 413.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 437.75, \n\t\t/*eA*/ -2.5, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 437.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 461.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 20., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 461.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 485.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.7, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 6., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 485.75, \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.6, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 24., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*iTime*/ 528., \n\t\t/*eA*/ -2.4, \n\t\t/*eB*/ 30., \n\t\t/*pA*/ -2., \n\t\t/*pD*/ -0.6, \n\t\t/*it*/ 8., \n\t\t/*s0*/ 1., \n\t\t/*pB*/ 0.25, \n\t\t/*pC*/ 0.25, \n\t\t/*colBase*/ vec3(0.2,0.9,0.3), \n\t\t/*colFactA*/ 3., \n\t\t/*colFactB*/ 0.00005, \n\t\t/*fadeIn*/ 3., \n\t\t/*fadeOut*/ 24., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t)\n);\nvarsStruct vars;\nvoid varsInit(){\n\tconst float beatTime = 60. / SEQ_BPM;\n\tfloat loopLength = varsSeq[varsSeq.length()-1].iTime * beatTime;\n\tfloat loopT = mod(iTime, loopLength);\n\tfloat clipT;\n\tfloat clipL;\n\tvarsStruct a;\n\tvarsStruct b;\n\tfloat t;\n\tfor(int i = 0; i < varsSeq.length()-1; i++){\n\t\tfloat sTimeNext = varsSeq[i+1].iTime * beatTime;\n\t\tif(sTimeNext > loopT){\n\t\t\tfloat sTime = varsSeq[i].iTime * beatTime;\n\t\t\ta = varsSeq[i];\n\t\t\tb = varsSeq[i+1];\n\t\t\tclipT = loopT - sTime;\n\t\t\tclipL = sTimeNext - sTime;\n\t\t\tt = clipT/clipL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvars.iTime = loopT;\n\tvars.clipTime = t;\n\tvars.eA = mix(a.eA, b.eA, t);\n\tvars.eB = mix(a.eB, b.eB, t);\n\tvars.pA = mix(a.pA, b.pA, t);\n\tvars.pD = mix(a.pD, b.pD, t);\n\tvars.it = mix(a.it, b.it, t);\n\tvars.s0 = mix(a.s0, b.s0, t);\n\tvars.pB = mix(a.pB, b.pB, t);\n\tvars.pC = mix(a.pC, b.pC, t);\n\tvars.colBase = mix(a.colBase, b.colBase, t);\n\tvars.colFactA = mix(a.colFactA, b.colFactA, t);\n\tvars.colFactB = mix(a.colFactB, b.colFactB, t);\n\tvars.fade = 1.;\n\tif(a.fadeIn != 0.){\n\t\tvars.fade *= clamp(clipT / (a.fadeIn * beatTime), 0., 1.);\n\t}\n\tif(a.fadeOut != 0.){\n\t\tvars.fade *= clamp((clipL - clipT) / (a.fadeOut * beatTime), 0., 1.);\n\t}\n\tvars.clipTime = mix(a.clipTime, b.clipTime, t);\n}\n\nmat3 rotMat(vec3 v, float c, float s){\n\tfloat k = (1. - c);\n\treturn mat3(\n\t\tk * v.x * v.x + c,\t\t\tk * v.x * v.y - s * v.z,\tk * v.x * v.z + s * v.y,\n\t\tk * v.x * v.y + s * v.z,\tk * v.y * v.y +c,\t\t\tk * v.y * v.z - s * v.x,\n\t\tk * v.x * v.z - s * v.y,\tk * v.y * v.z + s * v.x,\tk * v.z * v.z + c\n\t);\n}\nmat3 rotMat(vec3 v, float angle){\n\treturn rotMat(v, cos(angle), sin(angle));\n}\nmat3 rotMat(vec3 z, vec3 d){\n\tvec3 cr = cross(z, d);\n\treturn rotMat(cr, dot(z, d), length(cr));\n}\nvec3 opRepeat(vec3 p, float repW){\n\tfloat repWD = repW / 2.;\n\treturn mod(p + repWD, repW) - repWD;\n}\n\nvoid tune(){ \n    if(vars.eA > 0.){\n        vars.pB = abs(vars.pB);\n    }else if(vars.eA < 0.){\n        vars.it = ceil(vars.it/2.)*2.;\n    }\n    #if defined(PULSE)\n    \tvars.s0 *= 1.-0.15*barPulse;\n    \tvars.pA *= 1.+0.001*barPulse;\n    #endif\n}\nvec4 deFractal(vec3 p){\n\tfloat s = vars.s0;\n\tp = abs(p);\n    p += vars.pA;\n    for(float i=0.; i<vars.it; i++){\n        p -= vars.pB;\n        p = abs(p);\n\t\tp = vars.pC - p;\n\t\tfloat e = vars.eA/min(dot(p,p),vars.eB);\n\t\ts*=e;\n\t\tp=p*e + vars.pD;\n\t}\n\tfloat dist = abs(p.z)/s;\n\tdist += .001;\n\tvec3 col = vars.colBase * 10. + log(s * vars.colFactA);\n\tcol = vars.colFactB * abs(cos(col))/dot(p,p)/dist;\n\treturn vec4(col, dist);\n}\n\nvec4 map(vec3 p){\n\tp -= ro0;\n\tp = opRepeat(p, 2.);\n\treturn deFractal(p);\n}\nvec3 march(vec3 ro, vec3 rd){\n\tvec4 res = vec4(0.);\n\tfor(int i=0; i<MARCH_MAX_STEPS; i++){\n\t\tvec3 p = ro + res.a * rd;\n\t\tvec4 m = map(p);\n\t\tres += m;\n\t }\n\t return res.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvarsInit();\n\t\n\tconst float beatTime = 60./SEQ_BPM;\n\tconst float barTime = BAR*beatTime;\n\t#if defined(PULSE)\n\t\tfloat iTimeInBars = vars.iTime / barTime;\n\t\tbarPulse = pow(1. - abs(iTimeInBars - round(iTimeInBars))*2., 3.);\n\t#endif\n\t\n\ttune();\n\n\tconst float foc = 1.;\n\tro0 = vec3(0, 0, 0);\n\tro = ro0 + vec3(0,0,iTime/barTime/4.);\n\tvec3 col =vec3(0.);\n#if AA>1\n\tfor(int i = 0; i < AA; ++i){\n\t\tfor(int j = 0; j < AA; ++j){\n\t\t\tvec2 ao = vec2(float(i),float(j))/float(AA) - .5;\n\t\t\tvec2 uv = (fragCoord.xy + ao - .5*iResolution.xy)/iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n#endif\n\t\t\tvec3 rd = normalize(vec3(uv.x, uv.y, foc));\n\t\t\tcol += march(ro, rd);\n\t\t\t\n#if AA>1\n\t\t}\n\t}\n\tcol /= float(AA*AA);\n#endif\n\tfragColor = vec4(col * vars.fade, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXXR2.jpg", "access": "api", "license": "mit", "functions": [[14372, 14372, 14388, 14388, 15584], [15586, 15586, 15624, 15624, 15880], [15881, 15881, 15914, 15914, 15959], [15960, 15960, 15988, 15988, 16057], [16058, 16058, 16092, 16092, 16158], [16160, 16160, 16172, 16172, 16405], [16406, 16406, 16429, 16429, 16828], [16830, 16830, 16847, 16847, 16904], [16905, 16905, 16934, 16934, 17078]], "test": "untested"}
{"id": "ctfXRj", "name": "ink explosion - golf ( 256 ch )", "author": "FabriceNeyret2", "description": "simplifying and golfing \"perception of change\" experiment [url]https://shadertoy.com/view/4tG3Wy[/url]\nend of line 11:  try /1e3 , /2e3  , etc\n\n( in the experiment, adjusting the amount of grey transition was making new feature creation almost invisible)", "tags": ["noise", "explosion", "perlin", "ink", "2tweets", "perception", "short", "artefact"], "likes": 36, "viewed": 417, "published": 3, "date": "1675016662", "time_retrieved": "2024-07-30T18:13:10.378847", "image_code": "// golfing 433 chars experiment https://shadertoy.com/view/4tG3Wy\n// based on https://www.shadertoy.com/view/ltjXWW\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec2  R = iResolution.xy ;\n    float L = 20., A = 1.7, i=0., k,s;\n    \n\tfor ( O*=0.; i++ < L; A += A )                    // loop on harmonics\n\t\ts = exp2( k = mod( i - 1.5*iTime, L ) ),      // fractal noise spectrum\n\t\tO += ( 1. - cos(6.3*k/L) ) / s                // enveloppe                    // try 1e3,2e3\n           * (.15 - abs( texture(iChannel0, s*(U+U-R)/R.y* mat2(cos(A+vec4(0,11,33,0))) /2e3 ).r - .5));\n        \n    O = O / fwidth(O) +.7;\n}                                              ", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 614]], "test": "untested"}
{"id": "dtsXRB", "name": "Fuzzy Fractal Fern Fork", "author": "drliquidglitch", "description": "[url]https://twitter.com/zozuar/status/1618281672008675330[/url]\n", "tags": ["short", "fractale", "golf", "reproduction"], "likes": 5, "viewed": 288, "published": 3, "date": "1675005351", "time_retrieved": "2024-07-30T18:13:11.173722", "image_code": "// Remix of FabriceNeyret2's Fractale Fern\n\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float k = fract(iTime*.5), i=0., y = i, f;\n    vec2  R = iResolution.xy;\n          u.x += sin(iTime*u.y*0.01)*0.1;\n          u.y += cos(iTime*u.x*0.01)*R.x*sin(iTime*0.1)*0.01;\n    vec2  p = ( u+u - R ) / R.y / exp(k+2.);                // normalization & zoom\n          \n    for(o *= i ; i++ < 6. && y < .5; p -= round(p) )        // fractal loop ( try without y<.5 ;-) )\n        o += smoothstep( f = fwidth(p.y), -f , p.y+.26 )    // antialias outer spiral arm\n           * smoothstep( 0., min(.1,f+f) , .5 - abs(p.y) ), // antialias inner spiral arm\n        p = vec2( y = atan(p.x,p.y)/1.05 + k + (2.0*sin(iTime)),          // spiral transform\n                  y = log(length(p)*2.7) - k/6.28 + y/6. );\n     o.r += u.x/R.x*.02;\n     o.g += u.y/R.y;\n     o.b += sin(iTime*0.1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 83, 83, 870]], "test": "untested"}
{"id": "mtsXRS", "name": "Directed Photon Mapping V2 prog", "author": "TimoKinnunen", "description": "Directed Photon Mapping V2 by gcgac, with progressive rendering and mouse controls.\nFork of the original:\n\nAn improved version of my efficient photon mapping algorithm. The gloss and GI is fake.", "tags": ["raymarching", "ray", "gi", "fake", "marching", "mapping", "glossy", "photon"], "likes": 6, "viewed": 305, "published": 3, "date": "1674997388", "time_retrieved": "2024-07-30T18:13:11.975578", "image_code": "// Directed Photon Mapping V2 by gcgac, with progressive rendering and mouse controls\n// Original code in Buffer A.\n// \n// Original by https://www.shadertoy.com/user/gcgac @ https://www.shadertoy.com/view/clsXzB\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Thanks to Inigo Quilez for the PRNG and trigophers for helping me make this progressive (in progress)\n\n\nint seed = 2;\nvec3 rgb;\nint frand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat rand(void) { return float(frand())/32767.0; }\nvec3 point;\nvec3 lightpos = vec3(0.0,90,70.0);\nfloat hash1( uint n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nfloat sde;\nvec3 pos;\nfloat maxl = 10000.0;\n\n\nvec3 sphrand(){\n    point = vec3(2.0);\n    while(length(point)>=1.0){\n        point = vec3(rand()*2.0-1.0,rand()*2.0-1.0,rand()*2.0-1.0);\n    }\n    return point;\n}\n\nfloat plane_sde(vec3 ray, vec3 nor, float planey, vec3 col){\n    if (dot(ray,nor)+planey < sde){\n        sde = dot(ray,nor)+planey;\n        rgb = col;\n    }\n    return dot(ray,nor)+planey;\n}\n\n\nfloat sphere_sde(vec3 ray, vec3 position, float radius, vec3 col){\n    if (length(position-ray)-radius < sde){\n        sde = length(position-ray)-radius;\n        rgb = col;\n    }\n    return length(position-ray)-radius;\n}\n\n\nvec4 map(vec4 dstLo, vec4 dstHi, vec2 srcLo, vec2 srcHi, vec2 x){\n    return dstLo + (dstHi-dstLo)*((x-srcLo)/(srcHi-srcLo)).xxyx;\n}\nfloat calc_sdf(vec3 ray){\n    sde = maxl;\n    vec2 mouseInput = dot(iMouse.zw,iMouse.zw) < 10.0 ? vec2(0.25,0.1875) : abs(iMouse.zw)/iResolution.xy;\n    vec4 sphL = map(vec4(-20,11,80-40,20),vec4(-10, 2,80+40,10),vec2(0.25,0.0625),vec2(0.75,0.3125),mouseInput);\n    vec4 sphR = map(vec4( 10, 2,80-40,10),vec4( 20,11,80+40,20),vec2(0.25,0.0625),vec2(0.75,0.3125),mouseInput);\n\n    sphere_sde(ray,sphL.xyz,sphL.w, COLOR_SPHERE_L);\n    plane_sde(ray,vec3( 0,1,0),10.0, vec3(1,1,1));\n    plane_sde(ray,vec3( 1,0,0),21.0, vec3(1,1,1));\n    plane_sde(ray,vec3(-1,0,0),21.0, vec3(1,1,1));\n    sphere_sde(ray,sphR.xyz,sphR.w, COLOR_SPHERE_R);\n    return sde;\n}\n\n\nvec4 raycol(vec3 orig, vec3 dir, float ml){\n    float len = 0.0;\n    sde = ml;\n    float steps = 0.0;\n    pos = orig;\n\n    while (len < ml && sde > 0.1){\n        sde = calc_sdf(pos);\n        pos += dir*sde;\n        len += sde;\n        steps += 1.0;\n    }\n    return vec4(pos,steps);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 newfrag = vec2(fragCoord.x+iResolution.x/2.0,fragCoord.y+iResolution.y/2.0); \n    uvec2 p = uvec2((newfrag-.5*iResolution.xy)/iResolution.y*1000.0);\n    seed = int(round(hash1( p.x + 1920U*p.y + (1920U*1080U))*100.0));\n    seed += iFrame;\n    vec3 pos = vec3(0.0,10.0,10.0);\n    vec3 direction = normalize(vec3(uv.x,uv.y,1));\n    vec4 o;\n    float steps;\n    o = raycol(pos,direction,500.0);\n    if (sde <= 0.1){\n        steps =o.w;\n        vec3 inter = o.xyz;\n        vec3 colour = rgb;\n        for (int i = 0; i<100; i++){\n            vec3 offset = sphrand();\n            offset *= COC;\n            vec3 hit = raycol(lightpos,normalize(inter+offset-lightpos),500.0).xyz;\n            if (length(hit-inter)<COC){\n                colour += rgb*(1.0-length(hit-inter)/COC);\n            }\n        }\n        colour /= 50.0;\n        fragColor = vec4(colour,1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 bufB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = iTime*iFrameRate <= 2.5 ? bufA : mix(bufA,bufB,KEEP_PREV_BUFFER);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define KEEP_PREV_BUFFER 0.9375\n\n//#define COC 8.0\n#define COC 16.0\n\n//#define COLOR_SPHERE_L vec3(1,0,0)\n//#define COLOR_SPHERE_R vec3(0,1,1)\n#define COLOR_SPHERE_L vec3(1,0.5,0)\n#define COLOR_SPHERE_R vec3(0,0.5,1)\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 270, 270, 332]], "test": "untested"}
{"id": "DlsSRB", "name": "Fork Tiled Text zyc 785", "author": "zyc", "description": "A little helper effect practice", "tags": ["texture", "zoom", "scroll", "tiling"], "likes": 3, "viewed": 227, "published": 3, "date": "1674977805", "time_retrieved": "2024-07-30T18:13:12.751504", "image_code": "// vertical scroll: 1\n// horizontal scroll: 0\n#define SCROLL_DIRECTION 1\n//#define FIX_CENTER\n\n\n#define PI 3.14159265358979323846\n\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float padding = 0.015;\n    float aspect = 16./9.;\n    vec4 color = vec4(1.);\n    float cycleTime = mod(iTime, 2.0)/2.0;\n    float time = 3.*cos((cycleTime + 1.0) * PI) / 2.0 + 0.5;\n    \n    vec2 uv = (1.5 * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y *= aspect; // fix aspect ratio\n    \n    #if (SCROLL_DIRECTION == 0)\n       float rows = 1.;\n        // calc row index to offset x of every other row\n        float rowIndex = floor(uv.y * rows);\t\t\n        float oddEven = mod(rowIndex, 2.);\n\n        // create grid coords & set color\n        vec2 uvRepeat = fract(uv * rows);\t\t\n        if(oddEven == 1.) {\n            #ifdef FIX_CENTER\n                uvRepeat = fract(vec2(0.5, 0.) + uv * rows);\n            #else\n                uvRepeat = fract(vec2(time, 0.) + uv * rows); // scroll override\n            #endif\n        } else {\n            uvRepeat = fract(vec2(-time, 0.) + uv * rows); // scroll override\n        }\n\n        // add padding and only draw once per cell\n        uvRepeat *= 1. + padding * 2.;\n        uvRepeat -= padding;\n    #else\n        float columns = 1.;\n        // calc row index to offset x of every other row\n        float columnIndex = floor(uv.x * columns);\t\t\n        float oddEven = mod(columnIndex, 2.);\n\n        // create grid coords & set color\n        vec2 uvRepeat = fract(uv * columns);\t\t\n        if(oddEven == 1.) {\n            #ifdef FIX_CENTER\n                uvRepeat = fract(vec2(0., 0.5) + uv * columns);\n            #else\n                uvRepeat = fract(vec2(0., -time) + uv * columns); // scroll override\n            #endif\n        } else {\n            uvRepeat = fract(vec2(0., time) + uv * columns); // scroll override\n        }\n\n        // add padding and only draw once per cell\n        uvRepeat *= 1. + padding * 2.;\n        uvRepeat -= padding;\n    #endif\n    \n    // antialias - probably a very long & stupid way of doing it, but it's smooth :)\n    float alphaX = 1.0;\n    float alphaY = 1.0;\n    float center = 0.5;\n    float repeatThresh = 0.51;\t// push out a little so we don't cut any texture off. also helps blend nicely when no padding\n    float aa = repeatThresh - center;\n    aa *= 0.5;\n    float centerDistX = distance(center, uvRepeat.x);\n    float centerDistY = distance(center, uvRepeat.y);\n    if(centerDistX > repeatThresh - aa) alphaX = map(centerDistX, repeatThresh - aa, repeatThresh + aa, 1., 0.);\n    if(centerDistY > repeatThresh - aa) alphaY = map(centerDistY, repeatThresh - aa, repeatThresh + aa, 1., 0.);\n    float alpha = min(alphaX, alphaY);\n    color = texture(iChannel0, uvRepeat);\n    color = mix(vec4(1.), color, alpha);\n\n    // draw repeating texture\n    fragColor = color;\n}\n\n/*\n\t// simple texture repeat option\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv = rotateCoord(uv, 0.2 * sin(iTime));\n    uv.y *= 4.5/3.; // fix aspect ratio\n    uv *= 1. + 0.75 * sin(iTime); // zoom\n    vec4 color = texture(iChannel0, uv + vec2(iTime, 3. * sin(iTime)));\n    fragColor = color;\n*/", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 206, 206, 275], [277, 277, 334, 334, 3005]], "test": "untested"}
{"id": "DtXXRS", "name": "Hypocycloid Plotter", "author": "MysteryPancake", "description": "Inspired by the image on the Wikipedia article :)", "tags": ["2d", "circle", "plot", "draw", "plotter", "buffer", "trail", "radius", "astroid", "hypocycloid", "deltoid"], "likes": 6, "viewed": 240, "published": 3, "date": "1674976753", "time_retrieved": "2024-07-30T18:13:13.528426", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Draw buffer\n    vec3 col = texture(iChannel0, uv).rgb;\n    float rbMax = max(col.r, col.b);\n    fragColor = vec4(rbMax, col.g + rbMax, col.r, 1.0);\n    \n    // Draw vignette\n    fragColor.b += smoothstep(0.4, 1.0, length(uv - 0.5));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float TAU = 6.28318530;\n\n// From https://iquilezles.org/articles/distfunctions2d\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 2.0;\n    float points = floor(time / TAU) + 3.0;\n    \n    const float outerRadius = 0.45;\n    float innerRadius = outerRadius / points;\n    \n    float innerSpeed = 1.0 - points;\n    vec2 drawOffset = vec2(sin(time * innerSpeed), cos(time * innerSpeed));\n    vec2 circleOffset = vec2(sin(time), cos(time)) * (outerRadius - innerRadius);\n    vec2 trailOffset = circleOffset + drawOffset * innerRadius;\n    \n    // Draw trail in red channel\n    float trail = min(1.0, 0.01 / length(p - trailOffset));\n    float last = texture(iChannel0, fragCoord / iResolution.xy).r;\n    fragColor.r = max(max(0.0, last - 0.005), trail);\n    \n    // Draw outer circle in green channel\n    fragColor.g = 0.005 / abs(length(p) - outerRadius);\n    \n    // Draw inner circle in blue channel\n    float circleBorder = abs(length(p - circleOffset) - innerRadius);\n    float circleLine = line(p, circleOffset, trailOffset);\n    fragColor.b = 0.003 / min(circleBorder, circleLine);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 344]], "test": "untested"}
{"id": "ctsSRS", "name": "2d maps square generator", "author": "4eckme", "description": "see tags ^", "tags": ["2d", "generator", "gamedev", "maps", "labirint"], "likes": 4, "viewed": 195, "published": 3, "date": "1674962034", "time_retrieved": "2024-07-30T18:13:14.439989", "image_code": "void mainImage(out vec4 c,in vec2 o){\n  c=vec4(1);\n  float y=floor(o.y/12.0);\n  float x=floor(o.x/12.0);\n  float square=x*x+y*y+iTime/7.0;\n  c*=ceil((vec4(ceil(sin(square))+mod(y,2.0))+vec4(floor(cos(square))+mod(x,2.0))));\n  if (length(c)<=0.0)c=vec4(0);;\n  c=1.0-c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 269]], "test": "untested"}
{"id": "ctlSRS", "name": "4D Sphere", "author": "oseday", "description": "high dimensional", "tags": ["raymarch", "fractals"], "likes": 3, "viewed": 263, "published": 3, "date": "1674960456", "time_retrieved": "2024-07-30T18:13:15.828277", "image_code": "//Sphere sdf from https://www.shadertoy.com/view/wtVGDR\n\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\n#define complex\n\nfloat time;\n\nfloat cross4D(vec4 p) {\n    float aa = length(p.xy)-0.0001;\n    float bb = length(p.zw)-0.0001;\n    float cc = length(p.yw)-0.0001;\n    float dd = length(p.xw)-0.0001;\n    //float de = smin(smin(aa, bb, 0.1), cc, 0.1)-0.01;\n    return min(min(min(aa,bb),cc),dd);\n}\n\nfloat de4d(vec4 p) {\n    p.zw *= rot(PI/2.);\n    //p.xz *= rot(time*5.);\n    //p.xw *= rot(time*3.187);\n    //p.x += time*1.687;\n   \t//p.y -= time*1.87454;\n   \tp.w -= time*1.87454;\n   \tp.z -= 1.24;//time*1.87454;\n    //p.z = 0.;\n    vec4 inG = (fract(p*0.45) - 0.5);\n    return cross4D(inG);\n}\n\nfloat de(vec3 p) {\n    float d = dot(p, p);\n    d = de4d(vec4(p/d, 0.))*d;\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.00005, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nstruct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\n#define EPSILON 0.0005\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.00;\n\n\nfloat map(vec3 p)\n{\n    return de(p);\n}\n\n\nconst int kRaymarchIterations = 100;\nconst float mapddivisor = 1.08;\n\nconst vec3 sundir = normalize(vec3(0,1,1));\nconst vec3 suncol = vec3(0.8,0.8,0.8);\nconst vec3 objcol = vec3(0.9,0.9,0.8);\n\nvec3 manager(rayresult io){\n\n    vec3 skycol = texture(iChannel0,io.v).xyz;\n    \n\tfloat t = 0.00;\n    \n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n        vec3 pos = io.o + io.v * t;\n    \n\t\tfloat d = map(pos);\n        \n        \n\t\tif(d < 0.002){\n        if (length(pos) > 0.95)  return skycol;\n            if (length(pos-io.o) > 0.3){\n\n                vec3 n = getNormal(pos);\n\n                float sundot = dot(n,sundir);\n\n                vec3 col = suncol * sundot + objcol;\n\n                vec3 sdir = reflect(io.v,n);\n                col *= texture(iChannel0,sdir).xyz;\n\n                return col;\n            }else{\n                skycol *= 0.2;\n                t+=0.05;\n            }\n\t\t}\n        \n        t += d/mapddivisor;\n\t}\n    \n    return skycol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tick = iTime/5.;\n    time = tick;\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*PI,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*PI,0,0))\n        ;\n        \n    ncam = ncam\n        *build_transform(vec3(0,0,-1.00),vec3(0,0,0))\n        ;\n    \n    vec3 campos = matpos(ncam);\n        \n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n    vec3 color = vec3(0,0,0);\n\n    rayresult ray;\n    \n    ray.o=campos;\n    ray.v=v;\n    ray.dist=0.10;\n\n    color += manager(ray);\n\n    color = clamp(color,0.,1.);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotateabout(vec3 vec, vec3 axis, float angle) {\n    return (rotationMatrix(axis, angle) * vec4(vec, 1.0)).xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 187, 187, 428], [430, 430, 450, 450, 723], [725, 725, 743, 743, 815], [817, 817, 841, 841, 986], [1178, 1178, 1207, 1207, 1266], [1268, 1268, 1287, 1287, 1386], [1388, 1388, 1410, 1410, 1435], [1469, 1469, 1488, 1488, 1508], [1704, 1704, 1731, 1731, 2467], [2469, 2469, 2526, 2526, 3283]], "test": "untested"}
{"id": "DllXW4", "name": "clouds - 183t", "author": "ArmandB", "description": "wasd + space and shift to move\nclick and drag mouse to turn\nx = toggle time, c = decrease time, v = increase time", "tags": ["3d", "clouds"], "likes": 1, "viewed": 172, "published": 3, "date": "1674956547", "time_retrieved": "2024-07-30T18:13:16.828602", "image_code": "const int maxsteps = 128;\nconst int maxlightsteps = 4;\nconst float maxdist = 1000000.0;\nconst float gamma = 2.2;\nconst float epsilon = 0.01;\nconst float lightstep = 4.0;\nconst float lightAmount = 10.0;\nconst float shadowAmount = 1.0;\nconst float cloudcover = 0.7;\nconst float cameraFrustum = 0.5;\n\nconst Cloud cloud0 = Cloud(150.0,-0.6,2.0,50.0,-0.5,1.0,20.0,-0.5,0.5,5.0,-0.5,0.25);\nconst Cloud cloud1 = Cloud(300.0,-0.4,2.0,50.0,-0.3,1.0,20.0,-0.5,0.5,5.0,-0.5,0.25);\\\nconst Cloud cloud2 = Cloud(200.0,-0.4,2.0,50.0,-0.2,1.0,20.0,-0.3,0.5,5.0,-0.2,0.25);\nconst CloudContainer cloudsmain = CloudContainer(vec3(1000000,100,1000000), vec3(0,100,0), cloud0);\nconst CloudContainer bigcloud = CloudContainer(vec3(400,200,400), vec3(0,300,0), cloud1);\nconst CloudContainer stratus = CloudContainer(vec3(1000000,30,1000000), vec3(0,500,0), cloud2);\n\nSceneData sceneSdf(vec3 p){\n    SceneData s = smoothUnify(sdCloud(cloudsmain,p), sdCloud(bigcloud,p),128.0);\n    s = smoothUnify(s, sdCloud(stratus,p),128.0);\n    return s;\n}\n\nfloat noise(vec3 x){\n    return textureLod(iChannel1, x/30.0, 0.0).x;\n}\n\nfloat sampleDensity(vec3 p){\n    SceneData sd = sceneSdf(p);\n    Cloud c = sd.cloudType;\n    float sc = sd.dist;\n    if (sc < 0.0){\n        float s = fpow(1.0 - clamp(-sc/50.0,0.0,1.0),0.2) - 0.2;\n        float v0 = noise(p/c.s0) + c.o0 - s;\n        float v1 = noise(p/c.s1) + c.o1 - s;\n        float v2 = noise(p/c.s2) + c.o2 - s;\n        float v3 = noise(p/c.s3) + c.o3 - s;\n        float n = v0*c.w0 + v1*c.w1 + v2*c.w2 + v3*c.w3 + 3.0*cloudcover - 3.0;\n        return clamp(n, 0.0, 1.0);\n    }\n    return 0.0;\n}\n\nHit marchRay(Ray ray, vec3 lightDir){\n    float density = 0.0;\n    float t = 0.0;\n    float shadow = 0.0;\n    vec3 pos = ray.origin;\n    int itts = 0;\n    for (int i = 0; i < maxsteps; i++){\n        if (t > maxdist) break;\n        float dist = sceneSdf(pos).dist;\n        \n        if (dist > 0.1 && i < 64){\n            pos += abs(dist)*ray.direction;\n            t += abs(dist);\n        } else {\n            float dens = sampleDensity(pos);\n            float densitySmoothing = smoothstep(0.0,1.0,-density + 2.0);\n            density += dens;\n            float stepsize = (dens >= 0.5 ? 1.0 : (8.0*pow(2.0*dens-1.0,2.0) + 0.5)) + t*0.01;\n            pos += stepsize*ray.direction;\n            t += stepsize;\n            if (dens >= 0.0 && density < 2.0){\n                shadow += dens*densitySmoothing;\n                vec3 p2 = pos;\n                for (int j = 0; j < maxlightsteps; j++){\n                    p2 -= lightDir*lightstep;\n                    shadow += sampleDensity(p2)*densitySmoothing;\n                }\n            }\n        itts ++;\n        }\n    }\n    return Hit(density,shadow);\n}\n\nvec4 renderMoon(vec2 uv, float spin, float stage){\n    float l = uv.x*uv.x + uv.y*uv.y;\n    if (l < 1.0){\n        uv /= sqrt(1.0 - l) + 1.0;\n        vec2 p = vec2(uv.x - spin, uv.y);\n        float v = abs(voronoi2d(p*3.0) - 0.3) + abs(voronoi2d(p*7.0)*0.4 - 0.1) +  abs(voronoi2d(p*15.0)*0.1 - 0.05);\n        vec3 lightColor = vec3(1);\n        vec3 darkColor = vec3(0,0.05,0.1);\n        vec3 shadowColor = vec3(0,0.025,0.05);\n        vec4 col = vec4(mix(darkColor,lightColor,1.0 - v),smoothstep(1.0,0.94,l));\n        float k = (2.0*asin(mod(stage,2.0) - 1.0)/3.14159)*sqrt((1.0 - uv.y*uv.y));\n        float s = sign(mod(stage,4.0) - 2.0);\n        if (s*uv.x < s*k){\n            col.rgb = mix(col.rgb,shadowColor,smoothstep(0.0,0.1,s*(k - uv.x))*0.75);\n        }\n        return col;\n    }\n    return vec4(0);\n}\n\nvec3 renderLensFlare(vec3 rd, float density, vec3 light, vec3 position, vec3 rotation, vec2 uv, vec3 sun, float time){\n    vec3 lr = rotate3dbackwards(-light,rotation,vec3(0));\n    if (lr.z > 0.0){\n        vec2 luv = lr.xy*cameraFrustum/lr.z;\n        float ld = distance(luv,uv);\n        vec2 ln = (luv-uv)/ld;\n        float horizonfactor = 100.0*(abs(time - 0.25) - 0.235);\n                \n        //ghosts\n        vec3 ghosts = vec3(0);\n        ghosts += renderhex(uv, -luv*0.25, 1.4, vec3(0.25,0.75,0));\n        ghosts += renderhex(uv, luv*0.25, 0.5, vec3(1,0.5,0.5));\n        ghosts += renderhex(uv, luv*0.1, 1.6, vec3(1,1,1));\n        ghosts += renderhex(uv, luv*1.8, 2.0, vec3(0,0.5,0.75));\n        ghosts += renderhex(uv, luv*1.25, 0.8, vec3(1,1,0.5));\n        ghosts += renderhex(uv, -luv*1.25, 5.0, vec3(0.5,0.5,0.25));\n        ghosts += fpow(1.0 - abs(distance(luv*0.8,uv) - 0.7),0.985)*vec3(0.15,0.1,0);\n        ghosts *= clamp(horizonfactor,0.0,1.0);\n        \n        float flare = fpow(textureLod(iChannel2,ln*0.25,0.0).r,0.3)*0.04/ld*clamp(horizonfactor - 0.5,0.0,1.0)/(1.0 + max(-rd.y,0.0)*10.0);\n        float bloom = 2.0*fpow(max(1.0 - ld,0.0),0.7)*clamp(horizonfactor,0.0,1.0)/(1.0 + max(-rd.y,0.0)*10.0);\n        \n        return (ghosts/(1.0 + distance(uv,luv)) + sun*min(bloom + flare,1.0))*clamp(1.0-density,0.001,1.0);\n    }\n    return vec3(0);\n}\n\nvec3 skyColor(vec3 l, float d, float t, vec3 r, vec3 water){\n    vec3 col = vec3(0);\n    \n    vec3 starRot = rotate3d(r,vec3(-t*2.0*PI,0,0),vec3(0));\n    float starlerp = textureLod(iChannel1,starRot*10.0,0.0).r*textureLod(iChannel1,starRot*0.8,0.0).r;\n    \n    vec3 red = vec3(1.0,0.05,0.06);\n    vec3 orange = vec3(1.0,0.5,0.0);\n    vec3 yellow = vec3(1.0,0.7,0.1);\n    vec3 purple = vec3(0.5,0.2,0.4);\n    vec3 blue = vec3(0.4,0.5,1.0);\n    vec3 black = mix(vec3(0,0,0.005),vec3(1),fpow(starlerp,0.6)*3.0);\n    vec3 black2 = vec3(0.02,0.015,0.05);\n    vec3 white = vec3(0.9);\n\n    float j = smin(abs(r.y),1.0 - d,0.1);\n    float x = max(abs(abs(clamp(t,0.0,1.0)*4.0 - 2.0) - 1.0)*2.0 - 1.0,0.0);\n    vec3 fog = vec3(0);   \n    if (t > 0.5){\n        x *= 3.0;\n        if (x < 1.0){\n            fog = mix(white,yellow,x);\n        } else if (x < 2.0){\n            fog = mix(yellow,orange,x-1.0);\n        } else if (x < 3.0){\n            fog = mix(orange,red,x-2.0);\n        }\n    } else {\n        x *= 2.0;\n        if (x < 1.0){\n           fog = mix(black2,purple,x);\n        } else if (x < 2.0){\n           fog = mix(purple,red,x-1.0);\n        }\n    }\n        \n    float skylerp = clamp(abs(2.0 - abs(1.0 - 4.0*t)) - 0.5,0.0,1.0);\n    col = mix(mix(blue,black,skylerp),fog,fpow(0.7-j,0.3));\n    \n    if (t > 0.1 && t < 0.4) l *= -1.0;\n    if (dot(-l,r) < 0.0){\n        vec3 z = normalize(vec3(0,-l.z,l.y));\n        vec2 uv = vec2(dot(cross(l,z),r),dot(z,r));\n        vec4 moon = renderMoon(uv*8.0,t*5.0,t*5.0);\n        col = mix(col,moon.rgb,moon.a*clamp(1.0-10.0*(abs(t - 0.25) - 0.2),0.0,1.0));\n    }\n    \n    if (r.y < 0.0){\n       return mix(water,col,clamp(1.0+r.y*80.0,0.0,1.0));\n    }\n    \n    return col;\n}\n\n//main render\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup camera\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    float t = fract(texelFetch(iChannel0, ivec2(5,0),0).r);\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    vec3 lightDirection = vec3(0,sin(t*2.0*PI),-cos(t*2.0*PI)); //negative (0.1,0.4)\n    if (t > 0.1 && t < 0.4) lightDirection *= -1.0;\n    \n    vec3 col = vec3(0);\n    \n    //colors\n    vec3 cloudLit = texelFetch(iChannel0, ivec2(10,0),0).rgb;\n    vec3 cloudShadowed = texelFetch(iChannel0, ivec2(11,0),0).rgb;\n    vec3 water = texelFetch(iChannel0, ivec2(8,0),0).rgb;\n    vec3 sun = texelFetch(iChannel0, ivec2(9,0),0).rgb;\n    \n    float d = dot(-lightDirection,ray.direction);\n    \n    //rendering\n    Hit hit = marchRay(ray,lightDirection);\n    float cloudSun = fpow(max(d,0.0),0.9)*5.0;\n    float shadow = hit.shadow/lightAmount - cloudSun/(1.0 + hit.density);\n    float shadowIntensity = clamp(abs(1.0 - 10.0*abs(t - 0.25) + 0.5),0.0,1.0); //allows the light direction to flip without being noticed\n    vec3 cloudColor = mix(cloudLit,cloudShadowed,min(shadow*shadowAmount,1.0)*shadowIntensity + 0.5*(1.0 - shadowIntensity));\n    \n    //col = mix(renderSky(ray,sky,haze,water), cloudColor, clamp(hit.density,0.0,1.0));\n    col = mix(skyColor(lightDirection, d, t, ray.direction, water), cloudColor, clamp(hit.density,0.0,1.0));\n    col += renderLensFlare(ray.direction, hit.density, lightDirection, position, rotation, cam.uv, sun, t);\n    \n    fragColor = vec4(pow(col.rgb, vec3(1.0/gamma)),0.0); //gamma correction\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159265;\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.4;\nconst float moveDamping = 0.8;\nconst float far = 1000.0;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Hit {\n    float density;\n    float shadow;\n};\n\nstruct Cloud {\n    float s0;\n    float o0;\n    float w0;\n    float s1;\n    float o1;\n    float w1;\n    float s2;\n    float o2;\n    float w2;\n    float s3;\n    float o3;\n    float w3;\n};\n\nstruct CloudContainer {\n    vec3 size;\n    vec3 origin;\n    Cloud cloudType;\n};\n\nstruct SceneData {\n    float dist;\n    Cloud cloudType;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n};\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){\n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n\n    point += origin; //add pivot\n    return point;\n}\n\n//returns a point rotated backwards in 3d (radians)\nvec3 rotate3dbackwards(vec3 point, vec3 angle, vec3 origin){\n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    //the transpose of the normal matrix\n    point *= mat3(\n        cy*cz, cy*sz, -sy,\n        sx*sy*cz - cx*sz, sx*sy*sz + cx*cz, sx*cy,\n        cx*sy*cz + sx*sz, cx*sy*sz - sx*cz, cx*cy\n    );\n\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    Ray ray = Ray(rotate3d(uv,camRot,vec3(0)) + cameraPos, rotate3d(normalize(uv), camRot, vec3(0)));\n    return Camera(cameraPos, ray, uv.xy);\n}\n\n//math functions:\n\nvec3 planeIntersect(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    return dot(po - ro, pd)/dot(rd,pd)*rd; \n    //return -(dot(ro,pd)+po)/dot(rd,pd)*rd;\n}\n\n//puts vec a into coord space of vec b\nvec3 toVectorSpace(vec3 a, vec3 b){\n    vec3 x = normalize(vec3(-b.y,b.x, 0));\n    return vec3(dot(x,a),dot(a,b),dot(cross(x,b),a));\n}\n\nSceneData sdCloud(CloudContainer box, vec3 p){\n    vec3 d = abs(p - box.origin) - box.size;\n    return SceneData(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), box.cloudType);\n}\n\nCloud mixCloud(Cloud a, Cloud b, float k){\n    return Cloud(\n        mix(a.s0,b.s0,k),\n        mix(a.o0,b.o0,k),\n        mix(a.w0,b.w0,k),\n        mix(a.s1,b.s1,k),\n        mix(a.o1,b.o1,k),\n        mix(a.w1,b.w1,k),\n        mix(a.s2,b.s2,k),\n        mix(a.o2,b.o2,k),\n        mix(a.w2,b.w2,k),\n        mix(a.s3,b.s3,k),\n        mix(a.o3,b.o3,k),\n        mix(a.w3,b.w3,k)\n    );\n}\n\nSceneData smoothUnify(SceneData a, SceneData b, float k){\n    float h = max(k-abs(a.dist-b.dist),0.0);\n    return SceneData(min(a.dist, b.dist) - h*h*0.25/k, mixCloud(a.cloudType, b.cloudType, clamp((k-b.dist+a.dist)/k,0.0,1.0)));\n}\n\n//fakes x^n for specular effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return ((a+b) - sqrt(h*h+k))*0.5;\n}\n\nfloat smin2( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//misc\n//https://www.shadertoy.com/view/Xd2GR3\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi2d(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = smin2(n,distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv),8.0);\n        }\n    }\n    return n;\n}", "buffer_a_code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _x = 88;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 col = vec4(0);\n    \n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    \n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity;\n        if (position.y < -1000.0){\n            position = vec3(0,24,0);\n        }\n        if (iFrame == 0){\n            position = vec3(0,6,0);\n        }\n        col.xyz = position;\n    }\n    \n    //time\n    if (floor(fragCoord) == vec2(5,0)){\n        vec4 data = texelFetch(iChannel0, ivec2(5,0), 0);\n        float time = data.r;\n        bool doNaturalTime = data.g != 1.0;\n        bool lastXpressed = data.b == 1.0;\n        bool Xpressed = keyPressed(_x) == 1.0;\n        \n        time += (keyPressed(_v)-keyPressed(_c))*0.005;\n        \n        if (!lastXpressed && Xpressed){\n            doNaturalTime = !doNaturalTime;\n        }\n        if (doNaturalTime){\n            time += 0.0005;\n        }\n        \n        col.r = time;\n        col.g = float(!doNaturalTime);\n        col.b = float(Xpressed);\n    }\n    \n    if (floor(fragCoord.y) == 0.0 && floor(fragCoord.x) >= 8.0 && floor(fragCoord.x) <= 11.0){\n        float t = fract(texelFetch(iChannel0, ivec2(5,0), 0).r);\n        if (floor(fragCoord) == vec2(8,0)){ //water\n            vec3 blue = vec3(0.2,0.25,0.8);\n            vec3 black = vec3(0.01,0.01,0.03);\n\n            col.rgb = mix(mix(blue,black,smoothstep(0.0,0.05,t)),blue,smoothstep(0.45,0.55,t));\n        }\n        if (floor(fragCoord) == vec2(9,0)){ //sun\n            vec3 white = vec3(1.0,0.6,0.4);\n            vec3 yellow = vec3(1.0,0.8,0.2);\n        \n            col.rgb = mix(yellow,mix(yellow,white,smoothstep(0.95,0.9,t)),smoothstep(0.55,0.65,t));\n        }\n        if (floor(fragCoord) == vec2(10,0)){ //cloud lit\n            vec3 white = vec3(1.6,1.4,1.2);\n            vec3 black = vec3(0.05,0.05,0.1);\n            vec3 pink = vec3(4.0,1.0,0.3);\n        \n            col.rgb = mix(mix(pink,mix(black,pink,smoothstep(0.45,0.55,t)),smoothstep(0.0,0.05,t)),mix(white,pink,smoothstep(0.95,1.0,t)),smoothstep(0.5,0.6,t));\n        }\n        if (floor(fragCoord) == vec2(11,0)){ //cloud shadowed\n            vec3 white = vec3(0.3,0.4,0.6);\n            vec3 black = vec3(0.01,0.01,0.05);\n            vec3 pink = vec3(0.1,0.1,0.2);\n        \n            col.rgb = mix(mix(pink,mix(black,pink,smoothstep(0.45,0.55,t)),smoothstep(0.0,0.05,t)),mix(white,pink,smoothstep(0.95,1.0,t)),smoothstep(0.5,0.6,t));\n        }\n\n    }\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[844, 844, 871, 871, 1018], [1020, 1020, 1040, 1040, 1091], [1093, 1093, 1121, 1121, 1608], [1610, 1610, 1647, 1647, 2713], [2715, 2715, 2765, 2765, 3524], [3526, 3526, 3644, 3644, 4895], [4897, 4897, 4957, 4957, 6612], [6614, 6628, 6685, 6704, 8358]], "test": "untested"}
{"id": "mlXXDM", "name": "voronoi giraffe 2", "author": "jonasfrey", "description": "giraffe", "tags": ["voronoi"], "likes": 11, "viewed": 198, "published": 3, "date": "1674951589", "time_retrieved": "2024-07-30T18:13:17.803995", "image_code": "// lazy hash steal from dave hoskins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n// lazy voronoi steal from iq \n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, md, mg );\n}\n\n\n#define n_aa (1./iResolution.x)*10.\n#define n_tau 6.283185\nfloat f_n_dist_sqr(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\nfloat f_n_dist_rct(vec2 o, float n){\n    n = abs(n);\n    float nx = o.x-n;\n    float ny = abs(o.y);\n    float nd = max(nx, ny);\n    float nx2 = (-1.*o.x)-n;\n    float nd2 = max(nx2, ny);\n    \n    return max(nd, nd2);\n}\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n\nvec4 f_o_col_horn(vec2 o_fc){\n    vec4 o_col = vec4(0.);\n    vec2 o = o_fc; \n    o *= vec2(3.+sin(o.y-.5*n_tau*.93)*5.+o.y*o.y*o.y*20., .9);\n    o *= vec2(1.5, 1.);\n    float nr = .5;\n    float n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    vec3 o_cl = vec3(0.545,0.498,0.506);\n    vec3 o_cd = vec3(0.055,0.078,0.059);\n    \n    return o_col*vec4(mix(o_cl, o_cd, o.y*2.), 1.);\n}\nvec4 f_o_col_head(vec2 o_fc){\n\n    vec4 o_col = vec4(0.);\n    vec2 o = o_fc; \n\n    //head \n    o = f_o_rotd(o, -0.05);\n    o.y *= 1.78-o.x;\n    float nr = .5;\n    float n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    // \"horn?\" 1\n    o = o_fc;\n    o*= 2.5;\n    o = f_o_rotd(o, 0.05);\n    o+= vec2(-0.02, -1.3);\n    vec4 o_ch1 = f_o_col_horn(o);\n    // horn 2\n    o = o_fc;\n    o*= 2.5;\n    o = f_o_rotd(o, 0.02);\n    o+= vec2(0.2, -1.1);\n    vec4 o_ch2 = f_o_col_horn(o);\n    vec4 o_ch = ((1.- (o_ch1 * o_ch2)))*o_ch1;//+o_ch2;\n    o_col += o_ch1+o_ch2;\n    return o_col;\n}\nvec4 f_o_col_neck(vec2 o_fc){\n\n    vec4 o_col = vec4(0.);\n    vec2 o = o_fc; \n\n    //head \n    o*= vec2(-1.,-1.);\n    o = f_o_rotd(o, -0.05+o.x*0.18);\n    o = f_o_rotd(o, -0.05);\n    o *= vec2(4., 1.);\n    float nr = .5;\n    float n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    return o_col;\n    \n}\nvec4 f_o_col_body(vec2 o_fc){\n\n    vec4 o_col = vec4(0.);\n    vec2 o = o_fc; \n\n    //o = f_o_rotd(o, -0.05);\n    o*=vec2(1.,(1.+o.x*1.5)*.5+1.);\n    float nr = .5;\n    float n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    return o_col;\n    \n}\nvec4 f_o_col_leg(vec2 o_fc, float n_t_offset){\n\n    vec4 o_col = vec4(0.);\n    \n    o_fc *= vec2(-1., 1.);\n    float n_tf = fract(iTime+n_t_offset);\n    float n_tfo = n_tf;\n    float n_tthr, n_tnor;\n    vec2 o = o_fc;\n    //upper leg\n    n_tthr = 0.8;\n    n_tfo = n_tf;\n    n_tnor = (n_tfo/n_tthr);\n    if(n_tfo > n_tthr){\n        n_tnor = 1.-(n_tfo - n_tthr)/ (1.-n_tthr);\n    }\n    o = f_o_rotd(o, n_tnor*0.2-0.1);\n    o*=vec2(2.-sin(o.y*n_tau*.5)*.8,1.);\n\n    float nr = .5;\n    float n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    vec2 o_2 = o;\n    //under leg\n    \n    o = o_fc;\n\n    o = o_fc;\n    n_tthr = 0.8;\n    n_tfo = fract(n_tf-0.02);\n    n_tnor = (n_tfo/n_tthr);\n    if(n_tfo > n_tthr){\n        n_tnor = 1.-(n_tfo - n_tthr)/ (1.-n_tthr);\n    }\n    \n    o = f_o_rotd(o, n_tnor*0.2-0.1);\n    \n    o+=vec2(0.0,0.8);\n\n    \n    o*=vec2(o.x*33.,1.);\n    nr = .5;\n    n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    //hoove\n    o = o_fc;\n    n_tthr = 0.8;\n    n_tfo = n_tf;\n    n_tnor = (n_tfo/n_tthr);\n    if(n_tfo > n_tthr){\n        n_tnor = 1.-(n_tfo - n_tthr)/ (1.-n_tthr);\n    }\n    \n    //o = f_o_rotd(o, n_tnor*0.2);\n    \n    o*=3.;\n\n\n    o = f_o_rotd(o, 0.2*n_tnor-.12);\n    o+=vec2(0.5,4.);\n    o = f_o_rotd(o, 0.);\n    o*=vec2(1.5+o.y*2.,1.);\n    nr = .5;\n    n = length(o);\n    n = smoothstep(nr+n_aa, nr, n);\n    o_col+=vec4(n);\n    \n    return o_col;\n    \n}\nvec4 f_o_col_giraffe(vec2 o_fc){\n    vec2 o = o_fc;\n    vec4 o_col = vec4(0.);\n    o*=8.;\n    o+=vec2(3.,-3.);\n    o_col += f_o_col_head(o);\n    o = o_fc;\n    o*=3.;\n    o+=vec2(0.8,-0.7);\n    o_col += f_o_col_neck(o);\n    o = o_fc;\n    o*=3.;\n    o+=vec2(0.2,-0.2);\n    o_col += f_o_col_body(o);\n    \n    o = o_fc;\n    o*=5.;\n    o+=vec2(0.8,0.4);\n    o_col += f_o_col_leg(o, 0.5);\n    \n    o = o_fc;\n    //o*=vec2(-4.,4.);\n    o*=vec2(5., 4.);\n    o+=vec2(-0.1,0.01);\n    o_col += f_o_col_leg(o, 1.);\n    return o_col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    vec2 o = o_fc;\n    vec4 o_col = clamp(f_o_col_giraffe(o),0., 1.);\n    //vec4 o_col2 = clamp(f_o_col_giraffe(o*1.05+vec2(0.002, -0.002)), 0., 1.);\n    \n    //o_col2 = o_col - o_col2;\n\n    \n    vec4 o_voronoi = voronoi(o_fc*20.);\n    \n    float n_thills = iTime*10.;\n    vec2 o_fc_vonoroi_hills = o_fc*20.+vec2(-n_thills, 0.);\n    vec4 o_voronoi_hills = voronoi(o_fc_vonoroi_hills);\n    vec2 o_voronoi_hills_rnd = hash22(floor(o_fc_vonoroi_hills)+o_voronoi_hills.zw);\n    float n_d_hills = o_fc.y - sin(o_fc.x*n_tau-n_thills/3.3)*0.1+0.2;\n    n_d_hills = smoothstep(0.1+n_aa, 0.1, n_d_hills);\n    n_d_hills -= o_col.x;\n    vec4 o_col_hills = vec4(0.,o_voronoi_hills_rnd.x*2.+.4,0.,1.);\n    vec4 o_cola_hills = o_col_hills*n_d_hills*o_voronoi_hills.x;    \n    \n\n    float n_tbg = iTime*3.;\n    vec2 o_fc_vonoroi_bg = o_fc*20.+vec2(-n_tbg, 0.);\n    vec4 o_voronoi_bg = voronoi(o_fc_vonoroi_bg);\n    vec2 o_voronoi_bg_rnd = hash22(floor(o_fc_vonoroi_bg)+o_voronoi_bg.zw);\n    float n_d_bg = clamp(1.-n_d_hills, 0., 1.); \n    n_d_bg -= o_col.x;\n    vec4 o_col_bg = vec4(o_voronoi_bg_rnd.y*4.,0.,o_voronoi_bg_rnd.x*10.,1.);\n    vec4 o_cola_bg = o_col_bg*n_d_bg*o_voronoi_bg.x;    \n    \n\n\n    float n_tgiraffe = 0.;\n    vec2 o_fc_vonoroi_giraffe = o_fc*20.+vec2(-n_tgiraffe, 0.);\n    vec4 o_voronoi_giraffe = voronoi(o_fc_vonoroi_giraffe);\n    vec2 o_voronoi_giraffe_rnd = hash22(floor(o_fc_vonoroi_giraffe)+o_voronoi_giraffe.zw);\n    float n_d_giraffe = clamp(o_col.x, 0., 1.); \n    vec3 o_colg = vec3(0.761,0.6,0.38);\n    vec4 o_col_giraffe = vec4(o_colg,1.);//*o_voronoi_giraffe_rnd.y;\n    float n_thick = o_voronoi_giraffe_rnd.x*0.1;\n    float n_ss = smoothstep(n_thick, n_thick+n_aa,o_voronoi_giraffe.x);\n    vec4 o_cola_giraffe = o_col_giraffe*n_d_giraffe;    \n    o_cola_giraffe += n_d_giraffe*vec4(1.-n_ss);\n    \n    fragColor = vec4(0.0);\n    //fragColor = vec4(vec4(n_col_bg)*(o_voronoi_bg));\n    \n    fragColor += o_cola_hills;\n    fragColor += o_cola_bg;\n    fragColor = clamp(fragColor, 0., 1.);\n    fragColor += o_cola_giraffe;\n    //fragColor = o_col;\n    //fragColor = vec4(n_d_hills);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 58, 58, 192], [225, 225, 252, 252, 1357], [1419, 1419, 1446, 1446, 1484], [1485, 1485, 1521, 1521, 1703], [1704, 1704, 1745, 1745, 1912], [1914, 1914, 1943, 1943, 2319], [2320, 2320, 2349, 2349, 2925], [2926, 2926, 2955, 2955, 3257], [3258, 3258, 3287, 3287, 3532], [3533, 3533, 3579, 3579, 4974], [4975, 4975, 5007, 5007, 5497], [5498, 5498, 5555, 5555, 7732]], "test": "untested"}
{"id": "dtfSRS", "name": "Mandelsphorb", "author": "Bricktronic", "description": "Just a simple test :)", "tags": ["raymarched", "sphere"], "likes": 0, "viewed": 205, "published": 3, "date": "1674939397", "time_retrieved": "2024-07-30T18:13:18.564961", "image_code": "const float EPS = 0.001;\nconst vec3 lightDir = vec3(0.5, 1, 0.25);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst vec3 ambient = vec3(0.4, 0.4, 0.4);\n\nvec3 cameraPos;\n\nstruct Ray\n{\n    vec3 Pos;\n    vec3 Dir;\n    vec4 Color;\n    float Offset;\n};\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, vec3 p2, float s )\n{\n      return length(p - p2)-s;\n}\n\n// https://www.shadertoy.com/view/4lVXRm\nmat3 camRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelBulb(vec3 pos) {\n    float Power = 6.0 + sin(iTime * 0.5) * 2.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 4 ; i++) {\n\t\tr = length(z);\n\t\tif (r>1.15) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat sceneDist(in vec3 p)\n{\n    return mix(mandelBulb(p), sdSphere(p, vec3(0, 0, 0), 1.0), max(sin(iTime * 0.25), 0.0));\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 sceneNormal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = sceneDist(p + small_step.xyy) - sceneDist(p - small_step.xyy);\n    float gradient_y = sceneDist(p + small_step.yxy) - sceneDist(p - small_step.yxy);\n    float gradient_z = sceneDist(p + small_step.yyx) - sceneDist(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\n// https://learnopengl.com/Lighting/Basic-Lighting\nvec3 lightScene(in vec3 pos)\n{  \n    // Diffuse\n    vec3 norm = normalize(sceneNormal(pos));\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = diff * lightColor;\n    \n    // Specular\n    vec3 viewDir = normalize(cameraPos - pos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = 0.002 * spec * lightColor;  \n\n    return (ambient + diffuse + specular);\n}\n\nvoid march(inout Ray ray)\n{\n    float totalDist = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        float dist = sceneDist(ray.Pos);\n        \n        if(dist < EPS)\n        {\n           ray.Color = vec4(vec3(0.45, 0.75, 0.85) * lightScene(ray.Pos), 1);\n           break;\n        }\n        \n        float travel = min(dist, 0.025);\n        ray.Pos += ray.Dir * (travel * ray.Offset);\n        totalDist += travel;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float div = (iResolution.x / iResolution.y);\n    vec2 sUV = vec2((uv.x * div) - 0.4, uv.y);\n    \n    float rot = iTime * 0.2;\n    cameraPos = vec3(-sin(rot) * 2.0, 0, -cos(rot) * 2.0);\n    mat3 cameraDir = camRotation(-vec2(rot, 0));\n    \n    Ray ray;\n    ray.Pos = cameraPos;\n    ray.Dir = vec3((sUV * 2.0 - 1.0), 1) * cameraDir;\n    ray.Dir = normalize(ray.Dir);\n    ray.Offset = (length(texture(iChannel0, uv * 1.0)) * 0.1) + 1.0;\n    ray.Color = vec4(ambient, 1);\n    \n    march(ray);\n    \n    fragColor = vec4(ray.Color.xyz,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 301, 345, 345, 378], [380, 421, 449, 449, 679], [681, 807, 835, 835, 1399], [1401, 1401, 1429, 1429, 1524], [1526, 1579, 1608, 1608, 2012], [2014, 2065, 2095, 2112, 2519], [2521, 2521, 2548, 2548, 2942], [2944, 2944, 3001, 3001, 3582]], "test": "untested"}
{"id": "DtfXzB", "name": "They Walk", "author": "SnoopethDuckDuck", "description": "Make sure the music is playing :)", "tags": ["audiovisual", "walk", "person", "dude"], "likes": 39, "viewed": 1245, "published": 3, "date": "1674937780", "time_retrieved": "2024-07-30T18:13:19.567280", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define rn 64.0\n\n//https://www.shadertoy.com/view/4tGXzt\nfloat getFreq(float x) {\n\treturn texture(iChannel0, vec2(floor(x * rn + 1.) / rn, 0)).x;\n}\n\nfloat getFreq_smooth(float x) {\n\tfloat index = floor(x * rn) / rn;\n    float next = floor(x * rn + 1.0) / rn;\n\treturn mix(getFreq(index), getFreq(next), smoothstep(0.0, 1.0, fract(x * rn)));\n}\n\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat seg(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 5.5;\n    float a = 0.25 * iTime;\n    vec3 ro = vec3(r * cos(a), 2. + 0.5 * cos(iTime), r * sin(a));\n    ro = mix(ro, vec3(4, 2, 2.*cos(a)), .5+.5*thc(4.,0.125*iTime));\n   // float a = iTime;\n  //  ro.yz *= rot(-m.y*3.14+1.);\n  //  ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\n#define strideHeight 0.2 \n\n#define hipWidth 0.125\n#define hipHeight 0.82\n\n#define shoulderWidth 0.23\n\n#define neckHipLength 0.55\n#define hipKneeLength 0.4\n#define kneeFootLength 0.45\n\n// https://iquilezles.org/articles/simpleik/\nvec2 solve(vec2 p, float r1, float r2) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nvec3 getKnee(vec3 hip, vec3 foot, vec3 toe, float rot) {\n    // Basis for plane, erot determines which plane we use\n    vec3 vy = normalize(hip - foot);\n    vec3 toeDir = foot - toe;\n    //toeDir = erot(toe, vy, rot); // uncomment if using rot\n    vec3 vx = normalize(toeDir - dot(toeDir, vy) / dot(vy, vy) * vy);\n    \n    // 2D positions in plane spanned by vx, vy\n    // (vFoot = vec2(0))\n    vec2 vHip = vec2(0, length(hip - foot));\n    vec2 vKnee = solve(vHip, kneeFootLength, hipKneeLength);\n    return foot + vKnee.x * vx + vKnee.y * vy;\n}\n\nfloat stride(float offset) {\n    float t = mod(iTime + offset, 2.);\n    float mt = min(t, 1.);\n    // 0.02 was boneRadius. hacky\n    return 0.02 + strideHeight * pow(4. * mt * (1.-mt), 2.);\n}\n\nvec2 map(vec3 p) { \n    float t = iTime;\n    float ct = cos(pi*t);\n    float st = sin(pi*t);\n    float c2t = cos(2.*pi*t);\n    float s2t = sin(2.*pi*t);\n\n    // Mix between cut space, regular space, reflected space\n    float mx  = .5 - .5 * ths(8., 0.08 * pi+ 0.25 * iTime);\n    float mx2 = .5 - .5 * ths(4., 0.08 * pi+ 0.5 * iTime);\n    \n    //float o = 2.*pi/3. + t;\n    //vec3 off = normalize(.5+.5*thc(4., 0.25 * p + vec3(-o,0,o)));\n    //p = erot(p, off, pi);\n    \n    // Plane offset (needs to be here!)\n    float y = 0.02 * dot(p.xz, p.xz); \n    \n    p.y = mix(p.y, abs(p.y) + 0.005, mx2);\n\n    // Cut p.xz into grid\n    float sc = mix(2.5, 4., 1.-mx2);\n    p.xz = mix(p.xz, mod(p.xz - 0.5 * sc, sc) - 0.5 * sc, mx);\n        \n    // \"Plane\" distance  \n    float zClamp = clamp(2.*p.z, -pi, pi);\n    float terrain = 1. - thc(4., zClamp);\n    terrain *= 0.5 + 0.5 * cos(p.z + t) * cos(p.x + t);\n    p.y += y;// mix(-0.25, 1., mx2) * y; //thc(3., 0. *x + 0.25 * pi * t) * y; //x=p.x\n    float pd = p.y;\n    pd += mix(0.5 * terrain, 0., mx);\n    \n    // -- positions --\n    vec3 hip = vec3(0, hipHeight - 0.04*s2t, 0);\n    vec3 hipL = hip - vec3(-0.05*ct, -0.025*st, hipWidth);\n    vec3 hipR = hip + vec3(-0.05*ct, -0.025*st, hipWidth);\n    vec3 footL = vec3( 0.3*ct, stride(0.), -0.2);\n    vec3 footR = vec3(-0.3*ct, stride(1.),  0.2);    \n    vec3 toeOffset = vec3(0.14, 0, 0);\n    vec3 toeL = footL - toeOffset;\n    vec3 toeR = footR - toeOffset;\n    vec3 kneeL = getKnee(hipL, footL, toeL, 0.);\n    vec3 kneeR = getKnee(hipR, footR, toeR, 0.);\n    \n    vec3 neck = hip + vec3(0.05*c2t, neckHipLength, 0.05*st);\n    vec3 head = neck + vec3(0.05*ct, 0.31, 0);\n    vec3 shoulderL = neck + vec3(-0.05*ct, -0.05*st, shoulderWidth);\n    vec3 shoulderR = neck - vec3(-0.05*ct, -0.05*st, shoulderWidth);\n    \n    float eaL = -pi/2.-0.4*pi*ct;\n    float eaR = -pi/2.+0.4*pi*ct;\n    vec3 elbowL = shoulderL + vec3(0.3*cos(eaL), 0.3*sin(eaL),  0.14);\n    vec3 elbowR = shoulderR + vec3(0.3*cos(eaR), 0.3*sin(eaR), -0.14);\n    eaL -= 0.4*pi*(.25+.5*st);\n    eaR -= 0.4*pi*(.25+.5*st);\n    vec3 handL = elbowL + vec3(0.3*cos(eaL), 0.3*sin(eaL),  0.09);\n    vec3 handR = elbowR + vec3(0.3*cos(eaR), 0.3*sin(eaR), -0.09);\n    \n    vec3 eyeL = head + vec3(-0.08, 0, -0.05);\n    vec3 eyeR = head + vec3(-0.08, 0, 0.05);\n    \n    // -- distances --  \n    float boneRadius = mix(0.04, 0.2, 1.-mx2);\n    \n    float headDist = length(p - head) - 0.1;\n    float headNeckDist = seg(p, head, neck) - boneRadius;\n    float neckHipDist = seg(p, neck, hip) - boneRadius;\n    float shoulderDist = seg(p, shoulderL, shoulderR) - boneRadius;  \n    vec2 shoulderElbowDist = vec2(seg(p,shoulderL,elbowL), seg(p,shoulderR,elbowR)) - boneRadius;\n    vec2 elbowHandDist = vec2(seg(p,elbowL,handL), seg(p,elbowR,handR)) - boneRadius;\n    vec2 handDist = vec2(length(p-handL), length(p-handR)) - boneRadius;\n    \n    float hipDist = seg(p, hipL, hipR) - 0.02;\n    vec2 hipKneeDist  = vec2(seg(p,hipL,kneeL),  seg(p,hipR,kneeR))  - boneRadius;\n    vec2 kneeFootDist = vec2(seg(p,kneeL,footL), seg(p,kneeR,footR)) - boneRadius;\n    vec2 footToeDist  = vec2(seg(p,footL,toeL),  seg(p,footR,toeR))  - boneRadius;\n\n    vec2 eyeDist = vec2(length(p-eyeL), length(p-eyeR)) - 0.025;\n\n    // -- min distance --\n    // smooth amount\n    float sa = mix(0.2, 0.4, mx2);\n    \n    // body distance\n    float bd = hipDist;\n    bd = smin(bd, smin(hipKneeDist.x, hipKneeDist.y, 0.5*sa),sa);\n    bd = smin(bd, min(kneeFootDist.x, kneeFootDist.y),sa);\n    bd = smin(bd, min(footToeDist.x, footToeDist.y),0.5*sa);\n \n    bd = smin(bd, neckHipDist,sa);\n    bd = smin(bd, headDist, sa);\n    \n    // arms dist\n    float ad = shoulderDist;\n    ad = smin(ad, min(shoulderElbowDist.x, shoulderElbowDist.y), 0.5*sa);\n    ad = smin(ad, min(elbowHandDist.x, elbowHandDist.y), 0.5*sa);\n    ad = smin(ad, min(handDist.x, handDist.y), 0.75*sa);\n    bd = smin(bd, ad, 0.25*sa);\n    \n    float ed = min(eyeDist.x, eyeDist.y);\n    \n    // -- return values --\n    if (ed < bd)\n        return vec2(ed, 0.25);\n    if (bd < pd)\n        return vec2(bd, 0.5);\n    \n    return vec2(pd, 1);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        m.x *= 0.9 + 0.1 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    float zoomMix = tanh(0.15 * iTime);\n    float zm = mix(5.6, 1.6, zoomMix);\n    float aimHeight = mix(1.5, 1.15, zoomMix);\n    vec3 rd = dir(uv, ro, vec3(0,aimHeight,0), zm);\n    vec3 col = vec3(0);\n   \n    // wish this was better but works okay!\n    float fr = getFreq_smooth(0.5);\n    vec3 myCol = hsv2rgb(vec3(2.*fr, 0.25 + 0.5 * fr, 1.));\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = normalize(vec3(1,2,3));\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 16.);\n        float fres = pow(1. + dot(rd, n),  5.);\n     \n        col = vec3(dif);    \n        col = mix(col, vec3(1), fres);\n        //col *= exp(-0.75 * length(p.xz));\n        \n       \n        if (m.z == 1.) { \n            float xmot = 0.25 * pi * (iTime -.25*sin(2.*pi * iTime)/pi);\n            col *= 0.75 + 0.25 * abs(step(mod(2.*(p.x - xmot), 1.), 0.5) \n                                   - step(mod(2.*p.z,1.), 0.5));         \n        }\n        \n        //col += 0.3/cosh(length(p.xz));\n        if (m.z == 0.5) {\n            vec3 tx = texture(iChannel2, n).rgb;\n            n = abs(n);\n            vec3 c1 = texture(iChannel1, .5+.5*p.xy).rgb;\n            vec3 c2 = texture(iChannel1, .5+.5*p.yz).rgb;\n            vec3 c3 = texture(iChannel1, .5+.5*p.zx).rgb;\n            vec3 c = c1 * n.z + c2 * n.x + c3 * n.y;\n            \n            //col *= 4. * tx * c;\n            col *= c;\n            col *= vec3(.82+.18*thc(4.,36.*p.x-4.*iTime));\n        }\n        \n        float sh = shadow(p + 20. * SURF_DIST * n, ld);\n        col = mix(col, 0.9 * col * (.5+.5*myCol), 1.-sh);            \n    }\n    \n    col *= 1./cosh(0.5*length(p.xz));\n    \n    // this causes annoying black dots! idk why!!!! :?uiwerwoenrikwun\n    col = mix(col, myCol, 1.-exp(-0.01*m.y));\n    \n    // this looks cool too\n    /*\n    float k = 2. / iResolution.y;\n    float s = smoothstep(-k, k, -0.1 + abs(uv.y - 0.4*cos(0.5*uv.x+iTime)));\n    vec3 col2 = mix(col, vec3(1), 1.-exp(-0.1 * length(p.xz)));\n    col = mix(col, col2, 1.-s);\n    //*/\n    \n    col = tanh(1.4*col);\n    //col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32109, "src": "https://soundcloud.com/justinhawkes/neverafter?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//        Tater - raymarching\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 125, 149, 149, 215], [217, 217, 248, 248, 409], [411, 411, 436, 436, 592], [594, 594, 629, 629, 746], [748, 748, 760, 760, 1088], [1274, 1319, 1359, 1359, 1511], [1513, 1513, 1569, 1628, 2058], [2060, 2060, 2088, 2088, 2251], [2253, 2253, 2271, 2271, 6371], [6373, 6373, 6412, 6412, 6920], [6922, 6922, 6941, 6941, 7123], [7125, 7125, 7169, 7169, 7360], [7362, 7362, 7394, 7394, 7629], [7631, 7631, 7669, 7669, 8012], [8014, 8014, 8071, 8071, 10445]], "test": "untested"}
{"id": "DtXXRB", "name": "Plasmaroo", "author": "afterlifevj", "description": "Plasma", "tags": ["plasma"], "likes": 5, "viewed": 202, "published": 3, "date": "1674934422", "time_retrieved": "2024-07-30T18:13:20.339216", "image_code": "//experimenting with 3D Gradient noise from: https://www.shadertoy.com/view/Xsl3Dl\n#define layers 5 //int how many layers\n#define speed .25 //float speed multiplyer\n#define scale 1.2 //float scale multiplyer\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n\n\treturn p;\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized device coordinates from -1 to 1\n    vec2 uv = (fragCoord-iResolution.xy-.5)/iResolution.y;\n    //time value\n    float t = iTime*speed;\n\n    uv *= scale;\n    float h = noise(vec3(uv*2.,t));\n    //uv distortion loop \n  for (int n = 1; n < layers; n++){\n      float i = float(n);\n    uv -= vec2(0.7 / i * sin(i * uv.y+i + t*5. + h * i) + 0.8, 0.4 / i * sin(uv.x+4.-i+h + t*5. + 0.3 * i) + 1.6);\n  }\n\n    uv -= vec2(1.2 * sin(uv.x + t + h) + 1.8, 0.4 * sin(uv.y + t + 0.3*h) + 1.6);\n\n\n    // Time varying pixel color\n    vec3 col = vec3(.5 * sin(uv.x) + 0.5, .5 * sin(uv.x + uv.y) + 0.5, .5 * sin(uv.y) + 0.8)*0.8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 229, 229, 406], [407, 407, 433, 433, 1258], [1259, 1259, 1316, 1365, 2002]], "test": "untested"}
{"id": "ctfSRS", "name": "Simple Phong Raymarch Template", "author": "Bricktronic", "description": "A globally lit scene with a phong shaded sphere. Supports ambient lighting and a main directional light.", "tags": ["raymarched", "sphere"], "likes": 2, "viewed": 256, "published": 3, "date": "1674934228", "time_retrieved": "2024-07-30T18:13:21.238811", "image_code": "const float EPS = 0.001;\nconst vec3 lightDir = vec3(0.5, 1, 0.25);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst vec3 ambient = vec3(0.0, 0.0, 0.0);\n\nvec3 cameraPos;\n\nstruct Ray\n{\n    vec3 Pos;\n    vec3 Dir;\n    vec4 Color;\n    float Offset;\n};\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, vec3 p2, float s )\n{\n      return length(p - p2)-s;\n}\n\n// https://www.shadertoy.com/view/4lVXRm\nmat3 camRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\n\nfloat sceneDist(in vec3 p)\n{\n    return sdSphere(p, vec3(0, 0, 0), 1.0);\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 sceneNormal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = sceneDist(p + small_step.xyy) - sceneDist(p - small_step.xyy);\n    float gradient_y = sceneDist(p + small_step.yxy) - sceneDist(p - small_step.yxy);\n    float gradient_z = sceneDist(p + small_step.yyx) - sceneDist(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\n// https://learnopengl.com/Lighting/Basic-Lighting\nvec3 lightScene(in vec3 pos)\n{  \n    // Diffuse\n    vec3 norm = normalize(sceneNormal(pos));\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = diff * lightColor;\n    \n    // Specular\n    vec3 viewDir = normalize(cameraPos - pos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = 0.002 * spec * lightColor;  \n\n    return (ambient + diffuse + specular);\n}\n\nvoid march(inout Ray ray)\n{\n    float totalDist = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        float dist = sceneDist(ray.Pos);\n        \n        if(dist < EPS)\n        {\n           ray.Color = vec4(vec3(1, 1, 1) * lightScene(ray.Pos), 1);\n           break;\n        }\n        \n        float travel = min(dist, 0.025);\n        ray.Pos += ray.Dir * (travel * ray.Offset);\n        totalDist += travel;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float div = (iResolution.x / iResolution.y);\n    vec2 sUV = vec2((uv.x * div) - 0.4, uv.y);\n    \n    float rot = iTime * 0.2;\n    cameraPos = vec3(-sin(rot) * 2.0, 0, -cos(rot) * 2.0);\n    mat3 cameraDir = camRotation(-vec2(rot, 0));\n    \n    Ray ray;\n    ray.Pos = cameraPos;\n    ray.Dir = vec3((sUV * 2.0 - 1.0), 1) * cameraDir;\n    ray.Dir = normalize(ray.Dir);\n    ray.Offset = (length(texture(iChannel0, uv * 1.0)) * 0.1) + 1.0;\n    ray.Color = vec4(ambient, 1);\n    \n    march(ray);\n    \n    fragColor = vec4(ray.Color.xyz,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 301, 345, 345, 378], [380, 421, 449, 449, 679], [681, 681, 709, 709, 755], [757, 810, 839, 839, 1243], [1245, 1296, 1326, 1343, 1750], [1752, 1752, 1779, 1779, 2164], [2166, 2166, 2223, 2223, 2804]], "test": "untested"}
{"id": "clfSRB", "name": "sketch_011", "author": "afterlifevj", "description": "rainbow sketch", "tags": ["rainbow"], "likes": 2, "viewed": 170, "published": 3, "date": "1674933695", "time_retrieved": "2024-07-30T18:13:22.190267", "image_code": "\n#define u_time iTime\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n    vec3 pct = vec3(uv.x);\n    \n    pct.r = abs(sin(cos(uv.y + u_time) * 10. * uv.x + u_time));\n    pct.g = abs(cos(sin(u_time + 5. * uv.x) * 5. * uv.y + u_time));\n    pct.b = abs(cos(sin(u_time + 2. * uv.x) * 7. * cos(uv.y + u_time)));\n    \n    color = mix(colorA, colorB, pct);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 159, 209, 618]], "test": "untested"}
{"id": "DtfSRB", "name": "Shiny Pool mod", "author": "afterlifevj", "description": "Shiny pool mod", "tags": ["shiny"], "likes": 8, "viewed": 208, "published": 3, "date": "1674933456", "time_retrieved": "2024-07-30T18:13:23.194582", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 random3(vec3 st){\n    st = vec3( dot(st,vec3(17.1,61.7,19.73)),\n              dot(st,vec3(69.43,33.3,93.8)),\n             dot(st,vec3(74.31,36.1,83.9)));\n    return -1.0 + 2.0*fract(sin(st)*437581.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st,float travel) {\n    st += vec2(0.,0.);\n    vec3 i = floor(vec3(st,travel));\n    vec3 f = fract(vec3(st,travel));\n    \n\n    vec3 u = smoothstep(0.,1.,f);\n\n    float base00 = dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) );\n    float base10 = dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) );\n    float base01 = dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) );\n    float base11 = dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) );\n    float top00 = dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) );\n    float top10 = dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) );\n    float top01 = dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) );\n    float top11 = dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) );\n    float base = mix(mix(base00,base10,u.x),mix(base01,base11,u.x),u.y);\n    float top = mix(mix(top00,top10,u.x),mix(top01,top11,u.x),u.y);\n    return mix(base,top,u.z);\n    \n}\n\nfloat bumpFunc(vec2 st){\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);\n    float center = smoothstep(1.,0.,length(st));\n    vec2 noisedist = vec2(noise((st+0.3)*2.,10.),noise((st+vec2(13.1238,11.8837))*2.,iTime*0.1));\n    noisedist += vec2(noise((st)*8.,3.),noise((st+vec2(13.1238,11.8837))*8.,iTime*0.1+28.))*0.1;\n    float noisevalue = noise((st+noisedist*0.07+vec2(0.,iTime*0.05)*5.),iTime*2.);\n    noisevalue += noise((st+noisedist*0.35+vec2(0.,iTime*0.05))*25.,iTime*0.5)*0.25;\n    noisevalue += noise(st*5.5,iTime*0.15)*0.15;\n    return center*0.+smoothstep(-1.25,1.25,noisevalue);\n}\n\n//LIGHTING and BUMP section adapted from https://www.shadertoy.com/view/4l2XWK\n\nvec3 bumpMap(vec3 st){\n    vec3 sp = st;\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n\n\tconst float bumpFactor = 0.1;\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    return vec3(fx,fy,0.)*bumpFactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface position.\n    vec3 rd = normalize(vec3(uv, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(iMouse.xy/iResolution.xy*2.-vec2(1.), -0.85); // Light position\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\" \n    sn = normalize( sn + bumpMap(sp));           \n   \n    \n    // LIGHTING\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.05);\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 31.);\n    \n    //reflections\n    vec3 ref = reflect( vec3(sp.xy,bumpFunc(sp.xy)*0.8), sn );\n  \tfloat m = 2. * sqrt(pow( ref.x, 2. ) +\n    \t\t\tpow( ref.y, 2. ) +\n    \t\t\tpow( ref.z + 1., 2. ));\n  \tvec2 tcx = ref.xy / m + .5;\n    vec3 env_color = texture(iChannel0,tcx).rgb;\n    float grain = noise(uv.xy*10.,0.1);\n    vec3 color = diff*0.35*vec3(0.9450980392156862, 1.0, 0.3215686274509804)+vec3(0.8666666666666667, 0.4549019607843137, 0.9705882352941176)*spec*1.75+pow(env_color,vec3(2.9))*0.65+vec3(grain*0.1);\n    fragColor = vec4(color,1.);\n    //fragColor = vec4(vec3(bumpFunc(sp.xy)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 185, 185, 376], [378, 460, 495, 495, 1463], [1465, 1465, 1489, 1489, 2064], [2146, 2146, 2168, 2168, 2632], [2634, 2634, 2691, 2691, 4281]], "test": "untested"}
{"id": "Ds2SWt", "name": "Log-Polar Fractal Noise", "author": "amhall", "description": "Log-polar fractal noise with analytic normals.", "tags": ["noise", "fbm", "zoom", "logpolar"], "likes": 24, "viewed": 289, "published": 3, "date": "1674932880", "time_retrieved": "2024-07-30T18:13:24.276689", "image_code": "/*\n\n    Log-Polar Fractal Noise\n    Created by Anthony Hall, 2023\n\n    Infinitely descendable procedural fractal noise! I once saw an animation\n    with something like this but haven't been able to find it since.\n\n    The obstacle with any log-polar transform is the theta discontinuity. The\n    solution is to ensure that when your un-transformed theta coordinate shifts\n    by 2pi, you should see the exact same thing.\n\n    In addition to adding several rotated and scaled layers as in traditional\n    fractal noise, each layer has that constraint: moving 2pi units in the\n    un-rotated, un-scaled space lands you at the same part of the same noise\n    texel. So the scale and rotation of each layer are rounded such that in the\n    transformed space, a radial traversal's x and y components are integers,\n    and the domain's x and y are looped to those sizes.\n\n    Since every layer now needs its own rotation matrices, it's certainly\n    pricier than traditional fractal noise. It looks nice though!\n\n    A note on the analytic normals: They are only correct with a constant number\n    of layers. For anti-aliasing, the number of layers is proportional to the\n    log of the radius (the last layer is scaled by the decimal part). The exact\n    normals with this fade have hard edges between the start of each layer\n    because of the product rule. Changing the level fade to smooth the normals,\n    then computing that analytically, doesn't seem worth it. The last layer's\n    normals are scaled like the amplitude, without applying the product rule,\n    and still look good.\n\n*/\n\n// View a cross section of the noise. In the top-down view, it's kind of hard\n// to see what's really going on.\n// #define CROSSSECTION\n\n// Stay on one visualization method\n// 0 - colored and shaded, 1 - normalized height, 2 - normals\n// #define VIEW 0\n\n// Continually shift all the noise texel values (looks cool)\n// #define SHIFT\n\n// Generate a new seed on reset\n#define RESEED\n\n// Compare analytic vs numerical normals\n// #define DEBUGNORMALS\n\n\nconst float pi = radians(180.0);\nconst float tau = radians(360.0);\n\n// Globals calculated in mainImage()\nfloat shiftAmount;\nfloat seed;\n\n\nmat2 rotate(float theta)\n{\n  vec2 cs = vec2(cos(theta), sin(theta));\n  return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n// Slightly modified hash from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p, vec2 domainSize)\n{\n    // Tl;dr large inputs behave better when negated.\n    // Long version: The core of this all is that offsetting by domainSize\n    // needs to generate the same value. When this doesn't happen, there's\n    // visible discontinuity on the negative x axis. Normally, this starts to\n    // happen around time = 1620, but when negating the input, it never happened\n    // when I checked up to time = 10000.\n    p = -p;\n    \n    p = mod(p, domainSize);\n    \n    #ifdef RESEED\n        p.x += seed;\n    #endif\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float result = fract((p3.x + p3.y) * p3.z);\n\n    #ifdef SHIFT\n        return 0.5 - 0.5 * cos((result + shiftAmount) * tau);\n    #endif\n\n    return result;\n}\n\n// Interpolation function for noise\nvec2 interpolate(vec2 t)\n{\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Derivative of interpolation function\nvec2 dInterpolate(vec2 t)\n{\n    return 6.0 * (t - t * t);\n}\n\n// Gets the interpolated value and gradient of a single noise layer\nvec3 sampleNoise(vec2 point, vec2 domainSize)\n{\n    vec4 coords = vec4(floor(point), ceil(point));\n\n    float valTopLeft = hash12(coords.xw, domainSize);\n    float valTopRight = hash12(coords.zw, domainSize);\n    float valBottomLeft = hash12(coords.xy, domainSize);\n    float valBottomRight = hash12(coords.zy, domainSize);\n    \n    vec2 interp = interpolate(fract(point));\n    vec2 dInterp = dInterpolate(fract(point));\n\n    float top = mix(valTopLeft, valTopRight, interp.x);\n    float bottom = mix(valBottomLeft, valBottomRight, interp.x);\n    float left = mix(valBottomLeft, valTopLeft, interp.y);\n    float right = mix(valBottomRight, valTopRight, interp.y);\n\n    float height = mix(bottom, top, interp.y);\n    float dhdx = (right - left) * dInterp.x;\n    float dhdy = (top - bottom) * dInterp.y;\n    return vec3(height, dhdx, dhdy);\n}\n\n// Returns normalized height (not scaled), actual height (scaled with radius),\n// and gradient (xy partial derivaives)\nvec4 logPolarNoise(vec2 point)\n{\n    // Ideal deltas per layer. The true size and angle are rounded per layer\n    const float layerSizeScale = 2.0;\n    const float layerHeightScale = 0.5;\n    const float layerRotation = sqrt(0.5);\n\n    float r = length(point);\n    float logR = log(r);\n    float theta = atan(point.y, point.x);\n\n    #ifndef CROSSSECTION\n        vec2 zoom = vec2(0.01, 0.02) * iTime;\n        zoom.x = fract(zoom.x);\n    #else\n        vec2 zoom = vec2(0.0, 0.075 * iTime);\n    #endif\n    \n    vec2 logPolar = vec2(theta, logR) / tau - zoom;\n\n    float currentLayerSize = 13.0;\n    float currentLayerTheta = 0.0;\n    float currentLayerHeight = 1.0;\n    \n    float height = 0.0;\n    float maxHeight = 0.0;\n    vec2 gradient = vec2(0.0);\n \n    float layers = max(6.5 + logR / log(layerSizeScale), 1.0);\n    for (float i = 0.0; i < layers; i += 1.0)\n    {\n        // Calculate the rounded domain size based on the ideal scale and angle\n        vec2 domainSize = currentLayerSize \n            * vec2(cos(currentLayerTheta), sin(currentLayerTheta));\n        domainSize = floor(domainSize + 0.5);\n        float actualLayerSize = length(domainSize);\n        float actualLayerTheta = atan(domainSize.y, domainSize.x);\n        \n        // The offset is to prevent a visible \"lump\" where every layer's\n        // origins coincide\n        vec2 layerPoint = actualLayerSize\n          * rotate(actualLayerTheta) * logPolar + vec2(10.0, 0.0);\n        \n        // Fade in the fractional part of the last layer\n        float actualLayerHeight = currentLayerHeight * min(layers - i, 1.0);\n        maxHeight += actualLayerHeight;\n\n        // If a domain size evaluates to 0, it never has to repeat, so pretend\n        // by making it repeat infrequently\n        domainSize = abs(domainSize);\n        domainSize += 1e4 * step(domainSize, vec2(0.5));\n        \n        vec3 data = sampleNoise(layerPoint, domainSize);\n        height += actualLayerHeight * data.x;\n        gradient += actualLayerHeight * rotate(-actualLayerTheta - theta)\n          * data.yz * actualLayerSize;\n\n        currentLayerSize *= layerSizeScale;\n        currentLayerHeight *= layerHeightScale;\n        currentLayerTheta += layerRotation;\n    }\n    height /= maxHeight;\n    gradient = gradient.yx / tau / maxHeight;\n    \n    // Apply the product rule to the gradient. Note that the log-polar\n    // transform already scaled the domain by 1/r and the height by r\n    vec2 rGradient = point / r;\n    return vec4(height, height * r, rGradient * height + gradient);\n}\n\nvec3 visualizeData(vec4 data, int index)\n{\n    vec3 normal = normalize(vec3(-data.zw, 1.0));\n    \n    // Visualize height and shading with a moving light\n    if (index == 0)\n    {\n        float lightT = -1.59 * iTime;\n        vec3 toLight = normalize(vec3(cos(lightT), sin(lightT), 4.0));\n        return max(dot(normal, toLight), 0.0) * pow(vec3(data.x), vec3(4.0, 1.75, 1.0));\n        \n    }\n    // Raw noise (Not scaled with radius)\n    else if (index == 1)\n    {\n        return vec3(data.x);\n    }\n    // Surface normals\n    else\n    {\n        return 0.5 + 0.5 * normal;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #ifdef RESEED\n    \n        seed = texelFetch(iChannel0, ivec2(0), 0).x;\n    \n    #endif\n\n    #ifdef SHIFT\n    \n        if (iMouse.z > 0.0)\n        {\n            shiftAmount = iMouse.x / iResolution.x;\n        }\n        else\n        {\n            shiftAmount = 0.175 * iTime;\n        }\n    \n    #endif\n    \n    #ifndef DEBUGNORMALS\n    \n        #ifndef CROSSSECTION\n\n            // uv is not resolution-invariant to perserve fine detail in fullscreen\n            vec2 uv = (2.0 * fragCoord - iResolution.xy) / 450.0;\n            vec4 data = logPolarNoise(uv);\n\n            #ifndef VIEW\n\n                float view = iTime / 6.0;\n                int currentIndex = int(view) % 3;\n                int nextIndex = (currentIndex + 1) % 3;\n\n                float transitionLine = 0.5 * (fragCoord.x / iResolution.x + fragCoord.y / iResolution.y);\n                transitionLine -= 4.0 * (1.0 - fract(view));\n                float transition = smoothstep(-0.6, 0.0, transitionLine);\n\n                vec3 color = mix(\n                    visualizeData(data, currentIndex),\n                    visualizeData(data, nextIndex),\n                    transition);\n\n            #else\n\n                vec3 color = visualizeData(data, VIEW);\n\n            #endif\n\n        #else\n\n            // It would be way more efficient to just use a buffer but this is\n            // more for debug purposes anyway\n            float x = (2.0 * fragCoord.x - iResolution.x) / 800.0;\n            float y = fragCoord.y / 450.0;\n            vec4 data = logPolarNoise(vec2(x, 0.0));\n            \n            float yNorm = fragCoord.y / iResolution.y;\n            vec3 ground = mix(vec3(0.5, 0.25, 0), vec3(0), yNorm);\n            vec3 sky = pow(vec3(1.0 - yNorm), vec3(6.0, 2.0, 1.0));\n            vec3 color = mix(ground, sky, step(0.1 + data.y, y));\n\n        #endif\n    \n    #else\n    \n        // 10% pixel size epsilon\n        const vec2 eps = vec2(0.0, 0.2 / 450.0);\n        \n        vec2 uv = (2.0 * fragCoord - iResolution.xy) / 450.0;\n        vec4 data = logPolarNoise(uv);\n        \n        // A lot of the visible differences are because the numerical normal\n        // isn't symmetrically sampled. Taking 5 samples is not worth it, and\n        // making epsilon smaller makes fperror noticeable. Hopefully you're\n        // convinced the analytic normals are exact with constant layer count\n        vec3 analyticNormal = normalize(vec3(-data.zw, 1.0));\n        vec3 numericalNormal = normalize(vec3(\n            data.y - logPolarNoise(uv + eps.yx).y,\n            data.y - logPolarNoise(uv + eps.xy).y,\n            eps.y));\n       \n        // Display numerical or anayltic normal based on mouse X\n        // Display normal or difference between normals based on mouse Y\n        vec2 transition = (fragCoord.xy - iMouse.xy) / iResolution.xy;\n       \n        vec3 color = 0.5 + 0.5\n            * mix(numericalNormal, analyticNormal, step(0.0, transition.x));\n        color = mix(color, vec3(1.0), smoothstep(0.003, 0.0, abs(transition.x)));\n       \n        color = mix(0.5 + (analyticNormal - numericalNormal),\n            color, step(0.0, transition.y));\n        color = mix(color, vec3(1.0), smoothstep(0.003, 0.0, abs(transition.y)));\n    \n    #endif\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Random seed on reset\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    if (fragCoord == vec2(0.5))\n    {\n        if (iFrame == 0)\n        {\n            fragColor.x = hash14(iDate);\n        }\n        else\n        {\n            fragColor.x = texelFetch(iChannel0, ivec2(0), 0).x;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2SWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2173, 2173, 2199, 2199, 2307], [2309, 2394, 2433, 2838, 3182], [3184, 3220, 3246, 3246, 3284], [3286, 3326, 3353, 3353, 3385], [3387, 3455, 3502, 3502, 4295], [4297, 4416, 4448, 4525, 6947], [6949, 6949, 6991, 6991, 7530], [7532, 7532, 7587, 7587, 10854]], "test": "untested"}
{"id": "mtlSD7", "name": "Simple Raymarcher Test", "author": "Bricktronic", "description": "Just a simple raymarched noise sphere for now. I'm not very good at math, so I'm just messing around a bit :)", "tags": ["raymarched", "sphere"], "likes": 4, "viewed": 201, "published": 3, "date": "1674915539", "time_retrieved": "2024-07-30T18:13:25.045632", "image_code": "struct Ray\n{\n    vec3 Pos;\n    vec3 Dir;\n};\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, vec3 p2, float s )\n{\n      return length(p - p2)-s;\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nfloat sinNoise(vec3 p, float s)\n{\n    return sin(s * p.x) * sin(s * p.y) * sin(s * p.z);\n}\n\nfloat displace(vec3 p)\n{\n    return sinNoise(p, sin(iTime * 0.1) * 10.);\n}\n\n// https://www.shadertoy.com/view/4lVXRm\nmat3 camRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\n\nconst float EPS = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float div = (iResolution.x / iResolution.y);\n    vec2 sUV = vec2((uv.x * div) - 0.4, uv.y);\n    vec3 color = vec3(0, 0, 0);\n    \n    float rot = iTime * 0.2;\n    vec3 cameraPos = vec3(-sin(rot) * 2.0, 0, -cos(rot) * 2.0);\n    mat3 cameraDir = camRotation(-vec2(rot, 0));\n    \n    float offset = (length(texture(iChannel0, uv * 1.0)) * 0.1) + 1.0;\n    \n    Ray ray;\n    ray.Pos = cameraPos;\n    ray.Dir = vec3((sUV * 2.0 - 1.0), 1) * cameraDir;\n    ray.Dir = normalize(ray.Dir);\n    \n    float totalDist = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        float dist = sdSphere(ray.Pos, vec3(0, 0, 0), 1.0) + displace(ray.Pos);\n        \n        if(dist < EPS)\n        {\n           color = vec3(1, 1, 1) / ((float(i) + 1.) * 0.025);\n           break;\n        }\n        \n        float travel = min(dist, 0.025);\n        ray.Pos += ray.Dir * (travel * offset);\n        totalDist += travel;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 95, 139, 139, 172], [174, 227, 260, 260, 317], [319, 319, 343, 343, 393], [395, 436, 464, 464, 694]], "test": "untested"}
{"id": "dllSW7", "name": "new integer hash", "author": "FordPerfect", "description": "New hash, based on XQO primitive (https://github.com/skeeto/hash-prospector/issues/23), which seems better than murmur3-style two-rounders. Somewhat weaker than triple32.", "tags": ["random", "hash"], "likes": 5, "viewed": 416, "published": 3, "date": "1674910694", "time_retrieved": "2024-07-30T18:13:25.808593", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// See https://github.com/skeeto/hash-prospector/issues/23\n// for the description of the XQO primitive.\nuint hash(uint x)\n{\n    x ^= x >> 15;\n    x ^= (x * x) | 1u;\n    x ^= x >> 17;\n    x *= 0x9E3779B9u;\n    x ^= x >> 13;\n    return x;\n}\n\n/*\nComparison:\n\nFunction     | Linf        | RMS         | PractRand\n-------------|-------------|-------------|-------------------------------------------------\nxxHash       |     8658392 |   1195645.4 | Fails at  16KB\nMurmurHash3  |     4044016 |    566904.4 | Fails at  16KB\npcg_hash     |   331871348 |  16645540.6 | Fails at   4MB\nlowbias32    |     2023971 |    372660.4 | Fails at  32KB\nlowbias32_tib|     1211488 |    231074.2 | Fails at  64KB\n ->this<-    |      836260 |    121867.6 | Fails at   1GB\ntriple32     |      167788 |     44857.8 | Fails at   1GB ('mildly suspicious' at 8KB)\n\nNotes:\n1. Avalanche scores are measured similarly to\n     http://marc-b-reynolds.github.io/math/2019/08/10/Avalanche.html\n     with abs(counts[i][j]-(1ul<<31)) as data. Linf is infinity norm,\n     RMS is root mean square.\n2. PractRand is the result of `while(1) output(hash(i++));` piped to\n     RNG_test stdin32 -tlmin 1K -te 0 -tf 2\n     Using `-te 1` might be better.\n3. See https://www.shadertoy.com/view/XlGcRh for pcg_hash.\n4. See https://github.com/skeeto/hash-prospector for lowbias32 and\n     triple32. lowbias32_tib is the version by https://github.com/TheIronBorn.\n     See https://www.shadertoy.com/view/WttXWX.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    vec2 seed=mod(fragCoord,vec2(iResolution.x/8.0,iResolution.y/4.0));\n    uint bit=uint(int(floor(8.0*uv.x)+8.0*floor(4.0 * uv.y)));\n    uvec2 icoord=uvec2(ivec2(floor(seed+10.0*iTime)));\n    uint idx=1024u*icoord.y+icoord.x;\n    \n    float c=float((hash(idx)>>bit)&1u);\n\n    fragColor=vec4(c,c,c,1.0);\n    // Grid.\n    fragColor*=step(10.0/iResolution.x,1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor*=step(10.0/iResolution.y,1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSW7.jpg", "access": "api", "license": "public-domain", "functions": [[68, 172, 191, 191, 306], [1533, 1533, 1590, 1590, 2194]], "test": "untested"}
{"id": "cllXW4", "name": "Velvet Curl Noise PRM", "author": "fenix", "description": "Simulation from Shane's Visualizing Curl Noise: https://shadertoy.com/view/mlsSWH\nBRDF from knarkowicz's Cloth Shading: https://shadertoy.com/view/4tfBzn\n\nUsing \"progressive raymarching\" (PRM) as an optimization to allow steep slopes without bad FPS.", "tags": ["noise", "raymarch", "swirl", "fluid", "gradient", "curl", "warp", "bump", "brdf", "vortex"], "likes": 22, "viewed": 421, "published": 3, "date": "1674885984", "time_retrieved": "2024-07-30T18:13:26.913638", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This shader borrows heavily from others. Huge credit is due to Shane for his\n//\n//      Visualizing Curl Noise          https://shadertoy.com/view/mlsSWH\n//\n//  which forms the simulation backbone of this shader and was its inspiration. I have\n//  already shamelessly lifted the velvet BRDF from knarkowicz's\n//  \n//      Cloth Shading                   https://shadertoy.com/view/4tfBzn\n//\n//  You could consider this a mashup between those two shaders. But really, it was Shane's\n//  shader that inspired this one. The resulting texture seemed so rich and sumptuous that\n//  I had to know what it would look like raymarched in 3D with a velvet BRDF, and now I\n//  know. Pretty cool, I think.\n//\n//  I'm a little embarassed to be copy-pasting so much code, but I think I may have something\n//  interesting to contribute to raymarching here. Along the way I invented what might\n//  be a new technique that I'm calling \"progressive raymarching\" (PRM). Please disabuse\n//  me of my pride if it's a well known idea already. More details about that in Buffer C.\n//  In a nutshell it allow me to use very tiny raymarch increments (allowing resolution of\n//  steep slopes) without needing as many steps as you would normally. I think I will do\n//  more experiments with this idea in future shaders.\n//\n// ---------------------------------------------------------------------------------------\n\n// From Cloth Shading by knarkowics: https://www.shadertoy.com/view/4tfBzn\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat CharlieD(float roughness, float ndoth)\n{\n    float rcpR  = 1. / roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    return (2. + rcpR) * pow(sin2h, rcpR * .5) / (2. * PI);\n}\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n\nfloat CharlieV(float roughness, float ndotv, float ndotl)\n{\n\tfloat visV = ndotv < .5 ? exp(L(ndotv, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotv, roughness));\n\tfloat visL = ndotl < .5 ? exp(L(ndotl, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotl, roughness));\n\n\treturn 1. / ((1. + visV + visL) * (4. * ndotv * ndotl));\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0, 1, -0));\n\nvec3 velvet(vec3 normal, vec3 rayDir, vec3 baseColor)\n{\n    vec3 viewDir = -rayDir;\n    const vec3 lightDir = LIGHT_DIR;\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth = saturate(dot(viewDir, halfVec));\n    float ndoth\t= saturate(dot(normal.xyz, halfVec));\n    float ndotv = saturate(dot(normal.xyz, viewDir));\n    float ndotl = saturate(dot(normal.xyz, lightDir));\n\n    vec3 diffuseColor  = 0.25 * baseColor;\n    vec3 specularColor = sqrt(baseColor);\n    float roughness    = .2;\n\n    vec3 diffuse = diffuseColor * saturate(abs(dot(normal.xyz, lightDir)));\n\n    vec3 f = FresnelTerm(specularColor, vdoth);\n\n    float d = CharlieD(roughness, ndoth);\n    float v = CharlieV(roughness, ndotv, ndotl);\n\n    vec3 specular = f * (d * v * PI * ndotl);\n\n    vec3 color = diffuse + specular;\n    return color;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec4 gb = texture(iChannel0, fragCoord/iResolution.xy);\n    vec3 n = gb.xyz; // unpack normal from G buffer\n    float t = gb.w;  // unpact t from G bufffer\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fragColor.rgb = velvet(n, rayDir, vec3(.2,.01,.2));\n    fragColor.rgb = pow(ACESFilm(fragColor.rgb), vec3(1./2.2));\n    fragColor.a = 1.;\n    if (keyDown(KEY_SPACE))\n        fragColor = pow(vec4(.9, .5, .3, 0), 1./texture(iChannel0, fragCoord/iResolution.xy));\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//   This is just a modified version of Buffer A of Shane's\n//   \n//   Visualizing Curl Noise     https://shadertoy.com/view/mlsSWH\n//\n//   First off, I hope Shane doesn't mind my direct copying of his code. I hope (s)he sees\n//   this and signals approval or disapproval. It's hard to know whether (s)he expected\n//   people to copypasta the code or just read and learn from it. If the intent was for me\n//   to develop my own version following the model but not copy the code, I'll go off and\n//   do that before re-posting this. My excuse for posting is that I think I have contributed\n//   something of value on top of the original simulation.\n//\n//   This was super fun to play with, not least because of the very clear code and\n//   comments. I tried to set the options to get lots of surface texture while minimizing\n//   sharp peaks that give the raymarcher fits. @Shane if you're reading this, I wonder if\n//   you have any other ideas to make this even better looking.\n//\n// ---------------------------------------------------------------------------------------\n\n// Integrate more frames and increase the swirl length.\n#define LONGER\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(27, 57, 111)));   \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n \n}\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing -- I'll rewrite it at some stage. By the way, Stefan Gustavson has an account on\n// Shadertoy, if you feel like tracking that down.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p){\n\n    // Skewing the cubic grid, then determining the first vertex and fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)) );  p -= i - dot(i, vec3(1./6.));\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + 1./6., p2 = p - i2 + 1./3., p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n     \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), \n                  dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n \n}\n\n\n// Layered noise function.\nfloat fBm(in vec3 p){\n    \n    return (tetraNoise(p)*4. + tetraNoise(p*2. + .23)*2. + tetraNoise(p*4. + .07))/7.;\n    //return (tetraNoise(p)*2. + tetraNoise(p*2. + .23)*1.)/3.;\n}\n \n \n// Flow function.\nfloat flow(vec3 p){\n\n   // Emulating moving toward the surface of a sphere, or landing on \n   // planet Cartoon Jupiter, if you prefer. :)\n \n   p.z -= dot(p, p)*.5; \n   p.xy *= rot2(iTime/16.);\n   #ifdef LONGER\n   // Longer swirl strands get too tight if you slice through\n   // Z too quickly, so it needs slowing down.\n   p.z += .1*iTime;\n   #else\n   p.z += .15*iTime;\n   #endif\n   \n   // You can put whatever function you want here, but simplex noise has nice\n   // animation qualities, so I've used that. At some stage, I'll try other \n   // things. By the way, if you have any suggestions, feel free to let me know.\n   return fBm(p*1.5)*2. - 1.;\n   \n   \n   /*\n   // Failed angular noise experiment.\n   p += vec3(.0, .0, .2)*iTime/3.;\n   return fBm(p*1.5*2.)*2. - 1.;\n   */\n  \n}\n\n \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    // Coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR;\n    \n      \n    vec2 uva = (fragCoord - iR/2.)/iR.y;\n  \n    // Taking the curl of the flow function. Intuitively, the perpendicular\n    // vector to the tangent vector \"v\" is simply, \"vec2(v.y, -v.x)\", and the\n    // curl is analogous to the gradient equivalent, \"vec2(df/dy, -df/dx)\".\n    vec2 e = vec2(.01, 0);\n    vec3 p = vec3(uva, 0);//vec3(p, length(p)*.5);\n    float dx = (flow(p + e.xyy) - flow(p - e.xyy))/(2.*e.x);\n    float dy = (flow(p + e.yxy) - flow(p - e.yxy))/(2.*e.x);\n    vec2 curl = vec2(dy, -dx);\n     \n    // 3D curl. Not used here.\n    //float dz = (noise(p + e.yyx) - noise(p - e.yyx))/(2.*e.x);\n    //vec3 curl = vec3(dz - dy, dx - dz, dy - dx);\n \n/*\n    // Angular offsetting... Not right for this example.\n    vec2 e = vec2(.001, 0);\n    vec3 pos = vec3(p, 0);/\n    float a = (flow(pos))*6.2831*1.5;\n    vec2 curl = vec2(cos(a), -sin(a))*2.;\n*/\n      \n \n    // Update the field coordinates.\n    uv += curl*.0005*vec2(iR.y/iR.x, 1); // Move to the new position.\n    \n    \n    // Buffer sample from the new position.\n    vec3 val = texture(iChannel0, uv).rgb;\n \n    \n    //col = texture(iChannel2, uv, 3.).xyz; col *= col;\n    //col = smoothstep(.0, .5, col);\n\n    // Create transcental color pattern using the warped coordinates.\n    float snNs = dot(sin(uv*8. - cos(uv.yx*12.)), vec2(.25)) + .5;\n    //vec3 col = .5 + .45*cos(6.2831*snNs/6. + vec3(0, 1.2, 2)*.8);\n    vec3 col = mix(vec3(1, .8, .6).zyx, vec3(.6, .3, .2), snNs);\n   \n    // Color shading.\n    // Just the original function without the curl, which gives the\n    // impression of cast shadows.\n    //col *= flow(p) + .5;\n    // This is more correct, but I like the uncurled shading more.\n    //col *= flow(vec3(uv, 0)) + .5;\n    \n  \n    // Ridges -- Probably a little too much, but it'd be an interesting\n    // addition if you wanted to raymarch the surface.\n    col *= abs(fract(col.x*16.) - .5)*200.*.04 + .96;\n     \n    \n    // Mix the curent warped color texture in with the previous one.\n    // Some people like to inject pixels from the sides and add those, but\n    // for this example, I'm performing a simple blend... However you mix\n    // frames is entirely up to you.\n    //\n    // More frames generally result in longer spirals. However, the speed at \n    // which we cut through the Z-planes (p.z += a*iTime), might need to \n    // be lowered.\n    #ifdef LONGER\n    const float nFrames = 32.;\n    #else\n    const float nFrames = 16.;\n    #endif\n    if(iFrame>0) col = mix(val, col, 1./nFrames);\n    \n  \n    fragColor = vec4(col, 1);\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//   This is just a stripped-down version of the Image tab of Shane's\n//   \n//   Visualizing Curl Noise     https://shadertoy.com/view/mlsSWH\n//\n//   I highly recommend checking out the original with all its options and awesome\n//   comments. But I only needed the height information to raymarch against, so after\n//   stripping it down, it didn't seem to make much sense to leave half the code\n//   commented out.\n//\n// ---------------------------------------------------------------------------------------\n\n// Texture samples.\nvec3 tx2D(vec2 p){ return texture(iChannel0, p).xyz; }\n\n// Texture height.\nfloat getHeight(vec2 p){ return dot(tx2D(p), vec3(.299, .587, .114)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR;\n    \n    // Texture samples.\n    vec3 col = tx2D(uv);\n    \n    // Height value and offset sample for the colored lights.\n    float height = dot(col, vec3(.299, .587, .114));\n    float height2 = getHeight(uv - normalize(vec2(1, 2))*.001*vec2(iR.x/iR.y, 1));\n    \n    vec2 e = vec2(.0045, 0); // Constant sample distance.\n\n    // Taking four nearby offset samples to use for gradient and curvature calculations.\n    vec4 t4 = vec4(getHeight(uv - e.xy),  getHeight(uv + e.xy), \n               getHeight(uv - e.yx), getHeight(uv + e.yx));\n\n    // Using the four samples above to calculate the surface curvature.\n    float amp = .7;\n    float curv = (height*4. - dot(t4, vec4(1)))/e.x/8.*amp + .5;\n            \n    // Rough gamma correction.\n    fragColor = vec4(pow(curv, 1.2));\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n//   Progressive raymarch/G buffer\n//\n//   So the story is, I originally thought I was going to use SSOA on this shader, so I\n//   set it up using deferred rendering in the style of a lot of my recent shaders like\n//\n//     Candy Avalance         https://shadertoy.com/view/dlfSz4\n//\n//   I ended up not being able to tune the SSOA to really look good on top of the Charlie\n//   sheen velvet BRDF. It's already darkened in the crevices so it was hard to blend the\n//   two. But, along the way, having a deferred rendering pipeline gave me what might be a\n//   new idea, or at least, it's new to me.\n//\n//   I've been calling it \"progressive raymarching\" during development...please let me \n//   know if it's a known thing and already has a name.\n//\n//   The idea is essentially simple: use the previous frame's t value as a starting point\n//   for the next frame's raymarch. This was super easy to try out since I already was \n//   remembering the t value in the G buffer. By itself this causes a tremendous speed\n//   boost...try turning off PROGRESSIVE to see the difference. It reminds me of the value\n//   of \"warm starting\" a constraint solver, since you essentially continue from where you\n//   left off the previous frame. This allow me to use a very tiny march increment and still\n//   need relatively few steps in the average case.\n//\n//   By itself, though, this can cause artifacts. When an area of lower t begins to occlude\n//   a higher t area, the raymarcher can get stuck in the \"local minima\" of the higher t\n//   surface. To combat this, I take a few extra sample points below and to the sides\n//   of the rendered pixel, and use the minimum t of all those points as a starting point.\n//   This results in a few extra iterations in the usual case, but it's still faster than\n//   starting without a warm-start value for t. To disable this workaround, turn off\n//   MULTI_SAMPLE_LAST_T. \n//\n//   Hold down space to see a visualization of the nubmer of steps the raymarcher needed,\n//   noting that with PROGRESSIVE disabled, it takes a lot more steps. Also try pressing\n//   space while you have MULTI_SAMPLE_LAST_T disabled and observe how almost no raymarch\n//   steps are needed. If local-minima artifacts are acceptable in your scene for whatever\n//   reason (say, t is static or only changes smoothly over time) then the speedup of this\n//   method is huge.\n//\n// ---------------------------------------------------------------------------------------\n\n#define PROGRESSIVE 1 // enable \"progressive raymarching\"\n#define MULTI_SAMPLE_LAST_T 1 // enable this for speed boost + local-minima artifacts\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n#if PROGRESSIVE\n    // look up the results of last frame's raymarching so we can use it as a starting point\n    float lastT = texelFetch(iChannel1, ivec2(fragCoord), 0).w;\n    ivec2 below = ivec2(fragCoord.x, max(fragCoord.y - 5., 0.));\n#if MULTI_SAMPLE_LAST_T\n    // also consider a few other pixels so we don't get stuck in local minima as easily\n    float lastBelowT = texelFetch(iChannel1, below, 0).w;\n    ivec2 right = ivec2(min(fragCoord.x + 5., iResolution.x - 1.), fragCoord.y);\n    float lastRightT = texelFetch(iChannel1, right, 0).w;\n    ivec2 left = ivec2(max(fragCoord.x - 5., 0.), fragCoord.y);\n    float lastLeftT = texelFetch(iChannel1, left, 0).w;\n    \n    float t = min(min(min(lastT, lastBelowT), lastRightT), lastLeftT);\n#else\n    float t = lastT;\n#endif\n\n    if (iFrame < 2) t = -cameraPos.y / rayDir.y; // don't trust buffer values until a couple of frames have gone by\n#else\n    float t = -cameraPos.y / rayDir.y;\n#endif\n    \n    vec3 p = cameraPos + rayDir * t; // start right on the surface from last frame\n    vec3 hitPos = march(iChannel0, p, rayDir, t);\n    \n    vec3 n = norm(iChannel0, hitPos);\n    \n    // record G buffer results\n    fragColor.xyz = n;\n    fragColor.w = t;\n    \n    // support step number debug visualization\n    if (keyDown(KEY_SPACE))\n        fragColor.xyz = vec3(float(ns) / float(MAX_STEPS));\n}\n\n\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653589793;\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, -.5, 0);\n    cameraPos\t = vec3(0, 2, -5);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0) *.3,\n        vec4(-0.5*cameraUp, 0.0) * .3,\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft * .3 - screenPos.y * cameraUp * .3);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nfloat map(sampler2D sampler, vec3 p)\n{\n    return texture(sampler, p.xz*.2 + .5).x*.5 + p.y + .2;\n}\n\nconst int MAX_STEPS = 512;\nconst float SDF_EPS = .01;\n\nint ns;\nvec3 march(sampler2D sampler, vec3 p, vec3 rd, inout float t)\n{\n    ns = 0;\n   \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = map(sampler, p);\n        if (abs(d) < SDF_EPS) break;\n        d *= .05;\n        p += d * rd;\n        t += d;\n        ns++;\n    }\n    return p;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 norm(sampler2D sampler, vec3 p)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.0001;\n    return normalize( e.xyy*map(sampler, p + e.xyy) + \n\t\t\t\t\t  e.yyx*map(sampler, p + e.yyx) + \n\t\t\t\t\t  e.yxy*map(sampler, p + e.yxy) + \n\t\t\t\t\t  e.xxx*map(sampler, p + e.xxx) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllXW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1601, 1676, 1727, 1727, 1824], [1826, 1826, 1851, 1851, 1882], [1884, 1884, 1907, 1907, 1950], [1952, 1952, 1998, 1998, 2157], [2159, 2159, 2186, 2186, 2481], [2483, 2483, 2542, 2542, 2821], [2874, 2874, 2929, 2929, 3697], [3699, 3783, 3806, 3806, 3966], [3968, 3968, 4020, 4020, 4683]], "test": "untested"}
{"id": "mtfSD7", "name": "Flood fill maze", "author": "jarble", "description": "An infinite maze with randomly colored [url=https://en.wikipedia.org/wiki/Flood_fill]flood-filled[/url] walls.\nThis flood fill algorithm doesn't always fill every pixel, so some of the walls have more than one color.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 17, "viewed": 432, "published": 3, "date": "1674857296", "time_retrieved": "2024-07-30T18:13:27.678593", "image_code": "float threshold = .5;\nint iters = 4;\n\n#define noise2D(p) float(((p).x * 68657387u ^ (p).y * 361524851u + (p).x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < threshold);\n}\n\nbool labyrinth1(uvec2 I){\nbool b = false;\n    for(int i = 0; i++ < iters;I = I*2u/3u){\n        float n = noise2D(I);\n        b = !b || labyrinth(I,n);\n        \n        //some random-looking distortion\n        //{I = I+I.yx/(31u)-I.yx/(29u)-I.yx/(23u);}\n        //{I = I-I.yx/13u/11u/7u/5u+I.yx/11u/7u/5u-I.yx/7u/5u;}\n    }\n    return b;\n}\n\n\nbool next_to_wall(uvec2 current){\n    return labyrinth1(current + uvec2(0,1))\n    || labyrinth1(current - uvec2(0,1))\n    || labyrinth1(current + uvec2(1,0))\n    || labyrinth1(current - uvec2(0,1));\n}\n\nuvec2 next_pos(uvec2 prev,uvec2 current){\n    uvec2 diff = current-prev;\n    uvec2 forward = current+diff;\n    uvec2 left = current + diff.yx;\n    uvec2 right = current - diff.yx;\n    //if(prev == current || !next_to_wall(current)) current.y += 1u;\n    if(!labyrinth1(forward) && next_to_wall(forward)) return forward;\n    else if(labyrinth1(forward) && !labyrinth1(left) && next_to_wall(left)) return left;\n    else if(labyrinth1(forward) &&  !labyrinth1(right) && next_to_wall(right)) return right;\n    else return prev;\n    \n}\n\nvec3 hash32(uvec2 p1)\n{\n    vec2 p=vec2(p1);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nbool move1(in uvec2 I,inout uvec2 I1){\n    if(!labyrinth1(I))\n    {I1=I;return true;}\n    else return false;\n}\n\nvec4 floodfill(uvec2 I){\n    vec4 O = vec4(1);\n    if(labyrinth1(I)) return O = 1.-O;\n        \n    while(true){\n            if(!(move1(uvec2(I.x,I.y-1u),I)\n            || move1(uvec2(I.x-1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y-1u),I)\n            || move1(uvec2(I.x+1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y+1u),I)\n            || move1(uvec2(I.x+1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y+1u),I)\n            || move1(uvec2(I.x-1u,I.y),I)))\n            break;\n    }\n    return vec4(hash32(I),1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = floodfill(I);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a += floor(a/b);\n    /*\n    for(int i = 0; i < 3; i++){\n        a /= 1. + mod(floor(a*2.),2.);\n        a += floor(a/pow(2.,b));\n    }\n    */\n    a +=\n        floor(a*pow(2.,b))/pow(2.,b)\n        //floor(a*8.)/8.\n    ;    \n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/2.)),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  //t = mod(t,2.)+floor(t/2.)*2.;\n  //t = (t + pow(2.,fmod(t,3.)));\n  //t +=\n      //floor(t/8.) + floor(t*8.)/8.\n      //mod(floor(t*8.)+floor(t/8.),8.)/8.\n  //;\n  //t /= 2.;\n  float\n  tempo1 =\n      //4.\n      pow(2.,1.+fmod(t/8.,2.))\n  ,\n  m1 =\n      //tempo1\n      //pow(2.,1.+fmod(t/tempo1,3.))\n      pow(2.,1.+fmod(t*tempo1,3.))\n  ,\n  \n  c1 = fmod(t*tempo1,m1+fmod(t,m1)),\n  s1 = 1.+c1,\n  \n  t1 = t*tempo1,\n  m2 = fmod(t1*(1.+fmod(t,2.))/2.,s1),\n\n  a=\n      64.*pow((1.-sqrt(fract((t*tempo1+m2+t1)/2.))/1.25),2.)*.2\n      //16.*log((1.-abs(fract((-t*tempo1+m2-t1)/2.))/1.25))\n      //pow((1.-sqrt(fract(t*tempo1+floor(m2+t1)/2.))/1.25),2.)*.2\n  ,\n  nb =\n      t*tempo*pow(2.,m2/5.+7.)/(1.+fmod(t+m2,2.))\n      //pow(2.,m2/5.+7.5)/(1.+fmax(t+m2,t,2.))\n  ;\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //log(1.-abs(.5-vec2(fract(nb*.998*2.),fract(nb))))*a\n      //vec2(fract(t*nb*.998/2.*(1.+m2)),fract(t*nb*2./(1.+m2)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 167, 167, 256], [258, 258, 283, 283, 596], [599, 599, 632, 632, 799], [801, 801, 842, 842, 1330], [1332, 1332, 1355, 1355, 1512], [1514, 1514, 1552, 1552, 1624], [1626, 1626, 1650, 1650, 2273], [2275, 2275, 2311, 2311, 2373]], "test": "untested"}
{"id": "dtfXDM", "name": "fractale fern  ( 296 ch )", "author": "FabriceNeyret2", "description": "transposing yonatan's [url]https://twitter.com/zozuar/status/1618281672008675330[/url]\nwith antialiasing", "tags": ["short", "fractale", "golf", "reproduction"], "likes": 56, "viewed": 666, "published": 3, "date": "1674853152", "time_retrieved": "2024-07-30T18:13:28.721804", "image_code": "// transposing yonatan's https://twitter.com/zozuar/status/1618281672008675330\n\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float k = fract(iTime*.5), i=0., y = i, f;\n    vec2  R = iResolution.xy,\n          p = ( u+u - R ) / R.y / exp(k+2.);                // normalization & zoom\n          \n    for(o *= i ; i++ < 6. && y < .5; p -= round(p) )        // fractal loop ( try without y<.5 ;-) )\n        o += smoothstep( f = fwidth(p.y), -f , p.y+.26 )    // antialias outer spiral arm\n           * smoothstep( 0., min(.1,f+f) , .5 - abs(p.y) ), // antialias inner spiral arm\n        p = vec2( y = atan(p.x,p.y)/1.05 + k + 2.,          // spiral transform\n                  y = log(length(p)*2.7) - k/6.28 + y/6. );\n     // p -= round(p);                                      // tiling along the spiral\n}\n\n\n\n\n\n\n/** // 319 chars\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float k = fract(iTime*.5), y = -1., i=0.;\n    vec2  R = iResolution.xy,\n          p = ( u+u - R ) / R.y / exp(k+9.);             // normalization & zoom\n          \n    for(o *= i ; i++ < 6. && y < -.5; )                  // fractal loop ( try without y<-.5 ;-) )\n     // o += step(p.y,-.7),\n        o += smoothstep( 1., -1. ,(p.y+.7)/fwidth(p.y) ) // antialias outer spiral arm\n           * smoothstep( .0, 2. , ( 1.35 - abs(p.y) ) / min(.1,fwidth(p.y)) ), // antialias inner spiral arm\n        p = vec2( y = atan(p.x,p.y)/1.05 + k - 4.,       // spiral transform\n                  y = log(length(p)) - k/6.28 + y/6. ),\n        p -= round(p),                                   // tiling along the spiral\n     // p = fract(p+.5) - .5,\n        p *= 2.7;                                        // scaling between levels\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 119, 119, 801]], "test": "untested"}
{"id": "dlfSDM", "name": "Logo Unity Animated", "author": "Karp", "description": "Unity Logo\n", "tags": ["logo", "unity"], "likes": 5, "viewed": 219, "published": 3, "date": "1674849582", "time_retrieved": "2024-07-30T18:13:29.520668", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameter\n    float time = mod(iTime,3. * PI);\n    float size = 1. + Clamp01((time * .5) -2.) *sin(time) * .2;\n    float rounding = 0.1;\n    float blurLvl = 250.0;\n\n    //Color\n    vec3 background = Color255(250,250,250);\n    vec3 shadow = Color255(0,0,0);\n    vec3 highlight = Color255(140,140,140);\n    vec3 midtone = Color255(76,76,76);\n    vec3[] colors = vec3[](highlight, midtone, shadow);\n    \n    //Start\n    vec2 uv = AspectRatioUV(fragCoord, iResolution.xy);\n    vec3 pixel = background;\n    float voidmask,square, line;\n    \n    //Cube\n    pixel = mix(Clamp01(time -0.33)*Cube(uv * (1./size), 0.,colors,blurLvl), pixel, CubeMask(uv, Clamp01(time) * size, blurLvl));\n    \n    for(float i = 0.; i < 3.; i++)\n    {\n        //Rounded Square\n        square = sdRhombus(RotateUV(uv, i *120.) + Clamp01(time -1.-(i * .33)) * vec2(0.0,-0.25 * size),Clamp01(time -1.-(i * .33)) * vec2(.22* size,.22* size / 1.75));\n        voidmask += mix(1., 0., Clamp01((square-.01)*blurLvl));\n        //Line\n        line = sdBox(RotateUV(uv, i *120.)+ Clamp01(time -2.-(i * .33)) *vec2(0.0,-1.* size), Clamp01(time -2.-(i * .33)) *vec2(0.025* size,0.8* size));\n        voidmask += mix(1., 0., Clamp01((line-.01)*blurLvl));\n    }\n\n    pixel = mix(pixel, background, Clamp01(time -1.66) *Clamp01(voidmask));\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n//UV\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = vec2( fragCoord.xy - 0.5*resolution.xy );\n    // [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920 / 1080 = 1.778\n    // [-0.5*iResolution.x, 0.5*iResolution.x] ->[-1.778, 1.778]\n\t// [-0.5*iResolution.y, 0.5*iResolution.y] ->[-1, 1]\n    \n    return uv;\n}\nvec2 RotateUV(inout vec2 uv, float angle)\n{\t\n\tangle = angle * PI / 180.0;\n    return uv * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\n//Color \nvec3 Color255(int R, int G, int B)\n{\n    return vec3(float(R)/255.0, float(G)/255.0, float(B)/255.0);\n}\nfloat Clamp01( in float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n//Regular Hexagon - exact from https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n// Rhombus - exact from IQ (https://www.shadertoy.com/view/XdXcRB)\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\nfloat sdBox( in vec2 pos, in vec2 box )\n{\n    vec2 dist = abs(pos)-box;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0);\n}\nvec3 Cube(vec2 uv,float size, vec3[3] colors, float blurLvl)\n{\n    vec3 result = vec3(0.0);\n    //Sqrt(3) = 1.732\n    float top   = sdRhombus(RotateUV(uv, 000.0) + vec2(0.0,-.6/ 1.732), vec2(.6,.6 / 1.732));\n    float left  = sdRhombus(RotateUV(uv, 120.0) + vec2(0.0,-.6/ 1.732), vec2(.6,.6 / 1.732));\n    float right = sdRhombus(RotateUV(uv,-120.0) + vec2(0.0,-.6/ 1.732), vec2(.6,.6 / 1.732));\n\n    result = mix(colors[0], result, Clamp01((top)*blurLvl));\n    result = mix(colors[1], result, Clamp01((left)*blurLvl));\n    result = mix(colors[2], result, Clamp01((right)*blurLvl));\n\n    return result;\n}\n\nfloat CubeMask(vec2 uv,float size, float blurLvl)\n{\n    return Clamp01((sdHexagon(RotateUV(uv, 30.0), size *0.5))*blurLvl);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DlXSW7", "name": "Kebabogauchiste - Sin(Banger)", "author": "totetmatt", "description": "Most difficult part of a journey is the first step -- One day, someone", "tags": ["banger"], "likes": 4, "viewed": 251, "published": 3, "date": "1674827889", "time_retrieved": "2024-07-30T18:13:30.430235", "image_code": "float rand(float co){\n    return fract(sin(dot(vec2(co,co), vec2(12.9898, 78.233))) * 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    float s = length(uv)-.4;\n    float tempo = iTime*135./60.;\n    s = smoothstep(sqrt(dFdx(s)*dFdx(s)+dFdy(s)*dFdy(s)),.0,abs(s)-.1-sin(tempo+atan(uv.x,uv.y)*(8.-floor(rand(floor(tempo))*7.*pow(fract(tempo),.1))))*.05);\n                  // ^--- Apparently it's more correct than fwidth \n                  // I'm expecting this code will invoke a\n                  // FabriceNeyret to explain why :D \n    vec3 col = vec3(1.)*s;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "/**\n\n\nYou need to start with something.....\n\nGreets to @0b5vr, getting understanding of this madness to\nmaybe get something released in JS one day ? \nhttps://github.com/0b5vr/js-4k-test\n\nThe kick is mainly from 0b5vr framework.\n\n**/\nfloat rand(float co){\n    return fract(sin(dot(vec2(co,co), vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec2 mainSound( int samp, float time )\n{\n   float tempo = time*135./60.;\n   float bpm = floor(tempo*4.);\n   float seq[4];\n   seq[0] = 660.;\n   seq[1] = 330.;\n   seq[2] = 660.*4.*sin(time*2.)*.5+1.;\n   seq[3] = 660.*1.5;\n   \n   vec2 dest = vec2(0.);\n // kick\n   \n    float t = fract(tempo);\n    float env = smoothstep( 0.95, 0.1, t);\n\n    dest += 0.5 * env * tanh(fract(cos(t*1.)*50.+t*100.)+ 1.5 * sin(\n      100.0 * t\n      - 45.0 * exp( -1. * t )\n      - 30.0 * exp( -500.0 * t )\n      \n      + sin(t)\n    ) )*2.;\n\n\n   \n   dest = max(dest,sin(t*seq[int(rand(bpm)*3.+2.)]));\n   dest +=fract(time*(rand(ceil(time))*50.+100.))*.5;\n    // A 440 Hz wave that attenuates quickly overt time\n    return dest;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 100], [101, 101, 158, 208, 786]], "test": "untested"}
{"id": "cdXSWj", "name": "Louis Cole - Thinking Cover", "author": "MysteryPancake", "description": "Available on music platforms! https://distrokid.com/hyperfollow/mysterypancake/thinking-glsl-remix\nLearnt how to make delays, tremolo and vibrato. Rewind for better audio sync :)", "tags": ["sound", "music", "synthesis", "synth", "saw", "song", "sawtooth", "gpusound", "supersaw", "chords"], "likes": 25, "viewed": 873, "published": 3, "date": "1674816280", "time_retrieved": "2024-07-30T18:13:31.449510", "image_code": "vec3 drawTrack(vec2 uv, vec2 samp, float offset, vec3 color) {\n    float glow = min(1.0, 0.03 / abs(uv.y - samp.x * 0.1 - offset));\n    float line = min(1.0, 0.003 / abs(uv.y - samp.y * 0.1 - offset));\n    return line + glow * color * 0.4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    Song song = getSong(iTime + (uv.x - 1.0) * SPB * 0.5);\n    Song songNow = getSong(iTime);\n    float boom = 1.0 - songNow.sidechain;\n    \n    // Draw foreground\n    vec3 col = drawTrack(uv, song.drums, 0.8 + boom * 0.1, vec3(1.0, 0.0, 0.0));\n    col += drawTrack(uv, song.bass, 0.6 + boom * 0.2, vec3(1.0, 1.0, 0.0));\n    col += drawTrack(uv, song.voice, 0.4 - boom * 0.2, vec3(0.0, 1.0, 0.0));\n    col += drawTrack(uv, song.lead, 0.2 - boom * 0.1, vec3(0.0, 0.0, 1.0));\n    \n    // Draw background\n    vec2 center = uv - 0.5;\n    vec2 coolUv = fract(center / dot(center, center));\n    float dist = abs(coolUv.y - song.drums.x * 0.5 - 0.5);\n    col += min(1.0, 0.02 / dist) * 0.2;\n    \n    // Glow effects\n    col *= 1.0 + boom * 2.0;\n    col += smoothstep(0.4, 0.6, length(uv - 0.5)) * boom * 0.5;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "const float BPM = 112.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\n// This song uses nonstandard tuning (50 cents above 440 Hertz)\nconst float TUNING = 440.0;\nconst float MIDIOFFSET = 68.5;\n\nconst float TAU = 6.28318530;\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn TUNING * exp2((note - MIDIOFFSET) / 12.0);\n}\n\n// Triangle waveform, see https://www.shadertoy.com/view/clXSR7\nvec2 tri(float freq, float time, vec2 phase) {\n    return abs(fract(phase + freq * time) - 0.5) * 4.0 - 1.0;\n}\n\n// Sawtooth waveform, see https://www.shadertoy.com/view/clXSR7\nvec2 saw(float freq, float time, vec2 phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// Basic white noise\nvec2 stereoNoise(float time) {\n    return vec2(hash(time * 2048.0), hash(time * 1024.0)) * 2.0 - 1.0;\n}\n\nvec2 noiseHit(float time, float fade) {\n\treturn stereoNoise(time) * exp(-fade * time);\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash(float(si)), hash(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float bandwidth) {\n    return sin(TAU * freq * fract(time)) * noise(time * bandwidth);\n}\n\n// Used for bass and lead synths\nvec2 timedSaw(float freq, float time, float start, float end, float seed) {\n    if (time >= start * SPB && time < end * SPB) {\n        vec2 phase = vec2(hash(seed * 1024.0));\n        // Keep bass mostly mono\n        if (freq > 45.0) {\n            phase += vec2(hash(1024.0 * seed + 2048.0 * start), hash(2048.0 * seed + 1024.0 * start));\n        }\n        return saw(noteFreq(freq), time, phase);\n    }\n    return vec2(0.0);\n}\n\n// Used for voices\nvec2 timedTri(float freq, float time, float start, float end, float seed) {\n    if (time >= start * SPB && time < end * SPB) {\n        vec2 phase = vec2(hash(1024.0 * seed + 2048.0 * start), hash(2048.0 * seed + 1024.0 * start));\n        float hertz = noteFreq(freq);\n        float timeOffset = time - start * SPB;\n        // Increase vibrato over time\n        float vibrato = sin(time * freq * 0.8) * 1.6 * timeOffset;\n        // Layer a triangle and saw wave, makes a string-like sound\n        vec2 layers = tri(hertz, time, phase + vibrato) + saw(hertz * 2.0, time, vibrato - phase) * 0.3;\n        return layers * min(0.58, timeOffset * 32.0);\n    }\n    return vec2(0.0);\n}\n\n// Seems to reduce compilation time\nvec2 sawChord(float time, float start, float a, float b, float c, float d, float e) {\n    float end = start + 0.25;\n    vec2 result = timedSaw(a, time, start, end, 0.0);\n    result += timedSaw(b, time, start, end, 1.0);\n    result += timedSaw(c, time, start, end, 2.0);\n    result += timedSaw(d, time, start, end, 3.0);\n    result += timedSaw(e, time, start, end, 4.0);\n    return result;\n}\n\n// Seems to reduce compilation time\nvec2 lead(float time, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o) {\n    vec2 result = vec2(0.0);\n    // 3 chord repetition, optimized\n    if (time <= SPB * 1.5) {\n        float t = mod(time, SPB * 0.5);\n        result += sawChord(t, 0.0, a, b, c, d, e);\n    }\n    \n    // 2 chord repetition, don't know how to optimize\n    result += sawChord(time, 1.75, f, g, h, i, j);\n    result += sawChord(time, 2.25, f, g, h, i, j);\n    // Same chord\n    result += sawChord(time, 3.0, f, g, h, i, j);\n    \n    // Different chord\n    result += sawChord(time, 3.5, k, l, m, n, o);\n    return result;\n}\n\n// I wrote these notes in FL Studio, then wrote a MIDI to code conversion script\nvec2 bass1(float time) {\n    vec2 result = timedSaw(33.0, time, 0.0, 0.25, 0.0);\n    result += timedSaw(33.0, time, 0.5, 0.75, 1.0);\n    result += timedSaw(33.0, time, 1.0, 1.25, 2.0);\n    result += timedSaw(35.0, time, 1.75, 2.0, 3.0);\n    result += timedSaw(35.0, time, 2.25, 2.5, 4.0);\n    result += timedSaw(35.0, time, 3.0, 3.25, 5.0);\n    result += timedSaw(39.0, time, 3.5, 3.75, 6.0);\n    result += timedSaw(40.0, time, 4.0, 4.25, 7.0);\n    result += timedSaw(47.0, time, 4.5, 4.75, 8.0);\n    result += timedSaw(40.0, time, 5.0, 5.25, 9.0);\n    result += timedSaw(38.0, time, 5.75, 6.0, 10.0);\n    result += timedSaw(40.0, time, 6.25, 6.5, 11.0);\n    result += timedSaw(33.0, time, 7.0, 7.25, 12.0);\n    result += timedSaw(35.0, time, 7.5, 7.75, 13.0);\n    result += timedSaw(33.0, time, 8.0, 8.25, 14.0);\n    result += timedSaw(33.0, time, 8.5, 8.75, 15.0);\n    result += timedSaw(33.0, time, 9.0, 9.25, 16.0);\n    result += timedSaw(35.0, time, 9.75, 10.0, 17.0);\n    result += timedSaw(35.0, time, 10.25, 10.5, 18.0);\n    result += timedSaw(35.0, time, 11.0, 11.25, 19.0);\n    result += timedSaw(36.0, time, 11.5, 11.75, 20.0);\n    result += timedSaw(37.0, time, 12.0, 12.25, 21.0);\n    result += timedSaw(44.0, time, 12.5, 12.75, 22.0);\n    result += timedSaw(37.0, time, 13.0, 13.25, 23.0);\n    result += timedSaw(40.0, time, 13.75, 14.0, 24.0);\n    result += timedSaw(42.0, time, 14.25, 14.5, 25.0);\n    result += timedSaw(35.0, time, 15.0, 15.25, 26.0);\n    result += timedSaw(42.0, time, 15.5, 15.75, 27.0);\n    return result;\n}\n\nvec2 bass2(float time) {\n    vec2 result = timedSaw(33.0, time, 0.0, 0.25, 0.0);\n    result += timedSaw(33.0, time, 0.5, 0.75, 1.0);\n    result += timedSaw(33.0, time, 1.0, 1.25, 2.0);\n    result += timedSaw(35.0, time, 1.75, 2.0, 3.0);\n    result += timedSaw(35.0, time, 2.25, 2.5, 4.0);\n    result += timedSaw(42.0, time, 2.75, 3.0, 5.0);\n    result += timedSaw(35.0, time, 3.0, 3.25, 6.0);\n    result += timedSaw(39.0, time, 3.5, 3.75, 7.0);\n    result += timedSaw(40.0, time, 4.0, 4.25, 8.0);\n    result += timedSaw(47.0, time, 4.5, 4.75, 9.0);\n    result += timedSaw(52.0, time, 5.0, 5.25, 10.0);\n    result += timedSaw(38.0, time, 5.75, 6.0, 11.0);\n    result += timedSaw(45.0, time, 6.25, 6.5, 12.0);\n    result += timedSaw(38.0, time, 6.75, 7.0, 13.0);\n    result += timedSaw(42.0, time, 7.25, 7.5, 14.0);\n    result += timedSaw(35.0, time, 7.5, 7.75, 15.0);\n    result += timedSaw(33.0, time, 8.0, 8.25, 16.0);\n    result += timedSaw(40.0, time, 8.5, 8.75, 17.0);\n    result += timedSaw(45.0, time, 9.0, 9.25, 18.0);\n    result += timedSaw(40.0, time, 9.75, 10.0, 19.0);\n    result += timedSaw(35.0, time, 10.25, 10.5, 20.0);\n    result += timedSaw(35.0, time, 11.0, 11.25, 21.0);\n    result += timedSaw(37.0, time, 11.5, 11.75, 22.0);\n    result += timedSaw(37.0, time, 12.0, 12.25, 23.0);\n    result += timedSaw(44.0, time, 12.5, 12.75, 24.0);\n    result += timedSaw(49.0, time, 13.0, 13.25, 25.0);\n    result += timedSaw(40.0, time, 13.75, 14.0, 26.0);\n    result += timedSaw(42.0, time, 14.25, 14.5, 27.0);\n    result += timedSaw(37.0, time, 14.75, 15.0, 28.0);\n    result += timedSaw(35.0, time, 15.0, 15.25, 29.0);\n    result += timedSaw(37.0, time, 15.5, 15.75, 30.0);\n    return result;\n}\n\nvec2 voice1(float time) {\n    return timedTri(76.0, time, 1.75, 2.0, 0.0) + timedTri(76.0, time, 2.25, 3.25, 1.0);\n}\n\nvec2 voice2(float time) {\n    vec2 result = timedTri(79.0, time, 0.0, 0.3, 0.0);\n    result += timedTri(79.0, time, 0.5, 0.6, 1.0);\n    result += timedTri(79.0, time, 1.0, 1.3, 2.0);\n    result += timedTri(76.0, time, 1.5, 1.75, 3.0);\n    result += timedTri(79.0, time, 1.75, 2.0, 4.0);\n    result += timedTri(78.0, time, 2.25, 3.0, 5.0);\n    result += timedTri(76.0, time, 3.0, 4.0, 6.0);\n    result += timedTri(79.0, time, 4.0, 4.2, 7.0);\n    result += timedTri(79.0, time, 4.5, 4.7, 8.0);\n    result += timedTri(79.0, time, 5.0, 5.3, 9.0);\n    result += timedTri(76.0, time, 5.5, 5.75, 10.0);\n    result += timedTri(78.0, time, 5.75, 6.0, 11.0);\n    result += timedTri(78.0, time, 6.25, 8.0, 12.0);\n    result += timedTri(79.0, time, 8.0, 8.3, 13.0);\n    result += timedTri(79.0, time, 8.5, 8.7, 14.0);\n    result += timedTri(79.0, time, 9.0, 9.3, 15.0);\n    result += timedTri(76.0, time, 9.5, 9.75, 16.0);\n    result += timedTri(79.0, time, 9.75, 10.0, 17.0);\n    result += timedTri(78.0, time, 10.25, 11.0, 18.0);\n    result += timedTri(76.0, time, 11.0, 11.5, 19.0);\n    result += timedTri(76.0, time, 11.75, 12.0, 20.0);\n    result += timedTri(83.0, time, 12.25, 12.5, 21.0);\n    result += timedTri(83.0, time, 12.75, 13.25, 22.0);\n    result += timedTri(81.0, time, 13.25, 13.75, 23.0);\n    result += timedTri(80.0, time, 13.75, 14.25, 24.0);\n    result += timedTri(78.0, time, 14.25, 14.75, 25.0);\n    result += timedTri(80.0, time, 14.75, 15.25, 26.0);\n    result += timedTri(76.0, time, 15.25, 16.0, 27.0);\n    return result;\n}\n\nvec2 voice3(float time) {\n    vec2 result = timedTri(76.0, time, 0.75, 0.95, 0.0);\n    result += timedTri(76.0, time, 1.0, 1.125, 1.0);\n    result += timedTri(76.0, time, 1.25, 1.45, 2.0);\n    result += timedTri(76.0, time, 1.5, 1.625, 3.0);\n    result += timedTri(76.0, time, 1.75, 1.95, 4.0);\n    result += timedTri(91.0, time, 2.0, 2.75, 5.0);\n    result += timedTri(88.0, time, 2.75, 3.5, 6.0);\n    result += timedTri(86.0, time, 3.725, 4.0, 7.0);\n    result += timedTri(88.0, time, 4.0, 5.5, 8.0);\n    result += timedTri(76.0, time, 5.5, 5.6, 9.0);\n    result += timedTri(76.0, time, 5.725, 6.0, 10.0);\n    result += timedTri(76.0, time, 6.0, 6.2, 11.0);\n    return result;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\n// Sliding pitch sine wave, used for bass drop and kick\nfloat drop(float time, float df, float dftime, float freq) {\n    return sin(TAU * (freq * time - df * dftime * exp(-time / dftime)));\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    float body = drop(time, 512.0, 0.01, 60.0) * smoothstep(0.3, 0.0, time) * 2.0;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body + click * 2.0;\n}\n\n// From https://www.shadertoy.com/view/NddSzl\nvec2 snare(float time) {\n    vec2 snoise = stereoNoise(time) + coloredNoise(time, 600.0, 1000.0);\n    float nenv = (exp(-5.0 * time) + exp(-30.0 * time)) * smoothstep(0.2, 0.0, time) * 0.3;\n    const float speed = 20.0;\n    float phase = TAU * 180.0 * time + TAU * 80.0 / speed * (1.0 - exp(-time * speed));\n    float body = sin(phase) * smoothstep(0.0, 0.005, time) * smoothstep(0.05, 0.0, time);\n    return snoise * nenv + body * 3.8;\n}\n\n// Exponential sidechain curve\nfloat sidechain(float time, float speed) {\n    return 1.0 - exp(time * -speed);\n}\n\n// For visualisation\nstruct Song {\n    vec2 drums;\n    vec2 bass;\n    vec2 lead;\n    vec2 voice;\n    float sidechain;\n};\n\nSong getSong(float time) {\n\n    Song song;\n    song.drums = song.bass = song.voice = song.lead = vec2(0.0);\n    \n    // Initial echos on lead synth\n    int leadEchos = 4;\n    // Sidechain factor (0-1)\n    song.sidechain = 1.0;\n    // Temporary variable for sidechain\n    float t = 0.0;\n    \n    if (time >= SPB * 15.2) {\n        // Snare 1\n        t = mod(time - SPB * 3.2, SPB * 4.0);\n        song.drums += snare(t);\n        song.sidechain *= sidechain(t, 6.0);\n        // Bass drop\n        if (time < SPB * 16.0) {\n            song.bass += clamp(drop(t, 70.0, 0.2, 40.0) * 5.0, -0.7, 0.7) * song.sidechain;\n        }\n    }\n    \n    // Drum fill, surrounds snare 1\n    t = mod(time, SPB * 16.0) - SPB * 14.7;\n    if (t > 0.0) {\n        song.drums += kick(t) * 0.45;\n        song.sidechain *= sidechain(t, 8.0);\n        t -= SPB * 0.34;\n        if (t > 0.0) {\n            song.drums += kick(t) * 0.5;\n            song.sidechain *= sidechain(t, 8.0);\n        }\n        t -= SPB * 0.5;\n        if (t > 0.0) {\n            song.drums += kick(t) * 0.55;\n            song.sidechain *= sidechain(t, 8.0);\n        }\n    }\n    \n    if (time >= SPB * 16.0) {\n        // Add more delay after the intro\n        leadEchos = 7;\n        \n        // Kick\n        t = mod(time, SPB * 4.0);\n        song.drums += kick(t) * 0.7;\n        song.sidechain *= sidechain(t, 5.0);\n\n        // Snare 2\n        t = mod(time - SPB * 1.2, SPB * 4.0);\n        song.drums += snare(t);\n        song.sidechain *= sidechain(t, 6.0);\n\n        // Bass\n        for (int i = 0; i <= 2; i++) {\n            // Linear delay, repeats every 0.05 seconds\n            float delay = float(i) * 0.05;\n            // Fade echo volume linearly (1 to 0)\n            float fade = 1.0 - float(i) / 3.0;\n            // Ping-pong panning, pans each echo left then right\n            vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 0 ? vec2(1.0, 0.5) : vec2(0.5, 1.0));\n            song.bass += bass1(mod(time - SPB * 16.0, SPB * 32.0) - delay) * song.sidechain * 0.65 * fade * pan;\n            song.bass += bass2(mod(time, SPB * 32.0) - delay) * song.sidechain * 0.65 * fade * pan;\n        }\n    }\n    \n    // Wiggle volume a bit to add variety\n    float tremolo = 1.0 - sin(time / SPB * TAU) * 0.1;\n    \n    // Lead voices\n    for (int i = 0; i <= 2; i++) {\n        // Linear delay\n        float delay = float(i) * 0.13;\n        // Fade echo volume linearly (1 to 0)\n        float fade = 1.0 - float(i) / 3.0;\n        // Ping-pong panning, pans each echo right then left\n        vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 1 ? vec2(1.0, 0.0) : vec2(0.0, 1.0));\n        // RIP compilation time\n        if (time >= SPB * 16.0) {\n            if (mod(time - SPB * 16.0, SPB * 48.0) >= SPB * 32.0) {\n                song.voice += voice3(mod(time, SPB * 8.0) - delay) * fade * pan * song.sidechain * tremolo;\n            } else {\n                song.voice += voice2(mod(time, SPB * 16.0) - delay) * fade * pan * song.sidechain * tremolo;\n            }\n        } else if (time >= SPB * 8.0) {\n            song.voice += voice1(mod(time, SPB * 4.0) - delay) * fade * pan * song.sidechain * tremolo;\n        }\n    }\n    \n    // Cut lead delay every few bars for variety\n    if (time >= SPB * 64.0 && mod(time, SPB * 64.0) < SPB * 32.0) leadEchos = 0;\n    \n    // Lead synths\n    for (int i = 0; i <= leadEchos; i++) {\n        // Exponential delay, seems to reduce phase weirdness\n        float delay = (exp(float(i) * 0.1) - 1.0) * 0.5;\n        // Fade echo volume linearly (1 to 0)\n        float fade = 1.0 - float(i) / float(leadEchos + 1);\n        // Ping-pong panning, pans each echo left then right\n        vec2 pan = i <= 0 ? vec2(1.0) : (i % 2 == 0 ? vec2(1.0, 0.4) : vec2(0.4, 1.0));\n        \n        // First bar\n        song.lead += lead(mod(time, SPB * 8.0) - delay,\n            45.0, 52.0, 60.0, 64.0, 67.0,\n            47.0, 54.0, 57.0, 62.0, 66.0,\n            47.0, 55.0, 57.0, 62.0, 66.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n        \n        // Repeats after first bar (1st time)\n        song.lead += lead(mod(time - SPB * 4.0, SPB * 16.0) - delay,\n            52.0, 59.0, 59.0, 64.0, 67.0,\n            52.0, 57.0, 57.0, 62.0, 66.0,\n            52.0, 57.0, 57.0, 62.0, 66.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n        \n        // Repeats after first bar (2nd time)\n        song.lead += lead(mod(time - SPB * 12.0, SPB * 16.0) - delay,\n            49.0, 56.0, 59.0, 64.0, 68.0,\n            49.0, 56.0, 56.0, 59.0, 64.0,\n            49.0, 56.0, 57.0, 59.0, 64.0\n        ) * song.sidechain * 0.2 * fade * pan * tremolo;\n    }\n    \n    // Hats, first panned right, second panned left\n    song.drums += noiseHit(mod(time, SPB * 0.5), 36.0) * 0.45 * vec2(0.6, 1.0);\n    song.drums += noiseHit(mod(time - SPB / 6.0, SPB * 0.5), 36.0) * 0.49 * vec2(1.0, 0.6);\n    \n    // More hats, adds more high end\n    if (time > SPB * 32.75) {\n        float offset = time + SPB * 0.25;\n        t = mod(offset, SPB);\n        vec2 hat = vec2(coloredNoise(t, 13000.0, 6000.0), coloredNoise(t, 13000.0, 6200.0));\n        // Ping-pong panning, pans left then right\n        vec2 pan = mod(offset, SPB * 2.0) >= SPB ? vec2(1.0, 0.3) : vec2(0.3, 1.0);\n        song.drums += hat * exp(-5.0 * t) * pan * song.sidechain * 0.5;\n    }\n    \n    const float freq = 16000.0;\n    const float bandwidth = 10000.0;\n    \n    // Riser\n    if (time < SPB * 16.0) {\n        song.drums += coloredNoise(time, freq, bandwidth) * exp(0.8 * (time - SPB * 16.0)) * song.sidechain * 0.35;\n    }\n    // Faller\n    if (time > SPB * 16.0) {\n        song.drums += coloredNoise(time, freq, bandwidth) * exp(SPB * 16.0 - time) * song.sidechain * 0.3;\n    }\n    \n    return song;\n}", "sound_code": "vec2 mainSound(int samp, float time) {\n    Song song = getSong(time);\n    return 0.75 * (song.drums + song.bass + song.lead + song.voice);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 241], [243, 243, 298, 298, 1176]], "test": "untested"}
{"id": "mtXXWN", "name": "Crossing ribbon", "author": "Karp", "description": "4 fun but need to add AA later", "tags": ["2d", "ribbon", "cross"], "likes": 6, "viewed": 178, "published": 3, "date": "1674812395", "time_retrieved": "2024-07-30T18:13:32.222444", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameter\n    float scale = 3.;\n    float time = 1.5 * 1./scale * iTime;\n    vec3 bgColor = vec3(0.33);\n    \n    vec3 ribbonAcolor = Color255(157,39,242);\n    ribbonAcolor = HueShiftcolor(ribbonAcolor,.05 * iTime);\n    vec3 ribbonBcolor = Color255(255,242,39);\n    ribbonBcolor = HueShiftcolor(ribbonBcolor,.05 * iTime);\n    float ribbonThickness = (.6)/2.;\n    \n    vec3 shadowColor = vec3(.15);\n    float shadowStrength = .25;\n    float shadowOffset = .15;\n\n    // UV manipulation\n    vec2 uv = scale * AspectRatioUV(fragCoord.xy, iResolution.xy);\n    uv = RotateUV(uv, 45.);\n    vec2 uvA = vec2(fract(uv.x), uv.y);\n    vec2 uvB = vec2(uv.x, fract(uv.y));\n    \n    //Visu\n    vec3 pix = bgColor;\n    \n    vec2 lineGrid = step(mod(uv,2.), vec2(1.));\n    float checkboard = mod(lineGrid.x + lineGrid.y, 2.0);\n    \n    float stripA = step(distance(uvA.x,.5),ribbonThickness);\n    stripA *= step(uvA.y, ceil(-uv.x) + 2.25 * scale * sin(time));\n    float stripAshadow = step(distance(uvA.x - shadowOffset,.5),ribbonThickness);\n    stripAshadow *= step(uvA.y, ceil(-uv.x) +  2.25 * scale * sin(time) - shadowOffset);\n    stripAshadow = clamp01(stripAshadow - stripA);\n    \n    float stripB = step(distance(uvB.y,.5), ribbonThickness);\n    stripB *= step(uvB.x, ceil(-uv.y) +  2.25 * scale * sin(time));\n    float stripBshadow = step(distance(uvB.y + shadowOffset,.5), ribbonThickness);\n    stripBshadow *= step(uvB.x, ceil(-uv.y) +  2.25 * scale * sin(time) - shadowOffset);\n    stripBshadow = clamp01(stripBshadow - stripB);\n    \n    float crossRibbon = (stripA + stripAshadow + stripB + stripBshadow)-1.;\n    \n    vec3 preRibbonB = mix(pix, ribbonBcolor, stripB);\n    vec3 ribbonA = mix(preRibbonB, ribbonAcolor, stripA);\n    ribbonA = mix(ribbonA, shadowColor, stripAshadow * shadowStrength);\n    vec3 ribbonB = mix(ribbonA, ribbonBcolor, stripB);\n    ribbonB = mix(ribbonB, shadowColor, stripBshadow * shadowStrength);\n    \n    pix = mix(ribbonB, ribbonA, crossRibbon * checkboard);\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "//Constant\n#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//Color\n#define black   vec3(0.0)\n#define grey    vec3(0.5)\n#define white   vec3(1.0)\n//\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n//Maths\nfloat clamp01(float value) {return clamp(value,0.0,1.0);}\nfloat saturate(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n///UV (TextCoord)\nvec2 CenterUV(vec2 fragCoord, vec2 resolution)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5 * resolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 FullScreenUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n    uv = 2.0 * uv.xy / resolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}\n\n///COLOR\nvec3 Color255(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\nvec4 Color255(int R, int G, int B, int A)\n{\n    return vec4(Color255(R,G,B), 255);\n}\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 HSV2RGB(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 RGB2HSV(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\nvec3 HueShiftcolor(vec3 c, float shift)\n{\n    c = RGB2HSV(c);\n    c = vec3(mod(c.x + shift,1.), c.yz);\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 2082]], "test": "untested"}
{"id": "mlsXDN", "name": "Shortest Truchet circle (145 ch)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "tiling", "2tweets", "short", "golf"], "likes": 17, "viewed": 347, "published": 3, "date": "1674810715", "time_retrieved": "2024-07-30T18:13:33.107079", "image_code": "// see more readable version below\n\n\n// --- -16 by Xor\n\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    O = iResolution.xxxx/18.;\n    U *= sign( cos(ceil(U /= O.x) * ceil(U.y)) );   // random flip of tile coords  \n    O *= .06 - abs( length(min( U = fract(U), 1.-U.yx)) - .5 ) *.6;\n}\n\n\n\n\n\n\n/** // --- 161 chars\n// new version adapted from Shane https://www.shadertoy.com/view/ls33DN\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    vec3 R = iResolution;\n    U.x *= sign( cos(length(ceil(U *= 18./R.x ))*99.) );   // random flip of tile coords  \n    O = ( .1 - abs( min(length(U = fract(U)), length(--U)) - .5 )  ) *R.xxxx/25.; // draw 2 arcs in tile\n}\n\n\n\n\n\n\n/** // 183 chars \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          U = 18. * u / R.x,                               // normalized coordinates\n          F = fract(                                       // local tile coords\n                 fract(1e4*sin(dot(ceil(U),R-17.))) > .5   // random PI/2 rotation per tile   \n                     ? vec2(-U.y,U) : U );\n    O = ( .1 - abs( length(  F.x+F.y > 1. ? 1.-F : F ) -.5 )  ) * R.xxxx/25.; // draw arcs\n // O.b = mod(ceil(U).x+ceil(U).y,2.);                     // show tiling\n}\n\n\n\n\n\n\n/** // 196 chars \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          U = 9. * ( u+u - R ) / R.x,                      // normalized coordinates\n          F = fract(U) -.5;                                // local tile coords\n    fract(1e4*sin(dot(ceil(U),R-17.))) > .5                // random PI/2 rotation     \n          ? F = vec2(-F.y,F) : F;\n    O = ( .1 - abs( length(  F.y > -F.x ? .5-F : .5+F ) -.5 )  ) * R.xxxx/25.; // draw arcs\n // O.b = mod(ceil(U).x+ceil(U).y,2.);                     // show tiling\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 93, 93, 282]], "test": "untested"}
{"id": "dllSW4", "name": "The Infinite Tunnel", "author": "zero_ou", "description": "A simple shader experimenting with some of the ideas from the first four episodes of The Art of Code's Shadertoy Tutorial YouTube series.", "tags": ["2d", "simple", "tutorial", "beginner"], "likes": 0, "viewed": 177, "published": 3, "date": "1674791117", "time_retrieved": "2024-07-30T18:13:33.918908", "image_code": "// Following: https://youtu.be/u5HAYVHsasc\n// Shadertoy for absolute beginners tutorials\n\nvec3 circ(vec2 uv, vec2 pos, float r, float blend, vec3 c)\n{\n    uv -= pos;\n    float d = length(uv);\n    float mx = smoothstep(r, r-blend, d);\n    return mx * c;\n}\n\nfloat band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1*step2;\n}\n\nfloat rect(vec2 uv, vec2 p, float w, float h, float blur)\n{\n    uv -= p;\n    \n    float left = 0.0;\n    float right = w;\n    float bottom = 0.0;\n    float top = h;\n    \n    float lr_band = band(uv.x, left, right, blur);\n    float bt_band = band(uv.y, bottom, top, blur);\n    return lr_band * bt_band;\n}\n\nfloat rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    float lr_band = band(uv.x, left, right, blur);\n    float bt_band = band(uv.y, bottom, top, blur);\n    return lr_band * bt_band;\n}\n\nfloat remap01(vec2 r, float t)\n{\n    return (t - r.x) / (r.y - r.x);\n}\n\nfloat remap(vec2 r1, vec2 r2, float t) {\n    return remap01(r1, t) * (r2.y - r2.x) + r2.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // 0  <>  1.\n    \n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 col = vec3(0.0); \n    //col += circ(uv, vec2(0.5, 0.0), 0.2, 0.05, red);\n    \n    //col += circ(uv, vec2(-0.5, 0.0), 0.2, 0.05, red);\n    \n    \n    float x = uv.x;\n    //float m = (x - 0.5) * (x + 0.5);\n    //m = -m * m * 2.0;\n    float m = -0.5 * sin(2.0 * 3.14159 * (x + iTime));\n    float y = uv.y + m;\n    \n    //x -= y * 0.2;\n    vec2 rect_x = vec2(-2.0, 2.0);\n    float blur = remap(rect_x, vec2(0.01, 0.25), x);\n    blur = pow(blur * 4.6, 3.0);\n    \n    col += blue * rect(vec2(x, y), vec2(rect_x.x, -0.5), rect_x.y - rect_x.x, 1.0, blur);\n    col -= blue * rect(vec2(x, y), -0.5, 0.5, -0.1, 0.1, 0.01);\n    \n    float val = band(uv.x, -0.2, 0.2, 0.01)*band(uv.y, -0.2, 0.2, 0.01);\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 150, 150, 254], [256, 256, 313, 313, 457], [459, 459, 518, 518, 761], [763, 763, 846, 846, 980], [982, 982, 1014, 1014, 1052], [1054, 1054, 1094, 1094, 1146], [1148, 1148, 1205, 1255, 2256]], "test": "untested"}
{"id": "dtfSWN", "name": "Your Social Enigma", "author": "QuantumSuper", "description": "Use with music to see in full color.", "tags": ["music", "audioreactive"], "likes": 10, "viewed": 352, "published": 3, "date": "1674756545", "time_retrieved": "2024-07-30T18:13:35.033927", "image_code": "// Your Social Enigma 0.73.230126\n// by QuantumSuper\n// Use with music to see in full color.\n\n#define PI 3.14159265359 \n\nfloat animTime;\nvec4 fft;\n\nfloat sinRad2(float a, float r2){ //angle, radius squared\n    return r2*(1.+.25*fft.x*sin(8.*a+animTime));\n}\n\nfloat sinRing(float d2, float a, float r2, float w){ //distance squared, angle, radius squared, width factor\n    float r2Min = sinRad2(a,r2);\n    float r2Max = sinRad2(a,r2*w);\n    if ((d2>=r2Min-.001)&&(d2<=r2Max+.001)) return 1.;\n    return .001/abs(d2-r2Min)+0.001/abs(d2-r2Max);\n}\n\nfloat sinRing2(float d2, float a, float r2, float w){ //distance squared, angle, radius squared, width factor\n    return sinRing(d2,a,r2,w)+sinRing(d2,a+PI/8.,r2,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Initializations\n    vec3 col = vec3(0);\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n    animTime = 2.133333*iTime;\n    float a = atan(uv.x/uv.y); //polar angle (limited)\n    float d2 = uv.x*uv.x+uv.y*uv.y; //polar distance squared\n    float p,s,amp,pc;\n    fft.xyzw = vec4(0); //sound\n    \n    // Sound (see shadertoy.com/view/Xds3Rr, assume? sound texture with 48Khz/4 in 512 texels)\n    for (int n=0;n<12;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass\n    for (int n=12;n<48;n++) fft.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech\n    for (int n=48;n<192;n++) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence\n    for (int n=192;n<512;n++) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance\n    fft /= vec4(12,36,144,320); //normalize\n   \n    // Geometry\n    for (float n=0.;n<8.;n++){\n        p = .01*animTime+n*PI/4.; //phase\n        s = smoothstep(-.3,0.,-cos(p));\n        pc = a+p+animTime; //phase color\n        amp = (.9-.8*s)*sinRing2(d2,(-1.+2.*mod(n,2.))*a,.9*(1.+.999*sin(p)),1.+.5*s); //rings\n        col += amp*(.1+.9*fft.zyw)*vec3(sin(pc),sin(pc+PI/3.),sin(pc+2.*PI/3.)); //colors\n    }\n    \n    // Finalizations\n    col *= col; // negative correction & harder falloff\n    col += vec3(.001/abs(d2-.0015)*(.1+.9*fft.x)); //center eye\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0); //output\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 181, 205, 256], [258, 258, 310, 366, 542], [544, 544, 597, 653, 711], [713, 713, 769, 792, 2206]], "test": "untested"}
{"id": "mlsSWH", "name": "Visualizing Curl Noise", "author": "Shane", "description": "Yet another curl noise demonstration. This one focuses more on presentation than procedural fluid flow, etc, so I wouldn't take the physics component too seriously.", "tags": ["noise", "swirl", "fluid", "gradient", "curl", "warp", "bump", "flow", "vortex"], "likes": 111, "viewed": 2228, "published": 3, "date": "1674742938", "time_retrieved": "2024-07-30T18:13:36.033255", "image_code": "/*\n\n    Visualizing Curl Noise\n    ----------------------\n\n    This example consists of simple to apply procedural and aesthetic \n    lighting cliches. In particular, it's some bump mapped warped noise\n    with colored highlighing. The warp operation used is the curl of a\n    noise based function, and it's applied in feedback form.\n    \n    Field flow examples are not new to me, but I hadn't been motivated to\n    post one until seeing Leon's really nice \"Curling Smoke\" submission. \n    I cobbled together some old code for this example, but it was good to \n    have Leon's and a couple of Fabrice's examples to refer to. I liked \n    the way Leon used blue noise to slightly randomize the offset sample \n    length when bump mapping, so I \"borrowed\" that idea. :)\n    \n    If you're not familiar with a curl function, I tend to liken it to \n    a perpendicular gradient vector of sorts that directs the flow in \n    a direction perpendicular to the tangential motion, which results \n    in vortex swirls -- Intuitively, if an object or particle travels \n    along a curve and you apply a sideways force component, a spiralesque \n    traversal pattern will result. \n    \n    Domain warping is a pretty common graphics procedure and there are \n    too many examples on Shadertoy to count. The idea is to warp the \n    input coordinates in some way prior to passing them to a function. \n    The function can be whatever you want, like a simple 2D checker or \n    Truchet pattern, texture, or a 3D object. You can warp the \n    coordinates just once, or integrate them, which can be achieved via \n    multiple loop iterations, or in buffered feedback form. I'm using\n    the latter method here.\n    \n    In regard to appearance, I wanted to provide a flow example that \n    clearly demonstrated the swirly flow motion. I did that by applying\n    a heavy bump and some surface curvature shading -- By the way,\n    curvature is easy to apply and can really bring out a surface.\n    \n    I used a very basic aesthetic cliche for the lighting. There are three\n    lights, including a main directional white light, and two lesser\n    strength red and blue lights, which hit from opposing directions. If\n    you've watched a movie lately, then I'm sure you're familiar with it.\n    \n    Anyway, this is not meant to be a treatise on applying curl distortion \n    to noise, or using the curl vector in general, but hopefully, it'll \n    give someone a start. By the way, I have an old 3D curl example that\n    I intend to post at some stage.\n    \n    \n    Related examples:\n    \n    // Really fun to watch. The transcendental noise works nicely\n    // in Leon's example, but I'm not sure it would have with the\n    // setup I have here.\n    https://www.shadertoy.com/view/cl23Wt\n    \n    // Integrating uv coordinates to a noise flow texture. IQ has a\n    // heap of \"Iterations\" tagged shaders that are all worth looking at.\n    Texture flow III - iq\n    https://www.shadertoy.com/view/ldjXD3\n    \n    // Related vector field line example. Fabrice has a heap of\n    // flow related examples that are worth looking at.\n    vortex field (flow/magnetic) - FabriceNeyret2\n    https://www.shadertoy.com/view/lljczz\n\n \n*/\n\n\n// Pinkish purple highlights.\n//#define PINK\n\n\n/*\n// Smoother texture sample.\nvec3 tx2D5(vec2 p, float mL){\n    vec3 col = texture(iChannel0, p, mL).xyz;\n    vec3 e = vec3(1./iResolution.xy, 0);\n    col += (texture(iChannel0, p + e.xz).xyz + texture(iChannel0, p - e.xz).xyz +\n            texture(iChannel0, p + e.yz).xyz + texture(iChannel0, p - e.yz).xyz)*.7;\n    return col/3.8;\n\n}*/\n\n// Texture samples.\nvec3 tx2D(vec2 p){ return texture(iChannel0, p).xyz; }\n\n// Texture height.\nfloat getHeight(vec2 p){ return dot(tx2D(p), vec3(.299, .587, .114)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR;\n    \n    \n    // Texture samples.\n    vec3 col = tx2D(uv);\n    // Height value and offset sample for the colored lights.\n    float height = dot(col, vec3(.299, .587, .114));\n    float height2 = getHeight(uv - normalize(vec2(1, 2))*.001*vec2(iR.x/iR.y, 1));\n    \n\n    // High frequency blue noise sample offset that I took from Leons curl example.\n    vec3 nTx = texture(iChannel1, fragCoord/1024.).xyz;\n    vec2 e = vec2((pow(dot(nTx, vec3(.299, .587, .114)), 3.)*.5 + .5)*.007, 0);\n    //vec2 e = vec2(.0045, 0); // Constant sample distance.\n\n    // Taking four nearby offset samples to use for gradient and curvature calculations.\n    vec4 t4 = vec4(getHeight(uv - e.xy),  getHeight(uv + e.xy), \n               getHeight(uv - e.yx), getHeight(uv + e.yx));\n\n    // Using the samples above and some vector math to obtain the surface normal. \n    // I did it this way just to show that there were other possibilities.\n    //vec3 vx = vec3(e.x, 0, -t4.y) - vec3(-e.x, 0, -t4.x);\n    //vec3 vy = vec3(0, -e.x, -t4.z) - vec3(0, e.x, -t4.w);\n    vec3 vx = vec3(e.x*2., 0, t4.x - t4.y);\n    vec3 vy = vec3(0, -e.x*2., t4.w - t4.z);\n    vec3 sn = normalize(cross(vx, vy));\n    \n    // One line approximation to the above, if you prefer.\n    //vec3 sn = normalize(vec3(t4.x - t4.y, t4.z - t4.w, -height*e.x*2.)); \n    \n    // Using the four samples above to calculate the surface curvature.\n    float amp = .7;\n    float curv = clamp((height*4. - dot(t4, vec4(1)))/e.x/2.*amp + .5, 0., 1.);\n         \n     \n    // Directional light. \n    vec3 ld = normalize(vec3(-.5, 1, -1));\n    // Point light, if preferred.\n    //vec3 ld = normalize(vec3(.25, 1.25, -.5) - vec3(uv, 0));\n\n    // Directional derivative colored heighlight values.\n    float b = max(height2 - height, 0.)/.001;\n    float b2 = max(height - height2, 0.)/.001;\n    // Highlight colors.\n    vec3 hiCol = vec3(.02, .2, 1)*b*.8 + vec3(1, .2, .1)*b2*.3;\n\n    #ifdef PINK\n    // Pinkish purple lights.\n    col = mix(col.xzy, col, max(dot(sn, ld), 0.));\n    #endif\n    \n    // Specular light, if you wanted that.\n    /*\n    vec3 rd = normalize(vec3(uv, 1));\n    float spe = pow(max(dot(reflect(ld, sn), rd), 0.), 16.);\n    hiCol += spe*2.;\n    */\n\n    // Applying the directional light, colored highlights and a bit of \n    // ambient light to the surface.\n    col *= max(dot(sn, ld), 0.) + hiCol + .4;\n\n    // Applying the curvature.\n    col *= curv + .2; \n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Integrate more frames and increase the swirl length.\n//#define LONGER\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(27, 57, 111)));   \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n \n}\n\n/*\n// Hastily modified \"uint\" based hash function. It's a mixture of\n// IQ and Fabrice's versions. It should be more reliable, but I\n// haven't tested it for speed inside a raymarching loop, so I'll\n// leave the old function (above) in place for now.\n//\n// IQ's hash function here: https://www.shadertoy.com/view/XlXcW4 \n//\n// IQ's uvec3 to vec3 hash.\nvec3 hash33(vec3 f){\n\n    //const uint k = 1664525U; // Numerical Recipes.\n    const uint k = 20170906U; // Today's date -- Use three days ago's date if you want a prime.\n\n    uvec3 x = floatBitsToUint(f);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(2./float(0xffffffffU)) - 1.;\n}\n*/\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing -- I'll rewrite it at some stage. By the way, Stefan Gustavson has an account on\n// Shadertoy, if you feel like tracking that down.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p){\n\n    // Skewing the cubic grid, then determining the first vertex and fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)) );  p -= i - dot(i, vec3(1./6.));\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of \n    // the intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + 1./6., p2 = p - i2 + 1./3., p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertex points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n     \n    // Dotting the fractional position with a random vector, generated for each corner, in order to \n    // determine the weighted contribution distribution... Kind of. Just for the record, you can do a \n    // non-gradient, value version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), \n                  dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary.\n \n}\n\n\n// Layered noise function.\nfloat fBm(in vec3 p){\n    \n    // Rewriting the fBm function to lower compile times.\n    float n = 0., sum = 0., a = 1.;\n    vec3 offs = vec3(0, .23, .07);\n    for(int i = min(0, iFrame); i<3; i++){\n    \n        n += tetraNoise(p*exp2(float(i)) + offs.x)*a;\n        sum += a;\n        a *= .5;\n        offs = offs.yzx;\n    \n    }\n    \n    return n/sum;\n    \n    //return (tetraNoise(p)*4. + tetraNoise(p*2. + .23)*2. + tetraNoise(p*4. + .07))/7.;\n    //return (tetraNoise(p)*2. + tetraNoise(p*2. + .23)*1.)/3.;\n}\n \n \n// Flow function.\nfloat flow(vec3 p){\n\n   // Emulating moving toward the surface of a sphere, or landing on \n   // planet Cartoon Jupiter, if you prefer. :)\n \n   p.z -= dot(p, p)*.5; \n   p.xy *= rot2(iTime/16.);\n   #ifdef LONGER\n   // Longer swirl strands get too tight if you slice through\n   // Z too quickly, so it needs slowing down.\n   p.z += .1*iTime;\n   #else\n   p.z += .15*iTime;\n   #endif\n   \n   // You can put whatever function you want here, but simplex noise has nice\n   // animation qualities, so I've used that. At some stage, I'll try other \n   // things. By the way, if you have any suggestions, feel free to let me know.\n   return fBm(p*1.5);\n   \n   \n   /*\n   // Failed angular noise experiment.\n   p += vec3(.0, .0, .2)*iTime/3.;\n   return fBm(p*1.5*2.)*2. - 1.;\n   */\n  \n}\n\n \n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n   \n    // Coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR; // Window coordinates.      \n    vec2 uva = (fragCoord - iR/2.)/iR.y; // Centered, aspect correct coordinates.\n  \n    // Taking the curl of the flow function. Intuitively, the perpendicular\n    // vector to the tangent vector \"v\" is simply, \"vec2(v.y, -v.x)\", and the\n    // curl is analogous to the gradient equivalent, \"vec2(df/dy, -df/dx)\".\n    vec2 e = vec2(.005, 0);\n    vec3 p = vec3(uva, 0);//vec3(p, length(p)*.5);\n    float dx = (flow(p + e.xyy) - flow(p - e.xyy))/(2.*e.x);\n    float dy = (flow(p + e.yxy) - flow(p - e.yxy))/(2.*e.x);\n    vec2 curl = vec2(dy, -dx);\n     \n    // 3D curl. Not used here.\n    //float dz = (noise(p + e.yyx) - noise(p - e.yyx))/(2.*e.x);\n    //vec3 curl = vec3(dz - dy, dx - dz, dy - dx);\n \n/*\n    // Angular offsetting... Not right for this example.\n    vec2 e = vec2(.001, 0);\n    vec3 pos = vec3(p, 0);/\n    float a = (flow(pos))*6.2831*1.5;\n    vec2 curl = vec2(cos(a), -sin(a))*2.;\n*/\n      \n \n    // Update the field coordinates.\n    uv += curl*.006*vec2(iR.y/iR.x, 1); // Move to the new position.\n    \n    \n    // Buffer sample from the new position.\n    vec3 val = texture(iChannel0, uv).rgb;\n \n    \n    //col = texture(iChannel2, uv, 3.).xyz; col *= col;\n    //col = smoothstep(.0, .5, col);\n\n    // Create a transcental color pattern using the warped coordinates.\n    float snNs = dot(sin(uv*8. - cos(uv.yx*12.)), vec2(.25)) + .5;\n    vec3 col = .5 + .45*cos(6.2831*snNs/6. + vec3(0, 1.2, 2)*.8);\n    //vec3 col = mix(vec3(1, .8, .6).zyx, vec3(.6, .3, .2), snNs);\n   \n    // Color shading.\n    // Just the original function without the curl, which gives the\n    // impression of cast shadows.\n    col *= flow(p)*2. - .5;\n    // This is more correct, but I like the uncurled shading more.\n    //col *= flow(vec3(uv, 0))*2. - .5;\n    \n  \n    // Ridges -- Probably a little too much, but it'd be an interesting\n    // addition if you wanted to raymarch the surface.\n    //col *= abs(fract(col.x*16.) - .5)*2.*.04 + .96;\n     \n    \n    // Mix the curent warped color texture in with the previous one.\n    // Some people like to inject pixels from the sides and add those, but\n    // for this example, I'm performing a simple blend... However you mix\n    // frames is entirely up to you.\n    //\n    // More frames generally result in longer spirals. However, the speed at \n    // which we cut through the Z-planes (p.z += a*iTime), might need to \n    // be lowered.\n    #ifdef LONGER\n    const float nFrames = 32.;\n    #else\n    const float nFrames = 16.;\n    #endif\n    if(iFrame>0) col = mix(val, col, 1./nFrames);\n    \n  \n    fragColor = vec4(max(col, 0.), 1);\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3601, 3621, 3639, 3639, 3675], [3677, 3696, 3720, 3720, 3767], [3769, 3769, 3823, 3856, 6410]], "test": "untested"}
{"id": "dtlSWH", "name": "Audio Equalizer (Biquad Filter)", "author": "MysteryPancake", "description": "Shader version of RBJ's famous EQ cookbook. Looks like no one has done this yet!\nNo benefit from running on the GPU, just for fun.\nThis version doesn't consider parameter automation when calculating past samples, which may cause issues.", "tags": ["sound", "filter", "audio", "equalizer", "highpass", "eq", "notch", "gpusound", "lowpass", "equaliser", "biquad", "bandpass", "peaking"], "likes": 18, "viewed": 653, "published": 3, "date": "1674730416", "time_retrieved": "2024-07-30T18:13:36.821148", "image_code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\n// Linear scale to decibel scale\nfloat gainTodB(float gain) {\n    return 20.0 * log(gain) / log(10.0);\n}\n\n// Based on https://www.desmos.com/calculator/m1m7rhdpda\nfloat drawResponseCurve(BiquadFilter biquad, vec2 uv) {\n    \n    // X looks wonky, probably due to log scale\n    float x = sin(0.5 * uv.x * PI);\n    x *= x;\n\n    float a = biquad.b0 + biquad.b2;\n    float b = biquad.a0 + biquad.a2;\n    float c = (a + biquad.b1) / 2.0;\n    float d = (b + biquad.a1) / 2.0;\n    \n    float e = c * c - x * (4.0 * biquad.b0 * biquad.b2 * (1.0 - x) + biquad.b1 * a);\n    float f = d * d - x * (4.0 * biquad.a0 * biquad.a2 * (1.0 - x) + biquad.a1 * b);\n    float gain = sqrt(e / f);\n    \n    float volume = gainTodB(gain) * 0.05 + 0.5;\n    float line = 0.01 / abs(uv.y - volume);\n    \n    float under = step(uv.y, volume) * 0.25 + line;\n    \n    return under;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0) {\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    int samp = int(uv.x * 128.0) + iFrame;\n    \n    // Run biquad filter and get coefficients\n    BiquadFilter biquad = process(samp, iTime);\n    \n    // Draw original sample in red\n    float dryDist = abs(biquad.x1.x * 0.5 + 0.5 - uv.y);\n    vec3 col = vec3(0.5, 0.0, 0.0) * min(1.0, 0.005 / dryDist);\n    \n    // Draw processed sample in yellow\n    float wetDist = abs(biquad.y1.x * 0.5 + 0.5 - uv.y);\n    col += vec3(0.5, 0.5, 0.0) * min(1.0, 0.005 / wetDist);\n    \n    // Draw magnitude response curve\n    col += drawResponseCurve(biquad, uv);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time) {\n    return process(samp, time).y1;\n}", "sound_inputs": [], "common_code": "// Based on the famous \"Cookbook formulae for audio EQ biquad filter coefficients\"\n// Huge thanks to Robert Bristow-Johnson and Tom St Denis!\n\nconst float PI = 3.1415926;\n\n// Past samples determine future samples, the higher the better\nconst int PAST_SAMPLES = 128;\n\n// Filter types\nconst int LOW_PASS = 0;\nconst int HIGH_PASS = 1;\nconst int BAND_PASS = 2;\nconst int NOTCH = 3;\nconst int PEAKING = 4;\nconst int LOW_SHELF = 5;\nconst int HIGH_SHELF = 6;\n\nstruct BiquadFilter {\n    // Coefficients used for visualization\n    float a0, a1, a2, b0, b1, b2;\n    // Sample tracking variables\n\tvec2 x1, x2, y1, y2;\n};\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - 69.0) / 12.0);\n}\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash(float(si)), hash(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float Q) {\n    return sin(2.0 * PI * freq * fract(time)) * noise(time * Q);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    const float df = 512.0, dftime = 0.01, freq = 60.0;\n    float phase = PI * 2.0 * (freq * time - df * dftime * exp(-time / dftime));\n    float body = sin(phase) * smoothstep(0.3, 0.0, time) * 2.0;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body + click * 2.0;\n}\n\n// Saw wave defined in samples to reduce aliasing\nfloat waveSaw(float freq, int samp) {\n    return fract(freq * float(samp) / iSampleRate) * 2.0 - 1.0;\n}\n\n// Offset the right channel for better stereo width\nvec2 widerSaw(float freq, int samp) {\n    int offset = int(freq) * 64;\n    return vec2(waveSaw(freq, samp - offset), waveSaw(freq, samp + offset));\n}\n\n// Dry sample (no equalization)\nvec2 drySample(int samp) {\n\n    // Imprecise time for drums and noise, not ideal\n    float time = float(samp) / iSampleRate;\n\n    // Main saw chords\n    vec2 result = widerSaw(noteFreq(38.0), samp);\n    result += widerSaw(noteFreq(45.0), samp);\n    result += widerSaw(noteFreq(66.0), samp);\n    result += widerSaw(noteFreq(69.0), samp);\n    result += widerSaw(noteFreq(76.0), samp);\n    result += widerSaw(noteFreq(80.0), samp);\n    \n    // Treble noise\n    result.x += coloredNoise(time, 14000.0, 3000.0) * 0.75;\n    result.y += coloredNoise(time + 0.5, 14000.0, 3000.0) * 0.75;\n    \n    // Kick and sidechain\n    float sidechain = mod(time, 0.5);\n    result *= min(1.0, sidechain * 3.0);\n    result += kick(sidechain) * 2.0;\n    \n    return result * 0.1;\n}\n\n// Wet sample (with equalization)\nBiquadFilter wetSample(int samp, int filterType, float dbGain, float freq, float Q) {\n    \n    float A = pow(10.0, dbGain / 40.0);\n    float omega = 2.0 * PI * freq / iSampleRate;\n    float sn = sin(omega);\n    float cs = cos(omega);\n    // Using Q alpha to make it easier to visualize\n    float alpha = sn / (2.0 * Q);\n    float beta = sqrt(A + A);\n    \n    // From \"Simple implementation of Biquad filters\" by Tom St Denis\n    BiquadFilter biquad;\n    switch (filterType) {\n    case LOW_PASS:\n        biquad.b0 = (1.0 - cs) * 0.5;\n        biquad.b1 = 1.0 - cs;\n        biquad.b2 = (1.0 - cs) * 0.5;\n        biquad.a0 = 1.0 + alpha;\n        biquad.a1 = -2.0 * cs;\n        biquad.a2 = 1.0 - alpha;\n        break;\n    case HIGH_PASS:\n        biquad.b0 = (1.0 + cs) * 0.5;\n        biquad.b1 = -(1.0 + cs);\n        biquad.b2 = (1.0 + cs) * 0.5;\n        biquad.a0 = 1.0 + alpha;\n        biquad.a1 = -2.0 * cs;\n        biquad.a2 = 1.0 - alpha;\n        break;\n    case BAND_PASS:\n        biquad.b0 = alpha;\n        biquad.b1 = 0.0;\n        biquad.b2 = -alpha;\n        biquad.a0 = 1.0 + alpha;\n        biquad.a1 = -2.0 * cs;\n        biquad.a2 = 1.0 - alpha;\n        break;\n    case NOTCH:\n        biquad.b0 = 1.0;\n        biquad.b1 = -2.0 * cs;\n        biquad.b2 = 1.0;\n        biquad.a0 = 1.0 + alpha;\n        biquad.a1 = -2.0 * cs;\n        biquad.a2 = 1.0 - alpha;\n        break;\n    case PEAKING:\n        biquad.b0 = 1.0 + (alpha * A);\n        biquad.b1 = -2.0 * cs;\n        biquad.b2 = 1.0 - (alpha * A);\n        biquad.a0 = 1.0 + (alpha / A);\n        biquad.a1 = -2.0 * cs;\n        biquad.a2 = 1.0 - (alpha / A);\n        break;\n    case LOW_SHELF:\n        biquad.b0 = A * ((A + 1.0) - (A - 1.0) * cs + beta * sn);\n        biquad.b1 = 2.0 * A * ((A - 1.0) - (A + 1.0) * cs);\n        biquad.b2 = A * ((A + 1.0) - (A - 1.0) * cs - beta * sn);\n        biquad.a0 = (A + 1.0) + (A - 1.0) * cs + beta * sn;\n        biquad.a1 = -2.0 * ((A - 1.0) + (A + 1.0) * cs);\n        biquad.a2 = (A + 1.0) + (A - 1.0) * cs - beta * sn;\n        break;\n    case HIGH_SHELF:\n        biquad.b0 = A * ((A + 1.0) + (A - 1.0) * cs + beta * sn);\n        biquad.b1 = -2.0 * A * ((A - 1.0) + (A + 1.0) * cs);\n        biquad.b2 = A * ((A + 1.0) + (A - 1.0) * cs - beta * sn);\n        biquad.a0 = (A + 1.0) - (A - 1.0) * cs + beta * sn;\n        biquad.a1 = 2.0 * ((A - 1.0) - (A + 1.0) * cs);\n        biquad.a2 = (A + 1.0) - (A - 1.0) * cs - beta * sn;\n        break;\n    }\n\n    // Precompute coefficients\n    float c0 = biquad.b0 / biquad.a0;\n    float c1 = biquad.b1 / biquad.a0;\n    float c2 = biquad.b2 / biquad.a0;\n    float c3 = biquad.a1 / biquad.a0;\n    float c4 = biquad.a2 / biquad.a0;\n\n    // Zero initial samples\n    biquad.x1 = biquad.x2 = biquad.y1 = biquad.y2 = vec2(0.0);\n    \n    // Run equalizer based on past samples\n    for (int i = PAST_SAMPLES; i >= 0; i--) {\n        \n        // Calculate past sample\n        vec2 currentSample = drySample(samp - i);\n\n        // Apply the filter\n        vec2 result = c0 * currentSample + c1 * biquad.x1 + c2 * biquad.x2 - c3 * biquad.y1 - c4 * biquad.y2;\n\n        // Shift x1 to x2, sample to x1\n        biquad.x2 = biquad.x1;\n        biquad.x1 = currentSample;\n\n        // Shift y1 to y2, result to y1\n        biquad.y2 = biquad.y1;\n        biquad.y1 = result;\n    }\n    \n    // Return final sample and coefficients\n    return biquad;\n}\n\n// Main processing\nBiquadFilter process(int samp, float time) {\n\n    // Swap between all 7 filter types\n    int filterType = int(mod(time * 0.5, 7.0));\n    \n    // Modulate frequency over time\n    float range = iSampleRate * 0.25;\n    float freq = mod(time, 28.0) >= 14.0 ? 500.0 : cos(time * PI * 2.0) * range * 0.95 + range;\n    \n    // Modulate filter quality over time\n    float Q = 1.5 + cos(time * 3.0);\n    \n    // Set shelving filters to 6dB of gain (200% boost)\n    const float dbGain = 6.0;\n    \n    // Calculate and run filter\n    return wetSample(samp, filterType, dbGain, freq, Q);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 70, 70, 387], [389, 422, 450, 450, 493], [495, 552, 607, 660, 1241], [1243, 1243, 1298, 1298, 2064]], "test": "untested"}
{"id": "ctXSW4", "name": "4 Color Gradient - AMA", "author": "afterlifevj", "description": "4 Color Gradient", "tags": ["gradient"], "likes": 6, "viewed": 323, "published": 3, "date": "1674725650", "time_retrieved": "2024-07-30T18:13:37.641954", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // parameters\n\n    vec2 p[4];\n    p[0] = vec2(0.1, 0.9);\n    p[1] = vec2(0.9, 0.9);\n    p[2] = vec2(0.5, 0.1);\n    p[3] = vec2(cos(iTime), sin(iTime)) * 0.4 + vec2(0.5, 0.5);\n    \n    vec3 c[4];\n    c[0] = vec3(0.996078431372549, 0.3411764705882353, 0.33725490196078434);\n    c[1] = vec3(0.996078431372549, 0.6352941176470588, 0.1607843137254902);\n    c[2] = vec3(0.1450980392156863, 0.8196078431372549, 0.8588235294117647);\n    c[3] = vec3(1.0, 1.0, 0.0);\n\n    float blend = 2.0;\n    \n    // calc IDW (Inverse Distance Weight) interpolation\n    \n    float w[4];\n    vec3 sum = vec3(0.0);\n    float valence = 0.0;\n    for (int i = 0; i < 4; i++) {\n        float distance = length(uv - p[i]);\n        if (distance == 0.0) { distance = 1.0; }\n        float w =  1.0 / pow(distance, blend);\n        sum += w * c[i];\n        valence += w;\n    }\n    sum /= valence;\n    \n    // apply gamma 2.2 (Approx. of linear => sRGB conversion. To make perceptually linear gradient)\n\n    sum = pow(sum, vec3(1.0/2.2));\n    \n    // output\n    \n\tfragColor = vec4(sum.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1165]], "test": "untested"}
{"id": "dllXDH", "name": "Yellow Red Rotating Gradient", "author": "afterlifevj", "description": "Linear Gradient + Rotation", "tags": ["gradient"], "likes": 1, "viewed": 233, "published": 3, "date": "1674725162", "time_retrieved": "2024-07-30T18:13:38.413891", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 startColor = vec4(0.996078431372549, 0.3411764705882353, 0.33725490196078434, 1.0);\n    vec4 endColor = vec4(0.9450980392156862, 1.0, 0.3215686274509804, 1.0);\n    float currentAngle = -(iTime * 36.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 origin = vec2(0.5, 0.5);\n    uv -= origin;\n    \n    float angle = radians(90.0) - radians(currentAngle) + atan(uv.y, uv.x);\n\n    float len = length(uv);\n    uv = vec2(cos(angle) * len, sin(angle) * len) + origin;\n\t    \n    fragColor = mix(startColor, endColor, smoothstep(0.0, 1.0, uv.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 627]], "test": "untested"}
{"id": "dlsXWH", "name": "Never ending gradient scroll_alt", "author": "afterlifevj", "description": "A simple dual tone gradient shader that scrolls with time.adapted from Farious", "tags": ["gradient"], "likes": 0, "viewed": 158, "published": 3, "date": "1674719847", "time_retrieved": "2024-07-30T18:13:39.437154", "image_code": "\nvec4 colorLow = vec4(0.5333333333333333, 0.5019607843137255, 1.0, 0.);\nvec4 colorHigh = vec4(0.996078431372549, 0.6352941176470588, 0.1607843137254902, 0.);\nfloat spacingLow = 1.76;\nfloat spacingHigh = 2.;\n\nfloat gradient(float dir, float time, float spacing) {\n    float g = fract((dir + time * 0.1) * 3.);\n\tfloat left = step(0.5, g);\n    g = left * ((g - 0.5) * spacing) + (1. - left) * ((1. - g) - 0.5) * spacing;\n    return g;\n}\n\nvec4 dualTone(vec4 low, vec4 high, float gradient, float power) {\n    return mix(low, high, pow(gradient, power));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float gradient = gradient(uv.x, iTime, spacingHigh);\n    vec4 tone = dualTone(colorLow, colorHigh, gradient, spacingLow);\n    \n    // Output to screen\n    fragColor = tone;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 262, 262, 433], [435, 435, 500, 500, 551], [553, 553, 610, 660, 884]], "test": "untested"}
{"id": "ctlSD8", "name": "Volumetric Lighting V1", "author": "FifthStateOfMatter", "description": "Experimenting with volumetric fog.", "tags": ["3d"], "likes": 5, "viewed": 326, "published": 3, "date": "1674701358", "time_retrieved": "2024-07-30T18:13:40.408556", "image_code": "const vec3 densityCoefficient = vec3(0.02, 0.021, 0.023);\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return (fract(p.x + p.y)*2.0) - 1.0;\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return (mix(lerpBottomFront, lerpTopFront, frc.y) + 1.0)/2.0;\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise3(p*f)*h;\n    for(int i = 0; i < 2; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise3(rotate2D(p, vec2(0, r))*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat fbm2(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 8; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, float h, vec3 n){\n    return length((p - h)*n);\n}\n\nfloat spherePattern(vec3 p, vec3 c){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphere(q, 1.0);\n}\n\nfloat scene(vec3 p){\n    //return min(spherePattern(p - vec3(2, 0, 5), vec3(4, 0, 4)), plane(p, -1.0, vec3(0, 1, 0)));\n    //return min(sphere(p - vec3(0, 0, 5.0 + iTime), 1.0), plane(p, -1.0, vec3(0, 1, 0)));\n    return (plane(p, -1.0, vec3(0, 1, 0)) - fbm2(p*0.07)*5.0)*0.9;\n}\n\nfloat raymarch(vec3 o, vec3 d, out bool hit, int ms, float md){\n    float t = 0.0;\n    hit = false;\n    for(int i = 0; i < ms && t < md && !hit; i++){\n        float s = scene(o + d*t);\n        t += s;\n        if(abs(s) <= 0.001*t && t >= 0.0){\n            hit = true;\n        }\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    vec2 eps = vec2(0.01, 0);\n    return normalize(vec3(\n        scene(h + eps.xyy) - scene(h - eps.xyy),\n        scene(h + eps.yxy) - scene(h - eps.yxy),\n        scene(h + eps.yyx) - scene(h - eps.yyx)\n    ));\n}\n\nfloat G_SCATTERING = 2.0;\n\nfloat ComputeScattering(float lightDotView){\n    float result = 1.0 - G_SCATTERING*G_SCATTERING;\n    result /= (4.0*3.1415926535*pow(1.0 + G_SCATTERING*G_SCATTERING - (2.0*G_SCATTERING)*lightDotView, 1.5));\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float seed = iTime;\n    float hardness = 1.0;\n    vec3 outCol = vec3(0);\n    vec3 lPos = vec3(10, 10, -10.0 + iTime*3.0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 8, iTime*3.0);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(15.0), iTime*0.5)));\n    bool hit;\n    float density;\n    float t = raymarch(o, d, hit, 200, 200.0);\n    vec3 h = o + d*t;\n    if(!hit) t = 500.0;\n    for(int j = 0; j <= 0; j++){\n        seed += float(j);\n        //vec3 l = normalize(lPos - (h + vec3(random3(h*203824.42743 + seed*20834.842)*hardness, random3(h*334284.82372 + seed*22147.243)*hardness, random3(h*182037.28347 + seed*21382.428)*hardness)));\n        vec3 lRay = normalize(lPos - h);\n        vec3 l = -normalize(vec3(-10, -10, 10));\n        vec3 skycol = mix(vec3(0.9), vec3(1, 1, 0.9), smoothstep(0.0, 1.0, clamp(pow(dot(d, -lRay), 200000.0), 0.0, 1.0)));\n        //vec3 skycol = vec3(0.9);\n        vec3 col = skycol;\n        vec3 n = getNormal(h);\n        float ny = n.y - 0.25;\n        vec3 mat = mix(vec3(0.2, 0.15, 0.1), vec3(0.3, 0.5, 0.2), smoothstep(0.6, 0.7, ny));\n        float c = dot(n, l);\n        bool lhit;\n        float lt = raymarch(h + n*0.01, l, lhit, 30, 30.0);\n        lhit ? c *= 0.4 : c = dot(n, l);\n        vec3 testPos = o;\n        float cRayRes = 50.0;\n        float stepLength = t/cRayRes;\n        vec3 Step = d*stepLength;\n        density = 0.0;\n        for(int i = 0; i < int(cRayRes); i++){\n            testPos += Step;\n            //bool chit;\n            //float ct = raymarch(testPos + n*0.01, l, chit, 50, 50.0);\n            //if(!chit){\n                density += stepLength + fbm((testPos + vec3(0, -iTime*0.0, 0))*1.0)*2.0*stepLength;\n            //}else{\n                //density += (stepLength + fbm((testPos + vec3(0, -iTime*0.5, 0))*3.0)*stepLength + ComputeScattering(dot(d, l))*stepLength)*0.0;\n            //}\n        }\n        //density /= cRayRes;\n        if(hit){\n            col = mix(mat*clamp(c, 0.0, 1.0), vec3(0.9), vec3(1.0 - exp(-density*densityCoefficient)));\n        }else{\n            col = skycol;\n        }\n        //outCol = mix(outCol, col, 1.0/float(j + 1));\n        outCol = col;\n    }\n    fragColor = vec4(pow(outCol, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 89, 89, 496], [498, 532, 554, 554, 660], [662, 662, 684, 684, 783], [785, 785, 806, 806, 1640], [1642, 1642, 1663, 1663, 2095], [2097, 2097, 2115, 2115, 2383], [2385, 2385, 2404, 2404, 2678], [2680, 2680, 2710, 2710, 2738], [2740, 2740, 2777, 2777, 2809], [2811, 2811, 2847, 2847, 2916], [2918, 2918, 2938, 3127, 3196], [3198, 3198, 3261, 3261, 3497], [3499, 3499, 3522, 3522, 3735], [3764, 3764, 3808, 3808, 3991], [3993, 3993, 4047, 4047, 6299]], "test": "untested"}
{"id": "DtlXDH", "name": "Ranged Hue Shift 2.0", "author": "Valdex", "description": "ChatGPT: shader that modifies hue of an image with a brightness and time varying effect using a shader", "tags": ["imageprocessing", "hue", "brightness", "shift", "timevarying"], "likes": 2, "viewed": 192, "published": 3, "date": "1674693692", "time_retrieved": "2024-07-30T18:13:41.260279", "image_code": "vec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 editHue(sampler2D tex, vec2 uv, float hueStart, float hueEnd, float brightness,float shiftHue) {\n    vec4 color = texture(tex, uv);\n    vec3 hsv = rgb2hsv(color.rgb);\n    if (hsv.x >= hueStart && hsv.x <= hueEnd) {\n        hsv.x += shiftHue;\n        hsv.x = mod(hsv.x,1.0);\n        hsv.y *= brightness; // TO DO: fix\n        color.rgb = hsv2rgb(hsv);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float hueStart = 0.35;\n    float hueEnd = 0.55;\n    float brightness = 1.0;\n    float shiftHue = sin(iTime);\n    fragColor = editHue(iChannel0, uv, hueStart, hueEnd, brightness,shiftHue);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 352], [354, 354, 376, 376, 545], [547, 547, 648, 648, 928], [930, 930, 987, 987, 1226]], "test": "untested"}
{"id": "DtXXDr", "name": "round pixelate filter", "author": "ArmandB", "description": "it just works", "tags": ["2d", "pixelart"], "likes": 1, "viewed": 186, "published": 3, "date": "1674669881", "time_retrieved": "2024-07-30T18:13:42.157879", "image_code": "float pixelation = 7.0;\n\nvec2 pixelate(vec2 a, float k){\n    float p = pow(2.0,k);\n    return floor(a*p)/p;\n}\n\nvec4 pixelate(vec4 a, float k){\n    float p = pow(2.0,k);\n    return floor(a*p)/p;\n}\n\nvec4 getcol(vec2 p, vec2 o){\n    return pixelate(textureLod(iChannel0,p + o/pow(2.0,pixelation) + iTime*0.005,0.0),3.0);\n}\n\nvec4 mincol(vec4 a, vec4 b){\n    float A = (0.299*a.r + 0.587*a.g + 0.114*a.b);\n    float B = (0.299*b.r + 0.587*b.g + 0.114*b.b);\n    return A < B ? a : (B < A ? b : (a.r+a.g+a.b > b.r+b.g+b.b ? a : b));\n}\n\nvec4 mincol4(vec4 a, vec4 b, vec4 c, vec4 d){\n    return mincol(mincol(a,b),mincol(c,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y/2.0;\n    vec2 uvpx = pixelate(uv,pixelation);\n    float pxunit = 1.0/pow(2.0,pixelation);\n\n    vec4 c = getcol(uvpx,vec2(0,0));\n    vec4 c0 = getcol(uvpx,vec2(1,0));\n    vec4 c1 = getcol(uvpx,vec2(1,1));\n    vec4 c2 = getcol(uvpx,vec2(0,1));\n    vec4 c3 = getcol(uvpx,vec2(-1,1));\n    vec4 c4 = getcol(uvpx,vec2(-1,0));\n    vec4 c5 = getcol(uvpx,vec2(-1,-1));\n    vec4 c6 = getcol(uvpx,vec2(0,-1));\n    vec4 c7 = getcol(uvpx,vec2(1,-1));\n    bool u = c2 == c;\n    bool d = c6 == c;\n    bool l = c4 == c;\n    bool r = c0 == c;\n    \n    vec2 relcoord = uv - uvpx - pxunit/2.0;\n    float dist = length(relcoord);\n        \n    if (!(u || l) && relcoord.y > 0.0 && relcoord.x < 0.0 && dist > pxunit/2.0){\n        c = c2 == c4 ? c2 : (c == c3 ? c : mincol4(c,c2,c3,c4));\n    } else if (!(u || r) && relcoord.y > 0.0 && relcoord.x > 0.0 && dist > pxunit/2.0){\n        c = c == c1 ? c : (c2 == c0 ? c2 : mincol4(c,c0,c1,c2));\n    } else if (!(d || l) && relcoord.y < 0.0 && relcoord.x < 0.0 && dist > pxunit/2.0){\n        c = c == c5 ? c : (c6 == c4 ? c6 : mincol4(c,c4,c5,c6));\n    } else if (!(d || r) && relcoord.y < 0.0 && relcoord.x > 0.0 && dist > pxunit/2.0){\n        c = c6 == c0 ? c6 : (c == c7 ? c : mincol4(c,c0,c6,c7));\n    }\n    \n    fragColor = c;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 56, 56, 109], [111, 111, 142, 142, 195], [197, 197, 225, 225, 319], [321, 321, 349, 349, 527], [529, 529, 574, 574, 620], [622, 622, 679, 679, 1973]], "test": "untested"}
{"id": "mtfXD8", "name": "French Pharmacy", "author": "rcargou", "description": "Hi", "tags": ["sdf", "cross", "french", "pharmacy"], "likes": 18, "viewed": 523, "published": 3, "date": "1674660338", "time_retrieved": "2024-07-30T18:13:43.104349", "image_code": "\nvec3 k_cross = vec3(0., .9, 0.0)*3.;\nvec3 k_screen = vec3(0.01, 0.015, 0.01);\nvec3 k_light1 = vec3(.7, 0.2, 0.3);\nvec3 k_light2 = vec3(0.3, 0.2, .7);\n//------------------------------------------------------------------\n\n//------------------------------------------------------------------\n\nvec2 getPhase() {\n   // return vec2( 3., 0. );\n    return vec2( floor( mod(iTime / 20., 4.) ),  floor( mod(iTime / 5., 2.)) );\n}\n\nfloat sdCross(vec3 p, vec2 s) {\n        vec3 dim = vec3(1.5,\n                     .6,\n                     .33123405437896355);\n                \n    vec3 dim2 = dim * vec3(1.1 + s.x , 1. + s.y + .3, dim.z);\n    \n    float s1 = sdBox(p, dim.xyz );\n    float s2 = sdBox(p, dim.yxz );\n    \n    float core_cross = opU(vec2(s1), vec2(s2)).x;\n    \n    s1 = sdBox(p, vec3( dim2.xy, dim.z * 1.1) );\n    s2 = sdBox(p, vec3( dim2.yx, dim.z * 1.1) );\n    \n    float core_anticross = opU(vec2(s1), vec2(s2)).x;\n    \n    float ret = opS(core_cross, core_anticross);\n    return ret;\n}\n\nfloat mapSphericalPill(vec3 p, out vec3 id) {\n\n\n    p.y +=1.2;\n    p.xy -= vec2(-0.2, 1.) * pow(abs( sin(iTime * 6.)), 9.) / 4.;\n    p.z -= 4.;\n    p *= rotateZ(sin( iTime  * 15.) / 2. );\n//    p *= rotateX(sin( iTime  * 15.) / 20. );\n    \n    vec3 s = vec3(1., 5., .5) * 1.2;\n    float size = .5;\n    id.x = 5.;\n    id.y = smoothstep( .7, .06, abs(p.x));\n\n    return length(p * s) - size;\n}\n\nfloat mapPill(vec3 p, out vec3 id, float in_id) {\n    p.z-=3.;\n    id.x = 1.;\n    p *= rotateZ(iTime * 10. + in_id * 21.4);\n   // p *= rotateY(iTime * 12.+ in_id * 2111.4);\n    \n    float s = sdCapsule( p, vec3(-.1, .0, 0.),vec3(.1, 0., 0.) , .09);\n    id.y = step(p.x, 0.) * in_id;\n    \n    return s;\n}\n\nfloat mapPillField(vec3 p, out vec3 id) {\n    vec3 o = vec3(.0, .0, 10.);\n    float speed = 20.;\n    vec3 tmp_id;\n  \n    if(length(p.xy) > 5.5)\n        return 1e10;\n  \n    float rep = 2.;\n    \n    vec2 u = floor(p.xy / rep);\n    float i =  hash11( u.x * fract( sin(u.x+u.y)));\n    \n    p.xy = mod(p.xy, rep) - vec2(rep / 2.);\n    float offset = i * 14.;\n    p.z -= 15. - iTime * 30.;\n    p.z = mod(p.z, 25.) - 12.5;\n    p.z+=offset;\n    float d = mapPill(p / 2., id, i );\n    return d;\n}\n\nvec3 path(float time, float z) {\n    if (getPhase().x != 0.) \n        return vec3(0.);\n    vec3 p = vec3(0.);\n    float t = length(z - 1.);\n\n    p.y += sin(t / 20.) * 2. * pow( sin(iTime * .8), 2.);\n    p.x += sin(t /20.) * 2. * pow( sin(1.+iTime * .8), 2.);\n\n    \n    //p.y -= sin(t / 10.) * 2. * pow( cos(iTime), 7.);\n   // p.x -= sin(t / 10.) * 2. * pow( cos(iTime), 3.);\n    //p*=2.;\n    return vec3(p);\n}\n\nfloat sdLights(vec3 p, out vec3 id, out float dlight2) {\n    p += path(iTime, p.z);\n    p.z-=15.;\n    float s = .3;\n    float rotSpeed = 5.;\n    float rotAmp = 5.;\n    vec3 p1 = p, p2 = p;\n    \n    p1.x += sin(iTime * rotSpeed) * rotAmp;\n    p1.z += cos(iTime * rotSpeed) * rotAmp;\n    \n    p2.z += sin(iTime * rotSpeed + .57) * rotAmp * 1.;\n    p2.x += 1.1*cos(iTime * rotSpeed + .57) * rotAmp;\n    \n    float d1 = length(p1) - s;\n    d1 = sdCross(p1 * 1.2, vec2(-.1, -0.5));\n    float d2 = length(p2) - s;\n    d2 = sdCross(p2 * 1.2, vec2(-.1, -0.5));\n\n    id.x = 4.;\n    id.y = step(d1, d2);\n    dlight2 = max(d1,d2);\n    return min(d1, d2);\n}\n\nfloat sdCross2D(vec2 uv, float s) {\n    \n    if (getPhase().x != 2.)\n        s = 1.;\n\n    vec4 dim = vec4(0.85, 0.3, 0.2, 0.1) * s;\n    vec4 dim_inside = vec4(0.85, 0.3, 0.2, 0.1) * s;\n    float smoothness = .01;\n    \n    float d1 = smoothstep(dim.x, dim.x - smoothness, abs( uv.x ) );\n    d1 *= smoothstep(dim.y, dim.y - smoothness, abs( uv.y ) );\n \n    float d2 = smoothstep(dim.y, dim.y - smoothness, abs( uv.x ) );\n    d2 *= smoothstep(dim.x, dim.x - smoothness, abs( uv.y ) );\n \n    return 1.-step(d1+d2, 0.);\n}\n\nmat2 rotate2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat maze2D(vec2 uv, float t) {\n    uv.y += .5;\n    vec2 off = vec2(-0.2, 1.) * pow(abs( sin(iTime * 6.)), 9.) / 4.;\n    uv -= off / 4.;\n    uv *= rotate2d(sin(iTime * 6.) / 5.);\n    \n    uv.xy += texture(iChannel1, uv.xy * 100. + vec2(iTime)).xx / 6.;\n    float d1 = smoothstep(.7, 0.0, abs( uv.x / (uv.y) ));\n    d1 *= smoothstep(1.5, .3, uv.y);\n    d1 *= step(-.0, uv.y);\n    d1 *= min(1.,pow( texture(iChannel1, uv.xy / 2.1 + vec2(0., -iTime)).x, 1.5 ));\n    \n    return d1;\n}\n\nfloat rotatingCross2Dfield(vec2 uv, float t) {\n\n    vec2 p1 = uv + vec2 ( .54, .0 );\n    vec2 p2 = uv + vec2 ( -.54, .0 );\n    vec2 p3 = uv + vec2 ( 0, .54 );\n    vec2 p4 = uv + vec2 ( 0, -.54 );\n\n    vec2 dir1 = vec2(1., 0.);\n    vec2 dir2 = vec2(-1., 0.);\n    vec2 dir3 = vec2(0., 1.);\n    vec2 dir4 = vec2(0., -1.);\n    \n    mat2 r = rotate2d(- 8.* iTime);\n    float d1 = sdCross2D(p1 * r +dir1 * (t) * r , .25 * (1.- t*3.));\n    float d2 = sdCross2D(p2 * r+ dir2 * (t) * r, .25 * (1.- t*3.) );\n    float d3 = sdCross2D(p3 * r+ dir3 * (t) * r, .25 * (1.- t*3.));\n    float d4 = sdCross2D(p4 * r+ dir4 * (t) * r, .25 * (1.- t*3.) );\n    \n    return d1 + d2 + d3 + d4;\n}\n\n\nfloat mapCrossField(vec3 p) {\n  \n    p+=path(iTime, p.z);\n    float speed = 30.;\n\n    float l = mod( iTime * speed, 200.);\n    if (getPhase().x == 1.) {\n        l = mod(l,13.5);\n    }\n\n    if (getPhase().x >= 2.)\n    {\n        l = 11.5;\n    }\n\n    p.z+= l;\n\n    vec3 prep = p;\n    float rep_size = 5.5;\n\n    if (getPhase().x == 0.)\n       p.z = mod(p.z, rep_size) - rep_size / 2.; \n    else\n       p.z -= 15.;\n\n    return sdCross(p, vec2( -.1, -0.5 ));\n}\n\nfloat crossfield2d(vec2 uv) {\n\n    if (abs(uv.x) < .9)\n        return 0.;\n    \n    uv *= 3.;\n    uv.x += .48;\n    float rep = 1.;\n    uv.y -= iTime * 6.;\n    vec2 ids = floor(uv * rep);\n    \n    float id = hash11(ids.x);\n    uv = mod(uv, rep) - rep / 2.;\n    \n    return sdCross2D(uv * 2.5, 1.);\n}\n\nfloat glowingCross2d(vec2 uv ) {\n    return 0.;\n}\n\nvec2 map( in vec3 pos, out vec3 id )\n{\n    vec3 tmp_id;\n    vec2 res = vec2( 1e10, -42.0 );\n     float d;\n     \n    id.z = 0.;\n    if ((d = mapCrossField(pos)) < res.x) {\n        res.x = d;\n        id.x = 0.;\n        id.z = 1.;\n    }\n    if ((d = mapPillField(pos, tmp_id)) < res.x && ( getPhase().x == 1.\n    || getPhase() == vec2(3., 1.) ) ) {\n           id = tmp_id;\n           res.x = d;\n           id.z = 1.;\n    }\n    if ( ( d = sdCross(pos - vec3 ( 0., 0., 3.5), vec2(0.0, 0.0) ) ) <= res.x ) {\n     //   res.x = d;\n      //  id.x = 3.;\n       // id.z = 0.;\n    }\n    float k;\n    if ( (d = sdLights(pos, tmp_id, k)) < res.x) {\n        if (getPhase() == vec2(0., 1.)) {\n            res.x = d;\n            id = tmp_id;\n        }\n    }\n    if ( (d = mapSphericalPill(pos, tmp_id) ) < res.x ) {\n        if ( getPhase().x == 3. ) {\n           id = tmp_id;\n           res.x = d;\n        }\n    }\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 id )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 100.0;\n    int steps = 50;\n    if (getPhase().x == 0.) \n        steps = 120;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<steps && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t, id );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * 1.;\n        }\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec4 render( in vec3 ro, in vec3 rd , vec2 uv)\n{ \n    vec3 col = vec3(.0f);\n    vec3 id;\n    vec2 res = castRay(ro,rd, id);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 albedo = vec3(0., 0., 0.);\n    vec3 tmp_id;\n    float dLight2;\n    float dLight1 = sdLights(ro+rd*t, tmp_id, dLight2);\n    if (res.x > .0f) {\n        if (id.x == 0.) {\n            albedo = k_cross;\n        }\n        if (id.x == 1.) {\n            albedo = vec3(1.);\n            if (id.y > 0.) {\n                albedo = 15.*pow( hash13(id.y) /20., vec3(.85));//vec3(1., 0., 0.);\n            }\n        }\n        if (id.x == 3.) {\n           albedo = k_screen;\n        }\n        if (id.x == 4.) {\n            if (id.y == 0.) {\n                albedo = k_light1/.1;\n            } else { \n                albedo = k_light2/.1;           \n            }\n        }\n        if (id.x == 5.) {\n            albedo = vec3(.8) / 1.;\n            if (id.y == 1.) {\n                albedo = vec3(1) / 2.;\n            }\n        }\n    }\n    \n    float falloff = 7.0;\n    float bias = 15.5;\n    float intensity = 5.1;\n    vec3 lCol = ( intensity / pow( 1.+ dLight1 / bias, falloff)) * k_light1 +\n    ( 1. / pow( 1. + dLight2 / bias, falloff)) * k_light2;\n    if (getPhase().x == 3.) {\n        lCol = vec3( 0. );\n    }\n    vec3 a = albedo * min(1., -.3+res.x)+ lCol * step(.2, albedo.g);\n\n    if (getPhase().x == 2.) {\n        a.xyz+=vec3(sdCross2D(uv.xy, abs( pow ( sin(iTime * 4.), 5.) )) ) * k_cross;\n        a.xyz+=vec3(rotatingCross2Dfield(uv.xy, abs( pow ( sin(iTime * 4.), 5.) )) ) * k_cross;\n        \n    } else if ( getPhase().x == 3. ) {\n       a.xyz += vec3(maze2D(uv, 0.));\n       a.xyz += crossfield2d(uv) * k_cross;\n    }\n   \tvec4 ret = vec4(a.x, a.y,a.z, id.z);\n    return ret;\n}\n\nvec3 retro_filter(vec2 uv, vec3 col) {\n    float rep_size = .015;\n    vec2 uv_rep = mod(uv, vec2(rep_size)) - rep_size / 2.;\n    \n    float l = length(uv_rep);\n    float circle = smoothstep(0.5 * .015, 0.2* .015, l);\n    return circle * col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, .0f);\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = normalize( vec3(p.xy,2.) );\n\n    // render\t\n    vec4 colid = render( ro, rd, p );\n    \n    vec3 col = colid.xyz;\n\n    col = retro_filter(p, col);\n    \n    // gamma\n    col = pow( col, vec3(0.9545) );\n    tot += col;\n\n\n\n    fragColor = vec4( tot * 1., 1.0 );\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opSs( in float d1, in float d2 )\n{\n    d1 *= -1.0;\n    return (d1 > d2) ? d1 : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 308, 337, 419], [421, 421, 452, 452, 991], [993, 993, 1038, 1038, 1384], [1386, 1386, 1435, 1435, 1689], [1691, 1691, 1732, 1732, 2178], [2180, 2180, 2212, 2212, 2589], [2591, 2591, 2647, 2647, 3236], [3238, 3238, 3273, 3273, 3754], [3756, 3756, 3780, 3780, 3832], [3834, 3834, 3866, 3866, 4315], [4317, 4317, 4363, 4363, 4988], [4991, 4991, 5020, 5020, 5445], [5447, 5447, 5476, 5476, 5744], [5746, 5746, 5778, 5778, 5795], [5797, 5797, 5835, 5835, 6712], [6714, 6714, 6767, 6767, 7272], [7274, 7274, 7326, 7326, 7503], [7504, 7504, 7552, 7552, 9249], [9251, 9251, 9289, 9289, 9494], [9497, 9497, 9554, 9554, 10189]], "test": "untested"}
{"id": "DtfSDH", "name": "Basic Audio Visualizer Modified", "author": "Spheroidon", "description": "chronos' audio visualizer modified to use channel 0.", "tags": ["simple"], "likes": 2, "viewed": 215, "published": 3, "date": "1674649365", "time_retrieved": "2024-07-30T18:13:43.967043", "image_code": "/* Simple audio visualizer by chronos\n// Feel free to use any part of the code and/or improve it further\n// Drop a link in the comments! :)\n// \n// Recommended tracks:\n// https://soundcloud.com/kubbi/pathfinder\n// https://soundcloud.com/wearecastor/rad\n// https://soundcloud.com/jco-de/coronoid-soundtrack\n//\n*/\n\n#define WIDTH 1.0\n\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\nvec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered = 2.0 * uv - 1.0;\n    centered.x *= iResolution.x / iResolution.y;\n\n    float dist2 = dot(centered, centered);\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\n    \n    // Color variation functions\n    float t = iTime / 100.0;\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    vec3 disc_color  = 0.20 * base_color;\n    vec3 wave_color  = 0.10 * base_color;\n    vec3 flash_color = 0.05 * base_color;\n    \n    float sample1 = audio_freq(iChannel0, abs((uv.x - .5) / WIDTH) + 0.01);\n    float sample2 = audio_ampl(iChannel0, clamped_dist);\n    float sample3 = audio_ampl(iChannel0, arclength);\n    \n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\n    disp_dist *= (1.0 - disp_dist);\n\t\n    vec3 color = vec3(0.0);\n    \n    // spline debug\n    // vec3 s = smoothstep(-0.01, 0.01, spline-uv.y); color += (1.0-s) * s;\n    \n    float v = abs(uv.y - 0.5);\n    color += flame_color * smoothstep(v, v*8.0, sample1);\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\n    color += wave_color  * disp_dist;\n    color = pow(color, vec3(0.4545));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 384, 384, 430], [431, 431, 484, 484, 530], [532, 532, 556, 600, 907], [909, 909, 966, 966, 2609]], "test": "untested"}
{"id": "dt23Dh", "name": "Cloudspace", "author": "Dragonpeak", "description": "Fly through of a cloudscape, testing out some different volume rendering optimisation techniques.", "tags": ["raymarching", "noise", "clouds", "volumetric"], "likes": 5, "viewed": 352, "published": 3, "date": "1674639124", "time_retrieved": "2024-07-30T18:13:44.851677", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 screen_pos = fragCoord.xy/iResolution.xy;\n\n    fragColor = vec4(pow(texture(iChannel0, screen_pos/RENDER_SCALE*.99).xyz*vec3(0.886,0.953,1.000), vec3(1./2.2)),1.);//upscale to fill screen and gamma correct\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Fly through of a cloudscape, testing out some different volume raymarching optimisation techniques.\n//Optimisations:\n//Blue noise based dithering.\n//Lower render resolution & upscaling.\n//Early out for dense areas.\n//Interpolate between density samples for smoother light.\n//Lower noise octaves in distance \n//Interframe averaging\n//Use larger steps based on approx slope of noise function, using difference with last sample\nconst float RENDER_SCALE=1.5;\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec2 Rand2D(vec2 v)\n{\n    return vec2(pcg2d(uvec2(v)))/float(0xffffffffu);\n}\nvec3 Rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 ap = abs(p);\n    vec2 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand2D(ap).x;\n    float b = Rand2D(ap+vec2(1,0)).x;\n    float c = Rand2D(ap+vec2(0,1)).x;\n    float d = Rand2D(ap+vec2(1)).x;\n\n    float v = mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y);\n    \n\n    \n\n    return v;\n}\nfloat Noise3D(vec3 p)\n{\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand3D(ap).x;\n    float b = Rand3D(ap+vec3(1,0,0)).x;\n    float c = Rand3D(ap+vec3(0,1,0)).x;\n    float d = Rand3D(ap+vec3(1,1,0)).x;\n    \n    float e = Rand3D(ap+vec3(0,0,1)).x;\n    float f = Rand3D(ap+vec3(1,0,1)).x;\n    float g = Rand3D(ap+vec3(0,1,1)).x;\n    float h = Rand3D(ap+vec3(1,1,1)).x;\n\n    float v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n\n    \n\n    return v;\n}\n\n", "buffer_a_code": "// Fork of \"Cloud Interptest\" by Dragonpeak. https://shadertoy.com/view/dtS3Rm\n// 2023-01-09 12:26:15\n\nconst vec3 SUN_DIR = normalize(vec3(.7,.1,.3));\nconst vec3 SUN_COL = vec3(1.000,0.812,0.588)*1.1;\nconst float LIGHT_DENS_MUL = .04;//multipier for the density when marching light, else the light has to low of a falloff\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nRay ConstructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\n\nfloat GetDens(vec3 pos, int oct)//cloud density function\n{\n    float d = pow(clamp((abs(pos.y/6.)), 0., 1.), 2.);// carving middle y section to fly through\n    d+=(Noise2D(pos.xz*.5+5125.62)*2.-1.)*.4;//large scale 2d noise to control cloud height\n    d=clamp(d,0.,1.);\n    d*=clamp(length(pos.yz)*.5, 0., 1.);//carve a tunnel for the camera to fly through\n    float a = .1;\n    float f = 2.;\n    for(int i = 0; i < oct; i++)//fBm 3d noise for cloud details, use passed in octaves\n    {\n        d=max(d-(Noise3D(pos*f+vec3(25.61,12.512,63.42)+iTime*.1))*a, 0.);\n        f*=1.9;\n        a*=.6;\n    }\n    return clamp(pow(d, 0.7), 0., 1.)*90.; }\n\nvec3 MarchLightSmooth(Ray r, int oct)//march the light through the clouds\n{\n    const float STEP = .2;//minumum step count\n    const float FAR = 2.;//max light march distance\n    float dist = 0.1;//initial distance\n    float dens = 0.;\n    float lastDens = 0.;\n    float lastStep = STEP;// use the minimum step as the last step initially\n    while(dist < FAR)\n    {\n\n        vec3 pos = r.origin+r.dir*dist;\n        float currentDens = max(GetDens(pos,max(oct-1, 1)), 0.);// we use the pased in octaves -1 for the noise, the light doesn;t need as much detail as the main march\n        float st = clamp(STEP/pow(abs(currentDens-lastDens), .2), STEP, STEP*3.);//calculate step based on difference between this and last step power func to adjust curve and clamped to range of minstep to minstep*some const\n        if(lastDens < .01)st+=.2;//use larger steps in empty areas\n        \n        dist+=st;\n        currentDens = min(currentDens, lastDens)*lastStep + (abs(currentDens-lastDens)*lastStep)/2.;//calculate density from current and last dens this interp helps to smooth the effect but can cause some artifacts\n        dens += currentDens;\n        lastStep=st;\n        lastDens = currentDens;\n        \n    }\n    return vec3(exp(-(dens/STEP)*LIGHT_DENS_MUL))*SUN_COL*.8+vec3(.2,.2,.45)*.05;//calculate lighting from marched density\n}\n\nvec4 MarchCloudsSmooth(Ray r)//march the clouds, most is same as above, only differences will be commented\n{\n    float STEP = .03;\n    float FAR = 30.;\n    \n    float dist = .5;\n    float trans = 1.;\n    vec3 light = vec3(0.);\n    vec3 lastLight = vec3(0);\n    float lastCd = 0.;\n    float lastStep = STEP;\n    while(dist < FAR)\n    {\n        vec3 pos = r.origin+r.dir*dist;\n        int oct = int((1.-dist/FAR)*8.);//use a lower octave at greater distances\n        float cd = GetDens(pos,oct);\n        float st = clamp(STEP/pow(abs(cd-lastCd), .2) , STEP, STEP*3.);\n        if(lastCd < .01)st+=.01;\n        dist+=st;\n        float cd1 = min(cd, lastCd)*lastStep + (abs(cd-lastCd)*lastStep)/2.;\n   \n        if(cd1>.01)\n        {\n            vec3 cLight = MarchLightSmooth(Ray(pos, SUN_DIR), oct)*cd1*trans;//march the light only of we are in a cloud with some density\n            \n            light += min(cLight, lastLight)*lastStep + (abs(cLight-lastLight)*lastStep)/2.;//interp like with density\n            trans *= exp(-cd1);// calc transmission\n            lastLight = cLight;\n        }\n        lastCd = cd;\n        lastStep=st;\n        if(trans < .05)break;//break if we are almost at min transmission, new steps would have little effect on final image\n        \n        \n    }\n    return vec4(light/STEP, trans);\n}\n\nvec3 DrawSky(vec3 dir)//simple sky gradient\n{\n    float sun = smoothstep(0.5, 1., dot(dir, SUN_DIR))*.5;\n\n    return mix(vec3(.6, .6, .8), vec3(.4, .4, .9), dir.y) + vec3(1,.8,.7)*sun;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord*=RENDER_SCALE;//render at a lower resolution\n    vec3 col = vec3(0);\n    if(fragCoord.x < iResolution.x && fragCoord.y < iResolution.y)\n    {\n\n        vec2 screen_pos = (fragCoord.xy/iResolution.xy*2.-1.);\n\n        vec3 eye_pos = vec3(iTime, -.4, 0.);\n\n        Ray view_ray = ConstructViewRay(screen_pos, eye_pos, normalize(vec3(1,0,-.1)), vec3(0,1,0), 1.2);\n        view_ray.origin+=view_ray.dir*(texture(iChannel0, screen_pos/RENDER_SCALE+iTime*10.3127).x*2.-1.)*1.;\n\n        vec4 dens = MarchCloudsSmooth(view_ray);\n\n        col = mix(dens.xyz, DrawSky(view_ray.dir), dens.w);\n    }\n\n    //col = texture(iChannel0, fragCoord/iResolution.xy).zzz;\n    //col = vec3(GetDens(vec3(screen_pos*10., 1.).yzx));\n    fragColor = vec4(col,1.)*.5+texelFetch(iChannel1, ivec2(fragCoord/RENDER_SCALE), 0)*.5;//blend with prev frame to smooth noise\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt23Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 275]], "test": "untested"}
{"id": "dtsXWr", "name": "Randomized Dithering Experiment", "author": "oneshade", "description": ".", "tags": ["color", "random", "dither", "image"], "likes": 10, "viewed": 271, "published": 3, "date": "1674614564", "time_retrieved": "2024-07-30T18:13:45.618626", "image_code": "// 0=disable, 1=enable\n#define RANDOM_DITHER 1\n\n#define Hex(c) vec3(c >> 16, c >> 8 & 255, c & 255) / 255.\nconst vec3[] palette = vec3[](\n    Hex(0x000000),\n    Hex(0x626262),\n    Hex(0x898989),\n    Hex(0xADADAD),\n    Hex(0xFFFFFF),\n    Hex(0x9F4E44),\n    Hex(0xCB7E75),\n    Hex(0x6D5412),\n    Hex(0xA1683C),\n    Hex(0xC9D487),\n    Hex(0x9AE29B),\n    Hex(0x5CAB5E),\n    Hex(0x6ABFC6),\n    Hex(0x887ECB),\n    Hex(0x50459B),\n    Hex(0xA057A3)\n);\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 imgColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    //fwidth(length(imgColor)) > 1e-6\n\n    if (RANDOM_DITHER == 1) {// && fwidth(length(imgColor)) > 1e-6) {\n        // Calculate a similarity metric between the pixel color and\n        // each color in the palette\n        float[palette.length()] M;\n        float total = 0.0;\n        for (int i=0; i < palette.length(); i++) {\n            vec3 palColor = palette[i];\n            float m = 1.0 - max(abs(palColor.x - imgColor.x), max(abs(palColor.y - imgColor.y), abs(palColor.z - imgColor.z)));\n            M[i] = m;\n            total += m;\n        }\n\n        // Weight the chances toward more likely matches\n        float totalM = total;\n        total = 0.0;\n        for (int i=0; i < palette.length(); i++) {\n            float pickChance = M[i] / totalM;\n            pickChance = pow(pickChance, 20.0);\n            M[i] = pickChance;\n            total += pickChance;\n        }\n\n        // Select palette color\n        float rand = Hash21(fragCoord);\n        float low = 0.0;\n        for (int i=0; i < palette.length(); i++) {\n            vec3 palColor = palette[i];\n            float pickChance = M[i] / total;\n            float high = low + pickChance;\n            if (rand >= low && rand <= high) {\n                fragColor = vec4(palColor, 1.0);\n                break;\n            }\n\n            low = high;\n        }\n    } else {\n        float bestM = 0.0;\n        for (int i=0; i < palette.length(); i++) {\n            vec3 palColor = palette[i];\n            float m = 1.0 - max(abs(palColor.x - imgColor.x), max(abs(palColor.y - imgColor.y), abs(palColor.z - imgColor.z)));\n            if (m > bestM) {\n                fragColor = vec4(palColor, 1.0);\n                bestM = m;\n            }\n        }\n    }\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsXWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 486, 511, 511, 625]], "test": "untested"}
{"id": "DllXR4", "name": "Year of Truchets #004", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 20, "viewed": 309, "published": 3, "date": "1674600958", "time_retrieved": "2024-07-30T18:13:46.486306", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #004\n    01/24/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nfloat mid,sid;\nmat2 flip,turn;\n\nvec3 colorA = vec3(.65);\nvec3 colorB = vec3(.40);\nvec3 colorC = vec3(.80);\n\nconst vec3 size = vec3(1.75,2.5,1.75);\nconst vec3 hlf =  size/2.;\nconst vec3 bs = vec3(hlf*.9);\nconst vec3  grid = vec3(1,1,1);\nconst float thick = .45/size.x;\n\nfloat u_hash = .6938;\nconst vec3 d = vec3(0.957,0.439,0.043);\nvec3 hue(float t){ return .5 + .4*cos(PI2*t*(vec3(.95,.97,.98)*d)); }\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    \n    p.x+=T*.25;\n    float pd = floor((p.x+4.)/8.);\n    mid=pd;\n    p.x=mod(p.x+4.,8.)-4.;\n    \n    p.yz*=flip;\n    p.xz*=turn;\n\n\n    vec3 q = p;\n\n    vec3 id = floor((q + hlf)/size)-grid;\n    id+=pd;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    vec3 fq = q;\n\n    float hs = hash21(id.xz+id.y+u_hash);\n    if(hs>.5) q.z*=-1.;\n\n    vec2 d2 = vec2(length(q.xz-hlf.xz), length(q.xz+hlf.xz));\n    vec2 gx = d2.x<d2.y ? vec2(q.xz-hlf.xz) : vec2(q.xz+hlf.xz);\n    vec3 tq = vec3(gx.x,q.y,gx.y);\n\n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = 1e5;\n\n    if(fract(xhs+id.x*33.32)>.75) q.zx*=rot(1.5707);\n    \n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf.x,.25,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf.z))-thick,trh);\n    }else if(rhs>.7){\n        float qy = .15+.15*sin((q.z+.5)*size.z*2.);\n        float qx = .15+.15*sin((q.x+.5)*size.x*2.);\n        trh = cap(q-vec3(0,.25+qy,0),hlf.x,thick);\n        trh = min(cap(q.zyx-vec3(0,.25-qx,0),hlf.z,thick),trh);\n    } else{\n        trh = trs(tq-vec3(0,.25,0),vec2(hlf.x,thick));\n    }\n    \n \n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        gtile.xyz = vec3(id.xz,1.);\n        gtile.w=mt;\n        res = vec2(trh,mt);\n        hit = tq;\n    } \n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.4,thick*1.1);\n    bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.4,thick*1.1),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.34,thick*1.45);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.34,thick*1.45),crt);\n    \n    bls=max(crt,-bls);\n    \n    if(bls<res.x) {\n       res = vec2(bls,1.);\n       hit = q;\n    } \n\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = 1e-4*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    float ftx = 276.;\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv = floor(uv*(ftx*R.x/R.y))/(ftx*R.x/R.y);\n\n    //u_hash+=floor(T*.1);\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.z < 0. || M.xy==vec2(0) ? 0.0 : (M.y/R.y*2.-1.)*PI;\n    float y = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : T*.063;\n    \n    mat2 rx =rot(-.65);\n    mat2 ry =rot(.0);\n    \n    flip=rot(x);\n    turn=rot(y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<164;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<d*1e-5||d>35.)break;\n        d += i<42? ray.x*.25: ray.x*.5;\n        m  = ray.y;\n    } \n\n    sid=mid;\n    colorA = hue(.00+u_hash+sid);\n    colorB = hue(.15+u_hash+sid);\n    colorC = hue(.60+u_hash+sid);\n\n    float alpha = 1.;\n\n    if(d<35.)\n    {\n    \n        hitPoint = hit;\n        alpha *=1e-5;\n        \n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(5,5,9.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),0. , 1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n      \n        float shdw = 1.0;\n        float t=.01;\n        for( int i =0; i<64; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<1e-4 ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<1e-4 || t>35. ) break;\n        }\n        diff = mix(diff,diff*shdw,.5);\n\n        vec3 h = vec3(.0);\n        \n        if(m==1.) {h=vec3(.35);}\n        if(m==2.) {h=colorB;}\n        if(m==3.) {h=colorC;}\n        if(m==4.) {h=colorA;}\n        if(m==5.) {h=vec3(.05);}\n\n        float xiff = diff;\n        if(diff<.6 && (mod(F.x,4.)==mod(F.y,4.))) xiff*=.3;\n        if(diff<.4 && (mod(F.x,3.)==mod(F.y,3.))) xiff*=.3;\n        if(diff<.2 && (mod(F.x,2.)==mod(F.y,2.))) xiff*=.3;\n        \n        if(spec>.25) xiff=clamp(xiff*1.15,0.,1.);\n        if(spec>.5 && (mod(F.x,2.)==mod(F.y,2.))) xiff=clamp(xiff*1.5,0.,1.);\n      \n        C = h*xiff;\n    }\n    \n\n    C = mix(C,mix(vec3(.025),vec3(.95),(uv.y+.5)*.25),1.-exp(-.0005*d*d*d));\n    C = clamp(C,vec3(1e-3),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllXR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[823, 823, 841, 841, 892], [894, 894, 912, 912, 956], [957, 957, 978, 978, 1034], [1036, 1036, 1061, 1061, 1146], [1148, 1148, 1182, 1182, 1287], [1290, 1290, 1316, 1316, 1385], [1387, 1387, 1404, 1404, 3272], [3274, 3349, 3379, 3379, 3614], [3616, 3616, 3657, 3657, 5948]], "test": "untested"}
{"id": "mlsXWn", "name": "FBM Slow Blue Fog", "author": "kunshksingh", "description": "Credit to https://www.shadertoy.com/view/tdG3Rd#", "tags": ["fog", "blue", "brownianmotion"], "likes": 1, "viewed": 302, "published": 3, "date": "1674599418", "time_retrieved": "2024-07-30T18:13:47.314094", "image_code": "//Adapted from https://www.shadertoy.com/view/tdG3Rd#\n\n// Inputs\nuniform sampler2D u_velocity;\nuniform sampler2D u_density;\n\n//Other\nfloat u_dt;\nfloat u_diff;\nfloat u_visc;\nfloat prevTime;\nfloat currTime;\n\nvoid updateVars(){\n    u_dt = currTime - prevTime;\n    u_diff = sin(iTime*0.01);\n    u_visc = 1.0;\n    prevTime = currTime;\n    currTime = iTime*0.01;\n    \n}\nfloat colormap_red(float x) {\n    if (x < 0.0) {\n        return 0.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (95.79 * x + 54.51) / 255.0;\n    } else {\n        return 0.5;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.2;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (1038067.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 0.4;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 95.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (8299.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (7922.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n// https://iquilezles.org/articles/warp\n/*float noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}*/\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(18.9898, 14.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.700000*noise( p + iTime *0.01  ); p = mtx*p*2.02;\n    f += 0.001250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.025000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime*0.01) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    updateVars();\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    \n    //BREAK\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec2 xy = p * vec2(iResolution.x / iResolution.y, 1);\n\n    vec2 velocity = texture(u_velocity, xy).xy;\n    float density = texture(u_density, xy).x+sin(iTime*0.01);\n    \n     // Viscosity\n    vec2 viscosity = (texture(u_velocity, xy + vec2(u_visc, 0.1)).xy +\n                      texture(u_velocity, xy - vec2(u_visc, 0.1)).xy +\n                      texture(u_velocity, xy + vec2(0.1, u_visc)).xy +\n                      texture(u_velocity, xy - vec2(0.1, u_visc)).xy -\n                      4.0 * texture(u_velocity, xy).xy) / (u_visc * u_visc);\n\n\n    // Advection\n    vec2 advection = texture(u_velocity, xy - u_dt * velocity).xy;\n    \n\n    // Diffusion\n    vec2 diffusion = (texture(u_velocity, xy + vec2(u_diff, 0.1)).xy +\n                          texture(u_velocity, xy - vec2(u_diff, 0.1)).xy +\n    texture(u_velocity, xy + vec2(1.0, u_diff)).xy +\n    texture(u_velocity, xy - vec2(1.0, u_diff)).xy) / 4.0;\n\n   \n    // Update velocity and density\n    velocity = advection + diffusion;\n    density = texture(u_density, xy - u_dt * velocity).x;\n\n    fragColor = vec4(colormap(shade).rgb * (density+0.1), shade);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 224, 224, 363], [364, 364, 393, 393, 565], [567, 567, 598, 598, 932], [934, 934, 964, 964, 1351], [1353, 1353, 1377, 1377, 1455], [1914, 1914, 1934, 1934, 2005], [2007, 2007, 2027, 2027, 2262], [2317, 2317, 2338, 2338, 2676], [2678, 2678, 2706, 2706, 2748], [2750, 2750, 2807, 2807, 4092]], "test": "untested"}
{"id": "ctlXWr", "name": "Mountain Lakes", "author": "FifthStateOfMatter", "description": "3D", "tags": ["3d"], "likes": 8, "viewed": 387, "published": 3, "date": "1674586075", "time_retrieved": "2024-07-30T18:13:48.226653", "image_code": "//Thanks to iq for some help with artifacts\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return (fract(p.x + p.y)*2.0) - 1.0;\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 8; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat yPlane(vec3 p){\n    return p.y;\n}\n\nfloat scene(vec3 p){\n    return min((yPlane(p - vec3(0, -1, 0)) - fbm(p*0.05)*5.0)*0.65, (yPlane(p - vec3(0, -2, 0)) - noise2(p.xz*20.0)*0.002));\n}\n\nfloat raymarch(vec3 o, vec3 d, int ms, float md, float eps, out bool hit){\n    float t = 0.0;\n    hit = false;\n    for(int i = 0; i < ms && t < md && !hit; i++){\n        float s = scene(o + d*t);\n        t += s;\n        if(abs(s) < eps*t*0.1){\n            hit = true;\n            return t;\n        }\n    }\n    hit = false;\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    return normalize(vec3(\n        scene(vec3(h.x + 0.01, h.yz)) - scene(vec3(h.x - 0.01, h.yz)),\n        scene(vec3(h.x, h.y + 0.01, h.z)) - scene(vec3(h.x, h.y - 0.01, h.z)),\n        scene(vec3(h.xy, h.z + 0.01)) - scene(vec3(h.xy, h.z - 0.01))\n    ));\n}\n\nfloat getLighting(vec3 h, vec3 ldir, vec3 n){\n    float c = dot(n, -ldir);\n    float cr = c;\n    float lt = 0.0;\n    bool hit = false;\n    vec3 so = h + n*0.01;\n    for(int i = 0; i < 50 && lt <= 30.0 && !hit; i++){\n        float s = scene(so - ldir*lt);\n        lt += s;\n        if(abs(s) <= lt*0.001 && lt >= 0.0){\n            hit = true;\n            c -= 0.6;\n        }else{\n            c = cr;\n        }\n        //return c;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec3 lDir = normalize(vec3(-10, -10, -10));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 4, iTime*3.0);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(15.0), iTime*0.1)));\n    bool hit;\n    float t = raymarch(o, d, 150, 120.0, 0.01, hit);\n    if(!hit) t = 500.0;\n    //t *= 0.9;\n    vec3 n = getNormal(o + d*t);\n    float ny = n.y - 0.1;\n    float rd = 1.0 - d.y;\n    col = mix(\n        vec3(\n            rd/5.0 + 0.2,\n            rd/2.0 + 0.2,\n            rd + 0.2\n        ),\n        vec3(1),\n        clamp(fbm((o + d*t).xzy*0.01) + 0.2, 0.0, 1.0)\n    );\n    \n    float c = clamp(getLighting(o + d*t, lDir, n), 0.0, 1.0);\n    \n    vec3 rfd = normalize(d - 2.0*n*dot(n, d));\n    \n    float spec = pow(clamp(dot(-lDir, rfd), 0.0, 1.0), 9.0);\n    bool rhit;\n    vec3 rfo = (o + d*t) + n*0.01;\n    float rft = raymarch(rfo, rfd, 100, 100.0, 0.01, rhit);\n    if(!rhit) rft = 500.0;\n    float rdy = 1.0 - rfd.y;\n    vec3 rfclouds = mix(\n        vec3(\n            rdy/5.0 + 0.2,\n            rdy/2.0 + 0.2,\n            rdy + 0.2\n        ),\n        vec3(1),\n        clamp(fbm((rfo + rfd*rft).xzy*0.01) + 0.2, 0.0, 1.0)\n    );\n    vec3 rn = getNormal(rfo + rfd*rft);\n    float rc = clamp(getLighting(rfo + rfd*rft, lDir, rn), 0.0, 1.0);\n    vec3 matcol = (o.y + d.y*t) > -1.94 ? mix(vec3(0.2, 0.15, 0.1) + spec/8.0, vec3(0.2, 0.5, 0) + spec/8.0, smoothstep(0.6, 0.7, ny))*c : (rhit ? mix(vec3(0.2, 0.5, 1)*c, mix(vec3(0.2, 0.15, 0.1), vec3(0.1, 0.5, 0), smoothstep(0.6, 0.7, ny))*rc, 0.3)*c + spec : mix(vec3(0.2, 0.5, 1), rfclouds, 0.3)*c + spec);\n    \n    if(hit){\n        col = vec3(\n            mix(matcol.r, col.r, 1.0 - exp(-t*0.01)),\n            mix(matcol.g, col.g, 1.0 - exp(-t*0.01)),\n            mix(matcol.b, col.b, 1.0 - exp(-t*0.012))\n        );\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlXWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 75, 75, 482], [484, 518, 540, 540, 646], [648, 648, 670, 670, 769], [771, 771, 792, 792, 1626], [1628, 1628, 1649, 1649, 2069], [2071, 2071, 2089, 2089, 2363], [2365, 2365, 2386, 2386, 2404], [2406, 2406, 2426, 2426, 2553], [2555, 2555, 2629, 2629, 2893], [2895, 2895, 2918, 2918, 3175], [3177, 3177, 3222, 3222, 3626], [3628, 3628, 3682, 3682, 5573]], "test": "untested"}
{"id": "dtXSWr", "name": "Inverse kaleidoscope", "author": "callumacrae", "description": "An inverse kaleidoscope - instead of moving the background, the viewer moves instead! You can also manually change the position of the viewer using your mouse / touch screen.\n\nTweakpane version here: https://sketchbook-2.macr.ae/inverted-kaleidoscope", "tags": ["2d", "interactive", "animated", "kaleidoscope"], "likes": 5, "viewed": 229, "published": 3, "date": "1674562616", "time_retrieved": "2024-07-30T18:13:49.098323", "image_code": "// Background config\n#define SQUARE_SIZE 0.01 // 0.001 - 0.05\n#define RAND_REPEAT_CHANCE 0.3 // 0.0 - 0.5\n#define BG_NOISE_FACTOR 3.8 // 0.0 - 10.0\n#define BG_RAND_TO_NOISE_RATIO 0.4 // 0.0 - 1.0\n#define BG_BLEND_MODE 3 // normal:0, multiply:1, screen:2, overlay:3, hard light:4, soft light:5\n#define COLOR_SATURATION 0.5 // 0.0 - 1.0\n#define COLOR_VALUE 0.75 // 0.0 - 1.0\n#define DEBUG_BACKGROUND false\n\n// Viewer config\n#define BASE_TRIANGLE_SIZE 0.1 // 0.01 - 0.4\n#define POSITION_NOISE_FACTOR 2.0 // 0.0 - 10.0\n#define ANGLE_NOISE_IN_FACTOR 2.5 // 0.0 - 10.0\n#define ANGLE_NOISE_OUT_FACTOR 0.25 // 0.0 - 10.0\n\n#define PI 3.1415926535897932384626433832795 // no-config\n\n/** VENDOR START **/\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(int n) { return rand(float(n)) * 1000.0; }\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){ const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }\n\n// https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n/** VENDOR END **/\n\nmat3 translationMatrix(float x, float y) {\n  return mat3(1, 0, 0, 0, 1, 0, x, y, 1);\n}\nmat3 rotationMatrix(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\nmat3 scaleMatrix(float x, float y) {\n  return mat3(x, 0, 0, 0, y, 0, 0, 0, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  // Means that a 1x1 square in UV units is always a square\n  // Be careful, this means that u and v can now be outside of [0, 1]\n  if (iResolution.x > iResolution.y) {\n    uv.x *= iResolution.x / iResolution.y;\n  } else {\n    uv.y *= iResolution.y / iResolution.x;\n  }\n\n  float triangleSize = BASE_TRIANGLE_SIZE;\n  float triangleHeight = triangleSize / 2.0 / tan(PI / 6.0);\n  vec2 triangleFrom;\n  if (iMouse.z > 0.0) {\n    triangleFrom = iMouse.xy / iResolution.xy;\n  } else {\n    triangleFrom = vec2(\n      snoise(vec2(iTime * POSITION_NOISE_FACTOR / 100.0 + rand(3), 0.0)),\n      snoise(vec2(iTime * POSITION_NOISE_FACTOR / 100.0 + rand(4), 0.0))\n    ) * 0.2 + 0.5;\n  }\n  float triangleAngle = snoise(\n    vec2(iTime * ANGLE_NOISE_IN_FACTOR / 100.0 + rand(8), 0.0)\n  ) * PI * 2.0 * ANGLE_NOISE_OUT_FACTOR;\n\n  // TS = triangle space\n  vec2 uvTS = (rotationMatrix(triangleAngle) * vec3(uv - triangleFrom, 1.0)).xy;\n\n  if (!DEBUG_BACKGROUND) {\n    uvTS.y = mod(uvTS.y, triangleHeight * 2.0);\n    if (uvTS.y > triangleHeight) {\n      uvTS.y = 2.0 * triangleHeight - uvTS.y;\n    }\n\n    float modX = mod((uvTS.x + triangleSize / 2.0), triangleSize);\n    float maxWidthAtX = uvTS.y / triangleHeight * triangleSize;\n    // Inverted = point side up (the origin triangle is point side down)\n    bool isInverted = abs(modX - triangleSize / 2.0) > maxWidthAtX / 2.0;\n\n    float offsetX = floor((uvTS.x + (isInverted ? 0.0 : triangleSize / 2.0)) / triangleSize);\n    uvTS.x -= offsetX * triangleSize;\n\n    if (isInverted) {\n      mat3 reflect = rotationMatrix(radians(-60.0)) * scaleMatrix(-1.0, 1.0);\n      uvTS = (reflect * vec3(uvTS, 1.0)).xy;\n    }\n\n    float originY = triangleSize * sqrt(3.0) / 3.0;\n    mat3 rotation = translationMatrix(0.0, originY) * rotationMatrix(radians(-120.0) * offsetX) * translationMatrix(0.0, -originY);\n    uvTS = (rotation * vec3(uvTS, 1.0)).xy;\n  }\n\n  float size = SQUARE_SIZE * max(iResolution.x, iResolution.y);\n  uv = (rotationMatrix(-triangleAngle) * vec3(uvTS, 1.0)).xy + triangleFrom;\n  vec2 xy = uv * iResolution.xy / size;\n  xy.x = floor(xy.x);\n  xy.y = floor(xy.y);\n\n  float randIndex = xy.x + xy.y * (1.0 / SQUARE_SIZE);\n\n  // Make it so there's two or three in a row sometimes\n  if (rand(randIndex - 1.0) > (1.0 - RAND_REPEAT_CHANCE / 2.0)) {\n    randIndex -= 2.0;\n  } else if (rand(randIndex) > (1.0 - RAND_REPEAT_CHANCE)) {\n    randIndex -= 1.0;\n  }\n\n  float hRand = rand(randIndex);\n  float hNoise = snoise(xy * BG_NOISE_FACTOR / 100.0) * 0.5 + 0.5;\n\n#if BG_BLEND_MODE == 0\n  // Normal blend mode\n  float hBlend = (hRand + hNoise) / 2.0;\n#elif BG_BLEND_MODE == 1\n  // Multiply blend mode\n  float hBlend = hRand * hNoise;\n#elif BG_BLEND_MODE == 2\n  // Screen blend mode\n  float hBlend = 1.0 - (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 3\n  // Overlay blend mode\n  float hBlend = hRand < 0.5\n    ? 2.0 * hRand * hNoise\n    : 1.0 - 2.0 * (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 4\n  // Hard light blend mode\n  float hBlend = hNoise < 0.5\n    ? 2.0 * hRand * hNoise\n    : 1.0 - 2.0 * (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 5\n  // Soft light blend mode\n  float hBlend = hNoise < 0.5\n    ? hRand - (1.0 - 2.0 * hNoise) * hRand * (1.0 - hRand)\n    : hRand + (2.0 * hNoise - 1.0) * (sqrt(hRand) - hRand);\n#endif\n\n  float h;\n  if (BG_RAND_TO_NOISE_RATIO > 0.5) {\n    h = mix(hBlend, hRand, BG_RAND_TO_NOISE_RATIO * 2.0 - 1.0);\n  } else {\n    h = mix(hNoise, hBlend, BG_RAND_TO_NOISE_RATIO * 2.0);\n  }\n\n  /* h = h < 0.75 && h > 0.25 ? 0.0 : 0.5; */\n\n  fragColor = vec4(hsv2rgb(vec3(h, COLOR_SATURATION, COLOR_VALUE)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 764, 784, 784, 822], [823, 823, 842, 842, 876], [877, 877, 899, 899, 938], [939, 939, 960, 960, 1721], [1723, 1825, 1847, 1847, 2004], [2026, 2026, 2068, 2068, 2112], [2113, 2113, 2147, 2147, 2250], [2251, 2251, 2287, 2287, 2331], [2333, 2333, 2388, 2388, 6028]], "test": "untested"}
{"id": "dlXSWn", "name": "Roman Disco", "author": "dr2", "description": "Repurposed Pantheon for the neopagan era (mouseable)", "tags": ["lighting", "architecture", "pantheon"], "likes": 18, "viewed": 290, "published": 3, "date": "1674552630", "time_retrieved": "2024-07-30T18:13:50.197384", "image_code": "// \"Roman Disco\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Nighttime version of \"Pantheon\" with dynamic lighting added\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (vec2 vAzEl);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 RotVF (vec3 v, vec4 cs);\nvec3 RotVB (vec3 v, vec4 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, doorSz, cutVec, bmOrg, bmCol;\nvec2 bmAzEl, drAngCs, nSeg;\nfloat tCur, dstFar, domeRd, domeBs, oculRd, wallRd, wallThk, wallHt, bmRd;\nint idObj, dirCut;\nbool disco;\nconst int idDomeI = 1, idDomeM = 2, idDomeO = 3, idDomeOx = 4, idWallin = 5, idWallex = 6,\n   idCeil = 7, idFlor = 8, idPort = 9, idPortRf = 10, idGrt = 11, idPil = 12, idPlin = 13,\n   idBall = 14, idEnt = 15, idDoor = 16, idBase = 17, idBmSup = 18, idBmSrc = 19;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define CUT  Cut (p, d);\n#define DMIN(id) CUT if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) CUT if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid Cut (vec3 p, inout float d)\n{\n  if (dirCut > 0) d = max (d, dot (p, cutVec));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 a, b1, b2, dmx[3], u;\n  float dMin, d, dd, r, rh, t;\n  dMin = dstFar;\n  rh = length (p.xz);\n  r = length (p - vec3 (0., domeBs, 0.));\n  q = p;\n  q.y -= domeBs;\n  a = 2. * pi * (floor (nSeg * atan (q.zy, - vec2 (q.x, rh)) / (2. * pi)) + 0.5) / nSeg;\n  b1 = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  b1.y = abs (b1.y);\n  b2 = Rot2Cs (vec2 (rh, q.y), sin (a.y + vec2 (0.5 * pi, 0.)));\n  b2.y = abs (b2.y);\n  for (int k = 0; k < 3; k ++) {\n    u = sin (0.1 * float (k + 1) * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n    dmx[k] = vec2 (dot (b1, u), dot (b2, u));\n  }\n  t = domeRd - r;\n  d = max (min (max (abs (t - 0.06) - 0.01, Minv2 (dmx[0])),\n     max (abs (t - 0.04) - 0.04, rh - 0.43)), max (oculRd - rh, -0.01 - q.y));\n  DMIN (idDomeI);\n  d = max (min (max (abs (t - 0.045) - 0.01, Minv2 (dmx[1])),\n     max (abs (t - 0.03) - 0.01, Minv2 (dmx[2]))), max (0.42 - rh, - q.y));\n  DMIN (idDomeM);\n  dd = domeRd + 0.45 - length (vec3 (q.x, q.y + 0.42, q.z));\n  d = max (- min (dd, q.y), t - 0.02);\n  d = max (max (d, oculRd - rh), min (1.6 - rh, 0.2 - abs (q.y + 0.2)));\n  DMIN (idDomeO);\n  d = max (min (max (abs (dd) - 0.02, max (oculRd - rh, dmx[0].x - 0.005)),\n     max (abs (dd) - 0.025, abs (oculRd + 0.05 - rh) - 0.05)), - q.y);\n  DMIN (idDomeOx);\n  d = max (min (min (min (max (abs (0.15 + dd) - 0.05, q.y - 0.44),\n     max (abs (0.1 + dd) - 0.05, q.y - 0.48)),\n     max (abs (0.05 + dd) - 0.05, q.y - 0.52)),\n     max (abs (dd) - 0.05, q.y - 0.56)), - q.y + 0.3);\n  DMIN (idDomeOx);\n  q = p;\n  d = max (max (rh - wallRd + wallThk, domeRd - rh - 0.025), abs (q.y - domeBs + 0.13) - 0.27);\n  dd = length (vec2 (Minv2 (abs (q.xz)), q.y - domeBs + 0.52)) - 0.2;\n  d = max (d, - max (rh - wallRd + wallThk + 0.03, dd));\n  DMIN (idCeil);\n  d = max (max (max (abs (domeRd - rh - 0.02) - 0.04, abs (q.y - domeBs + 0.2) - 0.2),\n     min (dmx[1].x, 0.09 - abs (q.y - domeBs + 0.15))), - dd);\n  DMIN (idWallin);\n  d = max (abs (wallRd - wallThk - rh) - 0.03, abs (q.y - domeBs + 0.86) - 0.54);\n  if (q.z > 0. && abs (q.x) < 0.23) {\n    t = min (0.22 - abs (q.x), - q.y + domeBs - 0.54);\n  } else {\n    d = max (d, min (dmx[1].x - 0.03, 0.25 - abs (q.y - domeBs + 0.8)));\n    u = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    t = 0.15 - length (vec3 (abs (u.x) - wallRd + wallThk + 0.05, max (0., q.y - domeBs + 0.59),\n       u.y));\n  }\n  d = max (d, t);\n  DMIN (idWallin);\n  d = max (max (abs (wallRd - rh) - wallThk, abs (q.y - wallHt - 0.03) - wallHt), t);\n  DMIN (idWallex);\n  d = max (length (vec2 (rh - wallRd - wallThk, abs (abs (q.y - wallHt - 0.03) - 0.6) -\n     0.27)) - 0.02, min (q.z, 1. - abs (q.x)));\n  DMIN (idWallex);\n  q = p;\n  q.y -= 0.51;\n  d = max (max (abs (wallRd - rh - 0.01) - wallThk - 0.07, length (vec2 (q.x,\n     max (q.y - 0.28, 0.))) - 0.24), -0.45 - q.y);\n  d = max (max (d, - max (abs (q.x) - 2. * doorSz.x - 0.01, abs (q.y) - doorSz.y)), - q.z);\n  dd = d;\n  DMIN (idEnt);\n  t = 0.97/12.;\n  q = p;\n  q.y -= 0.09;\n  d = max (rh - wallRd - wallThk, abs (q.y) - 0.05);\n  d = max (d, min (t - rh, q.y + 0.01));\n  d = max (d, - dd);\n  DMIN (idFlor);\n  q = p;\n  d = max (max (rh - t, abs (q.y - 0.13) - 0.01),\n     min (0.3 * t - abs (0.6 * t - rh), dmx[2].x));\n  DMIN (idGrt);\n  if (p.z < 0.3) {\n    q = p;\n    q.xz = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    q.y -= 0.28;\n    q.x = abs (q.x) - wallRd + wallThk + 0.04;\n    d = min (max (length (q.xz) - 0.02, abs (q.y) - 0.13),\n       PrRoundBoxDf (vec3 (q.xz, abs (q.y) - 0.13).xzy, vec3 (0.06, 0.005, 0.06), 0.005));\n    DMINQ (idPlin);\n    d = PrSphDf (vec3 (q.xz, q.y - 0.21).xzy, 0.07);\n    DMIN (idBall);\n  }\n  q = p;\n  q.z -= wallRd + wallThk;\n  d = max (PrBoxDf (vec3 (q.x, q.y - wallHt - 0.03, q.z + 0.1), vec3 (1.05, wallHt, 0.21)),\n     - PrBox2Df (vec2 (q.x, q.y - 0.6), vec2 (0.7, 0.46)));\n  d = min (d, PrBoxDf (vec3 (q.x, abs (q.y - 0.58) - 0.49, q.z - 0.47), vec3 (1.05, 0.05, 0.47)));\n  DMIN (idPort);\n  d = max (PrRoundBoxDf (vec3 (q.x, q.y - 2. * wallHt, q.z + 0.1), vec3 (1.05, 0., 0.21), 0.02),\n     wallRd + 0.03 - rh);\n  DMIN (idWallex);\n  q = p;\n  q.yz -= vec2 (1.56, wallRd + wallThk + 0.31);\n  d = PrBox2Df (q.xz, vec2 (1.09, 0.67));\n  q.x = abs (q.x);\n  u = Rot2Cs (q.xy, CosSin (0.125 * pi));\n  d = max (d, max (max (u.y - 0.01, -0.45 - q.y), - max (max (u.y + 0.04, -0.4 - q.y), 0.63 - q.z)));\n  d = max (d, - max (min (max (PrBox2Df (vec2 ((fract (16. * q.x + 0.5) - 0.5) / 16.,\n     q.y + 0.45), vec2 (1.2/64., 0.02)), q.x - 0.98), max (PrBox2Df (vec2 ((fract (16. * u.x +\n     0.75) - 0.5) / 16., u.y + 0.04), vec2 (1.2/64., 0.02)), u.x - 0.9)), 0.63 - q.z));\n  DMIN (idPortRf);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2. * doorSz.x, 0.51, wallRd);\n  q.xz = Rot2Cs (q.xz, drAngCs) + doorSz.xz * vec2 (1., -1.);\n  d = PrBoxDf (q, doorSz);\n  DMINQ (idDoor);\n  q = p;\n  q.y -= 0.59;\n  d = 0.15 - Minv2 (abs (q.xz));\n  q.xz = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  q.z = abs (q.z);\n  q.xz -= vec2 (- wallRd + wallThk + 0.15, 0.05);\n  u = vec2 (length (q.xz) - 0.025, abs (q.y) - 0.45);\n  d = max (d, max (Maxv2 (u), 0.022 - length (vec2 (u.x - 0.01, - max (u.y + 0.04, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  q.yz -= vec2 (0.585, wallRd + wallThk + 0.4);\n  d = max (max (abs (q.x) - 1.1, abs (q.z - 0.1) - 0.4),\n     - max (abs (abs (abs (q.x) - 0.42) - 0.27) - 0.11, q.z - 0.23));\n  q.xz = (1./3.7) * (abs (fract (3.7 * q.xz) - 0.5));\n  u = vec2 (length (q.xz) - 0.08, abs (q.y) - 0.44);\n  d = max (d, max (Maxv2 (u), 0.06 - length (vec2 (u.x - 0.02, - max (u.y + 0.09, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  d = max (rh - wallRd - wallThk - 1.4, abs (q.y - 0.02) - 0.02);\n  DMINQ (idBase);\n  if (disco) {\n    q = p;\n    d = max (length (q.xz) - 0.05, abs (q.y - 0.14) - 0.005);\n    q.y -= bmOrg.y;\n    q.xz = Rot2Cs (q.xz, CosSin (bmAzEl.x));\n    t = length (q.xy) - bmRd;\n    d = min (d, max (max (max (t - 0.017, abs (q.z) - 0.004), 0.012 - t), q.y - 0.005));\n    DMINQ (idBmSup);\n    q = p;\n    q -= bmOrg;\n    q = RotVB (q, vec4 (CosSin (bmAzEl.x), CosSin (bmAzEl.y)));\n    d = max (length (q.xz) - bmRd - 0.01, abs (q.y) - 0.004);\n    DMINQ (idBmSrc);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 FloorCol (vec2 p)\n{\n  vec4 col4;\n  vec2 wd, w;\n  p = 6. * p + 0.5;\n  wd = abs (fract (p + 0.5) - 0.5);\n  if (disco && length (wd) < 0.03) {\n    col4 = vec4 (1.2, 1.2, 0.7, -1.);\n  } else if (Minv2 (wd) < 0.01) {\n    col4 = vec4 (0.6, 0.6, 0.6, 0.);\n  } else {\n    w = mod (floor (p), 2.);\n    col4 = mix (vec4 (0., 0., 0.8, 0.1), vec4 (0.8, 0.8, 0.8, 0.1), smoothstep (0.15, 0.2,\n       fract (16. * Fbm2 (Rot2D (vec2 (2., 4./3.) * p,\n       0.25 * pi * (0.5 + w.x + 2. * w.y)) + 20.))));\n    if (w.x == w.y) col4 = mix (((dot (mod (floor (p), 4.), vec2 (1., -1.)) == 0.) ?\n       vec4 (0.4, 0., 0., 0.1) : vec4 (0.6, 0.6, 0.55, 0.1)), mix (vec4 (0.7, 0.5, 0., 0.1),\n       col4, 0.1 + 0.9 * step (Minv2 (wd - 0.13), 0.)), step (0.28, length (wd - 0.5)));\n    else col4 = mix (vec4 (0.4, 0., 0., 0.1), col4, 0.1 + 0.9 * step (0.07,\n       abs (Minv2 (wd - 0.2))));\n    if (disco) col4 *= 1.2;\n  }\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4, mCol4, dwCol4, cwCol4, hiCol4;\n  vec2 u;\n  float rh, a, aa, x, wtm, wtp;\n  mCol4 = vec4 (0.8, 0.8, 0.75, 0.);\n  dwCol4 = vec4 (0.3, 0.3, 0.7, 0.);\n  hiCol4 = vec4 (HsvToRgb (vec3 (fract (0.1 * tCur), 1., 0.7)), -1.);\n  rh = length (ro.xz);\n  aa = atan (ro.z, - ro.x) / (2. * pi) + 0.5;\n  vf = vec2 (0.);\n  wtm = wallRd - wallThk;\n  wtp = wallRd + wallThk;\n  if (idObj <= idFlor) {\n    if (disco) {\n      a = 0.;\n      if (idObj == idDomeO && length (ro - vec3 (0., domeBs, 0.)) < domeRd || idObj == idCeil &&\n         rh < domeRd && ro.y > 1.4) a = 2. * (floor (nSeg.y * (atan (ro.y + domeBs, - rh) /\n         (2. * pi) + 0.5) + floor (nSeg.y * 0.1 * tCur) + 0.5) - 0.5) / nSeg.y;\n      else if (idObj == idWallex || idObj == idCeil && rh < domeRd && ro.y > 1.2 && ro.y < 1.4)\n         a = (floor (nSeg.x * (aa * ((idObj == idWallex) ? 1. : -1.)) +\n         floor (nSeg.x * 0.1 * tCur) + 0.5) - 0.5) / nSeg.x;\n      cwCol4 = vec4 (HsvToRgb (vec3 (a, 1., 0.7)), -1.);\n    }\n    if (idObj == idDomeI) {\n      if (rh < oculRd + 0.002) col4 = mCol4;\n      else if (rh > oculRd + 0.03 && rh < 0.43) col4 = disco ? mix (dwCol4, 0.5 * hiCol4,\n         step (0.5, fract (8. * tCur))) : dwCol4;\n      else col4 = 1.1 * mCol4;\n    } else if (idObj == idDomeM) {\n      col4 = 1.05 * mCol4;\n    } else if (idObj == idDomeO) {\n      if (length (ro - vec3 (0., domeBs, 0.)) < domeRd) {\n        col4 = disco ? cwCol4 : dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (32. *\n           atan ((ro.y - 1.12) / rh) / pi)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idDomeOx) {\n      col4 = vec4 (1., 1., 1.1, 1.) * mCol4;\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idWallin) {\n      if (rh > wtm - 0.02 && ro.y < 1. && ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22)) {\n        col4 = dwCol4;\n      } else if (rh < wtm - 0.05 && ro.y < 1.15) {\n        if (PrBox2Df (vec2 (fract (224. * aa + 0.5) - 0.5, ro.y - 1.14), vec2 (0.3, 0.004)) > 0.01)\n           col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n        else col4 = disco ? hiCol4 : 1.3 * mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n      } else {\n        a = fract (nSeg.x * aa + 0.5) - 0.5;\n        col4 = mCol4 * (1.2 - 0.2 * step (0.01, min (PrBox2Df (vec2 (a, ro.y - domeBs + 0.15),\n           vec2 (0.35, 0.09)), PrBox2Df (vec2 (a, ro.y - domeBs + 0.8), vec2 (0.24, 0.25)))));\n        if (ro.y > 0.92 && length (vec2 (a, 3.3 * (ro.y - 0.92))) < 0.2)\n            col4 = disco ? hiCol4 : 1.2 * col4;\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idWallex) {\n      if (ro.y < 1. && rh < wtm + 0.03 && abs (ro.x) > 0.22) {\n        col4 = disco ? cwCol4 : dwCol4;\n      } else if (ro.y < 1. && rh < wtm + 0.11 && ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22)) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        if (rh > wtp - 0.02) {\n          u = Rot2Cs (ro.xz, CosSin (pi / 14.));\n          x = 0.5 * wtp * dot (u.yx, CosSin (2. * pi * (floor (14. *\n             atan (u.y, - u.x) / (2. * pi)) + 0.5) / 14.));\n          if (ro.y > 1.44 && abs (length (vec2 (x, ro.y - 1.12)) - 0.55) < 0.05 ||\n             abs (ro.y - 1.36) < 0.08 && abs (x) > 0.37) col4 = 1.03 * mCol4;\n          if (PrBox2Df (vec2 (x, ro.y - 1.34), vec2 (0.04, 0.06)) < 0.)\n             col4 = disco ? vec4 (0.3, 0.3, 0.1, -1.) : vec4 (0.3, 0.3, 0.3, 0.);\n        }\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idCeil) {\n      if (ro.y < 1.2 && rh < wtm - 0.01) {\n        col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n      } else if (rh < domeRd) {\n        col4 = disco ? cwCol4 : dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idFlor) {\n      if (ro.y > 0.12 && rh < wallRd) {\n        col4 = FloorCol (ro.xz);\n      } else if (rh < 0.85 * oculRd && ro.y > 0.05) {\n        col4 = vec4 (0., 0.3, 0., 0.);\n      } else {  \n        col4 = mCol4;\n        vf = vec2 (128., 0.8);\n      }\n    }\n  } else {\n    if (idObj == idPil || idObj == idPlin) a = abs (fract (16. * atan (qHit.z, qHit.x) /\n       (2. * pi) + 0.5) - 0.5);\n    if (idObj == idPort) {\n      col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n      if (abs (ro.x) < 1.04 && abs (dot (vec2 (abs (ro.x), ro.y), sin (0.125 * pi +\n         vec2 (0., 0.5 * pi))) - 1.54) < 0.02) col4 = 1.03 * mCol4;\n      if (abs (ro.x) > 1. && PrBox2Df (vec2 (abs (ro.y - 0.5 * wallHt - 0.5) - 0.5,\n         ro.z - wtp + 0.1), vec2 (0.08, 0.04)) < 0.) col4 = disco ? vec4 (0.3, 0.3, 0.1, -1.) :\n         vec4 (0.3, 0.3, 0.3, 0.);\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idPortRf) {\n      col4 = mCol4 * vec4 (1., 0.95, 0.95, 1.) * (0.9 +\n         0.1 * step (0.05, abs (fract (16. * ro.z + 0.8) - 0.5)));\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idGrt) {\n      col4 = vec4 (1., 0.8, 0., 0.2);\n    } else if (idObj == idPil) {\n      if (rh < wallRd) {\n        col4 = vec4 (0.65, 0.6, 0.6, 0.);\n        if (disco && abs (qHit.y) < 0.41) col4 = 1.3 * mix (col4, hiCol4, step (0.8,\n           fract (8. * ro.y + sin (4. * pi * (aa + 0.2 * tCur)) - tCur)));\n      } else col4 = 0.95 * mCol4;\n      if (abs (qHit.y) < 0.41) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idPlin) {\n      col4 = vec4 (0.8, 0.7, 0.6, 0.);\n      if (abs (qHit.y) < 0.11) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idBall) {\n      col4 = vec4 ((disco ? bmCol.rgb : vec3 (0.9, 0.8, 0.5)) * (1. -\n         0.2 * Fbm1 (16. * tCur)), -1.);\n    } else if (idObj == idEnt) {\n      col4 = (disco && ro.z < wtm - 0.07 && ro.y > 0.92) ? hiCol4 :\n         mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n    } else if (idObj == idDoor) {\n      col4 = vec4 (0.3, 0.3, 0., 0.1) * (0.8 + 0.2 * step (0., PrBox2Df (qHit.xy,\n         doorSz.xy - 0.03)));\n    } else if (idObj == idBase) {\n      u = qHit.xz * vec2 (1./6., 1.) * 16.;\n      x = u.x + 1./3. + ((fract (0.5 * u.y) < 0.5) ? 0. : 0.5);\n      col4 = vec4 (0.5, 0.5, 0.5, 0.) * (0.9 + 0.1 * smoothstep (0.1, 0.15,\n         min (fract (u.y), 6. * min (fract (x), fract (x + 2./3.)))));\n    } else if (idObj == idBmSup) {\n      col4 = vec4 (1., 1., 1., 0.1);\n    } else if (idObj == idBmSrc) {\n      col4 = (qHit.y < 0. && length (qHit.xz) < bmRd) ? vec4 (bmCol.rgb, -1.) :\n         vec4 (1., 1., 1., 0.1);\n    }\n  }\n  return col4;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float rad, out vec3 rHit)\n{\n  vec3 vn;\n  float dMin, d, a, b, w;\n  dMin = 1e6;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      d /= a;\n      rHit = ro + d * rd;\n      dMin = d;\n      vn = vec3 (rHit.xz / rad, 0.).xzy;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BmVal (vec3 ro, vec3 rd, float dstLim, float bmRad, out vec3 bmHit, out vec3 bmAx)\n{\n  vec4 dc4, csBm;\n  float bmVal;\n  csBm = vec4 (CosSin (bmAzEl.x), CosSin (bmAzEl.y));\n  bmAx = RotVF (vec3 (0., -1. /*1.*/, 0.), csBm);\n  bmVal = 0.;\n  dc4 = CylHit (RotVB (ro, csBm), RotVB (rd, csBm), bmRad, bmHit);\n  if (dc4.x < dstLim) {\n    bmVal = max (- dot (RotVF (dc4.yzw, csBm), rd), 0.);\n    bmHit = RotVF (bmHit, csBm);\n  }\n  return bmVal;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 6. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n    if (disco) col *= 0.25;\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n    if (disco) col = vec3 (0.1) * col.r + StarPat (rd, 16.);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltDir, col, vn, roo, bmHit, bmAx, oculPos;\n  vec2 vf;\n  float dstObj, dstGrnd, sh, bmVal;\n  bool inBldg, isBg;\n  domeRd = 1.2;\n  domeBs = domeRd + 0.24;\n  wallRd = 1.7;\n  wallHt = 0.9;\n  wallThk = 0.26;\n  oculRd = 0.16;\n  oculPos = vec3 (0., domeBs + domeRd, 0.);\n  doorSz = vec3 (0.09, 0.35, 0.013);\n  drAngCs = CosSin (-0.5 * pi * clamp (-0.3 + 1.6 * abs (2. * fract (0.25 * tCur) - 1.), 0., 1.));\n  bmCol = disco ? HsvToRgb (vec3 (fract (0.1 * tCur), 0.7, 1.)) : vec3 (0.8, 1., 0.8);\n  nSeg = vec2 (28., 27.);\n  roo = ro;\n  isBg = false;\n  inBldg = false;\n  dstGrnd = dstFar;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    inBldg = ((dirCut == 0 && ((length (ro.xz) < wallRd && ro.y < 2. * wallHt ||\n       length (ro - vec3 (0., domeBs, 0.)) < domeRd && ro.y > domeBs) ||\n       idObj == idEnt && ro.z < wallRd || idObj == idDoor)) || idObj == idBall);\n    col4 = ObjCol (ro, vf);\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (inBldg) {\n        ltDir = normalize (oculPos - ro);\n        col = col4.rgb * (0.1 + 0.5 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n      }\n    } else {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0. && dirCut == 0) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    col4 = vec4 (0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz))), 0.05);\n  } else {\n    isBg = true;\n    col = (dirCut == 0) ? SkyBgCol (ro, rd) : vec3 (0.3, 0.4, 0.5) * (0.7 + 0.3 * rd.y);\n  }\n  if (! isBg && ! inBldg) {\n    if (disco) {\n      if (col4.a >= 0.) {\n        if (abs (ro.x) < 1. && ro.y < 1. && ro.z > wallRd && ro.z < wallRd + wallThk + 0.9) {\n          ltDir = normalize (vec3 (0., 1.6, wallRd + wallThk + 0.6) - ro);\n          col = 0.6 * col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n        } else {\n          col = 0.3 * col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n        }\n      } else {\n        col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n      }\n      if (dstObj >= dstFar) col = mix (col, 0.25 * vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else {\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      if (dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n  }\n  if (inBldg) { \n    if (disco) {\n      bmVal = BmVal (roo - bmOrg, rd, min (dstObj, dstFar), bmRd, bmHit, bmAx);\n      if (bmVal > 0. && length (bmHit.xz) < wallRd - 0.12 &&\n         RotVB (bmHit, vec4 (CosSin (bmAzEl.x), CosSin (bmAzEl.y))).y < 0.) {\n        col += 0.3 * mix (col4.rgb, bmCol, 0.5) * max (0., - dot (vn, bmAx)) * (1. -\n           smoothstep (-0.1, 0.1, length (ro - bmOrg - dot (ro - bmOrg, bmAx) * bmAx) - bmRd));\n        col += 0.3 * bmVal * bmCol;\n      }\n    } else {\n      bmVal = BmVal (roo - oculPos, rd, min (dstObj, dstFar), oculRd, bmHit, bmAx);\n      bmHit += oculPos;\n      if (bmVal > 0. && length (bmHit.xz) < wallRd - 0.12 && bmHit.y > 0.12) {\n        col += 0.2 * col4.rgb * max (0., - dot (vn, bmAx)) * (1. - smoothstep (-0.1, 0.1,\n           length (ro - oculPos - dot (ro - oculPos, bmAx) * bmAx) - oculRd));\n        if (bmHit.y < oculPos.y + 0.02) col += 0.2 * vec3 (1., 1., 0.9) * bmVal;\n      }\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  2  // 4\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, mAzEl, vAzEl;\n  float zmFac, asp, sr, t, tt;\n  int vuId, regId;\n  bool isPano;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (- asp, 1.);\n  disco = true;\n#if N_WIN > 2\n  mMid[2] = (1. - mSize.y) * vec2 (- asp, -1.);\n  mMid[3] = (1. - mSize.y) * vec2 (asp, -1.);\n  disco = false;\n#endif\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  mAzEl = (mPtr.z > 0. && vuId == regId) ? vec2 (2., 1.) * pi * msw : vec2 (0.);\n  if (mPtr.z <= 0.) {\n    t = mod (0.04 * tCur, 2.);\n    t = (abs ((floor (8. * t) + smoothstep (0.8, 1., fract (8. * t))) / 8. - 1.) - 0.5);\n  } else t = 0.;\n  dirCut = 0;\n  isPano = false;\n  if (vuId == 0) {\n    ro = vec3 (0., 0.7, -1.);\n    vAzEl = vec2 (0.25 * pi + mAzEl.x + 0.2 * pi * t, clamp (0.05 * pi + mAzEl.y, -0.37 * pi, 0.37 * pi));\n    zmFac = 1.5;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 1., -15.);\n    vAzEl = vec2 (pi + 1.1 * mAzEl.x + 0.4 * pi * t, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.));\n    zmFac = 6.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 1.2, -0.8);\n    vAzEl = vec2 (1.1 * mAzEl.x, clamp (0.5 *  mAzEl.y, -0.1 * pi, 0.1 * pi));\n    zmFac = 0.3;\n    isPano = true;\n  } else if (vuId == 3) {\n    ro = vec3 (0., 1.2, -10.);\n    vAzEl = vec2 (1.1 * mAzEl.x, 0.);\n    zmFac = 5.;\n    dirCut = 2;\n  } else if (vuId == 4) {\n    ro = vec3 (0., 1.3, -10.);\n    vAzEl = vec2 (-0.5 * pi + 1.1 * mAzEl.x, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.4 * pi));\n    zmFac = 5.;\n    dirCut = 1;\n  }\n  vuMat = StdVuMat (vAzEl);\n  ro = vuMat * ro;\n  if (vuId == 0) ro.y = max (ro.y, 0.2);\n  if (dirCut == 1) {\n    cutVec = vec3 (1., 0., 0.);\n  } else if (dirCut == 2) {\n    cutVec = vec3 (0., 0., -1.);\n    cutVec.xz = Rot2D (cutVec.xz, - vAzEl.x);\n  }\n  tt = 1. - fract (0.05 * tCur);\n  t = SmoothBump (0.25, 0.75, 0.23, tt);\n  bmOrg = vec3 (0., 0.23, 0.);\n  bmRd = 1. * 0.97/12.;\n  if (disco) bmAzEl = pi * vec2 (0.2 * tCur + 2. * Fbm1 (0.2 * tCur),\n     0.8 + 0.14 * cos (2. * pi * t));\n  else bmAzEl = pi * ((tt < 0.5) ? vec2 (0.5 + t, 0.16) : vec2 (0.5, 0.16 * (1. - 2. * t)));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)),\n       uvv.y).xzy : vec3 (2. * tan (0.5 * atan (uvv / vec2 (asp, 1.))) * vec2 (asp, 1.), 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (vec2 vAzEl)\n{\n  vec2 ca, sa;\n  ca = cos (vAzEl);\n  sa = sin (vAzEl);\n  return mat3 (ca.x, 0., - sa.x, 0., 1., 0., sa.x, 0., ca.x) *\n         mat3 (1., 0., 0., 0., ca.y, - sa.y, 0., sa.y, ca.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, cs * vec2 (1., -1.)), dot (q.yx, cs));\n}\n\nvec3 RotVF (vec3 v, vec4 cs)\n{\n  v.yz = Rot2Cs (v.yz, cs.zw * vec2 (1., -1.));\n  v.xz = Rot2Cs (v.xz, cs.xy * vec2 (1., -1.));\n  return v;\n}\n\nvec3 RotVB (vec3 v, vec4 cs)\n{\n  v.xz = Rot2Cs (v.xz, cs.xy);\n  v.yz = Rot2Cs (v.yz, cs.zw);\n  return v;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXSWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1591, 1591, 1625, 1625, 1675], [1677, 1677, 1699, 1699, 7806], [7808, 7808, 7841, 7841, 8025], [8027, 8027, 8048, 8048, 8305], [8307, 8307, 8344, 8344, 8599], [8601, 8601, 8625, 8625, 9519], [9521, 9521, 9557, 9557, 16046], [16048, 16048, 16106, 16106, 16464], [16466, 16466, 16556, 16556, 16910], [16912, 16912, 16947, 16947, 17400], [17402, 17402, 17436, 17436, 18285], [18287, 18287, 18322, 18322, 22053], [22079, 22079, 22135, 22135, 25897], [25899, 25899, 25921, 25921, 25948], [25950, 25950, 25972, 25972, 25999], [26001, 26001, 26023, 26023, 26061], [26063, 26063, 26095, 26095, 26179], [26181, 26181, 26214, 26214, 26298], [26300, 26300, 26346, 26346, 26393], [26395, 26395, 26428, 26428, 26455], [26457, 26457, 26502, 26502, 26594], [26596, 26596, 26641, 26641, 26679], [26681, 26681, 26738, 26738, 26821], [26823, 26823, 26851, 26851, 27033], [27035, 27035, 27065, 27065, 27178], [27180, 27180, 27211, 27211, 27275], [27277, 27277, 27307, 27307, 27417], [27419, 27419, 27449, 27449, 27525], [27527, 27527, 27551, 27551, 27668], [27702, 27702, 27726, 27726, 27786], [27788, 27788, 27812, 27812, 27865], [27867, 27867, 27891, 27891, 28003], [28005, 28005, 28030, 28030, 28176], [28178, 28178, 28203, 28203, 28389], [28391, 28391, 28413, 28413, 28567], [28569, 28569, 28590, 28590, 28745], [28747, 28747, 28776, 28776, 28988], [28990, 28990, 29029, 29029, 29281]], "test": "untested"}
{"id": "DtfSWr", "name": "My friend's profile picture/logo", "author": "jackwitherell", "description": "and used it to make this cut copy and paste audio shader", "tags": ["2d", "sdf", "audio", "soundreactive", "pfp"], "likes": 3, "viewed": 218, "published": 3, "date": "1674539629", "time_retrieved": "2024-07-30T18:13:50.997247", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-vec2(iResolution.x*0.08,0.0))/min(iResolution.x,iResolution.y);\n    vec3 colblue = vec3(4./255.,163./255.,230./255.);\n    vec3 colpink = vec3(235./255.,20./255.,143./255.);\n    colpink = vec3((sin(iTime)/2.0)+1.0,(sin(iTime)/2.0)+0.3,0.0);\n    colblue = vec3(0.0,(sin(iTime)/2.0)+0.3,(sin(iTime)/2.0)+1.0);\n    vec3 col = mix(vec3(1.,1.,1.), mix(colblue,colpink,uv.y), uv.x);\n    \n    vec2 uvjames = (uv-0.5);\n    uv-=length(uvjames)*normalize(uvjames)*texelFetch(iChannel0,ivec2((((atan(-abs(uvjames.x),uvjames.y)/(2.0*3.141592))+1.0)/1.0)*512.0,0),0).x;\n    uv = uv-vec2(0.5,0.5);\n    \n    if(distance(abs(uv.x)+abs(uv.y),0.4)<0.01) col = vec3(0.0);\n    if(distance(abs(uv.x)+abs(uv.y),0.45)<0.005) col = vec3(0.0);\n    if(distance(abs(uv.x)+abs(uv.y),0.35)<0.005) col = vec3(0.0);\n    \n    \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 58, 58, 943]], "test": "untested"}
{"id": "dlfSz4", "name": "Candy Avalanche", "author": "fenix", "description": "40000 fruit-flavored sweets falling down a cube-wall, rendered via voronoi tracking with screen space ambient occlusion.\n\n*mouse to control candy dropper*\n*shift to disable ambient occlusion*\n*alt to disable FXAA*\n*up/down to zoom*", "tags": ["3d", "simulation", "particles", "dynamics", "physics", "ssao"], "likes": 61, "viewed": 726, "published": 3, "date": "1674536573", "time_retrieved": "2024-07-30T18:13:52.152158", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  40000 fruit-flavored sweets falling down a cube-wall, rendered via voronoi tracking\n//  with screen space ambient occlusion.\n//\n//  This shader uses the same ideas as its predecessor, but it improves on them in\n//  several ways:\n//\n//   * SSAO can now be cast by the background. This required the system to consider\n//     the normal of the surface when deciding whether a pixel is occluded.\n//\n//   * SSAO now uses a spiral pattern instead of noise, for a smoother look.\n//\n//   * New particle stability hacks. The hackiest one is to defeat some jitter: I'm only\n//     updating the rendered position of the candies when they move more than a threshold.\n//\n//   * FXAA to smooth out the cube edges.\n//\n//  If your update is slow at all you can try to enable EIGHT_NBS in the common tab.\n//  \n//  Inspired by this vid: https://www.youtube.com/watch?v=heD5492JLRI\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D performs main render, light and SSAO\n//  Image performs FXAA\n//\n// ---------------------------------------------------------------------------------------\n\n// From reinder's  Post process - FXAA\n//    https://www.shadertoy.com/view/ls3GWS\n// he got it from:\n//    http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 AArender( vec2 uv2 )\n{    \n    uv2 /= iResolution.xy;\n    vec2 rcpFrame = 1. / iResolution.xy;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = textureLod(iChannel0, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(iChannel0, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(iChannel0, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(iChannel0, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(iChannel0, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(iChannel0, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (keyDown(KEY_CTRL))\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor.xyz = AArender(fragCoord);\n        \n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .08;\nconst float FAR_CLIP = 1e6;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n// enable for speed if your particle update is too slow\n// this helps it two ways: faster update per particle, plus,\n// less stable so more particles fall off the screen\n#define EIGHT_NBS 0\n\n#if EIGHT_NBS\n#define L_NEIGHBORS 0\n#define R_NEIGHBORS 1\n#define POS 2\n#define RPOS 3\n#define VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n#else\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define RPOS 5\n#define VEL 6\n#define NUM_PARTICLE_DATA_TYPES 7\n#endif\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    vec3 rPos;\n#if EIGHT_NBS\n    ivec4 nbs[2];\n#else\n    ivec4 nbs[4];\n#endif\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n#if EIGHT_NBS\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, L_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, R_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, RPOS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.pos = particleData2.xyz;\n    particle.rPos = particleData3.xyz;\n    particle.vel = particleData4.xyz;\n#else\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, RPOS), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.rPos = particleData5.xyz;\n    particle.vel = particleData6.xyz;\n#endif\n\n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n#if EIGHT_NBS\n    case L_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case R_NEIGHBORS:\n        return vec4(p.nbs[1]);\n#else\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n#endif\n    case POS:  \n        return vec4(p.pos, 0);\n    case RPOS:  \n        return vec4(p.rPos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 40000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;\n    float chuteX;\n    float chuteVel;\n    float lastMouseX;\n    float camDist;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.resolution = -iResolution.x * iResolution.y;\n    state.chuteX = 0.;\n    state.chuteVel = 0.05;\n    state.lastMouseX = 0.;\n    state.camDist = 10.;\n}\n\n#define fxInitState(state) fxInitStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    \n    fxState state;\n    state.resolution = data0.x;\n    state.chuteX = data0.y;\n    state.chuteVel = data0.z;\n    state.lastMouseX = data0.w;\n    state.camDist = data1.x;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n        return vec4(state.resolution, state.chuteX, state.chuteVel, state.lastMouseX);\n    else\n        return vec4(state.camDist, 0, 0, 0);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, 0, 0);\n    cameraPos\t = vec3(3, 1, -3) * state.camDist;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0) *.3,\n        vec4(-0.5*cameraUp, 0.0) * .3,\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft * .3 - screenPos.y * cameraUp * .3);\n}\n\n// SDFS\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rotMat(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat mapCubes(vec3 p)\n{\n    p.y += floor(p.x) - floor(p.z);\n    p.xz = fract(p.xz) - .5;\n\n    float d = sdBox(p, vec3(.5));\n    d = min(d, sdBox(p + vec3(1, -1, 0), vec3(.5)));\n    d = min(d, sdBox(p + vec3(0, -1, -1), vec3(.5)));\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normCubes(vec3 p)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*mapCubes(p + e.xyy) + \n\t\t\t\t\t  e.yyx*mapCubes(p + e.yyx) + \n\t\t\t\t\t  e.yxy*mapCubes(p + e.yxy) + \n\t\t\t\t\t  e.xxx*mapCubes(p + e.xxx) );\n}\n\nvec3 getChutePos(fxState state)\n{\n    return vec3(-1.5 + state.chuteX, 7, 1.5 + state.chuteX);\n}\n\nfloat mapChute(vec3 p, fxState state)\n{\n    return sdCappedCylinder(p - getChutePos(state), 1., 1.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normChute(vec3 p, fxState state)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.0005773;\n    return normalize( e.xyy*mapChute(p + e.xyy, state) + \n\t\t\t\t\t  e.yyx*mapChute(p + e.yyx, state) + \n\t\t\t\t\t  e.yxy*mapChute(p + e.yxy, state) + \n\t\t\t\t\t  e.xxx*mapChute(p + e.xxx, state) );\n}\n\n// G BUFFER\n\n// note there are five dwords here...c is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    if (fragColor.z == 0.) fragColor.z = 1e-3;\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    \n    pix.m = abs(fragColor.z);\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-.005,0);\n\nvoid particleStep(inout fxParticle p, int id, fxState state)\n{\n    // init\n    vec3 h = hash3( uvec3(id, id * iFrame, iFrame) );\n\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init particles in the holding pen\n        p.pos = vec3(0, -10, 0);\n        p.rPos = p.pos;\n        p.vel = vec3(0);\n        \n        return;\n    }\n    \n    // deactivate particles off the screen until we want to drop them\n    if (p.pos.y < -7.)\n    {        \n        if (h.x < .002)\n        {\n            // selected for being dropped from the chute\n            p.pos = getChutePos(state) + vec3(h.y - .5, -.75, h.z - .5);\n            p.vel = vec3(.5*state.chuteVel, -.01, .5*state.chuteVel);\n        }\n        else\n        {\n            // off-screen holding pen\n            p.pos = vec3(0, -10, 0);\n            p.vel = vec3(0);\n        }\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .99; // damping\n    float velMag = length(p.vel);\n    const float MAX_SPEED = .1; // clamping\n    const float MIN_SPEED = .001;\n    if (velMag > MAX_SPEED)\n    {\n        p.vel = p.vel * MAX_SPEED / velMag;\n    }\n    else if (velMag < MIN_SPEED)\n    {\n        p.vel = vec3(0);\n    }\n    p.vel += GRAVITY;\n    p.pos += p.vel; // integrate (this is done before collision so that the rendered results are position-corrected)\n\n    // collide with neighbors\n    bool noColl = true;\n    for (int i = 0; i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            int nid = p.nbs[i][j];\n            if (nid < 0 ) break;\n            fxParticle nb = fxGetParticle(nid);\n            vec3 dir = p.pos - nb.pos;\n            float dist = distance(nb.pos, p.pos) + 0.001;\n            dir = normalize(dir);\n\n            if (dist < PARTICLE_SIZE * 2.)\n            {\n                noColl = false;\n                \n                if (dist < PARTICLE_SIZE * .1)\n                {\n                    // we're overlapping another particle, emergency teleport; use id difference to decide direction\n                    p.pos.x += 2. * PARTICLE_SIZE * (float(id < nid) - .5);\n                    return;\n                }\n\n                float f = 1.; // relVel factor\n                float r = 1.; // restitution\n                if (nb.pos.y < p.pos.y + PARTICLE_SIZE * .3)\n                {\n                    // position correction (only applied on particles below us; stability hack)\n                    p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .5);\n                }\n                else\n                {\n                    // particles above us can barely move us (stability hack)\n                    f = .8;\n                    r = .1;\n                }\n\n                // velocity correction\n                vec3 relVel = p.vel - nb.vel * f;\n                p.vel -= dot(relVel, dir) * dir * r;\n            }\n        }\n    }\n\n    // collide with boundary\n    float boundary = mapCubes(p.pos);\n    if (boundary < PARTICLE_SIZE + .01) // add margin due to SDF_EPSILON, so render and physical boundaries match\n    {\n        vec3 normal = normCubes(p.pos);\n\n        // position correction\n        p.pos += normal * (PARTICLE_SIZE + .01 - boundary);\n\n        // clip velocity\n        p.vel -= min(0., dot(p.vel, normal)) * normal * 1.2;\n    }\n    \n    // sleep particles that didn't move much (stability hack)\n    if (noColl || distance(p.pos, p.rPos) > .05 || length(p.vel) > .01)\n        p.rPos = mix(p.pos, p.rPos, .5);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n#if EIGHT_NBS\n    int dir = int(float(dx.x > 0.) * .5 + .5);\n#else\n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n#endif\n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // consider neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % ((EIGHT_NBS == 1) ? 2 : 4);\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n\n                for (int y = 0; y < 2; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, id, state);\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, RPOS).xyz;\n    float t = sphIntersect(ro, rd, vec4(worldPos, PARTICLE_SIZE));\n        \n    if (t > 0. && worldPos != vec3(0))\n    {\n        return t;\n    }\n    \n    return FAR_CLIP;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            float m = .5 - iMouse.x / iResolution.x;\n            if (iMouse.w < 0.)\n            {\n                state.chuteX = m * 16.;\n                state.chuteVel = m - state.lastMouseX;\n            }\n            \n            state.lastMouseX = m;\n        }\n        else\n        {\n            state.chuteVel -= state.chuteX * .00005;\n            state.chuteX += state.chuteVel;\n        }\n        \n        state.chuteVel *= float(abs(state.chuteX) < 8.);\n        state.chuteX = clamp(state.chuteX, -8., 8.);\n        \n        if (keyDown(KEY_UP)) state.camDist -= .1;\n        if (keyDown(KEY_DOWN)) state.camDist += .1;\n        if (keyDown(KEY_SPACE)) fxInitState(state);\n        \n        state.camDist = clamp(state.camDist, 2., 10.);\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float dis2 = distance2Particle(nid, p, cameraPos, rayDir);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 24u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, cameraPos, rayDir);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, p, cameraPos, rayDir));\n        }\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n\n// draw one ball\nvoid renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.rPos, PARTICLE_SIZE));\n    if (t > 0. && t <= pix.t && p.pos != vec3(0))\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.rPos);\n\n        pix.n = normal;\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.t = t;\n    }\n}\n\nvec3 marchCubes(vec3 p, vec3 rd, out float t)\n{\n    const int MAX_STEPS = 25;\n    const float SDF_EPS = .01;\n    t = dot(p, vec3(1));\n    p += rd * t;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = mapCubes(p);\n        if (abs(d) < SDF_EPS) break;\n        d *= .6;\n        p += d * rd;\n        t += d;\n    }\n    return p;\n}\n\nvec3 marchChute(vec3 p, vec3 rd, out float t, fxState state)\n{\n    const int MAX_STEPS = 15;\n    const float SDF_EPS = .01;\n    t = 0.;\n    p += rd * t;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = mapChute(p, state);\n        if (abs(d) < SDF_EPS) break;\n        p += d * rd;\n        t += d;\n    }\n    return p;\n}\n\nvoid renderScene(vec3 cameraPos, vec3 rayDir, fxState state, inout fxGBufferPixel pix)\n{\n    // march cubes and chute separately, otherwise it takes a lot of steps to get around the chute\n    float cubeT;\n    vec3 cubeHitPos = marchCubes(cameraPos, rayDir, cubeT);\n    vec3 cubeNormal = normCubes(cubeHitPos);\n    \n    float chuteT;\n    vec3 chuteHitPos = marchChute(cameraPos, rayDir, chuteT, state);\n    vec3 chuteNormal = normChute(chuteHitPos, state);\n    \n    if (cubeT < chuteT)\n    {\n        pix.n = cubeNormal;\n        pix.t = cubeT;\n        pix.m = 0.;\n    }\n    else\n    {\n        pix.n = chuteNormal;\n        pix.t = chuteT;\n        pix.m = 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n    \n    // render box\n    renderScene(cameraPos, rayDir, state, pix);\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, cameraPos, rayDir, pix);\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Main render\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\nvec3 materialColor(float c)\n{\n    if (c <= .5) return vec3(1);\n    if (c <= 1.5) return vec3(.25);\n    \n    // sphere colors\n    switch(int(c - 2.) % 5)\n    {\n        case 0: return RGB(255,46,0);\n        case 1: return RGB(221,150,2);\n        case 2: return RGB(4,150,7);\n        case 3: return RGB(48,11,53);\n        case 4: return RGB(140,4,12); \n    }\n}\n\nfloat calcAO(fxGBufferPixel pix, vec2 fragCoord, vec3 sNorm)\n{\n    if (pix.m == 1.) return 1.;// chute doesn't get occluded\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    // sample neighbor pixels\n    float ao = 0.;\n    const float SAMPLES = 20.; // increase for higher quality if your GPU can handle it\n    for( float i=0.; i<SAMPLES; i++ )\n    {\n        // compute an offset in a spiral pattern\n        vec2 off = vec2(.2 + i * 40. / SAMPLES, 0) * rotMat(i * 20. / SAMPLES) / pix.t;\n        off += .1 * sNorm.xy / sNorm.z; // search more in the diretion of surface normal\n\n        // sample the zbuffer at a neightbor pixel\t\t\n        fxGBufferPixel nbPix = fxUnpackGBuffer(texture(iChannel0, (fragCoord.xy) / iResolution.xy + off * .015));\n\n        if (nbPix.m != 1.) // chute doesn't cause occlusion (prevents black halo)\n        {\n            vec2 td = min(vec2(0), 2. * sNorm.xy * off / sNorm.z);\n            float xt = pix.t + td.x + td.y - PARTICLE_SIZE * .0; // expected t based on plane determined by initial point and slope\n\n            // accumulate occlusion\t\n            float dt = xt - nbPix.t;\n            ao += smoothstep(0., .1, dt) * smoothstep(1., .5, dt); // blend out below .1 (not taller) and above .5 (foreground object)\n        }\n    }\n    \n    // average down the occlusion\t\n    return clamp(1. - pow(ao,1.4)/SAMPLES, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel0, fragCoord/iResolution.xy));\n    if (pix.t >= FAR_CLIP)\n    {\n        // background\n        fragColor = vec4(.2);\n    }\n    else\n    {    \n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n        // construct basis for screen-space normal\n        vec3 left = -normalize(cross(rayDir, vec3(0, 1, 0)));\n        vec3 up = normalize(cross(left, rayDir));\n        mat3 basis = mat3(left, up, rayDir);\n\n        // screen-space normal\n        vec3 sNorm = pix.n * basis;\n        \n        float ao = calcAO(pix, fragCoord, sNorm);\n        \n        // lighting\n        const vec3 LIGHT_DIR = normalize(vec3(.5, 1, -.7));\n        float nDotL = max(dot(pix.n, LIGHT_DIR), .0);\n        float dif = ao * (nDotL * .9 + .1) + .1;\n        vec3 reflection = reflect(-LIGHT_DIR, pix.n);\n        float spec = ao * pow(max(dot(pix.n, reflection), 0.), 50.0);\n        fragColor.xyz = materialColor(pix.m) * dif + spec;\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 5.; // multiply with sth for intensity\n    vig = sqrt(vig); // change pow for modifying the extend of the  vignette\n    fragColor *= vig;\n\n    fragColor.a = 1.;\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfSz4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1771, 1771, 1798, 1798, 3647], [3649, 3733, 3756, 3756, 3916], [3918, 3918, 3975, 3975, 4219]], "test": "untested"}
{"id": "ctXXWn", "name": "Abstract noise contours", "author": "fishy", "description": "Tried using fwidth to make antialiased noise contours and this was the result!", "tags": ["noise", "perlin", "contours", "fwidth"], "likes": 16, "viewed": 433, "published": 3, "date": "1674523291", "time_retrieved": "2024-07-30T18:13:52.916115", "image_code": "#define saturate(x) clamp(x,0.0, 1.0)\n#define smooth(x) smoothstep(0., 1., x)\n\n#define PERIOD 10.\n\n#define iTime iDate.w\n\nfloat pulse(float x, float k)\n{\n    return 1.-min(1., abs(fract(x)-0.5)/k);\n}\n\nmat2 r(float t)\n{\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float t)\n{\n    mat2 r = r(t);\n    \n    vec2 tlVal = r*(hash22(vec2(floor(p.x),  ceil(p.y))) - 0.5) * 2.0;\n    vec2 blVal = r*(hash22(vec2(floor(p.x), floor(p.y))) - 0.5) * 2.0;\n    vec2 trVal = r*(hash22(vec2( ceil(p.x),  ceil(p.y))) - 0.5) * 2.0;\n    vec2 brVal = r*(hash22(vec2( ceil(p.x), floor(p.y))) - 0.5) * 2.0;\n    \n    float tl = dot(p - vec2(floor(p.x),  ceil(p.y)), tlVal);\n    float bl = dot(p - vec2(floor(p.x), floor(p.y)), blVal);\n    float tr = dot(p - vec2( ceil(p.x),  ceil(p.y)), trVal);\n    float br = dot(p - vec2( ceil(p.x), floor(p.y)), brVal);\n    \n    return mix(mix(bl, tl, smooth(fract(p.y))), \n               mix(br, tr, smooth(fract(p.y))),\n               smooth(fract(p.x)))*0.5 + 0.5;\n}\n\nfloat vignette(vec2 p, float s)\n{\n    p = 1.-(4.*p*p-4.*p+1.)*s;\n    return p.x*p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float v = perlinNoise(uv*2.+iTime*0.05, iTime*0.2);\n    float fw = fwidth(v);\n    float t = 0.8;\n    vec3 col = (smoothstep(t, t+fw*PERIOD*2., pulse(v*PERIOD, 1.))*0.8+0.2)*vec3(1.000,0.812,0.643);\\\n    col = mix(col.xyz, col.xyy, smoothstep(0., .25, sin(v*6.2831)));\n\n    // Output to screen\n    fragColor = vec4(col*vignette(fragCoord/iResolution.xy, 0.3),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 153, 153, 199], [201, 201, 218, 218, 270], [272, 272, 293, 293, 423], [425, 425, 461, 461, 1168], [1170, 1170, 1203, 1203, 1256], [1258, 1258, 1315, 1365, 1795]], "test": "untested"}
{"id": "dtlXR7", "name": "another clock 6", "author": "jonasfrey", "description": "this clock can be seen at many trainstations in switzerland", "tags": ["classic", "shaderclockdenodev"], "likes": 3, "viewed": 249, "published": 3, "date": "1674517559", "time_retrieved": "2024-07-30T18:13:53.710990", "image_code": "\nfloat f_n_dist_sqr(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\nfloat f_n_dist_rct(vec2 o, float n){\n    n = abs(n);\n    float nx = o.x-n;\n    float ny = abs(o.y);\n    float nd = max(nx, ny);\n    float nx2 = (-1.*o.x)-n;\n    float nd2 = max(nx2, ny);\n    \n    return max(nd, nd2);\n}\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n\n\n//IMPORTANT START, keep the lines with and between IMPORTANT START and IMPORTANT END\n// and add the tag 'shaderclockdenodev' to the shader\n// otherwise the shader will not work on https://shaderclock.deno.dev/\n// also at the moment only the following variables are available iTime, iResolution,fragCoord,iDate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//IMPORTANT END\n\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    // by default the rotation starts between quadrant II and quadrant III\n    // so this rotation compensates one quadrant\n    o_trn_fc_nor_offset = f_o_rotd(o_trn_fc_nor_offset, (1./4.)*2.);\n    \n    o_trn_fc_nor_offset *= 1.2;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.283185;\n    float n_freq_sec = fract(iTime)*n_tau;\n    //float n_t_sec = (iTime);\n    //n_t_sec = floor(iTime);// for snapping handle\n    float n_ang_nor = fract(atan(o_trn_fc_nor_offset.y, o_trn_fc_nor_offset.x)/n_tau);\n    float n_t_yea = (iDate.x);//year-1\n    float n_t_mon = (iDate.y);//month-1\n    float n_t_day = (iDate.z);//day-1\n    float n_t_sec_since_midnight = (iDate.w);//secs since midnight\n    \n    float n_d,n_w, n_dcenter, n_radius, n_pointerstart, n_pointerend, n, n_radians_nor,n_divisor, n_glow; \n    vec2 o;\n    n_dcenter = length(vec2(0.)-o_trn_fc_nor_offset);\n    \n    float n_aa = n_ratio_1to_iresx*6.;\n    \n    //sec\n    n_pointerstart = 0.;\n    n_pointerend = 0.2;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/60.;\n    n_radians_nor = -floor(n_t_sec_since_midnight)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nsec = length(o-o_trn_fc_nor_offset);\n    n_w = 0.01;\n    \n    nsec = smoothstep(n_w+n_aa, n_w, nsec);\n    \n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor-1./4.);\n    \n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor-1./4.);\n    o.x += .12;\n    n_w = 0.002;\n    nsec = f_n_dist_rct(o, 0.21);\n    nsec = smoothstep(n_w+n_aa, n_w, nsec);\n    \n    n_w = 0.018;\n    o = o_trn_fc_nor_offset;\n    nsec += smoothstep(n_w+n_aa, n_w, length(o));\n    \n    \n    n_w = 0.038;\n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor-1./4.);\n    o.x += .32;\n    nsec += smoothstep(n_w+n_aa, n_w, length(o));\n    vec3 o_col_sec = vec3(0.925,0.,0.);\n    nsec = clamp(nsec, 0., 1.);\n    o_col_sec = nsec*o_col_sec;\n    //fragColor = vec4(nsec*o_col_sec, 1.);\n    //return;\n\n    //min\n    n_pointerstart = 0.0;\n    n_pointerend = 0.3;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/n_divisor;\n    n_radians_nor = -floor(n_t_sec_since_midnight/60.)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nmin = length(o-o_trn_fc_nor_offset);\n    n_w = 0.01;\n    nmin = smoothstep(n_w+n_aa, n_w, nmin);\n\n\n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor-1./4.);\n    o.x += .171;\n    n_w = 0.022;\n    nmin = f_n_dist_rct(o, 0.24);\n    nmin = smoothstep(n_w+n_aa, n_w, nmin);\n    \n    //hou\n    float n_radians_nor_hou = -(n_t_sec_since_midnight/60./60./12.);\n    n_radians_nor_hou = -floor(n_t_sec_since_midnight/60./60.)/12.;//make it tick tock!\n    float nhou;\n    \n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor_hou-1./4.);\n    o.x += .09;\n    n_w = 0.022;\n    nhou = f_n_dist_rct(o, 0.15);\n    nhou = smoothstep(n_w+n_aa, n_w, nhou);\n\n    //minutes indicators\n    float nminind;\n    n_radians_nor = floor(n_ang_nor*60.+0.5)/60.;\n    \n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor);\n    float n_xo = .42;\n    o.x -= n_xo;\n    n_w = 0.002;\n    float n_l = 0.012;\n    nminind = f_n_dist_rct(o, n_l);\n    nminind = smoothstep(n_w+n_aa, n_w, nminind);\n    \n    \n    \n    //hours indicators\n\n    n_radians_nor = floor(n_ang_nor*12.+0.5)/12.;\n\n    float nhouind;\n    o = o_trn_fc_nor_offset;\n    o = f_o_rotd(o, -n_radians_nor);\n    o.x -= n_xo-n_l*2.6;\n    n_w = n_w*6.;\n    nhouind = f_n_dist_rct(o, n_l*3.);\n    nhouind = smoothstep(n_w+n_aa, n_w, nhouind);\n    \n    \n    //border\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nborder = length(vec2(0.)-o_trn_fc_nor_offset);\n    nborder=sin(nborder*n_tau+1.5)*0.5+0.5;\n    nborder= pow(nborder, 1./3.);\n    n_w = 0.1;\n    n_aa = n_ratio_1to_iresx*123.;\n    nborder = smoothstep(n_w+n_aa,n_w, nborder);\n    //n = min(pow(nsec,1.),nmin);\n    //n = min(n, nhou);\n    //n = 1.-sqrt(n);\n    //n_glow = 1.;\n    //n = pow(n, 1./n_glow);\n    n = nsec;\n    n += nmin;\n    n += nhou;\n    n += nminind;\n    n += nhouind;\n    \n    n = clamp(n, 0., 1.);\n    //n += nborder;\n    vec3 o_col = o_col_sec + vec3(1.-n);\n    fragColor = vec4(o_col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 66], [67, 67, 103, 103, 285], [286, 286, 327, 327, 522], [525, 835, 892, 908, 5790]], "test": "untested"}
{"id": "dlsXR7", "name": "just a pattern", "author": "jonasfrey", "description": "discovered ", "tags": ["pattern"], "likes": 10, "viewed": 243, "published": 3, "date": "1674514643", "time_retrieved": "2024-07-30T18:13:54.479934", "image_code": "\nfloat f_n_dpat1(vec2 o, float n){\n    o = abs(o);\n    float nd = max(o.x*n, o.y);\n    \n    if(o.x > abs(o.y-n)){\n        return o.x;\n    }\n    return o.y;\n    \n    return nd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 o_fcorig = o_fc;\n    o_fc *= 20.;\n    vec2  o_fc_fract = fract(o_fc)-.5;\n\n    float n_t = iTime*2.;\n    \n    \n    float n_id = atan(floor(o_fc.x), floor(o_fc.y));\n    n_t+=n_id;\n    float n = f_n_dpat1(o_fc_fract, sin(n_t)*0.5+0.5)*2.;\n    n = (sin(n_t+n+n_id*33.)*.5+.7)*n;\n    fragColor = vec4(n);\n    fragColor = sqrt(fragColor);\n    fragColor.rb *= floor(o_fc)/5.;\n    fragColor.gb *= fract(length(fract(o_fc)-.5)+n_t*.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 177], [178, 178, 235, 285, 788]], "test": "untested"}
{"id": "dlsSR7", "name": "index/addr/reference or copy", "author": "jonasfrey", "description": "i just want to know if assigning a object to another does make a copy or copies the index/address/reference of the original object\n\nas i expected in glsl it is not possible to allocate memory\n\nhttps://stackoverflow.com/questions/16888585/how-to-use-point ", "tags": ["glsl"], "likes": 1, "viewed": 176, "published": 3, "date": "1674511204", "time_retrieved": "2024-07-30T18:13:55.253865", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 o_fc_2 = o_fc;// this makes a copy of o_fc and stores it into o_fc_2\n    o_fc_2 *= sin(iTime);\n    fragColor = vec4(length(o_fc));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 314]], "test": "untested"}
{"id": "clfSRM", "name": "Domain coloring w/ level curves", "author": "eo", "description": "An excuse to learn shader stuff...\n\nKeys:\nm               - toggle magnitude levels\np                - toggle phase levels\ntab             - toggle video source\nmouse x    - Interpolate domain warping on/off", "tags": ["video", "warping", "complex", "contours"], "likes": 6, "viewed": 241, "published": 3, "date": "1674506830", "time_retrieved": "2024-07-30T18:13:56.102596", "image_code": "/*\n\nVisualization of the (complex) function:\n\n           z - 1\n  f(z) = ──────────\n         z² + z + 1\n\nTrying to replicate the domain coloring + level curves from:\nhttps://complex-analysis.com/content/domain_coloring.html\n\nThe magnitude & phase level curves (toggle on/off with m, p keys)\nact a bit like grid lines on graph paper, but for polar coordinates.\nClick/drag to the left to see the undistorted xy plane for reference.\n\nSince this function distorts 2d space, the distorted coordinates\ncan be used to sample from images/video. Press tab to see the effect.\nFor a more comprehensive demonstration of this effect,\nI'd recommend the following YouTube video:\nhttps://www.youtube.com/watch?v=CMMrEDIFPZY\n*/\n\n// Control appearance\n#define MAG_LEVELS 4\n#define PHASE_LEVELS 12\n#define LEVELS_CONTRAST 0.25\n#define ZOOM 0.5\n\n\nvec2 calculate_f_of_z(vec2 xy, float zoom) {\n\n    /*\n    Calculates the function f(z) described above\n    \n    We can think of z as an xy coordinate (i.e. vec2),\n    and then just follow the arithimetic rules\n    for complex numbers to get the f(z) result\n    \n    Additional interpolating terms have been added, so that\n    the mouse x controls a 'nice' transistion between applying\n    the function above, versus no function (or f(z) = z)\n    */\n    \n    // Define an interpolating term, controlled by the mouse\n    float t = smoothstep(0.0, 1.0, get_mouse_x_norm(iMouse, iResolution));\n\n    // Calculate the function terms separately for readability\n    vec2 z = xy / zoom;\n    vec2 numer = z - vec2(1, 0)*t;    \n    vec2 z_squared = mult2d(z, z);\n    vec2 denom = (z_squared + z)*t + vec2(1, 0);\n    \n    return div2d(numer, denom);    \n}\n\n\nfloat get_level_scale(vec2 polar_mag_angle, bool enable_mag, bool enable_phase) {\n\n    /*\n    Calculates a scaling term used to darken the resulting image\n    in such a way that magnitude/phase contour lines appear,\n    acting a bit like polar coordinate grid-lines\n    */\n\n    // Set up the number of magnitude & phase levels\n    float mag_level = fract(float(MAG_LEVELS) * polar_mag_angle.x);\n    float phase_level = fract(float(PHASE_LEVELS) * polar_mag_angle.y);\n    \n    // Include mag/phase leveling, based on enabling inputs\n    mag_level = mix(1.0, mag_level, float(enable_mag));\n    phase_level = mix(1.0, phase_level, float(enable_phase));\n    float leveling = mag_level * phase_level;\n    \n    // Adjust scaling for better aesthetics\n    return (1.0 - LEVELS_CONTRAST) + LEVELS_CONTRAST * leveling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read keyboard\n    bool show_video = get_key_toggle(iChannel0, KEY_tab);\n    bool show_mag_levels = !get_key_toggle(iChannel0, KEY_m);\n    bool show_phase_levels = !get_key_toggle(iChannel0, KEY_p);\n\n    // Calculate warped z\n    vec2 cartesian_xy = get_cartesian_coords(fragCoord.xy, iResolution);\n    vec2 f_of_z = calculate_f_of_z(cartesian_xy, ZOOM);\n    vec2 polar = get_polar(f_of_z);\n    \n    // Calculate scaling for constant mag/phase level indicators\n    float level_scale = get_level_scale(polar, show_mag_levels, show_phase_levels);   \n    \n    // Toggle video imagery vs. domain coloring image\n    vec3 out_rgb;   \n    if (show_video) {\n        out_rgb = sample_video_warped(iChannel1, f_of_z * ZOOM, iResolution);\n    } else {\n        vec3 phase_color = angle_to_rgb(polar.y);\n        out_rgb = phase_color * level_scale;\n    }\n    \n    fragColor = vec4(out_rgb, 1.0);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// For clarity\n#define TWOPI 6.28318530718\n#define KEY_tab   9\n#define KEY_m    77\n#define KEY_p    80\n#define is_near_zero(v) abs(v) < 0.0001\n\n\n// From iq:\n// https://www.shadertoy.com/view/ll2GD3\nvec3 angle_to_rgb(float num_0_to_1)\n{\n    vec3 brightness = vec3(0.6);\n    vec3 saturation = vec3(0.525);\n    vec3 rgb_phase = vec3(0.0, 0.33, 0.67);\n    return brightness + saturation * cos( TWOPI * (num_0_to_1 + rgb_phase) );\n}\n\n\n// -------------------------------------------------------------------------------\n// Sampling functions\n\nvec2 get_cartesian_coords(vec2 xy_px, vec3 res) {\n\n    /*\n    Maps xy 'pixel' coordinates (eg. fragCoord or iMouse)\n    into centered normalized cartesian (not stretched) coordinates.\n    Can think of the result as being 'graph paper' coordinates\n    - The center of the screen maps to (0, 0)\n    - The top of the screen has a y value of +1\n    - The bottom of the screen has a y value of -1\n    - The left & right edge x values will be -/+ the aspect ratio (ex: 16/9)\n    */\n\n    return (2.0*xy_px - res.xy) / res.y;\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nfloat get_mouse_x_norm(vec4 mouse, vec3 res) {\n\n    /* Grab mouse x position, between 0 and 1, with some dead space on edges */\n\n    float is_mouse_down = clamp(mouse.z, 0., 1.);\n    float mouse_x_norm = clamp(2.0*mouse.x / res.x - 0.5, 0., 1.);\n    float default_mouse_not_down = 1.0;\n    return mix(default_mouse_not_down, mouse_x_norm, is_mouse_down);\n}\n\nvec3 sample_video_warped(sampler2D channel, vec2 warp_uv, vec3 res) {\n\n    /*\n    Helper used to sample from videos using warped coordinates.\n    The coords are assumed to be calculated on a centered,\n    non-stretched coordinate system, which must be undone\n    to properly sample the video\n    */\n    \n    vec2 aspect_correction = vec2(res.y / res.x, 1.0);\n    vec2 sample_coords = 0.5 * (1.0 + warp_uv * aspect_correction);\n    return texture(channel, fract(sample_coords)).rgb;\n}\n\n\n// -------------------------------------------------------------------------------\n// Functions for complex number arthimetic\n\nvec2 mult2d(vec2 a, vec2 b) {\n\n    /*\n    Multiplication defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    \n    a*b = (ax + i*ay)*(bx + i*by)\n        = ax*bx + ax*i*by + i*ay*bx + i*ay*i*by\n        = ax*bx - ay*by + i*ax*by + i*ay*bx\n        = (ax*bx - ay*by) + i*(ax*by + ay*bx)\n    */\n    \n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);    \n}\n\nvec2 div2d(vec2 a, vec2 b) {\n\n    /*\n    Division defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    b' = bx - i*by  ->  (aka 'b conjugate')\n    \n    a   a   b'  ax + i*ay   bx - i*by \n    ─ = ─ * ─ = ───────── * ─────────\n    b   b   b'  bx + i*by   bx - i*by\n    \n        (ax*bx + ay*by) + i*(ay*bx - ax*by)\n      = ───────────────────────────────────\n                  bx*bx + by*by\n    */\n    \n    // Bail on divide-by-zero\n    if (is_near_zero(b.x) && is_near_zero(b.y)) {\n        return vec2(0,0);\n    }\n\n    float numer_real = a.x*b.x + a.y*b.y;\n    float numer_imag = a.y*b.x - a.x*b.y;\n    float denom = b.x*b.x + b.y*b.y;\n    \n    return vec2(numer_real, numer_imag)/denom;\n}\n\nvec2 get_polar(vec2 xy) {\n    \n    /*\n    Get polar coordinates from xy\n    Resulting magnitude is stored in .x, angle in .y\n    Note, the angle value is unitless, 0 to 1 (not radians!)\n    */\n\n    float magnitude = sqrt(length(xy));\n    float angle_minus_pi_to_pi = atan(-xy.y, xy.x);\n    float angle_norm = angle_minus_pi_to_pi/TWOPI;\n    \n    return vec2(magnitude, fract(angle_norm));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[847, 847, 891, 1360, 1689], [1692, 1692, 1773, 2018, 2503], [2505, 2505, 2562, 2583, 3453]], "test": "untested"}
{"id": "ctlSzM", "name": "Edge detect", "author": "Iliana", "description": "Simple edge sobel edge detect.\nI did not make this code, I simply ported it from [url]https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115[/url]", "tags": ["computervision"], "likes": 4, "viewed": 336, "published": 3, "date": "1674499273", "time_retrieved": "2024-07-30T18:13:56.874531", "image_code": "void make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1./iResolution.x;\n\tfloat h = 1./iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec4 n[9];\n\tmake_kernel( n, iChannel0, I/iResolution.xy );\n\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  \tvec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n\tvec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n\tO = vec4( 1.0 - sobel.rgb, 1.0 );\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 511], [513, 513, 554, 554, 893]], "test": "untested"}
{"id": "DlsSRM", "name": "大龙猫 - Datenacksess", "author": "totetmatt", "description": "Datenacksess", "tags": ["datenacksess"], "likes": 20, "viewed": 470, "published": 3, "date": "1674494935", "time_retrieved": "2024-07-30T18:13:57.807038", "image_code": "float box3(vec3 p,vec3 b){\n    p = abs(p)-b;\n    return length(max(vec3(0.),p))+min(0.,max(p.x,max(p.y,p.z)));\n}\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\n\nfloat txt(vec2 uv){\n    float d = min(length(fract(uv.x)-.5),length(fract(uv.y)-.5))-.1;\n    return max(.05,smoothstep(sqrt(dFdx(d)*dFdx(d)+dFdy(d)*dFdy(d)),0.,abs(d)-.01));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float tt = texture(iChannel0,vec2(.1)).r*.5;\n    vec3 col = vec3(0.);\n    vec3 p,d = normalize(vec3(uv,1.+(-tt+.8)*sqrt(length(uv))));\n    for(float i=0.,e=0.,g=0.;i++<50.;){\n      p  = d*g;\n      float z = p.z;\n      p.z -=10.;;\n      \n    \n      p = erot(p,normalize(vec3(2.*cos(iTime),1.,sin(iTime)*-.66)),floor(iTime*.2)+pow(fract(iTime*.2),.25));\n      \n      float mj=1.;\n      for(float j=0.;j++<5.;){\n        p =abs(p)-vec3(1.7);\n        p*=1.4;\n        \n        mj*=1.4;\n        p = erot(p,normalize(vec3(-.5,5.,1.5*sin(j))),j*j*.785);\n        \n      }\n      float h = box3(p,vec3(1.));\n      h = min(h,min(min(length(p.yz),length(p.xz)),length(p.xy))-0.1);\n      g+=e=max(.001,abs(h/mj));\n      float dd = txt(p.xy)+txt(p.xz)+txt(p.yz);\n      col += (erot(vec3(.1,.2,.3),normalize(vec3(.3,.2+sin(i*5.),.3)),i+iTime+p.z)*(.05+dd*sin(z+iTime)))/exp(i*i*e);\n        \n    }\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 32066, "src": "https://soundcloud.com/r-srecords/ken-ishii-extra-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 112], [113, 113, 147, 147, 201], [203, 203, 222, 222, 378], [379, 379, 434, 434, 1421]], "test": "untested"}
{"id": "mtfSR7", "name": "AtmosphereXXX", "author": "___HackerMann___", "description": "Atmosphere", "tags": ["atmosphere"], "likes": 16, "viewed": 297, "published": 3, "date": "1674484589", "time_retrieved": "2024-07-30T18:13:58.689678", "image_code": "vec3 sphere_centre = vec3(0);\nfloat sphere_radius = 0.4;\n\nvec2 sphere_line_intersection(in vec3 centre, in float radius, in vec3 ray_origin, in vec3 ray_direction) {\n    float dir_sqr = dot(ray_direction, ray_direction);\n    float diff = dot(ray_direction, centre - ray_origin);\n    float sum = dot(ray_origin, ray_origin) + dot(centre, centre) - radius * radius;\n    float discr_sqrt = sqrt(diff * diff - dir_sqr * sum);\n\n    return vec2(\n        diff + discr_sqrt,\n        diff - discr_sqrt\n    ) / dir_sqr;\n}\n\nvec3 get_sphere_normal(in vec3 centre, in vec3 position) {\n    return normalize(position - centre);\n}\n\nvec3 calculate_density(in vec3 centre, in vec3 position, in float radius, in vec3 density_falloff) {\n    float initial_density = 1.0;\n\n    float dist = length(centre - position);\n    return initial_density * (exp(-dist / density_falloff) - exp(-radius / density_falloff));\n}\n\nvec3 calculate_volume(in vec3 ray_origin, in vec3 ray_direction, in float max_dist, in vec3 light_pos) {\n    int   MAX_STEPS = 5000 / 26;\n    float STEP_SIZE = 0.006;\n    vec3  EPS_GAS_VOLUME = vec3(1) / 10000.0;\n    vec3  PLANET_CENTRE = vec3(0);\n    float ATMOSPHERE_RADIUS = 0.65;\n    vec3  DISTANCE_MULTIPLIER = vec3(260, 220, 280) * 3000000.0;\n    \n    vec3 gas_volume = vec3(0.0);\n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 position = ray_origin + dist * ray_direction;\n        vec3 to_light_dir = normalize(light_pos - position);\n        to_light_dir.z *= -1.0;\n        vec2 t = sphere_line_intersection(sphere_centre, sphere_radius, position, to_light_dir);\n\n        vec3 density = max(calculate_density(\n            PLANET_CENTRE,\n            position,\n            ATMOSPHERE_RADIUS,\n            vec3(1, 1.07, 1.13) * 0.1\n        ), vec3(0));\n        \n        vec3 volume = STEP_SIZE * EPS_GAS_VOLUME * density;\n        \n        if (dist > max_dist - STEP_SIZE)\n            break;\n            \n        dist += STEP_SIZE;\n        \n        if (t.x < 1000.0 && 0.0 < t.x)\n            continue;\n            \n        float light_dist = length(light_pos - position);\n        gas_volume += volume / exp(light_dist * 2.0) * DISTANCE_MULTIPLIER;\n    }\n\n    return gas_volume;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ambient_brightness = 0.2;\n    float specular_power = 20.0;\n    float specular_multiplier = 0.4;\n    float gas_color_density = 18000.0;\n    float diffusion_intensity = 40.0;\n    \n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ray_origin = vec3(0, 0, -1);\n    vec3 ray_direction = normalize(vec3(uv, 0) - ray_origin);\n\n    vec2 t = sphere_line_intersection(sphere_centre, sphere_radius, ray_origin, ray_direction);\n    vec3 nearest_hit_pos = ray_origin + t.x * ray_direction;\n\n    vec3 light_pos = 6.0 * vec3(cos(2.0 * iTime), 1, sin(2.0 * iTime));\n    vec3 dir_to_light = normalize(light_pos - nearest_hit_pos);\n    \n    vec3 gas_volume = calculate_volume(ray_origin, ray_direction, t.x, light_pos);\n\n    vec3 normal = get_sphere_normal(sphere_centre, nearest_hit_pos);\n    float light_dist = length(nearest_hit_pos - light_pos);\n    float brightness = diffusion_intensity * max(ambient_brightness, dot(normal, dir_to_light))\n                     / (light_dist * light_dist);\n\n    vec3 reflected = reflect(-ray_direction, normal);\n    float r_dot_l = max(0.0, dot(dir_to_light, reflected));\n    float specular_brightness = pow(r_dot_l, specular_power) * specular_multiplier;\n\n    vec3 color = normal * 0.5 + 0.5;\n    color *= brightness;\n    color += specular_brightness;\n\n    color = clamp(color, 0.0, 1.0);\n    \n    vec3 gas_color = gas_volume * gas_color_density;\n\n    fragColor = vec4(gas_color + color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 165, 165, 511], [513, 513, 571, 571, 614], [616, 616, 716, 716, 890], [892, 892, 996, 996, 2203], [2205, 2205, 2260, 2260, 3743]], "test": "untested"}
{"id": "DtXSRM", "name": "Inside the Mandelbulb", "author": "kishimisu", "description": "My first 3D fractal scene :)", "tags": ["3d", "fractal", "distance", "tracing", "estimator", "path"], "likes": 30, "viewed": 671, "published": 3, "date": "1674481844", "time_retrieved": "2024-07-30T18:13:59.567332", "image_code": "/* \"Inside the Mandelbulb\" by @kishimisu (2023) - https://www.shadertoy.com/view/DtXSRM\n    \n    My third path-tracing scene and first 3D fractal scene!\n    \n    I spent the whole last week exploring, learning and being amazed by\n    fractalforum.org posts from 2013 only wishing I discovered this community \n    sooner. The mandelbulb seems to be a great first step into 3D fractal worlds.\n    \n    Technically we're not inside the mandelbulb, we're looking at one of\n    its edges, however I mirrored it around the surface of a sphere slightly\n    bigger than the fractal boundary. This means that at the center of the scene\n    is the original mandelbulb, but everywhere else is a mirrored/inside out \n    version of the mandelbulb, allowing this feeling of being \"inside\".\n    \n    Finally, this scene has 3 viewpoints and animates every 10 seconds between\n    each of them. You can control this interval in Buffer A.\n    \n    Move the camera with the mouse!\n*/\n\nvec3 ACESFilm(vec3 x) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0., 1.);\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec3 col = texture(iChannel0, F/iResolution.xy).rgb;\n    \n    col *= .5;                   // exposure\n    col = ACESFilm(col);         // tone-mapping\n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    O = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Time to wait before switching viewpoints (in seconds)\n#define T 10.\n\n// Maximum number of ray bounces during the path-tracing loop\n#define BOUNCES 3\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n\n#define iter 200.\n#define max_dist 10.\n#define eps 0.0004\n\n// Viewpoints coordinates\nconst vec2 VP1 = vec2(.45, .7);\nconst vec2 VP2 = vec2(0, -.18);\nconst vec2 VP3 = vec2(-.4, -.4);\n\n// 4-values smoothstep (0->1 between a & b, 1->0 between c & d)\nfloat smooth4(float a, float b, float c, float d, float x) {\n    if (x < b) return smoothstep(a, b, x);\n    if (x < c) return 1.;\n    return smoothstep(d, c, x);\n}\n\n// (Clamped) quadratic rational smoothstep - https://iquilezles.org/articles/smoothsteps/\nfloat qrstep(float x) {\n    x = clamp(x, 0., 1.);\n    return x*x/(2.*x * (x-1.) + 1.);\n}\n\n// I think this is from iq ? Can't find the original version\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// Mandelbulb distance estimator\nfloat orbitTrap;\nfloat mdb(vec3 p) {\n    const float scale = 2.5;\n    p = vec3(p.x, p.z, -p.y)/scale;\n    float lp = length(p); \n    \n    // Magic line that mirrors the mandelulb around a sphere\n    // Uncomment it to see the difference \n    if (lp > 1.1) p = normalize(p) * (2.2-lp);\n    \n    vec3 z = p;\n    float r = length(p), dr = 1.;    \n    orbitTrap = 1e7;\n    \n    //http://blog.hvidtfeldts.net/index.php/2011/09/\n    for (float i = 0.; i < 4.; i++) {\n        if (r > 2.) break;\n        \n        // convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi   = atan(z.y,z.x);\n\t\tdr =  8.*pow(r, 7.)*dr + 1.;\n        \n        // scale and rotate the point\n\t\tfloat zr = pow(r, 8.);\n\t\ttheta = theta*8.;\n\t\tphi   = phi*8.;\n        \n        // convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += p;\n\n        orbitTrap = min(orbitTrap, zr);\n        r = length(z);\n    }\n    \n    return .5*log(r)*r/dr * scale;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) { \n    float t = 0.;\n    for (float i = 0.; i < iter; i++) {\n        vec3  p = ro + t*rd;\n        float d = mdb(p);\n        t += d;\n        \n        if (d < eps || t > max_dist) return t;\n    }\n    return -1.;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(1,-1)*.0001;\n    return normalize(e.xyy*mdb(p + e.xyy) + e.yyx*mdb(p + e.yyx) + \n\t\t\t\t\t e.yxy*mdb(p + e.yxy) + e.xxx*mdb(p + e.xxx));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd, float t) { \n    // Mouse coordinates (clip space)           + handle default mouse position\n    vec2 m  = (iMouse.xy/iResolution.xy*2.-1.)  * step(1., dot(iMouse.xy, iMouse.xy)); \n    \n    // Animate viewpoint\n    vec2 vp = t < T*2. ?\n                mix(VP1, VP2, qrstep(t/T-0.5)) :\n                mix(VP2, VP3, qrstep(t/T-2.5)) ;\n    \n    // Setup ray origin\n    ro = vec3(0, 1.8, 2.04);\n    ro.yz *= rot(vp.y*.7 + m.y*.1);\n    ro.zx *= rot(vp.x*2. + m.x*.2 - .22);\n      \n    // Setup ray direction\n    const vec3 lookAt = vec3(0,2.2,0);\n    vec3 f = normalize(lookAt-ro), \n         r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {  \n    // Animation progression\n    float t = T*4. - abs(mod(iTime + T*1.5, T*8.) - T*4.);\n    bool isAnim = abs(T - abs(t - T*2.)) < T*.48; // True when the camera position is animating\n    \n    // Frame average management\n    float frame = texture(iChannel0, vec2(0)).r;\n    bool  reset = iFrame == 0 || iMouse.z > 1.;     \n    if (all(equal(F-.5, vec2(0)))) {\n        O.r = reset || isAnim ? 3. : (frame + 1.);  \n        return;\n    }\n    \n    // Path-tracing setup\n    float seed = hash(dot(F, vec2(12.9898, 78.233)) + 1113.1*iTime); \n    vec2 of = vec2(hash(seed+13.271), hash(seed+63.216))-0.5;\n    vec2 uv = (2.*(F+of) - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd, t);\n    \n    vec3 col = vec3(0);\n    vec3 lum = vec3(1);\n    float t0;\n    \n    // Path-tracing loop\n    for (int i = 0; i < BOUNCES; i++) {\n        // Get scene intersection\n        float d = raymarch(ro, rd);\n        \n        if (i == 0) t0 = d;\n        if (d < 0.) break;\n        \n        // Calculate hit position and normal\n        vec3 p = ro + d*rd;\n        vec3 n = getNormal(p - rd*eps*2.);\n        \n        // Update ray origin and direction\n        float cseed = seed + 76.2 + 73.1*float(i) + 17.7*iTime;\n        ro = p + n*eps*2.;\n        rd = cosineDirection(cseed, n);\n        \n        // Colorize ray\n        const vec3 lavaCol = vec3(0.96, 0.27, 0);\n        const vec3 glowCol = vec3(.3, .2, 1);\n        const vec3 reflCol = vec3(0.61,0.07,0.07) * .75;\n        \n        float centerMask = smoothstep(1., .6, length(p - vec3(0,2.2,0)));\n        float lavaMask = 3.*smoothstep(.4,.5, .06+abs(orbitTrap-.5) - smoothstep(0., 1.5, p.y-1.6));\n        float glowMask = 3.*pow((1.+centerMask)*smoothstep(.04, .03, orbitTrap), 4.);\n        glowMask = min(25., glowMask);\n        \n        float reflMask = smooth4(.03, .045, .045, .06, orbitTrap-.1) +\n                         smooth4(.5, .9, 1.7, 1.8, orbitTrap);\n              \n        vec3 albedo   = lavaCol*.6 + .4;\n        vec3 emissive = lavaMask * lavaCol + \n                        glowMask * glowCol + \n                        reflMask * reflCol ;\n  \n        col += emissive*lum;\n        lum *= albedo;\n    }\n    \n    // Apply fog\n    col = mix(vec3(0,.01,.03), col, exp2(-t0*.8));\n        \n    if (reset) O.rgb = col;\n    else {\n        // Average frames\n        vec3 ocol = texture(iChannel0, F/iResolution.xy).rgb;\n        O.rgb = mix(ocol, col, isAnim ? .16 : 1./frame);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[967, 967, 990, 990, 1068], [1070, 1070, 1109, 1109, 1348]], "test": "untested"}
{"id": "clXSR7", "name": "Basic Waveforms", "author": "MysteryPancake", "description": "All waveforms found in the common tab, feel free to use!\nPhases are aligned and DC offset is 0. Amplitude is maximum without distortion (0 decibels), multiply to reduce volume.", "tags": ["2d", "pulse", "basic", "sound", "wave", "triangle", "audio", "primitives", "square", "sine", "1d", "waveform", "shape", "saw", "tri", "sawtooth", "gpusound"], "likes": 12, "viewed": 376, "published": 3, "date": "1674474278", "time_retrieved": "2024-07-30T18:14:00.348244", "image_code": "// See \"Common\" tab for all waveform definitions!\n\nvec3 drawWave(float x, float p) {\n\n    const vec3 red = vec3(1.0, 0.0, 0.0);\n    const vec3 yellow = vec3(1.0, 1.0, 0.0);\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    vec3 color = (x > 0.0 ? green : red) * smoothstep(1.5, 1.0, abs(p));\n    float mask = 0.01 / min(abs(p - 1.0), abs(p + 1.0));\n    float wave = 0.04 / abs(x - p);\n    return color * (min(mask, 1.0) * 0.5 + 0.15) + wave;\n}\n\nfloat timeRange(float start) {\n    return step(fract(iTime * 0.2 - start), 0.2) * 16.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float freq = 0.25;\n    vec2 uv = 18.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    fragColor.rgb = drawWave(waveSine(freq, uv.x - timeRange(0.0) * iTime), uv.y - 7.0);\n    fragColor.rgb += drawWave(waveSquare(freq, uv.x - timeRange(0.2) * iTime), uv.y - 3.5);\n    fragColor.rgb += drawWave(waveTriangle(freq, uv.x - timeRange(0.4) * iTime), uv.y);\n    fragColor.rgb += drawWave(waveSaw(freq, uv.x - timeRange(0.6) * iTime), uv.y + 3.5);\n    \n    float duty = sin(iTime * 4.0) * 0.25 + 0.5;\n    fragColor.rgb += drawWave(wavePulse(freq, uv.x - timeRange(0.8) * iTime, duty), uv.y + 7.0);\n}", "image_inputs": [], "common_code": "// Sine wave. The constant here is Tau (2 * PI)\nfloat waveSine(float freq, float time) {\n    return sin(6.28318530 * freq * time);\n}\n\n// Square wave. ceil() has less error than sign().\nfloat waveSquare(float freq, float time) {\n    return ceil(0.5 - fract(freq * time)) * 2.0 - 1.0;\n}\n\n// Triangle wave\nfloat waveTriangle(float freq, float time) {\n    return abs(fract(freq * time - 0.25) - 0.5) * 4.0 - 1.0;\n}\n\n// Sawtooth wave\nfloat waveSaw(float freq, float time) {\n    return fract(freq * time + 0.5) * 2.0 - 1.0;\n}\n\n// Pulse wave. Duty cycle is 0 to 1.\nfloat wavePulse(float freq, float time, float duty) {\n    return step(fract(freq * time), duty) * 2.0 - 1.0;\n}", "sound_code": "vec2 mainSound(int samp, float time) {\n\n    const float freq = 200.0;\n    time = mod(time, 5.0);\n    \n    float result = 0.0;\n    if (time < 1.0) {\n        result = waveSine(freq, time);\n    } else if (time < 2.0) {\n        result = waveSquare(freq, time);\n    } else if (time < 3.0) {\n        result = waveTriangle(freq, time);\n    } else if (time < 4.0) {\n        result = waveSaw(freq, time);\n    } else {\n        float duty = sin(time * 4.0) * 0.25 + 0.5;\n        result = wavePulse(freq, time, duty);\n    }\n    return vec2(result * 0.1);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 84, 84, 446], [448, 448, 478, 478, 537], [539, 539, 594, 594, 1212]], "test": "untested"}
{"id": "DlXXz7", "name": "Kelvin waves / ship waves - golf", "author": "FabriceNeyret2", "description": "Semi-analytic Kelvin waves, in deep water conditions ( w=sqrt(gk), group velocity = 1/2 phase velocity ).\n\nMouse.x controls boat size ( in facts, the max of waves emission spectrum ).\nMouse.y controls the width of emission spectrum.\n(0,0) : auto-demo", "tags": ["2d", "waves", "water", "fluid", "physics", "2tweets", "short", "wake"], "likes": 17, "viewed": 542, "published": 3, "date": "1674467489", "time_retrieved": "2024-07-30T18:14:01.173038", "image_code": "// golfing 480 chars https://shadertoy.com/view/4llBRl\n// ( see original for comments )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2  R = iResolution.xy,  \n          M = length(iMouse.xy) > 10. ? iMouse.xy / R : vec2(.55,.7);\n    float d = 2./R.y, x, l,v;                          \n    \n    for( O *= x = 0. ; x < 5.; x += d ) \n        l = length( ( u+u - R ) / R.y  - vec2( x-1.2, .2* sin(x+x-iTime) ) ), \n        v = ( l - 2.*M.x ) / exp2(7.+5.*M.y),\n        O -=  cos( 27.8 * x / sqrt(l) ) / l  / exp(v*v*3e6) *d *.34;\n\n    O += .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 127, 127, 538]], "test": "untested"}
{"id": "ctfXzM", "name": "Flower mosaic", "author": "jarble", "description": "A flower mosaic pattern.", "tags": ["fractal", "flower", "mosaic"], "likes": 8, "viewed": 231, "published": 3, "date": "1674447483", "time_retrieved": "2024-07-30T18:14:01.953951", "image_code": "vec2 triangle_wave(vec2 a){\n    //a -= .5;\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvec3 image1(vec2 uv,float sign1){\n    float scale = 1.5;\n    vec3 col = vec3(0.);\n    bool t3 = false;\n    uv /= 8.*8.;\n    for(int k = 0; k < 21; k++){\n        t3 = uv.x > uv.y || !t3;\n        //uv *= -1.;\n        uv =\n            triangle_wave(uv-.5)/1.5+triangle_wave(uv.yx)\n        ;\n        //uv *= -1.;\n        //if(uv.y>uv.x){uv=uv.yx;}\n        \n        //if(uv.x>0.5)\n        col.x = uv.y-uv.x;\n        if(t3) {col = col.yzx;uv=uv.yx;}\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 16.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    fragColor = vec4(abs(image1(uv,1.))*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/b),8.); i++){\n        a += mod(floor(a/b),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    return mod(floor(a),b);\n}\n\nvec2 mainSound(int samp, float time){\n  \n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time/4.)/4.,2.); }\n  \n  //time *= 2.;\n  float s1 =\n      5.,\n\n  s2 = 7.,\n  t=time,\n  m1 =\n      fmod(time,s2)\n  ;\n  for(int i = 0; i < 5; i++){\n      t = t/(1.+fmod(m1+floor(t/2.),2.));\n      //t = t/(1.+fmod(m1+floor(t-m1)/s1,2.));\n      //i /= int(1.+mod(floor(t)*2.,2.));\n  }\n  \n  float\n  m4 =\n      fmod(t*s1+s1,s2)\n  ,\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s2)\n      //fmod((t+m4)*s1/(m1+.5+fmod(t*s1,s1)),s2)\n  ;\n\n  t *=\n      s1*s1\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1);\n  ;\n  \n  float a=\n      pow(log(.125+((fract(t/s1)/4.))),2.)\n  ;\n  \n  float nb = time*pow(2.,(7.+m3+m2-m1)/5.+6.5)/2.;\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb*2.)))*2.*a\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 42, 92], [94, 94, 127, 127, 561], [563, 563, 620, 620, 813]], "test": "untested"}
{"id": "DlXXRM", "name": "Ripple Circles", "author": "hnrq", "description": "Learning how to shade", "tags": ["newbie", "ripple"], "likes": 1, "viewed": 194, "published": 3, "date": "1674440997", "time_retrieved": "2024-07-30T18:14:02.806670", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 cPos = ( 2. * fragCoord -  iResolution.xy ) / iResolution.y;\n    float cLength = length(cPos);\n\n    vec2 uv = fragCoord.xy / iResolution.xy + (cPos / cLength) * cos(cLength * 12.0 - iTime * 4.0);\n    float strength = smoothstep(100./iResolution.y, 0., distance(uv, vec2(0.5)));\n\n    fragColor = vec4(vec3(strength), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 390]], "test": "untested"}
{"id": "mtXXzN", "name": "FlowFlowFlow", "author": "JB_0x0003", "description": "flow", "tags": ["flow"], "likes": 4, "viewed": 157, "published": 3, "date": "1674428417", "time_retrieved": "2024-07-30T18:14:03.575615", "image_code": "float random2d(vec2 seed){\n\n\n    float val = fract(sin(\n                    dot(seed, vec2(12.9898,78.233))\n                                ) * 40000.0);\n    \n    return val;\n    \n\n}\n\nfloat noise2d(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random2d( i + vec2(0.0,0.0) ),\n                     random2d( i + vec2(1.0,0.0) ), u.x),\n                mix( random2d( i + vec2(0.0,1.0) ),\n                     random2d( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv.y *= 4.0;\n    \n    uv += 1.0;\n\n    uv = rotate2d(noise2d(uv.yx + min(0.0, (3.0 - (uv.x + uv.y) * 2.0  ) ) + iTime * 0.2 ) * 2.0) * uv;\n\n\n    float value = (sin(uv.y * 6.28318) + 1.0) * 0.5;\n    float pulse = (sin(uv.x * 3.1415 - iTime) + 1.0) * 0.5;\n    \n    //pulse = smoothstep(0.0,0.1,pulse);\n    \n    pulse = 1.11 - pulse * 0.3;\n    pulse = min(pulse, 1.0);\n    value *= pulse;\n    \n    value = smoothstep(0.8,1.0,value);\n    vec3 col = value * 0.7 * (\n                    sin( uv.x + vec3(0,1,2) - iTime / 3.1415)\n                    +1.0 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 182], [184, 184, 208, 208, 514], [516, 516, 543, 543, 625], [629, 629, 686, 686, 1342]], "test": "untested"}
{"id": "dtlXRN", "name": "dot instead of length", "author": "jonasfrey", "description": "dot product also gives a circle", "tags": ["dot"], "likes": 1, "viewed": 187, "published": 3, "date": "1674427631", "time_retrieved": "2024-07-30T18:14:04.340570", "image_code": "float  f_n_dotproduct(vec2 o_p1, vec2 o_p2){\n    return (\n        o_p1.x * o_p2.x \n        + o_p1.y * o_p2.y\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mo = (iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n\n    float n_dist = length(o_fc-o_mo);\n    if(o_fc.x > o_mo.x){\n        n_dist = f_n_dotproduct(o_fc-o_mo,o_fc-o_mo);\n    }\n    \n    fragColor = vec4(\n        smoothstep(0.1, 0.2,n_dist)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 117], [118, 118, 175, 225, 548]], "test": "untested"}
{"id": "clsSRN", "name": "Stochastic Depth Compositing", "author": "technobaboo", "description": "testing if you can blend stuff using noise to avoid the compositing hell that is alpha blending", "tags": ["noise", "flicker", "translucency"], "likes": 2, "viewed": 431, "published": 3, "date": "1674423396", "time_retrieved": "2024-07-30T18:14:05.458581", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // convert to sRGB, then output\n    // pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n    \n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_DEPTH 1000.\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec2 img_uv(vec2 fragCoord, vec2 resolution) {\n    return mod((fragCoord - resolution.xy) / resolution.xy, 1.);\n}\nvec3 heatmap(float level) {\n    level = clamp(level, 0.0, 100000000000.);\n    level *= 3.14159265/2.;\n    return vec3(sin(level), sin(level*2.), cos(level));\n}\n// all hail the GOD TIER noise algorithm: https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat InterleavedGradientNoise(vec2 pixel, int frame) {\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// The good stuff!\nvec4 depthComposite(vec4 surf0, vec4 surf1) {\n    return mix(surf0, surf1, float(surf0.a >= surf1.a));\n}\nvec4 alphaDither(vec4 surf, float alpha, vec2 pixelCoord, int frame, int seed) {\n    float alphaDither = InterleavedGradientNoise(pixelCoord, frame);\n    \n    return vec4(surf.rgb, map(float(alphaDither < alpha), 0.0, 1.0, MAX_DEPTH, surf.a));\n}\n", "buffer_a_code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n    \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    float balls = sphereSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, inout float closestDistance, out float closestDepth) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if(dist < closestDistance){\n            closestDepth = depth;\n        }\n        closestDistance = min(closestDistance, dist);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float closestDistance = MAX_DEPTH;\n    float closestDepth = MAX_DEPTH;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DEPTH, closestDistance, closestDepth);\n    \n    // Debug\n    // fragColor = vec4(vec3(closestDepth * 0.05), 0.0);\n    // return;\n    \n    if (dist > MAX_DEPTH - EPSILON) {\n        // Didn't hit anything\n        fragColor = alphaDither(vec4(vec3(1.0), closestDepth), map(closestDistance, 0.1, 0.0, 0.0, 1.0), fragCoord, iFrame, 1);\n        // fragColor = vec4(vec3(closestDistance), 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, dist);\n}", "buffer_a_inputs": [], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// #define AA // Comment to deactivate antialiasing\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x-.25)\n\nvec3 rdrCirc(vec2 uv, float t)\n{\n    vec3 col = vec3(0.);\n    vec2 ouv = uv;\n    float rep = .03;\n    float id = floor((uv.y+rep*.5)/rep);\n    uv.y = mod(uv.y+rep*.5,rep)-rep*.5;\n    uv.x += id;\n    float cl = .1;\n    float h = clamp(asin(sin(uv.x*5.)), -cl, cl)/cl;\n    float line = abs(uv.y-h*0.01)-.001;\n    vec3 rgb = mix(vec3(.4,.3,.7), vec3(.4,.6,.9).zxy, sat(sin(id)));\n    rgb *= 1.-sat((abs(ouv.x+(fract(id*.1)-.5)+mod(t*.75+.5*id,4.)-2.)-.2)*4.);\n    col = mix(col, rgb,1.-sat(line*iResolution.x*.5));\n        col += .5*rgb*(1.-sat(line*80.));\n    return col;\n}\nvec3 rdrCircuit(vec2 uv)\n{\n    vec3 col = rdrCirc(uv, iTime);\n    col += rdrCirc(uv+vec2(0.,.2), iTime*.7);\n    col += .5*rdrCirc(2.*uv+vec2(0.,.1), iTime*.5).zxy;\n    col += .15*rdrCirc(4.*uv+vec2(0.,.1), iTime*.25).yzx;\n    return col;\n}\n\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    //acc = _min(acc, vec2(length(p)-2., 0.));\n    float h = .2;\n    acc = _min(acc, vec2(-p.y-.2*clamp(asin(sin(p.z*3.)),-h,h), 0.));\n    return acc;\n}\n\nvec3 getEnv(vec3 rd)\n{\n    rd.xy *= r2d(.5);\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float gradf = 3.;\n    vec3 up = mix(vec3(0.161,0.055,0.239),vec3(0.639,0.059,0.341), sat(uv.y*gradf));\n    vec3 low = mix(vec3(0.161,0.055,0.239),vec3(0.157,0.345,0.337), sat(-uv.y*gradf));\n    vec3 back = mix(low, up, float(uv.y > 0. ? low : up));\n\n    float stars = pow(texture(iChannel2, uv*4.).x, 10.);\n    \n    uv.x *= 1.75;\n    float an = iTime*.1+atan(uv.y+.1, uv.x+.1);\n    back += .25*((.35*vec3(0.945,0.220,0.310)*sat(sin(an*12.)+.8))*(1.-sat(length(uv*2.)))+\n    .5*vec3(0.945,0.263,0.216)*sat(sin(-iTime*.05+an*7.+1.)+.7)*(1.-sat(length(uv*1.5)))+\n    .5*vec3(1.000,0.533,0.502)*sat(sin(an*5.)+.5)*(1.-sat(length(uv*1.)))).zxy;\n    \n        float rep = 0.05;\n    vec2 uv2 = uv-vec2(0.,-0.35);\n    uv2 *= 1.5;\n    float id = floor((uv2.x+rep*.5)/rep);\n    uv2.x = mod(uv2.x+rep*.5,rep)-rep*.5;\n    float height = pow(FFT(abs(id*.01)),1.);\n    float shape = max(abs(uv2.y)-height, abs(uv2.x)-0.001);\n    vec3 rgbs = mix(vec3(0.208,0.675,0.431)*0., vec3(0.180+sin(id+iTime)*.5+.5,0.820,0.659+sin(-id+iTime)*.5+.5), sat((abs(uv2.y))*10.));\n    back += rgbs*(1.-sat(shape*400.))*(1.-sat(abs(uv.x*2.)-.5));\n    \n    float psz = .25;\n    uv += vec2(.2,-0.1);\n    uv *= r2d(2.5);\n    float planet = length(uv)-psz;\n    vec3 col = back+stars*vec3(0.580,0.804,0.820)*.5;\n    vec3 planetrgb = vec3(0.161,0.055,0.239)*.75\n    +vec3(0.961,0.000,0.192)*pow(texture(iChannel1,vec2(-iTime*.02,0.)+uv*5.*length(uv)).x,3.)*sat(uv.y*5.);\n    planetrgb += vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.001)*50.))*sat(uv.y*5.);\n    col = mix(col, planetrgb, 1.-sat(planet*400.));\n    col += .8*vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.01)*10.))*sat(uv.y*5.);\n    col += vec3(1.000,0.314,0.141)*(1.-sat(planet*100.))*.15;\n    \n    col += .25*rgbs*(1.-sat(shape*10.))*(1.-sat(abs(uv.x*2.)-.5))*sat(planet*10.);\n    uv.y *= 3.5-2.*uv.y;\n    float anr = atan(uv.y, uv.x); // ring\n    float ring = abs(length(uv)-.4)-.1;\n    col += sat(uv.y+.15)*(1.-sat(ring*100.))*texture(iChannel2, vec2(length(uv), anr*.01)).xxx;\n    return col;\n}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*4.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    return vec3(.1);\n}\n\nvec4 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(5.,-5.0,-0.1);\n    vec3 ta = vec3(0.,-4.25,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float d = 100.;\n    vec3 res = trace(ro, rd, 64);\n    \n    if (res.y > 0.)\n    {\n    d = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        float move = p.x+iTime;\n        float river = (abs(p.z-sin(move*1.)*.5-sin(move*.5)*2.)-1.5);\n        float spec = 1.;//mix(.25,1.,1.-sat(river*400.));\n        float gloss = .05;//mix(.5,.05, 1.-sat(river*400.));\n        vec3 refl = normalize(reflect(rd, n)+gloss*(vec3(rand(), rand(), rand())-.5));\n        vec3 resrefl = trace(p+n*0.01, refl, 32);\n        vec3 reflec = vec3(0.);\n        float gridrep = 1.;\n        vec2 griduv = vec2(move, p.z);\n        griduv = mod(griduv+gridrep*.5,gridrep)-gridrep*.5;\n        float gridth = .001;\n        float grid = min(abs(griduv.x)-gridth, abs(griduv.y)-gridth);\n        //col += sat(river*400.)*vec3(0.220,0.800,0.412)*(1.-sat(grid*40.))*(1.-sat(res.y/10.));\n        col += rdrCircuit(vec2(p.x, p.z)*.1);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n\n            reflec=getMat(resrefl, refl, prefl, nrefl);\n        }\n        else\n            reflec=getEnv(refl);\n        col += reflec*spec;\n    } else {\n        col = getEnv(rd);\n        res.y = MAX_DEPTH - 1.0;\n    }\n    col += vec3(0.816,0.541,1.000)*(1.-sat(exp(-d*0.2+.5)))*sat(rd.y*1.+.5);\n    col += .5*vec3(1.000,0.314,0.141)*(1.-sat(exp(-d*0.2+1.5)))*sat(rd.y*3.+.5);\n    \n    col += vec3(0.302,0.698,1.000)*pow(1.-sat(abs((rd.y-.05)*15.)),2.)*(1.-sat(abs(rd.z)));\n    return vec4(col, res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel2,uv).x;\n    seed+=fract(iTime);\n    vec4 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n    #ifdef AA\n    if (true)// Not so cheap antialiasing\n    {\n        vec3 acc = col.rgb;\n        acc += rdr(uv+off.xx).rgb;\n        acc += rdr(uv+off.xy).rgb;\n        acc += rdr(uv+off.yy).rgb;\n        acc += rdr(uv+off.yx).rgb;\n        col.rgb = acc/5.;\n        \n    }\n    #endif\n    col.rgb *= 1.-sat(length(uv*1.5));\n    col.rgb = pow(col.rgb, vec3(1.2));\n   col.rgb *= sat(iTime-1.);\n    col.rgb = mix(col.rgb, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz,.5);\n       col.rgb = pow(col.rgb, vec3(1.15));\n    col.rgb = sat(col.rgb);\n\n    fragColor = col.zxxw;\n}", "buffer_b_inputs": [], "buffer_c_code": "//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n\n//-----------------------------------------------------------------------------\n// Main functions\n//-----------------------------------------------------------------------------\nfloat scene(vec3 p)\n{\t\n\treturn .1-length(p)*.05+fbm(p*.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/ iResolution.y;\n\n\t#if 0\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    #else\n\tvec2 mo = vec2(iTime*.1,cos(iTime*.25)*3.);\n\t#endif\n\n    // camera by iq\n    vec3 org = 25.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7-1.0*(mo.y-1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - org);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 dir = normalize( v.x*uu + v.y*vv + 1.5*ww );\n\tvec4 color=vec4(vec3(0.0), MAX_DEPTH);\n\t\n\t\n\t\n\tconst int nbSample = 32;\n\tconst int nbSampleLight = 12;\n\t\n\tfloat zMax         = 40.;\n\tfloat step         = zMax/float(nbSample);\n\tfloat zMaxl         = 20.;\n\tfloat stepl         = zMaxl/float(nbSampleLight);\n    vec3 p             = org;\n    float T            = 1.;\n    float absorption   = 100.;\n\tvec3 sun_direction = normalize( vec3(1.,.0,.0) );\n    float a = 0.0;\n    \n\tfor(int i=0; i<nbSample; i++)\n\t{\n\t\tfloat density = scene(p);\n\t\tif(density>0.)\n\t\t{\n\t\t\tfloat tmp = density / float(nbSample);\n\t\t\tT *= 1. -tmp * absorption;\n\t\t\tif( T <= 0.01)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t\n\t\t\t //Light scattering\n\t\t\tfloat Tl = 1.0;\n\t\t\tfor(int j=0; j<nbSampleLight; j++)\n\t\t\t{\n\t\t\t\tfloat densityLight = scene( p + normalize(sun_direction)*float(j)*stepl);\n\t\t\t\tif(densityLight>0.)\n                \tTl *= 1. - densityLight * absorption/float(nbSample);\n                if (Tl <= 0.01)\n                    break;\n\t\t\t}\n\t\t\t\n\t\t\t//Add ambiant + light scattering color\n            vec4 particle = vec4(1.)*50.*tmp*T +  vec4(1.,.7,.4,1.)*80.*tmp*T*Tl;\n            a += particle.a;\n            vec4 particleDithered = alphaDither(vec4(particle.rgb + color.rgb, length(p)), a, fragCoord, iFrame, 2);\n\t\t\tcolor = depthComposite(color, particleDithered);\n            //color = particle;\n\t\t}\n\t\tp += dir*step;\n\t}    \n\n    fragColor = color;\n\n}\n", "buffer_c_inputs": [], "buffer_d_code": "#define SHAPE_ALPHA 1.0\n\nvec4 composite(vec2 uv) {\n    vec4 shape = texture(iChannel0, uv);\n    vec4 tron = texture(iChannel1, uv);\n    vec4 volume = texture(iChannel2, uv);\n    vec3 center = texture(iChannel0, uv).rgb;\n    \n    return depthComposite(depthComposite(volume, tron), shape);\n}\n\nconst float a = 0.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = composite(uv);\n    return; // disable TAA\n    \n    vec2 delta = vec2(1.0) / iResolution.xy;\n    \n    vec2 offsets[9];\n    offsets[0] = vec2(-1.0, 1.0) * delta;\n    offsets[1] = vec2( 0.0, 1.0) * delta;\n    offsets[2] = vec2( 1.0, 1.0) * delta;\n    offsets[3] = vec2(-1.0, 0.0) * delta;\n    offsets[4] = vec2( 0.0, 0.0) * delta;\n    offsets[5] = vec2( 1.0, 1.0) * delta;\n    offsets[6] = vec2(-1.0,-1.0) * delta;\n    offsets[7] = vec2( 0.0,-1.0) * delta;\n    offsets[8] = vec2( 1.0,-1.0) * delta;\n\n    vec3 mn = vec3(100000);\n    vec3 mx = vec3(-100000);\n    for(int i=0;i<9;i++)\n    {\n        vec3 s = composite(uv + offsets[i]).rgb;\n        mn = min(mn, s);\n        mx = max(mx, s);\n    }\n    \n    vec3 h = texture(iChannel3, uv).rgb;\n    h = clamp(h, mn, mx);\n    \n    vec3 c = composite(uv).rgb;\n    \n    // History\n    fragColor = vec4(mix(c, h, a),1.0);\n    \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 287]], "test": "untested"}
{"id": "dllSR4", "name": "carving a sphere in a cube", "author": "FabriceNeyret2", "description": "How to carve a sphere trapped into a cube ( in wood, soap of potatoe ) : first steps.\n( I use a drill for extremities then a scroll saw to hollow the band in between ).\nmouse controls camera\n", "tags": ["raymarching", "short"], "likes": 14, "viewed": 331, "published": 3, "date": "1674420429", "time_retrieved": "2024-07-30T18:14:06.306314", "image_code": "\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n\n#define H(a)        a.z < .7 ? abs(.7*(a.x+a.y)-1.1) - .1 : 9. \n/**  // with drill marks                  \n#define H(a)        min( length(a.yz-.6) -.15 ,                       \\\n                    min( a.z<.7 ? abs(.7*(a.x+a.y)-1.)-.05 : 9.,      \\\n                         a.y<.7 ? abs(.7*(a.x+a.z)-1.)-.05 : 9.  ) )\n/**/                    \n/**  // with more drill marks                           \n#define H(a)  min(  min( length(a.yz-.7) , min( a.z<.6 ? abs(.7*(a.x+a.y)-1.2)+.15 : 9.,      \\\n                                                a.y<.6 ? abs(.7*(a.x+a.z)-1.2)+.15 : 9.  ) ), \\\n                    min( length(vec2(a.y,.7*abs(a.x+a.z))-.7) ,                     \\\n                         length(vec2(.7*abs(a.x+a.y),a.z)-.7))   ) -.2\n/**/                         \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n          \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, \n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        a = abs(q),\n        t = max( max(a.x, max(a.y,a.z)) - 1.,              // cube\n                -min( H(a), min(H(a.yzx),H(a.zxy) )) ),    // holes\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n    O *= O*O*1.5;                                          // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 855, 891, 891, 1759]], "test": "untested"}
{"id": "cllXzN", "name": "Prism 2D", "author": "QuantumSuper", "description": "March ray, reflect, refract, repeat. As in light so does darkness.", "tags": ["raymarch", "refraction"], "likes": 14, "viewed": 350, "published": 3, "date": "1674416553", "time_retrieved": "2024-07-30T18:14:07.078250", "image_code": "//Prism v0.5-220122\n\n// Not entirely accurate 2D prism.\n\n#define PI3 1.0471975512\n#define MAX_STEPS 100\n#define MAX_DIST 1.\n#define MIN_DIST 0.02\nvec3[3] lines;\n\nfloat rect2(vec2 myVar, vec2 lim1, vec2 lim2){\n    return dot(step(min(lim1,lim2),myVar),step(myVar,max(lim1,lim2)));\n}\n\nfloat sRect2(vec2 myVar, vec2 lim1, vec2 lim2){\n    vec2 myMin = min(lim1,lim2);\n    vec2 myMax = max(lim1,lim2);\n    return dot(smoothstep(myMin,myMin+.05,myVar),smoothstep(myMax,myMax-.05,myVar));\n}\n\nfloat getLine(vec2 pos, vec3 def){ //def: x,y,c\n\treturn dot(def, vec3(pos, 1.)); //=0\n}\n\nfloat getDist(vec2 pos){\n\tfloat minDist = MAX_DIST;\n    float someDist;\n\t\n\tfor (int n=0; n<3; n++){\n\t\tminDist = min(minDist, abs(getLine(pos, lines[n])));\n\t}\n\t\n\treturn minDist;\n}\n\nvec2 guessNormal(vec2 pos){\n\tvec2 tangent = vec2(MIN_DIST, 0);\n\t\n\tvec2 normal = getDist(pos) - vec2(\n\t\tgetDist(pos-tangent.xy),\n\t\tgetDist(pos-tangent.yx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nfloat rayMarch(vec2 rayOrigin, vec2 rayDir){\n\tfloat rayLength = 0.1;  //tune to not get stuck at origin\n\tfloat radCirc;\n    \n    if (length(rayOrigin)>.5) rayLength += length(rayOrigin)-.5; //there is nothing outside of this circle\n\t\n\tfor (int n=0; n<MAX_STEPS; n++){\n\t\tradCirc = getDist(rayOrigin+rayLength*rayDir);\n\t\trayLength += radCirc;\n\t\tif (rayLength>MAX_DIST || abs(radCirc)<MIN_DIST) break;\n\t}\n\t\n\treturn rayLength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n    float animTime = 2.133333*iTime;\n    //mat2 rotM = mat2(cos(animTime/12.),-sin(animTime/12.),sin(animTime/12.),cos(animTime/12.)); \n    //uv *= rotM; //rotate \n    uv.y += .1+.1*sin(animTime/12.); //translate\n\tuv *= 1.+.05*sin(animTime/12.); //zoom\n    vec3 col = vec3(0);\n    \n\t// \"Surfaces\"\n    lines = vec3[](\n\t\tvec3(0.,1.,.5*sin(PI3/2.)), //horz edge\n\t\tvec3(sin(PI3),cos(PI3),-.5*sin(PI3/2.)), //right edge\n\t\tvec3(-sin(PI3),cos(PI3),-.5*sin(PI3/2.)) //left edge\n\t);\n\t\n    // Prism\n\tfloat bw = 0.;\n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[0]))); \n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[1]))); \n    bw += smoothstep(.01,.0,abs(getLine( uv, lines[2]))); \n    bw *= smoothstep(.001,.0,uv.x*uv.x+uv.y*uv.y-0.25); //cut overhangs (visual trick)\n\tcol += vec3(bw);\n\t//col += vec3(getLine( uv, lines[0]),getLine( uv, lines[1]),getLine( uv, lines[2])); //to see distance function\n\t\n\t// Ray marching\n    vec2 normal, pos, dir, pos2, dir2; \n    float amp, spread;\n\tfloat[] eta = float[](//baseline refraction index ratio, n2/n1, color dependence\n        0.68-.1*1.2598,\n        0.68-.1*1.3660,\n        0.68-.1*1.4863,\n        0.68-.1*1.7666,\n        0.68-.1*2.3124,\n        0.68-.1*2.6122,\n        0.68-.1*2.9032\n        ); \n    vec3[] myCol = vec3[](\n\t\t.3*abs(cos(animTime-.3))*vec3(1,0,0), //red\n        .2*abs(cos(animTime-.2))*vec3(.895,.446,0), //orange\n        .2*abs(cos(animTime-.1))*vec3(.707,.707,0), //yellow\n\t\t.2*abs(cos(animTime))*vec3(0,1,0), //green\n\t\t.2*abs(cos(animTime+.1))*vec3(0,0,1), //blue\n        .05*abs(cos(animTime+.2))*vec3(.5,0,.866), //indigo\n        .05*abs(cos(animTime+.3))*vec3(.574,0,.819) //violet\n\t);\n\t\n\tfor (int rayCol=0; rayCol<myCol.length(); rayCol++){ //r,g,b\n\t\tfor (int rayT=1; rayT<4; rayT++){ // (refractions, reflections) x (0,1; 1,0; 0,0; 1,1) \n            pos = vec2(-1.1,.03+.05*sin(animTime/8.)); //start pos\n            dir = normalize(vec2(1.+.01*float(rayCol),.2+.1*sin(animTime/8.))); //start dir\n            amp = 1.; //start amplitude\n            spread = 0.01; //start beam width\n\t\t\t for (int n=0; n<5; n++){//...I guess long iterations are not liked by shaders\n\t\t\t\tpos2 = pos+rayMarch(pos,dir)*dir;\n                col += amp*sRect2(uv,pos,pos2)*smoothstep(spread,.0,abs(getLine(uv, vec3(dir.y,-dir.x,pos.y*dir.x-pos.x*dir.y))))*myCol[rayCol];\n                spread += .01*length(pos2-pos);\n                normal = guessNormal(pos2-MIN_DIST*dir);\n\t\t\t\tif (int(mod(float(n+rayT)+mod(float(n),2.)*float(rayT)/2.,2.)) == 0){ //BUG this does not work right (rayT=0)\n\t\t\t\t\tdir2 = reflect(dir,normal);\n                    amp *= 0.4;\n\t\t\t\t} else {\n                    dir2 = refract(dir,normal,eta[rayCol]);\n                    eta[rayCol] = 1./eta[rayCol];\n                    amp *= 0.8;\n\t\t\t\t}\n                if (pos2.x*pos2.x+pos2.y*pos2.y > .25) break;\n\t\t\t\tpos=pos2; dir=dir2;\n\t\t\t }\t\t\n\t\t}\n\t}\n\t\t\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 208, 208, 281], [283, 283, 330, 330, 483], [485, 485, 519, 532, 572], [574, 574, 598, 598, 752], [754, 754, 781, 781, 944], [946, 946, 990, 990, 1370]], "test": "untested"}
{"id": "ctlXzN", "name": "Torus loop", "author": "mrange", "description": "CC0: Torus loop\n Saw some sweet twitter art again with torus that kept folding in on itself\n Tried something similar", "tags": ["torus"], "likes": 45, "viewed": 320, "published": 3, "date": "1674414773", "time_retrieved": "2024-07-30T18:14:07.841210", "image_code": "// CC0: Torus loop\n//  Saw some sweet twitter art again with torus that kept folding in on itself\n//  Tried something similar\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  22.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.025, 0.85, 0.5));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\nmat3  g_rot   ;\nfloat g_anim  ;\nmat2  g_rot_yx;\nmat2  g_rot_xz;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat df(vec3 p) {\n  const float zz  = 6.0;\n\n  const float r0  = 2.0-0.5;\n  const float r1  = r0/zz;\n  const float r2  = r1/zz;\n  const float r3  = r2/zz;\n\n  float anim  = g_anim;\n  float angle = anim*PI;\n  float z = mix(zz, 1.0, anim); \n\n  vec3 p0 = p;\n  p0 *= g_rot;\n  p0.yz *= g_rot_yx;\n  p0.x -= mix(r0*zz, 0.0, anim);\n  p0 /= z;\n \n  vec3 p1 = p0;\n\n  p1.z = abs(p1.z);\n  p1.xz *= g_rot_xz;\n\n  vec3 p2 = p1;\n  p2.z = abs(p2.z);\n  p2.z -= r0;\n  p2 = p2.zxy;\n\n  vec3 p3 = p0;\n  \n  float rr = mix(r3, 0.0, anim);\n  float d0 = torus(p0, vec2(r0, r1+rr));\n  d0 = abs(d0) - r2;\n  float d1 = p1.x;\n  float d2 = torus(p2, vec2(r1, r2+rr));\n  float d3 = p3.x;\n  \n  float d = d0;\n  d = max(d, d1);\n  d = min(d, d2);\n  if (angle < PI/4.0) d = max(d, d3);\n  if (angle > (TAU-PI/4.0)) d = max(d, -d3);\n  return d*z;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 gcol) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  vec3 gc = vec3(0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    gc += (0.0125*glowCol)/d;\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  gcol = gc;\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += clamp(vec3(0.0025/abs(rd.y))*glowCol, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 gcol;\n  int iter;\n  float t = rayMarch(ro, rd, gcol);\n  vec3 col = render0(ro, rd);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float fre = 1.0+dot(rd, n);\n  fre *= fre;\n  float dif = dot(sunDir1, n); \n\n  if (t < MAX_RAY_LENGTH) {\n    col = vec3(0.0);\n    col += sunCol1*dif*dif*diffCol*0.25;\n    col += mix(0.33, 1.0, fre)*render0(p, r);\n  } else {\n    col += gcol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float tm  = TIME*0.5+10.0;\n  g_rot     = rot_x(0.11*tm)*rot_y(0.23*tm)*rot_z(0.35*tm);\n  g_anim    = (0.5+0.5*sin(fract(0.1*TIME)*PI-PI/2.0));\n  g_rot_yx  = ROT(g_anim*(PI*0.5));\n  g_rot_xz  = ROT(PI/2.0-g_anim*PI);\n  \n  \n  vec3 ro = 2.0*vec3(5.0, 1.0, 0.);\n  ro.xz *= ROT(-0.1*tm);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 618, 618, 764], [1519, 1619, 1638, 1638, 1725], [1727, 1834, 1860, 1860, 2044], [2046, 2046, 2067, 2067, 2167], [2169, 2169, 2190, 2190, 2290], [2292, 2292, 2313, 2313, 2416], [2418, 2511, 2553, 2553, 2600], [2602, 2720, 2747, 2747, 2823], [2825, 2918, 2947, 2947, 3012], [3014, 3014, 3032, 3032, 3821], [3823, 3823, 3846, 3846, 4054], [4056, 4056, 4105, 4105, 4503], [4505, 4505, 4537, 4537, 5191], [5193, 5193, 5225, 5225, 5648], [5650, 5650, 5671, 5671, 6278], [6280, 6280, 6337, 6337, 6614]], "test": "untested"}
{"id": "clsSz4", "name": "UI Test 6", "author": "yasuo", "description": "UI Test 6", "tags": ["ui", "cineshader"], "likes": 46, "viewed": 2813, "published": 3, "date": "1674403080", "time_retrieved": "2024-07-30T18:14:08.806628", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat randomDotLine(vec2 p){\n    vec2 prevP = p;\n    p.x+=iTime*0.08;\n    vec2 gv = fract(p*20.0)-0.5;\n    vec2 id = floor(p*20.0);\n    \n    float n = Hash21(id);\n    float d = B(gv,vec2(0.25*(n*2.0),0.2));\n    p = prevP;\n    p.y+= 0.012;\n    d = max(abs(p.y)-0.01,max(abs(p.x)-0.08,d));\n    return d;\n}\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(40.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    //d = max(d2,d);\n    //d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.9;\n    p.y-=size*3.2;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.06;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = seg0(p)*checkChar(seg_0,char);\n    d += seg1(p)*checkChar(seg_1,char);\n    d += seg2(p)*checkChar(seg_2,char);\n    d += seg3(p)*checkChar(seg_3,char);\n    d += seg4(p)*checkChar(seg_4,char);\n    d += seg5(p)*checkChar(seg_5,char);\n    d += seg6(p)*checkChar(seg_6,char);\n    d += seg7(p)*checkChar(seg_7,char);\n    d += seg8(p)*checkChar(seg_8,char);\n    d += seg9(p)*checkChar(seg_9,char);\n    \n    return abs(d)-0.004;\n}\n\nfloat dLine(vec2 p, vec2 a, vec2 b, float w){\n    vec2 v = normalize(b-a);\n    vec2 right = normalize(cross(vec3(v,0.0),vec3(0.0,0.0,1.0)).xy);\n    vec2 newRightVec = right*(w*0.5);\n    vec2 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec2 mida = vec2((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5);\n    vec2 midb = vec2((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5);\n    \n    float rad1 = -atan(b1.x-a1.x,b1.y-a1.y);\n    float rad2 = -atan(a2.x-a1.x,a2.y-a1.y);\n    \n    float mad = Slice(p-mida,rad1);\n    float mbd = Slice(p-midb,rad1);\n    \n    float ad = Slice(p-a,rad2);\n    float bd = Slice(p-b,rad2);\n    float d = max(max(mad,-mbd),max(-ad,bd));\n    return d;\n}\n\nfloat ringItem(vec2 p, float r, float r2, float deg){\n    vec2 prevP = p;\n    float thickness = 0.001;\n    float d = abs(length(p)-r)-thickness;\n    float rad = radians(deg*iTime);\n    float x = r*cos(rad)+p.x;\n    float y = r*sin(rad)+p.y;\n    float d2 = length(vec2(x,y))-r2;\n    d = max(-d2,d);\n    d = min(d,abs(d2)-thickness);\n    d2 = length(p)-0.005;\n    d = min(d,d2);\n    d2 = length(vec2(x,y))-0.005;\n    d = min(d,d2);\n    return d;\n}\n\nfloat smallCircle(vec2 p, float r){\n    float thickness = 0.001;\n    float d = abs(length(p)-r)-thickness;\n    float d2 = length(p)-0.005;\n    d = min(d,d2);\n    return d;\n}\n\nfloat ringCircle(vec2 p){\n    vec2 prevP = p;\n    float thickness = 0.0005;\n    float R = 0.41;\n    float R2 = 0.29;\n    float r = R;\n    float r2 = R2;\n    float r3 = 0.465;\n    float d = abs(length(p)-r)-thickness;\n    \n    for(float i = 0.; i<4.; i++){\n        float startAngle = i*25.;\n        float rad = radians(startAngle+10.*-iTime);\n        float x = r*cos(rad)+p.x;\n        float y = r*sin(rad)+p.y;\n        float dir = (mod(i,2.) == 0.)?-1.:1.;\n        float d2 = ringItem(vec2(x,y),0.055-(i*0.005),0.02-(i*0.002), (30.+(i*5.))*dir);\n        d = min(d,d2);\n    }\n    \n    float d2 = abs(length(p)-r2)-thickness;\n    d = min(d,d2);\n    \n    float rad = radians(((3.*25.)+10.*-iTime)+sin(iTime*1.2)*-10.);\n    float x = r2*cos(rad)+p.x;\n    float y = r2*sin(rad)+p.y;\n    d2 = smallCircle(vec2(x,y),0.02);\n    d = min(d,d2);\n    \n    x =  r2*cos(rad);\n    y =  r2*sin(rad);\n    \n    rad = radians((2.*25.)+10.*-iTime);\n\n    float deg =  (30.+(2.*5.));\n    float rad2 = radians(deg*-iTime);\n    \n    r2 = 0.055-(2.*0.005);\n    float x2 = (r*cos(rad))+(r2*cos(rad2));\n    float y2 = (r*sin(rad))+(r2*sin(rad2));\n    \n    d2 = dLine(p,vec2(-x,-y),vec2(-x2,-y2),0.001);\n    d = min(d,d2);\n    \n    r2 = R2;\n    rad = radians((10.*-iTime)+sin(iTime*1.2)*10.);\n    x = r2*cos(rad)+p.x;\n    y = r2*sin(rad)+p.y;\n    d2 = smallCircle(vec2(x,y),0.02);\n    d = min(d,d2);\n    \n    x =  r2*cos(rad);\n    y =  r2*sin(rad);\n    \n    rad = radians(25.+10.*-iTime);\n\n    deg =  35.;\n    rad2 = radians(deg*iTime);\n    \n    r2 = 0.055-(1.*0.005);\n    x2 = (r*cos(rad))+(r2*cos(rad2));\n    y2 = (r*sin(rad))+(r2*sin(rad2));    \n    d2 = dLine(p,vec2(-x,-y),vec2(-x2,-y2),0.001);\n    d = min(d,d2);\n    \n    \n    for(float i = 0.; i<4.; i++){\n        float startAngle = i*25.;\n        float rad = radians(180.+startAngle+10.*-iTime);\n        float x = r*cos(rad)+p.x;\n        float y = r*sin(rad)+p.y;\n        float dir = (mod(i,2.) == 0.)?-1.:1.;\n        float d2 = ringItem(vec2(x,y),0.055-(i*0.005),0.02-(i*0.002), (30.+(i*5.))*dir);\n        d = min(d,d2);\n    }\n    \n    r2 = R2;\n    rad = radians((180.+(3.*25.)+10.*-iTime)+sin(iTime*1.3)*10.);\n    x = r2*cos(rad)+p.x;\n    y = r2*sin(rad)+p.y;\n    d2 = smallCircle(vec2(x,y),0.02);\n    d = min(d,d2);\n    \n    x =  r2*cos(rad);\n    y =  r2*sin(rad);\n    \n    rad = radians(180.+(3.*25.)+10.*-iTime);\n\n    deg = -(30.+(3.*5.));\n    rad2 = radians(deg*-iTime);\n    \n    r2 = 0.055-(3.*0.005);\n    x2 = (r*cos(rad))+(r2*cos(rad2));\n    y2 = (r*sin(rad))+(r2*sin(rad2));\n    \n    d2 = dLine(p,vec2(-x,-y),vec2(-x2,-y2),0.001);\n    d = min(d,d2);\n    \n    \n    \n    r2 = R2;\n    rad = radians(180.+(10.*-iTime)+sin(iTime*1.2)*-10.);\n    x = r2*cos(rad)+p.x;\n    y = r2*sin(rad)+p.y;\n    d2 = smallCircle(vec2(x,y),0.02);\n    d = min(d,d2);\n    \n    x =  r2*cos(rad);\n    y =  r2*sin(rad);\n    \n    rad = radians(180.+10.*-iTime);\n\n    deg = -30.;\n    rad2 = radians(deg*iTime);\n    \n    r2 = 0.055;\n    x2 = (r*cos(rad))+(r2*cos(rad2));\n    y2 = (r*sin(rad))+(r2*sin(rad2));    \n    d2 = dLine(p,vec2(-x,-y),vec2(-x2,-y2),0.001);\n    d = min(d,d2);    \n    \n    \n    p*=Rot(radians(sin(iTime*1.5)*120.));\n    d2 = abs(length(p)-r3)-0.0001;\n    d2 = max(abs(p.x)-0.3,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat circleRuler(vec2 p){\n    p*=Rot(radians(iTime*-25.));\n    vec2 prevP = p;\n    float r = 0.23;\n    float d = abs(length(p)-r)-0.0001;\n    \n    p=DF(p,5.);\n    p-=vec2(0.163);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.02));\n    d = min(d,d2);\n    \n    p = prevP;\n    p=DF(p,20.);\n    p-=vec2(0.163);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.0005,0.01));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat circleRuler2(vec2 p){\n    p*=Rot(radians(45.+iTime*20.));\n    vec2 prevP = p;\n    float r = 0.188;\n    float d = abs(length(p)-r)-0.0001;\n    \n    p=DF(p,5.);\n    p-=vec2(0.125);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.012));\n    d = min(d,d2);\n    \n    p = prevP;    \n    p=DF(p,10.);\n    p-=vec2(0.128);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.001,0.006));\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat circleItem0(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(10.+sin(iTime*0.5)*-150.));\n    p=DF(p,2.);\n    p-=vec2(0.24);\n    p*=Rot(radians(225.));\n    float d = abs(Tri(p,vec2(0.015,0.015),radians(45.)))-0.0005;\n    return d;\n}\n\nfloat circleItem1(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-15.*iTime));\n    float d = abs(length(p)-0.145)-0.007;\n    float a = radians(45.);\n    p.x = abs(p.x);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    float d2 = abs(length(p)-0.145)-0.0005;\n    d2 = max(-d,d2);\n    d = min(abs(d)-0.0005,d2);\n    return d;\n}\n\nfloat centerNumber(vec2 p){\n    vec2 prevP = p;\n    p*=2.7;\n    p*=SkewX(-0.4);\n    float d = drawFont(p-vec2(-0.09,0.0),int(mod(iTime*4.,10.)));\n    float d2 = drawFont(p-vec2(0.09,0.0),int(mod(iTime*8.,10.)));\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(B(p,vec2(0.095,0.06)))-0.0005;\n    d2 = max(-(abs(p.x)-0.085),d2);\n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat centerCircleUI(vec2 p){\n    vec2 prevP = p;\n    float d = ringCircle(p);\n    float d2 = circleRuler(p);\n    d = min(d,d2);\n    d2 = circleRuler2(p);\n    d = min(d,d2);\n    d2 = circleItem0(p);\n    d = min(d,d2);\n    d2 = circleItem1(p);\n    d = min(d,d2);\n    d2 = centerNumber(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat sideUIItem0Base(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.17,0.025));\n    p.x-=0.01;\n    p.y-=0.02;\n    float d2 = B(p,vec2(0.08,0.02));\n    float a = radians(-60.);\n    p.x = abs(p.x)-0.07;\n    d2 = max((dot(p,vec2(cos(a),sin(a)))),d2);\n    d = max(-d2,d);\n    \n    p = prevP;\n    a = radians(240.);\n    p.x+=0.12;\n    d = max((dot(p,vec2(cos(a),sin(a)))),d);\n    return d;\n}\n\nfloat sideUIItem0(vec2 p){\n    p*=1.1;\n    p.x*=-1.;\n    vec2 prevP = p;\n    p.x+=0.08;\n    p.y-=0.08;\n    float d = sideUIItem0Base(p);\n    p = prevP;\n    p.x*=-1.;\n    p.x+=0.08;\n    p.y+=0.08;\n    p*=Rot(radians(-90.));\n    float d2= sideUIItem0Base(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(45.);\n    p.x-=0.14;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p-=vec2(0.05,0.05);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(0.02,0.04));\n    d = abs(min(d,d2))-0.0005;\n    \n    p = prevP;\n    p-=vec2(0.052,0.052);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(0.0005,0.04));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = randomDotLine(p-vec2(-0.07,0.055));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.065,0.037),vec2(0.075,0.0001));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat sideUIItem1(vec2 p){\n    p*=1.1;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.003,0.36));\n    p.x+=0.027;\n    p.y = abs(p.y)-0.36;\n    float d2 = B(p,vec2(0.03,0.003));\n    d = min(d,d2);\n    \n    float speed = -0.1;\n    \n    p = prevP;\n    p.y += iTime*speed;\n    p.x+=0.015;\n    p.y = mod(p.y,0.02)-0.01;\n    d2 = B(p,vec2(0.01,0.0005));\n    p = prevP;\n    d2 = max(abs(p.y)-0.36,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y += iTime*speed;\n    p.x+=0.025;\n    p.y = mod(p.y,0.06)-0.03;\n    d2 = B(p,vec2(0.015,0.001));\n    p = prevP;\n    d2 = max(abs(p.y)-0.36,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x+=0.06;\n    p.y+=sin(iTime*0.5)*0.3;\n    p*=Rot(radians(90.));\n    d2 = abs(Tri(p,vec2(0.015),radians(45.)))-0.0005;\n    d = min(d,d2);\n    return d;\n}\n\nfloat graphItem(vec2 p, float speed, float start, float h){\n    vec2 prevP;\n    float endTime = 5.;\n    float dist = h-start;\n    float t = mod(iTime*speed,endTime);\n    float animVal = endTime*0.5;\n    float val = t/animVal;\n    if(t<endTime*0.5){\n        val=(t/animVal)*dist;\n    } else {\n        val=(1.-((t-animVal)/animVal))*dist;\n    }\n    \n    float w = 0.013;\n    float h2 = start+val;\n    float d = B(p-vec2(0.,val),vec2(w,h2));\n    float d2 = abs(B(p-vec2(0.,dist),vec2(0.022,h+start+0.005)))-0.0001;\n    d2 = max(-(abs(p.x)-(w-0.002)),d2);\n    d2 = max(-(abs(p.y-dist)-h),d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat graphUI(vec2 p){\n    float d = graphItem(p,2.5,0.01,0.1);\n    float d2 = graphItem(p-vec2(0.055,0.),2.,0.01,0.1);\n    d = min(d,d2);\n    d2 = graphItem(p-vec2(-0.055,0.),2.7,0.01,0.1);\n    d = min(d,d2);\n    return d;\n}\n\nfloat meterUI(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.06)-0.0001;\n    \n    p=DF(p,4.);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.005,0.2));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*0.5)*190.));\n    p.x = abs(p.x)-0.085;\n    p*=Rot(radians(90.));\n    \n    d2 = abs(Tri(p,vec2(0.015,0.015),radians(45.)))-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p,vec2(0.0002,0.04));\n    d = min(d,d2);\n    d2 = B(p,vec2(0.04,0.0002));\n    d = min(d,d2);\n    \n    p*=Rot(radians(45.));\n    d =max(-B(p,vec2(0.02)),d);\n    d2 = abs(B(p,vec2(0.01)))-0.00001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-30.));\n    d2 = B(p-vec2(0,0.025),vec2(0.0002,0.025));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat sideUIItem2(vec2 p){\n    p*= Rot(radians(45.));\n    vec2 prevP = p;\n    float d = abs(B(p,vec2(0.06)))-0.0001;\n    float d2 = abs(B(p,vec2(0.06)))-0.002;\n    p*=Rot(radians(20.*iTime));\n    float mask = min(abs(p.x)-0.03,abs(p.y)-0.03);\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(B(p,vec2(0.04)))-0.0001;\n    d = min(d,d2);\n    d2 = abs(B(p,vec2(0.04)))-0.002;\n    p*=Rot(radians(-25.*iTime));\n    mask = min(abs(p.x)-0.015,abs(p.y)-0.015);\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=1.+sin(iTime*5.)*0.1;\n    d2 = abs(B(p,vec2(0.015)))-0.0001;\n    mask = min(abs(p.x)-0.005,abs(p.y)-0.005);\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat sliderItem(vec2 p, float speed){\n    vec2 prevP = p;\n    float d = abs(B(p,vec2(0.02,0.1)))-0.0001;\n    d = max(-(abs(p.y)-0.09),d);\n    float d2 = B(p,vec2(0.0001,0.09));\n    d = min(d,d2);\n    p.y = mod(p.y,0.02)-0.01;\n    d2 = B(p,vec2(0.005,0.001));\n    p = prevP;\n    d2 = max((abs(p.y)-0.08),d2);\n    d = min(d,d2);\n    p.y+=sin(iTime*speed)*0.08;\n    d2 = B(p,vec2(0.018,0.005));\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.025;\n    p*=Rot(radians(-90.));\n    d2 = abs(Tri(p,vec2(0.013,0.013),radians(45.)))-0.0005;\n    d = min(d,d2);        \n    \n    return d;\n}\n\nfloat sideUIItem3(vec2 p){\n    vec2 prevP = p;\n    float d = sliderItem(p-vec2(-0.045,0.),1.);\n    float d2 = sliderItem(p-vec2(0.045,0.),1.5);\n    d = min(d,d2);\n    return d;\n}\n\nfloat smallCircleItem(vec2 p, float speed){\n    vec2 prevP = p;\n    p*=Rot(radians(20.*iTime*speed));\n    float d = abs(length(p)-0.029)-0.01;\n    p=DF(p,2.);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.005,0.2));\n    d = max(-d2,d);\n    d2 = length(p)-0.005;\n    d = min(d,d2);\n    return d;\n}\n\nfloat sideUIItem4(vec2 p){\n    vec2 prevP = p;\n    float d = smallCircleItem(p-vec2(-0.045,0.),1.);\n    float d2 = smallCircleItem(p-vec2(0.045,0.),-2.);\n    d = min(d,d2);\n    return d;\n}\n\nfloat sideUIItem5(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-25.*iTime));\n    p=DF(p,5.);\n    p-=vec2(0.04);\n    p*=Rot(radians(45.));\n    \n    float d = B(p,vec2(0.001,0.01));\n    \n    float speed = 2.;\n    p = prevP;\n    p*=Rot(radians(25.*iTime*speed));\n    float d2 = abs(length(p)-0.08)-0.005;\n    \n    float a = radians(45.);\n    p.x = abs(p.x);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(25.*iTime*speed));\n    d2 = abs(length(p)-0.08)-0.005;\n    \n    a = radians(-45.);\n    p.x = abs(p.x);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*2.)*45.));\n    d2 = B(p,vec2(0.03,0.001));\n    d = min(d,d2);\n    d2 = B(p,vec2(0.001,0.03));\n    d = min(d,d2);\n    d = max(-B(p,vec2(0.015)),d);\n    d2 = length(p)-0.005;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat triangle2(vec2 p, vec2 s, float thick){\n    float d = B(p, s);\n    float a = radians(225.);\n    d = abs(max(dot(p,vec2(cos(a),sin(a))),d))-thick;\n    return d;\n}\n\nfloat sideUIItem6(vec2 p){\n    vec2 prevP = p;\n    float d = triangle2(p,vec2(0.08),0.0005);\n    float d2 = triangle2(p,vec2(0.08),0.003);\n    p*=Rot(radians(-25.*iTime));\n    d2 = max(-min(abs(p.x)-0.03,abs(p.y)-0.03),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = triangle2(p-vec2(0.018),vec2(0.035),0.0005);\n    d = min(d,d2);\n    d2 = triangle2(p-vec2(0.018),vec2(0.035),0.003);\n    p-=vec2(0.018);\n    p*=Rot(radians(25.*iTime));\n    d2 = max(-min(abs(p.x)-0.015,abs(p.y)-0.015),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat plus(vec2 p, float speed){\n    p*=Rot(radians(10.*iTime*speed));\n    float d = B(p,vec2(0.0001,0.01));\n    float d2 = B(p,vec2(0.01,0.0001));\n    d = min(d,d2);\n    return d;\n}\n\nfloat sideAreaUI(vec2 p){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.57;\n    p.y = abs(p.y)-0.35;\n    float d = sideUIItem0(p);\n    p = prevP;\n    p.x = abs(p.x)-0.79;\n    float d2 = sideUIItem1(p);\n    d = min(d,d2);\n    p = prevP;\n    d2 = graphUI(p-vec2(0.625,0.125));\n    d = min(d,d2);\n    d2 = meterUI(p-vec2(-0.62,0.23));\n    d = min(d,d2);\n    d2 = sideUIItem2(p-vec2(-0.62,0.));\n    d = min(d,d2);\n    d2 = sideUIItem3(p-vec2(-0.62,-0.25));\n    d = min(d,d2);\n    d2 = sideUIItem4(p-vec2(0.62,0.));\n    d = min(d,d2);\n    d2 = sideUIItem5(p-vec2(0.62,-0.22));\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.37;\n    p.y = abs(p.y)-0.36;\n    d2 = sideUIItem6(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(-0.62,0.);\n    p.x = abs(p.x)-0.08;\n    p.y = abs(p.y)-0.1;\n    d2 = plus(p,5.);\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(0.62,-0.22);\n    p.x = abs(p.x)-0.07;\n    p.y = abs(p.y)-0.11;\n    d2 = plus(p,-8.);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat bg(vec2 p){\n    p = mod(p,0.04)-0.02;\n    float d = abs(p.x)-0.0001;\n    float d2 = abs(p.y)-0.0001;\n    d = min(d,d2);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    float d = centerCircleUI(p);\n    float d2 = sideAreaUI(p);\n    d = min(d,d2);\n    \n    float bgd = bg(p);\n    col = mix(col,vec3(0.03),S(bgd,0.0));\n    col = mix(col,vec3(1.),S(d,0.0));\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[733, 733, 755, 755, 845], [847, 847, 875, 875, 1150], [1152, 1152, 1174, 1174, 1669], [1671, 1671, 1690, 1690, 1840], [1842, 1842, 1861, 1861, 2172], [2174, 2174, 2193, 2193, 2481], [2483, 2483, 2502, 2502, 2797], [2799, 2799, 2818, 2818, 3106], [3108, 3108, 3127, 3127, 3415], [3417, 3417, 3436, 3436, 3706], [3708, 3708, 3727, 3727, 3910], [3913, 3913, 3932, 3932, 4118], [4120, 4120, 4139, 4139, 4409], [4411, 4411, 4453, 4453, 4513], [4515, 4515, 4548, 4548, 4985], [4987, 4987, 5032, 5032, 5688], [5690, 5690, 5743, 5743, 6135], [6137, 6137, 6172, 6172, 6310], [6312, 6312, 6337, 6337, 9564], [9566, 9566, 9592, 9592, 9984], [9986, 9986, 10013, 10013, 10410], [10412, 10412, 10438, 10438, 10648], [10650, 10650, 10676, 10676, 10989], [10991, 10991, 11018, 11018, 11386], [11388, 11388, 11417, 11417, 11710], [11712, 11712, 11742, 11742, 12106], [12108, 12108, 12134, 12134, 12924], [12926, 12926, 12952, 12952, 13705], [13707, 13707, 13766, 13766, 14330], [14332, 14332, 14354, 14354, 14557], [14559, 14559, 14581, 14581, 15331], [15333, 15333, 15359, 15359, 16054], [16056, 16056, 16094, 16094, 16633], [16635, 16635, 16661, 16661, 16813], [16815, 16815, 16858, 16858, 17117], [17119, 17119, 17145, 17145, 17307], [17309, 17309, 17335, 17335, 18208], [18210, 18210, 18255, 18255, 18377], [18379, 18379, 18405, 18405, 18913], [18915, 18915, 18947, 18947, 19097], [19099, 19099, 19124, 19124, 20072], [20074, 20074, 20091, 20091, 20215], [20217, 20217, 20274, 20274, 20589]], "test": "untested"}
{"id": "dllSR8", "name": "RayMarch11111", "author": "___HackerMann___", "description": "RayMarch", "tags": ["raymarch"], "likes": 1, "viewed": 178, "published": 3, "date": "1674385444", "time_retrieved": "2024-07-30T18:14:09.960543", "image_code": "#define RAYMARCH_MAX_ITERATIONS 1000\n#define MAX_DISTANCE 1000.0\n#define EPS 0.0001\n\nfloat soft_min(in float lhs, in float rhs, in float radius) {\n    float h = clamp(0.5 + 0.5 * (lhs - rhs) / radius, 0.0, 1.0);\n    return mix(lhs, rhs, h) - radius * h * (1.0 - h);\n}\n\nfloat sphere_sdf(in vec3 position, in vec3 centre, in float radius) {\n    return length(position - centre) - radius;\n}\n\nfloat torus_sdf(in vec3 position, in float R, in float r) {\n    vec2 q = vec2(length(position.xz) - R, position.y);\n    return length(q) - r;\n}\n\nfloat scene_sdf(in vec3 position) {\n    //position = floor(position);\n\n    float sphere_h = (pow(-1.5 * sin(0.23123 * iTime + 0.123), 4.0) - 1.8) * 0.2;\n    float sphere = sphere_sdf(position, vec3(0, sphere_h, 0), 0.25);\n    float torus  = torus_sdf(position, 0.5, 0.13);\n\n    return soft_min(sphere, torus, 0.5);\n}\n\nvec3 calculate_normal(in vec3 pos) {\n    vec2 eps = vec2(EPS, 0);\n\n    return normalize(vec3(\n        scene_sdf(pos + eps.xyy) - scene_sdf(pos - eps.xyy),\n        scene_sdf(pos + eps.yxy) - scene_sdf(pos - eps.yxy),\n        scene_sdf(pos + eps.yyx) - scene_sdf(pos - eps.yyx)\n    ));\n}\n\nfloat march_shadow(in vec3 ray_origin, in vec3 to_light_direction, in float min_t, in float max_t, in float k) {\n    float result = 1.0;\n\n    for (float t = min_t; t <= max_t;) {\n        float h = scene_sdf(ray_origin + t * to_light_direction);\n\n        if (h < EPS)\n            return 0.0;\n\n        result = min(result, k * h / t);\n        t += h;\n    }\n\n    return result;\n}\n\nfloat ray_march(in vec3 ray_origin, in vec3 ray_direction, out int steps) {\n    float dist = 0.0;\n\n    steps = 0;\n    for (; steps < RAYMARCH_MAX_ITERATIONS; ++steps) {\n        float depth = scene_sdf(ray_origin + dist * ray_direction);\n        if (depth <= EPS)\n            return depth + dist;\n\n        dist += depth;\n\n        if (depth > MAX_DISTANCE)\n            return MAX_DISTANCE;\n    }\n\n    return MAX_DISTANCE;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec3 ambient_color = vec3(0.6);\n\n    vec2 uv = 2.0 * frag_coord / iResolution.xy - vec2(1);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ray_origin = vec3(0, 2, -4);\n    vec3 ray_direction = normalize(vec3(uv, 0) - ray_origin);\n    vec3 texture_sample = texture(iChannel0, ray_direction).rgb;\n\n    int steps;\n    float dist = ray_march(ray_origin, ray_direction, steps);\n    if (60.0 < dist) {\n        frag_color = vec4(texture_sample, 1);\n        return;\n    }\n    \n    vec3 hit_pos = ray_origin + dist * ray_direction;\n    vec3 normal = calculate_normal(hit_pos);\n    \n    vec3 light_position = 10.0 * vec3(sin(1.5 * iTime), 1, cos(1.5 * iTime));\n    vec3 to_light_direction = normalize(light_position - hit_pos);\n\n    float brightness = max(dot(normal, to_light_direction), ambient_color.r);\n    float to_light_dist = length(light_position - hit_pos);\n    brightness /= 0.006 * to_light_dist * to_light_dist;\n\n    vec3 reflected = reflect(ray_direction, normal);\n    float specular_power = 200.0;\n    float specular_brightness = pow(max(0.0, dot(reflected, to_light_direction)), specular_power);\n\n    float fresnel_power = 7.0;\n    float fresnel_factor = pow(1.0 - dot(normal, -ray_direction), fresnel_power);\n    \n    vec3 albedo = vec3(hit_pos * 0.5 + vec3(0.5));\n    vec3 color = brightness * albedo;\n\n    float shadow = march_shadow(hit_pos + EPS * normal * 4.0, to_light_direction, 0.0, 10000.0, 2.2);\n    shadow = exp(shadow) / exp(1.0);\n    shadow = (shadow + ambient_color.r + 0.8) / (1.0 + ambient_color.r + 0.8);\n    color = shadow * albedo;\n    \n    color += fresnel_factor * 0.35;\n    color += specular_brightness;\n\n    frag_color = vec4(color, 1);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 146, 146, 267], [269, 269, 338, 338, 387], [389, 389, 448, 448, 532], [534, 534, 569, 603, 850], [852, 852, 888, 888, 1137], [1139, 1139, 1251, 1251, 1515], [1517, 1517, 1592, 1592, 1938], [1940, 1940, 1997, 1997, 3675]], "test": "untested"}
{"id": "dtXXRN", "name": "field art - golfed (402 ch)", "author": "FabriceNeyret2", "description": "reference:  image from Tyler Hobbs Art \n[img]https://i.imgur.com/uiKQAeR.png[/img]\nmore: [url]https://tylerxhobbs.com/essays/2020/flow-fields[/url]", "tags": ["flow", "field", "lic", "reproduction"], "likes": 36, "viewed": 661, "published": 3, "date": "1674378988", "time_retrieved": "2024-07-30T18:14:10.884074", "image_code": "// golfing  748 / 591 chars  https://shadertoy.com/view/wtVyRW\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (u+u-R)/R.y, P;      \n    O*=0.;O++;\n    \n    for( int i=0; i < 9 * min( int( pow(1.-U.y,1.7) *R.y/13. ), 200); i++ )\n        P =  round(U*11.) + vec2(i%3,(i/3)%3),\n        P += fract( 4e4* sin( 1e2* ( mat2(10,71,51,23) * P + float(i/9) ) )) -1.5,\n        O -= O * max( 0., .5 - abs( dot( P = U - P/11. , \n                                    normalize( sin( vec2(5,3)*U/2. + cos( U/2.*mat2(3,10,-4,1) ) ) ) \n                                  ))*R.y/4. )\n               * clamp( ( .08 - length(P) ) *R.y ,0.,1.);\n     \n    O = sqrt( O + max(0., length(U)-.8 ) *R.y );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 103, 103, 714]], "test": "untested"}
{"id": "dtfSz4", "name": "Smooth Normal Map", "author": "MysteryPancake", "description": "Mouse controls radius :)", "tags": ["2d", "edge", "emboss", "normal", "smooth", "difference", "findedges", "direction"], "likes": 10, "viewed": 370, "published": 3, "date": "1674369376", "time_retrieved": "2024-07-30T18:14:11.782671", "image_code": "const float TAU = 6.28318530;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 16.0;\n    const float contrast = 3.0;\n    \n    // Control radius with mouse\n    float radius = iMouse.z > 0.0 ? iMouse.x / iResolution.x * 32.0 : sin(iTime * 4.0) * 2.0 + 3.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    vec2 dirAvg = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n    \n        // Find color difference in all directions\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        \n        // Scale direction according to difference\n        dirAvg += dir * distance(fragColor.rgb, col.rgb);\n    }\n    \n    dirAvg *= contrast;\n    fragColor.rgb = vec3(dirAvg * 0.5 + 0.5, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 86, 86, 927]], "test": "untested"}
{"id": "DlXXzN", "name": "Planet in starry sky", "author": "ManuManu", "description": "A (rather) cheap planet on a starry sky", "tags": ["planet", "starfield"], "likes": 6, "viewed": 240, "published": 3, "date": "1674350269", "time_retrieved": "2024-07-30T18:14:12.685258", "image_code": "#define PI 3.14159265359\n\nmat2 Rot(float angle) {\n    float s=sin(angle);\n    float c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash21( vec2 p )\n{\n    p = fract( p*vec2( 789.123, 456.987));\n    p += dot( p, p + vec2(12.34));\n    return fract( p.x*p.y);\n}\n\nfloat circle( vec2 pos, vec2 center, float radius, float width, float smooth_width)\n{\n    float l = length(pos-center);\n\n    float low_val = width*.5 - smooth_width;\n    float high_val = width*.5;\n    float tore = smoothstep( high_val, low_val, abs( l - radius));\n    return tore;\n}\n\nfloat dirty_circle( vec2 pos, vec2 center, float radius, float width, float smooth_width)\n{\n    float rand_val = hash21(pos);\n    pos = pos + vec2( rand_val, fract(rand_val * 11.)) * 0.01;\n    return circle (pos, center, radius, width, smooth_width);\n}\nvec3 planet_text( vec2 uv )\n{\n    float nb_circles = 5.;\n    float val = 0.;\n\n    //vec3 col = vec3(1.,.5,.5)*.28; // Redish planet\n    //vec3 col = vec3(0.1,.3,.6)*.28;  // bluesish planet\n    vec3 col = vec3(.2,.6,.4)*.28;   // greenish planet\n    \n    for( float i = 0.001; i < nb_circles; i+= 1.)\n    {\n        float rand_val = hash21( vec2(i, i*.123));\n        float rand_val1 = fract( rand_val * 13.);\n        float rand_val2 = fract( rand_val * 53.);\n        float rand_val3 = fract( rand_val * 111.);\n        vec2 center = vec2( rand_val -.5, rand_val1 -.5);\n        center.x *= 1.7;\n        float radius = .3- ( rand_val2 -.5) * 0.3;\n        float width = .2- ( rand_val3 -.5) * 0.05;\n        float tore = dirty_circle( uv, center, radius, width, 0.1);\n        //float tore = circle( uv, center, radius, width, 0.1);\n        \n        val = max(tore, val );\n    }\n    nb_circles = 40.;\n    for( float i = 0.00001; i < nb_circles; i+= 1.)\n    {\n        float rand_val = hash21( vec2(i*.321, i*.456));\n        float rand_val1 = fract( rand_val * 13.);\n        float rand_val2 = fract( rand_val * 53.);\n        float rand_val3 = fract( rand_val * 111.);\n        vec2 center = vec2( rand_val -.5, rand_val1 -.5);\n        center.x *= 1.7;\n        center.y *= 2.1;\n        float radius = .1- ( rand_val2 -.5) * 0.1;\n        float width = .1- ( rand_val3 -.5) * 0.2;\n        float tore = dirty_circle( uv, center, radius, width, 0.1);\n        //float tore = circle( uv, center, radius, width, 0.1);\n        \n        val = max(tore, val );\n    }\n    \n    return vec3(val)+col;\n}\n\nvec3 planet( vec2 uv, vec3 local_y, vec3 local_z )\n{\n    vec3 local_x = cross( local_y, local_z);\n\n\n    float dist_from_center = length(uv);\n    float dist_from_circle_plane = sqrt( 1. - dist_from_center * dist_from_center );\n    \n    \n    vec3 pos_on_sphere = vec3( uv.x, uv.y, dist_from_circle_plane);\n    vec2 proj_on_equator_plane = vec2( dot( pos_on_sphere, local_x), dot( pos_on_sphere, local_z) );\n    float long_angle = atan( proj_on_equator_plane.y, proj_on_equator_plane.x );\n    \n    vec3 proj_eq_plane = dot( pos_on_sphere, local_x) * local_x + dot( pos_on_sphere, local_z) * local_z;\n    float lat_angle= atan( dot( pos_on_sphere, local_y), dot( pos_on_sphere, proj_eq_plane ) );\n    \n    vec2 text_uv = vec2( (long_angle+PI)/(2.*PI), ( lat_angle + PI/2.)/PI);\n    text_uv = 2.*text_uv -1.;\n    \n    vec3 col = vec3(0.);\n    \n    const float nb_div = 6.;\n    float inc = 2. * PI / nb_div;\n    for ( float i = 0.;  i < 2.*PI; i+= inc)\n    {\n        float moved_ux = fract( (text_uv.x + i)*.5 + .5 ) *2. - 1.;\n        vec2 cur_uv= vec2(moved_ux, text_uv.y);\n        col += planet_text( cur_uv );\n    }\n    \n    const float nb_div2 = 3.;\n    inc = 2. * PI / nb_div2;\n    float wind = .02*iTime + sin(iTime*.1) * .09;\n    for ( float i = 0.;  i < 2.*PI; i+= inc)\n    {\n        float moved_ux = fract( (0.456 + text_uv.x + i + wind*i)*.5 + .5 ) *2. - 1.;\n        vec2 cur_uv= vec2(moved_ux, text_uv.y);\n        col += planet_text( cur_uv );\n    }\n    return col/(nb_div + nb_div2) ;\n}\n\nvec3 add_planet( vec2 uv )\n{\n    vec3 col = vec3(0.2);\n    \n    // quasi up vect :\n    //vec3 axis = vec3 ( sin(iTime) * 0.3, 1.0, cos(iTime*2.));\n    vec3 axis = vec3 ( 0.3, 1.0, 0.);\n    axis = normalize(axis);\n    \n    vec3 right_vect = vec3(1.,0.,0.);\n    float rotation_speed = 0.35;\n    float angle = mod( iTime * rotation_speed, 2.*PI);\n    //float angle = 0.;\n    right_vect = vec3(cos(angle),0.,sin(angle));\n    \n    \n    vec3 dir = normalize( cross( right_vect, axis ));\n    \n    col = planet(uv, axis, dir);\n    return col;\n}\n\n\nfloat star(vec2 uv, float flare)\n{\n    float d = length(uv);\n    float col = 0.;\n    //col = .001/d/d;\n    col = .01/d;\n    \n    col += max(0., 1.-abs(uv.x * uv.y) * 2000.) * flare;\n    uv = Rot(3.14/4.) * uv;\n    col += max(0.,1.-abs(uv.x * uv.y) * 2000.) * .4 * flare;\n    \n    col *= smoothstep(.5, .3, d);\n    return col;\n}\n\nvec3 starfield( vec2 uv, float flare, vec3 color1, vec3 color2 )\n{\n    vec2 gv = fract(uv)-.5;\n    vec2 n = floor(uv);\n    float flare_effect = flare*1./5.;\n            \n    vec3 col = vec3(0.);\n    for( int i = -1; i<=1; i++)\n        for( int j = -1; j<=1; j++)\n        {\n            vec2 offset = vec2( i,j );\n            float rand_val = hash21(n+offset);\n            float flare_rand = flare * ( fract( rand_val * 789.) *.5 +.5);\n            float starcol = star(gv - offset  + vec2(rand_val-.5, fract(rand_val*10.) -.5), flare_rand);\n            \n            // flickering :\n            float freq  = (fract(rand_val * 100.) + 3.) / 2.;\n            float phase = fract(rand_val * 1000.)*15.;\n            float power = fract(rand_val * 55.) * (1.-flare_effect) + flare_effect;\n            float sin_amplitude = ( 1.-power);\n            \n            starcol *= abs(sin( iTime *freq +phase ))* sin_amplitude + power + sin_amplitude/2.;\n            float colRand = fract( rand_val * 123456.);\n            col += starcol * mix(color1, color2, colRand) * fract(rand_val*111.);\n        }\n    \n    //if (gv.x > .48 ||gv.y > .48) col.r = 1.;\n    return col;\n}\n\nvec3 starry_sky( vec2 uv )\n{\n    vec3 col = vec3(0.,0.,0.1);\n\n    uv *= 12.;\n    col += starfield(uv, .1, vec3(.97,.95,.77), vec3(.97,.77,.22));\n    uv /= 2.;\n    uv = Rot(.5) * uv;\n    col += starfield(uv, .1, vec3(.65,.32,.60), vec3(.18,.50,.63));\n    uv /= 2.;\n    uv = Rot(1.) * uv;\n    col += starfield(uv, .4, vec3(.34,.09,.39), vec3(.18,.43,.52));\n    uv /= 2.;\n    uv += vec2(5.,10.);\n    uv = Rot(6.2) * uv;\n    col += starfield(uv, .4, vec3(.18,.43,.52), vec3(.08,.40,.51));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = starry_sky(uv);\n    uv *= 2.;\n    \n    const float planet_factor = .6;\n    if ( length(uv) < planet_factor )\n    {\n        col = add_planet(uv / planet_factor);\n    }   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 129], [131, 131, 155, 155, 263], [265, 265, 350, 350, 547], [549, 549, 640, 640, 801], [802, 802, 831, 831, 2380], [2382, 2382, 2434, 2434, 3874], [3876, 3876, 3904, 3904, 4412], [4415, 4415, 4449, 4449, 4742], [4744, 4744, 4810, 4810, 5899], [5901, 5901, 5929, 5929, 6403], [6405, 6405, 6462, 6512, 6819]], "test": "untested"}
{"id": "DlfXR4", "name": "Basic Trail Effect", "author": "animtor120", "description": "Simplified version of https://www.shadertoy.com/view/llVGDh", "tags": ["video", "colors", "effect", "greenscreen", "rainbow", "hue", "rotation", "trail", "quad", "jcvd", "trailing"], "likes": 5, "viewed": 620, "published": 3, "date": "1674329825", "time_retrieved": "2024-07-30T18:14:13.652672", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SPEED 0.01\n#define DIRECTION vec2(-.6, -0.3)\n#define ATTENUATION 0.975\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    // Orignial color\n    vec4 source = texture(iChannel1, uv);\n    \n    // Avoid clamp\n    float v = 1.0;\n\n    // Green screen\n    float ref = max(source.r, source.b)*1.1;\n    float amask = source.g - ref;\n    amask = 1.0 - smoothstep(0.1, 0.2, amask);\n\n    source.rgb = mix(vec3(0.0), source.rgb, amask);\n    source.g = min(source.g, (source.r + source.b) * 0.5);\n\n    \n    // Trail effect\n    float sinEffect = sin(iTime * 10.0) * 0.25;\n    uv = uv + normalize(DIRECTION * vec2(1.0, sinEffect)) * SPEED;\n    vec4 feedback = texture(iChannel0, uv * (1.0));\n    // Color attenuation\n    feedback *= ATTENUATION;\n    \n    \n    source.rgb = mix(feedback.rgb, source.rgb, amask);\n    \n\tfragColor.rgb = source.rgb;\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "ctfXR4", "name": "Kaleidoscope-x", "author": "Sergeindamix", "description": "from chatGPT", "tags": ["sergemoore"], "likes": 0, "viewed": 178, "published": 3, "date": "1674328766", "time_retrieved": "2024-07-30T18:14:14.522346", "image_code": "\nprecision highp float;\n\nuniform sampler2D imageTex;\n\nuniform float time;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#define resolution iResolution\n#define time iTime\n    vec2 newCoord = uv;\n    newCoord = vec2(newCoord.x * cos(time) - newCoord.y * sin(time), newCoord.x * sin(time) + newCoord.y * cos(time));\n    newCoord = vec2(newCoord.x / resolution.x, newCoord.y / resolution.y);\n    newCoord = (newCoord - 0.5) * vec2(2.0, 2.0);\n    newCoord = vec2(newCoord.x * cos(time) - newCoord.y * sin(time), newCoord.x * sin(time) + newCoord.y * cos(time));\n    newCoord = (newCoord + 0.5) / vec2(2.0, 2.0);\n    newCoord = vec2(newCoord.x * resolution.x, newCoord.y * resolution.y);\n    vec4 color = texture(imageTex, newCoord);\n    fragColor = color;\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 134, 184, 862]], "test": "untested"}
{"id": "dtlSRH", "name": "gyroid 2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/4stfRX[/url]", "tags": ["raymarching", "sdf", "short", "trabeculum"], "likes": 25, "viewed": 346, "published": 3, "date": "1674317319", "time_retrieved": "2024-07-30T18:14:15.283312", "image_code": "// variant of https://shadertoy.com/view/4stfRX\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,v,d=t;\n    mat2  R = mat2( sin(.5*t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),              // ray direction\n          p = 90./q, a;                                 // marching point along ray \n    O-=O; \n    for ( O++; O.x > 0. && d > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                           // rotation\n        v= dot(sin(q),cos(q.yzx)) ,\n        d = abs(v-1.3),                                 // gyroid\n        fract(t/4.)>.5 ? d = min(d, abs(v+1.3)) : d,    // dual                  \n     // d = abs(v)-.1,                                  // regular gyroid\n        a = abs(q),\n        d = max(d, max(a.x,max(a.y,a.z))-18.),          // clamped to cube\n\n        p += .5*d*D;                                    // step forward = dist to obj\n \n    O *= v>0. ? vec4(1,.8,.8,1) : vec4(.8,.8,1,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 987]], "test": "untested"}
{"id": "mllXz8", "name": "Year of Truchets #003", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 30, "viewed": 383, "published": 3, "date": "1674317148", "time_retrieved": "2024-07-30T18:14:16.064224", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #003\n    01/21/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat time;\nconst float scale = 1.;\nconst vec3 d = vec3(0.957,0.439,0.043);\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nvec3 hue(float t){ return .42 + .425*cos(PI2*t*(vec3(.95,.97,.98)*d)); }\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec3 C = vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv = uv, dv = uv;\n    \n    uv *= rot(T*.025);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*3.5;\n    uv.x -= T*.25;\n\n    dv = vec2(log(length(dv)), atan(dv.y, dv.x))*3.5;\n    dv.x += T*.075;\n    \n    float px = fwidth(uv.x);\n\n    vec2 id = floor(uv*scale);\n    float chk = mod(id.y+id.x,2.)*2.-1.;\n\n    float rnd = hash21(id);\n    if(rnd>.5) uv.x*=-1.;\n\n    vec2 qv = fract(uv*scale)-.5;\n\n    float circle = min(length(qv-vec2(-.5,.5))-.5,length(qv-vec2(.5,-.5))-.5);\n    float circle3 = abs(circle)-.05;\n    \n    float c2 = smoothstep(-px,px,abs(abs(circle)-.125)-.025);\n    circle = (rnd>.5^^chk>.5) ? smoothstep(px,-px,circle) : smoothstep(-px,px,circle);\n    circle3 = smoothstep(.125,-px,circle3);\n    \n    dv=fract(dv*scale)-.5;\n    float dots = min(length(abs(dv)-vec2(0,.5))-.25,length(abs(dv)-vec2(.5,0))-.5);\n\n    dots = abs(abs(abs(abs(dots)-.1)-.05)-.025)-.0125;\n    dots = smoothstep(px,-px,dots);\n    \n    float hs = hash21(vuv)*.25;\n    C = clamp(hue(52.+id.x*.15)+hs,C,vec3(1));\n    \n    C = mix(C,C*.75,dots);\n    C = mix(C,C*.75,circle3);\n    C = mix(C,vec3(.001),clamp(min(circle,c2),0.,1.));\n \n    // Output to screen\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllXz8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[510, 510, 530, 530, 575], [576, 576, 598, 598, 660], [661, 661, 679, 679, 733]], "test": "untested"}
{"id": "dllXz8", "name": "plasmai", "author": "Sergeindamix", "description": "created with chatGPT", "tags": ["sergemoore"], "likes": 1, "viewed": 143, "published": 3, "date": "1674314728", "time_retrieved": "2024-07-30T18:14:16.826186", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = uv * 4.0 - 2.0;\n    float s = sin(iTime);\n    float c = cos(iTime);\n    p = vec2(dot(p, vec2(c, s)), dot(p, vec2(-s, c)));\n    float r = dot(p,p);\n    float f;\n    f  = 0.50000*sin(r*12.9898+dot(p,vec2(78.233,31.646)));\n    f += 0.25000*sin(r*12.9898+dot(p,vec2(31.646,78.233)));\n    f += 0.12500*sin(r*12.9898+dot(p,vec2(31.646,31.646)));\n    fragColor = vec4(f * vec3(0.5, 1.0, 1.0), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 560]], "test": "untested"}
{"id": "dlsXR8", "name": "Hebbian Learning", "author": "timeiskey", "description": "i want to have a hebbian network using locality rules to overfit on a circle pattern. \nim interested in seeing this visually, but also i suspect it scales very well for memory locality, (hardware native implementations)", "tags": ["ai", "ml"], "likes": 1, "viewed": 152, "published": 3, "date": "1674314087", "time_retrieved": "2024-07-30T18:14:17.727776", "image_code": "/*here we should output the current network*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*The Update Shader\n in here we read the weights in the network from\n iChannel1 on color r, and output the next weight and output\n \n the weight should be output on color r\n the neuron output, its current activation level, on color g\n*/\n\n#define RADIUS 10.0\n\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 nppd = 1.0/iResolution.xy * 1.0;\n    \n    vec2 nmp = iMouse.xy / iResolution.xy;\n\n    vec3 c = vec3(0.0);\n    \n    // network values and local neighborhood\n    // where mc is the center pixel, the current neuron\n    vec3 tl = texture(iChannel1, abs(uv + nppd * vec2( -1.0, -1.0))).rgb;\n    vec3 tc = texture(iChannel1, abs(uv + nppd * vec2(  0.0, -1.0))).rgb;\n    vec3 tr = texture(iChannel1, abs(uv + nppd * vec2(  1.0, -1.0))).rgb;\n    vec3 ml = texture(iChannel1, abs(uv + nppd * vec2( -1.0,  0.0))).rgb;\n    vec3 mc = texture(iChannel1, abs(uv + nppd * vec2(  0.0,  0.0))).rgb;\n    vec3 mr = texture(iChannel1, abs(uv + nppd * vec2(  1.0,  0.0))).rgb;\n    vec3 bl = texture(iChannel1, abs(uv + nppd * vec2( -1.0,  1.0))).rgb;\n    vec3 bc = texture(iChannel1, abs(uv + nppd * vec2(\t0.0,  1.0))).rgb;\n    vec3 br = texture(iChannel1, abs(uv + nppd * vec2(  1.0,  1.0))).rgb;\n \n    // before frame 20, set your pixel weights to be random by just using the input\n    // from iChannel0 which is a noisy texture.\n    if (iFrame < 20)\n    {\n        tl = texture(iChannel0, uv + nppd * vec2( -1.0, -1.0)).rgb;\n        tc = texture(iChannel0, uv + nppd * vec2(  0.0, -1.0)).rgb;\n        tr = texture(iChannel0, uv + nppd * vec2(  1.0, -1.0)).rgb;\n        ml = texture(iChannel0, uv + nppd * vec2( -1.0,  0.0)).rgb;\n        mc = texture(iChannel0, uv + nppd * vec2(  0.0,  0.0)).rgb;\n        mr = texture(iChannel0, uv + nppd * vec2(  1.0,  0.0)).rgb;\n        bl = texture(iChannel0, uv + nppd * vec2( -1.0,  1.0)).rgb;\n        bc = texture(iChannel0, uv + nppd * vec2(\t0.0,  1.0)).rgb;\n        br = texture(iChannel0, uv + nppd * vec2(  1.0,  1.0)).rgb;\n    }\n    \n    /* this is where you would compute the output of the current \n    neuron (mc) and its new weight\n    input is the output of the \"in_circle\" function which \n    takes in the pixel coord of mc and outputs true or false. \n    the neuron then uses that as input, to compute its next output, \n    \n    and updates itself based on its neighbors last outputs\n    */\n    // in circle\n    float in_circle = step(length(uv - vec2(0.5, 0.5)), RADIUS);\n    float error = in_circle - mc.g;\n    float next_weight = mc.r + 0.01 * error * (tl.g + tc.g + tr.g + ml.g + mr.g + bl.g + bc.g + br.g);\n    float out_put = sigmoid(next_weight * in_circle);\n    \n    fragColor = vec4( next_weight, out_put, 0.0, 1.0 );\n    \n    // this lets us draw weights, its weird but should help with debugging\n    if(iMouse.z > 0.0)\n    \tfragColor = max(fragColor,vec4(step(length(iMouse.xy - fragCoord),RADIUS)));\n        }", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 104, 104, 185]], "test": "untested"}
{"id": "mtsSz8", "name": "balls in maze 2", "author": "FabriceNeyret2", "description": ".", "tags": ["ball", "maze", "short", "marbles"], "likes": 13, "viewed": 205, "published": 3, "date": "1674313285", "time_retrieved": "2024-07-30T18:14:18.490736", "image_code": "// variant of https://shadertoy.com/view/mllXR8\n\n#define H(p) fract ( 1e4*sin( dot( p , vec2(71,-97) )) )           // rand\n#define B(s) length( F - .707*vec2( .5*s , fract(d*iTime) -.5) )   // ball SDF\n#define D(v) clamp(  1. - (v) * R.y/10. , 0.,1.)                   // AA draw\n\nvoid C( vec2 U, vec2 D, inout float l, inout float x ) {\n    vec2 I = floor(U)      + D,              // cell Id\n         F = fract(U) - .5 - D;              // cell coordinates\n         \n    float s = sign(H(I)-.5),                 // wall direction ( one of the 2 cell diagonals )\n          d = mod(I.x+I.y,2.) > 0. ? s : -s; // balls direction\n    F = ( F + s*vec2(-F.y,F) ) *.707;        // wall frame\n    x = min( x, abs(F.x) );                  // min distance to wall\n    \n    d *= sign( F.x );\n    l = min(l, min( B(s), B(-s) ) -.1 );     // min distance to balls on each wall side\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 10. * u / R.y + iTime;\n         \n    float x=9., l=9.;\n    C( U, vec2(0)    , l,x );                 // distance to balls and walls\n    C( U, vec2( 1,0) , l,x );                 // check neighbors when overlapping\n    C( U, vec2( 0,1) , l,x );\n    C( U, vec2(-1,0) , l,x );\n    C( U, vec2(0,-1) , l,x );\n    \n    O = mix( vec4( D(abs(x-.35)-.15) ) *.4,   // draw walls\n             vec4(1,0,0,1),  D(l) );          // draw balls\n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 338, 338, 873], [875, 875, 913, 913, 1395]], "test": "untested"}
{"id": "mlsSR8", "name": "waffle sphere maze 3", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "balls", "maze", "short", "marbles", "waffle"], "likes": 28, "viewed": 312, "published": 3, "date": "1674311656", "time_retrieved": "2024-07-30T18:14:19.254693", "image_code": "// variant of https://shadertoy.com/view/DlsXRn\n// variant of https://shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                          // rotation \n#define H(p)    fract( 1e4*sin( dot( p , vec2(71,-97) )) )            // rand\n#define B(s)    length( F - .707*vec2( .5*s , fract(d*iTime) -.5) )   // ball SDF\n#define D(v)    max( 1. - v * R.y/20., 0.)                            // AA draw\n\nvoid C( vec2 U, vec2 D, inout float l, inout float x ) {\n    vec2 I = floor(U)      + D,              // cell Id\n         F = fract(U) - .5 - D;              // cell coordinates\n    float s = sign(H(I)-.5),                 // wall direction ( one of the 2 cell diagonals )\n          d = mod(I.x+I.y,2.) > 0. ? s : -s; // balls direction\n    F = ( F + s*vec2(-F.y,F) ) *.707;        // wall frame\n    x = min( x, abs(F.x) );                  // min distance to wall\n    \n    d *= sign( F.x );\n    l = min(l, min( B(s), B(-s) ) );         // min distance to balls on each wall side\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s,m, r=8.,l,x; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),           // ray direction\n          p = vec3(0,0,40.+20.*cos(.2*iTime)), q,a,         // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.1*iTime + vec3(0,11,0)); \n    p.y += 7.; \n    for ( O=vec4(1); O.x > 0. && t > .001; O-=.01 ) {       // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                  // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q) - r;\n      if (abs(t)<.1) {                                      // optim: decorations only when close\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,        \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,\n        U *= 4.*r/m, \n        l=9.,x=9.; \n        C( U, vec2( 0 )  , l,x );                           // distance to balls and walls\n        C( U, vec2( 1,0) , l,x );                           // check neighbors when overlapping\n        C( U, vec2( 0,1) , l,x );\n        C( U, vec2(-1,0) , l,x );\n        C( U, vec2(0,-1) , l,x );\n        l /= 4.*r/7., x /= 4.*r/7., \n        s = min ( t+.1, max( t , x ) ),                     // walls trimmed by sphere\n        t = min(s, length(vec2(l*1.,t+.04))-.025 );         // balls\n      }\n        p += .5*t*D;                                        // step forward = dist to obj    \n      }\n\n   if (t!=s) O.gb = U-U;\n   O *= O*1.5; // O *= O*O*1.5;                             // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 478, 478, 1003], [1005, 1005, 1041, 1041, 2642]], "test": "untested"}
{"id": "mllXR8", "name": "balls in maze", "author": "FabriceNeyret2", "description": ".", "tags": ["ball", "maze", "short", "marbles"], "likes": 19, "viewed": 218, "published": 3, "date": "1674310665", "time_retrieved": "2024-07-30T18:14:20.287931", "image_code": "#define H(p) fract ( 1e4*sin( dot( p , vec2(71,-97) )) )           // rand\n#define B(s) length( F - .707*vec2( .5*s , fract(d*iTime) -.5) )   // ball SDF\n#define D(v) max( 1. - v * R.y/20., 0.)                            // AA draw\n\nvoid C( vec2 U, vec2 D, inout float l, inout float x ) {\n    vec2 I = floor(U)      + D,              // cell Id\n         F = fract(U) - .5 - D;              // cell coordinates\n         \n    float s = sign(H(I)-.5),                 // wall direction ( one of the 2 cell diagonals )\n          d = mod(I.x+I.y,2.) > 0. ? s : -s; // balls direction\n    F = ( F + s*vec2(-F.y,F) ) *.707;        // wall frame\n    x = min( x, abs(F.x) );                  // min distance to wall\n    \n    d *= sign( F.x );\n    l = min(l, min( B(s), B(-s) ) -.1 );     // min distance to balls on each wall side\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 10. * u / R.y;\n         \n    float x=9., l=9.;\n    C( U, vec2(0)    , l,x );                 // distance to balls and walls\n    C( U, vec2( 1,0) , l,x );                 // check neighbors when overlapping\n    C( U, vec2( 0,1) , l,x );\n    C( U, vec2(-1,0) , l,x );\n    C( U, vec2(0,-1) , l,x );\n    \n    O *= 0.;\n    O   += D(x) * ( .5 + .5*sin(iTime) );     // draw walls\n    O.r += D(l);                              // draw balls\n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 289, 289, 824], [826, 826, 864, 864, 1351]], "test": "untested"}
{"id": "ctXSR8", "name": "butterfly parallel sort  3", "author": "FabriceNeyret2", "description": "[ restart if texture not there ]\nbutterfly sort is one of the most efficient in parallelism ( log²(n)  step to sort n numbers )\nsee p113 [url]https://airccse.org/journal/ijdps/papers/3612ijdps09.pdf[/url]\nColor sort variant: see header.\n", "tags": ["sorting", "short", "histogram", "parallel"], "likes": 19, "viewed": 345, "published": 3, "date": "1674294430", "time_retrieved": "2024-07-30T18:14:21.163590", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// cf https://www.academia.edu/77537224/Parallel_butterfly_sorting_algorithm_on_GPU\n// color sort: switch #inf line 6  and  del .rrr line 11\n\n#define tex(i)   ivec2( (i) % n , (i) / n )\n#define inf(A,B) ( (A).x < (B).x )\n//#define inf(A,B) (  A.x == B.x ? A.y == B.y ? A.z == B.z ? A.w < B.w : A.z < B.z : A.y < B.y : A.x < B.x  )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    if ( iFrame < 1 ) { O = textureSize(iChannel1,0).x > 1 // init array\n                            ? texture(iChannel1, u/R ).rrrr\n                            : vec4(fract(1e4*sin(dot(u,R-17.)))); // fallback if texture not loaded\n                        return; }                     \n    O = T(u);                                         // last state \n    R = exp2(floor(log2(R))); \n    if ( u.x > R.x || u.y > R.y ) return;             // power-of-2 image only\n    int m = int(log2(R.x*R.y));\n    if ( iFrame >= ((m+1)*(m+2))/2 ) return;          // sort finished\n // if ( iFrame > n ) return;                         // min-max finished\n    \n    ivec2 I = ivec2(u);\n    int n = int(R.x), \n        i = I.x+ n*I.y,                               // 2D → linear index\n#if 0                                                 // min-max butterfly:\n        f = iFrame,\n#else                                                 // full butterfly:\n        F = iFrame, \n        t = int(.5+.5*sqrt(float(1+8*F))),            // build t = 1  2    3      4\n        f = (t*(t+1))/2 - F,                          //       f = 1, 2 1, 3 2 1, 4 3 2 1\n#endif\n        d = 1<<f,                                     // butterfly span\n        l = t==f ?  (d/2)-1 - 2*(i%(d/2))  :          // phase1. get twin side (i.e. offset to other) in the span \n            i%d < d/2 ? d/2 : -d/2;                   // phase2\n\n    vec4 T = T( tex(i + l) );                         // twin value to compare with\n    if ( inf(O,T) != l > 0 ) O = T;                   // if ill sorted, swap\n    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 54]], "test": "untested"}
{"id": "ddB3Rw", "name": "2.01-ShapingFunctions", "author": "retonym", "description": "practice shader made while going through thebookofshaders.com", "tags": ["thebookofshaders"], "likes": 0, "viewed": 137, "published": 3, "date": "1674286643", "time_retrieved": "2024-07-30T18:14:22.029275", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 uv, float line)\n{\n    //takes a vector 2 and uses it to plot a line\n    //that reflects an externally-applied mathematical relationship between x and y.\n    \n    return smoothstep(line - 0.02, line, uv.y) - \n           smoothstep(line, line + 0.02, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= (iResolution.x/iResolution.y);//2.0;\n    uv.x -= .85;\n    uv *= 1.2;\n    \n    //BASIC CURVES\n    //float y = pow(uv.x, 5.0);\n    //float y = exp(-5.0 * uv.x);\n    //float y = log(uv.x * PI); \n    //float y = sqrt(uv.x * 1.0); \n    \n    //STEPS\n    //float y = step(0.5, uv.x);\n    //float y = smoothstep(0.1, 0.9, uv.x);\n\n    //SIN AND COS\n    //sin and cos are handy, they give you nice, neat, 0-1, x and y values of points on the outer edge of a circle, based on the degree!\n    //float y = sin(uv.x * PI);\n    //float y = cos(uv.x * PI) * .5 + .5;\n    \n    \n    //INIGO QUILEZ SHAPER FUNCTIONS\n    //float y = exp(-10.0 * pow(uv.x, 2.0));  //\"Impulse\" -- change the last value to change the 'mouth' of the slide\n    \n    \n    \n    \n    \n    //HOMEWORK TIME! replicate the shapes in this image: \n    //https://thebookofshaders.com/05/kynd.png\n    //try to hide the formulas and figure out first before just copying!\n    \n    float y = uv.x;\n    \n    //ROW 1\n    float a = 0.5;\n    //y = 1.0 - pow(abs(uv.x), a);\n    \n    //ROW 2\n    //NOTE THE DIFFERENCE between these 2:\n    //y = sin(uv.x);\n    //y = pow(sin(uv.x), .5);  \n    //you can add get a quarter circle lookin curve by raising cos/sin x to the power of .5!\n    //pow adds a horizontal bulge-out/suck-in effect.\n    float b = 0.5;\n    //y = pow(cos(uv.x * .5 * PI), b);\n    \n    //ROW 3\n    float c = 1.5;\n    //y = 1.0 - pow(abs(sin((uv.x) * .5 * PI)), c);\n    \n    //ROW 4\n    float d = 0.5;\n    //i think i stumbled onto a shorter version of this formula than on the kynd sheet?\n    //y = pow(1.0 - abs(uv.x), d);\n    \n    //ROW 5\n    float e = 3.5;\n    //y = 1.0 - max(0.01, pow(uv.x * 2.0 + .2f, e));\n    //y *= .5f;\n\n    //Inigo Quilez impulse:\n    float k = 8.0f;\n    float h = k * (uv.x + .05f);\n    y = h * exp(1.0f - h);\n\n    \n    float line = plot(uv, y);\n    \n    float gradientY = step(uv.x, 0.0f);\n    vec3 gradientColor = vec3(gradientY);\n    vec3 lineColor = vec3(0.0, 1.0, 0.0);\n    vec3 color = ((1.0 - line) * gradientColor) + (line * lineColor);\n\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddB3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 59, 194, 299], [301, 301, 358, 408, 2554]], "test": "untested"}
{"id": "cssXDj", "name": "2.01-ColorWheel", "author": "retonym", "description": "exercise done while going through www.thebookofshaders.com", "tags": ["thebookofshaders"], "likes": 1, "viewed": 148, "published": 3, "date": "1674286443", "time_retrieved": "2024-07-30T18:14:23.037579", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //squash screen space into a square instead of a rectangle\n    vec2 uv = fragCoord/iResolution.xy;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n    uv.x -= .4;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n    \n    //E1: MAKE COLOR WHEEL SPIN\n    //redundant but i just needed to make this its own line\n    float time = iTime;\n    color = hsb2rgb(vec3((angle/TWO_PI)+time,radius,1.0));\n    \n    \n    //E2: MAKE ONE HUE COVER A GREATER ANGLE AND ALL THE REST A SMALLER ANGLE\n    //distort the angle -- color bands will look narrow on the 'ends', wide in the 'center'\n    angle = (pow(angle, 3.0));\n    color = hsb2rgb(vec3((angle/TWO_PI)+time,radius,1.0));\n\n    \n    //E3: FIX THE COLOR WHEEL WITH SHAPING FUNCTIONS\n    //ref to match: https://thebookofshaders.com/06/colorwheel.png\n    //angle = atan(toCenter.y,toCenter.x);\n    //angle = angle/TWO_PI + .5;\n    //angle = pow(angle, 2.0);\n    //color = hsb2rgb(vec3((angle + 0.05),radius,1.0));\n    \n       \n    //E4: add the circle frame around the wheel\n    vec2 center = vec2(0.5, 0.5);\n    float len = distance(uv, center);\n    len = step(.5, len);\n    vec3 circle = vec3(len, len, len);\n    circle = 1.0 - circle;\n\n\n    fragColor = vec4(color * circle,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 151, 177, 177, 410], [413, 413, 468, 531, 1880]], "test": "untested"}
{"id": "dlBGD1", "name": "2.2 - Radial Values for Dummies", "author": "retonym", "description": "exercises done while going through thebookofshaders.com\nim bad at math so i write a lot of notes to try to understand better!", "tags": ["thebookofshaders"], "likes": 0, "viewed": 205, "published": 3, "date": "1674286422", "time_retrieved": "2024-07-30T18:14:23.949142", "image_code": "#define PI 3.1415926535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // EDIT: fixing screen ratio distortion. previously had overcomplicated stretching/ratio shenanigans\n    // fragCoord is a value anywhere from 0x0, to 945x531, representing the current pixel coordinates\n    // iResolution is just 945x531.\n    // uv is current pixel coordinate minus one half screen (x+y), to move it that half screen up+right to the center,\n    // divided by the y to get rid of the screen stretch\n    // this means (0,0) is now the center of the screen!\n    vec2 uv = (fragCoord - (.5 * iResolution.xy))/iResolution.y;\n    \n\n    //These are notes digging into the 'atan' part of this lesson: https://thebookofshaders.com/06/\n    //GOAL: draw a circle around the center of the screen and vary its color based on angle.\n\n\n    //RADIAL VALUES FOR DUMMIES\n \n       \n    //to map around a circle, we need to get the current pixel's angle relative to a\n    // baseline angle. we can get the angle of the vector from the center of the screen to the current pixel\n    // in radians, using atan\n    // ok that's a lot of math words. what the heck is atan?\n\n    // so... imagine that this pixel's distance from the center is drawn as a line from the center of the screen\n    // to the current pixel. A nice diagonal line.\n    \n    //      . < current pixel\n    //     /\n    //    /\n    //   /\n    //  . < center of screen\n    \n    // now imagine we draw out a horizontal line and a vertical line representing the \n    // 'height and width' of this diagonal.\n\n    //      .\n    //     /|\n    //    / |< height line\n    //   /  |\n    //  .___| \n    //    ^\n    //   width line\n    \n\n    // i'm bad at math but this link shows how the triangle's left-side angle value changes based on \n    // the horizontal line length and vertical line length: \n            // mathopenref.com/arctan.html\n\n    // i'm still not sure what exactly arctan (long name for atan) is doing inside the math black box \n        // that is its function, \n    // but it seems that when you write out atan(height, width) \n    // what you're essentially doing is giving atan the height line and width line, and then it uses that\n    // to find and return the angle of the that inner corner of the triangle shown above. \n\n    float angleInRadians = atan(uv.y, uv.x);\n    \n    // this angle isn't in degrees, but in radians. \n    // we actually don't need to convert it to degrees. We just want to remap any output values\n    // we get from atan across a 0 to 1 space, where 0 = -180 degrees and 1 = 180 degrees.\n    \n    // right now the minimum angleInRadians we will ever get as output is -PI. -PI radians is -180 degrees.\n    // and the maximum angleInRadians we will ever get as output is PI. PI radians is 180 degrees.\n    // this is just how arctan works, those are the most extreme values it can put out.\n    \n    // so you can think of our output values as falling across a -PI to PI range\n    // (i'm gonna think of this as a -3.14 to 3.14 range for ease of visualization.)\n    \n    // .[-3].....[-2].....[-1].....[0].....[1].....[2].....[3].\n\n    // and the output values falling across that range, i want to squish down into a 0 to 1 range\n\n    //                      [-.5]..[0]..[.5]\n\n    // as you can see, the big range is ~6.28 times as big as the small range\n    // which means any output values i get from arctan are also ~6.28 times too big\n    // so i can take my output values, and divide them by ~6.28 to squish em down into this 0 to 1 space.\n\n    float zeroToOneRadialValue = angleInRadians / (2.0 * PI);\n\n    // then i need to add .5 to my output values to shift them from a (-.5, .5) range up into a (0, 1) range\n    \n    //                             [0].....[1]\n    \n    zeroToOneRadialValue += 0.5;\n    \n    // great, now we have a radial gradient going from -180 to 180.\n    // use this line as the final output to preview how it looks when red is mapped across this gradient!\n    //fragColor = vec4(zeroToOneRadialValue, 0, 0, 1);\n\n\n    // now if i wanna turn this into a rainbow circle\n    // i can do that by picturing a 'venn diagram' of colors: red, green, blue, red.\n    // when these colors overlap each other they form the entire rainbow spectrum.\n    //  (     R   { Y )   G   [ GB }   B   ( V ]   R     )\n    // so i just wanna map these 4 colors across my 0-1 space.\n    \n\n\n    // EDIT: to get a color band with a soft falloff, i'll use... SMOOTHSTEP (ty FabriceNeyret2!):\n    \n    // smoothstep( floor, ceiling, abs(x - c) )\n    \n    // this is tricky to visualize at first, but imagine x is a horizontal space, and\n    // c is the spot we want to place our color band gradient in that space.\n    // when you draw abs(x - c) it is basically a positive value that bounces off 0 at the spot we want our gradient.\n\n    //      \\  /\n    //  0....\\/.............\n    //       c\n\n    // smoothstep takes those values, and clamps em into a curve between 2 ceiling and floor values provided.\n    // then whatever the resulting values are, it remaps across a 0-1 space.\n    \n    // so when smoothstep clamps that abs(x-c) in between the floor and ceiling values, and remaps them, we get this:\n\n\n    //                 smoothstep( 0, w, abs(x - c) )\n    //bright color (1)   ______    __________\n    //                         \\  /\n    //black  (0)                \\/\n\n\n    // essentially x is flooded with color except for a black gradient band right at that bounce point.\n    // to invert the gradient you can swap the ceiling and floor values, then you get this:\n    \n\n    //                 smoothstep( w, 0, abs(x - c) )\n    //bright color (1)    \n    //                          /\\ \n    //black  (0)         ______/  \\__________\n\n\n    //phew! then you can just map that gradient across your radial space instead of a horizontal one.\n\n        \n    float redGradient1 = smoothstep(.5, 0.0, abs(zeroToOneRadialValue));\n    float greenGradient = smoothstep(.35, 0.0, abs(zeroToOneRadialValue - .35));\n    float blueGradient = smoothstep(.35, 0.0, abs(zeroToOneRadialValue - .65));\n    float redGradient2 = smoothstep(.5, 0.0, abs(zeroToOneRadialValue - 1.0));\n    \n    \n    vec4 rainbowGradient = vec4(redGradient1 + redGradient2, greenGradient, blueGradient, 1);\n    \n    //i want red at the start and at the end so that the gradient loops/tiles nicely.\n    \n    // use this line as the final output to preview how the rainbow gradient looks!\n    //fragColor = rainbowGradient;\n    \n    \n    \n    \n    // the last thing i want to do is put this inside a circle.\n    // i can draw a circle by checking the distance of the current pixel from the center of the screen\n    // and using a step function to set the color to black if the pixel is outside the radius.\n    //EDIT: don't need to do distance from 0,0. use len :)\n    float len = length(uv);\n    len = step(.5, 1.0-len);\n     \n    //then just combine the circle and the rainbow!\n    fragColor = len * rainbowGradient;\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 563, 6976]], "test": "untested"}
{"id": "mtfSzH", "name": "Star Field (raymarching)", "author": "null_ptr", "description": "My first shader with raymarching", "tags": ["raymarching", "stars"], "likes": 2, "viewed": 243, "published": 3, "date": "1674270335", "time_retrieved": "2024-07-30T18:14:24.771942", "image_code": "#define MAX_STEP 32\n#define STAR_RANGE 0.03\n#define PI 3.1415926536\n#define ANGLE PI/6.\n\nfloat hash1( in vec3 p )\n{\n    p  = 50.0*fract( p*2.3183099 );\n    return fract( p.x*p.y*(p.x+p.y + 0.6543) + p.z*22.632334);\n}\n\nvec3 relative_star_pos( in vec3 ind)\n{\n\treturn 0.9 * vec3(hash1(ind * 2.65 + vec3(1.11, 3.67, 4.6)), hash1(ind * 34. + vec3(123.21,657.15, 12.347)), hash1(ind + vec3(0.1,0.2,.04)))*STAR_RANGE;\n}\n\nvec3 absolute_star_pos( in vec3 ind)\n{\n\treturn relative_star_pos(ind) + ind*vec3(STAR_RANGE);\n}\n\nfloat dist_to_nearest_star( out vec3 star_ind, in vec3 p)\n{\n\tvec3 ind0 = floor(p / vec3(STAR_RANGE));\n\tfloat l = 1e10;\n\tfor (int x = -1; x <= 1; x++)\n\t\tfor (int y = -1; y <= 1; y++)\n\t\t\tfor (int z = -1; z <= 1; z++)\n\t\t\t{\n\t\t\t\tfloat new_l = distance(absolute_star_pos(ind0 + vec3(x,y,z)), p);\n\t\t\t\tif (new_l < l)\n                    star_ind = ind0 + vec3(x,y,z), l = new_l;\n\t\t\t}\n\t\n\treturn l;\n}\n\nvec3 star_color (in vec3 ind)\n{\n    return vec3(hash1(ind), hash1(ind + 1.2), hash1(ind*2.46 + 3.567));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0,0,0);\n\t\n\tvec2 mousePos = iMouse.yx/iResolution.yx - vec2(0.25, 0.75);\n\tfloat cos_x = cos(mousePos.x), sin_x = sin(mousePos.x);\n\tfloat cos_y = cos(mousePos.y), sin_y = sin(mousePos.y);\n\tmat3 rot = mat3(cos_y, 0,  sin_y,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t-sin_y, 0, cos_y);\n\trot *= mat3(1, 0, 0,\n\t\t\t\t0, cos_x, -sin_x,\n\t\t\t\t0, sin_x, cos_x);\n\n\tvec3 ro = vec3(0.,0.,-iTime/10.), rd = normalize(rot*vec3(sin(uv * ANGLE), -1.));\n\t\n    //Some noise\n\t//rd += 1e-3 * vec3(hash1(vec3(uv, iTime)) * 2. - 1., hash1(vec3(uv+1.34, iTime*2.378)) * 2. - 1., hash1(vec3(uv*5.6 + 1.4, iTime*12.32)) * 2. - 1.);\n\t\n\tfloat t = 0.;\n\tint i;\n\t\n\tfor (i = 0; i < MAX_STEP; i++)\n\t{\n\t\tvec3 ind0;\n\t\tfloat d = dist_to_nearest_star(ind0, ro + t*rd);\n\t\tt+=d;\n\n\t\tif (t >= 0.5)\n\t\t\tbreak;\n\t\t\n\t\tfloat l = d;\n\t\tl = 1./(1e4*l);\n\t\tl *= pow(1.1, -l*1.);\n\t\tcol += clamp(vec3(l), 0., 1.) * star_color(ind0) * pow(1.1, -t*40.);\n\t}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 115, 115, 216], [218, 218, 256, 256, 412], [414, 414, 452, 452, 509], [511, 511, 570, 570, 901], [903, 903, 934, 934, 1008], [1010, 1010, 1067, 1067, 2039]], "test": "untested"}
{"id": "mtSGDt", "name": "Swarming Anchoveta", "author": "fenix", "description": "75k Engraulia ringens, the Peruvian anchoveta, form into a swarm in an attempt to dissuade predators.\n\nFeaturing \"ocean under\" by rockhard https://shadertoy.com/view/7dyXWc\n\n*mouse to attract the swarm*\n*shift to disable ssao*\n*space to disable fxaa*", "tags": ["3d", "simulation", "particles", "ocean", "dynamics", "fish", "ssao", "swarm"], "likes": 73, "viewed": 978, "published": 3, "date": "1674264061", "time_retrieved": "2024-07-30T18:14:26.009633", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  75k Engraulia ringens, the Peruvian anchoveta, form into a swarm in an attempt to\n//  dissuade predators. Water surface borrowed from rockhard's\n//\n//      ocean under               https://shadertoy.com/view/7dyXWc\n//\n//  FXAA from reinder's\n//\n//      Post process - FXAA       https://shadertoy.com/view/ls3GWS\n//\n//  SSAO originally from iq's\n//\n//      SSAO (basic)              https://www.shadertoy.com/view/Ms23Wm\n//\n//  I saw these fish swarms, and I thought it looked like a good use for SSAO.\n//\n//      https://www.researchgate.net/profile/Michael-Thrun/publication/338880262/figure/fig1/AS:1033391478669313@1623391136755/A-fish-swarm-in-the-form-of-a-ball-Uber-Pix-2015-an-example-of-emergence-in-swarms.ppm\n//\n//  Since I already had particles rendering with SSAO, I modified the particle sim to\n//  to move like this swarm, and then modified the particle rendering to draw ellipoids\n//  instead of spheres, with an environment map. For the environment map and background\n//  I borrowed the water surface from the excellent \"water under\" by rockhard (if (s)he\n//  sees this I hope (s)he's OK with my pilfering...if not please let me know).\n//\n//  The physics simply treats the particles as spheres. But, the screen-space voronoi \n//  neighbor search does take the ellipsoid shape into account (otherwise the heads and\n//  tails of the fish get lost).\n//\n//  As usual I'm not really that happy with the anti-aliasing. The FXAA avoids the worst\n//  artifacts at least. Suggestions are welsome!\n//\n//  Click mouse to attract the swarm. Space to disable SSAO, shift to disable FXAA.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D performs lighting and SSAO\n//  Image performs FXAA post-process\n//\n// ---------------------------------------------------------------------------------------\n\n// From reinder's  Post process - FXAA\n//    https://www.shadertoy.com/view/ls3GWS\n// he got it from:\n//    http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 AArender( vec2 uv2 )\n{    \n    uv2 /= iResolution.xy;\n    vec2 rcpFrame = 1. / iResolution.xy;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = textureLod(iChannel0, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(iChannel0, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(iChannel0, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(iChannel0, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(iChannel0, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(iChannel0, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (keyDown(KEY_SPACE))\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor.xyz = AArender(fragCoord);\n        \n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .025;\nconst vec3 FISH_SIZE = vec3(4, .4, .8)*PARTICLE_SIZE;\nconst float FAR_CLIP = 1e6;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    ivec4 nbs[4];\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.vel = particleData5.xyz;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 75000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, 0., 0);\n    cameraPos\t = vec3(0, -1, 3.5);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.resolution = -iResolution.x * iResolution.y;\n}\n\n#define fxInitState(state) fxGetStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    \n    fxState state;\n    state.resolution = data0.x;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, 0, 0, 0);\n}\n\n// G BUFFER\n\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n, pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n = fragColor.xyz;\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/intersectors/\n// ellipsoid centered at the origin with radii ra\nfloat eliIntersect( in vec3 ro, in vec3 rd, in vec3 ra )\n{\n    vec3 ocn = ro/ra;\n    vec3 rdn = rd/ra;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h = b*b - a*(c-1.0);\n    if( h<0.0 ) return -1.; //no intersection\n    h = sqrt(h);\n    return (h - b) / a;\n}\n\nvec3 eliNormal( in vec3 pos, in vec3 ra )\n{\n    return normalize( pos/(ra*ra) );\n}\n\nfloat fishIntersect(fxParticle p, vec3 ro, vec3 rd, out vec3 normal)\n{\n    vec3 front = normalize(p.vel);\n    vec3 left = -normalize(cross(vec3(0, 1, 0), front));\n    vec3 up = -normalize(cross(left, front));\n    mat3 m = mat3(front, left, up);\n    mat3 mi = inverse(m);\n    \n    vec3 ero = mi * (ro - p.pos);\n    vec3 erd = mi * rd;\n    \n    float t = eliIntersect(ero, erd, FISH_SIZE);\n    vec3 hitPos = ero + erd * t;\n    normal = m * eliNormal(hitPos, FISH_SIZE);\n\n    return t;\n}", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nvoid particleStep(inout fxParticle p, fxState state, int id)\n{\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init\n        for (int i = 0; i < 100; ++i) // kinda dumb, but just keep trying until it's in a sphere (relax it's just init)\n        {\n            vec3 h = hash3( uvec3(id, iFrame, i) );\n\n            p.pos = h * 2. - 1.;\n            p.vel = vec3(0);\n            \n            if (length(p.pos) < 1.)\n            {\n                p.pos *= 1.2; // expand a bit\n                p.vel.xz = p.pos.zx * vec2(1, -1) * .01; // initial swarm rotation\n                return;\n            }\n        }\n        \n        return;\n    }\n\n    // particle update\n    p.vel.xz += p.vel.zx * vec2(1, -1) * sin(iTime * 15. + float(id)) * .04; // swim\n    p.vel.xz += p.pos.zx * vec2(1, -1) / sqrt(length(p.pos.xz)) * .0001; // swarm rotation\n    p.vel.xz -= p.pos.xz * .00015; // attract to swarm center\n    p.vel.y -= p.pos.y * .0001; // attract to swarm center\n    \n    vec3 attractPos;\n    float attractStrength;\n    if (iMouse.z > 0.)\n    {\n        // mouse interact\n        attractPos = (iMouse.xy - .5 * iResolution.xy).xyy * vec3(1, 1, 0) / iResolution.y;\n        attractStrength = .0005;\n    }\n    else\n    {\n        // drag the swarm around a bit more gently if no mouse, to keep it changing\n        attractPos = sin(iTime * vec3(.2, 0, .2));\n        attractStrength = .0001;\n    }\n    p.vel += (attractPos - p.pos) / length(attractPos - p.pos) * attractStrength;\n    \n    // collide with neighbors (only as sphere)\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            int nid = p.nbs[i][j];\n            if (nid < 0) break;\n            fxParticle nb = fxGetParticle(nid);\n            vec3 delta = nb.pos - p.pos;\n\n            if (length(delta) > 1e-6 && length(delta) < PARTICLE_SIZE * 2.)\n            {\n                vec3 dir = normalize(p.pos - nb.pos);\n\n                // position correction\n                p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .25);\n\n                // clip velocity\n                vec3 relVel = p.vel - nb.vel;\n                p.vel -= dot(relVel, dir) * dir;\n            }\n        }\n    }\n\n    p.vel *= .99; // damping\n    const float MAX_SPEED = .2; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n\n    p.pos += p.vel; // integrate\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // consider neighbors' neighbors\n                for (int x = 0; x < 4; ++x)\n                {\n                    ivec4 nbsNbs = ivec4(fxGetParticleData(nid, x));\n                    for (int y = 0; y < 2; ++y)\n                    {\n                        int nbNid = nbsNbs[y];\n                        if (nbNid < 0) break;\n                        sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                    }\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 3;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, state, id);\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    fxParticle p = fxGetParticle(id);\n    vec3 hitPos;\n    float t = fishIntersect(p, ro, rd, hitPos);\n\n    if (t == -1.) return FAR_CLIP;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            for (int i = 0; i < 3; ++i)\n            {\n                ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j * 4 + i)));\n                ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n                int nid = nbs[h.y % 4];\n\n                if (nid >= 0)\n                {\n                    float dis2 = distance2Particle(nid, cameraPos, rayDir);\n                    insertion_sort( new, dis, nid, dis2 );\n                }\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 16u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 4; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, cameraPos, rayDir);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, cameraPos, rayDir));\n        }\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// draw one fish\nbool renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    vec3 normal;\n    float t = fishIntersect(p, ro, rd, normal);\n    if (t > 0. && t < pix.t)\n    {\n        pix.n = normal;\n        pix.t = t;\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        if (!renderParticle(id, data, cameraPos, rayDir, pix)) break;\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Lighting and shading first pass\n// ---------------------------------------------------------------------------------------\n\n// water surface borrowed from \"ocean under\" by rockhard\n//     https://shadertoy.com/view/7dyXWc\nfloat wavedx(vec2 position, vec2 direction, float time, float freq){\n    float x = dot(direction, position) * freq + time;\n    return exp(sin(x) - 1.0);\n}\n\nfloat getwaves(vec2 position){\n    float iter = 0.0,phase = 6.0,speed = 2.0;\n    float weight = 1.0,w = 0.0,ws = 0.0;   \n    for(int i=0;i<5;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        float res = wavedx(position,p,speed*iTime,phase);        \n        w += res * weight; ws += weight;\n        iter += 12.0; weight *=0.75; phase *= 1.18; speed *= 1.08;\n    }\n    return w / ws;\n}\nfloat sea_octave(vec2 uv,float choppy){\nreturn getwaves(uv*choppy)+getwaves(uv); }\n\nconst vec3 WATER_COLOR = vec3(0.0,0.39,0.62);\nvec3 water(vec3 cameraPos, vec3 rayDir)\n{\n    vec3 sun = vec3(-0.6, 0.5,-0.3); \n    float i = max(0.0, 1.4/(length(sun-rayDir)+1.0));\n    vec3 col = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8));\n    col = mix(col, WATER_COLOR,(1.0-rayDir.y)*0.9);   \n\n    if (rayDir.y > 0.0){//water suf\n        float d = (cameraPos.y-3.0)/rayDir.y;\t\n        vec2 wat = (rayDir * d).xz-cameraPos.xz;\n        d += sin(wat.x + iTime);\n        wat = (rayDir * d).xz-cameraPos.xz;     \n        wat = wat * 0.1 + 0.2* texture(iChannel0,wat*0.01).xz;      \n        col += sea_octave(wat,0.5) * max(2.0/-d, 0.0);\n    }\n    \n    return col*col*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel0, fragCoord/iResolution.xy));\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (pix.t >= FAR_CLIP)\n    {\n        fragColor.xyz = water(cameraPos, rayDir);\n    }\n    else\n    {\n        // ssao model inspired by SSAO (basic) by iq: https://www.shadertoy.com/view/Ms23Wm\n        // sample neighbor pixels\n        float ao = 0.0;\n        const float SAMPLES = 20.; // increase for higher quality if your GPU can handle it\n        for( float i=0.; i<SAMPLES; i++ )\n        {\n            vec3 h = hash3(uvec3(fragCoord, 0));\n\n            // get a random 2D offset vector\n            vec2 off = texture(iChannel1, (fragCoord.xy + 23.71*float(i)) / iChannelResolution[1].xy).xz - .5\n                + vec2(0, 1.); // shift search in the direction of normal\n            off += sign(off) * .0; // don't waste samples looking at nearby pixels\n\n            // sample the zbuffer at a neightbor pixel\t\t\n            fxGBufferPixel nbPix = fxUnpackGBuffer(texture(iChannel0, fragCoord.xy / iResolution.xy + off * .03));\n            \n            // accumulate occlusion if difference is less than 0.02 units\t\t\n            ao += clamp((pix.t-nbPix.t)/.02, 0., 1.);\n        }\n        \n        // average down the occlusion\t\n        ao = clamp(1. - ao/SAMPLES, 0., 1.);\n        \n        // lighting\n        vec3 hitPos = cameraPos + rayDir * pix.t;\n        float hf = (smoothstep(-.7, -.1, hitPos.y) * .9 + .1); // darken lowest area (cheat!) because ao doesn't reach far enough\n        if (keyDown(KEY_SHIFT)) { ao = 1.; hf = 1.; }\n        fragColor.xyz = ao * water(hitPos, pix.n) * .95 * hf + WATER_COLOR * .05;\n    }\n\n    fragColor.a = 1.;\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSGDt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2504, 2504, 2531, 2531, 4380], [4382, 4466, 4489, 4489, 4649], [4651, 4651, 4708, 4708, 4953]], "test": "untested"}
{"id": "mlfSz8", "name": "Gamma experiment", "author": "JB_0x0003", "description": "Different gamma encoding methods based on https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BThe%20sRGB%20learning%20curve%5D%5D", "tags": ["experiment", "scroll", "gamma"], "likes": 0, "viewed": 138, "published": 3, "date": "1674259423", "time_retrieved": "2024-07-30T18:14:26.860358", "image_code": "// Experiment with different gamma encoding methods\n// Each column in each color is a different gamma encoding\n// From left to right: linear, gamma=2.2, and srgb\n// Based on https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BThe%20sRGB%20learning%20curve%5D%5D\n\nvec3 SRGBToLinear(vec3 inputCol){\n\n\n    for (int i=0; i<3; ++i){\n    \n        if( inputCol[i] < 0.04045 )\n            inputCol[i] /= 12.92;\n        else\n            inputCol[i] = pow((inputCol[i] + 0.055)/1.055,2.4);\n        \n    }\n    return inputCol;\n\n}\n\nvec3 panelColor(in vec2 uv, in vec3 hue){\n\n    float baseColor = abs(mod((uv.y + iTime),1.0) * 2.0 - 1.0);\n    vec3 linearColor;\n    \n    //initially linear\n    linearColor = vec3(baseColor) * hue;\n    \n    if ( uv.x > 0.3333){\n    \n        //Interpret as though stored as gamma 2.2\n        if (uv.x <= 0.6666){\n        \n            linearColor.x = pow(linearColor.x, 2.2);\n            linearColor.y = pow(linearColor.y, 2.2);\n            linearColor.z = pow(linearColor.z, 2.2);\n    \n        //Interpret as though stored as srgb\n        } else{\n        \n           linearColor = SRGBToLinear(linearColor);\n        \n        }\n    }\n    \n    \n\n    //Assume monitor is already gamma 2.2, so correct for that\n    linearColor.x = pow(linearColor.x, 1.0/2.2);\n    linearColor.y = pow(linearColor.y,1.0/2.2);\n    linearColor.z = pow(linearColor.z,1.0/2.2);\n\n\n    return linearColor;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //hues\n    vec3 hue1 = vec3(0.6,1.0,0.0);\n    vec3 hue2 = vec3(1.0,0.5,0.2);\n    vec3 hue3 = vec3(0.6,0.3,0.8);\n    vec3 hue4 = vec3(1.0,1.0,1.0);\n\n    \n\n    //different hue for each panel\n    vec3 color;\n    if (uv.y >= 0.5){\n    \n        if(uv.x <= 0.5)\n            //each panel is normalized to its own uv coordinates\n            //it'd be better to add borders but I'm laaaaazy\n            color = panelColor((mod(uv,0.5) * 2.0 ),hue1);\n        else\n            color = panelColor((mod(uv,0.5) * 2.0 ),hue2);\n    }else {\n        if(uv.x <=0.5)\n            color = panelColor((mod(uv,0.5) * 2.0 ),hue3);\n        else\n            color = panelColor((mod(uv,0.5) * 2.0 ),hue4);\n    \n    }\n\n    \n    //output :)\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 298, 298, 520], [522, 522, 563, 563, 1401], [1403, 1403, 1460, 1510, 2302]], "test": "untested"}
{"id": "ctXXRH", "name": "Test API", "author": "libreliu", "description": "All channels & passes are on", "tags": ["test"], "likes": 0, "viewed": 176, "published": 3, "date": "1674242643", "time_retrieved": "2024-07-30T18:14:27.702108", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "ctXXR8", "name": "Cornell Box Scene Description", "author": "shaofun", "description": "A very simple physics-based ray-tracing renderer.\nWASDQE to move, SHIFT to accelerate, SPACE to refresh.\n\n\ngithub: https://github.com/HK-SHAO/RayTracingPBR", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr"], "likes": 1, "viewed": 239, "published": 3, "date": "1674232475", "time_retrieved": "2024-07-30T18:14:28.937804", "image_code": "// Fork of \"A very simple PBRT\" by shaofun. https://shadertoy.com/view/Dtj3DG\n// 2023-01-20 16:08:57\n\n// Fork of \"RayTracing PBR with Free Camera\" by shaofun. https://shadertoy.com/view/ddSSWy\n// 2023-01-16 08:11:26\n\n// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color  = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    color.rgb = color.rgb / color.a;\n    \n    // 色调映射\n    color.rgb *= camera_exposure;\n    color.rgb  = ACESFitted(color.rgb);\n    \n    // 伽马矫正\n    color.rgb = pow(color.rgb, vec3(1.0 / gamma));\n    \n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(0.0, 0.2, 4.0, 0.0));\n        store(ROTATION, vec4(0.0));\n        \n        store(TARGET,   vec4(0.0, 0.0, 3.5, 0.0));\n        store(TMOUSE,   vec4(0.0));\n        store(PMOUSE,   vec4(0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// 摄像机参数\nconst float camera_vfov       = 35.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 2.0;                  // 摄像机的对焦距离\nconst float camera_aperture   = 0.002;                // 摄像机的光圈大小\nconst float camera_exposure   = 0.6;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.002;                     // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 2000.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.00005;                   // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = 0.000001;                  // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 3U;                        // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// https://www.shadertoy.com/view/ddSSWy before 2023.01.17", "buffer_b_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野角度\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// 地图列表\nconst object[] map = object[] (\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, -1),\n                    vec3(0, 0, 0),\n                    vec3(1, 1, 0.2)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.4, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 1, 0),\n                    vec3(90, 0, 0),\n                    vec3(1, 1, 0.2)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.4, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, -1, 0),\n                    vec3(90, 0, 0),\n                    vec3(1, 1, 0.2)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.4, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(-1, 0, 0),\n                    vec3(0, 90, 0),\n                    vec3(1, 1, 0.2)\n        ),\n        material(vec3(1, 0, 0)*0.5, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(1, 0, 0),\n                    vec3(0, 90, 0),\n                    vec3(1, 1, 0.2)\n        ),\n        material(vec3(0, 1, 0)*0.5, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(-0.275, -0.3, -0.2),\n                    vec3(0, -253, 0),\n                    vec3(0.25, 0.5, 0.25)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.4, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0.26, -0.55, 0.35),\n                    vec3(0, -197, 0),\n                    vec3(0.25, 0.25, 0.25)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.4, // 基础色\n                    vec3(1), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.530  // 折射率\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0.809, 0),\n                    vec3(90, 0, 0),\n                    vec3(0.2, 0.2, 0.01)\n        ),\n        material(vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(100), // 自发光\n                    1.0, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.0  // 折射率\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2  rud = lens_radius * random_in_unit_disk();\n    vec3  offset = x * rud.x + y * rud.y;\n    \n    // 计算半高、半宽、左下角位置等\n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    p *= angle(radians(rotation));\n    \n    return sd_box(p, scale);\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o = map[0]; o.dis = abs(signed_distance(o, p));\n    for (int i = 1; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 光线步进检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis;\n    }\n    return rec;\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float NoI, float F0) {\n    return mix(pow(abs(1.0 + NoI), 5.0), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float NoI, float F0, float roughness) {\n    return mix(fresnel_schlick(NoI, F0), F0, roughness);\n}\n\n// 在切线空间半球采样\nvec3 hemispheric_sampling(vec3 nor) {\n    vec2  r = rand21() * vec2(2.0, TAU) - vec2(1, 0);\n    vec2 xy = sqrt(1.0 - r.x*r.x) * vec2(sin(r.y), cos(r.y));\n    float z = r.x;\n    \n    return normalize(nor + vec3(xy, z));\n}\n\n// 用粗糙度改变采样方向\nvec3 roughness_sampling(vec3 hemispheric_sample, vec3 nor, float roughness) {\n    float alpha = roughness * roughness;\n    return normalize(mix(nor, hemispheric_sample, alpha));\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    float ior          = rec.obj.mtl.ior;\n    \n    vec3 normal = rec.normal;\n    bool outer = dot(normal, r.direction) < 0.0; // 光正在从外面穿入物体表面\n    \n    vec3 I  =  r.direction; // 入射光方向\n    vec3 N  =  normal *= outer ? 1.0 : -1.0; // 如果处于 SDF 物体内部就反过来\n    vec3 C  =  r.color; // 光的颜色\n    vec3 L; // 出射光方向\n    \n    vec3  hemispheric_sample = hemispheric_sampling(normal); // 切线空间的半球采样方向\n    \n    N = roughness_sampling(hemispheric_sample, normal, roughness);\n    float NoI = dot(N, I);\n\n    float eta = outer ? ENV_IOR / ior : ior / ENV_IOR; // 计算折射率之比\n    float k   = 1.0 - eta * eta * (1.0 - NoI * NoI); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 2.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoI, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.x < F + metallic || k < 0.0) {\n        L = I - 2.0 * NoI * N; // 包含镜面反射、菲涅尔反射、全反射\n        // 下面可以提高帧数，但是会导致透明材质发黑，需要优化\n        C *= float(dot(L, normal) > 0.0); // 如果光穿入或穿出表面就直接吸收掉\n    } else if (rand2.y < transmission) {\n        L = eta * I - (sqrt(k) + eta * NoI) * N; // 斯涅尔折射\n    } else {\n        L = hemispheric_sample; // 漫反射\n    }\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) {\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= 0.0;\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 更新光子的位置\n        r.origin = rec.pos;\n        \n        // 应用 PBR 材质更新光线\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n        r.color *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        // 光太暗或者击中光源\n        if (intensity < visible || visible < VISIBILITY) break;\n    }\n\n    return r;\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, iTime*iTimeDelta));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXXR8.jpg", "access": "api", "license": "mit", "functions": [[317, 417, 446, 486, 1004], [1006, 1006, 1061, 1061, 1406]], "test": "untested"}
{"id": "DtXSR8", "name": "Bouncing Orb", "author": "QuantumSuper", "description": "Looking into the depth with shadows never reaching the light.", "tags": ["raymarching"], "likes": 1, "viewed": 196, "published": 3, "date": "1674230925", "time_retrieved": "2024-07-30T18:14:29.973036", "image_code": "// Bouncing Orb v0.91-220120\n// Simple distance-aided ray marching with floor and spheres.\n// Inspired by The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n\n// DEFINITIONS\n// Calculation precision\n#define MAX_STEPS 70\n#define MAX_DISTANCE 110.0\n#define MIN_DISTANCE 0.01\n\n// Global objects, lights & cam initializations\nstruct object{\n\tint type; //0: floor; 1: sphere\n\tvec4 param; //horizontal plane: y, y, y, y; sphere: x, y, z, radius\n};\nobject[4] objects; // ...is there a better way to get iterability of different objects?\nstruct light{ //spotlights\n\tvec3 pos; //x,y,z; position of light\n\tvec3 col; //(r,g,b)*amp; color & brightness of light\n};\nlight[2] lights;\nfloat[2] animTime; //time for object operations\nfloat camTime; //time for camera operations\n\n// FUNCTIONS\n// Calculate distance from position p to next object\nfloat getDistance(vec3 pos){\t\n\tfloat minDist = MAX_DISTANCE; //max minDist\n\t\n\tfor (int n=0; n<objects.length(); n++){ //get the distance to each object\n\t\tswitch (objects[n].type){\n\t\t\tcase 0: //hPlane\n\t\t\t\t//minDist = min(minDist, pos.y-objects[n].param.y); break; //hPlane static\n                minDist = min(minDist, pos.y-objects[n].param.y+0.2*sin(animTime[1])*sin(4.0*animTime[0]-length(pos)/0.2)*smoothstep(22.*clamp(0.9+cos(animTime[1]),0.,2.),-0.1,pos.x*pos.x+pos.z*pos.z)); break; //hPlane flubber, ?BUG for long iTime: pattern breaks\n\t\t\tcase 1: //sphere\n\t\t\t\tminDist = min(minDist, length(pos-objects[n].param.xyz)-objects[n].param.w); break;\n\t\t\tcase 2: //flubber sphere\n\t\t\t\tminDist = min(minDist, length(pos-objects[n].param.xyz)-objects[n].param.w+0.1*cos(animTime[1])*smoothstep(-0.2,1.2,abs(cos(pos.x*pos.y*pos.z)))); break;\n\t\t}\n\t}\n\t\n\treturn minDist;\n}\n\n// March the ray through tracing spheres\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection){\n\tfloat rayLength = MIN_DISTANCE; \n\tfloat radSphere;\n\t\n\tfor (int n=0; n<MAX_STEPS; n++){\n\t\tradSphere = getDistance(rayOrigin+rayLength*rayDirection); //get sphere\n\t\trayLength += radSphere; //march\n\t\tif (rayLength>MAX_DISTANCE || abs(radSphere)<MIN_DISTANCE) break;\n\t}\n\t\n\treturn rayLength;\n}\n\n// Estimate the surface normal at position p\nvec3 guessNormal(vec3 pos){\n\tvec2 tangent = vec2(MIN_DISTANCE, 0);\n\t\n\tvec3 normal = getDistance(pos) - vec3(\n\t\tgetDistance(pos-tangent.xyy),\n\t\tgetDistance(pos-tangent.yxy), \n\t\tgetDistance(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\n// Calculate light diffusion\nvec3 getSpotlight(vec3 pos, light myLight){\n\tvec3 lightDirection = normalize(myLight.pos - pos);\n\tvec3 surfaceNormal = guessNormal(pos);\n\t\n\tfloat diffLight = clamp(dot(lightDirection, surfaceNormal), 0.0, 1.0); //intensity\n    diffLight = pow(diffLight,3.)*1.5; //?fake shine\n\tif (rayMarch(pos + 2.0*MIN_DISTANCE*surfaceNormal, lightDirection) < length(myLight.pos-pos)) diffLight *= 0.2; //shadows at 20%\n\treturn myLight.col*vec3(diffLight); //color \n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Misc initialization\n    vec3 col = vec3(0); //fragColor\n\tvec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //normalized true-scaling pixel uv mapping, longer edge square -1..1\n    float myDist; // ray length\n\tanimTime = float[]( //time for object operations\n\t\tmod(2.133333*iTime, 6.283185), //std, mod 2pi because of ?overflow: bug at getDistance case 0 if not mod\n\t\tmod(0.2666666*iTime, 6.283185) //slow\n\t);\n    \n    // Camera initialization\n    vec3 camPos = vec3(0, 2.5, 0); //ray origin, static\n\t//vec3 camDir = normalize(vec3(uv.x, uv.y, 1)); //ray direction, static straight\n\tvec3 camDir = normalize(vec3(uv.x, uv.y*cos(.15)-sin(.1), uv.y*sin(.15)+cos(.1))); //ray direction, static, slightly downwards\n\tcamTime = 0.2*iTime; //time for cam operations\n\tcamPos += vec3(9.*sin(camTime), 0,-9.*cos(camTime)); //rotating on circle\n    camDir = vec3( //rotation on xz-plane about (0,0,0)\n\t\tcamDir.x*cos(camTime)-camDir.z*sin(camTime),\n\t\tcamDir.y,\n\t\tcamDir.x*sin(camTime)+camDir.z*cos(camTime)\n\t);\n\t\n\t// Object initializations\n\tobjects = object[](\n\t\tobject(0, vec4(0)), //hPlane\n\t\tobject(2, vec4(0,2.9,0,2.0+cos(animTime[1]))), //sphere 1, shrink & grow\n        object(1, vec4(-3,0.4+3.*abs(sin(animTime[0])),5,0.5)), //sphere 2, bounce up & down\n\t\tobject(1, vec4(3,0.4+3.*abs(cos(1.5*animTime[0])),-5,0.5)) //sphere 3, bounce up & down\n\t);\n\t\n\t// Spotlight initialization\n    lights = light[]( //light pos, light col\n\t\tlight(vec3(9.*cos(camTime+.1), 3.5, 9.*sin(camTime+.1)), //cam syncronized rotation\n\t\t\tnormalize(vec3(245.*(1.+0.7*cos(animTime[1])),10,193))*1.5), // synthwave pink, dynamic\n\t\tlight(vec3(8.*sin(camTime-0.4), 4.5, 8.*-cos(camTime-0.4)), //cam syncronized rotation\n\t\t\tnormalize(vec3(73,10,245))*0.1) //synthwave blue\n\t);\n\t\n\t// Calculate depth-map\n\tmyDist = rayMarch(camPos, camDir);\n\t\n\t// Calculate diffused spotlight & convert to color\n\tfor (int n=0; n<lights.length(); n++){\n\t\tcol += getSpotlight(camPos+myDist*camDir, lights[n]);\n\t}\n\tcol = pow(col, vec3(.4545)); //gamma correction\n\t\n\tfragColor = vec4(col, 1.0); //output\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[772, 838, 866, 866, 1702], [1704, 1745, 1795, 1795, 2085], [2087, 2132, 2159, 2159, 2373], [2375, 2404, 2447, 2447, 2857]], "test": "untested"}
{"id": "dtsXzr", "name": "Progress Bar Meme (189 chars)", "author": "MysteryPancake", "description": "My take on the Twitter progress bar meme, also made by mrange and totetmatt. Domain clamping avoids unneeded branching.", "tags": ["2d", "sdf", "domain", "silly", "circle", "progress", "progressbar", "twitter", "bar", "meme", "golf", "golfed"], "likes": 9, "viewed": 284, "published": 3, "date": "1674230780", "time_retrieved": "2024-07-30T18:14:30.848695", "image_code": "// With anti-aliasing, by fishy + iapafoto (215 chars)\n#define A(d) smoothstep(-y, y, d - length(fract(clamp(u, vec2(1, 3), vec2(11, 4))) - .5))\nvoid mainImage(out vec4 O, vec2 u) {\n    float y = 12. / iResolution.x; \n    u *= y;\n    O = 1. - A(.45) + A(.4) * (u.x > ceil(sin(iTime) * 6. + 6.) ? O - O + .9 : vec4(0, .5, .9, 1));\n}\n\n// Original, by me + iapafoto (189 chars)\n/* void mainImage(out vec4 O, vec2 u) {\n    u *= 12. / iResolution.x;\n    O.a = length(fract(clamp(u, vec2(1, 3), vec2(11, 4))) - .5);\n    O = step(.45, O.a) + step(O.a, .4) * (u.x > ceil(sin(iTime) * 6. + 6.) ? O - O + .9 : vec4(0, .5, .9, 1));\n} */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 181, 181, 331]], "test": "untested"}
{"id": "Dtj3DG", "name": "A very simple PBRT", "author": "shaofun", "description": "A very simple physics-based ray-tracing renderer.\nWASDQE to move, SHIFT to accelerate, SPACE to refresh.\n\nmore info: https://shao.fun/blog/w/taichi-ray-tracing.html\ngithub: https://github.com/HK-SHAO/RayTracingPBR", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr"], "likes": 10, "viewed": 904, "published": 3, "date": "1674230731", "time_retrieved": "2024-07-30T18:14:31.892903", "image_code": "// Fork of \"RayTracing PBR with Free Camera\" by shaofun. https://shadertoy.com/view/ddSSWy\n// 2023-01-16 08:11:26\n\n// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color  = a / b;\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    color.rgb = color.rgb / color.a;\n    \n    // 伽马矫正\n    color.rgb *= camera_exposure;\n    color.rgb  = pow(color.rgb, vec3(1.0 / gamma));\n    \n    // 色调映射\n    color.rgb = ACESFitted(color.rgb);\n    \n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(0.0, 0.2, 4.0, 0.0));\n        store(ROTATION, vec4(0.0));\n        \n        store(TARGET,   vec4(0.0, -0.2, 4.0, 0.0));\n        store(TMOUSE,   vec4(0.0));\n        store(PMOUSE,   vec4(0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\nconst mat3 MAT3_NULL = mat3(vec3(0),vec3(0),vec3(0));\n\n// 摄像机参数\nconst float camera_vfov       = 30.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 2.0;                  // 摄像机的对焦距离\nconst float camera_aperture   = 0.002;                // 摄像机的光圈大小\nconst float camera_exposure   = 0.8;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMAX         = 2000.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float VISIBILITY   = 0.0001;                    // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.03;\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// 2023.01.27\n// Fix the order of tone mapping.\n\n// 2023.01.26\n// Fixes placing objects inside the glass, but reduces a few frames.\n\n// 2023.01.25\n// Use enhanced sphere tracing to accelerate the intersection. About 10 fps improvement.\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n// https://www.shadertoy.com/view/ddSSWy before 2023.01.17", "buffer_b_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n    mat3 matrix;        // 旋转矩阵\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野角度\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// 全局变量\nfloat pixradius;\nfloat bias;\n\n// 地图列表\nobject[] map = object[] (\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, -100.501, 0),\n                    vec3(0, 0, 0),\n                    vec3(100, 100, 100), MAT3_NULL\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.6, // 基础色\n                    vec3(1), // 自发光\n                    0.9, // 粗糙度\n                    0.1, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, 1, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.5, 0.5, 0.5), MAT3_NULL\n        ),\n        material(   vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(1.0, 100.0, 1.0), // 自发光\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.000  // 折射率 （真空）\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(-1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3), MAT3_NULL\n        ),\n        material(   vec3(1.0, 0.2, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    0.1, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.460  // 折射率 （塑料）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3), MAT3_NULL\n        ),\n        material(   vec3(0.2, 0.2, 1.0), // 基础色\n                    vec3(1), // 自发光\n                    0.2, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.100  // 折射率 （铜）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0.0, -0.2, 2),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3), MAT3_NULL\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    0.0, // 粗糙度\n                    0.0, // 金属度\n                    1.0, // 透明度\n                    1.500  // 折射率 （玻璃）\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, 5),\n                    vec3(0, 0, 0),\n                    vec3(2, 1, 0.2), MAT3_NULL\n        ),\n        material(   vec3(1.0, 1.0, 0.2)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    0.470  // 折射率 （金）\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, -1),\n                    vec3(0, 0, 0),\n                    vec3(2, 1, 0.2), MAT3_NULL\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.5, // 基础色\n                    vec3(1), // 自发光\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    2.950  // 折射率 （铁）\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2  rud = lens_radius * random_in_unit_disk();\n    vec3  offset = x * rud.x + y * rud.y;\n    \n    // 计算半高、半宽、左下角位置等\n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    mat3 matrix   = obj.trs.matrix;\n    \n    vec3 p = pos - position;\n    p *= matrix;\n    \n    switch(obj.shape) {\n        case SHAPE_SPHERE:\n            return sd_sphere(p, scale.x);\n        case SHAPE_BOX:\n            return sd_box(p, scale);\n        case SHAPE_CYLINDER:\n            return sd_cylinder(p, scale.xy);\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o = map[0]; o.dis = signed_distance(o, p);\n    for (int i = 1; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = signed_distance(oi, p);\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 光线步进检测第一个交点 from http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nrecord raycast(ray r) {\n    record rec; float w = 1.6, t = bias, s = 0.0, d = 0.0;\n    \n    for (uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n\n        float ld = d; d = abs(rec.obj.dis);\n        \n        if (w > 1.0 && ld + d < s) {\n            s -= w * s; t += s; w = 1.0;\n            continue;\n        }\n        \n        rec.hit = d < pixradius * t;\n        \n        t += s = w * d;\n    }\n    return rec;\n}\n\n// 采样天空\nvec3 sky(ray r, float brightness, float lod) {\n    vec3 ibl = textureLod(iChannel2, r.direction, lod).rgb; // 天空盒 IBL 照明\n    return pow(ibl * brightness, vec3(gamma)); // gamma 矫正\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float NoI, float F0) {\n    return mix(pow(abs(1.0 + NoI), 5.0), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float NoI, float F0, float roughness) {\n    return mix(fresnel_schlick(NoI, F0), F0, roughness);\n}\n\n// 在切线空间半球采样\nvec3 hemispheric_sampling(vec3 nor) {\n    vec2  r = rand21() * vec2(2.0, TAU) - vec2(1, 0);\n    float z = r.x;\n    vec2 xy = sqrt(1.0 - z*z) * vec2(sin(r.y), cos(r.y));\n    \n    return normalize(nor + vec3(xy, z));\n}\n\n// 用粗糙度改变采样方向\nvec3 roughness_sampling(vec3 hemispheric_sample, vec3 nor, float roughness) {\n    float alpha = roughness * roughness;\n    return normalize(mix(nor, hemispheric_sample, alpha));\n}\n\n// 应用 PBR 材质\nray ray_surface_interaction(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    float ior          = rec.obj.mtl.ior;\n    \n    vec3 normal = rec.normal;\n    bool outer = dot(normal, r.direction) < 0.0; // 光正在从外面穿入物体表面\n    \n    vec3 I  =  r.direction; // 入射光方向\n    vec3 N  =  normal *= outer ? 1.0 : -1.0; // 如果处于 SDF 物体内部就反过来\n    vec3 C  =  r.color; // 光的颜色\n    vec3 L; // 出射光方向\n    \n    vec3 hemispheric_sample = hemispheric_sampling(normal); // 切线空间的半球采样方向\n    \n    N = roughness_sampling(hemispheric_sample, normal, roughness);\n    float NoI = dot(N, I);\n\n    float eta = outer ? ENV_IOR / ior : ior / ENV_IOR; // 计算折射率之比\n    float k   = 1.0 - eta * eta * (1.0 - NoI * NoI); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 2.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoI, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.x < F + metallic || k < 0.0) {\n        L = I - 2.0 * NoI * N; // 包含镜面反射、菲涅尔反射、全反射\n        // 下面可以提高帧数，但是会导致透明材质发黑，需要优化\n        C *= float(dot(L, normal) > 0.0); // 如果光穿入或穿出表面就直接吸收掉\n    } else if (rand2.y < transmission) {\n        L = eta * I - (sqrt(k) + eta * NoI) * N; // 斯涅尔折射\n    } else {\n        L = hemispheric_sample; // 漫反射\n    }\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.direction = L;\n    r.origin += normal * bias * sign(dot(L, normal)); // 偏移一点\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float roulette_prob = 1.0 - float(i / MAX_RAYTRACE);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() > roulette_prob) {\n            r.color *= 1.0 - roulette_prob;\n            break;\n        }\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r, 2.0, 1.0 - 1.0 / (1.0 + 0.1 * float(i)));\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 更新光子的位置\n        r.origin = rec.pos;\n        \n        // 应用 PBR 材质更新光线\n        r = ray_surface_interaction(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n        r.color *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        // 光太暗或者击中光源\n        if (intensity < visible || visible < VISIBILITY) break;\n    }\n\n    return r;\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, iTime*iTimeDelta));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    return vec4(color, 1.0);\n}\n\nvoid pre_calculate() {\n    pixradius = 0.5 / max(iResolution.x, iResolution.y);\n    bias = 2.5 * pixradius;\n    \n    for (int i = 0; i < map.length(); i++) {\n        vec3 rotation = map[i].trs.rotation;\n        map[i].trs.matrix = angle(radians(rotation));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    pre_calculate(); // 预计算某些参数\n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtj3DG.jpg", "access": "api", "license": "mit", "functions": [[215, 315, 344, 391, 925], [927, 927, 982, 982, 1327]], "test": "untested"}
{"id": "mlfSRr", "name": "Realistic Fractal", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it. 15 FPS on my multi-year-old Chromebook.", "tags": ["raymarching", "clouds", "pathtracer"], "likes": 2, "viewed": 193, "published": 3, "date": "1674223948", "time_retrieved": "2024-07-30T18:14:32.843362", "image_code": "void mainImage(out vec4 C, in vec2 P) {\n    vec4 c = texelFetch(iChannel0,ivec2(P),0);\n    C = vec4(pow(c.xyz/c.w,v(1./2.2)),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float str;\n    int type;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "buffer_a_code": "#define MAX_STEPS 500\n#define MAX_DIST 10.\n#define SURF_DIST .005\n#define OFFSET SURF_DIST*(SURF_DIST+1.)\n\n#define _rs vec4(1142.,858411.,3122.,814.)\n#define _fogB .05\n#define _fogA .01\n\n#define maxcomp(a) max(a.x,a.y)\n#define avrg(a) (a.x+a.y+a.z)/3.\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed = _rs.w*mod(_rs.y*seed+_rs.z,_rs.x)/_rs.z;\n    return seed/_rs.w;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time*4.+sin(time-c.x)*c.x-iResolution.y*(cos(time+c.y)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\nfloat angMod(float a) {\n    return a*2.*PI;\n}\n\nmat2 rot(float a) {\n    float s = sin(angMod(a));\n    float c = cos(angMod(a));\n    return mat2(vec2(c,s),vec2(-s,c));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time,vec3 sunDir) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(sunDir,rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),sat(sun));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n/*\nfloat sdCross( vec3 p ) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.;\n}\n\n*/\n\n/////World\nvec2 map(in vec3 p,float ctime,bool fornorm) {\n   float f = 3.;\n   vec3 q = (p-vec3(0.,0.,1.5))/f;\n   \n   float d0 = sdBox(q,v(0.),vec4(1.,1.,1.,0.));\n\n   float s = 1.;\n   for( float m=0.; m<5.; m++ ){\n      if(d0>=.01&&!fornorm) break;\n      q += v(.03)*s/f;\n      q -= v(.005)/f;\n      vec3 a = mod( q*s, 2. )-1.;\n      s *= 3.;\n      vec3 r = abs(1. - 3.*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.)/s;\n\n      d0 = max(d0,c);\n   }\n\n   \n   float d1 = sdSphere(p,vec4(0.,0.,6.,2.));\n   float d2 = sdSphere(p,vec4(-1.5,3.,6.,1.5));\n   float d3 = sdSphere(p,vec4(1.5,3.,6.,1.5));\n   \n   float d = min(d0,min(d1,min(d2,d3)));\n   d = d0*f;\n   //d = MAX_DIST;\n   \n   float mat;\n   mat = 0.;\n   if(d==d1) mat=1.;\n   if(d==d2||d==d3) mat=2.;\n   \n   return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float t) {\n    const vec2 e = vec2(.0001,0.);\n    return normalize(vec3(\n    map(p+e.xyy,t,true).x-map(p-e.xyy,t,true).x,\n    map(p+e.yxy,t,true).x-map(p-e.yxy,t,true).x,\n    map(p+e.yyx,t,true).x-map(p-e.yyx,t,true).x));\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime,false);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime,false).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime,int type,float i) {\n    vec3 l = normalize(lp0);\n    \n    float len = length(lp0);\n    if(type==1) len = 1000.;\n    float ss = shadow(p+n*OFFSET,l,len,ctime);\n    //ss = 1.;\n    \n    float it = (type==0)?pow(i/len,2.):1.;\n    \n    float dif = dot(l,n);\n    \n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.283185;\n    float x = rand1()*2.-1.;\n    float z = rand1();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid setMat(vec3 color, float fp, float  g, float drr, out vec3 scol, out vec3 sdat) {\n    scol = color;\n    sdat = vec3(fp,g,drr);\n}\n\nLight newLight(int type,vec3 col, vec3 p, float i) {\n    if(type==1) {\n        return Light(col,normalize(p),i,1);\n    } else {\n        return Light(col,p,i,0);\n    }\n}\n\nvoid worldGetMat(float id, vec3 n, out vec3 col, out vec3 dat) {\n    if(id==0.) setMat(v(.2),1.,1.,.0,col,dat);\n    //if(id==1.) setMat(vec3(.2,.15,.05),2.,.6,.8,col,dat);\n    //if(id==2.) setMat(v(.03),7.,1.,.9,col,dat);\n}\n\nvec3 applyFog(in vec3 col, float dist, vec3 rd, vec3 ro, vec3 ld) {\n    float fa = (_fogA/_fogB) * exp(-ro.y*_fogB) * (1.-exp(-dist*rd.y*_fogB))/rd.y;\n    float sa = max(dot(rd,ld),0.);\n    vec3 fc = mix(vec3(.5,.6,.7),vec3(1.,.9,.7),sat(pow(sa,8.)));\n    return mix(col,fc,sat(fa));\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, vec3 m) {\n    ro = p+n*OFFSET;\n    if(rand1() < m.z) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = m.y*sat(pow(1.-dot(-rd,n),m.x));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid rot3(inout vec3 v, vec3 a){\n    vec2 t = vec2(v.z,v.x);\n    t *= rot(a.y);\n    v.zx = t;\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww,bool rt) {\n    time += 1.;\n    if(rt) {ro = vec3(sin(time/3.)*.8,0.,cos(time/3.)*.8+1.5);\n    }else{\n        ro = vec3(0.,0.,-1.5);\n    }\n    uu = normalize(vec3(1.,0.,0.));\n    vv = normalize(vec3(0.,1.,0.));\n    ww = normalize(vec3(0.,0.,1.));\n    if(!rt) return;\n    vec3 a = vec3(0.,.0625*sin(time/2.75),0.);\n    a.y = time/9.;\n    rot3(uu,a);\n    rot3(vv,a);\n    rot3(ww,a);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    Light LIGHT = newLight(0,vec3(-10.*sin(ctime*2.*PI/10.),0.,1.5-10.*cos(ctime*2.*PI/10.)),vec3(1.,.98,.94),1.5)\n;\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    float td = 0.;\n    for(float i = 0.; i < 3.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        td += d;\n        if (hit == true) {\n            float tdReq = 5.;\n            tdReq += tdReq/(i+1.);\n            if(td > tdReq) break;\n            \n            vec3 n = getNormal(p,ctime);\n            vec3 ld;\n            if(LIGHT.type==0) ld = LIGHT.pos-p;\n            if(LIGHT.type==1) ld = LIGHT.pos;\n            \n            float dif = diffuse(p,ld,n,ctime,LIGHT.type,LIGHT.str);\n\n            vec3 sdat;\n            worldGetMat(mat,n,scol,sdat);\n            \n            vec3 diffuse = (dif*.5+.5)*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += applyFog(fcol * dcol,d,rd,ro,ld);\n            \n            \n            getBRDFRay(ro,rd,p,n,sdat);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime,normalize(LIGHT.pos));\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if(iTime<.035||true) {\n        \n    \n        bool rt = true;\n    \n        float frame = float(iFrame);\n        if(iFrame==0||rt) fragColor=vec4(0.);\n    \n        float dv = 1./tan(FOV*PI/360.);    \n    \n        float spp     = 2.;\n        float shutAp  = .6;\n        float blurAmt = .0015;\n        float fcsDist = 1.3;\n    \n        vec3 qcol = v(0.);\n        for(float i = 0.; i < spp; i++) {\n            initRand(frame,fragCoord);\n            \n            //float frameTime = frame*(1./30.);\n            float frameTime = iTime;\n        \n            vec2 of = -.5 + fract(rand2());\n            vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n            vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        \n            float ctime = (frameTime*1.)-3. + shutAp*(1./24.)*rand1();\n            getCam(ctime,ro,uu,vv,ww,rt); \n            vec3 er = normalize(vec3(p,dv));\n            vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n            vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n            vec3 gd = normalize(er*fcsDist-go);\n            ro += go.x*uu+go.y*vv;\n            rd += gd.x*uu+gd.y*vv;\n        \n            //vec3 rdOrig = rd;\n            vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n            qcol += col;\n            //qcol += ro;\n            //frame++;\n        }\n        qcol /= spp;\n        fragColor += vec4(qcol,1.);\n    }\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 131]], "test": "untested"}
{"id": "ctlSRr", "name": "Quantized rendering", "author": "NohatCoder", "description": "Simulating a fixed update rate with no rendering interpolation. Update rates are 50 Hz, 100 Hz, 200 Hz and no quantization.\n\nOpinion wanted: How smooth is each animation? And what is your screen update rate?", "tags": ["techtest"], "likes": 1, "viewed": 155, "published": 3, "date": "1674211379", "time_retrieved": "2024-07-30T18:14:33.737969", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float boxsize=min(iResolution.x*0.5,iResolution.y*0.5);\n    vec2 centre;\n    int quadrant=0;\n    if(fragCoord.x*2.0<iResolution.x){\n        centre.x=iResolution.x*0.25;\n    }\n    else{\n        centre.x=iResolution.x*0.75;\n        quadrant+=1;\n    }\n    if(fragCoord.y*2.0<iResolution.y){\n        centre.y=iResolution.y*0.25;\n    }\n    else{\n        centre.y=iResolution.y*0.75;\n        quadrant+=2;\n    }\n    float time=iTime;\n    vec3 c=vec3(1.0,0.8,0.8);\n    if(quadrant==1){\n        time=floor(time*200.0)/200.0;\n        c=vec3(1.0,1.0,1.0);\n    }\n    if(quadrant==2){\n        time=floor(time*100.0)/100.0;\n        c=vec3(0.8,1.0,0.8);\n    }\n    if(quadrant==3){\n        time=floor(time*50.0)/50.0;\n        c=vec3(0.8,0.8,1.0);\n    }\n    time*=1.0;\n    vec2 along=vec2(sin(time),cos(time));\n    vec2 normal=vec2(cos(time),-sin(time));\n    vec2 end1=centre+along*boxsize*0.4;\n    vec2 end2=centre-along*boxsize*0.4;\n    float radius=boxsize*0.05;\n    float radiuss=radius*radius;\n    float sumd=0.0;\n    float sumdp=0.0;\n    float a;\n    float b;\n    for(a=-0.5;a<1.0;a+=1.0){\n        for(b=-0.5;b<1.0;b+=1.0){\n            vec2 pixelcorner=fragCoord+vec2(a,b);\n            float d=distance(end1,pixelcorner)-radius;\n            d=min(d,distance(end2,pixelcorner)-radius);\n            float inlinesegment=dot(pixelcorner-centre,along);\n            if(abs(inlinesegment)<boxsize*0.4){\n                d=min(d,abs(dot(normal,pixelcorner-centre))-radius);\n            }\n            sumd+=d;\n            sumdp+=abs(d);\n        }\n    }\n    float fill=((-sumd/sumdp)+1.0)*0.5;\n    fragColor = vec4(c*fill,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1669]], "test": "untested"}
{"id": "DllSzr", "name": "大龙猫 - Progress bar meme", "author": "totetmatt", "description": "Following the meme / hype train started by mrange https://www.shadertoy.com/view/DlsXzn", "tags": ["progressbar"], "likes": 5, "viewed": 289, "published": 3, "date": "1674210305", "time_retrieved": "2024-07-30T18:14:34.607644", "image_code": "//Following the meme / hype train started by mrange https://www.shadertoy.com/view/DlsXzn\n//mercurysexy\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    \n    vec3 p,d=vec3(uv,1.);\n    vec3 col=vec3(0.);;\n    vec3 inactive = vec3(1.);\n    vec3 act = vec3(.45,.55,1.);\n    float t = floor(iTime)+pow(fract(iTime),2.5);; \n    float st = mod(iTime,15.);\n    for(float i=0.,e=0.,g=0.;i++<10.;){\n            p = d*g;\n            float idx  = pModInterval1(p.x,.7,-5.,4.);\n            p.z -= 5.;\n            float isAct = pow(smoothstep(idx+5.,idx+6.,st+.2*length(p)*dot(cos(p*70.+st),sin(p.yzx*20.-st))),2.5);\n            \n            float h=length(p)-.25-isAct*.01;\n            g+=e=max(.005,h);\n            vec3 c = mix(inactive, act, isAct-p.x);\n            col+=c*(.1+isAct)/exp(2.*i*i*e)/3.;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 104, 177, 177, 511], [513, 513, 568, 568, 1314]], "test": "untested"}
{"id": "DlsXRr", "name": "waffle sphere maze 2c", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "short"], "likes": 20, "viewed": 246, "published": 3, "date": "1674209254", "time_retrieved": "2024-07-30T18:14:35.385565", "image_code": "// variant of https://shadertoy.com/view/DllSRr\n// variant of https://shadertoy.com/view/DlsXRn\n// variant of https://shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                   // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h,h2,h3, r=8.; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),              // ray direction\n          p = vec3(0,0,20), q,a,b,                             // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    p.y += 7.; \n    for ( O=vec4(1); O.x > 0. && t > .001; O-=.003 )           // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                     // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q) - r,\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,               // cube-sphere mapping\n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,\n        U *= 2.*r/m, h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 2./r *.7,                   // distance to walls\n        a = 128.* vec3(q.x-sign(h-.5)*q.y, (t+.2)*.2, 0),      // wall parameterization\n        a = ( a + vec3(-a.y,a.x,0) ) * .7,\n        h2 = H(ceil(a.xy)+ceil(U)), a = ( fract(a) -.5 ) /128.,// for maze on walls\n        b = 128.*vec3(q.xy,0)/.7,                              // floor parameterization\n        h3 = H(ceil(b.xy)+ceil(U)), b = ( fract(b) -.5 ) /128.,// for maze on floor\n        t = min ( max(t+.4,.003 - abs(b.x+sign(h3-.5)*b.y)),   // floor\n                  max( t ,                                     // trimmed by out sphere\n                  min( max(abs(q.x+sign(h-.5)*q.y),            // wall = random tile diagonal\n                           .003-abs(a.x+sign(h2-.5)*a.y)       // wall decoration: maze holes\n                          ),\n                       length(abs(.5-abs(fract(U)-.5)))/2./r*.7) ) ), // columns at wall ends\n        p += .5*t*D;                                           // step forward = dist to obj    \n      \n\n// O *= O*O*1.5;                                               // color scheme\n// O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 306, 306, 2375]], "test": "untested"}
{"id": "DllSRr", "name": "waffle sphere maze 2b", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "maze", "short", "waffle"], "likes": 14, "viewed": 256, "published": 3, "date": "1674208538", "time_retrieved": "2024-07-30T18:14:36.214348", "image_code": "// variant of https://shadertoy.com/view/DlsXRn\n// variant of https://shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h, r=8.; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q,a,                            // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    p.y += 7.; \n    for ( O=vec4(1); O.x > 0. && t > .001; O-=.003 )          // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                  // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q) - r,\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n     // U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,           // cube-sphere mapping\n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,        \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,// kastorp's way : more regular\n        U *= 2.*r/m, h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 2./r *.7,                // distance to walls\n        t = min ( t+.4, max( t ,                            // trimmed by sphere\n                  min( max(abs(q.x+sign(h-.5)*q.y),         // wall = random tile diagonal\n                           .02-length(vec2(q.x-sign(h-.5)*q.y,(t+.2)*.2)) // hole in walls\n                        // .02-.05*sin(500.*length(vec2(q.x-sign(h-.5)*q.y,(t+.2)*.2))) // hole in walls\n                          ),\n                       length(abs(.5-abs(fract(U)-.5)))/2./r*.7) ) ), // columns at wall ends\n        p += .5*t*D;                                        // step forward = dist to obj    \n      \n\n// O *= O*O*1.5;                                            // color scheme\n// O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 255, 255, 2016]], "test": "untested"}
{"id": "DllXzn", "name": "Coaxal Circles", "author": "mla", "description": "Coaxal Circles, with an exact SDF and xoring a system with its complement. Mouse sets system parameters, keys a,b,c,d change displayed elements.\n\n[url]https://mathworld.wolfram.com/CoaxalCircles.html[/url]\n\n", "tags": ["circles", "sdf", "xor", "coaxal"], "likes": 20, "viewed": 245, "published": 3, "date": "1674206415", "time_retrieved": "2024-07-30T18:14:37.217666", "image_code": "// Coaxal Circles, mla, 2023\n// https://mathworld.wolfram.com/CoaxalCircles.html\n// an exact SDF and xoring a \n// system with its complement. Mouse sets system parameters,\n// keys a,b,c,d change displayed elements.\n// 'x' to just  see the basic system\n\n// Exact distance to circle lam in system c\nbool coaxal(out float d, vec2 p, float c, float lam) {\n  if (abs(lam) > 1e4) { // lam may be infinity\n    d = abs(p.x);\n  } else {\n    vec2 centre = vec2(-lam,0);\n    float radius = lam*lam-c;\n    if (radius < 0.0) return false; // No real circle.\n    radius = sqrt(radius);\n    d = length(p-centre) - radius;\n  }\n  return true;\n}\n\n// map parameter lam, -inf < lam < inf, to linear range \nfloat map(float lam, float t, float N) {\n  float x = atan(lam);\n  x /= 0.5*PI;\n  x += t;\n  x *= N;\n  return x;\n}\n\n// linear range back to parameter - inverse of map()\nfloat unmap(float x, float t, float N) {\n  x /= N;\n  x -= t;\n  x *= 0.5*PI;\n  x = tan(x);\n  return x;\n}\n\nfloat pencil(vec2 p, float c, float t, float N, out float ix) {\n  float d = 1e8, d1;\n  float lam = -(dot(p,p) + c)/(2.0*p.x);\n  lam = map(lam,t,N);\n  float lam0 = round(lam); // Nearest circle\n  if (coaxal(d1,p,c,unmap(lam0,t,N))) d = min(d,abs(d1));\n  float lam1 = lam0+sgn(lam-lam0); // Nearest on other side\n  if (coaxal(d1,p,c,unmap(lam1,t,N))) d = min(d,abs(d1));\n  ix = min(lam0,lam1); // Index of region we are in\n  if (mod(ix,2.0) == 0.0) d = -d; // Set interior/exterior\n  return d;\n}\n\nfloat xor(float d0, float d1) {\n  // Union minus the intersection\n  return max(min(d0,d1),-max(d0,d1));\n}\n\nfloat ssqr(float x) {\n return sign(x)*x*x; // signed square\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 fg = vec3(0.5);\n  float scale = 3.0;\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p *= scale;\n  float px = fwidth(p.x);\n  float c = 1.0, N = 10.0;\n  if (iMouse.x > 0.0) {\n    c = ssqr(8.0*(iMouse.x/iResolution.x-0.5));\n    N = 1.0+floor(20.0*iMouse.y/iResolution.y);\n  }\n  float t = mod(iTime/N,2.0);\n  float ix0, ix1;\n  float d = pencil(p.yx,c,t,N,ix0);\n  if (!key(CHAR_X)) d = xor(d,pencil(p.xy,-c,0.0,N,ix1));\n  vec3 col = vec3(1.0);\n  if (!key(CHAR_C)) fg = h2rgb(rand(mod(vec2(ix0,ix1),2.0*N)));\n  if (!key(CHAR_A)) col = mix(fg,col,smoothstep(-0.5*px,0.5*px,d));\n  float k = 0.5; // Pixel scaling factor for distance field\n  if (!key(CHAR_D)) col *= 0.75-0.25*cos(k*PI*d/px);\n  if (!key(CHAR_B)) col *= smoothstep(0.0,px,abs(d)-0.01); // Border\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define sgn(x) ((x) >= 0.0 ? 1.0 : -1.0)\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nfloat rand(vec2 p) {\n  return rand(ivec2(p));\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 297, 351, 351, 627], [629, 686, 726, 726, 798], [800, 853, 893, 893, 956], [958, 958, 1021, 1021, 1451], [1453, 1453, 1484, 1518, 1558], [1560, 1560, 1581, 1581, 1621], [1623, 1623, 1675, 1675, 2533]], "test": "untested"}
{"id": "DlsXzn", "name": "Progress bar meme", "author": "mrange", "description": "CC0: Progress bar meme\nThere's kind of a C# meme going on twitter about this tweet:\nhttps://twitter.com/mariusbancila/status/1615710620204077056?s=20&t=Miioq51z6b8eSJ_6Gu4ubg\nThe community is divided. Does the code suck or is it good?\n", "tags": ["silly", "twitter"], "likes": 14, "viewed": 357, "published": 3, "date": "1674206140", "time_retrieved": "2024-07-30T18:14:38.100306", "image_code": "// CC0: Progress bar meme\n//  There's kind of a C# meme going on twitter about this tweet:\n//  https://twitter.com/mariusbancila/status/1615710620204077056?s=20&t=Miioq51z6b8eSJ_6Gu4ubg\n//  The community is divided. Does the code suck or is it good?\n//  So I implemented the progress bar in GLSL for fun.\n//  I am kind of hoping Fabrice shows up and gives it a minification treatment so all\n//  readability disappears :)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  const float sz  = 0.25;\n  const float hsz = sz*0.5;\n\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float progress = smoothstep(-0.9, 0.9, sin(TIME));\n  \n  float aa = 2.0/RESOLUTION.y;\n   \n  vec2 p0 = p;\n  p0.x += sz*4.5;\n\n  float n0 = floor((p0.x + hsz)/sz);\n  p0.x = mod(p0.x + hsz, sz) - hsz;\n  \n  vec3 col = vec3(1.0);\n  if (n0 >= 0.0 && n0 < 10.0) {\n    float d0 = length(p0)-sz*0.4;\n    vec3 fcol = n0 >= 10.0*progress ? vec3(0.9) : vec3(0.125, 0.33, 0.9);\n    col = mix(col, vec3(0.0), smoothstep(aa, -aa, d0));\n    col = mix(col, fcol, smoothstep(aa, -aa, d0+0.02*sz));\n  }\n  col *= smoothstep(1.75, 0., length(pp));\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[481, 481, 538, 538, 1287]], "test": "untested"}
{"id": "cllSRn", "name": "2D Binary Search", "author": "MysteryPancake", "description": "2D version of my 1D binary search shader (shadertoy.com/view/cljGDt), probably equivalent to a quadtree.\nUse mouse to move target :)", "tags": ["2d", "binary", "animation", "1d", "sort", "quad", "quad", "squares", "quadtree", "search", "find"], "likes": 17, "viewed": 306, "published": 3, "date": "1674202982", "time_retrieved": "2024-07-30T18:14:38.926098", "image_code": "// UV distortion for fun\nvec2 distort(vec2 uv) {\n    return uv * (1.0 - length(uv * 0.1));\n}\n\n// Function to converge towards, use mouse to move target\nbvec2 check(vec2 guess) {\n    vec2 target = iMouse.z > 0.0 ?\n        distort((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y)\n        : vec2(sin(iTime * 2.0) * 0.5, cos(iTime * 2.0) * 0.5);\n    return greaterThan(guess, target);\n}\n\n// From https://iquilezles.org/articles/distfunctions2d\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Modified from https://www.shadertoy.com/view/lsS3Wc\nvec3 hue2rgb(float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = distort((fragCoord - 0.5 * iResolution.xy) / iResolution.y);\n    fragColor.rgb = vec3(0.0);\n    \n    // Draw grid\n    vec2 grid = fract(uv * 16.0);\n    fragColor.rgb += vec3(step(0.9, max(grid.x, grid.y))) * 0.05;\n    \n    // Binary search\n    int steps = 6;\n    vec2 current = vec2(0.0);\n\tvec2 move = vec2(0.25);\n    \n\tfor (int i = 0; i < steps; i++, move *= 0.5) {\n        // Store previous for line\n        vec2 last = current;\n        \n        // Move another half towards the target\n        bvec2 result = check(current);\n\t\tcurrent.x += result.x ? -move.x : move.x;\n        current.y += result.y ? -move.y : move.y;\n        \n        // Draw line\n        float dist = line(uv, last, current);\n        float percent = float(i) / float(steps);\n        vec3 hue = hue2rgb(percent);\n        fragColor.rgb += hue * (0.005 + percent * 0.005) / dist;\n\t}\n    \n    // Draw vignette\n    fragColor.rgb += smoothstep(0.5, 2.0, length(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 48, 48, 92], [94, 152, 177, 177, 385], [387, 443, 479, 479, 604], [606, 661, 686, 686, 776], [778, 778, 833, 833, 1782]], "test": "untested"}
{"id": "clsSzn", "name": "waffle torus maze", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "maze", "short", "waffle"], "likes": 24, "viewed": 281, "published": 3, "date": "1674201813", "time_retrieved": "2024-07-30T18:14:39.710002", "image_code": "// variant of https://shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q,a,                            // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )          // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                  // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q - vec3( q.xz/length(q.xz)*1.5,0).xzy ) - .5,\n        U.x = atan(q.x,q.z)*1.5/.5, U.y = atan(q.y,length(q.xz) - 1.5 ),\n        U *= 8., h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 8. *.7,                  // distance to walls\n     // t = ( max( abs(t),                                  // hollow torus\n        t = min ( t+.05, max( t ,                           // trimmed by torus\n                  min( abs(q.x+sign(h-.5)*q.y),                     // wall = random tile diagonal\n                       length(abs(.5-abs(fract(U)-.5)))/8.*.7) ) ), // columns at wall ends\n               // min(abs(q.x),abs(q.y)) )),                // wall = waffle\n        p += .5*t*D;                                        // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                            // color scheme\n// O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 207, 207, 1701]], "test": "untested"}
{"id": "DlsXRn", "name": "waffle sphere maze 2", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "maze", "short", "waffle"], "likes": 12, "viewed": 209, "published": 3, "date": "1674200660", "time_retrieved": "2024-07-30T18:14:40.479943", "image_code": "// variant of https://shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h, r=8.; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q,a,                            // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    p.y += 7.; \n    for ( O=vec4(1); O.x > 0. && t > .001; O-=.01 )          // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                  // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q) - r,\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n     // U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,           // cube-sphere mapping\n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,        \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,// kastorp's way : more regular\n        U *= 8.*r/m, h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 8./r *.7,                // distance to walls\n        t = min ( t+.03, max( t ,                           // trimmed by sphere\n                  min( abs(q.x+sign(h-.5)*q.y),                       // wall = random tile diagonal\n                       length(abs(.5-abs(fract(U)-.5)))/8./r*.7) ) ), // columns at wall ends\n        p += .5*t*D;                                        // step forward = dist to obj    \n      \n\n// O *= O*O*1.5;                                            // color scheme\n// O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 207, 207, 1752]], "test": "untested"}
{"id": "dlfXRn", "name": "CRT bend", "author": "KoharuXenon", "description": "Simulate the bend of a crt monitor, with a bit of chromattic abberation too", "tags": ["crt", "bend"], "likes": 1, "viewed": 264, "published": 3, "date": "1674170911", "time_retrieved": "2024-07-30T18:14:41.304738", "image_code": "float warp = 0.75; // simulate curvature of CRT monitor\nfloat zoom_factor;\nfloat abberationoffset = 0.1;\n\nvoid mainImage(out vec4 O, vec2 funni)\n{\n    warp = sin(iTime);\n    //comment out the line above if you dont want the screen to zoom in and out\n    zoom_factor =  1. + ((warp / 15.) * -1.);\n    vec2 p = funni.xy / iResolution.xy;\n    vec4 toUse = vec4(texture(iChannel0,p));\n    // squared distance from center\n    vec2 uv = p;\n    vec2 redoffsetfunniredamgus = uv;\n    vec2 blueoffsetlikedeeznuts = uv;\n    vec2 dc = abs(0.5-uv);\n    dc *= dc;\n    \n    // warp the fragment coordinates\n    uv.x -= 0.5; uv.x *= 1.0+(dc.y*(0.3*warp)); uv.x += 0.5;\n    uv.y -= 0.5; uv.y *= 1.0+(dc.x*(0.2*warp)); uv.y += 0.5;\n\n    // warp the red/blue offset coordinates\n    redoffsetfunniredamgus.x -= 0.5; redoffsetfunniredamgus.x *= 1.0+(dc.y*((0.3 + abberationoffset)*warp)); redoffsetfunniredamgus.x += 0.5;\n    redoffsetfunniredamgus.y -= 0.5; redoffsetfunniredamgus.y *= 1.0+(dc.x*((0.2 + abberationoffset)*warp)); redoffsetfunniredamgus.y += 0.5;\n    blueoffsetlikedeeznuts.x -= 0.5; blueoffsetlikedeeznuts.x *= 1.0+(dc.y*((0.3 - abberationoffset)*warp)); blueoffsetlikedeeznuts.x += 0.5;\n    blueoffsetlikedeeznuts.y -= 0.5; blueoffsetlikedeeznuts.y *= 1.0+(dc.x*((0.2 - abberationoffset)*warp)); blueoffsetlikedeeznuts.y += 0.5;\n\n    // zoom in the uv because uh yeah\n    uv = uv + (uv - vec2(0.5, 0.5)) * (zoom_factor - 1.0);\n    redoffsetfunniredamgus = redoffsetfunniredamgus + (redoffsetfunniredamgus - vec2(0.5, 0.5)) * (zoom_factor - 1.0);\n    blueoffsetlikedeeznuts = blueoffsetlikedeeznuts + (blueoffsetlikedeeznuts - vec2(0.5, 0.5)) * (zoom_factor - 1.0);\n\n    // sample inside boundaries, otherwise set to black\n    if (uv.y > 1.0 || uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0)\n        O = vec4(0.0,0.0,0.0,1.0);\n    else\n    {\n        // sample the texture\n        vec4 col1 = vec4(texture(iChannel0,uv));\n        vec4 col2 = vec4(texture(iChannel0,redoffsetfunniredamgus));\n\t\t//vec4 col2 = texture2D(bitmap, redoffsetfunniredamgus);\n        vec4 col3 = vec4(texture(iChannel0,blueoffsetlikedeeznuts));\n\t\t//vec4 col3 = texture2D(bitmap, blueoffsetlikedeeznuts);\n    \tO = vec4(col2.r, col1.g, col3.b, col1.a);\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 146, 146, 2222]], "test": "untested"}
{"id": "mtXXRn", "name": "Melting screen", "author": "KoharuXenon", "description": "Simple screen melt shader, with a few sin functions, feel free to change any values to your liking and make sure to credit me if used in any project", "tags": ["distort", "melt"], "likes": 2, "viewed": 285, "published": 3, "date": "1674169343", "time_retrieved": "2024-07-30T18:14:42.177405", "image_code": "uniform float u_time;\n\nvoid mainImage(out vec4 O, vec2 uv)\n{\n    float time = iTime;\n    time = mod(time, 3.5);//comment out this line if you dont want it to repeat\n    if (time > 3.5)\n        O = vec4(0.0,0.0,0.0,0.0);\n    else\n    {\n        vec2 p = uv.xy / iResolution.xy;\n        float melt = time * 0.2;\n        float stretch = sin(((p.x*0.5)) * 10.0) * time * 0.2;\n        stretch += sin(((p.x*1.3)) * 10.0) * time * 0.1;\n        stretch += sin(((p.x*2.4)) * 10.0) * time * 0.05;\n        vec2 offset = vec2(0., (stretch * stretch) + ((melt * melt * melt) * 3.));\n        p += offset;\n        vec4 video = vec4(texture(iChannel0,p));\n        if (p.y > 1.0 || p.x < 0.0 || p.x > 1.0 || p.y < 0.0)\n            O = vec4(0.0,0.0,0.0,1.0);\n        else\n            O = video;\n    }\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 60, 60, 783]], "test": "untested"}
{"id": "ct23Dd", "name": "Year of Truchets #002", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 14, "viewed": 238, "published": 3, "date": "1674163605", "time_retrieved": "2024-07-30T18:14:43.001202", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #002\n    01/18/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\nfloat hash21(vec2 p) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    t+=T*.06;\n    return .55+.75*cos(PI2*t*(vec3(1.,.99,.95)+vec3(.1,.34,.27))); \n}\n//@iq https://iquilezles.org/articles/distfunctions2d/\nfloat line( in vec2 p){\n    vec2 a = vec2(.2,.5),b = vec2(.8,.5);\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float d = length(pa-h*ba);\n    return d-.1;\n}\n\nconst float scale = 8.;\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // uv \n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv.x-=T*.05;\n    \n    // colors \n    vec3 h1 = hue(uv.y*.04+T*.01);\n    vec3 h2 = hue((15.+uv.y)*.04+T*.05);\n    vec3 h3 = hue(uv.x*.04+T*.01);\n    \n    vec3 C = hue((10.-uv.x)*.04+T*.1);\n    \n    // base grid and ids\n    vec2 id = floor(uv*scale);\n    vec2 gv = fract(uv*scale)-.5;\n    float px = scale/R.x;\n\n    float check = mod(id.y+id.x,2.)*2.-1.;\n    float rnd = hash21(id);\n    if(rnd>.5) gv.x *= -1.;\n    \n    // setup for truchet path\n    vec2 d2 = vec2(length(gv-.5),length(gv+.5));\n    vec2 g2 = d2.x<d2.y? gv-.5 : gv+.5;\n\n    float ft = .2+.1*sin(uv.y*5.2+T);\n    float d = length(g2)-.5;\n    float dl= smoothstep(px,-px,abs(abs(d)-ft)-.02);\n    d = smoothstep(-px,px,abs(d)-ft);\n\n    C = mix(C,h3,d);\n    C = mix(C,vec3(.8),dl);\n    \n    \n    // moving truchet parts\n    vec2 arc = gv-sign(gv.x+gv.y+.001)*.5;\n    float angle = atan(arc.x, arc.y);\n    d = length(arc);\n\n    float x = fract(3.*check*angle/PI+T*1.15);\n    float y = (d/.5)-.5;\n    \n    if(rnd<.5 ^^ check>0.) y=1.-y;\n    vec2 tuv = vec2(x,y);\n    \n    float ts = length(tuv-vec2(.5))-.25;\n    ts = smoothstep(.05+px,-px,abs(ts)-.125);\n    C = mix(C,vec3(.01),ts);\n    \n    float t = length(tuv-vec2(.5))-.25;\n    t = smoothstep(px,-px,abs(t)-.075);\n    C = mix(C,h2,t);\n    \n    ts = min(line(tuv-vec2(.5,0)),line(tuv+vec2(.5,0)));\n    ts = smoothstep(.05+px,-px,abs(ts)-.05);\n    C = mix(C,vec3(.01),ts);\n    \n    t = min(line(tuv-vec2(.5,0)),line(tuv+vec2(.5,0))); \n    t = smoothstep(px,-px,t);\n    C = mix(C,h1,t);\n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct23Dd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[455, 455, 477, 477, 532], [533, 533, 551, 551, 596], [598, 646, 664, 664, 749], [750, 805, 828, 828, 1003]], "test": "untested"}
{"id": "DtfSzn", "name": "Fractal - Besides This Nothing", "author": "Meleshin", "description": "I created this code to animate my music track: https://www.youtube.com/watch?v=DZeU3AhKqRo", "tags": ["raymarching", "fractal", "menger", "sequence"], "likes": 4, "viewed": 232, "published": 3, "date": "1674160081", "time_retrieved": "2024-07-30T18:14:44.038429", "image_code": "// Code of animation for my music track:\n// https://www.youtube.com/watch?v=DZeU3AhKqRo\n//\n// Roman Meleshin - Besides This Nothing\n//---------------------------------------------\n// http://romanmeleshin.art/\n// \n// The code is distributed under the MIT license.\n\n#define AA 1 // Antialias. 1 or more, 1 for fast.\n#define MARCH_MAX_STEPS 100\n#define MARCH_MAX_DIST 100.\n#define MARCH_END_DIST .001\n#define BAR 4. // Beats per bar.\n\n#define SEQ_BPM 130. // Beats per minute.\nstruct varsStruct{\n\tfloat fadeIn;\n\tfloat fadeOut;\n\tvec3 colorA;\n\tvec3 colorB;\n\tvec3 rotVector;\n\tfloat rotAngle;\n\tfloat scale;\n\tvec3 offset;\n\tfloat time;\n\tfloat fade;\n\tfloat clipTime;\n};\nvarsStruct varsSeq[] = varsStruct[](\n\tvarsStruct(\n\t\t/*fadeIn*/ 4., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 0., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 0., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 0., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 4., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 40., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 8., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 40., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 20., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 80., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 24., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 80., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 32., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 80., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 36., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 120., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 40., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 120., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 44., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 160., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 48., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 160., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 52., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 200., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 56., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 200., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 68., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 240., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 72., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 240., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 80., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 240., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 84., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 280., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 88., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 280., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 92., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 320., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 96., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 320., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 100., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 360., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 104., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 360., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 108., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 400., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 112., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0.5,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 440., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1.2,1,1), \n\t\t/*time*/ 116., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 440., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 120., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 480., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 124., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 520., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 128., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 560., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 132., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 600., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 136., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.9,0.1,0.8), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 640., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 140., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 680., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 144., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 680., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 148., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 680., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 152., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 720., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 156., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 720., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 164., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 760., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 168., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 760., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 176., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(7,0.7,0.1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 800., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,0.5), \n\t\t/*time*/ 180., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0.7,0.2), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 800., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 184., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0.7,0.2), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 840., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 188., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0.7,0.2), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 840., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 200., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0.7,0.2), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 880., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 204., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0,0.7,0.2), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 880., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 212., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.5,0.1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 880., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 216., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.5,0.1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 920., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 220., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.5,0.1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 920., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 232., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.5,0.1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 960., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 236., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.5,0.1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 960., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 240., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 960., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 244., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1000., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 248., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1000., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 260., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1040., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 264., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1040., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 276., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(3,3,0), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1080., \n\t\t/*scale*/ 3.7, \n\t\t/*offset*/ vec3(1,0.8,1.9), \n\t\t/*time*/ 280., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,7,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1080., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 284., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,7,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1120., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 288., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,7,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1120., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 292., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,7,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1160., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 296., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,7,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1160., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 300., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1160., \n\t\t/*scale*/ 5., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 304., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1200., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 308., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(1,0,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1200., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 320., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1240., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 324., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1240., \n\t\t/*scale*/ 3., \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 336., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 0., \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1280., \n\t\t/*scale*/ 3.5, \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 340., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 35.75, \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1280., \n\t\t/*scale*/ 3.5, \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 340., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsStruct(\n\t\t/*fadeIn*/ 0., \n\t\t/*fadeOut*/ 35.75, \n\t\t/*colorA*/ vec3(1,1,1), \n\t\t/*colorB*/ vec3(0.7,1,1), \n\t\t/*rotVector*/ vec3(0,1,1), \n\t\t/*rotAngle*/ 1280., \n\t\t/*scale*/ 3.5, \n\t\t/*offset*/ vec3(1,1,1), \n\t\t/*time*/ 372., \n\t\t/*fade*/ 1., \n\t\t/*clipTime*/ 0.\n\t)\n);\nvarsStruct vars;\nvoid varsInit(){\n\tconst float beatTime = 60. / SEQ_BPM;\n\tfloat loopLength = varsSeq[varsSeq.length()-1].time * beatTime;\n\tfloat loopT = mod(iTime, loopLength);\n\tfloat clipT;\n\tfloat clipL;\n\tvarsStruct a;\n\tvarsStruct b;\n\tfloat t;\n\tfor(int i = 0; i < varsSeq.length()-1; i++){\n\t\tfloat sTimeNext = varsSeq[i+1].time * beatTime;\n\t\tif(sTimeNext > loopT){\n\t\t\tfloat sTime = varsSeq[i].time * beatTime;\n\t\t\ta = varsSeq[i];\n\t\t\tb = varsSeq[i+1];\n\t\t\tclipT = loopT - sTime;\n\t\t\tclipL = sTimeNext - sTime;\n\t\t\tt = clipT/clipL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvars.colorA = mix(a.colorA, b.colorA, t);\n\tvars.colorB = mix(a.colorB, b.colorB, t);\n\tvars.rotVector = mix(a.rotVector, b.rotVector, t);\n\tvars.rotAngle = mix(a.rotAngle, b.rotAngle, t);\n\tvars.scale = mix(a.scale, b.scale, t);\n\tvars.offset = mix(a.offset, b.offset, t);\n\tvars.time = loopT;\n\tvars.clipTime = t;\n\tvars.fade = 1.;\n\tif(a.fadeIn != 0.){\n\t\tvars.fade *= clamp(clipT / (a.fadeIn * beatTime), 0., 1.);\n\t}\n\tif(a.fadeOut != 0.){\n\t\tvars.fade *= clamp((clipL - clipT) / (a.fadeOut * beatTime), 0., 1.);\n\t}\n\tvars.clipTime = mix(a.clipTime, b.clipTime, t);\n}\nstruct varsPStruct{\n\tvec3 pathStopDir;\n\tvec3 path;\n\tfloat time;\n\tvec3 pathDir;\n\tfloat pathMinDir;\n\tfloat clipTime;\n};\nvarsPStruct varsPSeq[] = varsPStruct[](\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(0,0,0), \n\t\t/*time*/ 0., \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(0,0,10), \n\t\t/*time*/ 39.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(0,12,10), \n\t\t/*time*/ 87.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(10,12,10), \n\t\t/*time*/ 123.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(10,18,10), \n\t\t/*time*/ 147.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(10,18,20), \n\t\t/*time*/ 187.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(10,26,20), \n\t\t/*time*/ 219.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,26,20), \n\t\t/*time*/ 247.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,36,20), \n\t\t/*time*/ 287.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,36,26), \n\t\t/*time*/ 307.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,36,32), \n\t\t/*time*/ 331.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,34,32), \n\t\t/*time*/ 339.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,34,40), \n\t\t/*time*/ 367.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,36,40), \n\t\t/*time*/ 375.75, \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t),\n\tvarsPStruct(\n\t\t/*pathStopDir*/ vec3(0,0,1), \n\t\t/*path*/ vec3(18,36,46), \n\t\t/*time*/ 396., \n\t\t/*pathDir*/ vec3(0,0,1), \n\t\t/*pathMinDir*/ 0.01, \n\t\t/*clipTime*/ 0.\n\t)\n);\nvarsPStruct varsP;\nvoid varsPInit(){\n\tconst float beatTime = 60. / SEQ_BPM;\n\tfloat loopLength = varsPSeq[varsPSeq.length()-1].time * beatTime;\n\tfloat loopT = mod(iTime, loopLength);\n\tfloat clipT;\n\tfloat clipL;\n\tvarsPStruct a;\n\tvarsPStruct b;\n\tfloat t;\n\tfor(int i = 0; i < varsPSeq.length()-1; i++){\n\t\tfloat sTimeNext = varsPSeq[i+1].time * beatTime;\n\t\tif(sTimeNext > loopT){\n\t\t\tfloat sTime = varsPSeq[i].time * beatTime;\n\t\t\ta = varsPSeq[i];\n\t\t\tb = varsPSeq[i+1];\n\t\t\tclipT = loopT - sTime;\n\t\t\tclipL = sTimeNext - sTime;\n\t\t\tt = clipT/clipL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfloat loopTLA = mod(iTime + 3., loopLength);\n\tvarsPStruct aLA;\n\tvarsPStruct bLA;\n\tfloat tLA;\n\tfor(int i = 0; i < varsPSeq.length()-1; i++){\n\t\tfloat sTimeNext = varsPSeq[i+1].time * beatTime;\n\t\tif(sTimeNext > loopTLA){\n\t\t\tfloat sTime = varsPSeq[i].time * beatTime;\n\t\t\taLA = varsPSeq[i];\n\t\t\tbLA = varsPSeq[i+1];\n\t\t\tfloat clipT = loopTLA - sTime;\n\t\t\tfloat clipL = sTimeNext - sTime;\n\t\t\ttLA = clipT/clipL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvarsP.path = mix(a.path, b.path, t);\n\tvec3 pLA = mix(aLA.path, bLA.path, tLA);\n\tvarsP.pathStopDir = mix(aLA.pathStopDir, bLA.pathStopDir, tLA);\n\tvarsP.pathMinDir = mix(aLA.pathMinDir, bLA.pathMinDir, tLA);\n\tvec3 pDir = pLA - varsP.path;\n\tfloat pStop = 1. - clamp(length(pDir) / varsP.pathMinDir, 0., 1.);\n\tpDir += varsP.pathStopDir * pStop;\n\tvarsP.pathDir = normalize(pDir);\n\tvarsP.time = loopT;\n\tvarsP.clipTime = t;\n\tvarsP.pathMinDir = mix(a.pathMinDir, b.pathMinDir, t);\n\tvarsP.clipTime = mix(a.clipTime, b.clipTime, t);\n}\n\nmat3 rot;\nconst float inf = 1e10;\nvec3 ro0;\nvec3 ro;\nfloat barPulse;\n\nmat3 rotMat(vec3 v, float c, float s){\n\tfloat k = (1. - c);\n\treturn mat3(\n\t\tk * v.x * v.x + c,\t\t\tk * v.x * v.y - s * v.z,\tk * v.x * v.z + s * v.y,\n\t\tk * v.x * v.y + s * v.z,\tk * v.y * v.y +c,\t\t\tk * v.y * v.z - s * v.x,\n\t\tk * v.x * v.z - s * v.y,\tk * v.y * v.z + s * v.x,\tk * v.z * v.z + c\n\t);\n}\nmat3 rotMat(vec3 v, float angle){\n\treturn rotMat(v, cos(angle), sin(angle));\n}\nmat3 rotMat(vec3 z, vec3 d){\n\tvec3 cr = cross(z, d);\n\treturn rotMat(cr, dot(z, d), length(cr));\n}\nvec3 opRepeat(vec3 p, float repW){\n\tfloat repWD = repW / 2.;\n\treturn mod(p + repWD, repW) - repWD;\n}\nfloat deMengerBased(vec3 p, int iter, float scale, vec3 offset){\n\tint n = 0;\n\t//offset.z += barPulse*.3;\n\t//scale += barPulse*.03;\n\twhile (n < iter) {\n\t\tp = abs(p);\n\t\tif (p.x<p.y){ p.xy = p.yx;}\n\t\tp.x += .24;\n\t\tif (p.x<p.z){ p.xz = p.zx;}\n\t\tp.y += .05;\n\t\tif (p.y<p.z){ p.yz = p.zy;}\n\t\tp.z -= .07;\n\t\tp = scale*p-offset*(scale-1.0);\n\t\tif( p.z<-0.5*offset.z*(scale-1.0)) p.z+=offset.z*(scale-1.0);\n\t\tp = rot * p;\n\t\tn++;\n\t}\n\treturn length(p) * pow(scale, float(-n));\n}\nfloat map(vec3 p){\n\tfloat res = inf;\n\tp -= ro0;\n\tp = opRepeat(p, 2.);\n\tres = min(res, deMengerBased(p, 8, vars.scale, vars.offset));\n\treturn res;\n}\nvec2 march(vec3 ro, vec3 rd, int maxSteps, float endDist, float maxDist){\n\tfloat res = 0.;\n\tint i=0;\n\tfor(; i < maxSteps; i++){\n\t\t vec3 p = ro + rd * res;\n\t\t float dist = map(p);\n\t\t res += dist;\n\t\t if(res > maxDist || dist < endDist){\n\t\t\treturn vec2(res, i);\n\t\t }\n\t}\n\treturn vec2(res, i);\n}\n\nvec3 colorFast(float dist, float it){\n\tvec3 itL = clamp(1. - it/40., 0., 1.) * vars.colorA;\n\tvec3 distL = clamp((1. + barPulse*2.3)*dist*dist/400., 0., 1.) * vars.colorB;\n\tfloat m = clamp(dist/2., 0., 1.);\n\treturn mix(itL, distL, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvarsInit();\n\tvarsPInit();\n\n\tconst float beatTime = 60./SEQ_BPM;\n\n\tconst float barTime = BAR*beatTime;\n\tfloat timeInBars = vars.time / barTime;\n\tbarPulse = pow(1. - abs(timeInBars - round(timeInBars))*2., 3.);\n\n\tconst float foc = 1.;\n\tro0 = vec3(0, 1, 0);\n\tro = ro0 + varsP.path;\n\tvec3 col =vec3(0.);\n\tvec3 lightPos = ro;\n\trot = rotMat(normalize(vars.rotVector), radians(vars.rotAngle));\n#if AA>1\n\tfor(int i = 0; i < AA; ++i){\n\t\tfor(int j = 0; j < AA; ++j){\n\t\t\tvec2 ao = vec2(float(i),float(j))/float(AA) - .5;\n\t\t\tvec2 uv = (fragCoord.xy + ao - .5*iResolution.xy)/iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n#endif\n\t\t\tvec3 rd = normalize(vec3(uv.x, uv.y, foc)) * rotMat(vec3(0, 0, 1), varsP.pathDir);\n\t\t\t\n\t\t\tvec2 dist = march(ro, rd, MARCH_MAX_STEPS, MARCH_END_DIST, MARCH_MAX_DIST);\n\t\t\tcol += colorFast(dist.x, dist.y);\n#if AA>1\n\t\t}\n\t}\n\tcol /= float(AA*AA);\n#endif\n\tfragColor = vec4(col * vars.fade, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfSzn.jpg", "access": "api", "license": "mit", "functions": [[18045, 18045, 18061, 18061, 19131], [21817, 21817, 21834, 21834, 23300], [23372, 23372, 23410, 23410, 23666], [23667, 23667, 23700, 23700, 23745], [23746, 23746, 23774, 23774, 23843], [23844, 23844, 23878, 23878, 23944], [23945, 23945, 24009, 24009, 24409], [24410, 24410, 24428, 24428, 24557], [24558, 24558, 24631, 24631, 24848], [24850, 24850, 24887, 24887, 25085]], "test": "untested"}
{"id": "dlj3Dd", "name": "waffle sphere maze 1b", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "maze", "short", "waffle"], "likes": 17, "viewed": 266, "published": 3, "date": "1674151195", "time_retrieved": "2024-07-30T18:14:44.872200", "image_code": "// variant of https://shadertoy.com/view/mtS3Wd\n// variant of https://shadertoy.com/view/mlBGWd\n// variant of https://shadertoy.com/view/dlBGWd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q,a,                            // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )          // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                  // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q),\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n     // U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,           // cube-sphere mapping\n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,        \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,// kastorp's way : more regular\n        U *= 8./m, h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 8. *.7,                  // distance to walls\n        t = min ( t-1.35, max( t-1.5 ,                      // trimmed by sphere\n                  min( abs(q.x+sign(h-.5)*q.y),                     // wall = random tile diagonal\n                       length(abs(.5-abs(fract(U)-.5)))/8.*.7) ) ), // columns at wall ends\n               // min(abs(q.x),abs(q.y)) )),                // wall = waffle\n        p += .5*t*D;                                        // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                            // color scheme\n// O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 303, 303, 1898]], "test": "untested"}
{"id": "mtj3Dd", "name": "waffle sphere 1b", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "short", "waffle"], "likes": 8, "viewed": 199, "published": 3, "date": "1674150904", "time_retrieved": "2024-07-30T18:14:45.787752", "image_code": "// variant of https://shadertoy.com/view/dlBGWd\n\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    //p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        a = abs(q),\n        m = max(a.x, max(a.y,a.z)),\n     // U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,          // cube-sphere mapping\n        q = m==a.x ? q.yzx : m==a.y ? q.xzy : q,        \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,// kastorp's way : more regular\n        U = abs( fract(4.5*U/m) - .5 ) *m / 4.5,           // distance to walls\n        t = max( length(q)-1.5 , min(U.x,U.y) ),           // distance trimmed by sphere\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 159, 159, 1451]], "test": "untested"}
{"id": "mlj3Wd", "name": "Distance and direction from edge", "author": "MysteryPancake", "description": "Very useful edge properties for different applications. Mouse controls radius :)\nFrom top to bottom: direction relative to interior, direction relative to edge, distance from edge, distance from interior", "tags": ["2d", "chroma", "sdf", "distort", "greenscreen", "distance", "edge", "normal", "chromakey", "matte", "compositing", "direction"], "likes": 17, "viewed": 406, "published": 3, "date": "1674148387", "time_retrieved": "2024-07-30T18:14:46.558691", "image_code": "const float TAU = 6.28318530;\n\nfloat getAlpha(vec3 col) {\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    return step(0.7, distance(col, green));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 64.0;\n    \n    // Control radius with mouse\n    float radius = iMouse.z > 0.0 ? iMouse.x / iResolution.x * 64.0 : sin(iTime * 4.0) * 8.0 + 16.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    float alpha = getAlpha(fragColor.rgb);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    // STEP 1: Find average direction away from edge\n    \n    vec2 dirAvg = vec2(0.0);\n    bool interior = false;\n    \n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n        // Move in a circle to find edges within radius\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        \n        // Edge was found, accumulate for average\n        float neighbor = getAlpha(col.rgb);\n        if (alpha != neighbor) {\n            dirAvg += dir;\n            interior = alpha > neighbor;\n        }\n    }\n    \n    // No edges within radius\n    if (length(dirAvg) <= 0.0) {\n        vec3 bg = uv.y < 0.5 ? vec3(0.5) : vec3(0.5, 0.5, 1.0);\n        fragColor.rgb = mix(bg, fragColor.rgb, alpha);\n        return;\n    }\n    \n    // Calculate average direction\n    dirAvg = normalize(dirAvg);\n\n    // STEP 2: Raycast in average direction until an edge is hit\n    \n    float dist = radius * 0.5;\n    float move = dist * 0.5;\n    // Binary search works better than linear search\n    for (int i = 0; i < 8; i++, move *= 0.5) {\n        vec4 col = texture(iChannel0, uv + dirAvg * aspect * dist);\n        dist += alpha != getAlpha(col.rgb) ? -move : move;\n    }\n    \n    // STEP 3: Calculate distance and direction from interior\n    \n    vec2 interiorDir = interior ? dirAvg : -dirAvg;\n    float interiorDist = interior ? radius - dist : dist + radius;\n\n    if (uv.y > 0.75) {\n        // Direction relative to interior (range -1 to 1)\n        fragColor.rgb = vec3(interiorDir * 0.5 + 0.5, 1.0);\n    } else if (uv.y > 0.5) {\n        // Direction relative to edge (range -1 to 1)\n        fragColor.rgb = vec3(dirAvg * 0.5 + 0.5, 1.0);\n    } else if (uv.y > 0.25) {\n        // Distance from edge\n        fragColor.rgb = vec3(dist / radius);\n    } else {\n        // Distance from interior\n        fragColor.rgb = vec3(interiorDist / radius * 0.5);\n    }\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlj3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 147], [149, 149, 204, 204, 2496]], "test": "untested"}
{"id": "dl23Wt", "name": "Refine Edges (Approximation)", "author": "MysteryPancake", "description": "An idea I had to roughly recreate Photoshop's \"Refine Edges\" effect. Mouse controls the radius :)\nFirst you find the edge and its direction, then sample colors inside and outside of it. Finally you lerp between a property of those colors.", "tags": ["2d", "chroma", "color", "greenscreen", "chromakey", "matte", "compositing", "photoshop", "despill", "decontaminate"], "likes": 2, "viewed": 258, "published": 3, "date": "1674145989", "time_retrieved": "2024-07-30T18:14:47.400441", "image_code": "const float TAU = 6.28318530;\n\nfloat getAlpha(vec3 col) {\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    return step(0.65, distance(col, green));\n}\n\nfloat inverseLerp(float x, float xMin, float xMax) {\n\treturn (x - xMin) / (xMax - xMin);\n}\n\n// From https://www.shadertoy.com/view/lsdGzN\nfloat xyzF(float t) {\n    return mix(pow(t, 1.0 / 3.0), 7.787037 * t + 0.139731, step(t, 0.00885645));\n}\n\nvec3 rgb2lch(vec3 c) {\n\tc *= mat3(0.4124, 0.3576, 0.1805, 0.2126, 0.7152, 0.0722, 0.0193, 0.1192, 0.9505);\n    c.x = xyzF(c.x);\n\tc.y = xyzF(c.y);\n\tc.z = xyzF(c.z);\n\tvec3 lab = vec3(max(0.0, 116.0 * c.y - 16.0), 500.0 * (c.x - c.y), 200.0 * (c.y - c.z)); \n    return vec3(lab.x, length(vec2(lab.y, lab.z)), atan(lab.z, lab.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 64.0;\n    \n    // Radius\n    float radius = iMouse.z > 0.0 ? iMouse.x / iResolution.x * 128.0 : sin(iTime * 6.0) * 8.0 + 16.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    float alpha = getAlpha(fragColor.rgb);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    // STEP 1: Find average direction away from edge\n    \n    vec2 dirAvg = vec2(0.0);\n    bool interior = false;\n    \n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n        // Move in a circle to find edges within radius\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        \n        // Edge was found, accumulate for average\n        float neighbor = getAlpha(col.rgb);\n        if (alpha != neighbor) {\n            dirAvg += dir;\n            interior = alpha > neighbor;\n        }\n    }\n    \n    // No edges within radius\n    if (length(dirAvg) <= 0.0) return;\n    \n    // Calculate average direction\n    dirAvg = normalize(dirAvg);\n\n    // STEP 2: Raycast in average direction until an edge is hit\n    \n    float d = radius * 0.5;\n    float move = d * 0.5;\n    // Binary search works better than linear search\n    for (int i = 0; i < 8; i++, move *= 0.5) {\n        vec4 col = texture(iChannel0, uv + dirAvg * aspect * d);\n        d += alpha != getAlpha(col.rgb) ? -move : move;\n    }\n    \n    // STEP 3: Fix interior direction and distance\n    \n    dirAvg = interior ? dirAvg : -dirAvg;\n    d = interior ? radius - d : d + radius;\n    \n    // STEP 4: Sample colors inside and outside edge\n    \n    vec3 insideColor = texture(iChannel0, uv - dirAvg * aspect * d).rgb;\n    vec3 outsideColor = texture(iChannel0, uv + dirAvg * aspect * (radius * 2.0 - d)).rgb;\n    \n    // STEP 5: Lerp between a property, I used the chrominance but Photoshop likely doesn't\n    \n    float chroma = inverseLerp(rgb2lch(fragColor.rgb).y, rgb2lch(outsideColor).y, rgb2lch(insideColor).y);\n    \n    // Display matte\n    fragColor.rgb = vec3(chroma);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl23Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 148], [150, 150, 202, 202, 240], [242, 288, 309, 309, 392], [394, 394, 416, 416, 722], [724, 724, 779, 779, 2861]], "test": "untested"}
{"id": "dtj3Wt", "name": "vonoroi minimal", "author": "jonasfrey", "description": "miniaml", "tags": ["minimal"], "likes": 6, "viewed": 169, "published": 3, "date": "1674143203", "time_retrieved": "2024-07-30T18:14:48.191325", "image_code": "#define j(n,m) ((floor(n*m)+.5)/m)\nvoid mainImage( out vec4 c, vec2 f )\n{\n    vec2 e = iResolution.xy,\n         n = (f-e*.5)/e.y*3.3,\n         x = n*20., \n         o = vec2(3.,18.),\n         p;\n    float m = 1.,\n          t = iTime,\n          a = o.x*o.y,\n          i;\n    for(i = 0.; i<a;i+=1.){\n        p = vec2(mod(i,o.x),floor(i/o.x));\n        p+=sin(t+i);\n        m = min(m,length(abs(n)-(p/o)));\n    }\n    c = vec4(1.-pow(m,1./3.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtj3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 440]], "test": "untested"}
{"id": "clj3Wd", "name": "something [333 chars]", "author": "jonasfrey", "description": "something", "tags": ["something"], "likes": 3, "viewed": 206, "published": 3, "date": "1674142118", "time_retrieved": "2024-07-30T18:14:48.973738", "image_code": "#define s(n) sin(n)\n#define j(n,m) ((floor(n*m)+.5)/m)\nvoid mainImage(out vec4 c, vec2 f )\n{\n    vec2 e = iResolution.xy,\n         n = (f-e*.5)/e.y;\n    float u = 6.28,\n          g = u/4.,\n          t = iTime,\n          a = atan(n.y,n.x)/u,\n          d = length(n), \n          b = j(a,33.),\n          r = j(d,66.),\n          x = t+r*99.,\n          h = s(t+d),\n          i = s((abs(b)+r)*22.+t)*.5+.5;\n    vec2 q = vec2(s(b*u+g+s(x)*h)*r, s(b*u+s(2.*x)*h)*r);\n    c = vec4(1.-pow(length(n-q),.3));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clj3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 92, 92, 498]], "test": "untested"}
{"id": "mlS3Dd", "name": "Thicc Claude", "author": "MysteryPancake", "description": "Click and move mouse to grow and shrink :)", "tags": ["2d", "chroma", "distort", "greenscreen", "chromakey", "matte", "compositing", "weird", "drugs", "funny", "thick", "wide", "weed", "thicc"], "likes": 18, "viewed": 359, "published": 3, "date": "1674140591", "time_retrieved": "2024-07-30T18:14:49.961098", "image_code": "const float TAU = 6.28318530;\n\nfloat getAlpha(vec3 col) {\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    return step(0.7, distance(col, green));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 64.0;\n    const float radius = 32.0;\n    \n    // Distortion factor, change with mouse\n    float distort = iMouse.z > 0.0 ? iMouse.x / iResolution.x * 2.0 - 1.0 : -0.5;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bg = vec3(uv.x, 1.0 - uv.y, 1.0) + smoothstep(0.4, 0.6, length(uv - 0.5));\n    \n    fragColor = texture(iChannel0, uv);\n    float alpha = getAlpha(fragColor.rgb);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    // STEP 1: Find average direction away from edge\n    \n    vec2 dirAvg = vec2(0.0);\n    bool interior = false;\n    \n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n        // Move in a circle to find edges within radius\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        \n        // Edge was found, accumulate for average\n        float neighbor = getAlpha(col.rgb);\n        if (alpha != neighbor) {\n            dirAvg += dir;\n            interior = alpha > neighbor;\n        }\n    }\n    \n    // No edges within radius\n    if (length(dirAvg) <= 0.0) {\n        fragColor.rgb = mix(bg, fragColor.rgb, alpha);\n        return;\n    }\n    \n    // Calculate average direction\n    dirAvg = normalize(dirAvg);\n\n    // STEP 2: Raycast in average direction until an edge is hit\n    \n    float d = radius * 0.5;\n    float move = d * 0.5;\n    // Binary search works better than linear search\n    for (int i = 0; i < 8; i++, move *= 0.5) {\n        vec4 col = texture(iChannel0, uv + dirAvg * aspect * d);\n        d += alpha != getAlpha(col.rgb) ? -move : move;\n    }\n    \n    // STEP 3: Fix interior direction and distance\n    \n    dirAvg = interior ? dirAvg : -dirAvg;\n    d = interior ? radius - d : d + radius;\n\n    // Distort the image\n    fragColor = texture(iChannel0, uv + dirAvg * aspect * d * distort);\n    fragColor.rgb = mix(bg, fragColor.rgb, getAlpha(fragColor.rgb));\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 147], [149, 149, 204, 204, 2158]], "test": "untested"}
{"id": "cl23Wt", "name": "Curling Smoke", "author": "leon", "description": "finally learnt how to curl noise", "tags": ["curl", "smoke", "gyroid"], "likes": 127, "viewed": 3668, "published": 3, "date": "1674136888", "time_retrieved": "2024-07-30T18:14:50.772927", "image_code": "\n// Curling Smoke by Leon Denise 2023-01-19\n\n// finally learnt how to curl noise\n\n// from Pete Werner article:\n// http://petewerner.blogspot.com/2015/02/intro-to-curl-noise.html\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // noise\n    vec3 blu = texture(iChannel1, fragCoord/1024.).rgb;\n    \n    // frame\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // normal\n    vec2 e = vec2(pow(blu.x, 3.)*0.084,0);\n    #define T(u) texture(iChannel0, uv+u).r\n    vec3 normal = vec3(\n        T(e.xy)-T(-e.xy), \n        T(-e.yx)-T(e.yx),\n        color.r*.1);\n    if (abs(normal.x) + abs(normal.y) + abs(normal.z) > .001)\n        normal = normalize(normal);\n             \n    // shade\n    color *= dot(normal, normalize(vec3(0,1,1)))*.5+.5;\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Curling Smoke\n\n// finally learnt how to curl noise\n\n// from Pete Werner article:\n// http://petewerner.blogspot.com/2015/02/intro-to-curl-noise.html\n\n#define R iResolution.xy\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\nfloat noise (vec3 p)\n{\n    float result = 0., a = .5;\n    float count = R.y < 500. ? 6. : 8.;\n    for (float i = 0.; i < count; ++i, a/=2.)\n    {\n        p.z += iTime*.1;//+result*.5;\n        result += abs(gyroid(p/a))*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = (2.*fragCoord-R.xy)/R.y;\n    vec2 offset = vec2(0);\n    \n    // curl\n    vec2 e = vec2(.01,0);\n    vec3 pos = vec3(p, length(p)*.5);\n    float x = (noise(pos+e.yxy)-noise(pos-e.yxy))/(2.*e.x);\n    float y = (noise(pos+e.xyy)-noise(pos-e.xyy))/(2.*e.x);\n    vec2 curl = vec2(x,-y);\n\n    // force fields\n    offset += curl;\n    offset -= normalize(p) * sin(iTime*2.-length(p)*6.);\n\n    // displace buffer sampler coordinates\n    uv += offset*.002*vec2(R.y/R.x, 1);\n    vec3 frame = texture(iChannel0, uv).rgb;\n    \n    // spawn from edge\n    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x - 1.\n        || fragCoord.y < 1. || fragCoord.y > R.y - 1.;\n    \n    // spawn at first frame\n    spawn = spawn || iFrame < 1;\n    \n    // color palette\n    // https://iquilezles.org/articles/palettes\n    if (spawn) color = .5+.5*cos(vec3(1,2,3)*5.5+iTime+(uv.x+uv.y)*6.);\n    \n    // buffer\n    else color = max(color, frame);\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl23Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 237, 256, 858]], "test": "untested"}
{"id": "Dl2GDt", "name": "Pantheon", "author": "dr2", "description": "Roman Pantheon; use mouse to select view and look around.", "tags": ["oculus", "temple", "architecture", "dome", "rome"], "likes": 21, "viewed": 271, "published": 3, "date": "1674131402", "time_retrieved": "2024-07-30T18:14:51.728373", "image_code": "// \"Pantheon\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/* \n  Some of the Pantheon's architectural features are roughly reproduced.\n  \n  Views: interior and exterior, fixed and variable sections, panorama.\n\n  Interior is dim since occulus in only light source; an update with\n  modern lighting is coming soon.\n\n  No. 74 in \"Architecture\" series - listed at end\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (vec2 vAzEl);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 RotVF (vec3 v, vec4 cs);\nvec3 RotVB (vec3 v, vec4 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, doorSz, cutVec;\nvec2 bmAzEl, drAngCs;\nfloat tCur, dstFar, domeRd, domeBs, oculRd, wallRd, wallThk, wallHt;\nint idObj, dirCut;\nconst int idDomeI = 1, idDomeM = 2, idDomeO = 3, idDomeOx = 4, idWallin = 5, idWallex = 6,\n   idCeil = 7, idFlor = 8, idPort = 9, idPortRf = 10, idGrt = 11, idPil = 12, idPlin = 13,\n   idBall = 14, idEnt = 15, idDoor = 16, idBase = 17;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define CUT Cut (p, d);\n#define DMIN(id) CUT if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) CUT if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid Cut (vec3 p, inout float d)\n{\n  if (dirCut > 0) d = max (d, dot (p, cutVec));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 nSeg, a, b1, b2, dmx[3], u;\n  float dMin, d, dd, r, rh, t;\n  dMin = dstFar;\n  nSeg = vec2 (28., 27.);\n  rh = length (p.xz);\n  r = length (p - vec3 (0., domeBs, 0.));\n  q = p;\n  q.y -= domeBs;\n  a = 2. * pi * (floor (nSeg * atan (q.zy, - vec2 (q.x, rh)) / (2. * pi)) + 0.5) / nSeg;\n  b1 = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  b1.y = abs (b1.y);\n  b2 = Rot2Cs (vec2 (rh, q.y), sin (a.y + vec2 (0.5 * pi, 0.)));\n  b2.y = abs (b2.y);\n  for (int k = 0; k < 3; k ++) {\n    u = sin (0.1 * float (k + 1) * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n    dmx[k] = vec2 (dot (b1, u), dot (b2, u));\n  }\n  t = domeRd - r;\n  d = max (min (max (abs (t - 0.06) - 0.01, Minv2 (dmx[0])),\n     max (abs (t - 0.04) - 0.04, rh - 0.43)), max (oculRd - rh, -0.01 - q.y));\n  DMIN (idDomeI);\n  d = max (min (max (abs (t - 0.045) - 0.01, Minv2 (dmx[1])),\n     max (abs (t - 0.03) - 0.01, Minv2 (dmx[2]))), max (0.42 - rh, - q.y));\n  DMIN (idDomeM);\n  dd = domeRd + 0.45 - length (vec3 (q.x, q.y + 0.42, q.z));\n  d = max (- min (dd, q.y), t - 0.02);\n  d = max (max (d, oculRd - rh), min (1.6 - rh, 0.2 - abs (q.y + 0.2)));\n  DMIN (idDomeO);\n  d = max (min (max (abs (dd) - 0.02, max (oculRd - rh, dmx[0].x - 0.005)),\n     max (abs (dd) - 0.025, abs (oculRd + 0.05 - rh) - 0.05)), - q.y);\n  DMIN (idDomeOx);\n  d = max (min (min (min (max (abs (0.15 + dd) - 0.05, q.y - 0.44),\n     max (abs (0.1 + dd) - 0.05, q.y - 0.48)),\n     max (abs (0.05 + dd) - 0.05, q.y - 0.52)),\n     max (abs (dd) - 0.05, q.y - 0.56)), - q.y + 0.3);\n  DMIN (idDomeOx);\n  q = p;\n  d = max (max (rh - wallRd + wallThk, domeRd - rh - 0.025), abs (q.y - domeBs + 0.13) - 0.27);\n  dd = length (vec2 (Minv2 (abs (q.xz)), q.y - domeBs + 0.52)) - 0.2;\n  d = max (d, - max (rh - wallRd + wallThk + 0.03, dd));\n  DMIN (idCeil);\n  d = max (max (max (abs (domeRd - rh - 0.02) - 0.04, abs (q.y - domeBs + 0.2) - 0.2),\n     min (dmx[1].x, 0.09 - abs (q.y - domeBs + 0.15))), - dd);\n  DMIN (idWallin);\n  d = max (abs (wallRd - wallThk - rh) - 0.03, abs (q.y - domeBs + 0.86) - 0.54);\n  if (q.z > 0. && abs (q.x) < 0.23) {\n    t = min (0.22 - abs (q.x), - q.y + domeBs - 0.54);\n  } else {\n    d = max (d, min (dmx[1].x - 0.03, 0.25 - abs (q.y - domeBs + 0.8)));\n    u = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    t = 0.15 - length (vec3 (abs (u.x) - wallRd + wallThk + 0.05, max (0., q.y - domeBs + 0.59),\n       u.y));\n  }\n  d = max (d, t);\n  DMIN (idWallin);\n  d = max (max (abs (wallRd - rh) - wallThk, abs (q.y - wallHt - 0.03) - wallHt), t);\n  DMIN (idWallex);\n  d = max (length (vec2 (rh - wallRd - wallThk, abs (abs (q.y - wallHt - 0.03) - 0.6) -\n     0.27)) - 0.02, min (q.z, 1. - abs (q.x)));\n  DMIN (idWallex);\n  q = p;\n  q.y -= 0.51;\n  d = max (max (abs (wallRd - rh - 0.01) - wallThk - 0.07, length (vec2 (q.x,\n     max (q.y - 0.28, 0.))) - 0.24), -0.45 - q.y);\n  d = max (max (d, - max (abs (q.x) - 2. * doorSz.x - 0.01, abs (q.y) - doorSz.y)), - q.z);\n  dd = d;\n  DMIN (idEnt);\n  t = 0.97/12.;\n  q = p;\n  q.y -= 0.09;\n  d = max (rh - wallRd - wallThk, abs (q.y) - 0.05);\n  d = max (d, min (t - rh, q.y + 0.01));\n  d = max (d, - dd);\n  DMIN (idFlor);\n  q = p;\n  d = max (max (rh - t, abs (q.y - 0.13) - 0.01),\n     min (0.3 * t - abs (0.6 * t - rh), dmx[2].x));\n  DMIN (idGrt);\n  if (p.z < 0.3) {\n    q = p;\n    q.xz = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    q.y -= 0.28;\n    q.x = abs (q.x) - wallRd + wallThk + 0.04;\n    d = min (max (length (q.xz) - 0.02, abs (q.y) - 0.13),\n       PrRoundBoxDf (vec3 (q.xz, abs (q.y) - 0.13).xzy, vec3 (0.06, 0.005, 0.06), 0.005));\n    DMINQ (idPlin);\n    d = PrSphDf (vec3 (q.xz, q.y - 0.21).xzy, 0.07);\n    DMIN (idBall);\n  }\n  q = p;\n  q.z -= wallRd + wallThk;\n  d = max (PrBoxDf (vec3 (q.x, q.y - wallHt - 0.03, q.z + 0.1), vec3 (1.05, wallHt, 0.21)),\n     - PrBox2Df (vec2 (q.x, q.y - 0.6), vec2 (0.7, 0.46)));\n  d = min (d, PrBoxDf (vec3 (q.x, abs (q.y - 0.58) - 0.49, q.z - 0.47), vec3 (1.05, 0.05, 0.47)));\n  DMIN (idPort);\n  d = max (PrRoundBoxDf (vec3 (q.x, q.y - 2. * wallHt, q.z + 0.1), vec3 (1.05, 0., 0.21), 0.02),\n     wallRd + 0.03 - rh);\n  DMIN (idWallex);\n  q = p;\n  q.yz -= vec2 (1.56, wallRd + wallThk + 0.31);\n  d = PrBox2Df (q.xz, vec2 (1.09, 0.67));\n  q.x = abs (q.x);\n  u = Rot2Cs (q.xy, CosSin (0.125 * pi));\n  d = max (d, max (max (u.y - 0.01, -0.45 - q.y), - max (max (u.y + 0.04, -0.4 - q.y), 0.63 - q.z)));\n  d = max (d, - max (min (max (PrBox2Df (vec2 ((fract (16. * q.x + 0.5) - 0.5) / 16.,\n     q.y + 0.45), vec2 (1.2/64., 0.02)), q.x - 0.98), max (PrBox2Df (vec2 ((fract (16. * u.x +\n     0.75) - 0.5) / 16., u.y + 0.04), vec2 (1.2/64., 0.02)), u.x - 0.9)), 0.63 - q.z));\n  DMIN (idPortRf);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2. * doorSz.x, 0.51, wallRd);\n  q.xz = Rot2Cs (q.xz, drAngCs) + doorSz.xz * vec2 (1., -1.);\n  d = PrBoxDf (q, doorSz);\n  DMINQ (idDoor);\n  q = p;\n  q.y -= 0.59;\n  d = 0.15 - Minv2 (abs (q.xz));\n  q.xz = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  q.z = abs (q.z);\n  q.xz -= vec2 (- wallRd + wallThk + 0.15, 0.05);\n  u = vec2 (length (q.xz) - 0.025, abs (q.y) - 0.45);\n  d = max (d, max (Maxv2 (u), 0.022 - length (vec2 (u.x - 0.01, - max (u.y + 0.04, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  q.yz -= vec2 (0.585, wallRd + wallThk + 0.4);\n  d = max (max (abs (q.x) - 1.1, abs (q.z - 0.1) - 0.4),\n     - max (abs (abs (abs (q.x) - 0.42) - 0.27) - 0.11, q.z - 0.23));\n  q.xz = (1./3.7) * (abs (fract (3.7 * q.xz) - 0.5));\n  u = vec2 (length (q.xz) - 0.08, abs (q.y) - 0.44);\n  d = max (d, max (Maxv2 (u), 0.06 - length (vec2 (u.x - 0.02, - max (u.y + 0.09, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  d = max (rh - wallRd - wallThk - 1.4, abs (q.y - 0.02) - 0.02);\n  DMINQ (idBase);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 FloorCol (vec2 p)\n{\n  vec4 col4;\n  vec2 wd, w;\n  p = 6. * p + 0.5;\n  wd = abs (fract (p + 0.5) - 0.5);\n  if (Minv2 (wd) < 0.01) {\n    col4 = vec4 (0.6, 0.6, 0.6, 0.);\n  } else {\n    w = mod (floor (p), 2.);\n    col4 = mix (vec4 (0., 0., 0.8, 0.1), vec4 (0.8, 0.8, 0.8, 0.1), smoothstep (0.15, 0.2,\n       fract (16. * Fbm2 (Rot2D (vec2 (2., 4./3.) * p,\n       0.25 * pi * (0.5 + w.x + 2. * w.y)) + 20.))));\n    if (w.x == w.y) col4 = mix (((dot (mod (floor (p), 4.), vec2 (1., -1.)) == 0.) ?\n       vec4 (0.4, 0., 0., 0.1) : vec4 (0.6, 0.6, 0.55, 0.1)), mix (vec4 (0.7, 0.5, 0., 0.1),\n       col4, 0.1 + 0.9 * step (Minv2 (wd - 0.13), 0.)), step (0.28, length (wd - 0.5)));\n    else col4 = mix (vec4 (0.4, 0., 0., 0.1), col4, 0.1 + 0.9 * step (0.07,\n       abs (Minv2 (wd - 0.2))));\n  }\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4, mCol4, dwCol4;\n  vec2 u;\n  float rh, a, x, wtm, wtp;\n  mCol4 = vec4 (0.8, 0.8, 0.75, 0.);\n  dwCol4 = vec4 (0.3, 0.3, 0.7, 0.);\n  vf = vec2 (0.);\n  rh = length (ro.xz);\n  wtm = wallRd - wallThk;\n  wtp = wallRd + wallThk;\n  if (idObj <= idFlor) {\n    if (idObj == idDomeI) {\n      if (rh < oculRd + 0.002) col4 = mCol4;\n      else if (rh < 0.43) col4 = dwCol4;\n      else col4 = 1.1 * mCol4;\n    } else if (idObj == idDomeM) {\n      col4 = 1.05 * mCol4;\n    } else if (idObj == idDomeO) {\n      if (length (ro - vec3 (0., domeBs, 0.)) < domeRd) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (32. *\n           atan ((ro.y - 1.12) / rh) / pi)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idDomeOx) {\n      col4 = vec4 (1., 1., 1.1, 1.) * mCol4;\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idWallin) {\n      a = atan (ro.z, - ro.x) / (2. * pi) + 0.5;\n      if (rh > wtm - 0.02 && ro.y < 1. && ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22)) {\n        col4 = dwCol4;\n      } else if (rh < wtm - 0.05 && ro.y < 1.15) {\n        col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.) * (1.2 - 0.2 * step (0.01,\n           PrBox2Df (vec2 (fract (224. * a + 0.5) - 0.5, ro.y - 1.14), vec2 (0.3, 0.004))));\n      } else {\n        a = fract (28. * a + 0.5) - 0.5;\n        col4 = mCol4 * (1.2 - 0.2 * step (0.01, min (PrBox2Df (vec2 (a, ro.y - domeBs + 0.15),\n           vec2 (0.35, 0.09)), PrBox2Df (vec2 (a, ro.y - domeBs + 0.8), vec2 (0.24, 0.25)))));\n        if (ro.y > 0.92) col4 *= 1.2 - 0.2 * step (0.2, length (vec2 (a, 3.3 * (ro.y - 0.92))));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idWallex) {\n      if (ro.y < 1. && (rh < wtm + 0.03 && abs (ro.x) > 0.22 || rh < wtm + 0.11 &&\n         ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22))) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        if (rh > wtp - 0.02) {\n          u = Rot2Cs (ro.xz, CosSin (pi / 14.));\n          x = 0.5 * wtp * dot (u.yx, CosSin (2. * pi * (floor (14. *\n             atan (u.y, - u.x) / (2. * pi)) + 0.5) / 14.));\n          if (ro.y > 1.44 && abs (length (vec2 (x, ro.y - 1.12)) - 0.55) < 0.05 ||\n             abs (ro.y - 1.36) < 0.08 && abs (x) > 0.37) col4 = 1.03 * mCol4;\n          if (PrBox2Df (vec2 (x, ro.y - 1.34), vec2 (0.04, 0.06)) < 0.)\n             col4 = vec4 (0.3, 0.3, 0.3, 0.);\n        }\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idCeil) {\n      if (ro.y < 1.2 && rh < wtm - 0.01) {\n        col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n      } else if (rh < domeRd) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idFlor) {\n      if (ro.y > 0.12 && rh < wallRd) {\n        col4 = FloorCol (ro.xz);\n      } else if (rh < 0.85 * oculRd && ro.y > 0.05) {\n        col4 = vec4 (0., 0.3, 0., 0.);\n      } else {  \n        col4 = mCol4;\n        vf = vec2 (128., 0.8);\n      }\n    }\n  } else {\n    if (idObj == idPil || idObj == idPlin) a = abs (fract (16. * atan (qHit.z, qHit.x) /\n       (2. * pi) + 0.5) - 0.5);\n    if (idObj == idPort) {\n      col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n      if (abs (ro.x) < 1.04 && abs (dot (vec2 (abs (ro.x), ro.y), sin (0.125 * pi +\n         vec2 (0., 0.5 * pi))) - 1.54) < 0.02) col4 = 1.03 * mCol4;\n      if (abs (ro.x) > 1. && PrBox2Df (vec2 (abs (ro.y - 0.5 * wallHt - 0.5) - 0.5,\n         ro.z - wtp + 0.1), vec2 (0.08, 0.04)) < 0.) col4 = vec4 (0.3, 0.3, 0.3, 0.); \n      vf = vec2 (128., 0.8);\n    } else if (idObj == idPortRf) {\n      col4 = mCol4 * vec4 (1., 0.95, 0.95, 1.) * (0.9 +\n         0.1 * step (0.05, abs (fract (16. * ro.z + 0.8) - 0.5)));\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idGrt) {\n      col4 = vec4 (1., 0.8, 0., 0.2);\n    } else if (idObj == idPil) {\n      col4 = (rh < wallRd) ? vec4 (0.65, 0.6, 0.6, 0.) : 0.95 * mCol4;\n      if (abs (qHit.y) < 0.41) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idPlin) {\n      col4 = vec4 (0.8, 0.7, 0.6, 0.);\n      if (abs (qHit.y) < 0.11) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idBall) {\n      col4 = vec4 (vec3 (0.9, 0.8, 0.5) * (1. - 0.2 * Fbm1 (16. * tCur)), -1.);\n    } else if (idObj == idEnt) {\n      col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n    } else if (idObj == idDoor) {\n      col4 = vec4 (0.3, 0.3, 0., 0.1) * (0.8 + 0.2 * step (0., PrBox2Df (qHit.xy,\n         doorSz.xy - 0.03)));\n    } else if (idObj == idBase) {\n      u = qHit.xz * vec2 (1./6., 1.) * 16.;\n      x = u.x + 1./3. + ((fract (0.5 * u.y) < 0.5) ? 0. : 0.5);\n      col4 = vec4 (0.5, 0.5, 0.5, 0.) * (0.9 + 0.1 * smoothstep (0.1, 0.15,\n         min (fract (u.y), 6. * min (fract (x), fract (x + 2./3.)))));\n    }\n  }\n  return col4;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float rad, out vec3 rHit)\n{\n  vec3 vn;\n  float dMin, d, a, b, w;\n  dMin = 1e6;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      d /= a;\n      rHit = ro + d * rd;\n      dMin = d;\n      vn = vec3 (rHit.xz / rad, 0.).xzy;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BmVal (vec3 ro, vec3 rd, float dstLim, float bmRad, out vec3 bmHit, out vec3 bmAx)\n{  // (circular cross section)\n  vec4 dc4, csBm;\n  float bmVal;\n  csBm = vec4 (CosSin (bmAzEl.x), CosSin (bmAzEl.y));\n  bmAx = RotVF (vec3 (0., -1., 0.), csBm);\n  bmVal = 0.;\n  dc4 = CylHit (RotVB (ro, csBm), RotVB (rd, csBm), bmRad, bmHit);\n  if (dc4.x < dstLim) {\n    bmVal = max (- dot (RotVF (dc4.yzw, csBm), rd), 0.);\n    bmHit = RotVF (bmHit, csBm);\n  }\n  return bmVal;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltDir, col, vn, roo, bmHit, bmAx, oculPos;\n  vec2 vf;\n  float dstObj, dstGrnd, sh, bmVal;\n  bool inBldg, isBg;\n  domeRd = 1.2;\n  domeBs = domeRd + 0.24;\n  wallRd = 1.7;\n  wallHt = 0.9;\n  wallThk = 0.26;\n  oculRd = 0.16;\n  oculPos = vec3 (0., domeBs + domeRd, 0.);\n  doorSz = vec3 (0.09, 0.35, 0.013);\n  drAngCs = CosSin (-0.5 * pi * clamp (-0.3 + 1.6 * abs (2. * fract (0.25 * tCur) - 1.), 0., 1.));\n  roo = ro;\n  isBg = false;\n  inBldg = false;\n  dstGrnd = dstFar;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    inBldg = ((dirCut == 0 && ((length (ro.xz) < wallRd && ro.y < 2. * wallHt ||\n       length (ro - vec3 (0., domeBs, 0.)) < domeRd && ro.y > domeBs) ||\n       idObj == idEnt && ro.z < wallRd || idObj == idDoor)) || idObj == idBall);\n    col4 = ObjCol (ro, vf);\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (inBldg) {\n        ltDir = normalize (oculPos - ro);\n        col = col4.rgb * (0.05 + 0.4 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n      }\n    } else {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0. && dirCut == 0) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    col4 = vec4 (0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz))), 0.05);\n  } else {\n    isBg = true;\n    col = (dirCut == 0) ? SkyBgCol (ro, rd) : vec3 (0.3, 0.4, 0.5) * (0.7 + 0.3 * rd.y);\n  }\n  if (! isBg && ! inBldg) {\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    if (dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  }\n  if (inBldg) {\n    bmVal = BmVal (roo - oculPos, rd, min (dstObj, dstFar), oculRd, bmHit, bmAx);\n    bmHit += oculPos;\n    if (bmVal > 0. && length (bmHit.xz) < wallRd - 0.12 && bmHit.y > 0.12) {\n      col += 0.2 * col4.rgb * max (0., - dot (vn, bmAx)) * (1. - smoothstep (-0.1, 0.1,\n         length (ro - oculPos - dot (ro - oculPos, bmAx) * bmAx) - oculRd));\n      if (bmHit.y < oculPos.y + 0.02) col += 0.2 * vec3 (1., 1., 0.9) * bmVal;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  4\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, mAzEl, vAzEl;\n  float zmFac, asp, sr, t, tt;\n  int vuId, regId;\n  bool isPano;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (- asp, -1.);\n  mMid[3] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  mAzEl = (mPtr.z > 0. && vuId == regId) ? vec2 (2., 1.) * pi * msw : vec2 (0.);\n  if (mPtr.z <= 0.) {\n    t = mod (0.04 * tCur, 2.);\n    t = (abs ((floor (8. * t) + smoothstep (0.8, 1., fract (8. * t))) / 8. - 1.) - 0.5);\n  } else t = 0.;\n  dirCut = 0;\n  isPano = false;\n  if (vuId == 0) {\n    ro = vec3 (0., 0.6, -1.);\n    vAzEl = vec2 (0.25 * pi + mAzEl.x + 0.2 * pi * t, clamp (0.04 * pi + mAzEl.y, -0.4 * pi, 0.4 * pi));\n    zmFac = 1.5;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 1., -15.);\n    vAzEl = vec2 (pi + 1.1 * mAzEl.x + 0.4 * pi * t, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.));\n    zmFac = 5.5;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 1.5, -0.1);\n    vAzEl = vec2 (1.1 * mAzEl.x, clamp (0.5 *  mAzEl.y, -0.15 * pi, 0.15 * pi));\n    zmFac = 0.3;\n    isPano = true;\n  } else if (vuId == 3) {\n    ro = vec3 (0., 1.2, -10.);\n    vAzEl = vec2 (1.1 * mAzEl.x, 0.);\n    zmFac = 5.;\n    dirCut = 2;\n  } else if (vuId == 4) {\n    ro = vec3 (0., 1.3, -10.);\n    vAzEl = vec2 (-0.5 * pi + 1.1 * mAzEl.x, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.4 * pi));\n    zmFac = 5.;\n    dirCut = 1;\n  }\n  vuMat = StdVuMat (vAzEl);\n  ro = vuMat * ro;\n  if (vuId == 0) ro.y = max (ro.y, 0.2);\n  if (dirCut == 1) {\n    cutVec = vec3 (1., 0., 0.);\n  } else if (dirCut == 2) {\n    cutVec = vec3 (0., 0., -1.);\n    cutVec.xz = Rot2D (cutVec.xz, - vAzEl.x);\n  }\n  tt = 1. - fract (0.02 * tCur);\n  t = SmoothBump (0.25, 0.75, 0.23, tt);\n  bmAzEl = pi * ((tt < 0.5) ? vec2 (0.5 + t, 0.16) : vec2 (0.5, 0.16 * (1. - 2. * t)));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)),\n       uvv.y).xzy : vec3 (2. * tan (0.5 * atan (uvv / vec2 (asp, 1.))) * vec2 (asp, 1.), 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (vec2 vAzEl)\n{\n  vec2 ca, sa;\n  ca = cos (vAzEl);\n  sa = sin (vAzEl);\n  return mat3 (ca.x, 0., - sa.x, 0., 1., 0., sa.x, 0., ca.x) *\n         mat3 (1., 0., 0., 0., ca.y, - sa.y, 0., sa.y, ca.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, cs * vec2 (1., -1.)), dot (q.yx, cs));\n}\n\nvec3 RotVF (vec3 v, vec4 cs)\n{\n  v.yz = Rot2Cs (v.yz, cs.zw * vec2 (1., -1.));\n  v.xz = Rot2Cs (v.xz, cs.xy * vec2 (1., -1.));\n  return v;\n}\n\nvec3 RotVB (vec3 v, vec4 cs)\n{\n  v.xz = Rot2Cs (v.xz, cs.xy);\n  v.yz = Rot2Cs (v.yz, cs.zw);\n  return v;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/* \n \"Architecture\" series:\n   \"Rainbow Cavern\"                  (XsfBWM)\n   \"Fractal Bridge\"                  (XlsGRN)\n   \"Icy Moon\"                        (XllGDr)\n   \"Parthenon\"                       (MtX3DH)\n   \"Temple of the Waves\"             (Mll3W4)\n   \"Albert Mews\"                     (lts3zf)\n   \"Stairway to the Stars\"           (lt2Gzt)\n   \"Wobbly Blob\"                     (ll2SRz)\n   \"Gotham City\"                     (XljXR3)\n   \"Magic Tree\"                      (llBSDK)\n   \"Flame Ascending\"                 (Xdd3W7)\n   \"Garage\"                          (Ms33Dj)\n   \"Pannini's Rotunda\"               (Ms3SzH)\n   \"Pannini Flies Gotham\"            (4s3XzN)\n   \"Canal City\"                      (lsdXzM)\n   \"Amphitheater\"                    (Xs3XDB)\n   \"Aquatic Hippodrome\"              (4stSWB)\n   \"Urban Growth\"                    (XdXcRM)\n   \"Babel's Library\"                 (4slcW2)\n   \"Bibliotheque\"                    (lsXcWs)\n   \"Ultimate Library\"                (4s2czR)\n   \"Books and Stairs\"                (4djczw)\n   \"Mount Book\"                      (XsjcRc)\n   \"Literary Tunnel\"                 (ldSyDG)\n   \"Atlantis 2\"                      (XdlBzX)\n   \"Desert Town\"                     (XslBDl)\n   \"Voronoi Towers\"                  (XdBBRh)\n   \"Canal Ruins\"                     (4dBfzD)\n   \"Alphaville\"                      (XtfczN)\n   \"Rector's Palace\"                 (Xl2yzK)\n   \"Ocean Structure\"                 (ltBczc)\n   \"White Folly\"                     (ll2cDG)\n   \"White Folly 2\"                   (ltXfzr)\n   \"Lightweight Lighthouse\"          (XtfBz4)\n   \"Magic Tree 2\"                    (MllBzH)\n   \"Books and Stairs 2\"              (MtsfRl)\n   \"Opera Island\"                    (MlSBWG)\n   \"Blob Zoo\"                        (4sdcWN)\n   \"Hexpo\"                           (lsdcD7)\n   \"Alphapolis\"                      (4scyDj)\n   \"Paternoster\"                     (XsVyz1)\n   \"Tesla's Tower\"                   (MdycRK)\n   \"Parthenon 2\"                     (lldBDn)\n   \"Waterworld City\"                 (wlsGDn)\n   \"Palace on the Hill\"              (Wlj3DD)\n   \"Stairs to Nowhere\"               (wtB3R3)\n   \"Submerging Tower\"                (wdcGWr)\n   \"Racetrack\"                       (tscSDn)\n   \"Chateaux..\"                      (Wtd3Df)\n   \"Library Lost and Found\"          (tdlBzH)\n   \"Sand Album\"                      (3slBRf)\n   \"Water Falling\"                   (3sBfDR)\n   \"Belvedere\"                       (3dSfzt)\n   \"Escalator 2\"                     (3lBBWm)\n   \"Edible Edifices\"                 (3ljBWt)\n   \"Gliders Over Voropolis\"          (WdKcz1)\n   \"Underground Trains\"              (tsKyzw)\n   \"Energy Temple\"                   (tttyzB)\n   \"Chateaux... v2\"                  (fsjXWG)\n   \"Urban Smog\"                      (NsdGDN)\n   \"Spherical Metropolis\"            (ssG3W3)\n   \"Vessel Climbing\"                 (NdGXDD)\n   \"Mesh Dome\"                       (ssKXRt)\n   \"Wind Farm\"                       (Ntd3R2)\n   \"Gold Edifices\"                   (NldSzM)\n   \"Mausolea\"                        (ftcSWS)\n   \"Melange\"                         (slKXD3)\n   \"Losing Focus 2\"                  (sdSBzc)\n   \"Reading Room\"                    (fs3fzn)\n   \"Ultimate Library 2\"              (flKyDt)\n   \"Build the Palace\"                (7tKfRV)\n   \"Monorail\"                        (cdfSzl)\n   \"Palladian Schneekugel\"           (mtf3zl)\n*/                         \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GDt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1742, 1742, 1776, 1776, 1826], [1828, 1828, 1850, 1850, 7518], [7520, 7520, 7553, 7553, 7737], [7739, 7739, 7760, 7760, 8017], [8019, 8019, 8056, 8056, 8311], [8313, 8313, 8337, 8337, 9121], [9123, 9123, 9159, 9159, 14103], [14105, 14105, 14163, 14163, 14521], [14523, 14523, 14613, 14642, 14989], [14991, 14991, 15025, 15025, 15782], [15784, 15784, 15819, 15819, 18342], [18362, 18362, 18418, 18418, 21959], [21961, 21961, 21983, 21983, 22010], [22012, 22012, 22034, 22034, 22061], [22063, 22063, 22085, 22085, 22123], [22125, 22125, 22157, 22157, 22241], [22243, 22243, 22276, 22276, 22360], [22362, 22362, 22408, 22408, 22455], [22457, 22457, 22490, 22490, 22517], [22519, 22519, 22564, 22564, 22656], [22658, 22658, 22703, 22703, 22741], [22743, 22743, 22800, 22800, 22883], [22885, 22885, 22913, 22913, 23095], [23097, 23097, 23127, 23127, 23240], [23242, 23242, 23273, 23273, 23337], [23339, 23339, 23369, 23369, 23479], [23481, 23481, 23511, 23511, 23587], [23621, 23621, 23645, 23645, 23705], [23707, 23707, 23731, 23731, 23784], [23786, 23786, 23810, 23810, 23922], [23924, 23924, 23949, 23949, 24095], [24097, 24097, 24122, 24122, 24308], [24310, 24310, 24332, 24332, 24486], [24488, 24488, 24509, 24509, 24664], [24666, 24666, 24695, 24695, 24907], [24909, 24909, 24948, 24948, 25200]], "test": "untested"}
{"id": "ct2GDt", "name": "Torus Heaven", "author": "Varyemez", "description": "lorem ipsum dolor sit amet, so to speak", "tags": ["torus"], "likes": 5, "viewed": 309, "published": 3, "date": "1674130679", "time_retrieved": "2024-07-30T18:14:52.600042", "image_code": "/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/\n\nconst int MAX_STEP = 80;\nconst float SURFACE_DIST = 0.02;\nconst float PI = radians(180.);\n\nconst vec2 torusr = vec2(0.85, 0.15)*0.5;\n\nmat2 rot2d(float r)\n{\nfloat s = sin(r), c = cos(r);\nreturn mat2(c,-s,s,c);\n}\nfloat random(vec2 s)\n{\nreturn fract(sin(dot(s, vec2(362.485, 123.445))*764.346)*2647.9752);\n}\n\nfloat plane(vec3 p)\n{\nreturn abs(p.y);\n}\nfloat sphere(vec3 p, float r)\n{\nreturn length(p)-r;\n}\nfloat torus(vec3 p, float a, float b)\n{\nreturn length(vec2(length(p.xz)-a, p.y))-b;\n}\nfloat cube(vec3 p, float r)\n{\np = abs(p);\nreturn length(max(p-r, 0.));\n}\n\nfloat map(vec3 p)\n{\nfloat angle = atan(1., 1.);\np.xz *= rot2d(angle);\n//p.y += time*pow(-1., floor(p.z));\np = fract(p);\np -= 0.5;\nfloat t0 = torus(p, torusr.x, torusr.y);\np.xy *= rot2d(PI*0.5);\np.z -= 0.5;\nfloat t1 = torus(p, torusr.x, torusr.y);\np.z += 1.;\nfloat t2 = torus(p, torusr.x, torusr.y);\nreturn min(min(t0, t1), t2);\n}\n\nvec3 get_normal(vec3 p)\n{\nvec2 e = vec2(0.05, 0.);\nfloat d = map(p);\nreturn -normalize(vec3(\nd-map(p+e.xyy),\nd-map(p+e.yxy),\nd-map(p+e.yyx)\n));\n}\n\nfloat raymarch(vec3 vo, vec3 dir)\n{\n    float d = 0.;\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n    float cd = map(vo + dir*d);\n    if (cd < SURFACE_DIST)\n    break;\n    d += cd;\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n    vec3 r0 = vec3(0.,1.,0.);\n    vec3 dir = normalize(vec3(uv.xy, 1.));\n    r0.z += iTime;\n    //dir.xz *= rot2d(time);\n    float d = raymarch(r0, dir);\n    vec3 p = r0 + dir*d;\n\n    fragColor = vec4(0.3, 0., 1., 1.) / max(0.5, d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2GDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 455, 455, 510], [511, 511, 533, 533, 604], [606, 606, 627, 627, 646], [647, 647, 678, 678, 700], [701, 701, 740, 740, 786], [787, 787, 816, 816, 859], [861, 861, 880, 880, 1190], [1192, 1192, 1217, 1217, 1337], [1339, 1339, 1374, 1374, 1542], [1544, 1544, 1599, 1599, 1899]], "test": "untested"}
{"id": "cljGDt", "name": "1D Binary Search", "author": "MysteryPancake", "description": "I think this is a binary search? I needed a function which converges to a value by overestimating first.\nUse your mouse to move the target :)", "tags": ["2d", "binary", "animation", "1d", "sort", "quad", "squares", "quadtree", "search", "find"], "likes": 5, "viewed": 213, "published": 3, "date": "1674130342", "time_retrieved": "2024-07-30T18:14:53.847707", "image_code": "// Function to converge towards, use mouse to move target\nbool check(float guess) {\n    float target = iMouse.z > 0.0 ? iMouse.x / iResolution.x : sin(iTime) * 0.5 + 0.5;\n\treturn guess > target;\n}\n\n// Each step, move another half towards the target\nfloat search(float maximum, int steps) {\n\tfloat current = maximum * 0.5;\n\tfloat move = current * 0.5;\n\tfor (int i = 0; i < steps; i++, move *= 0.5) {\n\t\tcurrent += check(current) ? -move : move;\n\t}\n\treturn current;\n}\n\n// Modified from https://www.shadertoy.com/view/lsS3Wc\nvec3 hue2rgb(float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // X axis is the estimated value, Y axis is the step\n    float steps = 12.0;\n    float result = search(1.0, int(uv.y * steps));\n    float line = 0.002 / abs(uv.x - result);\n    fragColor.rgb = hue2rgb(floor(uv.y * steps) / steps) * line;\n    \n    // Vignette\n    fragColor.rgb += smoothstep(0.1, 1.0, length(uv - 0.5)) * 0.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 83, 83, 196], [198, 249, 289, 289, 464], [466, 521, 546, 546, 636], [638, 638, 693, 693, 1074]], "test": "untested"}
{"id": "mtS3Wd", "name": "waffle sphere maze", "author": "FabriceNeyret2", "description": "WIP\nmouse controls camera", "tags": ["raymarching", "maze", "short", "waffle"], "likes": 22, "viewed": 270, "published": 3, "date": "1674117562", "time_retrieved": "2024-07-30T18:14:54.658539", "image_code": "// variant of https://shadertoy.com/view/mlBGWd\n// variant of https://shadertoy.com/view/dlBGWd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h; \n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q),\n        a = abs(q),\n        m = max(a.x, max(a.y,a.z)),\n        U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,          // cube-sphere mapping\n        U *= 8./t, h = H(ceil(U)),\n        q.xy = ( fract(U) - .5 ) / 8.*t*.7,                   // distance to walls\n        t = min ( t-1.3, max( t-1.5 ,                      // trimmed by sphere\n                  abs(q.x+sign(h-.5)*q.y)) ),              // wall = random tile diagonal\n               // min(abs(q.x),abs(q.y)) )),               // wall = waffle\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                           // color scheme\n //O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtS3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 254, 254, 1590]], "test": "untested"}
{"id": "dtS3Wd", "name": "waffle sphere 3", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "short", "waffle"], "likes": 11, "viewed": 201, "published": 3, "date": "1674117098", "time_retrieved": "2024-07-30T18:14:55.498293", "image_code": "// variant of https://shadertoy.com/view/mlBGWd\n// variant of https://shadertoy.com/view/dlBGWd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q),\n        a = abs(q),\n        m = min(a.x, min(a.y,a.z)),\n        U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,          // cube-sphere mapping\n        U = abs( fract(12.*U/t) - .5 ) / 12.*t,            // distance to walls\n        t = max( t-1.5 , min(U.x,U.y) ),                   // distance trimmed by sphere\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 206, 206, 1248]], "test": "untested"}
{"id": "mlBGWd", "name": "waffle sphere 2", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "short", "waffle"], "likes": 12, "viewed": 201, "published": 3, "date": "1674116953", "time_retrieved": "2024-07-30T18:14:56.432795", "image_code": "// variant of https://shadertoy.com/view/dlBGWd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        t = length(q),\n        a = abs(q),\n        m = max(a.x, max(a.y,a.z)),\n        U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,          // cube-sphere mapping\n        U = abs( fract(6.*U/t) - .5 ) / 6.*t,              // distance to walls\n        t = max( t-1.5 , min(U.x,U.y) ),                   // distance trimmed by sphere\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 158, 158, 1200]], "test": "untested"}
{"id": "dlBGWd", "name": "waffle sphere", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "short", "waffle"], "likes": 13, "viewed": 197, "published": 3, "date": "1674116758", "time_retrieved": "2024-07-30T18:14:57.396219", "image_code": "\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    //p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        a = abs(q),\n        m = max(a.x, max(a.y,a.z)),\n        U = m==a.x ? q.yz : m==a.y ? q.xz : q.xy,          // cube-sphere mapping\n        U = abs( fract(4.*U) - .5 ) / 4.,                  // distance to walls\n        t = max( length(q)-1.5 , min(U.x,U.y) ),           // distance trimmed by sphere\n        p += .5*t*D;                                       // step forward = dist to obj    \n      \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 110, 110, 1253]], "test": "untested"}
{"id": "dtB3Dt", "name": "animandel", "author": "jib", "description": "Guided by chatGPT", "tags": ["fractal", "animation"], "likes": 4, "viewed": 183, "published": 3, "date": "1674113561", "time_retrieved": "2024-07-30T18:14:58.150203", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.y) * 2.0 - 1.0;\n    p.x-=1.5;\n    p *= 1.0 + 0.5 * sin(pow(2.0,-0.5)*iTime);\n    vec2 c = p;\n    c.x += cos(.3*iTime+1.0) * .8;\n    c.y += sin(1.2*iTime-1.5) * .5;\n    float i;\n    for (i = 0.0; i < 1.0; i += 0.01)\n    {\n        float x = c.x;\n        float y = c.y;\n        float x2 = x*x;\n        float y2 = y*y;\n        c.x = x2 - y2 + p.x;\n        c.y = 2.0*x*y + p.y;\n        if (x2 + y2 > 8.0)\n            break;\n    }\n    vec3 color = vec3(c.x*3.1-c.y*.4,c.x*.5+c.y*2.7,i*15.0);\n    fragColor = vec4(color, .5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtB3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 619]], "test": "untested"}
{"id": "DlBGDd", "name": "Colorful Clouds", "author": "fishy", "description": "Volumetric rendering! I probably did a few things (or more?) wrong here and there, but I think they look good. Mouse to look.", "tags": ["volume", "clouds", "volumetric"], "likes": 3, "viewed": 191, "published": 3, "date": "1674093820", "time_retrieved": "2024-07-30T18:14:58.922139", "image_code": "// Doing this (define below) results in 0 second compile times (versues 5 second)\n// (when I added it I thought that something wasn't working right and that's why I got instant compilation)\n#define LOOP_ZERO float(min(iFrame, 0))\n\n#define FOCAL_LEN 1.5\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(in vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(in vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n \nvec3 rotZ(in vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 getVolume(vec3 p)\n{\n    vec3 a = vec3(0);\n    float g = 1.;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        a += texture(iChannel0, rotY(p*0.01, 1.)/g).rgb*g;\n        g *= 0.5;\n    }\n    \n    float m = smoothstep(10., -20., (p.y));\n    vec3 r = pow(a*0.9, vec3(4.*(1.-m)))*m*3.;\n    r = mix(r, vec3(length(r)), 0.5);\n    return r;\n}\n\nvec3 castRay(vec3 ro, vec3 rd, float steps, float dist)\n{\n    vec3 accumulate = vec3(0);\n    vec3 p = ro;\n    float stepSize = dist/steps;\n    for(float i = LOOP_ZERO; i < steps; i++)\n    {\n        vec3 volume = getVolume(p);\n        accumulate += volume*stepSize;\n        p += rd*stepSize;\n    }\n    return accumulate/dist;\n}\n\nvec3 renderVolume(vec3 ro, vec3 rd, vec3 lgt, float primarySteps, float primaryDist, float shadowSteps, float shadowDist)\n{\n    vec3 accumulate = vec3(0);\n    vec3 p = ro;\n    float stepSize = primaryDist/primarySteps;\n    for(float i = LOOP_ZERO; i < primarySteps; i++)\n    {\n        vec3 volume = getVolume(p);\n        float shadow = length(castRay(p, lgt, shadowSteps, shadowDist));\n        accumulate += volume*stepSize/(shadow+1.);\n        p += rd*stepSize;\n    }\n    return accumulate/primaryDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m =  (iMouse.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, iMouse.z);\n\n    vec2 rot = vec2(0, 0)-m.xy*4.;\n    vec3 ro = vec3(0, sin(iTime*0.5)*3., iTime*10.);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), rot.y), rot.x);\n    \n    vec3 col = renderVolume(ro, rd, vec3(0, 1, 0), 100., 50., 5., 25.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 324], [326, 326, 357, 357, 392], [394, 394, 425, 425, 460], [463, 463, 494, 494, 529], [531, 531, 555, 555, 870], [872, 872, 929, 929, 1198], [1200, 1200, 1323, 1323, 1705], [1707, 1707, 1764, 1814, 2250]], "test": "untested"}
{"id": "ctBGDd", "name": "Fractal labyrinth mosaic", "author": "jarble", "description": "A labyrinth-like fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "labyrinth", "rug"], "likes": 10, "viewed": 355, "published": 3, "date": "1674091495", "time_retrieved": "2024-07-30T18:14:59.679115", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = vec2(1.,.5);\n    return abs(f1((a+a2)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    bool t3 = false;\n    vec2 uv1=uv;\n    for(int k = 0; k < 9; k++){\n        //uv = uv.yx;\n        uv =\n            triangle_wave(uv-.5)-triangle_wave(uv.yx)\n            //abs(triangle_wave(uv-.5)-triangle_wave(uv.yx))\n            //triangle_wave(uv*sign(uv)-.5)-triangle_wave(uv.yx)\n        ;\n        \n        //awesome carpet pattern!\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        \n        //if(uv.y>uv.x) uv = uv.yx;\n        //uv *= sign(uv.x);\n        \n        vec2 uv1 =\n            //(triangle_wave((uv)/1.5)-triangle_wave((uv.yx)/1.5))*vec2(1.,-1.)\n            uv\n        ;   \n        \n        col.x =\n            max(abs(uv1.y+uv1.x)/2.,col.x)\n            //1.-max(abs(uv.y+uv.x)/2.,col.x)\n            //max(abs(uv.y*sign(uv.x)+uv.x*sign(uv.y))/2.,col.x)\n        ;\n        col =\n            abs(col-1.+col.x)\n            //abs(vec3(col.zx,max(uv.x-uv.y,col.y))-1.+col.y)\n        ;\n        //if(uv.x>uv.y){uv=uv.yx;}\n        //uv -= floor(1.)/8.;\n\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "float fract1(float a){\n    return\n        //fract(a)\n        abs(fract(a)-.25)*1.25\n        //fract(a+pow(fract(a*2.),2.))\n    ;\n}\n\nfloat fmod2(float a, float b){\n    return mod(floor(a/b),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += mod(pow(b/2.,2.),pow(2.,b));\n    //a += fmod2(a*4.,4.);\n    a += floor(a/2.);\n    a += floor(a/4.);\n    //divide by prime numbers to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(mod(floor(a/2.+4.),b*2.),b)\n        //floor(mod(floor(a+b/2.),b)+mod(floor(a+b/4.),b/2.))\n        //floor(sqrt(mod(floor(a),b)*mod(floor(a+b),b*2.)/2.))\n        //mod(floor(a/b+b)*floor(a+b),b)\n        //mod(floor(a+floor(a/8.*pow(2.,mod(floor(a/8.),4.)))),b)\n        //max(mod(floor(a+1.)*floor(a),b),mod(floor(a),b))\n        //max(mod(floor(a),b),mod(floor(a)*floor(a),b))\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n        //mod(mod(floor((a)),floor(1.+(a)/3.)),b)\n        //fmod(a,b) mod(floor(a) + floor(b*fract(((a)/b))),b)\n        //abs(mod(floor(a)*2.,(b)*2.)-mod(floor(a),b))\n        //floor(mod(floor(pow(b,mod(floor((a)*2.)/b/b,b))/b/b),b))\n        //floor(mod(floor(pow(b,mod(floor((a)*2.)/b/b,b))/b/b),b))\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  //time *= (1.+fmod(time*2.,2.));\n  //time *= pow(2.,fmod(time*2.,3.));\n  //time /= (1.+fmod(time/2.,2.));\n  \n  float s1 =\n      8.;\n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time*s1),2.); }\n\n  //time += floor(time*4.)/4.;\n\n  float s2 = 8.,\n  t=\n      time*2.\n      //time*2./pow(2.,fmod(time*2.,3.))\n      //time + mod(time,2.)\n      //time*2.+floor(time/2.)*2.\n  ,\n  m1 =\n      fmod(t*4.,s2)\n      //fmod(t*3.+mod(t,2.),s2)\n  ,\n  t1=fmod(t*4.,s2),\n  m3 =\n      (fmod(t1,abs(s2*2.-m1)+1.)-m1);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a=\n      pow(2.,2.-log(1./8.+fract(t/s1)))\n      //128.*(1.-sqrt(fract(t/s1)))*.2\n  ,\n\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      \n      //vec2(fract(time*nb*.998/4.*m2*s1)*a,fract(time*nb/4.*m2)*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 153], [155, 155, 212, 212, 1444]], "test": "untested"}
{"id": "ctB3Dt", "name": "Year of Truchets #001", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 18, "viewed": 250, "published": 3, "date": "1674088438", "time_retrieved": "2024-07-30T18:15:00.600651", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #001\n    01/18/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\nfloat hash21(vec2 p) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat torus( vec3 p, vec2 a ){\n  return length(vec2(length(p.xy)-a.x,p.z))-a.y;\n}\n\nvec3 hp,hitpoint;\nvec2 gid, sid;\n\nconst float sz = 2.35;\nconst float hf = sz/2.;\nconst float zz = 4.25;\n\nfloat truchet(vec3 p, float id) {\n    float res =1e5;\n    \n    p.xy*=rot(T*.025);\n    p.y+=T*1.5;\n    \n    vec3 q=p;\n    vec2 gid = floor((p.xy+hf)/sz);\n    p.xy  = mod(p.xy+hf,sz)-hf;\n    \n    float rnd = hash21(gid+id);\n    if(rnd>.5) p.y *=-1.;\n    \n    float thk = .35;\n    \n    thk += .1*sin(q.y*1.3);\n    thk += .1*sin(q.x*1.3);\n    \n    vec2 d2 = vec2(length(p.xy-hf), length(p.xy+hf));\n    vec2 gx = d2.x<d2.y ? vec2(p.xy-hf) : vec2(p.xy+hf);\n    vec3 pv = vec3(gx.xy,p.z);\n    hp=pv;\n    float d = torus(pv,vec2(hf,thk));\n    \n    if(rnd>.9) { d=min(length(p.xz)-thk,length(p.yz)-thk); }\n    if(d<res) { res=d; hp=p; }\n\n    return res;\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n\n\n    float d = 1e5;\n    float m = 0.;\n    \n    for(float i=0.;i<3.;i++){\n        float e = truchet(p,i);\n        p.z+=zz;\n        d=min(e,d);\n        m+=.5;\n\n        if(d<res.x) res=vec2(d,m);\n\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, int steps) {\n    float d=0.,m=0.;\n    for(int i=0;i<steps;i++){\n        vec2 t = map(p);\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(abs(t.x)<d*MIN_DIST||d>75.) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    t+=T*.06;\n    return .75+.75*cos(PI2*t*(vec3(1.,.99,.95)+vec3(.1,.34,.27))); \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    vec2 ray = marcher(ro,rd,p,100);\n    \n    float d = ray.x;\n    float m = 23.+(ray.y*.7);\n    \n    gid = sid;\n    hitpoint = hp;\n    \n    if(d<MAX_DIST) {\n  \n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5.5,-3,13.);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01;t<24.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>24. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.35);\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),0.),24.);\n        \n        vec3 h = hue(m+hitpoint.x*.2);\n        vec3 h2 = hue(2.52+(m*2.));\n        float px = 8./R.x;\n  \n        float f = length(hitpoint.xy)-(hf*.75);\n        float ff = abs(abs(abs(f)-.2)-.1)-.05;\n        float fs=smoothstep(.1+px,-px,ff);\n        \n        f=smoothstep(px,-px,ff);\n        h=mix(h,h*.4,fs);\n        h=mix(h,h2,f);\n        C = h * diff+spec;\n    }\n\n    C = mix(C,vec3(.04), 1.-exp(-.00045*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctB3Dt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[455, 455, 477, 477, 532], [533, 533, 551, 551, 596], [598, 598, 628, 628, 679], [786, 786, 819, 819, 1432], [1434, 1434, 1452, 1452, 1701], [1703, 1703, 1733, 1733, 1926], [1928, 1928, 1985, 1985, 2214], [2216, 2264, 2282, 2282, 2367], [2369, 2369, 2410, 2429, 3785]], "test": "untested"}
{"id": "clB3Dt", "name": "Logo ArtStation Animated", "author": "Karp", "description": "I remake the ArtStation Logo and show the process because it just look likes a moving sprite when i show it to my family. \n", "tags": ["2d", "logo", "artstation"], "likes": 3, "viewed": 192, "published": 3, "date": "1674084453", "time_retrieved": "2024-07-30T18:15:01.575046", "image_code": "#define PI 3.14159265359\nvec2 RotateUV(inout vec2 uv, float angle)\n{\t\n\tangle = angle * PI / 180.0;\n    return uv * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\nvec3 Color255(int R, int G, int B)\n{\n    return vec3(float(R)/255.0, float(G)/255.0, float(B)/255.0);\n}\nfloat Clamp01( in float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n// signed distance of a 2D EquilateralTriangle from IQ\n//(https://www.shadertoy.com/view/Xl2yDW)\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdBox( in vec2 pos, in vec2 box )\n{\n    vec2 dist = abs(pos)-box;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // UV manipulation\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n\tuv = 2.0 * uv.xy / iResolution.y;\n    \n    float t = mod(iTime*0.5,5.0);\n    t = abs(sin(iTime*0.25)* 4.)-.5;\n        \n    //Anim\n    float angle = sin(-iTime) * 6.66 * mix(0.0,1.0,Clamp01(t-2.0));\n    uv = RotateUV(uv, angle);\n    //Height Offset\n    uv.x += sin(-iTime) * 0.1 * mix(0.0,1.0,Clamp01(t-2.0));\n    uv.y += cos(-iTime) * 0.1 * mix(0.0,1.0,Clamp01(t-2.0));\n    \n    //Parameter\n    vec2 uvL = RotateUV(uv,-120.0);\n    vec2 uvR = RotateUV(uv, 120.0);\n    \n    float dist = 0.15;\n    float size = 0.6;\n    float borderSize = 0.1;\n    float rounding = 0.1;\n    float blurLvl = 100.0;\n    \n    //Shapes\n    float triA = sdEquilateralTriangle(uv  + vec2(0.0,dist), mix(-dist,size,Clamp01(t)));\n    float triB = sdEquilateralTriangle(uvL + vec2(0.0,dist), mix(-dist,size,Clamp01(t)));\n    float triC = sdEquilateralTriangle(uvR + vec2(0.0,dist), mix(-dist,size,Clamp01(t)));\n    \n    float rectA = sdBox(uv  + vec2(0.0,-size-dist+borderSize-0.02), vec2(mix(-1.0,borderSize,Clamp01(t-.33))));\n    float rectB = sdBox(uvL + vec2(0.0,-size-dist+borderSize-0.02), vec2(mix(-1.0,borderSize,Clamp01(t-.44))));\n    float rectC = sdBox(uvR + vec2(0.0,-size-dist+borderSize-0.02), vec2(mix(-1.0,borderSize,Clamp01(t-.55))));\n    \n    float diagMask = sdBox(uvR + vec2(0.0,0.18), vec2(1.0,mix(-1.0,0.025,Clamp01((t*.33) +.25))));\n    float lineMask = sdBox(uv + vec2(0.3,0.18), vec2(0.55,mix(-1.0,0.025,Clamp01((t*.33) +.1))));\n    \n    // color\n    vec3 bgCol = vec3(.0902);\n    vec3 logoCol = Color255(19,175,240);\n    \n    vec3 pixel = bgCol; \n    \n    pixel = mix(logoCol,pixel, Clamp01((triA-rounding)*blurLvl));\n    pixel = mix(logoCol,pixel, Clamp01((triB-rounding)*blurLvl));\n    pixel = mix(logoCol,pixel, Clamp01((triC-rounding)*blurLvl));\n    \n    pixel = mix(logoCol,pixel, Clamp01((rectA-rounding)*blurLvl));\n    pixel = mix(logoCol,pixel, Clamp01((rectB-rounding)*blurLvl));\n    pixel = mix(logoCol,pixel, Clamp01((rectC-rounding)*blurLvl));\n    \n    pixel = mix(bgCol,pixel, Clamp01((diagMask-0.1)*blurLvl));\n    pixel = mix(bgCol,pixel, Clamp01((lineMask-0.1)*blurLvl));\n    \n\tvec4 result = vec4(pixel, 1.0);\n\tfragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clB3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 68, 68, 168], [169, 169, 205, 205, 272], [273, 273, 305, 305, 340], [342, 439, 494, 494, 701], [702, 702, 743, 743, 839], [841, 841, 898, 922, 3119]], "test": "untested"}
{"id": "DlSGDt", "name": "Fractal Play", "author": "QuantumSuper", "description": "My first shader, watching the fractals play.", "tags": ["fractal"], "likes": 2, "viewed": 283, "published": 3, "date": "1674075673", "time_retrieved": "2024-07-30T18:15:02.500571", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fractals\n    // SETTINGS\n    float noiseShift = 4.0; //default 0; ?range -50..50\n    float spaceWarp = 0.1; //default 0; ?range 0..10\n    float digiZoom = 10.0; //default 1; ?range 1..10\n    float edgeTrueness = 1.0; //default 1; ?range 0.001..1000\n    float desat = 0.6; //default 0; range 0..1\n    float brightness = 1.1; //default 1; ?range 0..5\n    float colorShiftSpeed = 0.01; //default 0; ?range -0.01..0.01\n    float speedFactor = 0.3;\n\n    // Time renormalization\n    float time = speedFactor*iTime;\n    \n    // Normalized true-scaling pixel coordinates\n    vec2 p = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Randomize settings (optional)\n    noiseShift *= sin(time*0.1);\n    spaceWarp *= abs(sin(time*0.05));\n\n    // Fractal algorithm\n    float d = 0.;\n    float n = 0.;\n    vec2 c = vec2(0.0 + 0.66*sin(time), 0.1 + 0.9*cos(time)); //propagation vector, sensitive\n    for (int i=0; i<200; i++)\n    {\n        p = vec2(p.x*p.x - p.y*p.y, (spaceWarp+1.0)*2.0*p.x*p.y)+c; //imaginary p, p'=p*p+c\n        d = length(p) + noiseShift;\n        n += digiZoom*0.0002/d;\n        if (d > edgeTrueness*200.0) break; //no convergence\n    }\n    n = fract(n+colorShiftSpeed*time); //shift colors\n    vec3 col = abs(sin(n*vec3(99,66,33))); //define colors\n    \n    // Desaturation & Brightness\n    float luma = dot(col,vec3(0.3, 0.6, 0.1));\n    col = brightness*(col + desat*(luma-col));\n\n    // Output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 1527]], "test": "untested"}
{"id": "mljGDc", "name": "foggy2hn", "author": "hneupert", "description": "dfdfsd", "tags": ["dsfsfs"], "likes": 1, "viewed": 177, "published": 3, "date": "1674061482", "time_retrieved": "2024-07-30T18:15:03.453025", "image_code": "const vec4 bgColor = vec4 (0.16, 0.41, 0.43, 1.0);\nconst vec4 frontColor = vec4 (0.77, 0.5, 0.44, 1.0);\nconst vec4 frontColor2 = vec4 (0.99, 0.1, 0.44, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale UV coords to account for rectangular window\n\tvec2 uv = vec2(fragCoord.x - 0.35 * iResolution.x, fragCoord.y) / iResolution.y;\n\tvec2 uv2 = vec2(fragCoord.x - 0.25 * iResolution.x, fragCoord.y) / iResolution.y;\n    \n    uv = 2.0 * uv - 0.5;\n    uv2 = 2.0 * uv2 - 0.5;\n    \n    // Double the speed\n    // float wave = sin(iTime * 2.0);\n    float wave = sin(0.6);\n    \n    // Scale to make the circle bigger so it reaches the far edges\n    float circle = (uv.x * uv.x + uv.y * uv.y) * 0.7;\n    \n    float circle2 = (uv2.x * uv2.x + uv2.y * uv2.y) * 0.7;\n    \n    //vec4 color1 = vec4(1.0, 0.0, 0.0, 1.0); // Red\n    //vec4 color2 = vec4(0.0, 0.0, 1.0, 1.0); // Blue\n    //vec4 color3 = vec4(0.0, 1.0, 0.0, 1.0); // Green\n    vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0); // Blue\n    \n    vec4 gradient1 = mix(frontColor, transparent, circle);\n    vec4 gradient2 = mix(frontColor2, transparent, circle2 + 0.1);\n    //vec4 gradient2 = mix(color3, gradient1, circle2);\n    vec4 gradientMix = mix(gradient2, gradient1, 0.6);\n    // Lerp the two\n\tfragColor = mix(gradientMix, bgColor, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 216, 273, 1312]], "test": "untested"}
{"id": "dl2GWc", "name": "BLF Pop! part II", "author": "iY0Yi", "description": "sdf sketch for cartoon \"pop!\" shape.\n\nthis time, popping in high viscocity medium.\nand more modern cartoonish style.\nprev: [url]https://www.shadertoy.com/view/ctj3zK[/url]", "tags": ["cartoon", "comic", "pop", "maptoy"], "likes": 24, "viewed": 492, "published": 3, "date": "1674058801", "time_retrieved": "2024-07-30T18:15:04.537126", "image_code": "/*\n  SDF is in BufB.\n*/\n#define getBuf(coord)\ttexelFetch(iChannel0, ivec2(coord), 0)\nvec3 getAlbedo(vec2 coord) { return unpackU4(getBuf(coord).x).rgb; }\nfloat getDiffuse(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).r); }\nfloat getDepth(vec2 coord) { return getBuf(coord).w; }\nvec3 getNormal(vec2 coord) { return normalize(unpackS3(getBuf(coord).z)); }\nvec2 clampCoord(vec2 coord) { return clamp(coord, vec2(0), iResolution.xy - .5); }\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2) {\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(1.5, 1., difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord) {\n    if(getDepth(coord)>.9)return .4;\n    \n\tconst vec3 offset = vec3(.5, -.5, 0)*2.;\n    #define NM(x)\tgetNormal(x)\n\tvec2 coords = coord;\n\tfloat edge = 1.;\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yx)), NM(clampCoord(coords + offset.xy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.xx)), NM(clampCoord(coords + offset.yy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yz)), NM(clampCoord(coords + offset.xz))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.zx)), NM(clampCoord(coords + offset.zy))));\n\treturn edge;\n}\n\n// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir) {\n\tfloat np, zp, pp, nz, pz, nn, zn, pn, gx, gy;\n    np = getDiffuse(clampCoord(fragCoord + (vec2(-1, 1) + dir)));\n    zp = getDiffuse(clampCoord(fragCoord + (vec2(0, 1) + dir)));\n    pp = getDiffuse(clampCoord(fragCoord + (vec2(1) + dir)));\n    nz = getDiffuse(clampCoord(fragCoord + (vec2(-1, 0) + dir)));\n    pz = getDiffuse(clampCoord(fragCoord + (vec2(1, 0) + dir)));\n    nn = getDiffuse(clampCoord(fragCoord + (vec2(-1) + dir)));\n    zn = getDiffuse(clampCoord(fragCoord + (vec2(0, -1) + dir)));\n    pn = getDiffuse(clampCoord(fragCoord + (vec2(1, -1) + dir)));\n\n\t// https://www.shadertoy.com/view/Wds3Rl\n\tgx = np * -3. + nz * -10. + nn * -3. + pp * 3. + pz * 10. + pn * 3.;\n\tgy = np * -3. + zp * -10. + pp * -3. + nn * 3. + zn * 10. + pn * 3.;\n\n\tvec2 G = vec2(gx, gy);\n\treturn vec4(G, length(G), atan(G.y, G.x));\n}\n\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx) {\n\tvec4 edge = sobel(fragCoord, vec2(0));\n\tvec2 dir = vec2(cos(-edge.w), sin(-edge.w));\n\tvec4 edgep = sobel(fragCoord, dir),\n\t     edgen = sobel(fragCoord, -dir);\n\tif (edge.z < edgep.z || edge.z < edgen.z) edge.z = 0.;\n\treturn vec2((edge.z > mn) ? edge.z : 0., (edge.z > mx) ? edge.z : 0.);\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx, bool isDiffuse) {\n\tvec2 np = hysteresisThr(fragCoord + vec2(-1, 1), mn, mx),\n\t     zp = hysteresisThr(fragCoord + vec2(0, 1), mn, mx),\n\t     pp = hysteresisThr(fragCoord + vec2(1), mn, mx),\n\t     nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx),\n\t     zz = hysteresisThr(fragCoord + vec2(0), mn, mx),\n\t     pz = hysteresisThr(fragCoord + vec2(1, 0), mn, mx),\n\t     nn = hysteresisThr(fragCoord + vec2(-1), mn, mx),\n\t     zn = hysteresisThr(fragCoord + vec2(0, -1), mn, mx),\n\t     pn = hysteresisThr(fragCoord + vec2(1, -1), mn, mx);\n\treturn 1. - min(1., step(1e-3, zz.x * 8.) * smoothstep(0., .5, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y) * 8.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec3 albedo = getAlbedo(fragCoord);\n    vec3 col = vec3(.9608, .9216, .8431);\n\n\tcol *= min(getOutline(fragCoord), cannyEdge(fragCoord, 0., 3.5, true));    \n\tcol *= sms(.4, .401, gnoise(fragCoord * .18+floor(iTime)) + gnoise(fragCoord * .15) + .3);\n\tcol += 1. - sms(.8, .801, (1. - gnoise(fragCoord * .05+floor(iTime)) * gnoise(fragCoord * .1)) + .7);\n\tfragColor = vec4(pow3(col, .45), 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n  Generals\n*/\n\n#define PI acos(-1.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n#define sat(x) clamp(x,0.,1.)\n#define sms(min,max,x) smoothstep(min,max,x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x > 0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x),sign1f(v.y))\n#define linearstep(edge0,edge1,x) min(max((x-(edge0))/((edge1)-(edge0)),0.),1.)\n#define ZERO min(0,iFrame)\nvec3 pow3(vec3 v,float power){return pow(v,vec3(power));}\n\n// \"hash11()\"-\"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n  st *= .75;\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0., 1., f);\n\n  vec2 rnd_x0y0 = u2s(hash22(i + vec2(0, 0)));\n  vec2 rnd_x1y0 = u2s(hash22(i + vec2(1, 0)));\n  vec2 rnd_x0y1 = u2s(hash22(i + vec2(0, 1)));\n  vec2 rnd_x1y1 = u2s(hash22(i + vec2(1, 1)));\n\n  vec2 dir_x0y0 = st - (i + vec2(0, 0));\n  vec2 dir_x1y0 = st - (i + vec2(1, 0));\n  vec2 dir_x0y1 = st - (i + vec2(0, 1));\n  vec2 dir_x1y1 = st - (i + vec2(1, 1));\n\n  float dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n  float res_x = mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y = mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y) * 2.);\n}\n\n// Data packer/unpacker\n// albedo,diffuse,specular,shadow,normal,and depth are rendered in raymarching pass,\n// and then,those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) *.997 * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n\nstruct RenderData {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n} renDat;\n\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n}ray;\n\nstruct Camera {\n  vec3 position;\n  vec3 direction;\n  vec3 target;\n  vec4 quaternion;\n  float fov;\n  float orthoDist;\n  float orthoScale;\n  vec3 up;\n};\n\nstruct Light {\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n\n#define MAT_VOID vec3(-1)\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 20.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-.25,2)\n#define CAM_DIST 10.\n#define CAM_INIT_SCALE 1.35\n#define TURN_TABLE_SPEED .25\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\nvec4 packRenderData(){\n  return vec4(packU4(vec4(renDat.albedo, renDat.shadow)), packS3((vec3(u2s(renDat.diffuse), renDat.specular, u2s(renDat.ao)))), packS3((renDat.normal)), renDat.depth);\n}\n\n#define render() \\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=ZERO; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=ZERO; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(sign(iMouse.z)>.0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nvec4 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    float t= march(ray.origin, ray.direction);\\\n    renDat.normal=vec3(0);\\\n    renDat.diffuse=1.;\\\n    renDat.albedo=vec3(.9);\\\n    renDat.depth=1.;\\\n    renDat.specular=0.;\\\n    renDat.shadow=1.;\\\n    renDat.ao=1.;\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        renDat.normal=n;\\\n        renDat.diffuse=dif;\\\n        renDat.albedo = vec3(1);\\\n        renDat.depth = 0.;\\\n    }\\\n    return packRenderData();\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    fragColor = renderRect(fragCoord);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n  Pop! SDF\n*/\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tfloat h=max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y-=clamp(p.y,-h*.5,h*.5);\n  return length(p)-r;\n}\n\n#define USE_DODECAHEDRON 0\n// precalculated vertices of dodecahedron\n// not so efficient than I had guessed.\n// http://japla.sakura.ne.jp/workshop/symposium/2009/nishikawa_dec2009_1.pdf\nconst vec3[20] VCOORD = vec3[](\n    vec3(1.7013,0,2.22703),\n    vec3(0.525731,1.61803,2.22703),\n    vec3(-1.37638,1,2.22703),\n    vec3(-1.37638,-1,2.22703),\n    vec3(0.525731,-1.61803,2.22703),\n    vec3(2.75276,0,0.525731),\n    vec3(0.850651,2.61803,0.525731),\n    vec3(-2.22703,1.61803,0.525731),\n    vec3(-2.22703,-1.61803,0.525731),\n    vec3(0.850651,-2.61803,0.525731),\n    vec3(2.22703,-1.61803,-0.525731),\n    vec3(2.22703,1.61803,-0.525731),\n    vec3(-0.850651,2.61803,-0.525731),\n    vec3(-2.75276,0,-0.525731),\n    vec3(-0.850651,-2.61803,-0.525731),\n    vec3(1.37638,-1,-2.22703),\n    vec3(1.37638,1,-2.22703),\n    vec3(-0.525731,1.61803,-2.22703),\n    vec3(-1.7013,0,-2.22703),\n    vec3(-0.525731,-1.61803,-2.22703)\n);\n\n// \"SphericalFibonacci\" by EvilRyu:\n// https://www.shadertoy.com/view/dsjXDm\nconst float gNum = 8.;\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n// unoptimized version\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j){\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - 2. * j / gNum);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat map(vec3 p){\n    // pop on every half sec.\n    float T = floor(iTime*7.);\n    \n    // random center\n    p+=(hash33(vec3(T))-.5)*.5;\n    \n    // deform space a little bit\n    p.y+=sin(p.x*1.+T)*.125;\n    p.y+=cos(p.z*1.-T)*.125;\n    \n    // center sphere\n    float d = length(p)-.4;\n    \n    for(float i = float(ZERO); i < gNum; i++){\n    \n        /*\n          main-pop\n        */\n        \n        // create vertices on sphere\n        #if USE_DODECAHEDRON\n        vec3 sp = VCOORD[int(i*2.)]*.33;\n        #else\n        vec3 sp = sphericalFibonacci(i+1.);\n        #endif\n        \n        // randomize cells\n        vec3 r = hash33(sp+T+i);\n        \n        // create cells\n        const float MAX_RADIUS = .5;\n        float distFromCenter = .2 + r.x*.15 + r.y*.15;\n        float cellRadius = max(.15,MAX_RADIUS-distFromCenter); // get more spherical look than just random.\n        cellRadius+=.2*r.z; // and break it just a little.\n        d = fOpUnionSmooth(length(p-sp*distFromCenter)-cellRadius, d, .01+distFromCenter*.05);\n        \n        /*\n          pop-out parts\n        */\n        \n        float dd = 1e3;\n        \n        //distance from center\n        float popOffset = max(.1,(2.*r.x*r.x-1.));\n        \n        if(r.x*r.y*r.z>.05){\n            vec3 q = p-sp*.8;\n            \n            // fit vectors of sub-pop to main-pop.\n            float yz = atan(sp.z,sp.y);\n            vec3 sq = sp;\n            R(sq.yz, yz);\n            float xy = atan(sq.y,sq.x)+PI*.5;\n            R(q.yz, yz);\n            R(q.xy, xy);\n            \n            // pop-out\n            q.y+=popOffset;\n            \n            R(q.xz, q.y*4.);\n            \n            // sub-pop at the tip\n            for(float j = float(ZERO); j < gNum; j+=1.){\n            \n                #if USE_DODECAHEDRON\n                vec3 ssp = VCOORD[int(j*2.)]*.33;\n                #else\n                vec3 ssp = sphericalFibonacci(j+1.);\n                #endif\n                \n                vec3 rr = hash33(ssp.xyz+T+vec2(i,j).xyx);\n                \n                if(int(j)%3<1){\n                    // sub-pop\n                    vec3 subPopCenter = q+vec3(0,.5*r.x,0);\n                    subPopCenter.z*=1.25;\n                    R(subPopCenter.yz, yz);\n                    R(subPopCenter.xy, xy);\n                    float subPopRadius = .01+.05*rr.x;\n                    dd = fOpUnionSmooth(length(subPopCenter-ssp*.3*rr) - subPopRadius, dd, .02*rr.y+.05);\n                }\n                else{\n                    // tiny splashing\n                    dd = fOpUnionSmooth(length(q+vec3((rr.x-.5)*.15,.2+(rr.y-.5)*.4,(rr.z-.5)*.15))-rr.y*.015, dd,.05);\n                }\n            }\n            // cylinders between main-pop and sub-pop\n            q.y-=popOffset*.5;\n            q.x = sabs(q.x, .015);\n            q.x-=.025*r.z;\n            float suji = sdCapsule(q, .5+popOffset, .02-.01*popOffset);\n            suji+=(.5+.5*sin(atan(q.z,q.x)*1.))*.02;\n            \n            // combine cylinders with sub-pop\n            dd = fOpUnionSmooth(dd, suji, .2);\n            \n            // combine it with main-pop\n            d = fOpUnionSmooth(dd, d,.1+.3*popOffset);\n        }\n        else{\n            // additional cells for main-pop\n            d = fOpUnionSmooth(length(p-sp*(.6+.2*r.z))-r.y*.05, d,.05);\n        }\n        \n    }\n    return d;\n}\n\nrender();\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2GWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 113, 113, 153], [154, 154, 184, 184, 227], [228, 228, 256, 256, 282], [283, 283, 311, 311, 358], [359, 359, 388, 388, 441], [443, 443, 481, 481, 566], [568, 568, 598, 598, 1173], [1175, 1273, 1311, 1311, 2131], [2133, 2133, 2189, 2189, 2480], [2482, 2482, 2551, 2551, 3197], [3199, 3199, 3251, 3251, 3643]], "test": "untested"}
{"id": "dl2GD3", "name": "Path Tracer v1.3", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it. Renders as much as possible in 1 frame (relative to 30 FPS)", "tags": ["raymarching", "clouds", "pathtracer"], "likes": 2, "viewed": 210, "published": 3, "date": "1674058140", "time_retrieved": "2024-07-30T18:15:05.470630", "image_code": "void mainImage(out vec4 C, in vec2 P) {\n    vec4 c = texelFetch(iChannel0,ivec2(P),0);\n    C = vec4(c.xyz/c.w,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "buffer_a_code": "#define MAX_STEPS 1000\n#define MAX_DIST 10.\n#define SURF_DIST .005\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.0,vec3(-100.,200.,-200.),vec3(1.,.95,.85),3.)\n\n#define _randsettings vec3(48973.,3942067.,539.)\n#define _fogB .01\n#define _fogA .01\n\n#define maxcomp(a) max(a.x,a.y)\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed += _randsettings.z;\n    return mod(_randsettings.y*(seed-_randsettings.z) + _randsettings.z,_randsettings.x)/_randsettings.x;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time+sin(time-c.x)*c.x-iResolution.y*(cos(c.y-time)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n/*\nfloat sdCross( vec3 p ) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.;\n}\n\n*/\n\n/////World\nvec2 map(in vec3 p,float ctime) {\n   vec3 q = p-vec3(0.,0.,1.5);\n   \n   float d0 = sdBox(q,v(0.),vec4(1.,1.,1.,0.));\n\n   float s = 1.;\n   for( int m=0; m<3; m++ ){\n      q += v(.05);\n      vec3 a = mod( q*s, 2. )-1.;\n      s *= 3.;\n      vec3 r = abs(1. - 3.*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.)/s;\n\n      d0 = max(d0,c);\n   }\n\n   \n   float d1 = sdSphere(p,vec4(0.,0.,6.,2.));\n   float d2 = sdSphere(p,vec4(-1.5,3.,6.,1.5));\n   float d3 = sdSphere(p,vec4(1.5,3.,6.,1.5));\n   \n   float d = min(d0,min(d1,min(d2,d3)));\n   d = d0;\n   \n   float mat;\n   mat = 0.;\n   if(d==d1) mat=1.;\n   if(d==d2||d==d3) mat=2.;\n   \n   return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float ctime) {\n    float d0 = map(p,ctime).x;\n    vec2 e = vec2(.001,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,ctime).x,\n    map(p-e.yxy,ctime).x,\n    map(p-e.yyx,ctime).x);\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime) {\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0),ctime);\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.283185;\n    float x = rand1()*2.-1.;\n    float z = rand1();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid setMat(vec3 color, float fp, float  g, float drr, out vec3 scol, out vec3 sdat) {\n    scol = color;\n    sdat = vec3(fp,g,drr);\n}\n\nvoid worldGetMat(float id, vec3 n, out vec3 col, out vec3 dat) {\n    if(id==0.) setMat(v(.2),2.,.3,.2,col,dat);\n    if(id==1.) setMat(vec3(.2,.15,.05),2.,.6,.8,col,dat);\n    if(id==2.) setMat(v(.03),7.,1.,.9,col,dat);\n}\n\nvec3 applyFog(in vec3 col, float dist, vec3 rd, vec3 ro, vec3 ld) {\n    float fa = (_fogA/_fogB) * exp(-ro.y*_fogB) * (1.-exp(-dist*rd.y*_fogB))/rd.y;\n    float sa = max(dot(rd,ld),0.);\n    vec3 fc = mix(vec3(.5,.6,.7),vec3(1.,.9,.7),pow(sa,8.));\n    return mix(col,fc,fa);\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, vec3 m) {\n    ro = p+n*OFFSET;\n    if(rand1() < m.z) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = m.y*sat(pow(1.-dot(-rd,n),m.x));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww,bool rt) {\n    time += 1.;\n    ro = vec3(cos(time*2.),sin(time)*.5+.5,sin(time*2.5));\n    if(!rt)ro = v(0.);\n    //ro.z -= 1.;\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    float td = 0.;\n    for(float i = 0.; i < 5.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        td += d;\n        if (hit == true) {\n            float tdReq = 10.;\n            tdReq += tdReq/(i+1.);\n            if(td > tdReq) break;\n            \n            vec3 n = getNormal(p,ctime);\n            vec3 ld = LIGHT.pos-p;\n            float dif = diffuse(p,ld,n,ctime);\n            ld = normalize(ld);\n            //float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n            vec3 sdat;\n            worldGetMat(mat,n,scol,sdat);\n            \n            vec3 diffuse = (dif*.5+.5)*LIGHT.str*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += applyFog(fcol * dcol,d,rd,ro,ld);\n            \n            \n            getBRDFRay(ro,rd,p,n,sdat);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime);\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if(iTime<.034) {\n        \n    \n        bool rt = false;\n    \n        float frame = floor(float(iFrame)/2.);\n        if(iFrame==0||rt) fragColor=vec4(0.);\n        initRand(float(iFrame),fragCoord);\n    \n        float frameTime = frame*(1./30.);\n    \n        float spp     = 8.;\n        float shutAp  = .2;\n        float blurAmt = .0015;\n        float fcsDist = .975;\n    \n        vec3 qcol = v(0.);\n        for(float i = 0.; i < spp; i++) {\n            vec2 of = -.5 + fract(rand2());\n            vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n            vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        \n            float ctime = (frameTime*1.)-3. + shutAp*(1./24.)*rand1();\n            getCam(ctime,ro,uu,vv,ww,rt); \n            vec3 er = normalize(vec3(p,1./tan(FOV*PI/360.)));\n            vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n            vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n            vec3 gd = normalize(er*fcsDist-go);\n            ro += go.x*uu+go.y*vv;\n            rd += gd.x*uu+gd.y*vv;\n        \n            //vec3 rdOrig = rd;\n            vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n            qcol += col;\n            //qcol += ro;\n        }\n        qcol /= spp;\n        fragColor += vec4(qcol,1.);\n    }\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2GD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 116]], "test": "untested"}
{"id": "mtj3D3", "name": "radial neighbors 3 ", "author": "jonasfrey", "description": "fun", "tags": ["radial"], "likes": 0, "viewed": 146, "published": 3, "date": "1674056622", "time_retrieved": "2024-07-30T18:15:06.297420", "image_code": "float f_n_rand(float n){\n    n = fract(n * .1031);\n    n *= n + 33.33;\n    n *= n + n;\n    return fract(n);\n}\n\nvec2 f_o_radial(vec2 o_fc_nor_off, float n_its, float n_it){\n    float n_rand = f_n_rand(n_it);//*sin(iTime)*0.01;\n    float n_tau = 6.283185;\n    float n_one_it_nor = 1./n_its;\n    float n_it_nor = n_it/ n_its;\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_ang_off = sin(n_dcntr*12.+iTime*4.)*n_one_it_nor*n_rand*5.;\n    n_ang_off = n_one_it_nor*0.5;\n    //n_ang_off = (sin(33.*n_dcntr+iTime+mod(n_it,2.)*sin(iTime)*(n_tau/2.))*0.5+0.5)*n_one_it_nor*2.;\n    //n_ang_off = 0.;\n    vec2 o = vec2(\n        cos(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr,\n        sin(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr\n    );\n    float n_len = length(o_fc_nor_off - o);\n    \n    float naa = (1./iResolution.x)*20.;\n    float n_t = iTime*1.;\n    float nss = 1.5;//(sin(n_t*10.*(sin(((n_it_new+n_t*0.1)/n_its)*n_tau))*2.+(n_it_new/n_its)*n_tau+n_dcntr*300.)*0.5+0.5)*0.75;\n    //n_len = smoothstep(nss,nss+naa, n_len); \n    n_len = n_len*(sin(iTime+n_it_nor*n_tau)*0.5+0.5)*10.;\n\n    \n    //n_len = n_len*1.5*(sin(n_dcntr*n_tau+iTime*2.+n_it_nor*20.)*0.5+0.5);\n    float n_len_nor = n_len/n_dcntr*n_its/4.;// i dont know if this is correct, probably not...\n    //n_len_nor = smoothstep(0.1, 0.11, n_len_nor);\n    //n_len_nor = n_len_nor*1.;//(sin(n_dcntr*10.+iTime*10.)*0.5+0.5)*n_len*30.;\n    \n    return vec2(n_len, n_len_nor);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    float n_t = iTime*0.5; \n    \n\n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    //o_fc_nor_off *= 2.;\n    float n_its = 9.;//(sin(iTime)*.5+0.5)*18.+2.;\n    float n_tau = 6.283185;\n    \n    float n_ang_nor = fract(atan(o_fc_nor_off.y, o_fc_nor_off.x)/n_tau);\n\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_one_it_nor = 1./n_its;\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n    float n_nei = floor((1.-n_dcntr)*n_its);\n    vec2 o_len_min = vec2(1.);\n    float n_it_min = 0.;\n    float n_len_prod = 1.;\n\n    for(float n = 0.; n < n_nei ; n+=1.){\n        float n_pm = n - floor(n_nei/2.);\n        float n_it_new = mod(n_it+n_pm, n_its);\n        vec2 o_len = f_o_radial(o_fc_nor_off, n_its, n_it_new);\n\n        if(o_len.x < o_len_min.x){\n            o_len_min = o_len;\n            n_it_min = n_it_new;\n        }\n        n_len_prod *= o_len.x;\n    }\n    \n    if(iMouse.z == 0.){\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n    \n    float n = o_len_min.y;\n    fragColor = vec4(n);\n    \n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n    \n        fragColor = (1.-n)*vec4(\n            f_n_rand(1.+n_it_min),\n            f_n_rand(1.+n_it_min*2.),\n            f_n_rand(1.+n_it_min*3.),\n            1.\n        );\n\n    }\n\n\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 109], [111, 111, 171, 171, 1441], [1442, 1442, 1499, 1499, 3274]], "test": "untested"}
{"id": "mt23D3", "name": "BraKi - Sobel - Drag Mouse L / R", "author": "braki", "description": "Sobel operator for webcam feed. Made this with help from GPT-3. Check out my gpt-3 discord bot on my github: https://github.com/Brakistad", "tags": ["sobel", "webcam", "cam", "machinevision", "vision", "variable", "gpt3", "sobeloperator", "gpt", "braki"], "likes": 0, "viewed": 269, "published": 3, "date": "1674054819", "time_retrieved": "2024-07-30T18:15:07.120220", "image_code": "#define KERNEL_SIZE 3\n\nuniform sampler2D inputTex;\nfloat threshold;\n\nvec4 convolution(vec2 uv) {\n    vec4 sum = vec4(0.0);\n    vec2 offset;\n    for (int x = -KERNEL_SIZE; x <= KERNEL_SIZE; x++) {\n        for (int y = -KERNEL_SIZE; y <= KERNEL_SIZE; y++) {\n            offset = vec2(x, y) / iResolution.xy;\n            vec4 texel = texture(inputTex, uv + offset);\n            if (x == -1 && y == -1) sum += texel * -1.0;\n            if (x == -1 && y == 0) sum += texel * -2.0;\n            if (x == -1 && y == 1) sum += texel * -1.0;\n            if (x == 0 && y == -1) sum += texel * -2.0;\n            if (x == 0 && y == 0) sum += texel * 4.0;\n            if (x == 0 && y == 1) sum += texel * 2.0;\n            if (x == 1 && y == -1) sum += texel * -1.0;\n            if (x == 1 && y == 0) sum += texel * 2.0;\n            if (x == 1 && y == 1) sum += texel * 1.0;\n        }\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = convolution(uv);\n    color = (color + 1.0) / 2.0;\n    threshold = iMouse.x / iResolution.x;\n    color.rgb = step(threshold, color.rgb);\n    fragColor = color;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt23D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 893], [895, 895, 952, 952, 1175]], "test": "untested"}
{"id": "dljGD3", "name": "Zozuar Flower Remix", "author": "drliquidglitch", "description": "simplified code + unfolding + rotation", "tags": ["flower", "remix"], "likes": 7, "viewed": 305, "published": 3, "date": "1674052357", "time_retrieved": "2024-07-30T18:15:07.871212", "image_code": "// Remix of MLA's remix of https://twitter.com/zozuar/status/1612919479582728232\n\nvec3 hsv(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  // x²(3-2x) = 3x²-2x³, f'(x) = 6x-6x² = 6x(1-x)\n  // f'(x) = 1-x², f = 0.5*(3.0*x-x³)\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nmat2 rotate2D(float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float time = iTime;\n  fragCoord.x += 140.0*cos(iTime) * sin(0.01 * fragCoord.y);\n  fragCoord.y += 88.88*cos(iTime) * sin(0.01 * fragCoord.x);\n  fragColor = vec4(0);\n  vec2 uv = 0.3*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 ro = vec3(0,0,-0.6);\n  vec3 rd = vec3(uv,1);\n  float t = 0.0;\n  vec2 m = 2.0*(iMouse.xy/iResolution.xy - 0.5); \n  for (float i = 0.0; i < 1e2; i++) {\n    vec3 p = ro+t*rd-i/2e5;\n    \n      p.z -= abs(sin(iTime*0.1));\n      p.yz *= rotate2D(sin(iTime*0.1));\n      p.xz *= rotate2D(cos(iTime*0.1));\n    \n    p.yz *= rotate2D(0.2);\n\n    float r = length(p);\n    float e = asin(-p.z/r)-0.1/r;  // DE\n    float rot = cos(iTime*0.2); // rotational symmetry\n    vec3 q = vec3(log(r)-time,e,rot*atan(p.x,p.y)); // log spherical?\n    for (float scale = 1.0; scale<1e2; scale += scale) {\n      e += pow(abs(dot(sin(q.yxz*scale),cos(q*scale))),0.2)/scale; // FBM?\n    }\n    t += e*r*0.1; // Attenuate DE\n    if (t > 50.0) break;\n    float k = max(e*r*1e4,0.7);\n    k = pow(k,0.4);\n    fragColor.rgb += hsv(0.4-.02/r,k,0.02/exp(k));\n  }\n  fragColor *= 2.0/(1.0+fragColor);\n  fragColor = pow(fragColor,vec4(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 119, 119, 389], [391, 391, 415, 415, 462], [463, 463, 515, 515, 1657]], "test": "untested"}
{"id": "Dt23Dc", "name": "radial neighbors 2", "author": "jonasfrey", "description": "fun", "tags": ["radial"], "likes": 4, "viewed": 141, "published": 3, "date": "1674046909", "time_retrieved": "2024-07-30T18:15:08.646140", "image_code": "float f_n_rand(float n){\n    n = fract(n * .1031);\n    n *= n + 33.33;\n    n *= n + n;\n    return fract(n);\n}\n\nvec2 f_o_radial(vec2 o_fc_nor_off, float n_its, float n_it){\n    float n_rand = f_n_rand(n_it);//*sin(iTime)*0.01;\n    float n_tau = 6.283185;\n    float n_one_it_nor = 1./n_its;\n    float n_it_nor = n_it/ n_its;\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_ang_off = sin(n_dcntr*12.+iTime*4.)*n_one_it_nor*n_rand*5.;\n    n_ang_off = n_one_it_nor*0.5;\n    n_ang_off = (sin(33.*n_dcntr+iTime+mod(n_it,2.)*sin(iTime)*(n_tau/2.))*0.5+0.5)*n_one_it_nor*2.;\n    //n_ang_off = 0.;\n    vec2 o = vec2(\n        cos(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr,\n        sin(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr\n    );\n    float n_len = length(o_fc_nor_off - o);\n    float n_len_nor = n_len/n_dcntr*n_its/4.;// i dont know if this is correct, probably not...\n    //n_len_nor = smoothstep(0.1, 0.11, n_len_nor);\n    return vec2(n_len, n_len_nor);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    float n_t = iTime*0.5; \n    \n\n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    //o_fc_nor_off *= 2.;\n    float n_its = 33.;//(sin(iTime)*.5+0.5)*18.+2.;\n    float n_tau = 6.283185;\n    \n    float n_ang_nor = fract(atan(o_fc_nor_off.y, o_fc_nor_off.x)/n_tau);\n\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_one_it_nor = 1./n_its;\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n    float n_nei = floor((1.-n_dcntr)*n_its);\n    vec2 o_len_min = vec2(1.);\n    float n_it_min = 0.;\n    float n_len_prod = 1.;\n    //n_nei = 3.;\n    for(float n = 0.; n < n_nei ; n+=1.){\n        float n_pm = n - floor(n_nei/2.);\n        float n_it_new = mod(n_it+n_pm, n_its);\n        vec2 o_len = f_o_radial(o_fc_nor_off, n_its, n_it_new);\n        if(o_len.x < o_len_min.x){\n            o_len_min = o_len;\n            n_it_min = n_it_new;\n        }\n        n_len_prod *= o_len.x;\n    }\n    \n    if(iMouse.z == 0.){\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n    \n    fragColor = vec4(o_len_min.y);\n    \n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n        fragColor = (1.-o_len_min.y)*vec4(\n            f_n_rand(n_it_min),\n            f_n_rand(n_it_min*2.),\n            f_n_rand(n_it_min*3.),\n            1.\n        );\n    }\n\n\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt23Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 109], [111, 111, 171, 171, 964], [965, 965, 1022, 1022, 2792]], "test": "untested"}
{"id": "cljGDc", "name": "why bent?", "author": "jonasfrey", "description": "shouldn't this be 4 straight gradients? it seems that they are slightly bent, but why?\nit becomes better visible when using smoothstep\nis this because my TAU is not accurate enough?", "tags": ["question"], "likes": 0, "viewed": 156, "published": 3, "date": "1674040532", "time_retrieved": "2024-07-30T18:15:09.511825", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    \n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    float n_its = 4.;\n    float n_tau = 6.283185307179586;\n    float n_ang_nor = fract(atan(o_lfc_nor_off.y, o_lfc_nor_off.x)/n_tau);\n\n    float n_dcntr = length(o_lfc_nor_off);\n\n    float n_one_it_nor = 1./n_its;\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n    float n_nei = floor((1.-n_dcntr)*n_its);\n    vec2 o_len_min = vec2(1.);\n    float n_it_min = 0.;\n   \n    float n_ang_off = 0.;//n_one_it_nor*0.5;\n    vec2 o = vec2(\n        cos(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr,\n        sin(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr\n    );\n    float n_len = length(o_fc_nor_off - o);\n    float n_len_nor = n_len/n_dcntr*n_its/4.;// i dont know if this is correct, probably not...\n    //n_len_nor = smoothstep(0.1, 0.11, n_len_nor);\n\n    if(iMouse.z == 0.){\n        float n_t = iTime*2.;\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n\n    fragColor = vec4(n_len);\n    \n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n        fragColor = vec4(smoothstep(0.1, 0.1, n_len));\n    \n    }\n    \n\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1654]], "test": "untested"}
{"id": "cl23Wc", "name": "radial normalized ", "author": "jonasfrey", "description": "my try to normalize the distance to a edge of a equaly segmented circle\nright: not normalized, left: normalized", "tags": ["radial"], "likes": 1, "viewed": 187, "published": 3, "date": "1674040167", "time_retrieved": "2024-07-30T18:15:10.379505", "image_code": "float f_n_rand(float n){\n    n = fract(n * .1031);\n    n *= n + 33.33;\n    n *= n + n;\n    return fract(n);\n}\nvec2 f_o_idx(vec2 o_trn, vec2 o_scl){\n    //calculate an index based on a o_trn translation and o_scl scale\n    float n_idx_flr = floor(o_trn.x)\n        + floor(o_trn.y) * floor(o_scl.x);\n    return vec2(\n        n_idx_flr, \n        n_idx_flr / (floor(o_scl.x)*floor(o_scl.y))\n    );\n}\nvec2 f_o_radial(vec2 o_fc_nor_off, float n_its, float n_it){\n    float n_rand = f_n_rand(n_it);//*sin(iTime)*0.01;\n    float n_tau = 6.283185;\n    float n_one_it_nor = 1./n_its;\n    float n_it_nor = n_it/ n_its;\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_ang_off = sin(n_dcntr*12.+iTime*4.)*n_one_it_nor*n_rand*5.;\n    n_ang_off = n_one_it_nor*0.5;\n    //n_ang_off = (sin(iTime+n_dcntr*20.)*0.5+0.5)*n_one_it_nor;\n    //n_ang_off = 0.;\n    vec2 o = vec2(\n        cos(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr,\n        sin(((n_it/ n_its)+n_ang_off) * n_tau) * n_dcntr\n    );\n    float n_len = length(o_fc_nor_off - o);\n    float n_len_nor = n_len/n_dcntr*n_its/4.;// i dont know if this is correct, probably not...\n    //n_len_nor = smoothstep(0.1, 0.11, n_len_nor);\n    return vec2(n_len, n_len_nor);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    float n_t = iTime*0.5; \n    \n\n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    //o_fc_nor_off *= 2.;\n    float n_its = (sin(iTime)*.5+0.5)*18.+2.;\n    float n_tau = 6.283185;\n    \n    float n_ang_nor = fract(atan(o_fc_nor_off.y, o_fc_nor_off.x)/n_tau);\n\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_one_it_nor = 1./n_its;\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n    float n_nei = floor((1.-n_dcntr)*n_its);\n    vec2 o_len_min = vec2(1.);\n    float n_it_min = 0.;\n    \n\n    for(float n = 0.; n < n_nei ; n+=1.){\n        float n_pm = n - floor(n_nei/2.);\n        float n_it_new = mod(n_it+n_pm, n_its);\n        vec2 o_len = f_o_radial(o_fc_nor_off, n_its, n_it_new);\n        if(o_len.x < o_len_min.x){\n            o_len_min = o_len;\n            n_it_min = n_it_new;\n        }\n    }\n    \n    if(iMouse.z == 0.){\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n    \n    fragColor = vec4(o_len_min.y);\n    \n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n        fragColor = vec4(o_len_min.x);\n    }\n\n\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl23Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 109], [110, 110, 147, 217, 395], [396, 396, 456, 456, 1213], [1214, 1214, 1271, 1271, 2833]], "test": "untested"}
{"id": "dlj3DK", "name": "3D-stone___", "author": "vec255", "description": "3D", "tags": ["3d"], "likes": 2, "viewed": 190, "published": 3, "date": "1674037065", "time_retrieved": "2024-07-30T18:15:11.196321", "image_code": "\nvoid mainImage( out vec4 r, in vec2 u )\n{\n\n    vec3 o =vec3(cos(iMouse.x/100.0)*800.0+500.0,sin(iMouse.x/100.0)*800.0+500.0,sin(iMouse.y/100.0)*500.0+900.0) ;\n    vec3 of =vec3(500.0,500.0,0.0) ;\n    vec3 or =of-o;\n    \n    or=normalize(or);\n    \n    vec3 ol = cross(or,vec3(0.0,0.0,-1.0));\n    vec3 ow = cross(or,ol);\n      ol=normalize(ol);\n      ow=normalize(ow);\n      \n      vec3 op = vec3(0.5,-0.5+(u/R).x,-R.y/R.x/2.0+(u/R).y);\n    vec3 to =(op.x)*or -(op.y)*ol +(op.z)*ow;\n  \n  \n\n    \n   \n   \n   float st =90.0;\n   \n  float h=100.0; \n   vec3 dt = to/abs(to.z);\n   \n   vec3 pt = dt*(o.z-h)+o;\n   vec2 uv=vec2(0.0,0.0);\n   float y =0.0;\n   for(int i =0;i<int(st);i++)\n   {\n      vec3 dp =dt*((float(i)/st)*h)+pt;\n      float d = T(mod(dp.xy,R)  ).z*h;\n      if(dp.z<d)\n      {\n      y=1.0;\n      uv=mod(dp.xy,R);\n      i=int(st);\n      \n      }\n   \n   }   \n   \n   \n  \n   \n   \n   \n   \n   \n    r = T(uv);\n  // r=vec4(uv,0.0,1.0);\n    if(y==0.0)r=vec4(0.0);\n  //  r=vec4(pt.z-1.0);\n vec2 vFontSize = vec2(8.0, 15.0)*2.0;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 r, in vec2 d )\n{\n    float x =(d.x-iResolution.x)/40.0;\n    float y =(d.y-iResolution.y)/40.0;\n    r = T(d);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R  iResolution.xy\n#define T(i)  texture(iChannel0,i/R)\nvec3 poi(vec3 q,vec3 w,vec3 e,vec3 r)\n{\nvec3 e1=e-q;\nvec3 r1=r-q;\nvec3 w1=w-q;\n\nfloat a=dot(e1,w1);\nfloat b=dot(r1,w1);\nfloat c=a/(a-b);\nreturn (r-e)*c+e;\n}\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clj3Wc", "name": "Grid inside a grid", "author": "mrange", "description": "CC0: Grid inside a grid\n On twitter there's a bunch of Grid inside a grid tweets today\n So I removed the coordinate transform from an earlier shader to fit in theme.\n", "tags": ["2d", "grid"], "likes": 23, "viewed": 340, "published": 3, "date": "1674036520", "time_retrieved": "2024-07-30T18:15:11.978231", "image_code": "// CC0: Grid inside a grid\n//  On twitter there's a bunch of Grid inside a grid tweets today\n//  So I removed the coordinate transform from an earlier shader to fit in theme.\n//  Best view on 4K + Fullscreen\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int II = 5;\nconst float ZZ = sqrt(2.0);\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash2(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec2 df(vec2 p, float aa, out float h, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 123.4;\n  \n  for (int i = 0; i < II; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash2(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d0 = box(pp, vec2(1.45*sz-aa))-0.05*sz;\n  float d1 = sqrt(sqrt(dot2(pp*pp)));\n  h = fract(r);\n  sc = sz;\n  return vec2(d0, d1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash1(float co) {\n  co += 1234.5;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 transform(vec2 p) {\n  vec2 op = p;\n  p *= ZZ;\n  const float period = 10.0;\n  float nt = TIME/period;\n  float n  = floor(nt);\n  n += 2.0;\n  float m  = fract(nt);\n  float h = hash1(n);\n  float f = floor(4.0*h);\n  float t = floor(4.0*hash1(n+1.0));;\n  float sp = max(abs(t-f), 1.0);\n  float flip = 0.025*sp;\n  m += 0.5*(fract(8677.0*h)-0.5);\n  p *= ROT(PI/2.0*mix(f, t, smoothstep(flip, -flip, cos(-0.0125*length(op)+TAU*m/(2.0)))));\n  p += 100.0*sin((vec2(1.0, 0.5)*0.125*TAU/100.0)*(TIME+100.0));\n  return p;\n}\n\nvec3 effect(vec2 p, vec2 np, vec2 pp) {\n  p = transform(p);\n  float aa = (ZZ*2.0)/RESOLUTION.y; \n\n  float h = 0.0;\n  float sc = 0.0;\n  vec2 d2 = df(p, aa, h, sc);\n\n  vec3 col = vec3(0.0);\n\n  vec3 rgb = ((2.0/3.0)*(cos(TAU*h+vec3(0.0, 1.0, 2.0))+vec3(1.0))-d2.y/(3.0*sc));\n  col = mix(col, rgb, smoothstep(aa, -aa, d2.x));\n  \n  const vec3 gcol1 = vec3(.5, 2.0, 3.0);\n  col += gcol1*tanh_approx(0.025*aa);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p+1.0/RESOLUTION.y;\n  vec3 col = effect(p, np, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clj3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 551, 578, 578, 654], [656, 742, 778, 778, 872], [874, 940, 962, 962, 1030], [1032, 1092, 1120, 1186, 1262], [1264, 1264, 1284, 1284, 1306], [1308, 1308, 1362, 1362, 1720], [1722, 1782, 1805, 1805, 1869], [1871, 1871, 1895, 1895, 2385], [2387, 2387, 2426, 2426, 2858], [2860, 2860, 2917, 2917, 3125]], "test": "untested"}
{"id": "DtjGW3", "name": "spectral tests", "author": "vinvinvin", "description": "playing with zucconi6 rainbow", "tags": ["rainbow"], "likes": 4, "viewed": 228, "published": 3, "date": "1674005551", "time_retrieved": "2024-07-30T18:15:12.837932", "image_code": "float saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(spectral_zucconi6((uv.x*300.0)+400.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 61], [62, 62, 86, 86, 143], [144, 144, 180, 180, 253], [255, 255, 289, 323, 791], [793, 793, 850, 900, 1032]], "test": "untested"}
{"id": "dlSGWc", "name": "radial neighbors", "author": "jonasfrey", "description": "radial", "tags": ["radial"], "likes": 2, "viewed": 156, "published": 3, "date": "1673997703", "time_retrieved": "2024-07-30T18:15:13.697634", "image_code": "float f_n_rand(float n){\n    n = fract(n * .1031);\n    n *= n + 33.33;\n    n *= n + n;\n    return fract(n);\n}\nvec2 f_o_idx(vec2 o_trn, vec2 o_scl){\n    //calculate an index based on a o_trn translation and o_scl scale\n    float n_idx_flr = floor(o_trn.x)\n        + floor(o_trn.y) * floor(o_scl.x);\n    return vec2(\n        n_idx_flr, \n        n_idx_flr / (floor(o_scl.x)*floor(o_scl.y))\n    );\n}\nfloat f_n_radial(vec2 o_fc_nor_off, float n_its, float n_it){\n    float n_rand = f_n_rand(n_it);//*sin(iTime)*0.01;\n    float n_tau = 6.2831;\n    float n_one_it_nor = 1./n_its;\n    float n_it_nor = n_it/ n_its;\n    float n_dcntr = length(o_fc_nor_off);\n    float n_ang_off = sin(n_dcntr*12.+iTime*4.)*n_one_it_nor*n_rand*5.;\n\n    vec2 o = vec2(\n        cos((n_it_nor+n_one_it_nor*0.5+n_ang_off) * n_tau) * n_dcntr,\n        sin((n_it_nor+n_one_it_nor*0.5+n_ang_off) * n_tau) * n_dcntr\n    );\n    \n    float n_len = length(o_fc_nor_off - o);\n    float n_thick = sin(n_dcntr*n_tau*10.+iTime)*(n_dcntr)*0.1;\n    float n_aa = (1./ iResolution.x)*200.;\n    float n_circumfence_one = (n_tau * iResolution.x);\n    float n_circumfence_cur = n_circumfence_one * n_dcntr;\n    float n_circumfence_cur_nor = n_circumfence_cur/n_circumfence_one;\n    float n_len_nor = n_len / (1./n_dcntr);\n    n_len_nor = n_len / 0.1;\n    \n    //n_len_nor *= sin(n_dcntr*10.+iTime+n_it_nor*2.);\n    //n_len = pow(n_len, 1./3.);\n    //n_len = 1.-n_len;\n    //n_len_nor = pow(n_len, 1./floor(n_rand*10.));//((sin(n_dcntr*10.+iTime)*0.5+0.5)*4.));\n    //n_len_nor = smoothstep(n_thick, n_thick+n_aa, n_len);\n    \n    return n_len_nor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    float n_t = iTime*0.5; \n    \n\n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    o_fc_nor_off *= 2.;\n    float n_its = 50.;\n    float n_tau = 6.283185;\n    \n    float n_ang_nor = fract(atan(o_fc_nor_off.y, o_fc_nor_off.x)/n_tau);\n\n    float n_dcntr = length(o_fc_nor_off);\n\n    float n_one_it_nor = 1./n_its;\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n    float n_nei = floor((1.-n_dcntr)*n_its);\n    float n_len_min = 1.;\n    float n_it_min = 0.;\n\n    for(float n = 0.; n < n_nei ; n+=1.){\n        float n_pm = n - floor(n_nei/2.);\n        float n_it_new = mod(n_it+n_pm, n_its);\n        float n_len = f_n_radial(o_fc_nor_off, n_its, n_it_new);\n        if(n_len < n_len_min){\n            n_len_min = n_len;\n            n_it_min = n_it_new;\n        }\n    }\n\n    if(iMouse.z == 0.){\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n    float n_rand = f_n_rand(n_it_min);\n    float n_rand1 = f_n_rand(n_rand);\n    float n_rand2 = f_n_rand(n_rand1);\n    //n_len = sin(n_len*0.5 * n_tau);\n    fragColor = vec4(n_len_min);\n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n        fragColor = (1.-fragColor)*vec4(\n            n_rand,\n            n_rand1 ,//* (n_it_min / n_its),\n            n_rand2 ,//* (n_it_min / n_its),\n            1.\n        );\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 109], [110, 110, 147, 217, 395], [396, 396, 457, 457, 1599], [1600, 1600, 1657, 1657, 3455]], "test": "untested"}
{"id": "DlB3WV", "name": "Cavernic", "author": "leon", "description": "rockin' and waterin'", "tags": ["tunnel", "water", "gyroid", "rock"], "likes": 86, "viewed": 1864, "published": 3, "date": "1673985996", "time_retrieved": "2024-07-30T18:15:14.542376", "image_code": "\n// Cavernic by Leon Denise 2023-01-17\n\n// a noise designed cavern with rock and water\n// (you can move camera with mouse)\n\n// globals\nfloat material, total;\n\n// snippets\n#define R iResolution\n#define N(x,y,z) normalize(vec3(x,y,z))\n#define ss(a,b,t) smoothstep(a,b,t)\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid(vec3 p) { return dot(sin(p), cos(p.yzx)); }\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// the noises\nfloat noise(inout vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a/=2.)\n    {\n        result += (gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise2(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 6.; ++i, a/=2.)\n    {\n        p.z += result * .5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise3(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 5.; ++i, a/=2.)\n    {\n        p.y += result * .5 + iTime * .05;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise4(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a/=2.)\n    {\n        p.y += result * .5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // recenter\n    p.x += .7;\n    \n    // travel\n    p.z -= iTime * .1;\n    \n    // save position for later\n    vec3 q = p;\n    \n    // global structure\n    p.z *= .5;\n    dist = noise(p);\n    \n    // subtract medium holes\n    float grid = .5;\n    float shape = length(repeat(p,grid))-grid/1.5;\n    shape = max(dist, abs(shape)-.1);\n    dist = max(dist, -abs(shape)*.5);\n    \n    // add intermediate structure\n    p = q*5.;\n    p.y *= .3;\n    dist += abs(noise(p))*.2;\n    \n    // add medium vertical details\n    p = q*10.;\n    p.y *= .2;\n    dist += pow(abs(noise(p)), 4.)*.1;\n    \n    // extra medium horizontal details\n    p = q;\n    p.y += cos(p.z*2.)*.05;\n    p.zx *= .3;\n    dist -= pow(abs(noise4(p*10.)), 4.)*.03;\n    \n    // add surface details\n    p = q*10.;\n    p.z *= 2.;\n    dist -= noise2(p) * .05;\n    \n    // inflate/deflate volume along z\n    dist -= .1;\n    dist -= .1 * sin(q.z);\n    \n    // inflate volume for the ceiling\n    dist -= max(0., p.y) * .02;\n    \n    // water\n    float water = q.y + 1. + noise3(q*2.) * .01;\n    \n    material = water < dist ? 1. : 0.;\n    dist = min(water, dist);\n    \n    return dist;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 noff = vec2(e,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 ray, float shade)\n{\n    // Inigo Quilez palette\n    // https://iquilezles.org/articles/palettes\n    vec3 color = .5+.5*cos(vec3(1,2,3)*5.9+normal.y-normal.z*.5-.5);\n    \n    // light\n    color *= dot(normal, -normalize(pos))*.5+.5;\n    \n    // shadow\n    color *= shade*shade;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R.xy)/R.y;\n    vec3 pos = vec3(0,0,0);\n    vec3 ray = normalize(vec3(p,-1.));\n    vec3 rng = hash(uvec3(fragCoord, 0.));\n    \n    // mouse camera\n    bool clicked = iMouse.x > 0.;\n    bool clicking = iMouse.z > 0.;\n    if (clicked)\n    {\n        vec2 mouse = iMouse.xy-abs(iMouse.zw)+R.xy/2.;\n        vec2 angle = vec2((2.*mouse-R.xy)/R.y);\n        ray.yz *= rot(angle.y);\n        ray.xz *= rot(angle.x);\n    }\n\n    // raymarch\n    total = 0.;\n    float shade = 0.;\n    for (shade = 1.; shade > 0.; shade -= 1./200.)\n    {\n        float dist = map(pos);\n        if (dist < .001*total || total > 20.) break;\n        dist *= 0.12 + 0.05*rng.z;\n        pos += ray * dist;\n        total += dist;\n    }\n\n    // coloring\n    if (shade > .01)\n    {\n        float mat = material;\n        vec3 normal = getNormal(pos, .003*total);\n        \n        // cavern\n        if (mat == 0.)\n        {\n            color = getColor(pos, normal, ray, shade);\n            \n            // water wet\n            float spec = pow(dot(-ray, normal)*.5+.5, 100.);\n            color += .2*spec*ss(.5,.0,pos.y+1.);\n        }\n        // water\n        else\n        {\n            // raymarch reflection\n            ray = reflect(ray, normal);\n            pos += ray *.05;\n            total = 0.;\n            for (shade = 1.; shade > 0.; shade -= 1./80.)\n            {\n                float dist = map(pos);\n                if (dist < .05*total || total > 20.) break;\n                dist *= 0.2;\n                pos += ray * dist;\n                total += dist;\n            }\n            \n            // color reflection\n            color = getColor(pos, getNormal(pos, .001), ray, shade);\n            color *= ss(1.,0.,pos.y+1.);\n            color *= ss(0.,0.6,(pos.y+1.2));\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlB3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 324, 324, 369], [370, 370, 392, 392, 426], [428, 545, 567, 567, 695], [697, 754, 776, 776, 893], [895, 909, 936, 936, 1078], [1080, 1080, 1102, 1102, 1275], [1277, 1277, 1299, 1299, 1486], [1488, 1488, 1510, 1510, 1683], [1685, 1685, 1704, 1704, 2871], [2873, 2923, 2958, 2958, 3081], [3083, 3083, 3144, 3220, 3426], [3428, 3428, 3485, 3485, 5402]], "test": "untested"}
{"id": "clB3D3", "name": "Not what I intended...", "author": "mrange", "description": "CC0: Not what I intended...\n Looked at some twitter art, attempted to recreate it.\n End up with something completely different.\n", "tags": ["raymarch", "reflections"], "likes": 25, "viewed": 399, "published": 3, "date": "1673984824", "time_retrieved": "2024-07-30T18:15:15.395096", "image_code": "// CC0: Not what I intended...\n//  Looked at some twitter art, attempted to recreate it.\n//  End up with something completely different.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  12.0\n#define MAX_RAY_MARCHES 90\n#define MAX_SHADOW_MARCHES 30\n#define NORM_OFF        0.00125\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define H13(n) fract((n)*vec3(12.9898,78.233,45.6114)*43758.5453123)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.025, 0.85, 0.5));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus_(vec3 p, vec2 t) {\n  p = p.yzx;\n  return torus(p, t);\n  \n}\n\nmat3 g_rot;\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat modRadial(inout vec2 p, float o, float m) {\n  float l = length(p);\n  float k = l;\n  l -= o;\n  float n = mod1(l, m);\n  \n  p = (l/k)*p;\n  return n;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25) - r; \n}\n\nfloat df(vec3 p) {\n  vec3 p1 = p;\n  p1 *= g_rot;\n  \n  float d0 = sphere4(p1, 2.0);\n  \n  float d1 = 1E4;\n  const float ff = 1.5-1.25;\n  float l = length(p);\n  for (float i = 0.0; i < 4.0; ++i) {\n    p1 *= g_rot;\n    vec3 pp = p1;\n    float nn = 0.0;\n    nn = modRadial(pp.xz, ff*0.5*i, ff*2.0);\n    float dd = torus_(pp, 1.0*ff*vec2(1.0, 0.1));\n    dd = max(dd, l-ff*(11.0+i*0.5));\n    d1 = pmin(d1, dd, 0.025);\n}\n\n  d0 = pmax(d0, -(d1-0.05), 0.25);\n\n  return d0;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\n// Found somewhere, unsure where\nfloat softShadow(vec3 ps, vec3 ld, float initt, float mint, float k) {\n  // Walks towards the light source and accumulates how much in shadow we are.\n  \n  float res = 1.0;\n  float t = initt;\n  for (int i=0; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    res = min(res, k*d/t);\n    if (res < TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += clamp(vec3(0.0025/abs(rd.y))*glowCol, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\n\nvec3 render1(vec3 ro, vec3 rd) {\n  float t = rayMarch(ro, rd);\n  vec3 col = render0(ro, rd);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float fre = 1.0+dot(rd, n);\n  fre *= fre;\n  float dif = dot(sunDir1, n); \n  if (t < MAX_RAY_LENGTH) {\n    float sd  = softShadow(p, r, 0.1, 0.025, 4.0);\n    sd = sqrt(sd);\n    col = vec3(0.0);\n    col += sunCol1*dif*dif*diffCol*0.25;\n    col += mix(0.333, 1.0, fre)*render0(p, r)*sd;\n  }\n\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float tm = TIME*0.5+10.0;\n  g_rot = rot_x(0.1*tm)*rot_y(0.23*tm)*rot_z(0.35*tm);\n  \n  vec3 ro = vec3(5.0, 1.0, 0.);\n  ro.xz *= ROT(-0.1*tm);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clB3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[708, 708, 730, 730, 876], [1566, 1666, 1685, 1685, 1772], [1774, 1881, 1907, 1907, 2091], [2093, 2179, 2218, 2218, 2343], [2345, 2440, 2469, 2469, 2534], [2536, 2536, 2566, 2566, 2606], [2621, 2621, 2642, 2642, 2742], [2744, 2744, 2765, 2765, 2865], [2867, 2867, 2888, 2888, 2991], [2993, 2993, 3042, 3042, 3146], [3148, 3248, 3287, 3287, 3372], [3374, 3467, 3509, 3509, 3556], [3558, 3676, 3703, 3703, 3779], [3781, 3781, 3820, 3820, 3849], [3851, 3851, 3883, 3883, 3931], [3933, 3933, 3951, 3951, 4397], [4399, 4399, 4422, 4422, 4630], [4632, 4632, 4666, 4666, 4998], [5000, 5033, 5103, 5182, 5437], [5439, 5439, 5471, 5471, 6125], [6128, 6128, 6160, 6160, 6598], [6600, 6600, 6621, 6621, 7086], [7088, 7088, 7145, 7145, 7421]], "test": "untested"}
{"id": "DtBGD3", "name": "Mandelbrot Julia Correlation", "author": "megamaz", "description": "Same thing as my last one, a simple shader that shows the correlation between the julia and mandelbrot set. Use mouse to view the different fractals.", "tags": ["fractal", "julia", "mandelbrot"], "likes": 2, "viewed": 162, "published": 3, "date": "1673983244", "time_retrieved": "2024-07-30T18:15:16.219890", "image_code": "float lerp(float factor, float a, float b) {\n    return a + (b - a) * factor;\n}\n\n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcMandelbrot(in vec2 fragCoord, in float iter)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float real = uv[0];\n    float imag = uv[1];\n    \n    float col = 0.0f;\n    \n    // rescale\n    real = lerp(uv[0], -2.2f, 1.0f);\n    imag = lerp(uv[1], -1.0f, 1.0f);\n    \n    float creal = real;\n    float cimag = imag;\n    \n    for(float i = 0.0f; i < iter; i++){\n        float realtemp = real;\n        real = (real*real)-(imag*imag)+creal;\n        imag = 2.0f*(realtemp*imag)+cimag;\n        if(sqrt((real*real) + (imag*imag)) > 4.0f){\n            col = i/iter;\n        }\n    }\n    // Output to screen\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    if(col != 0.0f) {\n        color = hsv2rgb(vec3(col*2.0f, 1.0f, 1.0f));\n    }\n    return color;\n}\n\nvec3 calcJulia(in vec2 fragCoord, in vec2 p, in float iter)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float real = uv[0];\n    float imag = uv[1];\n    \n    float col = 0.0f;\n    \n    // rescale\n    real = lerp(uv[0], -2.2f, 1.0f);\n    imag = lerp(uv[1], -1.0f, 1.0f);\n    \n    float creal = p[0];\n    float cimag = p[1];\n    \n    for(float i = 0.0f; i < iter; i++){\n        float realtemp = real;\n        real = (real*real)-(imag*imag)+creal;\n        imag = 2.0f*(realtemp*imag)+cimag;\n        if(sqrt((real*real) + (imag*imag)) > 4.0f){\n            col = i/iter;\n        }\n    }\n    // Output to screen\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    if(col != 0.0f) {\n        color = hsv2rgb(vec3(col*2.0f, 1.0f, 1.0f));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // VALUES YOU CAN PLAY AROUND WITH\n    float iter = 100.0f;\n    \n    // code\n    vec2 mousepos = vec2(lerp(iMouse[0]/iResolution[0], -2.2f, 1.0f), \n                         lerp(iMouse[1]/iResolution[1], -1.0f, 1.0f));\n                         \n    // this could be improved\n    // the mandelbrot set is recalculated every frame even though\n    // it really only needs to be calculated once\n    // I'm rather new to glsl, so I'm not sure how that can be done\n    vec3 mcolor = calcMandelbrot(fragCoord, iter);\n    vec3 jcolor = calcJulia(fragCoord, mousepos, iter);\n    \n    vec3 color = (mcolor + jcolor) / vec3(2.0f, 2.0f, 2.0f);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 79], [81, 133, 155, 155, 324], [326, 326, 381, 431, 1123], [1125, 1125, 1186, 1236, 1928], [1930, 1930, 1987, 2026, 2664]], "test": "untested"}
{"id": "clSGDV", "name": "Path Tracer v1.2", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it.", "tags": ["raymarching", "clouds", "pathtracer"], "likes": 0, "viewed": 203, "published": 3, "date": "1673972357", "time_retrieved": "2024-07-30T18:15:17.002797", "image_code": "void mainImage(out vec4 C, in vec2 P) {\n    vec4 c = texelFetch(iChannel0,ivec2(P),0);\n    C = vec4(c.xyz/c.w,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "buffer_a_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.0,vec3(0.,120.,-50.),vec3(1.,.95,.85),2.)\n\n#define _randsettings vec3(48973.,3942067.,539.)\n#define _fogB .01\n#define _fogA .01\n\n#define maxcomp(a) max(a.x,a.y)\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed += _randsettings.z;\n    return mod(_randsettings.y*(seed-_randsettings.z) + _randsettings.z,_randsettings.x)/_randsettings.x;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time+sin(time-c.x)*c.x-iResolution.y*(cos(c.y-time)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nfloat sdCross( vec3 p ) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.;\n}\n\n\n\n/////World\nvec2 map(in vec3 p,float ctime) {\n   vec3 q = (p-vec3(0.,.5,15.))/9.; // vec3(0.,.5,15.) // v(0.)\n   float d0 = sdBox(p,v(0.),vec4(1.,1.,1.,0.));\n\n   float s = 1.0;\n   for( int m=0; m<3; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d0 = max(d0,c);\n   }\n   \n   float d1 = sdSphere(p,vec4(0.,0.,6.,2.));\n   float d2 = sdSphere(p,vec4(-1.5,3.,6.,1.5));\n   float d3 = sdSphere(p,vec4(1.5,3.,6.,1.5));\n   \n   float d = min(d0,min(d1,min(d2,d3)));\n   d = d0;\n   \n   float mat;\n   mat = 0.;\n   if(d==d1) mat=1.;\n   if(d==d2||d==d3) mat=2.;\n   \n   return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float ctime) {\n    float d0 = map(p,ctime).x;\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,ctime).x,\n    map(p-e.yxy,ctime).x,\n    map(p-e.yyx,ctime).x);\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime) {\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0),ctime);\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.283185;\n    float x = rand1()*2.-1.;\n    float z = rand1();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid setMat(vec3 color, float fp, float  g, float drr, out vec3 scol, out vec3 sdat) {\n    scol = color;\n    sdat = vec3(fp,g,drr);\n}\n\nvoid worldGetMat(float id, vec3 n, out vec3 col, out vec3 dat) {\n    if(id==0.) setMat(v(.2),4.,.9,.7,col,dat);\n    if(id==1.) setMat(vec3(.2,.15,.05),2.,.6,.8,col,dat);\n    if(id==2.) setMat(v(.03),7.,1.,.9,col,dat);\n}\n\nvec3 applyFog(in vec3 col, float dist, vec3 rd, vec3 ro, vec3 ld) {\n    float fa = (_fogA/_fogB) * exp(-ro.y*_fogB) * (1.-exp(-dist*rd.y*_fogB))/rd.y;\n    float sa = max(dot(rd,ld),0.);\n    vec3 fc = mix(vec3(.5,.6,.7),vec3(1.,.9,.7),pow(sa,8.));\n    return mix(col,fc,fa);\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, vec3 m) {\n    ro = p+n*OFFSET;\n    if(rand1() < m.z) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = m.y*sat(pow(1.-dot(-rd,n),m.x));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww) {\n    time += 1.;\n    ro = vec3(cos(time*2.)*4.,sin(time)*2.+2.,sin(time*2.5)*4.);\n    //ro = v(0.);\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    float td = 0.;\n    for(float i = 0.; i < 4.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        td += d;\n        if (hit == true) {\n            float tdReq = 10.;\n            tdReq += tdReq/(i+1.);\n            if(td > tdReq) break;\n            \n            vec3 n = getNormal(p,ctime);\n            vec3 ld = LIGHT.pos-p;\n            float dif = diffuse(p,ld,n,ctime);\n            ld = normalize(ld);\n            //float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n            vec3 sdat;\n            worldGetMat(mat,n,scol,sdat);\n            \n            vec3 diffuse = (dif*.5+.5)*LIGHT.str*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += applyFog(fcol * dcol,d,rd,ro,ld);\n            \n            \n            getBRDFRay(ro,rd,p,n,sdat);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime);\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if(iFrame==0) fragColor=vec4(0.);\n    initRand(float(iFrame),fragCoord);\n    \n    float frameTime = float(iFrame)*(1./30.);\n    frameTime = 3.;\n    \n    float spp     = 1.;\n    float shutAp  = .6;\n    float blurAmt = .0015;\n    float fcsDist = 1.3;\n    bool  perfect = false; //Removes all blurring if true;\n    \n    if(perfect) {shutAp=.0;blurAmt=.0;fcsDist=100.;}\n    \n    vec3 qcol = v(0.);\n    for(float i = 0.; i < spp; i++) {\n        vec2 of = -.5 + fract(rand2());\n        if(perfect) of = vec2(0.);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        \n        float ctime = (frameTime*1.)-3. + shutAp*(1./24.)*rand1();\n        getCam(ctime,ro,uu,vv,ww); \n        vec3 er = normalize(vec3(p,1./tan(FOV*PI/360.)));\n        vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist-go);\n        ro += go.x*uu+go.y*vv;\n        rd += gd.x*uu+gd.y*vv;\n        \n        //vec3 rdOrig = rd;\n        vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n        qcol += col;\n        //qcol += ro;\n    }\n    qcol /= spp;\n    qcol = pow(qcol,v(1./2.2));\n    fragColor += vec4(qcol,1.);\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 116]], "test": "untested"}
{"id": "dlj3WK", "name": "testhueshift", "author": "Del", "description": "hue shifter", "tags": ["hue", "shift"], "likes": 0, "viewed": 178, "published": 3, "date": "1673968873", "time_retrieved": "2024-07-30T18:15:17.750797", "image_code": "// just a function to shift the hue of a texture...\n\n#define saturate(v) clamp(v,0.,1.)\n\nvec3 HueShift(vec3 source, float shift)\n{\n    // convert to HSV\n\tvec4 K = vec4(0.,-1./3.,2./3.,-1.);\n\tvec4 p = mix(vec4(source.bg ,K.wz),vec4(source.gb,K.xy ),step(source.b,source.g));\n\tvec4 q = mix(vec4(p.xyw,source.r ),vec4(source.r ,p.yzx),step(p.x,source.r));\n    float d = q.x-min(q.w,q.y);\n\tfloat e=1e-10;\n\tvec3 c = vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n    \n    // apply shift\n    c.x = fract(c.x+shift);\n\n    // convert to RGB\n\tK = vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 sourcecol = texture(iChannel0, uv).xyz;\n    \n    float shift = fract(iTime);\n    sourcecol = HueShift(sourcecol,shift);\n\n    fragColor = vec4(sourcecol,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 130, 152, 637], [640, 640, 697, 697, 908]], "test": "untested"}
{"id": "DtS3DV", "name": " neighbors 6", "author": "jonasfrey", "description": "more vonoroi", "tags": ["template", "vonoroi"], "likes": 1, "viewed": 179, "published": 3, "date": "1673957779", "time_retrieved": "2024-07-30T18:15:18.497800", "image_code": "float f_n_rand(float n){\n    n = fract(n * .1031);\n    n *= n + 33.33;\n    n *= n + n;\n    return fract(n);\n}\nvec2 f_o_idx(vec2 o_trn, vec2 o_scl){\n    //calculate an index based on a o_trn translation and o_scl scale\n    float n_idx_flr = floor(o_trn.x)\n        + floor(o_trn.y) * floor(o_scl.x);\n    return vec2(\n        n_idx_flr, \n        n_idx_flr / (floor(o_scl.x)*floor(o_scl.y))\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_dscl = 1.;// dscl down scale\n    vec2 o_lires = iResolution.xy * n_dscl;// lres low resolution\n    vec2 o_lfc = fragCoord.xy * n_dscl;\n    float n_t = iTime*0.5; \n    \n\n    float n_ratio_1to_iresx = 1./ o_lires.x;\n\n    vec2 o_lfc_nor = floor(o_lfc) / o_lires; // low frag coord normalized\n    vec2 o_lfc_nor_off = (floor(o_lfc)-0.5*o_lires.xy)/ o_lires.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_fc_nor_off = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 o_mo_nor_off = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n\n    if(iMouse.z == 0.){\n        o_mo_nor_off = vec2(sin(n_t), cos(n_t)*0.5+0.5);\n    }\n    o_lfc *= (o_mo_nor_off.y)*0.3;\n\n\n    vec2 o_scl_krn = vec2(5.); //krn kernel\n    \n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    \n    vec2 o_lfc_min, o_idx_min; \n    float n_rnd_min;\n    \n    float n_rnd_amp = floor(min(o_scl_krn.x, o_scl_krn.y)/2.);\n    \n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        \n        vec2 o_lfc_krn = o_lfc + vec2(n_x, n_y);\n        vec2 o_idx = f_o_idx(floor(o_lfc_krn), floor(o_lires));\n        float n_rand = f_n_rand(floor(o_idx.x));\n        vec2 o_a = fract(o_lfc);\n        vec2 o_b = vec2(n_x, n_y)+(n_rand-0.5)*n_rnd_amp;\n        float n_dist = length(o_a-o_b)*.5;\n        n_dist *= 1.+n_rand;\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            o_lfc_min = o_lfc_krn;\n            o_idx_min = o_idx;\n            n_rnd_min = n_rand;\n        }\n        //n_dmin = n_dist;\n    }\n\n    fragColor = vec4(n_dmin);\n    fragColor = sqrt(fragColor);\n    \n    if(o_fc_nor_off.x > o_mo_nor_off.x){\n        float n_rnd1 = f_n_rand(n_rnd_min*0.3111);\n        float n_rnd2 = f_n_rand(n_rnd1*0.1113);\n        fragColor = vec4(n_rnd_min, n_rnd1, n_rnd2, 1.);\n        \n        fragColor *= 1.-(float(n_rnd1>0.5)*n_dmin);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 109], [110, 110, 147, 217, 395]], "test": "untested"}
{"id": "DtBGWV", "name": "Candy Cavern Vomit", "author": "leon", "description": "a very natural mineral formation", "tags": ["rainbow", "gyroid"], "likes": 27, "viewed": 418, "published": 3, "date": "1673955683", "time_retrieved": "2024-07-30T18:15:19.374456", "image_code": "\n// Candy Cavern Vomit by Leon Denise 2023-01-17\n\n// an authentic rainbow unicorn pukey\n\n// snippets\n#define R iResolution\n#define N(x,y,z) normalize(vec3(x,y,z))\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid(vec3 p) { return dot(sin(p), cos(p.yzx)); }\nfloat noise(inout vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a/=2.)\n    {\n        p.z += result * .5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\n// noise pattern\nfloat pattern(vec2 p)\n{\n    vec3 pos = vec3(p, length(p));\n    float n = noise(pos);\n    pos = pos*10.;\n    pos.y *= .25;\n    n = n/2. + noise(pos)/2.;\n    n -= .05*sin((pos.y*1.+n*2.+iTime*.5)*10.);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = (2.*fragCoord-R.xy)/R.y;\n    float lp = length(p);\n\n    // act as a \"height map\"\n    float n = pattern(p);\n\n    // normal\n    float height = .05;\n    float range = 1.;\n    vec3 unit = vec3(range/R.xy, 0);\n    #define T(uv) pattern(uv)\n    vec3 normal = normalize(vec3(T(p+unit.xz)-T(p-unit.xz),\n                                 T(p-unit.zy)-T(p+unit.zy),\n                                 n * height));\n    \n    // light\n    color += ss(.2,1.,n)*vec3(.5)*pow(dot(normal,N(0,1,.5))*.5+.5, 5.);\n    \n    // color\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*4.9+p.y*2.+n*1.);\n    float mask = ss(.0,.4,n-.55);\n    color += tint*mask;\n    \n    // tunnel shade\n    color *= ss(-.4,1.,lp);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 218, 218, 263], [264, 264, 286, 286, 320], [321, 321, 348, 348, 521], [523, 540, 563, 563, 755], [757, 757, 814, 814, 1620]], "test": "untested"}
{"id": "DtSGWV", "name": "Tribal Ornament", "author": "leon", "description": "Tribalistic pixels", "tags": ["kif", "tribal"], "likes": 46, "viewed": 471, "published": 3, "date": "1673955098", "time_retrieved": "2024-07-30T18:15:20.135421", "image_code": "\n// Tribal Ornament by Leon Denise 2023-01-17\n\n// Buffer A is drawing a circle in motion on a kif\n// Image is doing basic lighting and color pattern\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 frame = texture(iChannel0, uv).rgb;\n    \n    // pattern\n    float pattern = sin(frame.r*12.+3.14);\n    color = vec3(1) * smoothstep(.0,.5,pattern);\n    \n    // normal\n    #define T(uv) texture(iChannel0, uv).r\n    vec3 unit = vec3(1./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 frame.r * frame.r));\n    \n    // light\n    color *= dot(normal, normalize(vec3(0,1,1)))*.5+.5;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Tribal Ornament by Leon Denise 2023-01-17\n\n// Buffer A is drawing a circle in motion on a kif\n// Image is doing basic lighting and color pattern\n\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float lp = length(p);\n    \n    // angle of rotation\n    float t = iTime * 0.5;\n    \n    // range\n    float r = .5 + .2 * sin(lp*1.-iTime);\n\n    // kaleidoscopic iterated function\n    float a = 1.;\n    const float count = 6.;\n    for (float i = 0.; i < count; ++i)\n    {\n        p.x = abs(p.x)-r*a;\n        p *= rot(t/a);\n        a /= 1.7;\n    }\n    \n    // shape\n    float thin = .04+.02*sin(iTime*4.+lp*10.);\n    vec3 color = vec3(smoothstep(thin,.0,length(p)));\n    \n    // fade \n    vec4 frame = texture(iChannel0, uv);\n    color = max(color, frame.rgb - .005);\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 207, 207, 824]], "test": "untested"}
{"id": "DtjGDK", "name": "Base -1+i  Twindragon Loop", "author": "mla", "description": "Looping version of Fabrice's original:\n\nbase -1+i  allows to represent the whole complex plane as a binary number set.\n[url]https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i[/url]\n", "tags": ["binary", "fractals", "loop", "complex", "twindragon", "arithmetics"], "likes": 17, "viewed": 240, "published": 3, "date": "1673948499", "time_retrieved": "2024-07-30T18:15:20.895389", "image_code": "// Base -1+i Twindragon Loop, mla, 2023.\n// Original: https://www.shadertoy.com/view/dtj3Wy by @FabriceNeyret2\n\n// base -1+i  allows to represent the whole complex plane as a binary number set.\n// TwinDragon of order n = all positions that can be represented with n bits.\n// cf https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i\n\n// Replaced complex div with a matrix multiplication - other matrices\n// are possible, though the ones I've tried have been rather ugly (and\n// break the looping).\n//\n// There is a relation between the magic numbers NCOLS and LOOP, but I'm\n// not sure what it is. Some interesting sample values shown.\n//\n// Loop goes faster (on Intel anyway) with explicit counter & bound.\n\nvoid mainImage(out vec4 O, vec2 I) {\n  int AA = 2, NBITS = 80;\n  int NCOLS = 8, LOOP = NCOLS/2;\n  //NCOLS = 2, LOOP = 4;\n  //NCOLS = 4, LOOP = 4;\n  //NCOLS = 16, LOOP = NCOLS/2;\n  //NCOLS = 3, LOOP = NCOLS*4;\n  //NCOLS = 5, LOOP = NCOLS*4;\n  mat2 A = 0.5*mat2(-1,-1,1,-1); // NB: det(a) = 0.5 < 1\n  vec3 basecol = vec3(1,1,0.5);\n  I -= 0.5*iResolution.xy; // Centering\n  O = vec4(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 p = I + vec2(i,j)/float(AA);\n      p *= rotate(0.1*iTime); // Rotate a little\n      p *= exp2(mod(-0.75*iTime,float(LOOP))); // Exponential zoom\n      int i = 0;\n      for (i = 0; i < NBITS; i++) {\n        assert(i < NBITS-1);\n        p = floor(A*p); // Integral division by -1+i\n        if (p == vec2(0)) break;\n      }\n      O.rgb += float(i%NCOLS)/float(NCOLS-1)*basecol;\n      //O.rgb += h2rgb(float(i%NCOLS)/float(NCOLS));\n    }\n  }\n  O /= float(AA*AA);\n  O = pow(O,vec4(0.4545));\n  if (alert) O.r = 1.0;\n}", "image_inputs": [], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nmat2 rotate(float t) {\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[729, 729, 765, 765, 1703]], "test": "untested"}
{"id": "Dl2GDK", "name": "rounded rect light beads", "author": "vinvinvin", "description": "SIGNED distance to a rounded box. Video tutorials explaining how it works: [url]https://www.youtube.com/watch?v=62-pRVZuS5c[/url] and [url]https://www.youtube.com/watch?v=s5NGeUV2EyU[/url]", "tags": ["2d", "distance", "signed"], "likes": 0, "viewed": 183, "published": 3, "date": "1673946890", "time_retrieved": "2024-07-30T18:15:21.741128", "image_code": "// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Signed distance to a 2D rounded box. Tutorials explaining\n// how it works: \n//\n// https://www.youtube.com/watch?v=62-pRVZuS5c\n// https://www.youtube.com/watch?v=s5NGeUV2EyU\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 cp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 cp = vec2(2.0*fragCoord.x-(iMouse.x*2.0), 2.0*fragCoord.y-(iMouse.y*2.0))/iResolution.y;\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat rbd = sdRoundBox( p, vec2(1.2, 0.7), vec4(0.06) );\n    float cd = sdCircle( cp, 0.02 );\n    \n    float boxCircleD = 1.0-abs(sdRoundBox( p - cp, vec2(1.2, 0.7), vec4(0.06)));\n    \n    vec3 bead = vec3(1.0, 0.8, 0.8);\n    bead *= (pow((1.0-(abs(rbd) * 1.0)), 100.0));\n    bead *= pow(max(1.0 - (cd * 0.8), 0.0), 100.0);\n    bead *= 0.5;\n    \n    vec3 redOutline = vec3(1.0, 0.05, 0.1);\n    // rounded box component\n    redOutline *= (pow((1.0-(abs(rbd*0.8))), 100.0));\n    // circle component\n    redOutline *= pow(max(1.0-cd*0.5, 0.0), 10.0);\n    // redOutline *= 2.0;\n    redOutline *= 0.5;\n    \n    vec3 whiteOutline = vec3(1.0, 0.7, 0.8);\n    // rounded box component\n    // TODO: figure out why this makes a box in the center\n    whiteOutline *= (pow((1.0-(abs(rbd*0.9))), 250.0));\n    // circle component\n    whiteOutline *= pow(max(1.0-(cd * 0.4), 0.0), 6.0);\n    whiteOutline *= 0.8;\n    // whiteOutline *= 3.0;\n    // col = vec3(pow(max(1.0-cd, 0.0), 2.0));\n    \n    vec3 haloColor = vec3(0.8, 0.0, 0.1);\n    vec3 haloFalloff = vec3(0.0);\n    haloFalloff += haloColor * pow(max(1.0-(cd*6.0), 0.0), 4.0) * 0.25;\n    haloFalloff += haloColor * pow(max(1.0-(cd*4.0), 0.0), 2.0) * 0.1;\n    haloFalloff += haloColor * pow(max(1.0-(cd*0.8), 0.0), 2.0) * 0.2;\n    haloFalloff += haloColor * pow(max(1.0-(cd*0.3), 0.0), 2.0) * 0.1;\n    \n    vec3 col = vec3(0.0);\n    \n    // col = mix(col, vec3(0.2, 0.0, 0.0), 1.0-smoothstep(0.0,0.01,abs(cd)) );\n    col += redOutline;\n    col += haloFalloff * pow(boxCircleD, 100.0);\n    col += whiteOutline * pow(boxCircleD, 20.0);\n    // col = mix(col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.0,0.005,abs(rbd)));\n    col += bead * pow(boxCircleD, 100.0);\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GDK.jpg", "access": "api", "license": "mit", "functions": [[1450, 1604, 1658, 1658, 1815], [1817, 1817, 1859, 1859, 1885], [1887, 1887, 1944, 2007, 3948]], "test": "untested"}
{"id": "ct2GDK", "name": "Example for Windows Terminal", "author": "mrange", "description": "CC0: Simple gradient background for Windows Terminal\nhttps://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d"], "likes": 2, "viewed": 338, "published": 3, "date": "1673945675", "time_retrieved": "2024-07-30T18:15:22.577891", "image_code": "// CC0: Simple gradient background for Windows Terminal\n//  https://mrange.github.io/windows-terminal-shader-gallery/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n\n  vec2 p = -1.0 + 2.0*q;\n\n  // Compute a simple gradient\n  vec3 col = vec3(.0, q).zxy;\n  // Reduce intensity of gradient more to the corners\n  col *= 0.71*smoothstep(1.75, 0., length(p));\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2GDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 176, 176, 434]], "test": "untested"}
{"id": "Dt23WK", "name": "Square tile mosaic 2", "author": "jarble", "description": "A mosaic pattern made of square and triangular tiles.", "tags": ["music", "mosaic"], "likes": 2, "viewed": 133, "published": 3, "date": "1673940670", "time_retrieved": "2024-07-30T18:15:23.331875", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y*4.;\n    uv.y += iTime;\n    vec3 col = vec3(0);\n    vec2 offset = vec2(0.),\n    uv1 = uv;\n    for(int k = 0; k < 6; k++){\n        //uv.y += abs(fmod(uv.y+floor(uv1.y*16.)/16.,16.))/16.;\n        uv =\n            abs(fract(uv.yx+(fract(.5-(floor(uv.y)-floor(uv1.y*8.))/8.)))-.5)\n        ;\n        if(uv.y < uv.x) col =\n            vec3(col.yz,abs(max(uv.x,uv.y)))\n        ;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "\n\nvec2 mainSound(int samp, float time){\n //time /= 1.5;\n float s1 =\n      8.;\n  \n  time += floor(time*s1)/s1;\n  \n  float\n  m4 =\n      sqmod(time,2.)\n  ,\n  s2 =\n      8.\n      //4.*(1.+m4)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      sqmod(floor(t*s1)/s1,s2-m4)\n      //fmod(floor(t/(1.+m4))*floor(t*s1),s2)\n      //fmod(floor(t/s1)*(floor(t*s1)+floor(t)),s2)\n  ,\n  m3 =\n      sqmod(floor(t*s1+m1),s2-m1);\n  t /=\n      (1.+sqmod(t/s1,2.))\n      //(1.+fmod(t/(1.+m1),2.))\n  ;\n  t *=\n      s1*s1\n  ;\n  //t /= (1.+m4);\n\n    float m2 =\n      1. + sqmod(t/s1,s1)\n  ;\n  \n  float a=sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = pow(2.,(m3+m2)/5.+6.5);\n\n  return vec2(fract(time*nb*.998)\n   ,fract(time*nb))*a;\n\n}", "sound_inputs": [], "common_code": "#define fmod(x,y) mod(floor(x),y)\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)/4.,y*y)/y)\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\n#define floor2(x) floor(x)*pow(floor(mod((x)/4.,3.)),2.)", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt23WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 551]], "test": "untested"}
{"id": "mlS3DV", "name": "kifs walls ", "author": "dsa8", "description": "Extruded 2D kifs on a wobbly refractive plane, a bit untamed and rough around the edges but I like the look :)\n\nTips and criticism more than welcome! (particularly when it comes to performance, I'm guessing it could be a lot better)", "tags": ["raymarching", "refraction", "kifs"], "likes": 85, "viewed": 7398, "published": 3, "date": "1673932269", "time_retrieved": "2024-07-30T18:15:24.192574", "image_code": "\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n\nmat2 rot(float a) {\n    float ca =cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n//------------------\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// https://www.shadertoy.com/view/wlyBWm\nvec2 smoothrepeat_asin_sin(vec2 p,float smooth_size,float size){\n    p/=size;\n    p=asin(sin(p)*(1.0-smooth_size));\n    return p*size;\n}\n\n//--------------\n\n// don't remember were i took this from but I think I started from here \n// https://www.researchgate.net/publication/300124211_Interactive_Procedural_Building_Generation_Using_Kaleidoscopic_Iterated_Function_Systems\nvec2 dKifs(vec2 p, vec2 c, float s, float t1, float t2) {\n    float r2 = p.x*p.x+p.y*p.y;\n    float i;\n    for (i=0.;i<6. && r2 < 1000.; i++) {\n        p *= rot(t1);\n        \n        p = abs(p);\n        if (p.x - p.y < 0.) {\n            float x1=p.y;\n            p.y = p.x;\n            p.x = x1;\n        }\n        \n        p *= rot(t2);\n        \n        p.x = s*p.x-c.x*(s-1.);\n        p.y=s*p.y;\n        if(p.y>0.5*c.y*(s-1.)) p.y-=c.y*(s-1.);\n      \n        p.y += .1 *s;\n        p.y*=p.y*.45;\n        p.x -= .2 *s;\n        \n        r2 = p.x*p.x+p.y*p.y;\n    }\n    \n    return vec2( (sqrt(r2)-2.)*pow(s,-i), i);\n}\n\nvec3 camPos;\nvec2 map( in vec3 p ) {\n    float d = FLT_MAX;\n    float mat = -1.;\n    \n    vec2 f;\n    // extruded fractal\n    {\n    vec3 q = p;\n    q.xy = smoothrepeat_asin_sin(p.xy,.04, 4.0);\n    float c = 15.;\n    float zId = ceil((q.z+.5*c) / c);\n    q.z = mod(q.z+.5*c, c)-.5*c;\n\n    float r1 = 0.2 + hash(zId*1234.)*.75 + smoothstep(0., .2, sin((camPos.z+1.5)*PI / 15.)) *.15 ;\n    float r2 = mix(0.2, 0.5, hash(zId*4312.));\n    f = dKifs( q.xy*.2, vec2(1.), 3., r1, r2);\n    \n    if ( f.x < d ) mat = 0.;\n    d = min(d,opExtrussion( q, f.x, .5) ) - 0.002;\n    }\n\n    \n    // plane\n    {\n    vec3 q = p;\n    float c = 15.;\n    q.z = mod(q.z+.5*c, c)-.5*c;\n    \n    q.xy *= .5;\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*.5*(cos(6.2831*q.x+iTime*5.) + cos(6.2831*q.y+iTime*2.));;\n\t\ts *= 0.5 + 0.1*t;\n        q.xy = 0.97*mat2(1.6,-1.2,1.2,1.6)*q.xy + (t-0.5)*0.2;\n\t}\n    \n    float dP = abs(q.z  - 0.01 - (cos(q.x*4.+iTime)*.5+.5)*.02 );\n    if (dP-.3 < d) mat = 1.;\n    d = sminCubic( d,  dP, .6 );\n    }\n    \n    return vec2(d, mat);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n \n// https://www.shadertoy.com/view/MdS3Rw\nfloat ao( vec3 v, vec3 n ) {\n\tfloat sum = 0.0;\n\tfloat att = 3.0;\n    float aoStep = .1;\n    float aoScale = .3;\n\tfloat len = aoStep;\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tsum += ( len - map( v + n * len ).x ) * att;\n\t\t\n\t\tlen += aoStep;\n\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn max( 1.0 - sum * aoScale, 0.0 );\n}\n\n// https://www.shadertoy.com/view/flGyDd\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\nvec3 aces_approx(vec3 v)\n{\n    v = max(v, 0.0);\n    v *= 0.6f;\n    float a = 2.51f;\n    a = 2.;\n    float b = 0.03f;\n    float c = 2.43f;\n    c = 1.;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 col) {\n    col -= .1;\n    col += col*col*.4;\n    col = aces_approx(col);\n    col = sRGB(col);\n    return col;\n}\n\nvec2 march(vec3 ro, vec3 rd, float tmax, inout float t, int iMax, float e, float hStep) {\n    vec2 h;\n    for( int i=0; i<iMax; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        h = map(pos);\n        if( h.x<e || t>tmax ) break;\n        t += h.x*hStep;\n    }\n    return h;\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 ro, vec3 rd, float t) {\n    vec3 col = vec3(0.15,0.25,0.4);\n    float m = mod(pos.z, 15.);\n    col *= pow(1.-mod(pos.z, 15.)/15., 80.)*6.5;\n    \n    float fractal = 1.-step(m, .1);\n    vec3 lDir = vec3(0.57703);\n    lDir = normalize(vec3(0.3, .6, .6));\n    float dif = clamp( dot(nor, lDir), 0.0, 1.0 );\n    vec3  ref   = reflect(rd, nor);\n    float spec  = max(dot(ref, lDir), 0.0);\n    col += (spec*.5 + dif * vec3(.1, .15, .25)*.5) * fractal *.8;\n    \n    float plane = step(m, .3);\n    col = clamp(col + -.2 * plane, 0., 1.);\n    col += plane * col * col * .7;\n    \n    return col;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0., 0., 15. - iTime*2.5);\n    camPos = ro;\n    vec3 ta = vec3( 0.0, 0., 0.0 - iTime*2.5 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        rd.xy *= rot(sin(iTime*PI/7.5)*.4);\n        rd.xz *= rot(sin(iTime*PI/7.5 * 2.)*.15);\n        \n        // raymarch\n        float tmax = 40.0;\n        float t = 0.0;\n        vec2 h = march(ro, rd, tmax, t, 40, 0.005, .8);\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            col = shade(pos, nor, ro, rd, t);\n\n            float ao = clamp(pow(ao(pos,nor),5.)*3., 0., 1.);\n            col = vec3(ao) * col;\n            // thin layer transparent material or something \n            if ( h.y == 1.) {\n               vec3 ro2 = pos - nor * .5;\n               // interpolation suggest by alro ty :)\n               float ior = mix(1.2, 1., smoothstep(0.9, 1., cos(ro.z*PI / 7.5 - .3) ) );\n               vec3 rd2 = refract(rd, nor, ior);\n               // raymarch again\n               tmax = 60.;\n               t = 0.;\n               vec2 h2 = march(ro2, rd2, tmax, t, 50, 0.01, 1.);\n               // shade again\n               vec3 col2 = vec3(0.);\n               if (t<tmax) {\n                   vec3 pos2 = ro2 + t*rd2;\n                   vec3 nor2 = calcNormal(pos2);\n                   col2 = shade(pos2, nor2, ro2, rd2, t);\n               }\n               col = mix(col, col2, .5);\n            }\n        }\n        \n        col = postProcess(col); // doing it here reduces some artifacts\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    //tot = postProcess(tot);\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 100, 121, 121, 188], [191, 191, 210, 210, 286], [310, 310, 356, 356, 442], [444, 444, 503, 503, 599], [601, 642, 706, 706, 778], [798, 1014, 1071, 1071, 1629], [1644, 1644, 1667, 1667, 2707], [2709, 2755, 2787, 2787, 3034], [3037, 3078, 3106, 3106, 3375], [3377, 3518, 3537, 3537, 3624], [3626, 3626, 3652, 3652, 3876], [3878, 3878, 3906, 3906, 4011], [4013, 4013, 4102, 4102, 4287], [4289, 4289, 4348, 4348, 4912]], "test": "untested"}
{"id": "mlBGWV", "name": "Composition", "author": "wyatt", "description": "Composition runs a little longer than the Shadertoy sound buffer, the whole song is here [url]https://wyattflanders.com/WyattSong.m4a[/url]", "tags": ["sound"], "likes": 43, "viewed": 640, "published": 3, "date": "1673921106", "time_retrieved": "2024-07-30T18:15:25.680595", "image_code": "Main \n{\n    vec4 f = A(U);\n    Q = 1.-2.*f.wwww*(.5+.5*sin(6.2*f.z+vec4(1,2,3,4)));\n    Q *= 1.-smoothstep(.1,0.,f.w)*A(U+vec2(6)).w;\n    Q *= 1.-(exp(-.1*U.x)+exp(-.1*(R.x-U.x))+exp(-.1*U.y)+exp(-.1*(R.y-U.y)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi2 6.28318530718\n\t\t#define e(t,a,b) vec2(sin(pi2*(b)*(t)),sin(pi2*(b)*(t)))\n\t\t#define sin(a) sin(fract((a)/pi2)*pi2) \n\t\tfloat note (float t, float n) {\n\t\t\tfloat f = 261.626*pow(2.,n/12.);\n\t\t\treturn sin(pi2*f*t);\n\t\t}\n\t\tvec2 mainSound( int samp, float time )\n\t\t{\n\t\t\tvec2 o = vec2(0);\n            time *= 2.;\n\t\t\tfloat t = time;\n\t\tif (time < 60.) {\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-10.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .25;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += .5*note(t+sin(t*250.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*250.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-5.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-12.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.5;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 2.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .3*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .2*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .3*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .2*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 2.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += note(t+sin(t*550.)/550.*sin(t*5.)/5.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 2.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t    t -= 1.;\n\t\t}\n\t\tif (time > 47.&&time < 90.) {\n\t\t\tt = time-47.;\n\t\t\tt -= 1.;\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 2.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-2.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .2*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .3*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .2*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .3*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .2*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to +=  .1*note(t+sin(t*550.)/250.*sin(t*25.)/25.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 2.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 2.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 2.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 4.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 85.&&time < 130.) {\n\t\t\tt = time - 85.;\n\t\t\tfor (float i = 0.; i < 4.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 4.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tfor (float i = 0.; i < 4.; i++ ) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 123.&& time < 160.) {\n\t\t\tt = time - 123.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.75*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.;i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/35.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/30.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 156. && time < 215.) {\n\t\t\tt = time -156.;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/30.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/5.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .125;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/25.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/39.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 1.5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t \tt -= .5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/35.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/30.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt -= .5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\tt -= .5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/35.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/30.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t \tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 1.5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\tt -= .5;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/15.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 210. && time < 250.) {\n\t\t\tt = time - 210.;\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t}\n\t\t\tt += 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tt -= .25;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tt -= .25;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t}\n\t\tif (time > 246. && time < 290.) {\n\t\t\tt = time - 246.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt += .75;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt -= .5;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt += 1.5;\n\t\t\tfor (float i = 0.; i < 4.; i++) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\n\t\t\t}\n\t\t}\n\t\tif (time > 282. && time < 305.) {\n\t\t\tt = time - 282.;\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 2.5;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt += .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt += .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-35.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt += .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-35.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 302. && time < 340.) {\n\t\t\tt = time - 302.;\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 2.5;\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 2.5;\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 2.5;\n\t\t\tfor (float i = 0.; i < 3.; i++ ) {\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/40.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 330. && time < 360.) {\n\t\t\tt = time - 330.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.1*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .25;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t\tt += 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t    t -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt += 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t    t -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= 1.;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tt -= .5;\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt  -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt  -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 355. && time < 390.) {\n\t\t\tt = time - 355.;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.08*t);\n\t\t\tt -= 1.;\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t}\n\t\t\tt += 6.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 375. && time < 405.) {\n\t\t\tt = time - 375.;\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\tt -= .5;\n\t\t\t}\n\t\t\tt += 2.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .25;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t}\n\t\t\tt += 3.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-3.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t}\n\t\t\tt += 4.;\n\t\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t\tt -= 1.;\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t\t\to += .125*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-2.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t}\n\t\t}\n\t\tif (time > 395.) {\n\t\t\tt = time - 395.;\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tt -= .25;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tt -= .5;\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tt -= 1.;\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-25.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 1.; i++) {\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-15.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 1.; i++) {\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-7.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t}\n\t\t\tfor (float i = 0.; i < 1.; i++) {\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt -= 1.;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-5.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-35.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-20.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\tt -= .5;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-45.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-30.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-10.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-1.*t);\n\t\t\t\tt += .25;\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-40.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t\to += .25*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-3.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-4.*t);\n\t\t\t}\n\t\t\to += .5*note(t+sin(t*850.)/450.*sin(t*45.)/45.,-0.)\n\t\t\t\t\t*smoothstep(0.,.001,t)*exp(-.5*t);\n\t\t}\n\t\treturn clamp(.5*o,-.999,.999);\n\t}", "sound_inputs": [], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat erf(in float x) {\n    x *= 1.;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "buffer_a_code": "Main\n{\n    vec4 dQ = Q = vec4(0);\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    \n    if (iFrame%20==0) {\n        vec3 h = hash31(float(iFrame));\n        if (length(U-R*h.xy)<20.)\n            Q = vec4(0,0,h.z,2);\n    }\n    Q.w *= .999;\n    if (iFrame < 1) {Q = vec4(0,0,0,0);}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = a.w*(a.w-1.);\n        dQ.xy -= f*u/dot(u,u);\n    }\n    Q += dQ;\n    if (U.x<1.||U.y<1.||R.y-U.y<1.||R.x-U.x<1.) Q.w*=0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clS3WK", "name": "Golf, golfed (454 ch)", "author": "fenix", "description": "Yo, you said you liked code golf, so I golfed a golf shader. This is the barest semblance of a game, just seemed like a fun silly exercise.\n\n*drag and release mouse to putt*", "tags": ["game", "golf", "codegolf"], "likes": 8, "viewed": 257, "published": 3, "date": "1673902385", "time_retrieved": "2024-07-30T18:15:26.433582", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//   Yo, you said you liked code golf, so I golfed a golf shader. This is the barest\n//   semblance of a game, just seemed like a fun silly exercise. Drag the mouse to putt\n//   the ball into the hole.\n//\n//   Variations that improve the look (honestly any variation would look better) but\n//   don't add much size would be considered.\n//\n// ---------------------------------------------------------------------------------------\n\n// From coyote (113/454 ch):\n//*\n    M = mix(V(1,0,0, u+=u-R ),\n            1. + (V(0,.5,0, u/=R.y ) * s(.1)c)) - 1.) * s(.05)b)),\n            s(.01) clamp(dot(u - b, v) / dot(v, v), 0., 1.) * v - b))\n           );\n}\n/**/\n\n// From FabriceNeyret2 (119/468 ch):\n/*\nM;\n    u = (u+u - R) / R.y;\n    O = mix(V(1,0,0,1), \n            1. + (V(0,.5,0,1) * s(.1) c)) - 1.) * s(.05) b)),\n            s(.01) clamp(dot(u - b, v) / dot(v, v), 0., 1.) * v - b))\n           );\n}\n/**/\n\n// From coyote (165/472 ch):\n/*\n#define s(X, Y) smoothstep(X, X + 6./R.y, length(u - Y))\n\nM;\n    u = (u+u - R) / R.y;\n    O = mix(V(1,0,0,1), \n            1. + (V(0,.5,0,1) * s(.1, c) - 1.) * s(.05, b),\n            s(.01, clamp(dot(u - b, v) / dot(v, v), 0., 1.) * v - b)\n           );\n}\n/**/\n\n// From FabriceNeyret2 (171/475 ch):\n/*\n#define s(X, Y) smoothstep(X, X + 6./R.y, length(u - Y))\n\nM;\n    u = (u+u - R) / R.y;\n    O = mix(vec4(1,0,0,1), \n            1. + (vec4(0,.5,0,1) * s(.1, c) - 1.) * s(.05, b),\n            s(.01, clamp(dot(u - b, v) / dot(v, v), 0., 1.) * v - b)\n           );\n}\n/**/\n\n// From FabriceNeyret2 (181/489 ch):\n/*\n#define s(X, Y) smoothstep(X, X + 3./R.y, length(u - Y))\n\nM;\n    u = (u - .5*R) / R.y;\n    O = mix(vec4(1,0,0,1), \n            1. + (vec4(0,.5,0,1) * s(.05, g(2.).xy) - 1.) * s(.025, b),\n            s(.005, clamp(dot(u -= b, v) / dot(v, v), 0., 1.) * v)\n           );\n}\n/**/\n\n// From Xor (245/627 ch):\n/*\n#define s(C, X, Y) O += (C-O)*smoothstep(3./R.y,0.,length(u - Y.xy)-X)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5*R.xy)/R.y;\n    O = vec4(0,.5,0,1);\n    \n    V;\n         \n    s(0., .05, h);\n    s(1., .025, b);\n    u -= b.xy;\n    h.xy = b.zw * clamp(dot(u, b.zw) / dot(b.zw, b.zw), 0., 1.);\n    O = s(vec4(1,0,0,1), .005, h);\n}\n/**/\n\n// My golf attempt (285/682 ch):\n/*\n#define s(C, X, Y) mix(C, O, smoothstep(X, X + 3./R.y, vec4(length(u - Y.xy))));\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5*R.xy)/R.y;\n    O = vec4(0,.5,0,1);\n    \n    vec4 b = g(.5), h = g(1.5);\n         \n    O = s(vec4(0), .05, h);\n    O = s(vec4(1), .025, b);\n    u -= b.xy;\n    h.xy = b.zw * clamp(dot(u, b.zw) / dot(b.zw, b.zw), 0., 1.);\n    O = s(vec4(1,0,0,1), .005, h);\n}\n/**/\n\n// Original (485/1166 ch):\n/*\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length(p - b * h); // squared dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5*R.xy)/R.y;\n    O = vec4(0,.5,0,1);\n    \n    vec4 b = texelFetch(iChannel0, ivec2(0), 0);\n    vec4 h = texelFetch(iChannel0, ivec2(1, 0), 0);\n    O = mix(vec4(0), O, smoothstep(.05, .05 + 3./R.y, vec4(length(u - h.xy))));\n    O = mix(vec4(1), O, smoothstep(.025, .025 + 3./R.y, vec4(length(u - b.xy))));\n    O = mix(vec4(1,0,0,1), O, smoothstep(.005, .005 + 3./R.y, fxLinePointDist(b.xy, b.xy + b.zw, u)));\n}\n/**/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//   State update\n// \n//   pixel at 0, 0 contains the ball position (xy) and velocity (zw)\n//   pixel at 1, 1 container the hole position\n// ---------------------------------------------------------------------------------------\n\n// From coyote (148/454 ch):\n//*\n    M = length(b - c ) < .1 \n                         ? sin(iTime * V(1e4,2e4,0,0) + u.x - .5) * .8\n         : u.x > .5      ? c.xyxy\n         : iMouse.z > 0. ? V(b, (2.*iMouse.xy - R) / R.y - b)\n         :                 V(clamp(b -= v, -e, e), v * .9 * sign(e - abs(b)));\n}\n/**/\n\n// From FabriceNeyret2 (171/475 ch):\n/*\nM , e = .95 * R / R.y;\n         \n    O = length(b - c ) < .1 \n                         ? sin(iTime * vec4(1e4,2e4,0,0) + u.x - .5) * .8\n         : u.x > .5      ? c.xyxy\n         : iMouse.z > 0. ? vec4(b, (2.*iMouse.xy - R) / R.y - b)\n         :                 vec4(clamp(b -= v, -e, e), v * .9 * sign(e - abs(b)));\n}\n/**/\n\n// From myself (179/489 ch):\n/*\nM , e = .475 * R / R.y;\n         \n    O = length(b - g(2.).xy) < .05 \n                         ? sin(iTime * vec4(1e4,2e4,0,0) + u.x - .5) * .4\n         : u.x > .5      ? g(2.)\n         : iMouse.z > 0. ? vec4(b, (iMouse.xy - .5 * R) / R.y - b)\n         :                 vec4(clamp(b -= v, -e, e), v * .9 * sign(e - abs(b)));\n}\n/**/\n\n// From FabriceNeyret2 (193/504 ch):\n/*\nM , e = R/R.y * .475;\n    vec4 h = g(2.),\n         m = iMouse;\n         \n    O = length(b - h.xy) < .05 \n                      ? sin(iTime * vec4(1e4,2e4,0,0) + (u.x != .5 ? 2. : 0.)) * .4\n         : u.x != .5   ? h\n         : m.z > 0.   ? vec4( b, (m.xy - .5 * R ) / R.y - b )\n         :              vec4 (clamp(b-=v, -e, e), v * .9 * sign(e - abs(b)) );\n}\n/**/\n\n// From Xor (290/627 ch):\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    V,\n         n = vec4(b.xy - b.zw, b.zw * .9),\n         m = iMouse,\n         v = vec4(iFrame,iFrame*2,0,0) + vec4(u == u-u+1.5);\n    vec2 e = R.xy/R.y * .475;\n         \n    O = v.x == 0. || length((b - h).xy) < .05 ? sin(v) * .4 :\n            u.x != .5 ? h :\n                m.z > 0. ?\n                    O = vec4(b.xy, (m.xy - .5 * R.xy)/R.y - b.xy) :\n                    O = vec4(clamp(n.xy, -e, e), n.zw * (step(abs(n.xy), e) * 2. - 1.));\n}\n/**/\n\n// My golf attempt (337/682 ch):\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec4 b = g(.5),\n         h = g(1.5),\n         n = vec4(b.xy - b.zw, b.zw * .9),\n         m = iMouse,\n         v = float(iFrame) * vec4(1,2,0,0) + float(u == vec2(1.5));\n    vec2 e = vec2(R.x / R.y, 1) * .475;\n         \n    O = v.x == 0. || length(b.xy - h.xy) < .05 ? sin(v) * .4 :\n            u.x != .5 ? h :\n                m.z > 0. ?\n                    O = vec4(b.xy, (m.xy - .5 * R.xy)/R.y - b.xy) :\n                    O = vec4(clamp(n.xy, -e, e), n.zw * (vec2(greaterThan(abs(n.xy), e)) * -2. + 1.));\n}\n/**/\n\n// Original (659/1166 ch):\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    ivec2 i = ivec2(u);\n    vec4 b = texelFetch(iChannel0, ivec2(0), 0),\n         h = texelFetch(iChannel0, ivec2(1, 0), 0);\n         \n    if (i == ivec2(0))\n    {\n        if (iMouse.z > 0.)\n        {\n            O = vec4(b.xy, (iMouse.xy - .5*iResolution.xy)/iResolution.y - b.xy);\n        }\n        else\n        {\n            O = b;\n            O.xy -= O.zw;\n            O.zw *= .9;\n            if (abs(O.x) > .475 * iResolution.x / iResolution.y)\n            {\n                O.z = -O.z;\n                O.x = clamp(O.x, -.475 * iResolution.x / iResolution.y, .475 * iResolution.x / iResolution.y);\n            }\n            if (abs(O.y) > .475)\n            {\n                O.w = -O.w;\n                O.y = clamp(O.y, -.475, .475);\n            }\n        }\n        if (iFrame == 0 || length(b.xy - h.xy) < .05)\n        {\n            vec4 v = vec4(float(iFrame) * vec4(1,2,0,0));\n            O = sin(v) * .4;\n        }\n    }\n    else if (i == ivec2(1, 0))\n    {\n        O = h;\n        if (iFrame == 0 || length(b.xy - h.xy) < .05)\n        {\n            vec4 v = vec4(float(iFrame + 1) * vec4(3,4,0,0));\n            O = sin(v) * .4;\n        }\n    }\n}\n/**/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// From coyote (193/454):\n//*\n#define V vec4//\n#define s(X) smoothstep( X, X + 6./R.y, length(u -//\n#define g texture(iChannel0, .5/R//\n#define M void mainImage( out V O, vec2 u )  \\\n             { vec2 R = iResolution.xy, b = g).xy, v = g).zw,  c = g*4.).xy, e = .95 * R / R.y; O\n/**/\n\n// From FabriceNeyret2 (187/468):\n/*\n#define V vec4//\n#define s(X) smoothstep( X, X + 6./R.y, length(u -//\n#define g(X) texture(iChannel0, X / R )//\n#define M void mainImage( out V O, vec2 u )  \\\n             { vec2 R = iResolution.xy, b = g(.5).xy, v = g(.5).zw,  c = g(2.).xy\n/**/\n\n// From coyote (145/472 ch):\n/*\n#define V vec4\n#define g(X) texture(iChannel0, X / R )//\n#define M void mainImage( out V O, vec2 u )  \\\n             { vec2 R = iResolution.xy, b = g(.5).xy, v = g(.5).zw,  c = g(2.).xy\n/**/\n\n// From FabriceNeyret2 (133/475 ch):\n/*\n#define g(X) texture(iChannel0, X / R )//\n#define M void mainImage( out vec4 O, vec2 u )  \\\n             { vec2 R = iResolution.xy, b = g(.5).xy, v = g(.5).zw,  c = g(2.).xy\n/**/\n\n// From FabriceNeyret2 (129/409 ch):\n/*\n#define R iResolution.xy//\n#define g(X) texture(iChannel0, X / R )//\n#define M void mainImage( out vec4 O, vec2 u )  \\\n             { vec2 b = g(.5).xy, v = g(.5).zw\n/**/\n\n// From Xor (92/627 ch):\n/*\n#define R iResolution\n#define g(X) texture(iChannel0, X / R.xy)\n\n#define V vec4 b = g(.5), h = g(1.5)\n/**/\n\n// My golf attempt (60/682 ch):\n/*\n#define R iResolution\n#define g(X) texture(iChannel0, X / R.xy)\n/**/\n\n// Original (22/1166 ch)\n/*\n#define R iResolution\n/**/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clS3WK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "DtS3WV", "name": "VRC Audiolink port V3", "author": "Iliana", "description": "Port of VRChat audiolink\n[url=https://github.com/llealloo/vrc-udon-audio-link]vrc-udon-audio-link[/url]\n\nUse the circles to move the capture regions.\n\nThe UI is bad, but it's just a proof of concept.", "tags": ["audiolink"], "likes": 2, "viewed": 181, "published": 3, "date": "1673901763", "time_retrieved": "2024-07-30T18:15:27.745075", "image_code": "// Mechanism to index into texture.\n#ifdef AUDIOLINK_STANDARD_INDEXING\n    sampler2D _AudioTexture;\n    #define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, vec4(uvec2(xycoord) * _AudioTexture_TexelSize.xy, 0., 0.))\n#else\n    #define _AudioTexture iChannel0\n    #define AudioLinkData(xycoord) texelFetch(_AudioTexture, ivec2(xycoord), 0)\n#endif\n\n\n\n\n\n// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.\nvec4 AudioLinkDataMultiline(uvec2 xycoord) { return AudioLinkData(uvec2(xycoord.x % uint(AUDIOLINK_WIDTH), xycoord.y + xycoord.x/uint(AUDIOLINK_WIDTH))); }\n\n// Mechanism to sample between two adjacent pixels and lerp between them, like \"linear\" supesampling\nvec4 AudioLinkLerp(vec2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(ivec2(xy)+ivec2(1,0)), fract( xy.x ) ); }\n\n// Same as AudioLinkLerp but properly handles multiline reading.\nvec4 AudioLinkLerpMultiline(vec2 xy) { return lerp(AudioLinkDataMultiline(uvec2(xy)), AudioLinkDataMultiline(uvec2(xy+vec2(1.,0.))), fract(xy.x)); }\n\n\n\n//Get version of audiolink present in the world, 0 if no audiolink is present\nfloat AudioLinkGetVersion()\n{\n    ivec2 dims = ivec2(iResolution.xy);\n    /*#if !defined(AUDIOLINK_STANDARD_INDEXING)\n        _AudioTexture.GetDimensions(dims.x, dims.y);\n    #else\n        dims = _AudioTexture_TexelSize.zw;\n    #endif*/\n\n    if (dims.x >= 128)\n        return float(AudioLinkData(ALPASS_GENERALVU).x);\n    else if (dims.x > 16)\n        return 1.;\n    else\n        return 0.;\n}\n\n// Extra utility functions for time.\nuint AudioLinkDecodeDataAsUInt(uvec2 indexloc)\n{\n    uvec4 rpx = uvec4(AudioLinkData(indexloc));\n    return rpx.x + rpx.y*uint(1024) + rpx.z * uint(1048576) + rpx.w * uint(1073741824);\n}\n\nvoid renderCircle(inout vec4 col, in vec2 coord, vec2 c, float r, vec4 lineColor)\n{\n    float t = lineThickness/2.;\n    float l = length(coord - c);\n    if (l < r+t)\n    {\n        col = vec4(0.);\n    }\n    if (compare(l, r, t))\n    {\n        col = mix(col, lineColor, lineColor.a);\n    }\n}\n\nvoid renderHorizSlider(inout vec4 col, in vec2 uv, inout Slider horiz, float fmin, float fmax, vec4 lineColor)\n{\n    if (compare(uv.y, horiz.val, lineThickness / iResolution.y) && inRange(uv.x, fmin, fmax))\n    {\n        col = mix(col, lineColor, lineColor.a);\n    }\n    renderCircle(col, uv*iResolution.xy, vec2(fmin + (fmax-fmin)/2., horiz.val)*iResolution.xy, 15., lineColor);\n    \n}\n\nvoid renderVertiSlider(inout vec4 col, in vec2 uv, inout Slider verti, vec4 lineColor)\n{\n    if (compare(uv.x, verti.val, lineThickness / iResolution.x))\n    {\n        col = mix(col, lineColor, lineColor.a);\n    }\n    renderCircle(col, uv*iResolution.xy, vec2(verti.val, 0.5)*iResolution.xy, 15., lineColor);\n}\n\nvec4 getBand(float u)\n{\n    vec4 d = AudioLinkGetSelfPixelData(uvec2(u*float(AUDIOLINK_WIDTH), ALPASS_DFT.y));\n    return d;\n}\n\nfloat avgThresh(float fmin, float fmax, float thresh)\n{\n    float sum = 0.;\n    for (float i = fmin; i < fmax; i+=(1./iResolution.x))\n    {\n        float b = getBand(i).r;\n        if (b > thresh) sum+=b;\n    }\n    return max(sum / ((fmax-fmin)*10.),0.5);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 uv = I/iResolution.xy;\n    Zones z;\n    int i = 0;\n    decodeZones(iChannel1, z, i);\n    \n    O = vec4(0.0);\n    \n    \n    float b0 = avgThresh(z.x0.val, z.x1.val, z.t0.val);\n    float b1 = avgThresh(z.x1.val, z.x2.val, z.t1.val);\n    float b2 = avgThresh(z.x2.val, z.x3.val, z.t2.val);\n    float b3 = avgThresh(z.x3.val, 1., z.t3.val);\n    \n    \n    //O = vec4(0.);\n    vec4 band = getBand(uv.x);\n    if (uv.y < band.r) O = band;\n    //O.r = getBand(uv.x);\n    vec4 ui = vec4(0);\n    \n    renderHorizSlider(ui, uv, z.t0, z.x0.val, z.x1.val, vec4(T0COLOR*b0, 0.8));\n    renderHorizSlider(ui, uv, z.t1, z.x1.val, z.x2.val, vec4(T1COLOR*b1, 0.8));\n    renderHorizSlider(ui, uv, z.t2, z.x2.val, z.x3.val, vec4(T2COLOR*b2, 0.8));\n    renderHorizSlider(ui, uv, z.t3, z.x3.val, 1., vec4(T3COLOR*b3, 0.8));\n    \n    renderVertiSlider(ui, uv, z.x0, vec4(vec3(0.8), 0.8));\n    renderVertiSlider(ui, uv, z.x1, vec4(vec3(0.8), 0.8));\n    renderVertiSlider(ui, uv, z.x2, vec4(vec3(0.8), 0.8));\n    renderVertiSlider(ui, uv, z.x3, vec4(vec3(0.8), 0.8));\n    O = mix(O, ui, ui.a);\n    O.a = 1.;\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#include \"Common.glsl\"\n//#iChannel0 \"file://C:\\\\Users\\\\civel\\\\DownloadsTeminite - Ghost Ship.mp3\"\n//#iChannel1 \"self\"\n\nfloat _Gain /*Range(0, 2))*/ = 1.0;\nfloat _FadeLength /*Range(0 , 1))*/ = 0.8;\nfloat _FadeExpFalloff /*Range(0 , 1))*/ = 0.3;\nfloat _Bass /*Range(0 , 4))*/ = 1.0;\nfloat _Treble /*Range(0 , 4))*/ = 1.0;\nfloat _X0 /*Range(0.0, 0.168))*/ = 0.25;\nfloat _X1 /*Range(0.242, 0.387))*/ = 0.25;\nfloat _X2 /*Range(0.461, 0.628))*/ = 0.5;\nfloat _X3 /*Range(0.704, 0.953))*/ = 0.75;\nfloat _Threshold0 /*Range(0.0, 1.0))*/ = 0.45;\nfloat _Threshold1 /*Range(0.0, 1.0))*/ = 0.45;\nfloat _Threshold2 /*Range(0.0, 1.0))*/ = 0.45;\nfloat _Threshold3 /*Range(0.0, 1.0))*/ = 0.45;\nbool _EnableAutogain = true;\nfloat _AutogainDerate /*Range(.001, .5)*/ = 0.1;\nfloat _SourceVolume = 1.;\nfloat _SourceDistance = 1.;\nfloat _SourceSpatialBlend = 0.; //0-1 = 2D -> 3D curve;\nvec4 _SourcePosition = vec4(0.);\n\nint _ThemeColorMode = 0;\nvec4 _CustomThemeColor0 = vec4(1.0,1.0,0.0,1.0);\nvec4 _CustomThemeColor1 = vec4(0.0,0.0,1.0,1.0);\nvec4 _CustomThemeColor2 = vec4(1.0,0.0,0.0,1.0);\nvec4 _CustomThemeColor3 = vec4(0.0,1.0,0.0,1.0);\n\n#if defined(UNITY_UV_STARTS_AT_TOP) || defined(SHADER_API_GLES3)\n#define AUDIO_LINK_ALPHA_START(BASECOORDY) \\\n    vec2 guv = IN.xy; \\\n    uvec2 coordinateGlobal = uvec2(round(guv * _SelfTexture2D_TexelSize.zw - 0.5)); \\\n    uvec2 coordinateLocal = uvec2(coordinateGlobal.x - BASECOORDY.x, coordinateGlobal.y - BASECOORDY.y);\n#else\n#define AUDIO_LINK_ALPHA_START(BASECOORDY) \\\n    vec2 guv = IN.xy; \\\n    guv.y = 1.-guv.y; \\\n    uvec2 coordinateGlobal = uvec2(round(guv * _SelfTexture2D_TexelSize.zw - 0.5)); \\\n    uvec2 coordinateLocal = uvec2(coordinateGlobal.x - BASECOORDY.x, coordinateGlobal.y - BASECOORDY.y);\n#endif\n\n// Mechanism to index into texture.\n#ifdef AUDIOLINK_STANDARD_INDEXING\n    sampler2D _AudioTexture;\n    #define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, vec4(uvec2(xycoord) * _AudioTexture_TexelSize.xy, 0., 0.))\n#else\n    #define _AudioTexture iChannel0\n    #define AudioLinkData(xycoord) texelFetch(_AudioTexture, ivec2(xycoord), 0)\n#endif\n\n\n\n// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.\nvec4 AudioLinkDataMultiline(uvec2 xycoord) { return AudioLinkData(uvec2(xycoord.x % uint(AUDIOLINK_WIDTH), xycoord.y + xycoord.x/uint(AUDIOLINK_WIDTH))); }\n\n// Mechanism to sample between two adjacent pixels and lerp between them, like \"linear\" supesampling\nvec4 AudioLinkLerp(vec2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(ivec2(xy)+ivec2(1,0)), fract( xy.x ) ); }\n\n// Same as AudioLinkLerp but properly handles multiline reading.\nvec4 AudioLinkLerpMultiline(vec2 xy) { return lerp(AudioLinkDataMultiline(uvec2(xy)), AudioLinkDataMultiline(uvec2(xy+vec2(1.,0.))), fract(xy.x)); }\n\n\n\n//Get version of audiolink present in the world, 0 if no audiolink is present\nfloat AudioLinkGetVersion()\n{\n    ivec2 dims = ivec2(iResolution.xy);\n    /*#if !defined(AUDIOLINK_STANDARD_INDEXING)\n        _AudioTexture.GetDimensions(dims.x, dims.y);\n    #else\n        dims = _AudioTexture_TexelSize.zw;\n    #endif*/\n\n    if (dims.x >= 128)\n        return float(AudioLinkData(ALPASS_GENERALVU).x);\n    else if (dims.x > 16)\n        return 1.;\n    else\n        return 0.;\n}\n\n// This pulls data from this texture.\n#ifndef AudioLinkGetSelfPixelData\n    #define AudioLinkGetSelfPixelData(xy) texelFetch(_SelfTexture2D, ivec2(xy),0)\n#endif\n\n// Extra utility functions for time.\nuint AudioLinkDecodeDataAsUInt(uvec2 indexloc)\n{\n    uvec4 rpx = uvec4(AudioLinkData(indexloc));\n    return rpx.x + rpx.y*uint(1024) + rpx.z * uint(1048576) + rpx.w * uint(1073741824);\n}\n\n//Note: This will truncate time to every 134,217.728 seconds (~1.5 days of an instance being up) to prevent floating point aliasing.\n// if your code will alias sooner, you will need to use a different function.  It should be safe to use this on all times.\nfloat AudioLinkDecodeDataAsSeconds(uvec2 indexloc)\n{\n    uint time = AudioLinkDecodeDataAsUInt(indexloc) & uint(0x7ffffff);\n    //Can't just divide by float.  Bug in Unity's HLSL compiler.\n    return float(time / uint(1000)) + float( time % uint(1000) ) / 1000.; \n}\n\n\n\n// Sample the amplitude of a given frequency in the DFT, supports frequencies in [13.75; 14080].\nvec4 AudioLinkGetAmplitudeAtFrequency(float hertz)\n{\n    float note = float(AUDIOLINK_EXPBINS) * log2(hertz / float(AUDIOLINK_BOTTOM_FREQUENCY));\n    return AudioLinkLerpMultiline(float(ALPASS_DFT) + vec2(note, 0.));\n}\n\n// Sample the amplitude of a given quartertone in an octave. Octave is in [0; 9] while quarter is [0; 23].\nvec4 AudioLinkGetAmplitudeAtQuarterNote(float octave, float quarter)\n{\n    return AudioLinkLerpMultiline(float(ALPASS_DFT) + vec2(octave * float(AUDIOLINK_EXPBINS) + quarter, 0.));\n}\n\n// Sample the amplitude of a given semitone in an octave. Octave is in [0; 9] while note is [0; 11].\nvec4 AudioLinkGetAmplitudeAtNote(float octave, float note)\n{\n    float quarter = note * 2.0;\n    return AudioLinkGetAmplitudeAtQuarterNote(octave, quarter);\n}\n\n// Sample the amplitude of a given quartertone across all octaves. Quarter is [0; 23].\nvec4 AudioLinkGetAmplitudesAtQuarterNote(float quarter)\n{\n    vec4 amplitude = vec4(0.);\n    //UNITY_UNROLL\n    for (int i = 0; i < AUDIOLINK_EXPOCT; i++)\n    {\n        amplitude += AudioLinkGetAmplitudeAtQuarterNote(float(i),quarter);\n    }\n    return amplitude;\n}\n\n// Sample the amplitude of a given semitone across all octaves. Note is [0; 11].\nvec4 AudioLinkGetAmplitudesAtNote(float note)\n{\n    float quarter = note * 2.0;\n    return AudioLinkGetAmplitudesAtQuarterNote(quarter);\n}\n\n// Get a reasonable drop-in replacement time value for _Time.y with the\n// given chronotensity index [0; 7] and AudioLink band [0; 3].\nfloat AudioLinkGetChronoTime(uint index, uint band)\n{\n    return float(AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY + uvec2(index, band))) / 100000.0;\n}\n\n// Get a chronotensity value in the interval [0; 1], modulated by the speed input, \n// with the given chronotensity index [0; 7] and AudioLink band [0; 3].\nfloat AudioLinkGetChronoTimeNormalized(uint index, uint band, float speed)\n{\n    return fract(AudioLinkGetChronoTime(index, band) * speed);\n}\n\n// Get a chronotensity value in the interval [0; interval], modulated by the speed input, \n// with the given chronotensity index [0; 7] and AudioLink band [0; 3].\nfloat AudioLinkGetChronoTimeInterval(uint index, uint band, float speed, float interval)\n{\n    return AudioLinkGetChronoTimeNormalized(index, band, speed) * interval;\n}\n\n// Get time of day. The return value is a vec4 with the values vec3(hour, minute, second).\nvec3 AudioLinkGetTimeOfDay()\n{\n    /*float value = AudioLinkDecodeDataAsSeconds(ALPASS_GENERALVU_UNIX_SECONDS);\n    float hour = floor(value / 3600.0);\n    float minute = float(int(floor(value / 60.0)) % 60);\n    float second = value % 60.0;*/\n    return iDate.gba;\n}\n\n// Get a character from a globally synced string, given an index of string in range [0; 3], and\n// a character index in range [0; 31]. The string at the 0th index is the local player name.\n// The 1st index is the master name, and index 2 and 3 are custom strings.\n// Returns a unsigned integer represented a unicode codepoint, i.e. UTF32.\nuint AudioLinkGetGlobalStringChar(uint stringIndex, uint charIndex)\n{\n    uvec4 fourChars = uvec4(AudioLinkData(ALPASS_GLOBAL_STRINGS + uvec2(charIndex / uint(4), stringIndex)));\n    return fourChars[charIndex % uint(4)];\n}\n\n// Get a character from the local player name given a character index in the range [0; 31].\n// Returns a unsigned integer represented a unicode codepoint, i.e. UTF32.\nuint AudioLinkGetLocalPlayerNameChar(uint charIndex)\n{\n    return AudioLinkGetGlobalStringChar(uint(AUDIOLINK_STRING_LOCALPLAYER), charIndex);\n}\n\n// Get a character from the master player name given a character index in the range [0; 31].\n// Returns a unsigned integer represented a unicode codepoint, i.e. UTF32.\nuint AudioLinkGetMasterNameChar(uint charIndex)\n{\n    return AudioLinkGetGlobalStringChar(uint(AUDIOLINK_STRING_MASTER), charIndex);\n}\n\n// Get a character from the first custom string given a character index in the range [0; 31].\n// Returns a unsigned integer represented a unicode codepoint, i.e. UTF32.\nuint AudioLinkGetCustomString1Char(uint charIndex)\n{\n    return AudioLinkGetGlobalStringChar(uint(AUDIOLINK_STRING_CUSTOM1), charIndex);\n}\n\n// Get a character from the second custom string given a character index in the range [0; 31].\n// Returns a unsigned integer represented a unicode codepoint, i.e. UTF32.\nuint AudioLinkGetCustomString2Char(uint charIndex)\n{\n    return AudioLinkGetGlobalStringChar(uint(AUDIOLINK_STRING_CUSTOM2), charIndex);\n}\n\n// Returns the position of the AudioLink AudioSource in world space.\nvec4 AudioLinkGetAudioSourcePosition()\n{\n    return vec4(AudioLinkData(ALPASS_GENERALVU_SOURCE_POS).xyz,1);\n}\n\n// #pragma target 4.0\n// #pragma vertex CustomRenderTextureVertexShader\n// #pragma fragment frag\n\n// This changes _SelfTexture2D in 'UnityCustomRenderTexture.cginc' to Texture2D instead of sampler2D\n// Thanks Lyuma!\n// #define _SelfTexture2D _JunkTexture\n// #include \"UnityCustomRenderTexture.cginc\"\n// #undef _SelfTexture2D\n#define _SelfTexture2D iChannel1\n\n// #include \"UnityCG.cginc\"\n// #include \"AudioLink.cginc\"\nuniform vec4 _SelfTexture2D_TexelSize;\n\n// AudioLink 4 Band\n// uniform float _FadeLength;\n// uniform float _FadeExpFalloff;\n// uniform float _Gain;\n// uniform float _Bass;\n// uniform float _Treble;\n// uniform float _X0;\n// uniform float _X1;\n// uniform float _X2;\n// uniform float _X3;\n// uniform float _Threshold0;\n// uniform float _Threshold1;\n// uniform float _Threshold2;\n// uniform float _Threshold3;\n// uniform float _SourceVolume;\n// uniform float _SourceDistance;\n// uniform float _SourceSpatialBlend;\n// uniform vec4 _SourcePosition;\n// uniform uint _ThemeColorMode;\n// uniform vec4 _CustomThemeColor0;\n// uniform vec4 _CustomThemeColor1;\n// uniform vec4 _CustomThemeColor2;\n// uniform vec4 _CustomThemeColor3;\n\n// Global strings\nuniform vec4 _StringLocalPlayer[8];\nuniform vec4 _StringMasterPlayer[8];\nuniform vec4 _StringCustom1[8];\nuniform vec4 _StringCustom2[8];\n\n// Extra Properties\n// uniform float _EnableAutogain;\n// uniform float _AutogainDerate;\n\n// Set by Udon\nuniform vec4 _AdvancedTimeProps0;\nuniform vec4 _AdvancedTimeProps1;\nuniform vec4 _VersionNumberAndFPSProperty;\nuniform vec4 _PlayerCountAndData;\n\n\nfloat _Samples0(int i)\n{\n    return texelFetch(iChannel0, ivec2((float(i))/4092.*512.,0),0).r;\n}\nfloat _Samples1(int i)\n{\n    return texelFetch(iChannel0, ivec2((float(i)+1023.)/4092.*512.,0),0).r;\n}\nfloat _Samples2(int i)\n{\n    return texelFetch(iChannel0, ivec2((float(i)+2045.)/4092.*512.,0),0).r;\n}\nfloat _Samples3(int i)\n{\n    return texelFetch(iChannel0, ivec2((float(i)+3069.)/4092.*512.,0),0).r;\n}\n//Raw audio data.\n// cbuffer LeftSampleBuffer {\n    //float _Samples0L[1023];\n    //float _Samples1L[1023];\n    //float _Samples2L[1023];\n    //float _Samples3L[1023];\n// };\n// cbuffer RightSampleBuffer {\n    //float _Samples0R[1023];\n    //float _Samples1R[1023];\n    //float _Samples2R[1023];\n    //float _Samples3R[1023];\n// };\n\n// These may become uniforms set by the controller, keep them named like this for now\nconst float _LogAttenuation = 0.68;\nconst float _ContrastSlope = 0.63;\nconst float _ContrastOffset = 0.62;\n\nconst float _WaveInClampValue = 2.0;\n\n// Encodes a uint so it can be read-out by AudioLinkDecodeDataAsUInt().\nvec4 AudioLinkEncodeUInt(uint val)\n{\n    return vec4(\n        float((val) & uint(0x3ff)),\n        float((val >> uint(10)) & uint(0x3ff)),\n        float((val >> uint(20)) & uint(0x3ff)),\n        float((val >> uint(30)) & uint(0x3ff))\n    );\n}\n\nfloat ReadLeft( int s )\n{\n    if( s < 1023 )\n        return _Samples0(s);\n    else if( s < 2046 )\n        return _Samples1(s-1023);\n    else if( s < 3069 )\n        return _Samples2(s-2046);\n    else if( s < 4092 )\n        return _Samples3(s-3069);\n    else\n        return 0.;\n}\nfloat ReadRight( int s )\n{\n    if( s < 1023 )\n        return _Samples0(s);\n    else if( s < 2046 )\n        return _Samples1(s-1023);\n    else if( s < 3069 )\n        return _Samples2(s-2046);\n    else if( s < 4092 )\n        return _Samples3(s-3069);\n    else\n        return 0.;\n}\n\n// Name \"Pass1AudioDFT\"\n// CGPROGRAM\n//uniform float lut[240];\nfloat lut(int i)\n{\n\n    if (i == 0) return 0.000;\n    if (i == 1) return 0.000;\n    if (i == 2) return 0.000;\n    if (i == 3) return 0.000;\n    if (i == 4) return 0.000;\n    if (i == 5) return 0.000;\n    if (i == 6) return 0.000;\n    if (i == 7) return 0.000;\n    if (i == 8) return 0.000;\n    if (i == 9) return 0.000;\n    if (i == 10) return 0.000;\n    if (i == 11) return 0.000;\n    if (i == 12) return 0.000;\n    if (i == 13) return 0.000;\n    if (i == 14) return 0.000;\n    if (i == 15) return 0.000;\n    if (i == 16) return 0.000;\n    if (i == 17) return 0.000;\n    if (i == 18) return 0.000;\n    if (i == 19) return 0.000;\n    if (i == 20) return 0.000;\n    if (i == 21) return 0.000;\n    if (i == 22) return 0.000;\n    if (i == 23) return 0.000;\n    if (i == 24) return 0.000;\n    if (i == 25) return 0.000;\n    if (i == 26) return 0.000;\n    if (i == 27) return 0.000;\n    if (i == 28) return 0.000;\n    if (i == 29) return 0.000;\n    if (i == 30) return 0.000;\n    if (i == 31) return 0.000;\n    if (i == 32) return 0.000;\n    if (i == 33) return 0.000;\n    if (i == 34) return 0.000;\n    if (i == 35) return 0.000;\n    if (i == 36) return 0.000;\n    if (i == 37) return 0.000;\n    if (i == 38) return 0.000;\n    if (i == 39) return 0.000;\n    if (i == 40) return 0.000;\n    if (i == 41) return 0.000;\n    if (i == 42) return 0.000;\n    if (i == 43) return 0.000;\n    if (i == 44) return 0.000;\n    if (i == 45) return 0.000;\n    if (i == 46) return 0.000;\n    if (i == 47) return 0.000;\n    if (i == 48) return 0.000;\n    if (i == 49) return 0.000;\n    if (i == 50) return 0.000;\n    if (i == 51) return 0.000;\n    if (i == 52) return 0.001;\n    if (i == 53) return 0.002;\n    if (i == 54) return 0.003;\n    if (i == 55) return 0.004;\n    if (i == 56) return 0.005;\n    if (i == 57) return 0.006;\n    if (i == 58) return 0.008;\n    if (i == 59) return 0.010;\n    if (i == 60) return 0.012;\n    if (i == 61) return 0.014;\n    if (i == 62) return 0.017;\n    if (i == 63) return 0.020;\n    if (i == 64) return 0.022;\n    if (i == 65) return 0.025;\n    if (i == 66) return 0.029;\n    if (i == 67) return 0.032;\n    if (i == 68) return 0.036;\n    if (i == 69) return 0.040;\n    if (i == 70) return 0.044;\n    if (i == 71) return 0.048;\n    if (i == 72) return 0.053;\n    if (i == 73) return 0.057;\n    if (i == 74) return 0.062;\n    if (i == 75) return 0.067;\n    if (i == 76) return 0.072;\n    if (i == 77) return 0.078;\n    if (i == 78) return 0.083;\n    if (i == 79) return 0.089;\n    if (i == 80) return 0.095;\n    if (i == 81) return 0.101;\n    if (i == 82) return 0.107;\n    if (i == 83) return 0.114;\n    if (i == 84) return 0.121;\n    if (i == 85) return 0.128;\n    if (i == 86) return 0.135;\n    if (i == 87) return 0.142;\n    if (i == 88) return 0.149;\n    if (i == 89) return 0.157;\n    if (i == 90) return 0.164;\n    if (i == 91) return 0.172;\n    if (i == 92) return 0.180;\n    if (i == 93) return 0.188;\n    if (i == 94) return 0.196;\n    if (i == 95) return 0.205;\n    if (i == 96) return 0.213;\n    if (i == 97) return 0.222;\n    if (i == 98) return 0.230;\n    if (i == 99) return 0.239;\n    if (i == 100) return 0.248;\n    if (i == 101) return 0.257;\n    if (i == 102) return 0.266;\n    if (i == 103) return 0.276;\n    if (i == 104) return 0.285;\n    if (i == 105) return 0.294;\n    if (i == 106) return 0.304;\n    if (i == 107) return 0.313;\n    if (i == 108) return 0.323;\n    if (i == 109) return 0.333;\n    if (i == 110) return 0.342;\n    if (i == 111) return 0.352;\n    if (i == 112) return 0.362;\n    if (i == 113) return 0.372;\n    if (i == 114) return 0.381;\n    if (i == 115) return 0.391;\n    if (i == 116) return 0.401;\n    if (i == 117) return 0.411;\n    if (i == 118) return 0.421;\n    if (i == 119) return 0.431;\n    if (i == 120) return 0.441;\n    if (i == 121) return 0.451;\n    if (i == 122) return 0.460;\n    if (i == 123) return 0.470;\n    if (i == 124) return 0.480;\n    if (i == 125) return 0.490;\n    if (i == 126) return 0.499;\n    if (i == 127) return 0.509;\n    if (i == 128) return 0.519;\n    if (i == 129) return 0.528;\n    if (i == 130) return 0.538;\n    if (i == 131) return 0.547;\n    if (i == 132) return 0.556;\n    if (i == 133) return 0.565;\n    if (i == 134) return 0.575;\n    if (i == 135) return 0.584;\n    if (i == 136) return 0.593;\n    if (i == 137) return 0.601;\n    if (i == 138) return 0.610;\n    if (i == 139) return 0.619;\n    if (i == 140) return 0.627;\n    if (i == 141) return 0.636;\n    if (i == 142) return 0.644;\n    if (i == 143) return 0.652;\n    if (i == 144) return 0.660;\n    if (i == 145) return 0.668;\n    if (i == 146) return 0.676;\n    if (i == 147) return 0.684;\n    if (i == 148) return 0.691;\n    if (i == 149) return 0.699;\n    if (i == 150) return 0.706;\n    if (i == 151) return 0.713;\n    if (i == 152) return 0.720;\n    if (i == 153) return 0.727;\n    if (i == 154) return 0.734;\n    if (i == 155) return 0.741;\n    if (i == 156) return 0.747;\n    if (i == 157) return 0.754;\n    if (i == 158) return 0.760;\n    if (i == 159) return 0.766;\n    if (i == 160) return 0.772;\n    if (i == 161) return 0.778;\n    if (i == 162) return 0.784;\n    if (i == 163) return 0.790;\n    if (i == 164) return 0.795;\n    if (i == 165) return 0.801;\n    if (i == 166) return 0.806;\n    if (i == 167) return 0.811;\n    if (i == 168) return 0.816;\n    if (i == 169) return 0.821;\n    if (i == 170) return 0.826;\n    if (i == 171) return 0.831;\n    if (i == 172) return 0.835;\n    if (i == 173) return 0.840;\n    if (i == 174) return 0.844;\n    if (i == 175) return 0.848;\n    if (i == 176) return 0.853;\n    if (i == 177) return 0.857;\n    if (i == 178) return 0.861;\n    if (i == 179) return 0.864;\n    if (i == 180) return 0.868;\n    if (i == 181) return 0.872;\n    if (i == 182) return 0.875;\n    if (i == 183) return 0.879;\n    if (i == 184) return 0.882;\n    if (i == 185) return 0.885;\n    if (i == 186) return 0.888;\n    if (i == 187) return 0.891;\n    if (i == 188) return 0.894;\n    if (i == 189) return 0.897;\n    if (i == 190) return 0.899;\n    if (i == 191) return 0.902;\n    if (i == 192) return 0.904;\n    if (i == 193) return 0.906;\n    if (i == 194) return 0.909;\n    if (i == 195) return 0.911;\n    if (i == 196) return 0.913;\n    if (i == 197) return 0.914;\n    if (i == 198) return 0.916;\n    if (i == 199) return 0.918;\n    if (i == 200) return 0.919;\n    if (i == 201) return 0.921;\n    if (i == 202) return 0.922;\n    if (i == 203) return 0.924;\n    if (i == 204) return 0.925;\n    if (i == 205) return 0.926;\n    if (i == 206) return 0.927;\n    if (i == 207) return 0.928;\n    if (i == 208) return 0.928;\n    if (i == 209) return 0.929;\n    if (i == 210) return 0.929;\n    if (i == 211) return 0.930;\n    if (i == 212) return 0.930;\n    if (i == 213) return 0.930;\n    if (i == 214) return 0.931;\n    if (i == 215) return 0.931;\n    if (i == 216) return 0.930;\n    if (i == 217) return 0.930;\n    if (i == 218) return 0.930;\n    if (i == 219) return 0.930;\n    if (i == 220) return 0.929;\n    if (i == 221) return 0.929;\n    if (i == 222) return 0.928;\n    if (i == 223) return 0.927;\n    if (i == 224) return 0.926;\n    if (i == 225) return 0.925;\n    if (i == 226) return 0.924;\n    if (i == 227) return 0.923;\n    if (i == 228) return 0.922;\n    if (i == 229) return 0.920;\n    if (i == 230) return 0.919;\n    if (i == 231) return 0.917;\n    if (i == 232) return 0.915;\n    if (i == 233) return 0.913;\n    if (i == 234) return 0.911;\n    if (i == 235) return 0.909;\n    if (i == 236) return 0.907;\n    if (i == 237) return 0.905;\n    if (i == 238) return 0.903;\n    if (i == 239) return 0.900;\n}\n\n//#define lut(i) (int(i) < 51? 0. : 0.5+0.5*sin(float(int(i)-127)/239.*UNITY_TWO_PI/2.*1.6))\n//#define lut(i) lut[i]\n\nvec4 frag (in vec2 IN, in vec4 OUT)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_DFT)\n    \n    int note = int(coordinateLocal.y) * AUDIOLINK_WIDTH + int(coordinateLocal.x);\n    vec4 last = AudioLinkGetSelfPixelData(coordinateGlobal);\n    vec2 amplitude = vec2(0.);\n    float phase = 0.;\n    float phaseDelta = pow(2., float(note)/(float(AUDIOLINK_EXPBINS)));\n    phaseDelta = ((phaseDelta * float(AUDIOLINK_BOTTOM_FREQUENCY)) / float(AUDIOLINK_SPS)) * UNITY_TWO_PI * 2.; // 2 here because we're at 24kSPS\n    phase = -phaseDelta * float(AUDIOLINK_SAMPHIST)/2.;     // Align phase so 0 phase is center of window.\n\n    // DFT Window\n    float halfWindowSize = AUDIOLINK_DFT_Q / (phaseDelta / UNITY_TWO_PI);\n    int windowRange = int(floor(halfWindowSize)) + 1;\n    float totalWindow = 0.;\n\n    // For ??? reason, this is faster than doing a clever indexing which only searches the space that will be used.\n    /*uint idx;\n    for(idx = uint(0); idx < uint(AUDIOLINK_SAMPHIST / 2); ++idx)\n    {\n        // XXX TODO: Try better windows, this is just a triangle.\n        float window = max(0., halfWindowSize - abs(float(idx) - (float(AUDIOLINK_SAMPHIST) / 2. - halfWindowSize)));\n        float af = AudioLinkGetSelfPixelData(uvec2(ALPASS_WAVEFORM) + uvec2(idx % uint(AUDIOLINK_WIDTH), idx / uint(AUDIOLINK_WIDTH))).x;\n\n        // Sin and cosine components to convolve.\n        vec2 sinCos = vec2(sin(phase), cos(phase));\n\n        // Step through, one sample at a time, multiplying the sin and cos values by the incoming signal.\n        amplitude += sinCos * af * window;\n        totalWindow += window;\n        phase += phaseDelta;\n    }*/\n    //float mag = (length(amplitude) / totalWindow) * AUDIOLINK_BASE_AMPLITUDE * _Gain;\n    float mag = texelFetch(iChannel0, ivec2(float(IN.x)*512./float(AUDIOLINK_WIDTH),0), 0).r;\n\n    // Treble compensation\n    float lfac = lut(min(note, 239));\n    if (lfac <= 0.05)\n    {\n        lfac = (lut(158-note+72)-0.76) *2.;\n    }\n    else lfac *= AUDIOLINK_TREBLE_CORRECTION;\n    \n    mag *= (lfac*3. + 5.);\n\n    // Filtered output, also use FadeLength to lerp delay coefficient min/max for added smoothing effect\n    float magFilt = lerp(mag, last.z, lerp(AUDIOLINK_DELAY_COEFFICIENT_MIN, AUDIOLINK_DELAY_COEFFICIENT_MAX, _FadeLength));\n\n    // Filtered EQ'd output, used by AudioLink 4 Band\n    float freqNormalized = float(note) / float(AUDIOLINK_EXPOCT * AUDIOLINK_EXPBINS);\n    float magEQ = magFilt * (((1.0 - freqNormalized) * _Bass) + (freqNormalized * _Treble));\n\n    // Red:   Spectrum power, served straight up\n    // Green: Filtered power EQ'd, used by AudioLink 4 Band\n    // Blue:  Filtered spectrum\n    return vec4(mag, magEQ, magFilt, 1);\n}\n\n// Name \"Pass2WaveformData\"\n// CGPROGRAM\n\n\n\nvec4 fragwave (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_WAVEFORM)\n    int frame = int(coordinateLocal.x + coordinateLocal.y * uint(AUDIOLINK_WIDTH));\n    return vec4(texelFetch(iChannel0, ivec2(int(IN.x/512.*float(AUDIOLINK_WIDTH)), 0), 0));\n\n    float incomingGain = 1.;\n    // Scales the gain by the audio source component Volume to prevent data changing when changing the volume.\n    // Clamped to 0.001 to prevent division by 0 because that will make it 'splode and we don't want that now do we?\n    incomingGain *= 1./clamp(_SourceVolume, 0.001, 1.);\n    if(_EnableAutogain)\n    {\n        vec4 lastAutoGain = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(11, 0));\n\n        // Divide by the running volume.\n        incomingGain *= 1. / (lastAutoGain.x + _AutogainDerate);\n    }\n\n    // Downsampled to 24k and 12k samples per second by averaging, limiting frame to prevent overflow\n    vec4 ret = vec4(0.); // [ downsampled 24k mono, native 48k mono, down sampled to 12k mono, difference between left and right at 24k]\n    if( frame < 2046 )\n    {\n        ret.x = (\n            ReadLeft(frame * 2 + 0) + ReadRight(frame * 2 + 0) +\n            ReadLeft(frame * 2 + 1) + ReadRight(frame * 2 + 1) ) / 4.;\n    }\n    if( frame < 4092 )\n    {\n        ret.y = ( ReadLeft(frame) + ReadRight(frame) ) / 2.;\n    }\n    if( frame < 1023 )\n    {\n        ret.z = (\n            ReadLeft(frame * 4 + 0) + ReadRight(frame * 4 + 0) +\n            ReadLeft(frame * 4 + 1) + ReadRight(frame * 4 + 1) +\n            ReadLeft(frame * 4 + 2) + ReadRight(frame * 4 + 2) +\n            ReadLeft(frame * 4 + 3) + ReadRight(frame * 4 + 3) ) / 8.;\n    }\n    if( frame < 2046 )\n    {\n        ret.w = (\n            ReadLeft(frame * 2 + 0) - ReadRight(frame * 2 + 0) +\n            ReadLeft(frame * 2 + 1) - ReadRight(frame * 2 + 1) ) / 4.;\n    }\n\n    return (vec4(_WaveInClampValue) + clamp( ret * incomingGain, -_WaveInClampValue, _WaveInClampValue ))/ (2.* _WaveInClampValue);\n}\n\n//Name \"Pass3AudioLink4Band\"\n//CGPROGRAM\n\nvec4 fraglink (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_AUDIOLINK)\n\n    float audioBands[4];\n    audioBands[0] = _X0; audioBands[1] = _X1; audioBands[2] = _X2; audioBands[3] = _X3;\n    float audioThresholds[4];\n    audioThresholds[0] = _Threshold0; audioThresholds[1] = _Threshold1; audioThresholds[2] = _Threshold2; audioThresholds[3] = _Threshold3;\n    \n    int band = int(min(coordinateLocal.y, uint(3)));\n    int delay = int(coordinateLocal.x);\n    if (delay == 0)\n    {\n        // Get average of samples in the band\n        float total = 0.;\n        uint totalBins = uint(AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT);\n        uint binStart = uint(AudioLinkRemap(audioBands[band], 0., 1., AUDIOLINK_4BAND_FREQFLOOR * float(totalBins), float(AUDIOLINK_4BAND_FREQCEILING) * float(totalBins)));\n        uint binEnd = (band != 3) ? uint(AudioLinkRemap(audioBands[band + 1], 0., 1., AUDIOLINK_4BAND_FREQFLOOR * float(totalBins), float(AUDIOLINK_4BAND_FREQCEILING) * float(totalBins))) : uint(float(AUDIOLINK_4BAND_FREQCEILING) * float(totalBins));\n        float threshold = audioThresholds[band];\n        for (uint i=binStart; i<binEnd; i++)\n        {\n            ivec2 spectrumCoord = ivec2(int(i) % AUDIOLINK_WIDTH, int(i) / AUDIOLINK_WIDTH);\n            float rawMagnitude = AudioLinkGetSelfPixelData(ivec2(ALPASS_DFT) + spectrumCoord).y;\n            total += rawMagnitude;\n        }\n        float magnitude = total / float(binEnd - binStart);\n\n        // Log attenuation\n        magnitude = saturate(magnitude * (log(1.1) / (log(1.1 + pow(_LogAttenuation, 4.) * (1.0 - magnitude))))) / pow(threshold, 2.);\n\n        // Contrast\n        magnitude = saturate(magnitude * tan(1.57 * _ContrastSlope) + magnitude + _ContrastOffset * tan(1.57 * _ContrastSlope) - tan(1.57 * _ContrastSlope));\n\n        // Fade\n        float lastMagnitude = AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(0, band)).y;\n        lastMagnitude -= -1.0 * pow(_FadeLength-1.0, 3.);                                                                            // Inverse cubic remap\n        lastMagnitude = saturate(lastMagnitude * (1.0 + (pow(lastMagnitude - 1.0, 4.0) * _FadeExpFalloff) - _FadeExpFalloff));     // Exp falloff\n\n        magnitude = max(lastMagnitude, magnitude);\n\n        return vec4(magnitude, magnitude, magnitude, 1.);\n\n    // If part of the delay\n    } else {\n        // Slide pixels (coordinateLocal.x > 0)\n        vec4 lastvalTiming = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(4, 1)); // Timing for 4-band, move at 90 Hz.\n        lastvalTiming.x += iTimeDelta * AUDIOLINK_4BAND_TARGET_RATE;\n        uint framesToRoll = uint(floor( lastvalTiming.x ));\n\n        if( framesToRoll == uint(0) )\n        {\n            return AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(coordinateLocal.x, coordinateLocal.y));\n        }\n        else // 1 or more.\n        {\n            if( coordinateLocal.x > framesToRoll )\n            {\n                // For the rest of the line, move by the appropriate speed\n                return AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(coordinateLocal.x - framesToRoll, coordinateLocal.y));\n            }\n            else\n            {\n                // For the first part, extrapolate the cells.\n                float last = length(AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(0, coordinateLocal.y)));\n                float next = length(AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(1, coordinateLocal.y)));\n                float lprev = float(int(coordinateLocal.x) - 1) / float(framesToRoll);\n                return vec4(lerp( last, next, lprev ));\n            }\n        }\n    }\n}\n//Name \"Pass5-VU-Meter-And-Other-Info\"\n//CGPROGRAM\n// The structure of the output is:\n// RED CHANNEL: Peak Amplitude\n// GREEN CHANNEL: RMS Amplitude.\n// BLUE CHANNEL: RESERVED.\n\nvec4 fraggenvu (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_GENERALVU)\n\n    vec2 total = vec2(0.);\n    vec2 peak = vec2(0.);\n\n    // Only VU over 1024 24kSPS samples\n    int i;\n    for( i = 0; i < 1024; i++ )\n    {\n        vec4 audioFrame = AudioLinkGetSelfPixelData(ALPASS_WAVEFORM + uvec2(i % AUDIOLINK_WIDTH, i / AUDIOLINK_WIDTH));\n        vec2 leftright = audioFrame.x + vec2( audioFrame.a, -audioFrame.a );\n        total += leftright * leftright;\n        peak = max(peak, abs(leftright));\n    }\n\n    vec2 RMS = sqrt(total / float(i));\n    \n    vec4 markerValue = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(9, 0));\n    vec4 markerTimes = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(10, 0));\n    vec4 lastAutogain = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(11, 0));\n\n    markerTimes.xyzw += vec4(iTimeDelta);\n    //markerTimes = (markerTimes>1.) ? vec4(-1, -1, -1, -1) : markerTimes;\n    vec4 RMSPeak = vec4( RMS.x, peak.x, RMS.y, peak.y );\n#if 0\n    if(markerValue.x < RMSPeak.x || markerTimes.x > 1. )\n    {\n        markerValue.x = RMSPeak.x;\n        markerTimes.x = 0;\n    }\n    if(markerValue.y < RMSPeak.y || markerTimes.y > 1. )\n    {\n        markerValue.y = RMSPeak.y;\n        markerTimes.y = 0;\n    }\n    if(markerValue.z < RMSPeak.z || markerTimes.z > 1. )\n    {\n        markerValue.z = RMSPeak.z;\n        markerTimes.z = 0;\n    }\n    if(markerValue.w < RMSPeak.w || markerTimes.w > 1.)\n    {\n        markerValue.w = RMSPeak.a;\n        markerTimes.w = 0;\n    }\n#endif\n    \n    bvec4 peakout;\n    vec4Operation(i, {peakout[i] = (markerValue[i] < RMSPeak[i] || markerTimes[i] > 1. );})\n    vec4Operation(i, {if (peakout[i]) markerTimes[i] = 0.;})\n    \n    vec4Operation(i, {markerValue[i] = peakout[i]?RMSPeak[i]:markerValue[i];})\n\n    if( coordinateLocal.y == uint(0) )\n    {\n        if(coordinateLocal.x >= uint(8))\n        {\n            if(coordinateLocal.x == uint(8))\n            {\n                // First pixel: Current value.\n                return RMSPeak;\n            }\n            else if(coordinateLocal.x == uint(9))\n            {\n                // Second pixel: Limit Output\n                return markerValue;\n            }\n            else if(coordinateLocal.x == uint(10))\n            {\n                // Second pixel: Limit time\n                return markerTimes;\n            }\n            else if(coordinateLocal.x == uint(11))\n            {\n                // Third pixel: Auto Gain / Volume Monitor for ColorChord\n\n                // Compensate for the fact that we've already gain'd our samples.\n                float deratePeak = length(peak / (lastAutogain.x + _AutogainDerate));\n\n                if(deratePeak > lastAutogain.x)\n                {\n                    lastAutogain.x = lerp(deratePeak, lastAutogain.x, .5); //Make attack quick\n                }\n                else\n                {\n                    lastAutogain.x = lerp(deratePeak, lastAutogain.x, .995); //Make decay long.\n                }\n\n                lastAutogain.y = lerp(length(peak), lastAutogain.y, 0.95);\n                return lastAutogain;\n            }\n        }\n        else\n        {\n            if(coordinateLocal.x == uint(0))\n            {\n                // Pixel 0 = Version\n                return _VersionNumberAndFPSProperty;\n            }\n            else if(coordinateLocal.x == uint(1))\n            {\n                // Pixel 1 = Frame Count, if we did not repeat, this would stop counting after ~51 hours.\n                // So, instead we just reset it every 24 hours.  Note this is after 24 hours in an instance.\n                // Note: This is also used to measure FPS.\n\n                vec4 lastVal = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(1, 0));\n                float frameCount = lastVal.x;\n                float frameCountFPS = lastVal.y;\n                float frameCountLastFPS = lastVal.z;\n                float lastTimeFPS = lastVal.a;\n                frameCount++;\n                if(frameCount >= 7776000.) //~24 hours.\n                    frameCount = 0.;\n                frameCountFPS++;\n\n                // See if we've been reset.\n                if(lastTimeFPS > iTime)\n                {\n                    lastTimeFPS = 0.;\n                }\n\n                // After one second, take the running FPS and present it as the now FPS.\n                if(iTime > lastTimeFPS + 1.)\n                {\n                    frameCountLastFPS = frameCountFPS;\n                    frameCountFPS = 0.;\n                    lastTimeFPS = iTime;\n                }\n                return vec4(frameCount, frameCountFPS, frameCountLastFPS, lastTimeFPS);\n            }\n            else if(coordinateLocal.x == 2u)\n            {\n                // Output of this is daytime, in milliseconds\n                // This is done a little awkwardly as to prevent any overflows.\n                uint dtms = uint(_AdvancedTimeProps0.x * 1000.);\n                uint dtms2 = uint(_AdvancedTimeProps0.y * 1000.) + (dtms >> 10u);\n                // Specialized implementation, similar to AudioLinkEncodeUInt\n                return vec4(\n                    float(dtms & 0x3ffu),\n                    float((dtms2) & 0x3ffu),\n                    float((dtms2 >> 10u) & 0x3ffu),\n                    float((dtms2 >> 20u) & 0x3ffu)\n                );\n            }\n            else if(coordinateLocal.x == 3u)\n            {\n                // Current time of day, in local time.\n                // Generally this will not exceed 90 million milliseconds. (25 hours)\n                int ftpa = int(_AdvancedTimeProps0.z * 1000.);\n                // Specialized implementation, similar to AudioLinkEncodeUInt\n                return vec4(ftpa & 0x3ff, (ftpa >> 10) & 0x3ff, (ftpa >> 20) & 0x3ff, 0 );\n            }\n            else if(coordinateLocal.x == 4u)\n            {\n                // Time sync'd off of Networking.GetServerTimeInMilliseconds()\n                float fractional = _AdvancedTimeProps1.x;\n                float major = _AdvancedTimeProps1.y;\n                if( major < 0. )\n                    major = 65536. + major;\n                uint currentNetworkTimeMS = (uint(fractional)) | ((uint(major))<<16u);\n                return AudioLinkEncodeUInt(currentNetworkTimeMS);\n            }\n            else if(coordinateLocal.x == 6u)\n            {\n                //.x = Player Count\n                //.y = IsMaster\n                //.z = IsInstanceOwner\n                return vec4( _PlayerCountAndData );\n            }\n            else if(coordinateLocal.x == 7u)\n            {\n                //General Debug Register\n                //Use this for whatever.\n                return vec4( _AdvancedTimeProps0.w, iTimeDelta, markerTimes.y, 1. );\n            }\n        }\n    }\n    else\n    {\n        //Second Row y = 1\n        if( coordinateLocal.x < 4u )\n        {\n            if( _ThemeColorMode == 1 )\n            {\n                if( coordinateLocal.x == 0u ) return _CustomThemeColor0;\n                if( coordinateLocal.x == 1u ) return _CustomThemeColor1;\n                if( coordinateLocal.x == 2u ) return _CustomThemeColor2;\n                if( coordinateLocal.x == 3u ) return _CustomThemeColor3;\n            }\n            else\n            {\n                return AudioLinkGetSelfPixelData(ALPASS_CCCOLORS+uvec2(coordinateLocal.x,0));\n            }\n        }\n        else if( coordinateLocal.x == 4u )\n        {\n            // Computation for history timing.\n            vec4 lastval = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(4, 1)); // Timing for 4-band, move at 90 Hz.\n            lastval.x += iTimeDelta * AUDIOLINK_4BAND_TARGET_RATE;\n            // This looks like a frac() but I want to make sure the math gets done the same here\n            // to prevent any possible mismatch between here and the use of finding the int.\n            int framesToRoll = int(floor( lastval.x ));\n            lastval.x -= float(framesToRoll);\n            return lastval;\n        }\n        else if( coordinateLocal.x == 5u )\n        {\n            // UTC Day number\n            return AudioLinkEncodeUInt(uint(_AdvancedTimeProps1.z));\n        }\n        else if( coordinateLocal.x == 6u )\n        {\n            return AudioLinkEncodeUInt(uint(_AdvancedTimeProps1.w * 1000.));\n        }\n        else if( coordinateLocal.x == 7u)\n        {\n            // Audio Source Position\n            return _SourcePosition;\n        }\n    }\n\n    // Reserved\n    return vec4(0.);\n}\n\nfloat NoteWrap(float note1, float note2)\n{\n    float diff = note2 - note1;\n    diff = glsl_mod(diff, float(AUDIOLINK_EXPBINS));\n    if(diff > float(AUDIOLINK_EXPBINS) / 2.)\n        return diff - float(AUDIOLINK_EXPBINS);\n    else\n        return diff;\n}\n\nvec4 fragccinternal (vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_CCINTERNAL)\n\n    float vuAmplitude = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(8, 0)).y * _Gain;\n    float noteMinimum = 0.00 + 0.1 * vuAmplitude;\n\n    //Note structure:\n    // .x = Note frequency (0...AUDIOLINK_ETOTALBINS, but floating point)\n    // .y = The incoming intensity.\n    // .z = Lagged intensity.         ---> This is what decides if a note is going to disappear.\n    // .w = Quicker lagged intensity.\n\n    //NoteB Structure\n    // .x = Note Number  ::: NOTE if .y < 0 this is the index of where this note _went_ or what note it was joined to.\n    // .y = Time this note has existed.\n    // .z = Sorted-by-frequency position. (With note 0 being the 0th note)\n\n    //Summary:\n    // .x = Total number of notes.\n    // .y .z .w = sum of note's yzw.\n\n    //SummaryB:\n    // .x = Latest note number.\n    // .y = AUDIOLINK_ROOTNOTE\n    // .z = number of populated notes.\n\n    vec4 notes[COLORCHORD_MAX_NOTES];\n    vec4 notesB[COLORCHORD_MAX_NOTES];\n\n    int i;\n    for(i = 0; i < COLORCHORD_MAX_NOTES; i++)\n    {\n        notes[i] = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(i + 1, 0)) * vec4(1, 0, 1, 1);\n        notesB[i] = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(i + 1, 1));\n    }\n\n    vec4 noteSummary = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL);\n    vec4 noteSummaryB = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(0, 1));\n    float lastAmplitude = AudioLinkGetSelfPixelData(ALPASS_DFT + uvec2(AUDIOLINK_EXPBINS, 0)).z;\n    float thisAmplitude = AudioLinkGetSelfPixelData(ALPASS_DFT + uvec2(1 + AUDIOLINK_EXPBINS, 0)).z;\n\n    for(i = AUDIOLINK_EXPBINS + 2; i < COLORCHORD_EMAXBIN; i++)\n    {\n        float nextAmplitude = AudioLinkGetSelfPixelData(ALPASS_DFT + uvec2(i % AUDIOLINK_WIDTH, i / AUDIOLINK_WIDTH)).z;\n        if(thisAmplitude > lastAmplitude && thisAmplitude > nextAmplitude && thisAmplitude > noteMinimum)\n        {\n            // Find actual peak by looking ahead and behind.\n            float diffA = thisAmplitude - nextAmplitude;\n            float diffB = thisAmplitude - lastAmplitude;\n            float noteFreq = glsl_mod(float(i - 1), float(AUDIOLINK_EXPBINS));\n            if(diffA < diffB)\n            {\n                // Behind\n                noteFreq -= 1. - diffA / diffB; //Ratio must be between 0 .. 0.5\n            }\n            else\n            {\n                // Ahead\n                noteFreq += 1. - diffB / diffA;\n            }\n\n            int j;\n            int closestNote = -1;\n            int freeNote = -1;\n            float closestNoteDistance = COLORCHORD_NOTE_CLOSEST;\n\n            // Search notes to see what the closest note to this peak is.\n            // also look for any empty notes.\n            for(j = 0; j < COLORCHORD_MAX_NOTES; j++)\n            {\n                float dist = abs(NoteWrap(notes[j].x, noteFreq));\n                if(notes[j].z <= 0.)\n                {\n                    if(freeNote == -1)\n                        freeNote = j;\n                }\n                else if(dist < closestNoteDistance)\n                {\n                    closestNoteDistance = dist;\n                    closestNote = j;\n                }\n            }\n\n            float thisIntensity = thisAmplitude * COLORCHORD_NEW_NOTE_GAIN;\n\n            if(closestNote != -1)\n            {\n                // Note to combine peak to has been found, roll note in.\n                vec4 n = notes[closestNote];\n                float drag = NoteWrap(n.x, noteFreq) * 0.05;\n\n                float mn = max(n.y, thisAmplitude * COLORCHORD_NEW_NOTE_GAIN)\n                    // Technically the above is incorrect without the below, additional notes found should contribute.\n                    // But I'm finding it looks better w/o it.  Well, the 0.3 is arbitrary.  But, it isn't right to\n                    // only take max.\n                    + thisAmplitude * COLORCHORD_NEW_NOTE_GAIN * 0.3;\n\n                notes[closestNote] = vec4(n.x + drag, mn, n.z, n.w);\n            }\n            else if(freeNote != -1)\n            {\n\n                int jc = 0;\n                int ji = 0;\n                // uuuggghhhh Ok, so this's is probably just me being paranoid\n                // but I really wanted to make sure all note IDs are unique\n                // in case another tool would care about the uniqueness.\n                for(ji = 0; ji < COLORCHORD_MAX_NOTES && jc != COLORCHORD_MAX_NOTES; ji++)\n                {\n                    noteSummaryB.x = noteSummaryB.x + 1.;\n                    if(noteSummaryB.x > 1023.) noteSummaryB.x = 0.;\n                    for(jc = 0; jc < COLORCHORD_MAX_NOTES; jc++)\n                    {\n                        if(notesB[jc].x == noteSummaryB.x)\n                            break;\n                    }\n                }\n\n                // Couldn't find note.  Create a new note.\n                notes[freeNote]  = vec4(noteFreq, thisIntensity, thisIntensity, thisIntensity);\n                notesB[freeNote] = vec4(noteSummaryB.x, iTimeDelta, 0., 0.);\n            }\n            else\n            {\n                // Whelp, the note fell off the wagon.  Oh well!\n            }\n        }\n        lastAmplitude = thisAmplitude;\n        thisAmplitude = nextAmplitude;\n    }\n\n    vec4 newNoteSummary = vec4(0.);\n    vec4 newNoteSummaryB = noteSummaryB;\n    newNoteSummaryB.y = float(AUDIOLINK_ROOTNOTE);\n\n    for(i = 0; i < COLORCHORD_MAX_NOTES; i++)\n    {\n        int j;\n        vec4 n1 = notes[i];\n        vec4 n1B = notesB[i];\n\n        for(j = 0; j < COLORCHORD_MAX_NOTES; j++)\n        {\n            // 🤮 Shader compiler can't do triangular loops.\n            // We don't want to iterate over a cube just compare ith and jth note once.\n\n            vec4 n2 = notes[j];\n\n            if(n2.z > 0. && j > i && n1.z > 0.)\n            {\n                // Potentially combine notes\n                float dist = abs(NoteWrap(n1.x, n2.x));\n                if(dist < COLORCHORD_NOTE_CLOSEST)\n                {\n                    //Found combination of notes.  Nil out second.\n                    float drag = NoteWrap(n1.x, n2.x) * 0.5;//n1.z/(n2.z+n1.y);\n                    n1 = vec4(n1.x + drag, n1.y + thisAmplitude, n1.z, n1.w);\n\n                    //n1B unchanged.\n\n                    notes[j] = vec4(0.);\n                    notesB[j] = vec4(i, -1., 0., 0.);\n                }\n            }\n        }\n\n        #if 0\n        //Old values, framerate-invariant, assumed 60 FPS medium.\n        #define COLORCHORD_IIR_DECAY_1          0.90\n        #define COLORCHORD_IIR_DECAY_2          0.85\n        #define COLORCHORD_CONSTANT_DECAY_1     0.01\n        #define COLORCHORD_CONSTANT_DECAY_2     0.0\n        #else\n        // Calculated from above values using: 0.9 = pow( x, .016666 ), or new_component = x ^ 60\n        float COLORCHORD_IIR_DECAY_1 = pow( 0.0018, iTimeDelta );\n        float COLORCHORD_IIR_DECAY_2 = pow( 5.822e-5, iTimeDelta );\n        float COLORCHORD_CONSTANT_DECAY_1 = (0.01*60.)*iTimeDelta;\n        float COLORCHORD_CONSTANT_DECAY_2 = (0.0*60.)*iTimeDelta;\n        #endif\n        // Filter n1.z from n1.y.\n        if(n1.z >= 0.)\n        {\n            // Make sure we're wrapped correctly.\n            n1.x = glsl_mod(n1.x, float(AUDIOLINK_EXPBINS));\n\n            // Apply filtering\n            n1.z = lerp(n1.y, n1.z, COLORCHORD_IIR_DECAY_1) - COLORCHORD_CONSTANT_DECAY_1; //Make decay slow.\n            n1.w = lerp(n1.y, n1.w, COLORCHORD_IIR_DECAY_2) - COLORCHORD_CONSTANT_DECAY_2; //Make decay slow.\n\n            n1B.y += iTimeDelta;\n\n\n            if(n1.z < noteMinimum)\n            {\n                n1 = vec4(-1.);\n                n1B = vec4(0.);\n            }\n            //XXX TODO: Do uniformity calculation on n1 for n1.w.\n        }\n\n        if(n1.z >= 0.)\n        {\n            // Compute Y to create a \"unified\" value.  This is good for understanding\n            // the ratio of how \"important\" this note is.\n            n1.y = pow(max(n1.z - noteMinimum*10., 0.), 1.5);\n\n            newNoteSummary += vec4(1., n1.y, n1.z, n1.w);\n        }\n\n        notes[i] = n1;\n        notesB[i] = n1B;\n    }\n\n    // Sort by frequency and count notes.\n    // These loops are phrased funny because the unity shader compiler gets really\n    // confused easily.\n    float sortedNoteSlotValue = -1000.;\n    newNoteSummaryB.z = 0.;\n\n    for(i = 0; i < COLORCHORD_MAX_NOTES; i++)\n    {\n        //Count notes\n        newNoteSummaryB.z += (notes[i].z > 0.) ? 1. : 0.;\n\n        float closestToSlotWithoutGoingOver = 100.;\n        int sortID = -1;\n        int j;\n        for(j = 0; j < COLORCHORD_MAX_NOTES; j++)\n        {\n            vec4 n2 = notes[j];\n            float noteFreqB = glsl_mod(-notes[0].x + 0.5 + n2.x , float(AUDIOLINK_EXPBINS));\n            if(n2.z > 0. && noteFreqB > sortedNoteSlotValue && noteFreqB < closestToSlotWithoutGoingOver)\n            {\n                closestToSlotWithoutGoingOver = noteFreqB;\n                sortID = j;\n            }\n        }\n        sortedNoteSlotValue = closestToSlotWithoutGoingOver;\n        notesB[i] = notesB[i] * vec4(1, 1, 0, 1) + vec4(0, 0, sortID, 0);\n    }\n    // PIXEL LAYOUT:\n    //  Summary / Data[COLORCHORD_MAX_NOTES] / 0 / 0 / Colors[COLORCHORD_MAX_NOTES] / 0\n    // We now have a condensed list of all notes that are playing.\n    if( coordinateLocal.x < uint(COLORCHORD_MAX_NOTES)+1u )\n    {\n        if( coordinateLocal.x == 0u )\n        {\n            // Summary note.\n            return (coordinateLocal.y != 0u) ? newNoteSummaryB : newNoteSummary;\n        }\n        else\n        {\n            // Actual Note Data\n            return (coordinateLocal.y != 0u) ? notesB[coordinateLocal.x - 1u] : notes[coordinateLocal.x - 1u];\n        }\n    }\n    else if( coordinateLocal.x >= uint(COLORCHORD_MAX_NOTES+3) && coordinateLocal.x < uint(COLORCHORD_MAX_NOTES*2+4) && coordinateLocal.y == 0u )\n    {\n        uint id = coordinateLocal.x - uint(COLORCHORD_MAX_NOTES+2);\n        vec4 ThisNote = notes[id];\n        const float AudioLinkColorOutputIntensity = 0.4;\n        return vec4( AudioLinkCCtoRGB( glsl_mod(ThisNote.x,float(AUDIOLINK_EXPBINS)), ThisNote.z * AudioLinkColorOutputIntensity, AUDIOLINK_ROOTNOTE), 1.0 );\n    }\n    return vec4(0.);\n}\n\n// Name \"Pass7-AutoCorrelator\"\n// CGPROGRAM\n\n#define AUTOCORRELATOR_EMAXBIN 120\n#define AUTOCORRELATOR_EBASEBIN 0\n\nvec4 fragautocorr (in vec2 IN) \n{\n    AUDIO_LINK_ALPHA_START(ALPASS_AUTOCORRELATOR)\n\n    float wavePosition = float(coordinateLocal.x);\n    vec2 fvTotal = vec2(0.);\n    float fvr = 15.;\n\n    // This computes both the regular autocorrelator in the R channel\n    // as well as a uncorrelated autocorrelator in the G channel\n    int i;\n    for(i = AUTOCORRELATOR_EBASEBIN; i < AUTOCORRELATOR_EMAXBIN; i++)\n    {\n        float bin = AudioLinkGetSelfPixelData(ALPASS_DFT + uvec2(i % AUDIOLINK_WIDTH, i / AUDIOLINK_WIDTH)).z;\n        float frequency = pow(2., float(i) / 24.) * AUDIOLINK_BOTTOM_FREQUENCY / float(AUDIOLINK_SPS) * UNITY_TWO_PI;\n        vec2 csv = vec2(cos(frequency * wavePosition * fvr),  cos(frequency * wavePosition * fvr + float(i) * 0.32));\n        csv.y *= step(float(i % 4), 1.) * 4.;\n        fvTotal += csv * (bin * bin);\n    }\n\n    // Red:   Regular autocorrelator\n    // Green: Uncorrelated autocorrelator\n    // Blue:  Reserved\n    return vec4(fvTotal, 0, 1);\n}\n\n// Name \"Pass8-ColorChord-Linear\"\n// CGPROGRAM\n\nvec4 fragstrip (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_CCSTRIP)\n\n    int p;\n\n    const float Brightness = .3;\n    const float RootNote = 0.;\n\n    vec4 NotesSummary = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL);\n\n    float TotalPower = 0.0;\n    TotalPower = NotesSummary.y;\n\n    float PowerPlace = 0.0;\n    for(p = 0; p < COLORCHORD_MAX_NOTES; p++)\n    {\n        vec4 NotesB = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(1 + p, 1));\n        vec4 Peak = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(1. + NotesB.z, 0));\n        if(Peak.y <= 0.) continue;\n\n        float Power = Peak.y/TotalPower;\n        PowerPlace += Power;\n        if(PowerPlace >= IN.x)\n        {\n            return vec4(AudioLinkCCtoRGB(Peak.x, Peak.w*Brightness, AUDIOLINK_ROOTNOTE), 1.0);\n        }\n    }\n\n    return vec4(0., 0., 0., 1.);\n}\n\n// Name \"Pass9-ColorChord-Lights\"\n// CGPROGRAM\n\nconst float _PickNewSpeed = 1.0;\n\nfloat tinyrand(vec3 uvw)\n{\n    return fract(cos(dot(uvw, vec3(137.945, 942.32, 593.46))) * 442.5662);\n}\n\nfloat SetNewCellValue(float a)\n{\n    return a*.5;\n}\n\nvec4 fraglights(in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_CCLIGHTS)\n\n    vec4 NotesSummary = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL);\n\n    #define NOTESUFFIX(n) n.y       //was pow(n.z, 1.5)\n\n    vec4 ComputeCell = AudioLinkGetSelfPixelData(ALPASS_CCLIGHTS + uvec2(coordinateLocal.x, 1));\n    //ComputeCell\n    //    .x = Mated Cell # (Or -1 for black)\n    //    .y = Minimum Brightness Before Jump\n    //    .z = ???\n\n    vec4 ThisNote = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(int(ComputeCell.x) + 1, 0));\n    //  Each element:\n    //   R: Peak Location (Note #)\n    //   G: Peak Intensity\n    //   B: Calm Intensity\n    //   A: Other Intensity\n\n    ComputeCell.y -= _PickNewSpeed * 0.01;\n\n    if(NOTESUFFIX(ThisNote) < ComputeCell.y || ComputeCell.y <= 0. || ThisNote.z < 0.)\n    {\n        //Need to select new cell.\n        float min_to_acquire = tinyrand(vec3(coordinateLocal.xy, iTime));\n\n        int n;\n        vec4 SelectedNote = vec4(0.);\n        int SelectedNoteNo = -1;\n\n        float cumulative = 0.0;\n        for(n = 0; n < COLORCHORD_MAX_NOTES; n++)\n        {\n            vec4 Note = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(n + 1, 0));\n            float unic = NOTESUFFIX(Note);\n            if(unic > 0.)\n                cumulative += unic;\n        }\n\n        float sofar = 0.0;\n        for(n = 0; n < COLORCHORD_MAX_NOTES; n++)\n        {\n            vec4 Note = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(n + 1, 0));\n            float unic = NOTESUFFIX(Note);\n            if( unic > 0. )\n            {\n                sofar += unic;\n                if(sofar/cumulative > min_to_acquire)\n                {\n                    SelectedNote = Note;\n                    SelectedNoteNo = n;\n                    break;\n                }\n            }\n        }\n\n        if(SelectedNote.z > 0.0)\n        {\n            ComputeCell.x = float(SelectedNoteNo);\n            ComputeCell.y = SetNewCellValue(NOTESUFFIX(SelectedNote));\n        }\n        else\n        {\n            ComputeCell.x = 0.;\n            ComputeCell.y = 0.;\n        }\n    }\n\n    ThisNote = AudioLinkGetSelfPixelData(ALPASS_CCINTERNAL + uvec2(ComputeCell.x + 1., 0.));\n\n    if(float(coordinateLocal.y) < 0.5)\n    {\n        // the light color output\n        if(ComputeCell.y <= 0.)\n        {\n            return vec4(0.);\n        }\n\n        //XXX TODO: REVISIT THIS!! Ths is an arbitrary value!\n        float intensity = ThisNote.w/3.;\n        return vec4(AudioLinkCCtoRGB(glsl_mod(ThisNote.x,float(AUDIOLINK_EXPBINS)),intensity, AUDIOLINK_ROOTNOTE), 1.0);\n    }\n    else\n    {\n        // the compute output\n        return ComputeCell;\n    }\n}\n\n// Name \"Filtered-AudioLinkOutput\"\n// CGPROGRAM\nvec4 fragfilteraudio (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_FILTEREDAUDIOLINK)\n    vec4 AudioLinkBase = AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(0, coordinateLocal.y));\n    if( coordinateLocal.x < 16u )\n    {\n        // For pixels 0..15, filtered output.\n        vec4 Previous = AudioLinkGetSelfPixelData(ALPASS_FILTEREDAUDIOLINK + uvec2(coordinateLocal.x, coordinateLocal.y));\n        return lerp( AudioLinkBase, Previous, pow( pow(.55, iTimeDelta ), float(coordinateLocal.x+1u) ) ); //IIR-Filter\n    }\n    else if( coordinateLocal.x >= 16u &&  coordinateLocal.x < 24u )\n    {\n        // This section is for ALPASS_CHRONOTENSITY\n        uvec4 rpx = uvec4(AudioLinkGetSelfPixelData(coordinateGlobal.xy));\n\n        float ComparingValue = length((coordinateLocal.x & 1u) != 0u ? \n            AudioLinkGetSelfPixelData(ALPASS_FILTEREDAUDIOLINK + uvec2(4, coordinateLocal.y)) :\n            AudioLinkBase);\n\n        //Get a heavily filtered value to compare against.\n        float FilteredAudioLinkValue = length(AudioLinkGetSelfPixelData(ALPASS_FILTEREDAUDIOLINK + uvec2( 0, coordinateLocal.y ) ));\n        \n        float DifferentialValue = ComparingValue - FilteredAudioLinkValue;\n\n        float ValueDiff;\n\n        int mode = int(( coordinateLocal.x - 16u ) / 2u);\n\n        // Chronotensity is organized in a (4x2)x4 grid of accumulated values.\n        // Y is which band we are using.  X is as follows:\n        //\n        // x = 0, 1: Accumulates as a function of intensity of band.\n        //           The louder the band, the quicker the function increments.\n        // x = 0: Difference between base and heavily filtered.\n        // x = 1: Difference between slightly filtered and heavily filtered.\n        //\n        // x = 2, 3: Goes positive when band is higher, negative when lower.\n        // x = 2: Difference between base and heavily filtered.\n        // x = 3: Difference between slightly filtered and heavily filtered.\n        //\n        // x = 4, 5: Increments when respective filtered value is 0 or negative.\n        // x = 4: Difference between base and heavily filtered.\n        // x = 5: Difference between slightly filtered and heavily filtered.\n        //\n        // x = 6: Unfiltered, increments when band is above 0.05 threshold.\n        // x = 7: Unfiltered, increments when band is below 0.05 threshold.\n\n        if( mode == 0 )\n        {\n            ValueDiff = max( DifferentialValue, 0. );\n        }\n        else if( mode == 1 )\n        {\n            ValueDiff = DifferentialValue;\n        }\n        else if( mode == 2 )\n        {\n            ValueDiff = max( -DifferentialValue, 0. );\n        }\n        else\n        {\n            if( (coordinateLocal.x & 1u) != 0u)\n                ValueDiff = length(max((-(AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2( 0, coordinateLocal.y ) ) - vec4(0.05) )), 0. )*2.);\n            else\n                ValueDiff = length(max(((AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2( 0, coordinateLocal.y ) ) - 0.05 )), vec4(0) )*.5);\n        }\n        \n        uint Value = rpx.x + rpx.y * 1024u + rpx.z * 1048576u + rpx.w * 1073741824u;\n        Value += uint(ValueDiff * iTimeDelta * 1048576.);\n\n        return AudioLinkEncodeUInt(Value);\n    }\n    else\n    {\n        // Other features.\n        return vec4(0);\n    }\n}\n\n// Name \"Pass11-Filtered-VU\"\n// CGPROGRAM\nvec4 fragfilter (in vec2 IN, in vec4 OUT)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_FILTEREDVU)\n    if( coordinateLocal.x < 4u )\n    {\n        vec4 prev = AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + coordinateLocal.xy);\n        vec4 RMSPeak = AudioLinkGetSelfPixelData(ALPASS_GENERALVU + uvec2(8, 0));\n        vec4 lastFilteredRMSPeak = AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + uvec2(coordinateLocal.x, 0));\n        vec4 filteredRMSPeak = vec4(lerp(RMSPeak, lastFilteredRMSPeak, pow(pow(.046,iTimeDelta), float(coordinateLocal.x+1u))).x);\n\n        vec4 markerValue = AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + uvec2(coordinateLocal.x, 2));\n        vec4 timerValue = AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + uvec2(coordinateLocal.x, 3));\n        bvec4 peak;\n        vec4Operation(i, {filteredRMSPeak[i] > markerValue[i] || timerValue[i] > 0.5;})\n        // Filtered VU intensity\n        if(coordinateLocal.y == 0u)\n        {\n            return filteredRMSPeak;\n        }\n        // Filtered VU marker\n        else if (coordinateLocal.y == 1u)\n        {\n            // For linear fallof (we use exp now)\n            /*vec4 res =\n                abs(prev - markerValue) <= 0.01\n                    ? markerValue\n                    : prev < markerValue\n                        ? prev + 0.01 \n                        : prev - 0.01;*/\n\n            vec4 speed;\n            vec4Operation(i, {speed[i] = lerp(0.1, 0.05, abs(prev[i] - markerValue[i]));})\n            vec4 res;\n            vec4Operation(i, {res[i] = lerp(prev[i], markerValue[i], speed[i]);})\n            return max(filteredRMSPeak, res);\n        }\n        // VU markers values\n        else if (coordinateLocal.y == 2u)\n        {\n            vec4 res2;\n            vec4Operation(i, {res2[i] = peak[i] ? filteredRMSPeak[i] : markerValue[i];})\n            return res2;\n        }\n        // VU marker timers\n        else if (coordinateLocal.y == 3u)\n        {\n            vec4 res2;\n            vec4Operation(i, {res2[i] = peak[i] ? 0. : prev[i] + iTimeDelta;})\n            return res2;\n        }\n    }\n    else if (coordinateLocal.x == 4u)\n    {\n        // PEMA\n    }\n    else\n    {\n        // BEAT DETECTION STILL IN EARLY DEVELOPMENT - DO NOT USE\n        vec4 prev = AudioLinkGetSelfPixelData(coordinateGlobal.xy);\n        if( coordinateLocal.x == 5u )\n        {\n            float nowv = length(AudioLinkGetSelfPixelData(ALPASS_AUDIOLINK + uvec2(0, coordinateLocal.y)));\n            float beatdist = 0.;\n            if( prev.x > prev.y && prev.x > nowv )\n            {\n                beatdist = prev.z;\n                prev.z = 0.;\n            }\n            return vec4( nowv, prev.x, prev.z+1., beatdist );\n        }\n        else if( coordinateLocal.x == 6u )\n        {\n            uint y = coordinateLocal.y;\n            // for y = 0..3, each in decreasing levels of forced confidence\n            // used to enact a change on the one above.\n\n            for( int ib = 0; ib < 4; ib++ )\n            {\n                int beat = int(AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + uvec2( 4, ib ) ).x);\n                // Anywhere beat is nonzero is a data point.\n            }\n        }\n        else\n        {\n            vec4 this_bd_data = AudioLinkGetSelfPixelData(ALPASS_FILTEREDVU + uvec2(4, coordinateLocal.y));\n            //Assume beats in the range of 80..160 BPM only.\n        }\n    }\n    return OUT;\n}\n\n// Name \"Pass12-Global-Strings\"\n// CGPROGRAM\nvec4 fragstr (in vec2 IN)\n{\n    AUDIO_LINK_ALPHA_START(ALPASS_GLOBAL_STRINGS)\n    vec4 char4 = vec4(0.);\n    if (coordinateLocal.y == 0u) {\n        char4 = _StringLocalPlayer[coordinateLocal.x];\n    }\n    else if (coordinateLocal.y == 1u) {\n        char4 = _StringMasterPlayer[coordinateLocal.x];\n    }\n    else if (coordinateLocal.y == 2u) {\n        char4 = _StringCustom1[coordinateLocal.x];\n    } \n    else {\n        char4 = _StringCustom2[coordinateLocal.x];\n    }\n    return char4;\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    executeWhen(I, ALPASS_DFT, uvec2(AUDIOLINK_WIDTH,2)) O = frag(I, O);\n    executeWhen(I, ALPASS_WAVEFORM, uvec2(AUDIOLINK_WIDTH,16)) O = fragwave(I);\n    executeWhen(I, ALPASS_AUDIOLINK, uvec2(AUDIOLINK_WIDTH,4)) O = fraglink(I);\n    executeWhen(I, ALPASS_GENERALVU, uvec2(12,1)) O = fraggenvu(I);\n    executeWhen(I, ALPASS_CCINTERNAL, uvec2(12,2)) O = fragccinternal(I);\n    executeWhen(I, ALPASS_AUTOCORRELATOR, uvec2(AUDIOLINK_WIDTH,1)) O = fragautocorr(I);\n    executeWhen(I, ALPASS_CCSTRIP, uvec2(AUDIOLINK_WIDTH,1)) O = fragstrip(I);\n    executeWhen(I, ALPASS_CCLIGHTS, uvec2(AUDIOLINK_WIDTH,2)) O = fraglights(I);\n    executeWhen(I, ALPASS_FILTEREDAUDIOLINK, uvec2(16,4)) O = fragfilteraudio(I);\n    executeWhen(I, ALPASS_FILTEREDVU, uvec2(4,4)) O = fragfilter(I, O);\n    executeWhen(I, ALPASS_GLOBAL_STRINGS, uvec2(8,4)) O = fragstr(I);\n}\n", "buffer_a_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifndef AUDIOLINK_CGINC_INCLUDED\n#define AUDIOLINK_CGINC_INCLUDED\n// Map of where features in AudioLink are.\n#define ALPASS_DFT                      uvec2(0,4)  //Size: 128, 2\n#define ALPASS_WAVEFORM                 uvec2(0,6)  //Size: 128, 16\n#define ALPASS_AUDIOLINK                uvec2(0,0)  //Size: 128, 4\n#define ALPASS_AUDIOBASS                uvec2(0,0)  //Size: 128, 1\n#define ALPASS_AUDIOLOWMIDS             uvec2(0,1)  //Size: 128, 1\n#define ALPASS_AUDIOHIGHMIDS            uvec2(0,2)  //Size: 128, 1\n#define ALPASS_AUDIOTREBLE              uvec2(0,3)  //Size: 128, 1\n#define ALPASS_AUDIOLINKHISTORY         uvec2(1,0)  //Size: 127, 4\n#define ALPASS_GENERALVU                uvec2(0,22) //Size: 12, 1\n#define ALPASS_GENERALVU_INSTANCE_TIME  uvec2(2,22)\n#define ALPASS_GENERALVU_LOCAL_TIME     uvec2(3,22)\n#define ALPASS_GENERALVU_NETWORK_TIME   uvec2(4,22)\n#define ALPASS_GENERALVU_PLAYERINFO     uvec2(6,22)\n#define ALPASS_THEME_COLOR0             uvec2(0,23)\n#define ALPASS_THEME_COLOR1             uvec2(1,23)\n#define ALPASS_THEME_COLOR2             uvec2(2,23)\n#define ALPASS_THEME_COLOR3             uvec2(3,23)\n#define ALPASS_GENERALVU_UNIX_DAYS      uvec2(5,23)\n#define ALPASS_GENERALVU_UNIX_SECONDS   uvec2(6,23)\n#define ALPASS_GENERALVU_SOURCE_POS     uvec2(7,23)\n\n#define ALPASS_CCINTERNAL               uvec2(12,22) //Size: 12, 2\n#define ALPASS_CCCOLORS                 uvec2(25,22) //Size: 12, 1 (Note Color #0 is always black, Colors start at 1)\n#define ALPASS_CCSTRIP                  uvec2(0,24)  //Size: 128, 1\n#define ALPASS_CCLIGHTS                 uvec2(0,25)  //Size: 128, 2\n#define ALPASS_AUTOCORRELATOR           uvec2(0,27)  //Size: 128, 1\n#define ALPASS_FILTEREDAUDIOLINK        uvec2(0,28)  //Size: 16, 4\n#define ALPASS_CHRONOTENSITY            uvec2(16,28) //Size: 8, 4\n#define ALPASS_FILTEREDVU               uvec2(24,28) //Size: 4, 4\n#define ALPASS_FILTEREDVU_INTENSITY     uvec2(24,28) //Size: 4, 1\n#define ALPASS_FILTEREDVU_MARKER        uvec2(24,29) //Size: 4, 1\n#define ALPASS_GLOBAL_STRINGS           uvec2(40,28) //Size: 8, 4\n\n// Some basic constants to use (Note, these should be compatible with\n// future version of AudioLink, but may change.\n#define AUDIOLINK_SAMPHIST              3069        // Internal use for algos, do not change.\n#define AUDIOLINK_SAMPLEDATA24          2046\n#define AUDIOLINK_EXPBINS               24\n#define AUDIOLINK_EXPOCT                10\n#define AUDIOLINK_ETOTALBINS            (AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT)\n#define AUDIOLINK_WIDTH                 512\n#define AUDIOLINK_SPS                   44100       // Samples per second\n#define AUDIOLINK_ROOTNOTE              0\n#define AUDIOLINK_4BAND_FREQFLOOR       0.123\n#define AUDIOLINK_4BAND_FREQCEILING     1\n#define AUDIOLINK_BOTTOM_FREQUENCY      13.75\n#define AUDIOLINK_BASE_AMPLITUDE        2.5\n#define AUDIOLINK_DELAY_COEFFICIENT_MIN 0.3\n#define AUDIOLINK_DELAY_COEFFICIENT_MAX 0.9\n#define AUDIOLINK_DFT_Q                 4.0\n#define AUDIOLINK_TREBLE_CORRECTION     10.0\n#define AUDIOLINK_4BAND_TARGET_RATE     90.0\n\n// Text constants\n#define AUDIOLINK_STRING_MAX_CHARS      32\n#define AUDIOLINK_STRING_LOCALPLAYER    0\n#define AUDIOLINK_STRING_MASTER         1\n#define AUDIOLINK_STRING_CUSTOM1        2\n#define AUDIOLINK_STRING_CUSTOM2        3\n\n// ColorChord constants\n#define COLORCHORD_EMAXBIN              192\n#define COLORCHORD_NOTE_CLOSEST         3.0\n#define COLORCHORD_NEW_NOTE_GAIN        8.0\n#define COLORCHORD_MAX_NOTES            10\n\n// We use glsl_mod for most calculations because it behaves better\n// on negative numbers, and in some situations actually outperforms\n// HLSL's modf().\n#ifndef glsl_mod\n#define glsl_mod(x,y) (((x)-(y)*floor((x)/(y))))\n#endif\n\n#define UNITY_TWO_PI (3.141592653589*2.)\n#define saturate(x) clamp(x,0.,1.)\n\nuniform vec4               _AudioTexture_TexelSize;\n\n#ifdef SHADER_TARGET_SURFACE_ANALYSIS\n#define AUDIOLINK_STANDARD_INDEXING\n#endif\n\nbool inside(uvec2 v, uvec2 pos, uvec2 size)\n{\n    uvec2 pos2 = pos + size;\n    return v.x >= pos.x && v.y >= pos.y && v.x < pos2.x && v.y < pos2.y;\n}\n\n#define executeWhen(fragCoord, pos, size) if (inside(uvec2(fragCoord), uvec2(pos), uvec2(size)))\n#define aexecuteWhen(fragCoord, pos, size) //if (inside(uvec2(fragCoord), uvec2(pos), uvec2(size)))\n\nvec4 lerp(vec4 v1, vec4 v2, float f)\n{\n    return vec4(\n        smoothstep(v1.r, v2.r, f),\n        smoothstep(v1.g, v2.g, f),\n        smoothstep(v1.b, v2.b, f),\n        smoothstep(v1.a, v2.a, f)\n    );\n}\n\nvec3 lerp(vec3 v1, vec3 v2, float f)\n{\n    return vec3(\n        smoothstep(v1.r, v2.r, f),\n        smoothstep(v1.g, v2.g, f),\n        smoothstep(v1.b, v2.b, f)\n    );\n}\n\nvec2 lerp(vec2 v1, vec2 v2, float f)\n{\n    return vec2(\n        smoothstep(v1.r, v2.x, f),\n        smoothstep(v1.g, v2.y, f)\n    );\n}\n\nfloat lerp(float v1, float v2, float f)\n{\n    return smoothstep(v1, v2, f);\n}\n\n\n//Tests to see if Audio Link texture is available\nbool AudioLinkIsAvailable()\n{\n    return true;\n    // #if !defined(AUDIOLINK_STANDARD_INDEXING)\n    //     int width, height;\n    //     _AudioTexture.GetDimensions(width, height);\n    //     return width > 16;\n    // #else\n    //     return _AudioTexture_TexelSize.z > 16;\n    // #endif\n}\n\n\n#define ALDecodeDataAsSeconds( x ) AudioLinkDecodeDataAsSeconds( x )\n#define ALDecodeDataAsUInt( x ) AudioLinkDecodeDataAsUInt( x )\n#define vec4Operation(i,oper) for (int i = 0; i < 4; ++i) oper\n\nfloat AudioLinkRemap(float t, float a, float b, float u, float v) { return ((t-a) / (b-a)) * (v-u) + u; }\n\nvec3 AudioLinkHSVtoRGB(vec3 HSV)\n{\n    vec3 RGB = vec3(0.);\n    float C = HSV.z * HSV.y;\n    float H = HSV.x * 6.;\n    float X = C * (1. - abs(mod(H, 2.) - 1.));\n    if (HSV.y != 0.)\n    {\n        float I = floor(H);\n        if (I == 0.) { RGB = vec3(C, X, 0.); }\n        else if (I == 1.) { RGB = vec3(X, C, 0.); }\n        else if (I == 2.) { RGB = vec3(0., C, X); }\n        else if (I == 3.) { RGB = vec3(0., X, C); }\n        else if (I == 4.) { RGB = vec3(X, 0., C); }\n        else { RGB = vec3(C, 0., X); }\n    }\n    float M = HSV.z - C;\n    return RGB + M;\n}\n\nvec3 AudioLinkCCtoRGB(float bin, float intensity, int rootNote)\n{\n    float note = bin / float(AUDIOLINK_EXPBINS);\n\n    float hue = 0.0;\n    note *= 12.0;\n    note = glsl_mod(4. - note + float(rootNote), 12.0);\n    {\n        if(note < 4.0)\n        {\n            //Needs to be YELLOW->RED\n            hue = (note) / 24.0;\n        }\n        else if(note < 8.0)\n        {\n            //            [4]  [8]\n            //Needs to be RED->BLUE\n            hue = (note-2.0) / 12.0;\n        }\n        else\n        {\n            //             [8] [12]\n            //Needs to be BLUE->YELLOW\n            hue = (note - 4.0) / 8.0;\n        }\n    }\n    float val = intensity - 0.1;\n    return AudioLinkHSVtoRGB(vec3(mod(hue, 1.0), 1.0, clamp(val, 0.0, 1.0)));\n}\n\nstruct Slider\n{\n    float val;\n    float fmin;\n    float fmax;\n};\n\n\n\nvec3 sliderToVec(Slider val)\n{\n    return vec3(val.val, val.fmin, val.fmax);\n}\n\nSlider vecToSlider(vec3 val)\n{\n    Slider s;\n    s.val = val.r;\n    s.fmin = val.g;\n    s.fmax = val.b;\n    return s;\n}\n\nstruct Drag\n{\n    uint selectedID;\n    vec2 start;\n    vec2 last;\n    \n};\n\nstruct Zones\n{\n    Slider x0;\n    Slider x1;\n    Slider x2;\n    Slider x3;\n    Slider t0;\n    Slider t1;\n    Slider t2;\n    Slider t3;\n    \n};\n\nZones initZones()\n{\n    Zones z;\n    z.x0 = Slider(0., 0., 0.168);\n    z.x1 = Slider(0.38, 0.242, 0.387);\n    z.x2 = Slider(0.62, 0.461, 0.628);\n    z.x3 = Slider(0.8, 0.704, 0.953);\n    z.t0 = Slider(0.35, 0., 1.);\n    z.t1 = Slider(0.15, 0., 1.);\n    z.t2 = Slider(0.2, 0., 1.);\n    z.t3 = Slider(0.21, 0., 1.);\n    return z;\n}\n/*Zones initZones()\n{\n    Zones z;\n    z.x0 = Slider(0., 0., 0.15);\n    z.x1 = Slider(0.38, 0.02, 0.387);\n    z.x2 = Slider(0.62, 0.06, 0.628);\n    z.x3 = Slider(0.8, 0.2, 0.953);\n    z.t0 = Slider(0.35, 0., 1.);\n    z.t1 = Slider(0.15, 0., 1.);\n    z.t2 = Slider(0.2, 0., 1.);\n    z.t3 = Slider(0.21, 0., 1.);\n    return z;\n}*/\n\nconst float lineThickness = 5.;\n\n\n#define T0COLOR vec3(0.43359375, 0.40234375, 0.87109375)\n#define T1COLOR vec3(0.87109375, 0.40234375, 0.6015625)\n#define T2COLOR vec3(0.8359375, 0.87109375, 0.40234375)\n#define T3COLOR vec3(0.40234375, 0.87109375, 0.671875)\n\n#define AudioLinkGetSelfPixelData(xy) texelFetch(iChannel0, ivec2(xy),0)\n\n#define compare(v1,v2,thresh) (abs(v1-v2) <= thresh)\n\n#define inRange(v,fmin,fmax) (fmin <= v && v < fmax)\n\nvoid encode(inout vec4 O, in vec2 I, in vec3 v, inout int i)\n{\n    if (int(floor(I.x)) == i++)\n    {\n        O = vec4(v, 0.);\n    }\n}\n\nvoid encode(inout vec4 O, in vec2 I, in Slider v, inout int i)\n{\n    encode(O, I, sliderToVec(v), i);\n}\n\nvoid encode(inout vec4 O, in vec2 I, in Zones z, inout int i)\n{\n    encode(O, I, z.x0, i);\n    encode(O, I, z.x1, i);\n    encode(O, I, z.x2, i);\n    encode(O, I, z.x3, i);\n    encode(O, I, z.t0, i);\n    encode(O, I, z.t1, i);\n    encode(O, I, z.t2, i);\n    encode(O, I, z.t3, i);\n}\n\nvoid decodeVec3(sampler2D tex, out vec3 v, inout int i)\n{\n    v.rgb = texelFetch(tex, ivec2(i++,0),0).rgb;\n}\n\nvoid decodeSlider(sampler2D tex, out Slider v, inout int i)\n{\n    vec3 c;\n    decodeVec3(tex,c,i);\n    v = vecToSlider(c);\n}\n\nvoid decodeZones(sampler2D tex, out Zones z, inout int i)\n{\n    decodeSlider(tex, z.x0, i);\n    decodeSlider(tex, z.x1, i);\n    decodeSlider(tex, z.x2, i);\n    decodeSlider(tex, z.x3, i);\n    decodeSlider(tex, z.t0, i);\n    decodeSlider(tex, z.t1, i);\n    decodeSlider(tex, z.t2, i);\n    decodeSlider(tex, z.t3, i);\n}\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_code": "// Mechanism to index into texture.\n#ifdef AUDIOLINK_STANDARD_INDEXING\n    sampler2D _AudioTexture;\n    #define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, vec4(uvec2(xycoord) * _AudioTexture_TexelSize.xy, 0., 0.))\n#else\n    #define _AudioTexture iChannel0\n    #define AudioLinkData(xycoord) texelFetch(_AudioTexture, ivec2(xycoord), 0)\n#endif\n\nvoid vertiClickEvent(inout Slider s, vec2 pos, float r)\n{\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    if (abs(length(pos-mousePos)) < r/iResolution.x)\n    {\n        s.val = min(max(s.fmin, mousePos.x), s.fmax);\n    }\n}\n\nvoid horizClickEvent(inout Slider s, vec2 pos, float r)\n{\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    if (abs(length(pos-mousePos)) < r/iResolution.y)\n    {\n        s.val = min(max(s.fmin, mousePos.y), s.fmax);\n    }\n}\n\n\n\n// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.\nvec4 AudioLinkDataMultiline(uvec2 xycoord) { return AudioLinkData(uvec2(xycoord.x % uint(AUDIOLINK_WIDTH), xycoord.y + xycoord.x/uint(AUDIOLINK_WIDTH))); }\n\n// Mechanism to sample between two adjacent pixels and lerp between them, like \"linear\" supesampling\nvec4 AudioLinkLerp(vec2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(ivec2(xy)+ivec2(1,0)), fract( xy.x ) ); }\n\n// Same as AudioLinkLerp but properly handles multiline reading.\nvec4 AudioLinkLerpMultiline(vec2 xy) { return lerp(AudioLinkDataMultiline(uvec2(xy)), AudioLinkDataMultiline(uvec2(xy+vec2(1.,0.))), fract(xy.x)); }\n\n\n\n//Get version of audiolink present in the world, 0 if no audiolink is present\nfloat AudioLinkGetVersion()\n{\n    ivec2 dims = ivec2(iResolution.xy);\n    /*#if !defined(AUDIOLINK_STANDARD_INDEXING)\n        _AudioTexture.GetDimensions(dims.x, dims.y);\n    #else\n        dims = _AudioTexture_TexelSize.zw;\n    #endif*/\n\n    if (dims.x >= 128)\n        return float(AudioLinkData(ALPASS_GENERALVU).x);\n    else if (dims.x > 16)\n        return 1.;\n    else\n        return 0.;\n}\n\n// This pulls data from this texture.\n#ifndef AudioLinkGetSelfPixelData\n    #define AudioLinkGetSelfPixelData(xy) texelFetch(_SelfTexture2D, ivec2(xy),0)\n#endif\n\n// Extra utility functions for time.\nuint AudioLinkDecodeDataAsUInt(uvec2 indexloc)\n{\n    uvec4 rpx = uvec4(AudioLinkData(indexloc));\n    return rpx.x + rpx.y*uint(1024) + rpx.z * uint(1048576) + rpx.w * uint(1073741824);\n}\n\n\n\n\nfloat delta(float v1, float v2)\n{\n    return v1 + (v2 - v1) / 2.;\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    Zones z;\n    if (iFrame == 0)\n    {\n        z = initZones();\n    }\n    else\n    {\n        int i = 0;\n        decodeZones(iChannel0, z, i);\n    }\n    horizClickEvent(z.t0, vec2(delta(z.x0.val,z.x1.val), z.t0.val), 30.);\n    horizClickEvent(z.t1, vec2(delta(z.x1.val,z.x2.val), z.t1.val), 30.);\n    horizClickEvent(z.t2, vec2(delta(z.x2.val,z.x3.val), z.t2.val), 30.);\n    horizClickEvent(z.t3, vec2(delta(z.x3.val,1.), z.t3.val), 30.);\n    vertiClickEvent(z.x0, vec2(z.x0.val, 0.5), 30.);\n    vertiClickEvent(z.x1, vec2(z.x1.val, 0.5), 30.);\n    vertiClickEvent(z.x2, vec2(z.x2.val, 0.5), 30.);\n    vertiClickEvent(z.x3, vec2(z.x3.val, 0.5), 30.);\n\n    int ii = 0;\n    encode(O, I, z, ii);\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtS3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 484, 528, 528, 639], [641, 742, 771, 771, 859], [861, 926, 964, 964, 1074], [1078, 1156, 1185, 1185, 1548], [1550, 1587, 1635, 1635, 1773], [1775, 1775, 1858, 1858, 2064], [2066, 2066, 2178, 2178, 2452], [2454, 2454, 2542, 2542, 2764], [2766, 2766, 2789, 2789, 2892], [2894, 2894, 2949, 2949, 3150], [3152, 3152, 3191, 3191, 4288]], "test": "untested"}
{"id": "mtj3Dy", "name": "Frooty", "author": "leon", "description": "🌼", "tags": ["plant", "froot"], "likes": 59, "viewed": 632, "published": 3, "date": "1673894426", "time_retrieved": "2024-07-30T18:15:28.632702", "image_code": "\n// Frooty by Leon Denise 2023-01-16\n\n// a floral iteration over \n// Baroque Fractal Pattern https://www.shadertoy.com/view/flcBD4\n// Taste of Noise 7 https://www.shadertoy.com/view/NddSWs\n\n// Buffer A draws shape trails with a depth and id buffer\n// Buffer B calculates ambient occlusion and normal\n// Image does the coloring and lighting\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // 2d coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-R.xy/2.)/R.y;\n    \n    // pixel data from Buffer A (steps, timeline, id, depth)\n    vec4 data = texture(iChannel0, uv);\n    float total = data.a;\n    \n    if (total > .001 && total < max_dist)\n    {\n        // data from Buffer A\n        float shade = data.r;\n        float time = data.g;\n        float mat = floor(data.b);\n        float froot = fract(data.b);\n        \n        // data from Buffer B (normal, ao)\n        data = texture(iChannel1, uv);\n        vec3 normal = data.xyz;\n        float ao = data.a;\n        \n        // palettes\n        // Inigo Quilez https://iquilezles.org/articles/palettes\n        vec3 tintCold = .5+.5*cos(vec3(2,3,1)*5.7+4.-time*4.);\n        vec3 tintWarm = .5+.5*cos(vec3(1,2,3)*4.9+mat*1.+uv.y*2.+5.);\n        color = mix(tintCold, tintWarm, froot);\n        \n        // lighting\n        color += pow(dot(normal, N(0,1,1))*.5+.5, 4.)*froot;\n        //color += .2*(1.-pow(abs(dot(normal, N(0,0,1))), .5));\n        \n        // shadow\n        color *= shade;\n        color *= ao * .5 + .5;\n        color *= ss(100.,0.,total);\n    }\n    else\n    {\n        // background\n        color = vec3(0.039,0.110,0.322) * smoothstep(2., -2., length(uv-.5));\n    }\n    \n    // fade transition\n    float t = fract(iTime/delay);\n    color *= ss(.0,.1,t) * ss(1.,.9,t);\n    \n    // vignette\n    color *= ss(1.5, .5, length(p));\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Frooty by Leon Denise 2023-01-16\n\n// this frame buffer draws the depth buffer with pixel data (steps, timeline, id, depth)\n// it draws shape only if it is closer that previous depth\n// we can then draw trails of shapes and relight later in Buffer B\n\n\n// globals\nfloat timeline;\nfloat id, froot;\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    float dist = 100.;\n    float shape = 100.;\n    \n    // grid repeat\n    float cell = 5.;\n    vec3 pp = p+cell/2.;\n    id = hash13(floor(pp/cell));\n    p = repeat(pp, cell);\n    p += (hash31(floor(id*100.))*2.-1.)*cell/4.;\n    \n    // timing\n    float t = timeline;\n    float tt = fract(t);\n    float end = mix(.2,.8,id);\n    float anim = ss(-.1,end,tt);\n    \n    // shape parameters\n    float r = 1.; // range \n    float f = 1.7; // falloff coeficient\n    const float count = 6.; // iterations\n    \n    // angle\n    float n = id*1000.+anim*2. + floor(t); \n    \n    // going outter\n    r *= pow(ss(0.01,end,tt), .2);\n    \n    // kaleidoscopic iterated function\n    float a = 1.;\n    for (float i = 0.; i < count; ++i)\n    {\n        // twist faster and faster\n        p.xy *= rot(n/a);\n        p.yz *= rot(n/a);\n        \n        // fold\n        p.x = abs(p.x)-r*a;\n        \n        // falloff\n        a /= f;\n    }\n    \n    // tube (the stems)\n    dist = min(dist, max(abs(p.y)-.1*(1.-anim), length(p.xz)-.02));\n    \n    // sphere (the froots)\n    froot = ss(end-.3,end,tt);\n    float size = .1 * froot - (1.-froot) * .1;\n    dist = min(dist, length(p)-size);\n    \n    // crop shell to avoid camera collision\n    dist = max(dist, -length(q)+cell/2.);\n    \n    return dist * .8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 2d coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = (fragCoord-R.xy/2.)/R.y;\n    \n    // noise\n    vec3 rng = hash(uvec3(fragCoord, iFrame));\n    vec3 blu = texture(iChannel1, fragCoord/1024.).rgb;\n    vec2 blur = normalize(blu.xy*2.-1.) * blu.z;\n    \n    // buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // timeline used by map for animation\n    timeline = rng.x*.001+iTime/delay;\n\n    // 3d coordinates\n    vec3 pos = vec3(0,0,0);\n    vec3 ray = normalize(vec3(p, -2.));\n    vec2 angle = (hash21(floor(iTime/delay))*2.-1.)*.5;\n    ray.yz *= rot(angle.x);\n    ray.xz *= rot(angle.y);\n    \n    // raymarch\n    float total = 0.;\n    float steps = 0.;\n    float dof = 0.;\n    const float count = 80.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < .001 || total > max_dist) break;\n        \n        // dithering\n        dist *= 0.9 + 0.1 * rng.z;\n        \n        // dof far blur\n        dof += 0.0001 * ss(15.,30.,total);\n        ray.xy += blur * dof;\n        \n        total += dist;\n        pos += ray * dist;\n    }\n\n    // draw if closer\n    float depth = frame.a;\n    bool closer = total < depth || depth < .001;\n    if (total < max_dist && closer)\n    {\n        // data pack\n        fragColor = vec4(\n            steps/count, // used to apply shadow\n            fract(timeline), // used to offset tint\n            floor(id*100.) + froot * .99, // used as material\n            total); // depth buffer\n    }\n    else\n    {\n        // keep previous result\n        fragColor = frame;\n    }\n    \n    // clear between transition\n    fragColor *= step(.01, fract(iTime/delay));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// shared constants\nconst float delay = 15.;\nconst float max_dist = 200.;\n\n// snippets\n#define R iResolution\n#define T(uv) texture(iChannel0, uv).a\n#define N(x,y,z) normalize(vec3(x,y,z))\n#define ss(a,b,t) smoothstep(a,b,t)\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_b_code": "\n// Frooty by Leon Denise 2023-01-16\n\n// compute ambient occlusion and normal from Buffer A depth\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // ambient occlusion\n    float ao = 0.;\n    if (color.a < 20. && color.a > 0.5)\n    {\n        const float count = 6.;\n        for (float f = 0.; f < count; ++f)\n        {\n            vec3 rng = hash(uvec3(fragCoord, float(iFrame)+196.*f));\n            vec2 offset = 20.*pow(rng.z, 4.)*normalize(rng.xy*2.-1.)/R.xy;\n            float total = texture(iChannel0, uv+offset).a;\n            if (total < 20. && total > 0.5)\n                ao += 4.*abs(color.a - total);\n        }\n    }\n    float frame = texture(iChannel1, uv).a;\n    fragColor.a = mix(frame, 1.-clamp(ao, 0., 1.), .1);\n    \n    // normal\n    vec3 unit = vec3(1./R.xy, 0);\n    float w = T(uv+unit.xz);\n    float e = T(uv-unit.xz);\n    float n = T(uv+unit.zy);\n    float s = T(uv-unit.zy);\n    bool edge = w * e * n * s < .001;\n    if (color.a > .001 && color.a < max_dist && !edge)\n    {\n        vec3 normal = normalize(vec3(w-e, n-s, color.r*color.r*.05));\n        fragColor.rgb = normal;\n    }\n    else\n    {\n        fragColor.rgb = vec3(0,0,1);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 398, 398, 1898]], "test": "untested"}
{"id": "dtj3Wy", "name": "-1+i  base  &  twindragon figure", "author": "FabriceNeyret2", "description": "base -1+i  allows to represent the whole complex plane as a binary number set.\nTwinDragon of order n = all positions that can be represented with n bits.\n[url]https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i[/url]\n", "tags": ["binary", "fractals", "onetweet", "twindragon", "golf", "arithmetics", "complexe"], "likes": 19, "viewed": 299, "published": 3, "date": "1673892732", "time_retrieved": "2024-07-30T18:15:29.465476", "image_code": "// base -1+i  allows to represent the whole complex plane as a binary number set.\n// TwinDragon of order n = all positions that can be represented with n bits.\n// cf https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i\n               \n\n// --- golfed version.   -9 ch by coyote\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n     I -= .5 + .5*iResolution.xy;  \n     \n    for ( O *= 0. ; I != -I ; O += .05 )              // --- for all digits, as long as bit remains\n        I = floor( ( vec2( I.y, -I) -I ) / 2. );      // euclidian div by base -1+i  = next bit\n}\n\n\n\n\n\n/** // --- 270 chars version\n\n// complexes op from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cdiv(A,B)   cmul( A, cinv(B) )\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n     I -= .5 + .5*iResolution.xy;  \n     \n    float i = 0.;\n    for ( ; i < 16.; i++ ) {                  // --- for all digits   \n        I = floor( cdiv( I, vec2(-1,1) ) );   // euclidian div by base -1+i  = next bit\n        if ( I == vec2(0) ) break;          \n    }\n    O = vec4( i/16. );                        // show order as grey level\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtj3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 338, 338, 578]], "test": "untested"}
{"id": "ctSGWK", "name": "neighbors 5", "author": "jonasfrey", "description": "null", "tags": ["null"], "likes": 5, "viewed": 157, "published": 3, "date": "1673888481", "time_retrieved": "2024-07-30T18:15:30.292265", "image_code": "\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n\nfloat f_n_rand(float n){\n    n = n+n+n*.2133;\n    n = n*n*0.231;\n    n = sin(n*1.2324+123.1*n)*124.123;\n    return fract(n);\n}\nfloat f_n_dist_sqr(vec2 o){\n    float n = max(abs(o.x), abs(o.y));\n    return n; \n}\nfloat f_n_dist_crc(vec2 o){\n    return length(o);\n}\nfloat f_n_dist(vec2 o_trn_fc_nor_offset, vec2 o_scl, vec2 o_trn){\n    o_trn_fc_nor_offset*=o_scl;\n    \n    float n_index = (o_trn_fc_nor_offset.x)\n        + floor(o_trn_fc_nor_offset.y) * o_scl.x;\n        \n    vec2 o = o_trn_fc_nor_offset+floor(o_trn);\n    float n_x_nor = floor(o.x) / o_scl.x;\n    float n_index_floor = floor(o.x)\n        + floor(o.y) * o_scl.x;\n    float n_index_nor = floor(n_index) / (o_scl.x*o_scl.y);\n    float n_rand = f_n_rand(iTime*0.0001+n_index_floor/(o_scl.x*o_scl.y))-0.5;\n    //n_rand = 0.;\n    vec2 o2 = (fract(o_trn_fc_nor_offset)-(o_trn)-0.5);\n    float n_tau = 6.2831;\n    o2 = f_o_rotd(o2, sin(iTime+n_index_nor*0.2*n_tau));//+sin(n_index+iTime);\n    //radius\n    float n_dc = length(o_trn_fc_nor_offset);\n    float nf = fract(abs(sin(-iTime*2.+n_dc*0.2)));\n    //return nf;\n    o2 *= +5.*(nf);\n    \n    float n_dist = f_n_dist_crc(o2);\n    if(mod(floor(o_trn_fc_nor_offset.x),2.)==0.){\n        n_dist = f_n_dist_sqr(o2);\n    }\n    //n_dist = pow(n_dist, 1./5.)*1.;\n    //n_dist = 1.-n_dist;\n    //return n_index_floor / (o_scl.x * o_scl.y);\n    return n_dist;\n}\nvec2 f_o_index(vec2 o_trn, vec2 o_scl){\n    float n_index_floor = floor(o_trn.x)\n        + floor(o_trn.y) * o_scl.x;\n    return vec2(\n        n_index_floor, \n        n_index_floor / floor(o_scl.x*o_scl.y)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    o_trn_fc_nor_offset *= sin(iTime*0.2)*10.;\n    vec2 o_scl = vec2(11.);\n    \n    vec2 o_scl_krn = vec2(5.);\n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    vec2 omin = vec2(0.);\n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        float n_dist = f_n_dist(o_trn_fc_nor_offset, o_scl, vec2(n_x, n_y));\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            omin = (o_trn_fc_nor_offset*o_scl) + vec2(n_x, n_y);\n        }\n        //n_dmin = n_dist;\n    }\n    \n    fragColor = vec4(n_dmin);\n    \n    if(o_trn_fc_nor_offset.x > 0.){\n        vec2 o_index = f_o_index(floor(omin), o_scl);\n        float nr = f_n_rand(abs(o_index.g)*2.);\n        float nr2 = f_n_rand(nr);\n        fragColor = vec4(nr, nr2, 0.5, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 237], [239, 239, 263, 263, 365], [366, 366, 393, 393, 449], [450, 450, 477, 477, 501], [502, 502, 567, 567, 1600], [1601, 1601, 1640, 1640, 1814], [1815, 1815, 1872, 1872, 3238]], "test": "untested"}
{"id": "dlj3Dy", "name": "Breathing Liquid- with Shadow", "author": "cinmin", "description": "use distance value(t) to add shadow \n*drag to move the camera", "tags": ["raymarching", "reflection"], "likes": 4, "viewed": 229, "published": 3, "date": "1673886052", "time_retrieved": "2024-07-30T18:15:31.050238", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    \t\tfloat strength = 0.4;\n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.5 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*1.5 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.xyx+vec3(0,2,4));\n\t\t//Gamma\n\t\tcol = pow(col, vec3(0.4545));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.1);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(-10.,-10.,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=-0.288 * (noise_3(p*3.0)*2.0-1.0);\nvec3 p1 = p + bump;\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5);\nreturn sdTorus(p1+vec3(sin(iTime*0.3)*0.6,sin(iTime)*0.4,sin(iTime*0.3)*0.3),vec2(0.4,0.2));\n//return sdBox(p+vec3(0.0,0.0,0.0), vec3(0.4, 0.4, 0.4));\n//return udRoundBox(p+vec3(0.0,0.0,0.0), vec3(0.3, 0.3, 0.3), 0.1);\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\nvec3 BlendColor( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\nvec3 grid3D(vec3 p, float scale){\n    return floor(p*scale)/scale;\n}\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n    \n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\nvec3 gridTrace(vec3 o, vec3 r,  vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n    \n\td=map(grid3D(p,20.));\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn p;\n}\n\n\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    //ret.x = pow(1.0-e.y,3.0);\n    //ret.y = pow(1.0-e.y, 1.2);\n    //ret.z = 0.8+(1.0-e.y)*0.3;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = gl_FragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nuv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\nvec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, mouse.y, mouse.x); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n,grid_n;\n\tfloat t = trace(RayOri, RayDir, p);\n    vec3 grid_p=gridTrace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    grid_n=normalize(gradient(grid_p));\n    vec3 bump=normalMap(p*1.652,n);\n    n=n+bump*0.05;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.2, 0.256, edge);\n    \n    edge=edge+1.*0.3;\n    edge=min(1.,edge);\n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n    //result = vec3(edge);\n    result= phong(p,n,-RayDir)*ao; \n//HDR環境貼圖\n    vec3 refl = reflect(RayDir,grid_n);\n    vec3 refl_clr=warpSky(refl);\n\tvec3 BG=refl_clr;\t   //或getSkyFBM(RayDir)\n\n\nif(t<2.5) fragColor = vec4(vec3(result),1.0); else fragColor = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n fragColor*= vec4(exp(1.-t*0.5));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 273, 294, 552], [554, 554, 590, 613, 1031], [1033, 1033, 1054, 1054, 1148], [1151, 1151, 1186, 1186, 2530], [2532, 2561, 2596, 2596, 2622], [2623, 2623, 2654, 2654, 2741], [2742, 2742, 2775, 2775, 2840], [2843, 2843, 2886, 2929, 2973], [2975, 2975, 2997, 2997, 3328], [3330, 3359, 3405, 3405, 3623], [3625, 3625, 3673, 3673, 3891], [3892, 3892, 3925, 3925, 3960], [3962, 3991, 4032, 4032, 4179], [4181, 4181, 4222, 4222, 4381], [4421, 4421, 4445, 4460, 4694], [4696, 4696, 4720, 4741, 4921], [4923, 4923, 4947, 4947, 4972], [4974, 5001, 5053, 5053, 5230], [5232, 5240, 5266, 5266, 5636], [5639, 5659, 5716, 5716, 7433], [7454, 7483, 7506, 7506, 7556], [7557, 7557, 7579, 7579, 7659], [7660, 7660, 7682, 7682, 7770], [7772, 7784, 7810, 7810, 8431], [8432, 8457, 8505, 8505, 8543], [8545, 8574, 8620, 8620, 8758], [8759, 8759, 8809, 8809, 9230], [9231, 9231, 9277, 9277, 9535], [9537, 9570, 9601, 9601, 9689], [9691, 9691, 9732, 9732, 9928], [9974, 9974, 10012, 10012, 10411], [10413, 10413, 10445, 10445, 10761], [10763, 10788, 10830, 10830, 11175], [11177, 11246, 11280, 11280, 11458], [11460, 11460, 11501, 11501, 11616], [11618, 11618, 11645, 11645, 11718]], "test": "untested"}
{"id": "ctj3zK", "name": "BLF Pop!", "author": "iY0Yi", "description": "sdf sketch for cartoon \"pop!\" shape.", "tags": ["maptoy"], "likes": 45, "viewed": 635, "published": 3, "date": "1673885039", "time_retrieved": "2024-07-30T18:15:32.011668", "image_code": "/*\n  SDF is in BufB.\n*/\n#define getBuf(coord)\ttexelFetch(iChannel0, ivec2(coord), 0)\nvec3 getAlbedo(vec2 coord) { return unpackU4(getBuf(coord).x).rgb; }\nfloat getDiffuse(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).r); }\nfloat getDepth(vec2 coord) { return getBuf(coord).w; }\nvec3 getNormal(vec2 coord) { return normalize(unpackS3(getBuf(coord).z)); }\nvec2 clampCoord(vec2 coord) { return clamp(coord, vec2(0), iResolution.xy - .5); }\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2) {\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(1.5, 1., difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord) {\n    if(getDepth(coord)>.9)return .4;\n    \n\tconst vec3 offset = vec3(.5, -.5, 0)*2.;\n    #define NM(x)\tgetNormal(x)\n\tvec2 coords = coord;\n\tfloat edge = 1.;\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yx)), NM(clampCoord(coords + offset.xy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.xx)), NM(clampCoord(coords + offset.yy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yz)), NM(clampCoord(coords + offset.xz))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.zx)), NM(clampCoord(coords + offset.zy))));\n\treturn edge;\n}\n\n// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir) {\n\tfloat np, zp, pp, nz, pz, nn, zn, pn, gx, gy;\n    np = getDiffuse(clampCoord(fragCoord + (vec2(-1, 1) + dir)));\n    zp = getDiffuse(clampCoord(fragCoord + (vec2(0, 1) + dir)));\n    pp = getDiffuse(clampCoord(fragCoord + (vec2(1) + dir)));\n    nz = getDiffuse(clampCoord(fragCoord + (vec2(-1, 0) + dir)));\n    pz = getDiffuse(clampCoord(fragCoord + (vec2(1, 0) + dir)));\n    nn = getDiffuse(clampCoord(fragCoord + (vec2(-1) + dir)));\n    zn = getDiffuse(clampCoord(fragCoord + (vec2(0, -1) + dir)));\n    pn = getDiffuse(clampCoord(fragCoord + (vec2(1, -1) + dir)));\n\n\t// https://www.shadertoy.com/view/Wds3Rl\n\tgx = np * -3. + nz * -10. + nn * -3. + pp * 3. + pz * 10. + pn * 3.;\n\tgy = np * -3. + zp * -10. + pp * -3. + nn * 3. + zn * 10. + pn * 3.;\n\n\tvec2 G = vec2(gx, gy);\n\treturn vec4(G, length(G), atan(G.y, G.x));\n}\n\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx) {\n\tvec4 edge = sobel(fragCoord, vec2(0));\n\tvec2 dir = vec2(cos(-edge.w), sin(-edge.w));\n\tvec4 edgep = sobel(fragCoord, dir),\n\t     edgen = sobel(fragCoord, -dir);\n\tif (edge.z < edgep.z || edge.z < edgen.z) edge.z = 0.;\n\treturn vec2((edge.z > mn) ? edge.z : 0., (edge.z > mx) ? edge.z : 0.);\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx, bool isDiffuse) {\n\tvec2 np = hysteresisThr(fragCoord + vec2(-1, 1), mn, mx),\n\t     zp = hysteresisThr(fragCoord + vec2(0, 1), mn, mx),\n\t     pp = hysteresisThr(fragCoord + vec2(1), mn, mx),\n\t     nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx),\n\t     zz = hysteresisThr(fragCoord + vec2(0), mn, mx),\n\t     pz = hysteresisThr(fragCoord + vec2(1, 0), mn, mx),\n\t     nn = hysteresisThr(fragCoord + vec2(-1), mn, mx),\n\t     zn = hysteresisThr(fragCoord + vec2(0, -1), mn, mx),\n\t     pn = hysteresisThr(fragCoord + vec2(1, -1), mn, mx);\n\treturn 1. - min(1., step(1e-3, zz.x * 8.) * smoothstep(0., .5, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y) * 8.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec3 albedo = getAlbedo(fragCoord);\n    vec3 col = vec3(.9608, .9216, .8431);\n\n\tcol *= min(getOutline(fragCoord), cannyEdge(fragCoord, 0., 3.5, true));    \n\tcol *= sms(.4, .401, gnoise(fragCoord * .18+floor(iTime)) + gnoise(fragCoord * .15) + .3);\n\tcol += 1. - sms(.8, .801, (1. - gnoise(fragCoord * .05+floor(iTime)) * gnoise(fragCoord * .1)) + .7);\n\tfragColor = vec4(pow3(col, .45), 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n  Generals\n*/\n\n#define PI acos(-1.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n#define sat(x) clamp(x,0.,1.)\n#define sms(min,max,x) smoothstep(min,max,x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x > 0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x),sign1f(v.y))\n#define linearstep(edge0,edge1,x) min(max((x-(edge0))/((edge1)-(edge0)),0.),1.)\n#define ZERO min(0,iFrame)\nvec3 pow3(vec3 v,float power){return pow(v,vec3(power));}\n\n// \"hash11()\"-\"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n  st *= .75;\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0., 1., f);\n\n  vec2 rnd_x0y0 = u2s(hash22(i + vec2(0, 0)));\n  vec2 rnd_x1y0 = u2s(hash22(i + vec2(1, 0)));\n  vec2 rnd_x0y1 = u2s(hash22(i + vec2(0, 1)));\n  vec2 rnd_x1y1 = u2s(hash22(i + vec2(1, 1)));\n\n  vec2 dir_x0y0 = st - (i + vec2(0, 0));\n  vec2 dir_x1y0 = st - (i + vec2(1, 0));\n  vec2 dir_x0y1 = st - (i + vec2(0, 1));\n  vec2 dir_x1y1 = st - (i + vec2(1, 1));\n\n  float dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n  float res_x = mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y = mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y) * 2.);\n}\n\n// Data packer/unpacker\n// albedo,diffuse,specular,shadow,normal,and depth are rendered in raymarching pass,\n// and then,those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) *.997 * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n\nstruct RenderData {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n} renDat;\n\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n}ray;\n\nstruct Camera {\n  vec3 position;\n  vec3 direction;\n  vec3 target;\n  vec4 quaternion;\n  float fov;\n  float orthoDist;\n  float orthoScale;\n  vec3 up;\n};\n\nstruct Light {\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n\n#define MAT_VOID vec3(-1)\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 20.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-.25,2)\n#define CAM_DIST 10.\n#define CAM_INIT_SCALE 1.35\n#define TURN_TABLE_SPEED .25\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\nvec4 packRenderData(){\n  return vec4(packU4(vec4(renDat.albedo, renDat.shadow)), packS3((vec3(u2s(renDat.diffuse), renDat.specular, u2s(renDat.ao)))), packS3((renDat.normal)), renDat.depth);\n}\n\n#define render() \\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=ZERO; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=ZERO; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(sign(iMouse.z)>.0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nvec4 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    float t= march(ray.origin, ray.direction);\\\n    renDat.normal=vec3(0);\\\n    renDat.diffuse=1.;\\\n    renDat.albedo=vec3(.9);\\\n    renDat.depth=1.;\\\n    renDat.specular=0.;\\\n    renDat.shadow=1.;\\\n    renDat.ao=1.;\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        renDat.normal=n;\\\n        renDat.diffuse=dif;\\\n        renDat.albedo = vec3(1);\\\n        renDat.depth = 0.;\\\n    }\\\n    return packRenderData();\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    fragColor = renderRect(fragCoord);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SDF\n//-------------------------------------------------\n\nfloat bUniS(float a,float b,float r){\n\tfloat h=max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\n// \"SphericalFibonacci\" by EvilRyu:\n// https://www.shadertoy.com/view/dsjXDm\nconst float gNum = 16.;\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n// unoptimized version\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j){\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - 2. * j / gNum);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nfloat map(vec3 p){\n    float d = length(p)-.4;\n    float T = floor(iTime*2.);\n    \n    for(float i = float(ZERO); i < gNum; i++){\n        \n        vec3 sp = sphericalFibonacci(i+1.);\n        vec3 r = hash33(sp+T+i);\n        const float MAX_RADIUS = .6;\n        float distFromCenter = .25 + r.x*.15 + r.y*.15;\n        float cellRadius = MAX_RADIUS-distFromCenter; // get more spherical look than just random.\n        cellRadius+=.1*r.z; // and break it just a little.\n        d = bUniS(length(p-sp*distFromCenter)-cellRadius, d, .01+distFromCenter*.1);\n        \n        float dd = 1e3;\n        if(int(i+T)%2!=0){\n            \n            vec3 q = p;\n            float xy = atan(sp.y,sp.x);\n            float yz = atan(sp.z,sp.y);\n            R(q.yz,yz);\n            R(q.xy,xy);\n            \n            float popOffset = -r.x*.3;\n            \n            for(float j = float(ZERO); j < gNum; j+=4.){\n                vec3 ssp = sphericalFibonacci(j+1.);\n                vec2 rr = hash22(ssp.xz+T+vec2(i,j));\n                vec3 subPopCenter = q-vec3(0,1.25+popOffset,0);\n                float subPopRadius = .05+.05*rr.x;\n                dd = bUniS(length(subPopCenter-ssp*.1) - subPopRadius, dd, .0125*rr.y+.025);\n            }\n            vec3 qs = q;\n            qs.y-=.5+popOffset;\n            qs.y-=clamp(qs.y,0.,.7);\n            float suji = length(qs)-(.05*length(q-vec3(0,.75,0))+.02); \n            suji+=(.5+.5*sin(atan(q.x,q.z)*2.))*.015;\n            dd = bUniS(dd, suji, .2);\n        }\n        d = bUniS(dd, d,.3);\n    }\n    return d;\n}\n\nrender();\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctj3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 113, 113, 153], [154, 154, 184, 184, 227], [228, 228, 256, 256, 282], [283, 283, 311, 311, 358], [359, 359, 388, 388, 441], [443, 443, 481, 481, 566], [568, 568, 598, 598, 1173], [1175, 1273, 1311, 1311, 2131], [2133, 2133, 2189, 2189, 2480], [2482, 2482, 2551, 2551, 3197], [3199, 3199, 3251, 3251, 3643]], "test": "untested"}
{"id": "DtBGWG", "name": "painted wobbly circle", "author": "ducttapecode", "description": "genesis shadertoy experiment. maybe it looks like watercolor paint?  ¯\\_(ツ)_/¯\nlayered gradient noise on hsb colors in a circle distorted by radial gradient noise", "tags": ["sdf", "hsb", "gradientnoise"], "likes": 6, "viewed": 226, "published": 3, "date": "1673882254", "time_retrieved": "2024-07-30T18:15:32.812526", "image_code": "// random 1D to 1D\nfloat random11(float t) {\n    return fract(sin(t * 12.34) * 567.89);\n}\n\n// random 2D to 1D\nfloat random21(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(123.45, 67.89))) * 98765.4321);\n}\n\n// random 2D to 2D\nvec2 random2(vec2 st){\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n// rotation matrix\nmat2 rot1 = mat2(4., -3., 4., 3.) / 5.;\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat blob_sdf(vec2 uv, float r) {\n    \n    float d = length(uv); // radius from 0,0\n    vec2 n = uv / d; // normalized for a clear direction for the noise offset\n    \n    float magnitude = .5;\n    float frequency = .5;\n    vec2 t = vec2(iTime) * 0.5;\n    \n    float offset = noise(t + frequency * n);// \n    d += magnitude * offset;\n    return d - r;\n}\n\nvec3 hsb_noise(vec2 uv, float hue) {\n    vec3 color = vec3(0.0);\n    \n    float s = 1.57;\n    for (int i = 0; i < 7; i++) \n    {\n        uv = uv * rot1 * 2.23;\n        color += hsb2rgb(vec3(hue, \n            noise(uv * 0.3) * 0.5 + 0.45, \n            noise(uv * 0.712) * 0.2 + 0.8)) / s;\n        s *= 2.03;\n        uv += iTime * .25;\n    }\n    return color;\n}\n\nfloat hue = 0.73; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1 in a centered square)\n    // compensating for aspect ratio, coordinates outside -1..1 for the longer axis\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y) * 2.;\n    \n    // vary main hue\n    vec2 hue_line = vec2(0.123, 0.2345);\n    hue = fract(uv.x * hue_line.x + uv.y * hue_line.y + 0.1 * iTime);\n    // flipp hue across an oscillating line\n    hue = fract(hue + 0.5 * smoothstep(-0.001, 0.001, \n        uv.x * -hue_line.y * 1.73 \n        + uv.y * hue_line.x\n        + 0.2 * sin(iTime * 0.8)));\n\n    // layered hsb noise\n    vec3 color = hsb_noise(uv, hue);\n    //color = hsb2rgb(vec3(hue, 1., 1.));\n    \n    // blob shape sdf\n    float r = blob_sdf(uv, 0.75);\n    float t = 0.0;\n    \n    // get darker closer to the border\n    t = smoothstep(-0.2, 0.1, r);\n    color *= 1. - 0.15 * t;\n    \n    // blend the circle/blob with the background\n    t = smoothstep(-0.01, 0.0, r);\n    color = mix(color, vec3(0.97, 0.95, 0.93), t);\n    \n    // output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 44, 44, 89], [91, 110, 135, 135, 206], [208, 227, 249, 249, 395], [457, 542, 564, 564, 968], [970, 1044, 1070, 1070, 1302], [1304, 1304, 1338, 1338, 1657], [1659, 1659, 1695, 1695, 2018], [2040, 2040, 2097, 2242, 3164]], "test": "untested"}
{"id": "dlj3Wy", "name": "Swirling Intersection", "author": "cinmin", "description": "為一三維環境，兩顆球位移時會產生周圍空間扭曲效果，z方向移動時會影像材質粗糙度\n原為結合ultralap 3di手勢互動程式，可三維控制球體位置，轉為網頁版後位置為隨機移動。", "tags": ["raymarching", "reflection"], "likes": 2, "viewed": 175, "published": 3, "date": "1673881151", "time_retrieved": "2024-07-30T18:15:33.741044", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\nvec3 hand=vec3(0,1.3,3.4);\nvec3 hand2=vec3(0,1.3,3.4);\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\nfloat bnoise( in float x );\n\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    \t\tfloat strength = 0.4;\n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.5 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*1.5 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.xyx+vec3(0,2,4));\n\t\t//Gamma\n\t\tcol = pow(col, vec3(0.4545));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.1);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(mouse.x,mouse.y,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=-0.288 * (noise_3(p*3.0)*2.0-1.0);\nfloat bump_h1=-0.008 *hand.z* (noise_3(p*3.0)*2.0-1.0);\nfloat bump_h2=-0.008 *hand2.z* (noise_3(p*3.0)*2.0-1.0);\nvec3 p1 = p ;\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5);\nfloat t1=sdTorus(p1+hand+bump_h1,vec2(0.05,0.025));\nfloat t2=sdTorus(p1+hand2+bump_h2,vec2(0.05,0.025));\nreturn min(t1,t2);\n//return sdBox(p+vec3(0.0,0.0,0.0), vec3(0.4, 0.4, 0.4));\n//return udRoundBox(p+vec3(0.0,0.0,0.0), vec3(0.3, 0.3, 0.3), 0.1);\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    //ret.x = pow(1.0-e.y,3.0);\n    //ret.y = pow(1.0-e.y, 1.2);\n    //ret.z = 0.8+(1.0-e.y)*0.3;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hand=vec3(bnoise(iTime/8.+100.)*2.5,(bnoise(iTime/5.+15.))*0.9,(bnoise(iTime/6.)+1.)/2.*7.);\n    hand2=vec3(bnoise(iTime/9.+50.)*2.,(bnoise(iTime/6.+35.))*0.9,(bnoise(iTime/4.+60.)+1.)/2.*6.5);\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    uv.y*=1.0;\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n// camera option1  (模型應在原點，適用於物件)\n\t//vec3 CameraRot=vec3(0.0, mouse.y, mouse.x); \n    vec3 CameraRot=vec3(0.0, 0., 0.); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    vec3 bump=normalMap(p*1.652,n);\n    n=n+bump*0.05;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.072, 0.956, edge);\n    \n    \n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n    //result = vec3(edge);\n    result= phong(p,n,-RayDir)*ao;  //攝影機觀看視角(V)要轉負的，因為是方向是從物體發出到攝影機  //需要外接的話燈光另外寫\n    //result*=(1.-edge);\n//HDR環境貼圖\n    vec3 refl = reflect(RayDir,n);\n    vec3 refl_clr=warpSky(refl);\n\tvec3 BG=refl_clr;\t   //或getSkyFBM(RayDir)\n\n\nif(t<2.5) fragColor = vec4(vec3(result),1.0); else fragColor = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n  //float k = hash(uint(i));\n  //float k = 0.5+0.5*sin(i);\n    float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 357, 378, 636], [638, 638, 674, 697, 1115], [1117, 1117, 1138, 1138, 1232], [1235, 1235, 1270, 1270, 2620], [2622, 2651, 2686, 2686, 2712], [2713, 2713, 2744, 2744, 2831], [2832, 2832, 2865, 2865, 2930], [2933, 2933, 2976, 3019, 3063], [3065, 3065, 3087, 3087, 3556], [3558, 3587, 3633, 3633, 3851], [3854, 3883, 3924, 3924, 4066], [4106, 4106, 4130, 4145, 4379], [4381, 4381, 4405, 4426, 4606], [4608, 4608, 4632, 4632, 4657], [4659, 4686, 4738, 4738, 4915], [4917, 4925, 4951, 4951, 5321], [5323, 5343, 5400, 5400, 7280], [7293, 7308, 7336, 7353, 7680], [7685, 7714, 7737, 7737, 7787], [7788, 7788, 7810, 7810, 7890], [7891, 7891, 7913, 7913, 8001], [8003, 8015, 8041, 8041, 8662], [8663, 8688, 8736, 8736, 8774], [8776, 8805, 8851, 8851, 8989], [8990, 8990, 9040, 9040, 9461], [9462, 9462, 9508, 9508, 9766], [9768, 9801, 9832, 9832, 9920], [9922, 9922, 9963, 9963, 10159], [10205, 10205, 10243, 10243, 10642], [10644, 10644, 10676, 10676, 10992], [10994, 11019, 11061, 11061, 11406], [11408, 11477, 11511, 11511, 11689], [11691, 11691, 11732, 11732, 11847], [11849, 11849, 11876, 11876, 11949]], "test": "untested"}
{"id": "mt23z3", "name": "Fun #define alphabet experiment", "author": "kishimisu", "description": "Just a fun experiment, not practical in any way!", "tags": ["bloom", "glow", "font", "string", "alphabet", "hack", "code", "letters", "bright", "neon", "parse", "parsing"], "likes": 57, "viewed": 1284, "published": 3, "date": "1673879035", "time_retrieved": "2024-07-30T18:15:34.505001", "image_code": "/* @kishimisu (2023) - https://www.shadertoy.com/view/mt23z3\n\n   Just for fun, check the mainImage ^^\n   The compile time can be excessive on some machines.\n*/\n\n// Choose color a theme (if you don't have many characters, prefer to use RAINBOW/GOLD)\n#define THEME THEME_DEFAULT\n\n// Available themes\n#define THEME_MATRIX   vec4(.2,1,.4,1) * (cos(pp[1] + iTime)*.5 + 1.4)\n#define THEME_DEFAULT  cos(pp[1] + iTime + tt[3] + tt*2.) + 1.5\n#define THEME_GOLD     cos(pp[0]*.2 + tt*2.) + 1.3\n#define THEME_RAINBOW  cos(pp[0]*.1 + iTime + tt[3] + tt*2.) + 1.4\n#define THEME_PINK     vec4(1,.4,.8,1) * (cos(pp[1]*.8 + iTime + tt[3] + tt*2.) + 1.8)\n\n// Font style (best values between 0.6 and 1.0)\n#define FONT_STYLE (.9 + sin(iTime)*.2) // Font style is currently animated between the values 0.7-1.1\n#define GLOW_INTENSITY 1.               // Intensity of the glow effect\n\nvoid mainImage(out vec4 OO, vec2 FF) {\n    vec4 tt = vec4(0, .5, FONT_STYLE, 2), ww;\n    vec2 pp = (2.*FF-rr)/min(rr[1],rr[0]/1.6)*vec2(28,20)/ZOOM+OFFSET, \n         xz = tt.xz, zx = tt.zx, zz = tt.zz, iv = vec2(1,-1),\n         yz = tt.yz, yx = tt.yx, zy = tt.zy, p0 = pp, qq; pp[0] += CW; OO *= 0.;\n    \n    // Use _ for spaces (automatic with uppercase letters)\n         \n    T h i s   T e x t   I s   W r i t t e n   I n s i d e\n    \n    T h e   M a i n i m a g e   U s i n g   D e f i n e s\n        \n    F o r   E v e r y   C h a r a c t e r   O f   T h e\n    \n    A l p h a b e t                                         _BRK_\n    \n    \n    I t   F e a t u r e s   M a n u a l   A n d   \n    \n    A u t o m a t i c    R e t u r n s   T o   L i n e                          \n    \n    P l u s   C u s t o m   T h e m e s   _EXC_             _BRK_ \n                                                            _BRK_\n                                                            \n    K i s h i m i s u\n;}", "image_inputs": [], "common_code": "// Number of characters before returning to line\n#define COLS 27. \n\n// Characters X and Y spacing\n#define CW 3.2\n#define CH 1.2\n\n#define ZOOM 1.\n#define OFFSET vec2(45, -15)\n\n#define rr iResolution.xy\n\n// 2D rotation matrix\n#define ro(a) mat2(cos(a + vec4(0,33,11,0)))\n\n// segment sdf\n#define zu(p,a,b) length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.))\n\n// rotated arc sdf\n#define ra(p,a,r) ra_(p,a,r,tt)\nfloat ra_(vec2 p, float a, float r, vec4 t) {\n    vec2   sc = vec2(sin(a),cos(a)); p *= ro(r); p.x = abs(p.x);\n    return sc.y*p.x>sc.x*p.y ? length(p-sc*t.z) : abs(length(p)-t.z);\n}\n\n// character position update\n#define ki ; ww=vec4(pp-=vec2(CW,0)-CW*vec2(COLS,CH)*step(pp[0]-p0[0]-1e-4,-CW*COLS),qq=abs(pp))mi\n// character drawing\n#define mi ; OO += .015*GLOW_INTENSITY*(THEME)/\n\n// primitive shapes (had fun with the naming)\n#define shi zu(pp, -zz, -zz* iv)                           // vertical   left\n#define sa  zu(qq  -zx, -xz, xz)                           // vertical   left right \n#define ka  zu(pp, -xz,  xz)                               // vertical   mid\n#define to  zu(pp  -xz, -zx, zx)                           // horizontal top\n#define re  zu(qq  -xz, -zx, zx)                           // horizontal top bottom\n#define mu  zu(pp, -zx,  zx)                               // horizontal mid\n#define za  abs(length(pow(abs(pp*.95), vec2(1.2)))-tt[2]) // O (& Q)\n#define su  ra(pp*vec2(.6,1.5)+vec2(.4,-.75), 1.7, 1.6)    // P (& R)\n#define gu  ra(pp*vec2(.75,.9)-vec2(.3,0)   , 1.9, 4.7)    // C (& G)\n\n// letters (is this a japanese poem?)\n#define a ki zu(ww.zy*iv-yx, -yz, yz) mi zu(pp, -zy, zy*iv)\n#define b ki shi mi ra(ww.xw*vec2(.6,1.7)+vec2(.4,-tt[2]), 1.7, 1.6)\n#define c ki gu\n#define d ki shi mi ra(pp*vec2(.6,1)+vec2(.4,0), 1.7, 1.6)\n#define e ki shi mi mu mi re\n#define f ki shi mi mu mi to\n#define g ki gu  mi zu(pp*iv, zy, zz)\n#define h ki sa  mi mu\n#define i ki ka  mi re\n#define j ki zu(pp, zz, zx) mi ra(pp, .9, 2.6)\n#define k ki shi mi zu(ww.xw, -yx, zz)\n#define l ki shi mi zu(pp, -zz, zz*iv)\n#define m ki sa  mi zu(ww.yz, zz,)\n#define n ki sa  mi zu(pp*iv, zz, -zz)\n#define o ki za\n//        ki shi mi su !\n#define p ki shi mi su\n#define q ki za  mi zu(pp, tt.xx, zz*iv)\n#define r ki shi mi su mi zu(pp, -zx, zz*iv)\n#define s ki abs(zu(pp + vec2(sin(pp[1]*3.),0), -xz, xz)-.05)\n#define t ki ka  mi to\n#define u ki ra(pp, 1.4, 3.14) mi zu(ww.zy, zz, zx)\n#define v ki zu(ww.zy-yx, -yz, yz)\n#define w ki zu(vec2(abs(ww[2] - .5), ww[1]*.6+.4), -yz, yz)\n#define x ki zu(qq, zz, -zz)\n#define y ki zu(ww.zy, zz,) mi zu(pp, -xz,)\n#define z ki re mi zu(pp, -zz, zz)\n\n// Space, return to line and exclamation mark\n#define _     ;  pp[0] -= CW*step(-CW*COLS,pp[0]-p0[0]-1e-4)\n#define _BRK_ ;  ww=vec4(pp+=vec2(p0[0]-pp[0]+CW,CW*CH),qq=abs(pp))\n#define _EXC_ ki zu(pp, xz,) mi abs(length(pp+xz)-.05)\n\n// Handle EVERY character of the alphabet. \n// This means that every variable name must be at least 2 chars long\n// And we need to access x,y,z,w components with [0], [1] and so on...\n#define A _ a \n#define B _ b\n#define C _ c\n#define D _ d\n#define E _ e\n#define F _ f\n#define G _ g\n#define H _ h\n#define I _ i\n#define J _ j\n#define K _ k\n#define L _ l\n#define M _ m\n#define N _ n\n#define O _ o\n#define P _ p\n#define Q _ q\n#define R _ r\n#define S _ s\n#define T _ t\n#define U _ u\n#define V _ v\n#define W _ w\n#define X _ x\n#define Y _ y\n#define Z _ z", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt23z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtj3DG", "name": "Breathing Liquid", "author": "cinmin", "description": "調整trace迴圈數和步數 玩Raymarching物體與背景空間扭曲的關係\n*drag to mouve camera", "tags": ["raymarching", "reflection"], "likes": 3, "viewed": 187, "published": 3, "date": "1673878521", "time_retrieved": "2024-07-30T18:15:35.267961", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    \t\tfloat strength = 0.4;\n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\t//請小心！QC迴圈最好使用int index，float index有可能錯誤！\n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.5 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*1.5 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.xyx+vec3(0,2,4));\n\t\t//Gamma\n\t\tcol = pow(col, vec3(0.4545));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.1);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(mouse.x,mouse.y,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=-0.288 * (noise_3(p*3.0)*2.0-1.0);\nvec3 p1 = p + bump;\n\nreturn sdTorus(p1+vec3(sin(iTime*0.3)*0.2,sin(iTime)*0.5,0.0),vec2(0.4,0.2));\n\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    //ret.x = pow(1.0-e.y,3.0);\n    //ret.y = pow(1.0-e.y, 1.2);\n    //ret.z = 0.8+(1.0-e.y)*0.3;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    uv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, mouse.y, mouse.x); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    vec3 bump=normalMap(p*1.652,n);\n    n=n+bump*0.05;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.072, 0.956, edge);\n    \n    \n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n    //result = vec3(edge);\n    result= phong(p,n,-RayDir)*ao;  //攝影機觀看視角(V)要轉負的，因為是方向是從物體發出到攝影機  //需要外接的話燈光另外寫\n    //result*=(1.-edge);\n//HDR環境貼圖\n    vec3 refl = reflect(RayDir,n);\n    vec3 refl_clr=warpSky(refl);\n\t//vec3 BG=vec3(0.99);\t   \n    vec3 BG=refl_clr;\n\n\nif(t<2.5) fragColor = vec4(vec3(result),1.0); else fragColor = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 273, 294, 552], [554, 554, 590, 613, 1109], [1111, 1111, 1132, 1132, 1226], [1229, 1229, 1264, 1264, 2614], [2616, 2645, 2680, 2680, 2706], [2707, 2707, 2738, 2738, 2825], [2826, 2826, 2859, 2859, 2924], [2927, 2927, 2970, 3013, 3057], [3059, 3059, 3081, 3081, 3229], [3231, 3260, 3306, 3306, 3524], [3527, 3556, 3597, 3597, 3739], [3779, 3779, 3803, 3818, 4052], [4054, 4054, 4078, 4099, 4279], [4281, 4281, 4305, 4305, 4330], [4332, 4359, 4411, 4411, 4588], [4590, 4598, 4624, 4624, 4994], [4997, 5017, 5073, 5073, 6793], [6814, 6843, 6866, 6866, 6916], [6917, 6917, 6939, 6939, 7019], [7020, 7020, 7042, 7042, 7130], [7132, 7144, 7170, 7170, 7791], [7792, 7817, 7865, 7865, 7903], [7905, 7934, 7980, 7980, 8118], [8119, 8119, 8169, 8169, 8590], [8591, 8591, 8637, 8637, 8895], [8897, 8930, 8961, 8961, 9049], [9051, 9051, 9092, 9092, 9288], [9334, 9334, 9372, 9372, 9771], [9773, 9773, 9805, 9805, 10121], [10123, 10148, 10190, 10190, 10535], [10537, 10606, 10640, 10640, 10818], [10820, 10820, 10861, 10861, 10976], [10978, 10978, 11005, 11005, 11078]], "test": "untested"}
{"id": "DsfSRB", "name": "Liquid Metal Emergence", "author": "cinmin", "description": "- lighting and colors test\n- smooth edges\n- use grid to let background has different texture\n- drag to interact", "tags": ["raymarching", "reflection"], "likes": 1, "viewed": 203, "published": 3, "date": "1673877887", "time_retrieved": "2024-07-30T18:15:36.027929", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); // [0,1]\nvec3 FlameColour(float f);\nfloat fbm(in vec2 uv);\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    \t\tfloat strength = 0.4;\n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.5 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*1.5 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.xyx+vec3(0,2,4));\n\t\t//Gamma\n\t\tcol = pow(col, vec3(0.4545));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.1);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(-10.,-10.,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nvec4 m = (iMouse / iResolution.x)*2.0-1.0;\nfloat bump=-0.288 * (noise_3(p*3.0)*2.0-1.0);\nvec3 p1 = p + bump;\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5);\nfloat shape1 =sdTorus(p1+vec3(sin(iTime*0.3)*0.2,sin(iTime)*0.5,0.0),vec2(0.1,0.01));\nfloat shape2 =sdTorus(p1-vec3(m.x,m.y,0.5)+vec3(sin(iTime*0.3)*0.2,sin(iTime)*0.5,0.0),vec2(0.1,0.01));\nfloat sphere=sdSphere(p1-vec3(.0,.0,sin(iTime)),0.1);\nfloat sphere2=sdSphere(p1-vec3(.2,.2,sin(iTime)),0.1);\nfloat shapes=min(shape1,sphere2);\\\n\n//return sphere;\n//return shapes;\nreturn min(shapes,shape2);\n\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\nvec3 BlendColor( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\nvec3 grid3D(vec3 p, float scale){\n    return floor(p*scale)/scale;\n}\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n    \n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\nvec3 gridTrace(vec3 o, vec3 r,  vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n    \n\td=map(grid3D(p,30.));\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn p;\n}\n\n\n\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n// ================\nvoid  mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nuv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\nvec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n// camera option1  (模型應在原點，適用於物件)\n\t// vec3 CameraRot=vec3(0.0, mouse.y, mouse.x); \n    vec3 CameraRot=vec3(0.0, 0.,0.); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n,grid_n;\n\tfloat t = trace(RayOri, RayDir, p);\n     vec3 grid_p=gridTrace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    grid_n=normalize(gradient(grid_p));\n    vec3 bump=normalMap(p*1.652,n);\n    n=n+bump*0.05;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.2, 0.256, edge);\n    \n    edge=edge+1.*0.3;\n    edge=min(1.,edge);\n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n    //result = vec3(edge);\n    result= phong(p,n,-RayDir)*ao;  //攝影機觀看視角(V)要轉負的，因為是方向是從物體發出到攝影機  //需要外接的話燈光另外寫\n    result*=edge;\n//HDR環境貼圖\n    vec3 refl = reflect(RayDir,grid_n);\n    vec3 refl_clr=warpSky(refl);\n\tvec3 BG=refl_clr*0.3;\t   //或getSkyFBM(RayDir)\n\n\n\nif(t<2.5) fragColor = vec4(vec3(result),1.0); else fragColor = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 284, 305, 563], [565, 565, 601, 624, 1042], [1044, 1044, 1065, 1065, 1159], [1162, 1162, 1197, 1197, 2541], [2543, 2572, 2607, 2607, 2633], [2634, 2634, 2665, 2665, 2752], [2753, 2753, 2786, 2786, 2851], [2854, 2854, 2897, 2940, 2984], [2986, 2986, 3008, 3008, 3560], [3562, 3591, 3637, 3637, 3855], [3857, 3857, 3905, 3905, 4123], [4124, 4124, 4157, 4157, 4192], [4194, 4223, 4264, 4264, 4411], [4413, 4413, 4454, 4454, 4613], [4618, 4645, 4697, 4697, 4874], [4876, 4884, 4910, 4910, 5280], [5283, 5303, 5361, 5361, 7230], [7251, 7280, 7303, 7303, 7353], [7354, 7354, 7376, 7376, 7456], [7457, 7457, 7479, 7479, 7567], [7569, 7581, 7607, 7607, 8228], [8229, 8254, 8302, 8302, 8340], [8342, 8371, 8417, 8417, 8555], [8556, 8556, 8606, 8606, 9027], [9028, 9028, 9074, 9074, 9332], [9334, 9367, 9398, 9398, 9486], [9488, 9488, 9529, 9529, 9725], [9771, 9771, 9809, 9809, 10208], [10210, 10210, 10242, 10242, 10558], [10560, 10585, 10627, 10627, 10972], [10974, 11043, 11077, 11077, 11255], [11257, 11257, 11298, 11298, 11413], [11415, 11415, 11442, 11442, 11515]], "test": "untested"}
{"id": "mt23WG", "name": "Path tracer v1.0", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it.", "tags": ["raymarching", "clouds", "pathtracer"], "likes": 0, "viewed": 172, "published": 3, "date": "1673877874", "time_retrieved": "2024-07-30T18:15:36.855717", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.0,vec3(0.,120.,-50.),vec3(1.,.95,.85),2.)\n#define inf 10000.\n\n#define _randsettings vec3(48973.,3942067.,539.)\n#define _fogB .01\n#define _fogA .01\n\n#define maxcomp(a) max(a.x,a.y)\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed += _randsettings.z;\n    return mod(_randsettings.y*(seed-_randsettings.z) + _randsettings.z,_randsettings.x)/_randsettings.x;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time+sin(time-c.x)*c.x-iResolution.y*(cos(c.y-time)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nfloat sdCross( vec3 p ) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.;\n}\n\n\n\n/////World\nvec2 map(in vec3 p,float ctime) {\n   vec3 q = (p-vec3(0.,.5,15.))/9.; // vec3(0.,.5,15.) // v(0.)\n   float d0 = sdBox(q,v(0.),vec4(v(1.),0.))*9.;\n   float c = sdCross(q*3.)/3.*9.;\n    \n   float s = 1.;\n   vec3 l = p;\n   for( float m=0.; m<3.; m++ )\n   {\n      l += vec3(.05,.1,-.15)*pow(m,3.);\n      vec3 a = mod( l*s, 1. )-.5;\n      s *= 3.;\n      vec3 r = 1. - 3.*abs(a);\n\n      float c = sdCross(r*3.)/s/3.;\n      d0 = max(d0,c);\n   }\n   \n   float d1 = sdSphere(p,vec4(0.,0.,6.,2.));\n   float d2 = sdSphere(p,vec4(-1.5,3.,6.,1.5));\n   float d3 = sdSphere(p,vec4(1.5,3.,6.,1.5));\n   \n   float d = min(d0,min(d1,min(d2,d3)));\n   \n   float mat;\n   mat = 0.;\n   if(d==d1) mat=1.;\n   if(d==d2||d==d3) mat=2.;\n   \n   return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float ctime) {\n    float d0 = map(p,ctime).x;\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,ctime).x,\n    map(p-e.yxy,ctime).x,\n    map(p-e.yyx,ctime).x);\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime) {\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0),ctime);\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.283185;\n    float x = rand1()*2.-1.;\n    float z = rand1();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid setMat(vec3 color, float fp, float  g, float drr, out vec3 scol, out vec3 sdat) {\n    scol = color;\n    sdat = vec3(fp,g,drr);\n}\n\nvoid worldGetMat(float id, vec3 n, out vec3 col, out vec3 dat) {\n    if(id==0.) setMat(v(.2),4.,.9,.7,col,dat);\n    if(id==1.) setMat(vec3(.2,.15,.05),2.,.6,.8,col,dat);\n    if(id==2.) setMat(v(.03),7.,1.,.9,col,dat);\n}\n\nvec3 applyFog(in vec3 col, float dist, vec3 rd, vec3 ro, vec3 ld) {\n    float fa = (_fogA/_fogB) * exp(-ro.y*_fogB) * (1.-exp(-dist*rd.y*_fogB))/rd.y;\n    float sa = max(dot(rd,ld),0.);\n    vec3 fc = mix(vec3(.5,.6,.7),vec3(1.,.9,.7),pow(sa,8.));\n    return mix(col,fc,fa);\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, vec3 m) {\n    ro = p+n*OFFSET;\n    if(rand1() < m.z) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = m.y*sat(pow(1.-dot(-rd,n),m.x));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww) {\n    time += 1.;\n    ro = vec3(cos(time*2.)*4.,sin(time)*2.+2.,sin(time*2.5)*4.);\n    //ro = v(0.);\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    float td = 0.;\n    for(float i = 0.; i < 2.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        td += d;\n        if (hit == true) {\n            float tdReq = 10.;\n            tdReq += tdReq/(i+1.);\n            if(td > tdReq) break;\n            \n            vec3 n = getNormal(p,ctime);\n            vec3 ld = LIGHT.pos-p;\n            float dif = diffuse(p,ld,n,ctime);\n            ld = normalize(ld);\n            //float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n            vec3 sdat;\n            worldGetMat(mat,n,scol,sdat);\n            \n            vec3 diffuse = (dif*.5+.5)*LIGHT.str*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += applyFog(fcol * dcol,d,rd,ro,ld);\n            \n            \n            getBRDFRay(ro,rd,p,n,sdat);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime);\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initRand(float(iFrame),fragCoord);\n    \n    float frameTime = float(iFrame)*(1./30.);\n    \n    float spp     = 1.;\n    float shutAp  = .6;\n    float blurAmt = .0015;\n    float fcsDist = 1.3;\n    bool  perfect = false; //Removes all blurring if true;\n    \n    if(perfect) {shutAp=.0;blurAmt=.0;fcsDist=100.;}\n    \n    vec3 qcol = v(0.);\n    for(float i = 0.; i < spp; i++) {\n        vec2 of = -.5 + fract(rand2());\n        if(perfect) of = vec2(0.);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        \n        float ctime = (iTime*1.)-3. + shutAp*(1./24.)*rand1();\n        getCam(ctime,ro,uu,vv,ww); \n        vec3 er = normalize(vec3(p,1./tan(FOV*PI/360.)));\n        vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist-go);\n        ro += go.x*uu+go.y*vv;\n        rd += gd.x*uu+gd.y*vv;\n        \n        //vec3 rdOrig = rd;\n        vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n        qcol += col;\n        //qcol += ro;\n    }\n    qcol /= spp;\n    qcol = pow(qcol,v(1./2.2));\n    fragColor = vec4(qcol,1.);\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt23WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 336, 336, 473], [474, 474, 492, 492, 522], [523, 523, 557, 557, 679], [682, 689, 735, 782, 1576], [1633, 1633, 1670, 1670, 1714], [1716, 1716, 1768, 1768, 1875], [1877, 1877, 1914, 1914, 2009], [2011, 2011, 2040, 2040, 2116], [2118, 2118, 2143, 2143, 2276], [2280, 2291, 2324, 2324, 3026], [3028, 3028, 3064, 3064, 3255], [3257, 3257, 3321, 3321, 3515], [3518, 3518, 3583, 3583, 3959], [3961, 3961, 4016, 4016, 4238], [4240, 4240, 4292, 4292, 4436], [4438, 4438, 4459, 4506, 4661], [4663, 4663, 4686, 4686, 4855], [4857, 4857, 4943, 4943, 4990], [4992, 4992, 5056, 5056, 5211], [5213, 5213, 5280, 5280, 5488], [5490, 5490, 5561, 5561, 5820], [5822, 5822, 5901, 5901, 6077], [6079, 6079, 6162, 6162, 7352], [7354, 7354, 7411, 7411, 8650]], "test": "untested"}
{"id": "Dlf3zH", "name": "Square Field", "author": "PlaNex", "description": "Squares react to mouse position!", "tags": ["simple", "interactive"], "likes": 7, "viewed": 205, "published": 3, "date": "1673864752", "time_retrieved": "2024-07-30T18:15:37.603716", "image_code": "// settings\nconst int ROWS = 12,\n          COLUMNS = 20;\n\nconst vec4 BACKGROUND = vec4(80, 57, 76 , 255) / 255.,\n           SQUARECOLOR = vec4(255, 239, 150,  255) / 255.;\n\n// constants\nconst float DIAGONALTOSIDE = 1.4142;\n\nstruct square \n{\n    vec2 centre;\n    float sideLength;\n    float radians;\n    vec4 color;\n};\n\nfloat getAngle(vec2 origin, vec2 dir)\n{\n    dir = dir - origin;\n    return atan(dir.x, dir.y);\n}\n\nbool isInSquare(square checkSq, vec2 coords)\n{\n    float sqSin = sin(checkSq.radians);\n    float sqCos = cos(checkSq.radians);\n    mat2 rotationMatrix = mat2(sqCos,-sqSin,sqSin,sqCos);\n    \n    coords = (coords - checkSq.centre) * rotationMatrix;\n    coords = checkSq.centre + coords;\n    coords = abs( coords - checkSq.centre );\n    \n    return max( coords.x, coords.y ) < checkSq.sideLength / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = BACKGROUND;\n    \n    vec2 COUNT = vec2(COLUMNS, ROWS),\n         BetweenSq = iResolution.xy / ( COUNT + 1. ),\n         diag = BetweenSq * DIAGONALTOSIDE / 2.;\n         \n    float squareSide = min(diag.x, diag.y) * 0.9;\n    \n    vec2 Pos = floor( fragCoord / BetweenSq +.5 ) -.5;\n    if ( Pos.x>0. && Pos.y>0. && Pos.x < COUNT.x && Pos.y < COUNT.y )\n    {\n        Pos = Pos*BetweenSq + BetweenSq/2.;\n        square sq = square(Pos, squareSide, getAngle(Pos, iMouse.xy), SQUARECOLOR);\n        if (isInSquare(sq, fragCoord)) fragColor = sq.color;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 358, 358, 415], [417, 417, 463, 463, 817], [819, 819, 876, 876, 1444]], "test": "untested"}
{"id": "Dl2GWy", "name": "Basic print number example", "author": "wingei", "description": "Utility code to print numbers. \nExample display shader time, date, time, mouse co-ordinates and value on sin wave.\nIt can be useful to print values when tweaking shaders.\nNote - the values are not always accurate :)", "tags": ["utility", "numbers", "font", "digits"], "likes": 1, "viewed": 589, "published": 3, "date": "1673862444", "time_retrieved": "2024-07-30T18:15:38.366676", "image_code": "// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Disclaimer: The values printed may not be accurate!\n// Accuracy improvement for fractional values taken from TimoKinnunen https://www.shadertoy.com/view/lt3GRj\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\n// Original interface\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    \n    return PrintValue( vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n\n\n\t// Print a custom value\n\tvec2 vPixelCoord1 = vec2(5.0, 5.0);\n    float customValueToPrint = 7.0;\n    \n    float customDigit = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, customValueToPrint, 1.0, 1.0);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), customDigit);\n    \n\n\tfragColor = vec4(vColour,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GWy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1080, 1080, 1111, 1111, 1269], [1271, 1271, 1365, 1365, 2401], [2822, 2822, 2879, 2879, 3285]], "test": "untested"}
{"id": "dtSGWG", "name": "neighbors 4", "author": "jonasfrey", "description": "vonoroi", "tags": ["vonoroi"], "likes": 5, "viewed": 186, "published": 3, "date": "1673822569", "time_retrieved": "2024-07-30T18:15:39.206432", "image_code": "\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n\nfloat f_n_rand(float n){\n    n = n+n+n*.2133;\n    n = n*n*0.231;\n    n = sin(n*1.2324+123.1*n)*124.123;\n    return fract(n);\n}\nfloat f_n_dist_sqr(vec2 o){\n    float n = max(abs(o.x), abs(o.y));\n    return n; \n}\nfloat f_n_dist(vec2 o_trn_fc_nor_offset, vec2 o_scl, vec2 o_trn){\n    o_trn_fc_nor_offset*=o_scl;\n    \n    float n_index = (o_trn_fc_nor_offset.x)\n        + floor(o_trn_fc_nor_offset.y) * o_scl.x;\n        \n    vec2 o = o_trn_fc_nor_offset+floor(o_trn);\n    float n_x_nor = floor(o.x) / o_scl.x;\n    float n_index_floor = floor(o.x)\n        + floor(o.y) * o_scl.x;\n    float n_index_nor = floor(n_index) / (o_scl.x*o_scl.y);\n    float n_rand = f_n_rand(iTime*0.0001+n_index_floor/(o_scl.x*o_scl.y))-0.5;\n    //n_rand = 0.;\n    vec2 o2 = (fract(o_trn_fc_nor_offset)-(o_trn)-0.5);\n    float n_tau = 6.2831;\n    o2 = f_o_rotd(o2, sin(iTime+n_index_nor*0.2*n_tau));//+sin(n_index+iTime);\n    o2 *= (sin(n_x_nor*n_tau+iTime*10.)*0.5+0.5)*2.+1.;\n    float n_dist = f_n_dist_sqr(o2);\n    \n    //n_dist = pow(n_dist, 1./5.)*1.;\n    //n_dist = 1.-n_dist;\n    //return n_index_floor / (o_scl.x * o_scl.y);\n    return n_dist;\n}\nvec2 f_o_index(vec2 o_trn, vec2 o_scl){\n    float n_index_floor = floor(o_trn.x)\n        + floor(o_trn.y) * o_scl.x;\n    return vec2(\n        n_index_floor, \n        n_index_floor / floor(o_scl.x*o_scl.y)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    vec2 o_scl = vec2(11.);\n    \n    vec2 o_scl_krn = vec2(3.);\n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    vec2 omin = vec2(0.);\n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        float n_dist = f_n_dist(o_trn_fc_nor_offset, o_scl, vec2(n_x, n_y));\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            omin = (o_trn_fc_nor_offset*o_scl) + vec2(n_x, n_y);\n        }\n        //n_dmin = n_dist;\n    }\n    \n    fragColor = vec4(1.-(n_dmin*n_dmin*n_dmin*10.));\n    \n    if(o_trn_fc_nor_offset.x > 0.){\n        vec2 o_index = f_o_index(floor(omin), o_scl);\n        float nr = f_n_rand(abs(o_index.g)*2.);\n        float nr2 = f_n_rand(nr);\n        fragColor = vec4(nr, nr2, 0.5, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 237], [239, 239, 263, 263, 365], [366, 366, 393, 393, 449], [450, 450, 515, 515, 1365], [1366, 1366, 1405, 1405, 1579], [1580, 1580, 1637, 1637, 2979]], "test": "untested"}
{"id": "DlB3Dy", "name": "neighbors 3", "author": "jonasfrey", "description": "vonoroi", "tags": ["vonoroi"], "likes": 4, "viewed": 173, "published": 3, "date": "1673822012", "time_retrieved": "2024-07-30T18:15:39.953434", "image_code": "float f_n_rand(float n){\n    n = n+n+n*.2133;\n    n = n*n*0.231;\n    n = sin(n*1.2324+123.1*n)*124.123;\n    return fract(n);\n}\nfloat f_n_dist_sqr(vec2 o){\n    float n = max(abs(o.x), abs(o.y));\n    return n; \n}\nfloat f_n_dist(vec2 o_trn_fc_nor_offset, vec2 o_scl, vec2 o_trn){\n    o_trn_fc_nor_offset*=o_scl;\n    \n    float n_index = (o_trn_fc_nor_offset.x)\n        + floor(o_trn_fc_nor_offset.y) * o_scl.x;\n        \n    vec2 o = o_trn_fc_nor_offset+floor(o_trn);\n    \n    float n_index_floor = floor(o.x)\n        + floor(o.y) * o_scl.x;\n        \n    float n_rand = f_n_rand(iTime*0.0001+n_index_floor/(o_scl.x*o_scl.y))-0.5;\n    //n_rand = 0.;\n    vec2 o2 = (fract(o_trn_fc_nor_offset)-(o_trn))+sin(n_index+iTime);\n    float n_dist = f_n_dist_sqr(o2);\n    \n    //n_dist = pow(n_dist, 1./5.)*1.;\n    //n_dist = 1.-n_dist;\n    //return n_index_floor / (o_scl.x * o_scl.y);\n    return n_dist;\n}\nvec2 f_o_index(vec2 o_trn, vec2 o_scl){\n    float n_index_floor = floor(o_trn.x)\n        + floor(o_trn.y) * o_scl.x;\n    return vec2(\n        n_index_floor, \n        n_index_floor / floor(o_scl.x*o_scl.y)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    vec2 o_scl = vec2(33.,33.);\n    \n    vec2 o_scl_krn = vec2(6.,6.);\n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    vec2 omin = vec2(0.);\n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        float n_dist = f_n_dist(o_trn_fc_nor_offset, o_scl, vec2(n_x, n_y));\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            omin = (o_trn_fc_nor_offset*o_scl) + vec2(n_x, n_y);\n        }\n        //n_dmin = n_dist;\n    }\n    \n    fragColor = vec4(n_dmin*n_dmin*n_dmin*10.);\n    \n    if(o_trn_fc_nor_offset.x > 0.){\n        vec2 o_index = f_o_index(floor(omin), o_scl);\n        float nr = f_n_rand(abs(o_index.g)*2.);\n        float nr2 = f_n_rand(nr);\n        fragColor = vec4(nr, nr2, 0.5, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlB3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 126], [127, 127, 154, 154, 210], [211, 211, 276, 276, 892], [893, 893, 932, 932, 1106], [1107, 1107, 1164, 1164, 2508]], "test": "untested"}
{"id": "dt2GRd", "name": "Path Tracer v0.4", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it.", "tags": ["raymarching", "clouds", "pathtracer"], "likes": 0, "viewed": 147, "published": 3, "date": "1673818749", "time_retrieved": "2024-07-30T18:15:40.736340", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.0,vec3(0.,120.,-50.),vec3(1.,.95,.85),2.)\n#define inf 10000.\n\n#define _randsettings vec3(48973.,3942067.,539.)\n#define _fogB .01\n#define _fogA .01\n\n#define maxcomp(a) max(a.x,a.y)\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed += _randsettings.z;\n    return mod(_randsettings.y*(seed-_randsettings.z) + _randsettings.z,_randsettings.x)/_randsettings.x;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time+sin(time-c.x)*c.x-iResolution.y*(cos(c.y-time)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nfloat sdCross( vec3 p ) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.zx));\n  return min(da,min(db,dc))-1.;\n}\n\n\n\n/////World\nvec2 map(in vec3 p,float ctime) {\n   vec3 q = (p-vec3(0.,.5,15.))/9.; // vec3(0.,.5,15.) // v(0.)\n   float d0 = sdBox(q,v(0.),vec4(v(1.),0.))*9.;\n   float c = sdCross(q*3.)/3.*9.;\n    \n   float s = 1.;\n   vec3 l = p;\n   for( float m=0.; m<3.; m++ )\n   {\n      l += vec3(.05,.1,-.15)*pow(m,3.);\n      vec3 a = mod( l*s, 1. )-.5;\n      s *= 3.;\n      vec3 r = 1. - 3.*abs(a);\n\n      float c = sdCross(r*2.)/s/2.;\n      d0 = max(d0,c);\n   }\n   \n   float d1 = sdSphere(p,vec4(0.,0.,5.,2.));\n   float d2 = sdSphere(p,vec4(-1.5,3.,5.,1.5));\n   float d3 = sdSphere(p,vec4(1.5,3.,5.,1.5));\n   \n   float d = min(d0,min(d1,min(d2,d3)));\n   \n   float mat;\n   mat = 0.;\n   if(d==d1) mat=1.;\n   if(d==d2||d==d3) mat=2.;\n   \n   return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float ctime) {\n    float d0 = map(p,ctime).x;\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,ctime).x,\n    map(p-e.yxy,ctime).x,\n    map(p-e.yyx,ctime).x);\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime) {\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0),ctime);\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.283185;\n    float x = rand1()*2.-1.;\n    float z = rand1();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid setMat(vec3 color, float fp, float  g, float drr, out vec3 scol, out vec3 sdat) {\n    scol = color;\n    sdat = vec3(fp,g,drr);\n}\n\nvoid worldGetMat(float id, vec3 n, out vec3 col, out vec3 dat) {\n    if(id==0.) setMat(v(.2),4.,.9,.7,col,dat);\n    if(id==1.) setMat(vec3(.2,.15,.05),2.,.6,.8,col,dat);\n    if(id==2.) setMat(v(.03),7.,1.,.9,col,dat);\n}\n\nvec3 applyFog(in vec3 col, float dist, vec3 rd, vec3 ro, vec3 ld) {\n    float fa = (_fogA/_fogB) * exp(-ro.y*_fogB) * (1.-exp(-dist*rd.y*_fogB))/rd.y;\n    float sa = max(dot(rd,ld),0.);\n    vec3 fc = mix(vec3(.5,.6,.7),vec3(1.,.9,.7),pow(sa,8.));\n    return mix(col,fc,fa);\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, vec3 m) {\n    ro = p+n*OFFSET;\n    if(rand1() < m.z) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = m.y*sat(pow(1.-dot(-rd,n),m.x));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww) {\n    time += 1.;\n    ro = vec3(cos(time*2.)*4.,sin(time)*2.+2.,sin(time*2.5)*4.);\n    //ro = v(0.);\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    float td = 0.;\n    for(float i = 0.; i < 2.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        td += d;\n        if (hit == true) {\n            float tdReq = 30.;\n            tdReq += tdReq/i;\n            if(td > tdReq) break;\n            \n            vec3 n = getNormal(p,ctime);\n            vec3 ld = LIGHT.pos-p;\n            float dif = diffuse(p,ld,n,ctime);\n            ld = normalize(ld);\n            //float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n            vec3 sdat;\n            worldGetMat(mat,n,scol,sdat);\n            \n            vec3 diffuse = (dif*.5+.5)*LIGHT.str*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += applyFog(fcol * dcol,d,rd,ro,ld);\n            \n            \n            getBRDFRay(ro,rd,p,n,sdat);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime);\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initRand(float(iFrame),fragCoord);\n    \n    float spp     = 1.;\n    float shutAp  = .4;\n    float blurAmt = .0075;\n    float fcsDist = .65;\n    bool  perfect = true; //Removes all blurring if true;\n    \n    if(perfect) {shutAp=.0;blurAmt=.0;fcsDist=100.;}\n    \n    vec3 qcol = v(0.);\n    for(float i = 0.; i < spp; i++) {\n        vec2 of = -.5 + fract(rand2());\n        if(perfect) of = vec2(0.);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        float frameTime = iTime;\n        float ctime = (iTime*1.)-3. + shutAp*(1./24.)*rand1();\n        getCam(ctime,ro,uu,vv,ww); \n        vec3 er = normalize(vec3(p,1./tan(FOV*PI/360.)));\n        vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist-go);\n        ro += go.x*uu+go.y*vv;\n        rd += gd.x*uu+gd.y*vv;\n        \n        //vec3 rdOrig = rd;\n        vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n        qcol += col;\n        //qcol += ro;\n    }\n    qcol /= spp;\n    qcol = pow(qcol,v(1./2.2));\n    fragColor = vec4(qcol,1.);\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2GRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 336, 336, 473], [474, 474, 492, 492, 522], [523, 523, 557, 557, 679], [682, 689, 735, 782, 1576], [1633, 1633, 1670, 1670, 1714], [1716, 1716, 1768, 1768, 1875], [1877, 1877, 1914, 1914, 2009], [2011, 2011, 2040, 2040, 2116], [2118, 2118, 2143, 2143, 2276], [2280, 2291, 2324, 2324, 3026], [3028, 3028, 3064, 3064, 3255], [3257, 3257, 3321, 3321, 3515], [3518, 3518, 3583, 3583, 3959], [3961, 3961, 4016, 4016, 4238], [4240, 4240, 4292, 4292, 4436], [4438, 4438, 4459, 4506, 4661], [4663, 4663, 4686, 4686, 4855], [4857, 4857, 4943, 4943, 4990], [4992, 4992, 5056, 5056, 5211], [5213, 5213, 5280, 5280, 5488], [5490, 5490, 5561, 5561, 5820], [5822, 5822, 5901, 5901, 6077], [6079, 6079, 6162, 6162, 7347], [7349, 7349, 7406, 7406, 8617]], "test": "untested"}
{"id": "mdSXDG", "name": "Terraforming in progress...", "author": "derSchamane", "description": "- drag mouse to rotate the camera\n- more information see code\n- should run smooth on fullscreen\n- give it some time to terraform \n\nmusic: der Schamane - live analog recording session 2020", "tags": ["3d", "raymarching", "fractal", "kifs"], "likes": 10, "viewed": 359, "published": 3, "date": "1673814215", "time_retrieved": "2024-07-30T18:15:41.488330", "image_code": "//               = Terraforming in progress... =         \n//               by Maximilian Knape   ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n\n\"\n...strange frequencies generating stunning interference patterns on nearly every surface.\nBy following the symmetrical wave patterns to its core we found a kind of ancient technology.\nIt may seem old to us, but it feels like it's still fully active and oddly somehow alive.\nAfter a few days we were able to recover parts of the communication protocol from this object:\n\n    [...]\n    MX3I-2718 | 3708110813 : landing site found\n    MX3I-2718 | 3708110901 : landing successful\n    MX3I-2718 | 3708110903 : system cool down\n    MX3I-2718 | 3708122100 : terraforming module initializing\n    MX3I-2718 | 3708122254 : terraforming in progress...\n    MX3I-2718 | 3708122255 : estimate date of completion...\n    MX3I-2718 | 3709040723 : earliest possible returnal in 231y249d2h56m3s\n    MX3I-2718 | 3709040724 : deactivation message - \"I will be eagerly awaiting you, but \n                             now it's time to let go. I will never forget you and who created me...\"\n    MX3I-2718 | 3709040725 : set transmission state to standby\n    MX3I-2718 | 3709040726 : [BASE SIGNAL LOST]\n\n    [END OF LOG - DRONE MX3I-2718]\n\nThis is all we have for now.\nI hope this clears things up and we all know we need to prepare now!\n\nLove and Light\nCommander W. Bright\nStarfleet 73b1\nGalactic Federation\n\n\nPS: We drilled some holes in the ground and discovered caverns filled with a kind of extremely hot lava.\n\"\n\n*/\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 200\n#define STEP_FAC .9\n#define MAX_DIST 300.\n#define MIN_DIST .1\n\n#define SURF_DIST .01\n#define SURF_MUL 40.\n#define SURF_EXP 1.5\n\n#define GLOW_INT 1.0\n#define PP_CONT 0.6\n#define PP_VIGN 2.0\n#define AO_OCC 0.28\n#define AO_SCA 0.6\n\n#define iTime iTime*.8\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nmat2 Rot(float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(vec3 p, vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max(k-abs(a-b),0.);\n    return min(a, b) - h*h*.25/k;\n}\n\nfloat sin3(float x) { return sin(x)*sin(x)*sin(x); }\nvec3  sin3(vec3 x)  { return sin(x)*sin(x)*sin(x); }\n\nconst int iters = 7;\nconst vec3 fTra = vec3(0);\nconst vec3 fRot = vec3(0);\nconst vec4 k = vec4(2., 3.2, 4.5, 4.5);\n\nvec2 Map(vec3 p) \n{    \n    float d, col;\n    \n    vec3 po = p;\n    int i;\n    float x1, y1, \n    s = 10.,\n    lp = length(p);\n    p /= 2.;\n    p.xz = mod(abs(p.xz - s/2.), s) - s/2.;\n    p.y +=  length(dot(cos(po.zx/50.), sin(po.xz/30. + vec2(iTime/50.))))*10. * S(10., 50., lp)- \n            pow(length(po/100.), 3.)*3. +\n            S(20., 50., lp)*3.;\n    \n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 1e10; i++)\n    {\n        if (i > 0) \n        {\n            p += fTra - 1. - sin3(iTime / vec3(33,42,51));\n            p = Rot(p, fRot + .00001 + PI*.5*sin3(PI + iTime / vec3(61,52,43)));\n        }\n\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * k.x * (k.y - 1.) / k.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * k.x * (k.y - 1.) / k.y;\n\n        p.x = k.y * p.x - k.z * (k.y - 1.);\n        p.y = k.y * p.y - k.w * (k.y - 1.);\n        p.z = k.y * p.z;\n\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n    }\n    \n    d = length(p) * pow(k.y, float(-i));\n    col = 0.1;\n\n    float wv = sin(p.x/1e3+p.z/1e3);\n    float bt = pow(max(0., po.y + .1*wv), 1.2);\n    col = mix(col, 1.95, step(bt, d));\n    d = smin(d, bt*.6, 1.+.5*sin(po.x/1e2+iTime/3.));\n    \n    float sd = length(po - vec3(0,17.+sin(iTime/5.),0)) - .2*S(.3, 0., abs(fract(iTime/3.)-.5));\n    float sp = sd - 4.*(1.+pow(abs(cos(p.y/1e3)), 2.)*.1);\n    col = mix(col, 4.7, step(sp, d));\n    d = min(d, sp);\n    \n    s = sd - 4.05;\n    col = mix(col, -3.4, step(s, d));\n    d = min(d, s);\n\n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST) * \n                (1. - S(20., -.4 - 2.7*S(30., 10., p.y), length(p.xz)));\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .0, 1.); \n}\n\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = .001 + .150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(.0, 1. , 1. - 1.5 * occ);    \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb);\n    \n\treturn c.z * mix( vec3(1.), rgb, c.y);\n}\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 3.;\nconst vec3 sunCol = vec3(1., .8, .7) * 1.;\nconst vec3 skyCol = vec3(.3, .6, 1.) * 1.;\nconst float specExp = 5.;\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = CalcAO(p, n),\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad,\n          indi = 1.;\n    \n    return mix( indi * mix(ambCol, skyCol, .03) * col * amoc +       //ambient\n                mix(diff * col * sunCol,                             //diffuse\n                (spec * col + refl * mafa), mafa) * sunCol,          //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),                  //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., .85, .7);\n        case 1: return hsv2rgb_smooth(vec3(.61, .7, .5));\n        case 2: return hsv2rgb_smooth(vec3(.18, .3, .9));\n        case 3: return hsv2rgb_smooth(vec3(.3+.3*(.5+.5*sin(iTime/21.)), .6, .8));\n        case 4: return hsv2rgb_smooth(vec3(.95, .8, .6));\n    }\n    return vec3(0);\n}\n\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 20., -50. + sin3(iTime/42.) * 20.);\n    ro.yz *= Rot(m.y * PI/4. + PI/1.6);\n    ro.xz *= Rot(-m.x * PI + iTime/30.);\n    vec3 rd = R(uv, ro, vec3(0, 20, 0), 0.8);\n    \n    \n    vec3 lPos = vec3(1,3,3)*100.; \n    \n    vec3 col = skyCol;\n    vec3 p = vec3(0.);\n    \n    vec3 rmd = RayMarch(ro, rd);\n    p = ro + rd * rmd.x;\n    \n    vec3 bg = mix(vec3(0), skyCol, S(-100., 150., p.y));\n\n    if(rmd.x < MAX_DIST) \n    {\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        int ix = int(floor(abs(rmd.z)));\n        col = Palette(ix);\n        \n        if (ix == 1) \n        {\n            n = n * (dot(sin(p.xz/2.*Rot(1.+.1*sin(iTime/8.))), cos(p.xz/3.)*Rot(1.+.1*sin(iTime/5.)))*.03 + 1.);\n            col = col * (1. + (p.y+.1)*5.);\n            col = col * (1. + .05*pow(clamp(S(250., 20., length(p))*(p.y+.1)*4.5, 0., 1.1), 30.));\n        }\n        else if (ix == 0) col = mix(col, vec3(.6), .5+.5*dot(sin3(p/17.+5.), cos(Rot(p/13., vec3(4)))));\n        \n        col = Shade(col, shine, p, n, rd, lPos);   \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 2.));\n    \n    col = mix(col, bg, disFac);\n    col += pow(max(0., rmd.y / float(MAX_STEPS)), 1.5) * normalize(ambCol) * GLOW_INT;\n    \n    float dir = dot(rd, normalize(lPos));\n    col += pow(dir * disFac * .5+.5, 10.) * sunCol *.4;\n    col += 2e-5/(1e-5+S(1., -1., dir * disFac)) * sunCol;\n    \n    col *= 1. - 1./(1. + iTime/3.);\n    \n    fragColor = PP(col, uv);\n}\n", "image_inputs": [{"id": 31980, "src": "https://soundcloud.com/derschamane/mozhart-poweredub", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSXDG.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[2075, 2075, 2099, 2099, 2175], [2230, 2230, 2262, 2262, 2344], [2346, 2346, 2392, 2392, 2462], [2464, 2464, 2485, 2485, 2516], [2517, 2517, 2538, 2538, 2569], [2687, 2687, 2706, 2706, 4354], [4356, 4356, 4378, 4378, 4494], [4496, 4496, 4530, 4530, 5024], [5026, 5026, 5079, 5079, 5593], [5926, 5926, 5968, 5968, 6163], [6165, 6165, 6204, 6204, 6352], [6511, 6511, 6579, 6579, 7316], [7318, 7318, 7343, 7343, 7695], [7698, 7698, 7726, 7726, 7895], [7897, 7897, 7954, 7954, 9637]], "test": "untested"}
{"id": "DtSGWy", "name": "Moosic tunnel", "author": "Iliana", "description": "Simple tunnel that reacts to music.", "tags": ["soundcloud"], "likes": 2, "viewed": 226, "published": 3, "date": "1673812733", "time_retrieved": "2024-07-30T18:15:42.499626", "image_code": "\n\nfloat angle(vec2 v1, vec2 v2)\n{\n    return dot(normalize(v1), normalize(v2));\n}\n\nfloat map(float v, float imin, float imax, float omin, float omax)\n{\n    float idelta = imax - imin;\n    float odelta = omax - omin;\n    return ((v - imin) / idelta) * odelta + omin;\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 r = iResolution;\n    vec3 p = r/r + vec3(0.,0.,iTime*2.);\n\n    float c = 0.;\n    float grow = 2.;\n    float distFromCenter = length(iResolution.xy/2. - fragCoord);\n    float count = 200.;\n\n    for (float i = 1. + fract(iTime*3.)*grow; i<count; i+=grow)\n    {\n        float findex = (count-i)/count * float(BUFF_SIZE);\n        int index = int(round(findex));\n        float vol = readData1(iChannel0, index, 1);\n        vec4 height1 = readData4(iChannel0, index, 0);\n        vec4 height2 = readData4(iChannel0, index+1, 0);\n        vec4 height = height1 + height2 / 2.;\n\n\n\n        float n = i/count+iTime*0.2;\n        vec2 pos = vec2(noise(vec2(n, -n)), noise(vec2(-n,n)))*500.-iResolution.xy/4.;\n        float ag = (i * 0.05) - (iTime * 0.1) + 5.*angle(vec2(0.,1.),fragCoord - iResolution.xy/2. - pos);\n\n        float distFromOffset = length(iResolution.xy/2. - fragCoord + pos) +\n            noise(vec2(-n/grow-iTime*.01, ag*3.5-iTime)) * 1. *\n            length(iResolution.xy/2. - fragCoord + pos) + \n            height.a*-200.;\n        c = 1.- abs(2.* clamp(distFromOffset*0.1 -i, 0., 1.) - 1.);\n        float f = clamp(map(distFromOffset, 0., length(iResolution.xy)*0.3, 0., 1.), 0., 1.);\n        \n        fragColor += vec4((0.2+height.r)*c*f,(1.-height.b)*c*f,(1.-height.g)*c*f, 1.);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BUFF_SIZE 200\n\n\n#ifndef PI\n#define PI 3.141592653589\n#endif\n\n\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nivec2 divmod(int v1, int v2)\n{\n    int m = v1 % v2;\n    int d = (v1 - m) / v2;\n    return ivec2(d, m);\n}\n\nint coordToIndex(vec2 coord)\n{\n    return int(floor(coord.x)) * int(floor(coord.y));\n}\n\nfloat rect(float width, float height, float left, vec2 uv)\n{\n    if (uv.x >= left && uv.x < (left + width) && uv.y <= height) return 1.;\n    return 0.;\n}\n\nvoid arrange(float count, float index, out float width, out float left)\n{\n    width = 1. / count;\n    left = width * index;\n}\n\n#define getLevel(x, channel) (texelFetch(channel, ivec2(int(x*512.), 0), 0).r)\nfloat getVol(float samples, sampler2D channel) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples, channel); \n    return avg / samples;\n}\n\nfloat readBuffer(sampler2D tex, vec3 res, int index, int row, int channel)\n{\n    vec4 v = texelFetch(tex, ivec2(index, row), 0);\n    switch (channel)\n    {\n        case 0:\n        return v.r;\n        case 1:\n        return v.g;\n        case 2:\n        return v.b;\n        case 3:\n        return v.a;\n        default:\n        return 1.;\n    }\n}\n\n\nvec4 writeBuffer(vec4 col, vec2 fragCoord, int index, int row, vec3 res, int channel, float value)\n{\n    if (floor(fragCoord.x) == float(index) && floor(fragCoord.y) == float(row))\n    {\n        switch (channel)\n        {\n            case 0:\n                col.r = value;\n            break;\n            case 1:\n                col.g = value;\n            break;\n            case 2:\n                col.b = value;\n            break;\n            case 3:\n                col.a = value;\n            break;\n            default:\n            break;\n        }\n    }\n    return col;\n}\n\n\nfloat readData1(sampler2D tex, int id, int row) {\n    return texelFetch(tex, ivec2(id,row), 0).r;\n}\nvec3 readData3(sampler2D tex, int id, int row) {\n    return texelFetch(tex, ivec2(id,row), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id, int row) {\n    return texelFetch(tex, ivec2(id,row), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, int row, float value) {\n    if (floor(fragCoord.x) == float(id) && floor(fragCoord.y) == float(row))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, int row, vec3 value) {\n    if (floor(fragCoord.x) == float(id) && floor(fragCoord.y) == float(row))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, int row, vec4 value) {\n    if (floor(fragCoord.x) == float(id) && floor(fragCoord.y) == float(row))\n        col = value;\n        \n    return col;\n}\n\n\n// Convert vec4 to float[4]\nfloat[4] toArr(vec4 values)\n{\n    float res[4];\n    res[0]=values.r;\n    res[1]=values.g;\n    res[2]=values.b;\n    res[3]=values.a;\n    return res;\n}\n\n\n// Convert float[4] to vec4\nvec4 toVec(float arr[4])\n{\n    return vec4(arr[0],arr[1],arr[2],arr[3]);\n}\n\n// Data for transmission\nstruct Data\n{\n    float volume;\n    vec4 bands;\n    vec4 lastBands;\n    vec4 averages;\n    vec4 correctedFac;\n    vec4 mins;\n    vec4 maxs;\n};\n\n\n// Read data\nData readData(sampler2D tex, vec2 invRes, int row, int offset) {\n\tData data;\n    data.volume = readData1(tex, offset+0, row);\n    data.bands = readData4(tex, offset+1, row);\n    data.lastBands = readData4(tex, offset+2, row);\n    data.averages = readData4(tex, offset+3, row);\n    data.correctedFac = readData4(tex, offset+4, row);\n    data.mins = readData4(tex, offset+5, row);\n    data.maxs = readData4(tex, offset+6, row);\n    return data;\n}\n\n// Write data\nvec4 writeData(vec4 col, vec2 fragCoord, Data data, int row, int offset) {\n    col = writeData(col, fragCoord.xy, offset+0, row, data.volume);\n    col = writeData(col, fragCoord.xy, offset+1, row, data.bands);\n    col = writeData(col, fragCoord.xy, offset+2, row, data.lastBands);\n    col = writeData(col, fragCoord.xy, offset+3, row, data.averages);\n    col = writeData(col, fragCoord.xy, offset+4, row, data.correctedFac);\n    col = writeData(col, fragCoord.xy, offset+5, row, data.mins);\n    col = writeData(col, fragCoord.xy, offset+6, row, data.maxs);\n    return col;\n}", "buffer_b_code": "\n\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq, iChannel1));\n}\n\nfloat getVol(float samples) {\n    float avg = 0.5;\n    for (float i = 0.; i < samples; ++i) avg += getLevel(i/samples, iChannel1);\n    return avg / samples;\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --------------------------------------------------------------\n\n// Sample audio from a start freq to end freq (0.0 - 1.0) at *samples* positions\nfloat sampleAvg(float start, float end, float samples, bool mode)\n{\n    float delta = (end - start) / samples;\n    float res = 0.001;\n    if (!mode)\n    {\n    \n        for (float i = start; i < end; i+= delta)\n        {\n            res += getPitch(i, 0.7);\n        }\n        return res / samples;\n    }\n    else\n    {\n        for (float i = start; i < end; i+= delta)\n        {\n            res = max(getPitch(i, 0.7), res);\n        }\n        return res;\n    }\n}\n\n// Compute the minimums for each band with smoothing\nvoid computeMins(inout float mins[4], float bands[4], float avgs[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        mins[i] = min((mins[i]*fsmooth + avgs[i]) / (fsmooth + 1.), bands[i]);\n    }\n}\n\n// Compute the maximums for each dand with smoothing\nvoid computeMaxs(inout float maxs[4], float bands[4], float avgs[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        maxs[i] = max((maxs[i]*fsmooth + avgs[i]) / (fsmooth + 1.), bands[i]);\n    }\n}\n\n// Compute averages with smoothing\nvoid computeAverages(inout float avgs[4], float bands[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        //avgs[i] = smoothstep(avgs[i],bands[i], 0.1);\n        avgs[i] = (avgs[i]*fsmooth + bands[i]) / (fsmooth + 1.);\n    }\n}\n\n// Get thresholds by two methods and make a ratio between the two.\n// Method 1:\n// Use a position between the min and max as the threshold\n// min ........... max\n//             ^\n//             Threshold\n//\n// Method 2:\n// Use the average as the threshold.\nfloat[4] getThresholds(float mins[4], float maxs[4], float avgs[4], float minmaxRatio, float avgsRatio)\n{\n    float res[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        float thresh = smoothstep(mins[i], maxs[i], minmaxRatio);\n        res[i] = smoothstep(thresh, avgs[i], avgsRatio);\n    }\n    return res;\n}\n\n\n// If under threshold, return 0.0, if over, return 1.0\nvoid setCorrectedFacs(out float facs[4], float thresh[4], float bands[4])\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        facs[i] = 0.;\n        if (bands[i] > thresh[i]) facs[i] = 1.;\n    }\n}\n\n\n// Scale the band from 0.0 to 1.0 according to min and max\nvoid setScales(out float facs[4], float bands[4], float mins[4], float maxs[4])\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        facs[i] = (bands[i] - mins[i]) / (maxs[i] - mins[i]);\n    }\n}\n\n\n// If instant peek is found, apply it to the output\nvoid applyDerivative(inout float facs[4], float lastBands[4], float bands[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        if (lastBands[i] < bands[i])\n        {\n            float delta = bands[i] - lastBands[i];\n            facs[i] += delta * fsmooth;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Read data\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    Data data = readData(iChannel1, invRes, 0, BUFF_SIZE+1);\n    \n    // Run only once per frame\n    if (fragCoord.y > .5 && fragCoord.x > 0.5)\n    {\n        fragColor = writeData(fragColor, fragCoord, data, 0,BUFF_SIZE+1);\n        return; // Returns if this is not the first pixel\n    }\n    \n    // Frequency separators (0.0-1.0)\n    float s1 = 0.1;\n    float s2 = 0.5;\n    float s3 = 0.8;\n\n    \n    // Get global volume\n    data.volume = getVol(30.);\n    data.lastBands = data.bands;\n    \n    // Get bands from audio\n    float bands[4] = toArr(data.bands);\n    bands[0] = sampleAvg(0.,s1, 5.,true)/(data.volume*.5);\n    bands[1] = sampleAvg(s1,s2, 10.,true)/(data.volume*0.3);\n    bands[2] = sampleAvg(s2,s3, 15.,true)/(data.volume*.2);\n    bands[3] = sampleAvg(s3,1., 20.,true)/(data.volume*.1);\n    \n    // Get values from last frame\n    float[4] mins = toArr(data.mins);\n    float[4] maxs = toArr(data.maxs);\n    float[4] avgs = toArr(data.averages);\n    float[4] lastBands = toArr(data.lastBands);\n    \n    \n    // Compute the new values\n    computeAverages(avgs, bands, 20.);\n    computeMins(mins, bands, avgs, 20.);\n    computeMaxs(maxs, bands, avgs, 20.);\n    \n    // Get thresholds for bands\n    float thresh[4] = getThresholds(mins, maxs, avgs, 0.1, 0.4);\n    \n    // Get factors calculated from thresholds\n    float facs[4];\n    setCorrectedFacs(facs, thresh, bands);\n    applyDerivative(facs, lastBands, bands, 5.);\n    \n    // Get factors scaled from 0.0 to 1.0 from min and max\n    float facs2[4];\n    setScales(facs2, bands, mins, maxs);\n    \n\n    // Update data\n    data.bands = toVec(bands);\n    data.mins = toVec(mins);\n    data.maxs = toVec(maxs);\n    data.averages = toVec(avgs);\n    \n    // If global volume is close to zero, prevent x / ~0 = almost infinity;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (data.volume < 0.8) facs[i] = smoothstep(facs[i], 0., data.volume/.8);\n    }\n    \n    // Set new corrected data band\n    data.correctedFac = toVec(facs) * toVec(facs2);\n    \n    // Write data\n    fragColor = writeData(fragColor, fragCoord, data, 0,BUFF_SIZE+1);\n\n\n    vec2 uv = fragCoord / iResolution.xy;\n    int index = int(floor(fragCoord.x));\n    //fragColor = writeBuffer(fragColor, fragCoord, index, iResolution, 0, getVol(512., iChannel0));\n    if (iFrame % 1 == 0)\n    {\n        // First sample sends the latest input\n        if (index == BUFF_SIZE-1)\n        {\n            fragColor = writeData(fragColor, fragCoord.xy, index, 0, data.correctedFac);\n            fragColor = writeData(fragColor, fragCoord.xy, index, 0, vec4(data.correctedFac.rgb,getVol(512.)));\n        }\n        // Ignore anything after last\n        else if (index < BUFF_SIZE)\n        {\n            vec4 last = readData4(iChannel0, index + 1, 0);\n            fragColor = writeData(fragColor, fragCoord.xy, index, 0, last);\n            float vol = readData1(iChannel0, index, 1);\n            fragColor = writeData(fragColor, fragCoord.xy, index, 1, vol);\n        }\n    }\n    else\n    {\n        vec4 l = readData4(iChannel0, index, 0);\n        fragColor = writeData(fragColor, fragCoord.xy, index, 0, l);\n        float v = readData1(iChannel0, index, 1);\n        fragColor = writeData(fragColor, fragCoord.xy, index, 1, v);\n    }\n    //fragColor = writeBuffer(fragColor, fragCoord.xy, index, iResolution, 0, 1.);\n    //fragColor = writeBuffer(fragColor, fragCoord.xy, index, iResolution, 3, 1.);\n}", "buffer_b_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 33, 33, 81], [83, 83, 151, 151, 267], [272, 272, 329, 329, 1680]], "test": "untested"}
{"id": "clS3DG", "name": "Strange Perspective Lego", "author": "fishy", "description": "Lego! Testing funny optics where things further away are larger than things closer", "tags": ["tv", "crt", "raymarcher", "aa"], "likes": 11, "viewed": 275, "published": 3, "date": "1673810783", "time_retrieved": "2024-07-30T18:15:43.287520", "image_code": "#define AA 8.0\n#define FOCAL_LEN 1.\n\n#define AO_STR 1.\n#define AO_DIST 0.03\n#define AO_POW 2.\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#define saturate(x) clamp(0.0, 1.0, x)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    float scale = 0.02;\n    p /= scale;\n    //p = rotZ(p, iTime);\n    float d = 1e20;\n    join(d, sdBox(p, vec3(15.8, 9.6, 31.8)));\n    sub(d, sdBox(p-vec3(0, -2.1, 0), (vec3(15.8, 9.6, 31.8)-2.)));\n    join(d, sdCylinder(opRepLim3(p-vec3(-8, 9.6+1.8, -8), 16., vec3(1, 0, 2)), vec2(4.8, 1.8)));\n    outMat = marchMat(vec3(1., 0, 0), 0);\n    d *= scale;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.00001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n#define ORTHO (smoothstep(-1., 1., sin(iTime*0.5))*1.5)\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982+iTime*1.*(1.-step(0.01, m.z))) - mouse.yx;\n    //vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.), cr.x), cr.y);\n    //vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    vec3 ro = rotY(rotX(vec3(uv*ORTHO, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv*(1.-ORTHO), FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    float lighting = dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))+0.1*max(0., n.z);\n    float ao = 1.-pow(0.9-saturate(sceneDist(res.pos+AO_DIST*n)/AO_DIST), AO_POW);\n    \n    vec3 envMap = texture(iChannel0, reflect(rd, n), texture(iChannel2, res.pos*0.5).r*5.0).rgb;\n    envMap *= envMap;\n    \n    res.mat.color = res.mat.color + envMap*1.0;\n\n    return displayVar(mix(vec3(0.9), res.mat.color*lighting*mix(1., ao, AO_STR), vec3(res.hit)));\n    //return displayVar(ao);\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    res += getColorAtPix(fc, m);\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            res += getColorAtPix(fc + (hash22((x+iTime+fc)*25.)-0.5), m);\n        }\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = sqrt(col) + displayVar(printFR((fragCoord-iResolution.xy*0.5)/iResolution.y*0.55, iFrameRate));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clS3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 117, 117, 255], [257, 257, 278, 278, 414], [456, 456, 500, 500, 536], [538, 538, 577, 577, 617], [619, 619, 668, 668, 765], [767, 767, 788, 788, 837], [840, 840, 868, 868, 903], [905, 905, 933, 933, 968], [970, 970, 998, 998, 1033], [1035, 1035, 1181, 1181, 1265], [1402, 1402, 1436, 1436, 1454], [1455, 1455, 1495, 1495, 1512], [1514, 1514, 1569, 1569, 1650], [1652, 1652, 1708, 1708, 1806], [1808, 1808, 1868, 1868, 1909], [1911, 1911, 1971, 1971, 2015], [2017, 2017, 2050, 2050, 2076], [2078, 2078, 2118, 2118, 2205], [2207, 2207, 2247, 2247, 2325], [2327, 2327, 2365, 2365, 2395], [2397, 2397, 2431, 2431, 2478], [2480, 2480, 2523, 2523, 2574], [2576, 2576, 2641, 2641, 2753], [2755, 2755, 2801, 2801, 3171], [3173, 3173, 3198, 3198, 3244], [3246, 3246, 3320, 3320, 3701], [3703, 3703, 3742, 3742, 4005], [4063, 4063, 4100, 4100, 5188], [5190, 5190, 5222, 5222, 5441], [5443, 5443, 5479, 5479, 5750], [5752, 5752, 5809, 5809, 5971]], "test": "untested"}
{"id": "DlB3WG", "name": "Mind flowers", "author": "mrange", "description": "CC0: Mind flowers\nSaw some twitter art that inspired me to do weird colorful stuff\nTurn on, tune in, drop out!\nAnd full screen!\n\n", "tags": ["colorful"], "likes": 95, "viewed": 1853, "published": 3, "date": "1673809487", "time_retrieved": "2024-07-30T18:15:44.095359", "image_code": "// CC0: Mind flowers\n//  Saw some twitter art that inspired me to do weird colorful stuff\n//  Scry's twitter post: https://twitter.com/Scrygl/status/1614578715123683333\n//  Colorful circles from Xor's: https://www.shadertoy.com/view/msjXRK\n//  Turn on, tune in, drop out!\n//  And full screen!\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPM         (157.0/4.0)\n#define PCOS(a)     0.5*(cos(a)+1.0)\n\nconst float planeDist = 1.0-0.80;\nconst int   furthest  = 16;\nconst int   fadeFrom  = max(furthest-4, 0);\nconst float fadeDist  = planeDist*float(furthest - fadeFrom);\n\nconst float overSample  = 4.0;\nconst float ringDistance= 0.075*overSample/4.0;\nconst float noOfRings   = 20.0*4.0/overSample;\nconst float glowFactor  = 0.05;\n\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.15*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan_approx(p.y, p.x));\n}\n\nvec3 glow(vec2 pp, float h) {\n  float hh = fract(h*8677.0);\n  float b = TAU*h+0.5*TIME*(hh > 0.5 ? 1.0 : -1.0);\n  float a = pp.y+b;\n  float d = max(abs(pp.x)-0.001, 0.00125);\n  return \n    (   smoothstep(0.667*ringDistance, 0.2*ringDistance, d)\n      * smoothstep(0.1, 1.0, cos(a))\n      * glowFactor\n      * ringDistance\n      / d\n    )\n    * (cos(a+b+vec3(0,1,2))+vec3(1.0))\n    ;\n}\n\nvec3 glowRings(vec2 p, float hh) {\n  vec2 pp = toPolar(p);\n\n//  pp.y += TAU*hh;\n  vec3 col = vec3(0.0);\n  float h = 1.0;\n  const float nr = 1.0/overSample;\n\n  for (float i = 0.0; i < overSample; ++i) {\n    vec2 ipp = pp;\n    ipp.x -= ringDistance*(nr*i);\n    float rn = mod1(ipp.x, ringDistance); \n    h = hash(rn+123.0*i);\n    col += glow(ipp, h)*step(rn, noOfRings);\n  }\n  \n  col += (0.01*vec3(1.0, 0.25, 0.0))/length(p);\n\n  return col;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n+123.4);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  float l = length(p);\n  float fade = smoothstep(0.1, 0.15, l);\n  if (fade < 0.1) return vec4(0.0);\n  vec4 col = vec4(0.0);\n  \n  col.xyz = glowRings(p*mix(0.5, 4.0, h), h);\n  float i = max(max(col.x, col.y), col.z);\n\n  col.w = (tanh_approx(0.5+max((i), 0.0))*fade);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float rdd_per   = 10.0;\n  float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));\n//  float rdd = 2.0;\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  // Random color tweaks\n  col -= 0.075*vec3(2.0, 3.0, 1.0);\n  col *= sqrt(2.0);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 31975, "src": "https://soundcloud.com/ultimatespinach-music/mind-flowers-2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlB3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[898, 958, 998, 998, 1157], [1159, 1219, 1259, 1259, 1301], [1303, 1363, 1391, 1457, 1533], [1535, 1595, 1617, 1617, 1665], [1667, 1667, 1689, 1689, 1822], [1824, 1824, 1847, 1847, 1929], [1931, 1931, 1955, 1955, 2039], [2041, 2041, 2074, 2074, 2096], [2098, 2184, 2223, 2223, 2348], [2350, 2436, 2473, 2473, 2580], [2583, 2671, 2693, 2693, 2744], [2746, 2746, 2775, 2775, 3130], [3132, 3132, 3166, 3166, 3572], [3574, 3574, 3642, 3642, 4007], [4009, 4009, 4065, 4065, 5535], [5537, 5537, 5566, 5566, 6000], [6002, 6002, 6059, 6059, 6219]], "test": "untested"}
{"id": "dl2Gzd", "name": "Fork Truchet do cast3 228", "author": "cast3", "description": "Still having fun with truchet, now in 3D thanks to IQ's formula for extrusion :D ", "tags": ["raymarching", "tunnel", "truchet", "pattern", "extrude"], "likes": 5, "viewed": 214, "published": 3, "date": "1673805653", "time_retrieved": "2024-07-30T18:15:44.845354", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define circle(p,s) (length(p)-s)\n#define PI acos(-1.)\n#define hash21(x) fract(sin(dot(x,vec2(164.5, 231.8)))*2164.5)\n#define dt(s,o) fract((iTime+o)*s)\n\n// iq's distance function\n// https://iquilezles.org/articles/distfunctions/\nfloat opExtrusion (vec3 p, float d, float h)\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat truchet (vec2 uv, float w)\n{\n    vec2 id = floor(uv);\n    \n    uv = fract(uv)-.5;\n    if(hash21(id)<.5) uv.x *= -1.;\n    float s = (uv.x>-uv.y)?1.:-1.;\n    uv -= .5*s;\n    \n    float contour = abs(circle(uv,.5))-w;\n    return contour;\n}\n\nfloat SDF (vec3 p)\n{\n    p.z += iTime;\n    float per = 1.5;\n    float id = floor(p.z/per);\n    p.z = mod(p.z,per)-per*.5;\n    vec2 pp = p.xy+id*.5;\n    float width = sin(length(p.xy)-dt(.3, -id*.2)*(2.*PI))*.1;\n    return opExtrusion(p, truchet(pp, width), .05 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.01,-2.), rd=normalize(vec3(uv,1.)), p=ro,\n    col=vec3(0.);\n    float shad; bool hit = false;\n    for(float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        d *= .45+0.01*dither;\n        p += d*rd;\n    }\n    if(hit)\n    {\n        col = vec3(1.-shad); \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2Gzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 600, 646, 646, 741], [743, 743, 777, 777, 985], [987, 987, 1007, 1007, 1252], [1255, 1255, 1312, 1312, 1876]], "test": "untested"}
{"id": "Dl2GR3", "name": "Path tracer v0.1", "author": "raymarchingenthusiast", "description": "Raymarched Montecarlo path-tracer adapted from my other raymarchers, iq's article \"Path-Tracing in One Hour\" and the examples inside of it.", "tags": ["raymarching", "clouds"], "likes": 0, "viewed": 177, "published": 3, "date": "1673796446", "time_retrieved": "2024-07-30T18:15:45.596346", "image_code": "#define MAX_STEPS 250\n#define MAX_DIST 500.\n#define SURF_DIST .01\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.0,vec3(0.,120.,-50.),vec3(1.,.95,.85),2.)\n#define _randsettings vec3(48973.,3942067.,539.)\n\nfloat seed = 0.;\nfloat rand1(void) {\n    seed += _randsettings.z;\n    return mod(_randsettings.y*(seed-_randsettings.z) + _randsettings.z,_randsettings.x)/_randsettings.x;\n}\nvec2 rand2(void) {return vec2(rand1(),rand1());}\nvoid initRand(float time,vec2 c) {\n    seed = time+sin(time-c.x)*c.x-iResolution.y*(cos(c.y-time)*.5+.5);\n    //seed = abs((seed/rand1())-(179.*rand1()));\n}\n\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam,float time) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = time/15.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,time/96.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,time/96.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,time/96.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,time/96.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\n\n/////World\nvec2 map(in vec3 p,float ctime){\n    float d0 = sdSphere(p,vec4(-2.,0.,20.,1.)); //-2.,0.,20.,1.\n    float d1 = sdBox(p,vec3(0.,-4.,20.),vec4(9.8,1.3,9.8,.2));\n    float d = min(d0,d1);\n    \n    float mat;\n    if(d==d0) mat = 0.;\n    if(d==d1) mat = 1.;\n    \n    return vec2(d,mat);\n}\n\nvec3 getNormal(vec3 p,float ctime) {\n    float d0 = map(p,ctime).x;\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,ctime).x,\n    map(p-e.yxy,ctime).x,\n    map(p-e.yyx,ctime).x);\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, in vec3 n, sampler2D s, float k, float rk) {\n    n = pow(n,vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 raymarch(in vec3 rd, in vec3 ro, out bool hit,float ctime) {  \n    float h = 0.;  \n    hit = false;\n    float m = -1.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        vec2 q = map(p,ctime);\n        float d = q.x;\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            m = q.y;\n            break;\n        }\n        if (h > MAX_DIST) break;\n        h += d;\n    }\n    \n    return vec2(h,m);\n}\n\nfloat shadow(vec3 p, vec3 rd, float len, float ctime) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,ctime).x;\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0,vec3 n, float ctime) {\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0),ctime);\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nvec3 randCone(void) { // uniformVector from iq's \"Basic Montecarlo\" \n    float phi = rand1()*6.28318530718;\n    float x = rand1()*2.0-1.0;\n    float z = rand1();\n\treturn pow(z,1.0/3.0)*vec3(sqrt(1.0-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n\nvec3 cosDir(vec3 nor) {\n    vec2 uv = rand2();\n    \n    float a = 6.283185*uv.y; float b = 2.*uv.x-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\n\nvoid getBRDFRay(inout vec3 ro, inout vec3 rd, vec3 p, vec3 n, float fa) {\n    ro = p+n*OFFSET;\n    if(rand1() < .8) {\n        rd = cosDir(n);\n    } else {\n        vec3 rc = randCone();\n       // vec3 a = rc.x*uu+rc.y*vv+rc.z*ww;\n        float f = sat(pow(1.-dot(-rd,n),fa));\n        rd = normalize(reflect(rd,n)+rc*f);\n    }\n}\n\nvoid getCam(in float time, out vec3 ro,out vec3 uu, out vec3 vv, out vec3 ww) {\n    time += 1.;\n    ro = vec3(cos(time*4.5)*4.,sin(time*3.)*2.+2.,sin(time*5.5)*4.);\n    //ro = v(0.);\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n}\n\nvec3 rendererCalculateCol(vec3 ro, vec3 rd,float ctime,vec3 uu, vec3 vv, vec3 ww) {\n    vec3 tcol = v(0.);\n    vec3 fcol = v(1.);\n    for(float i = 0.; i < 2.; i++) {\n        bool hit = false;\n        vec2 q = raymarch(rd,ro,hit,ctime);\n        float d = q.x;\n        vec3 p = ro+rd*d;\n        float  mat;\n        mat = q.y;\n        \n        vec3 dcol;\n        vec3 scol;\n        if (hit == true) {\n            vec3 n = getNormal(p,ctime);\n            float dif = diffuse(p,LIGHT.pos-p,n,ctime);\n            //float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n            scol = v(.2);\n            vec3 diffuse = (dif*.5+.5)*LIGHT.str*LIGHT.col;\n            dcol = diffuse;\n            \n            fcol *= scol;\n            tcol += fcol * dcol;\n            getBRDFRay(ro,rd,p,n,8.);\n        } else {\n            vec3 sky = skybox(rd,ro,ctime);\n            scol = sky;\n            tcol += scol * fcol;\n            break;\n        }\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initRand(float(iFrame),fragCoord);\n    \n    float spp     = 6.;\n    float shutAp  = .8;\n    float blurAmt = .0045;\n    float fcsDist = .65;\n    \n    vec3 qcol = v(0.);\n    for(float i = 0.; i < spp; i++) {\n        vec2 of = -.5 + fract(rand2());\n        //of = vec2(0.);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        vec3 ro; vec3 uu; vec3 vv; vec3 ww;\n        float frameTime = iTime;\n        float ctime = (iTime*1.)-3. + shutAp*(1./24.)*rand1();\n        getCam(ctime,ro,uu,vv,ww); \n        vec3 er = normalize(vec3(p,1./tan(FOV*PI/360.)));\n        vec3 rd = uu*er.x+vv*er.y+ww*er.z;\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist-go);\n        ro += go.x*uu+go.y*vv;\n        rd += gd.x*uu+gd.y*vv;\n        \n        //vec3 rdOrig = rd;\n        vec3 col = sat(rendererCalculateCol(ro,normalize(rd),ctime,uu,vv,ww));\n        \n        qcol += col;\n        //qcol += ro;\n    }\n    qcol /= spp;\n    qcol = pow(qcol,v(1./2.2));\n    fragColor = vec4(qcol,1.);\n    //fragColor = vec4(rand2(),rand1(),1.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 60.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, bool sideways) {\n    vec2 mouse = PI*((vec2(iResolution.x*3.,.4*iResolution.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(.5*iResolution.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 245, 245, 382], [383, 383, 401, 401, 431], [432, 432, 466, 466, 588], [591, 598, 644, 691, 1485], [1542, 1542, 1579, 1579, 1623], [1625, 1625, 1677, 1677, 1784], [1786, 1786, 1823, 1823, 1918], [1921, 1932, 1964, 1964, 2216], [2218, 2218, 2254, 2254, 2445], [2447, 2447, 2511, 2511, 2705], [2708, 2708, 2773, 2773, 3149], [3151, 3151, 3206, 3206, 3428], [3430, 3430, 3482, 3482, 3626], [3628, 3628, 3649, 3696, 3861], [3863, 3863, 3886, 3886, 4055], [4057, 4057, 4130, 4130, 4383], [4385, 4385, 4464, 4464, 4644], [4646, 4646, 4729, 4729, 5611], [5613, 5613, 5670, 5670, 6755]], "test": "untested"}
{"id": "dtS3zG", "name": "Zozuar Flower", "author": "mla", "description": "A semi-degolfed version of the impressively short [url]https://twitter.com/zozuar/status/1612919479582728232[/url] by Zozuar, mainly just to see what's going on.\n\nI've added mouse rotation and dinked with the colours a little. Further eludication welcome.", "tags": ["zozuar"], "likes": 60, "viewed": 2483, "published": 3, "date": "1673784098", "time_retrieved": "2024-07-30T18:15:46.407178", "image_code": "// Zozuar Flower, mla, 2023. Original by @zozuar/@yonatan.\n// Degolfed version of https://twitter.com/zozuar/status/1612919479582728232\n\n/*\nfor(float i,g,e,R,S;i++<1e2;o.rgb+=hsv(.4-.02/R,\n(e=max(e*R*1e4,.7)),.03/exp(e))){S=1.;vec3 p=vec3\n((FC.xy/r-.5)*g,g-.3)-i/2e5;p.yz*=rotate2D(.3);\nfor(p=vec3(log(R=length(p))-t,e=asin(-p.z/R)-.1/\nR,atan(p.x,p.y)*3.);S<1e2;S+=S)e+=pow(abs(dot(sin\n(p.yxz*S),cos(p*S))),.2)/S;g+=e*R*.1;}\n*/\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float time = iTime;\n  fragColor = vec4(0);\n  vec2 uv = 0.5*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 ro = vec3(0,0,-0.6);\n  vec3 rd = vec3(uv,1);\n  float t = 0.0;\n  vec2 m = 2.0*(iMouse.xy/iResolution.xy - 0.5); \n  for (float i = 0.0; i < 1e2; i++) {\n    vec3 p = ro+t*rd-i/2e5;\n    if (iMouse.x > 0.0) {\n      p.z -= 1.0; // Rotation centre\n      p.yz *= rotate2D(PI*m.y);\n      p.xz *= rotate2D(PI*m.x);\n      p.z += 1.0;\n    }\n    p.yz *= rotate2D(0.2);\n\n    float r = length(p);\n    float e = asin(-p.z/r)-0.1/r;  // DE\n    float rot = 3.0; // rotational symmetry\n    vec3 q = vec3(log(r)-time,e,rot*atan(p.x,p.y)); // log spherical?\n    for (float scale = 1.0; scale<1e2; scale += scale) {\n      e += pow(abs(dot(sin(q.yxz*scale),cos(q*scale))),0.2)/scale; // FBM?\n    }\n    t += e*r*0.1; // Attenuate DE\n    if (t > 50.0) break;\n    float k = max(e*r*1e4,0.7);\n    k = pow(k,0.4);\n    fragColor.rgb += hsv(0.4-.02/r,k,0.02/exp(k));\n  }\n  fragColor *= 2.0/(1.0+fragColor);\n  fragColor = pow(fragColor,vec4(0.4545));\n}", "image_inputs": [], "common_code": "const float PI = 3.14159265;\n\nvec3 hsv(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  // x²(3-2x) = 3x²-2x³, f'(x) = 6x-6x² = 6x(1-x)\n  // f'(x) = 1-x², f = 0.5*(3.0*x-x³)\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nmat2 rotate2D(float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 429, 481, 481, 1517]], "test": "untested"}
{"id": "ml23Rt", "name": "INTEGRATRON ⚫️ 🌈 ⚪️", "author": "maxwellcoffee", "description": "Can you feel sadness and joy at the same time? It's time to integrate and defrag your light and dark spaces. \n\nA bittersweet feeling. An awareness and merging of all your states.\n\nI once thought I was enlightened. I felt both at once.", "tags": ["psychedelic"], "likes": 0, "viewed": 157, "published": 3, "date": "1673780154", "time_retrieved": "2024-07-30T18:15:47.155178", "image_code": "/* @maxwellcoffee - 2023 + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,f*f+4.5)\n#define s(a) mat2(tan(a*vec4(1,3,1,1)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          e = (0.4+iTime*.021111111)*(1.5+0.001*tan(iTime / 10.));\n    vec2  r = iResolution.xy; \n    \n    for (;o++<1e2;) {\n    /* substitute the 1e2 above to \n    1e1 for faster performance (such as full screen) or \n    1e3 for more detail (could make it choppy)\n*/\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*cos(6.*e);\n        p = fract(p)-.15;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.14,.31,.25,14.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(tan(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml23Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dl23Rt", "name": "PSYCHEDELIC ⚫️ 🌈 ⚪️ INTEGRATION", "author": "maxwellcoffee", "description": "Can we integrate our dreams with our waking life? Our logic with our intuition ? Our traumas with our light? Life and death itself?  \n\n\n\nTime to integrate.", "tags": ["psychedelic"], "likes": 2, "viewed": 195, "published": 3, "date": "1673779129", "time_retrieved": "2024-07-30T18:15:47.903178", "image_code": "/* @maxwellcoffee - 2023 + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,f*f+4.5)\n#define s(a) mat2(tan(a*vec4(1,3,1,1)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          e = 2.84+iTime*.021111111;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<1e2;) {\n    /* substitute the 1e2 above to \n    1e1 for faster performance (such as full screen) or \n    1e3 for more detail (could make it choppy)\n*/\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*cos(6.*e);\n        p = fract(p)-.15;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.14,.31,.25,14.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(tan(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl23Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dtjGDh", "name": "Shooting Stars Decoded", "author": "JB_0x0003", "description": "This took me way too long lmao", "tags": ["stars", "notgolf"], "likes": 18, "viewed": 415, "published": 3, "date": "1673773519", "time_retrieved": "2024-07-30T18:15:48.665141", "image_code": "/*\n    De-codegolfed version of a shader by XorDev\n    Intended to make it easier to see what's going on \n    and help steal some of his non-codegolf techniques.\n    \n    Was fun to figure out how this works!\n    Original: https://www.shadertoy.com/view/ctXGRn\n*/\n    \n    \n/////////////////// Orignal's Text /////////////////////\n//\n//  I got hit with inspiration for the concept of shooting stars.\n//  This is what I came up with.\n//  \n//  Tweet: twitter.com/XorDev/status/1604218610737680385\n//  Twigl: t.co/i7nkUWIpD8\n//  <300 chars playlist: shadertoy.com/playlist/fXlGDN\n//  \n///////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord)\n{\n    //Clear fragcolor\n    outColor *= 0.;\n    vec2 st = fragCoord.xy / iResolution.y;\n    //increase perceived horizontal resolution\n    //has the effect of horizontally squishing the screen\n    \n    //Line dimensions (box)\n    //distance from this is used to calculate value.\n    vec2 b = vec2(0,.2);\n    //Rotation matrix\n    mat2 rotation;\n    \n    float dist;\n    \n    //per loop \n    vec2 loopST;\n    //Original Code was meant to iterate 20 times, but actually iterates 21 times\n    //because i++ returns the previous value of i and not it's new value\n    for(float i=.9; i<21.0 ;++i){\n        //Rotate for each iteration. The rotation of 33 and 11 radians are there to \n        //appoximate sin and negative sin. 33 approximately equals 10.5 pi.\n        //11 approximately equals 3.5pi. These are equivalent to 0.6 and 1.5 pi, respectively.\n        //These offsets when applied to cosine make its output equivalent to sin and negative sin, respectively.\n        //it's a reflected rotation so that when it's applied twice, it will be reflected normaly.\n        rotation = mat2(cos(i + vec4(0,33,11,0)));\n        //Scale the underlying space.\n        //This step is the reason why there's a second variable for the in loop position.\n        loopST = st * (i) * .1 ;\n        // Translate downwards overtime\n        loopST.y += iTime * (0.2);\n        //Turn the points into rotated squares\n        loopST =(fract((loopST)*rotation)-.5);\n        //Rotate again so that the local down direction is equal to the global down direction\n        //removing this causes every line to be rotated semi-randomly\n        loopST = rotation * loopST;\n        //determines distance between closest point inside the line and the current point.\n        //used to create color falloff.\n        dist = distance(clamp(loopST,-b,b),loopST);\n        outColor += 0.001/dist\n                //Multiply the addition by his favorite color palette :)\n                //All values are always above 0 here, so it creates a lot of bloom\n                    * (cos(loopST.y/.1 +vec4(0,1,2,3))+1.0);\n        \n        \n        //uncomment this line to see the underlying squares and the colors the lines are being multiplied by.\n        //outColor = cos(loopST.y /.1 + vec4(0,1,2,3))+1.;\n        \n        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[639, 639, 690, 712, 2974]], "test": "untested"}
{"id": "mljGRy", "name": "Rotate Square :)", "author": "JB_0x0003", "description": "Just a test while messing with something else", "tags": ["test"], "likes": 1, "viewed": 166, "published": 3, "date": "1673773505", "time_retrieved": "2024-07-30T18:15:49.495920", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize with a single constant instead of two to ensure\n    // the squares are square in all resolutions\n    vec2 uv = fragCoord/iResolution.y;\n    // The recorded center is then offset on the x axis by \n    // the ratio of the constant w/ the true x-resolution\n    vec2 center = vec2(iResolution.x/iResolution.y * 0.5, 0.5);\n    \n    \n    mat2 rotation = mat2(cos(iTime) ,-sin(iTime),sin(iTime),cos(iTime));\n    //rotation = mat2(cos(iTime * 0.7853+ vec4(0,33,11,0)));\n    mat2 inverted = mat2(cos(-iTime) ,-sin(-iTime),sin(-iTime),cos(-iTime));\n    \n    uv= fract((uv - (center) ) * 3.0 * rotation);\n    uv = (uv - 0.5) * inverted ;\n    \n    // Time varying pixel color\n    vec3 hue = vec3(0.2,1.2,2.);\n    hue = cos(hue + uv.y * 5.0 - 1.0);\n    \n    //hue = vec3(uv.y + 0.2);\n\n    // Output to screen\n    fragColor = vec4(hue,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 171, 903]], "test": "untested"}
{"id": "Dlj3zd", "name": "old movie camera", "author": "yasuo", "description": "old movie camera", "tags": ["graphicdesign", "cineshader"], "likes": 24, "viewed": 1961, "published": 3, "date": "1673771166", "time_retrieved": "2024-07-30T18:15:50.354624", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderY( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderZ( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\n// tweaked as the center aligned horizontal capsule. \nfloat sdHorizontalCapsule( vec3 p, float w, float r )\n{\n      p.x-= clamp( p.x, -w*0.5, w*0.5 );\n      return length( p ) - r;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.yz), p.x );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat largeLensParts(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p,vec3(0.13,0.13,0.13));\n    float a = radians(-70.);\n    p.y = abs(p.y)-0.1;\n    d = max(-dot(p,vec3(cos(a),sin(a),0.0)),d);\n    p = prevP;\n    p.z = abs(p.z)-0.1;\n    d = max(-dot(p,vec3(cos(a),0.0,sin(a))),d);\n    p = prevP;\n    d = max(p.x-0.05,d);\n    return d;\n}\n\nfloat largeLens(vec3 p){\n    vec3 prevP = p;\n    float d = largeLensParts(p);\n    p*=1.1;\n    float d2 = largeLensParts(p-vec3(0.01,0.0,0.0));\n    d = max(-d2,d);\n    p = prevP;\n    d2 = sdCappedCylinderX(p-vec3(-0.1,0.0,0.0),0.035,0.01)-0.02;\n    d = min(d,d2);\n    return d;\n}\n\nfloat mainLens(vec3 p){\n    vec3 prevP = p;\n    float d = sdCappedCylinderX(p,0.08,0.02)-0.02;\n    float d2 =  sdCappedCylinderX(p-vec3(0.06,0.0,0.05),0.04,0.055);\n    d = min(d,d2);\n    d2 =  sdCappedCylinderX(p-vec3(0.02,0.04,-0.03),0.03,0.05);\n    float mask = sdCappedCylinderX(p-vec3(0.07,0.04,-0.03),0.025,0.01);\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    d2 =  sdCappedCylinderX(p-vec3(0.03,-0.04,-0.03),0.032,0.05);\n    mask = sdCappedCylinderX(p-vec3(0.08,-0.04,-0.03),0.027,0.01);\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    d2 = sdCappedCylinderX(p-vec3(0.105,0.0,0.05),0.06,0.01);\n    d = min(d,d2);\n    d2 = largeLens(p-vec3(0.25,0.0,0.05));\n    d = min(d,d2);\n    return d;\n}\n\nfloat viewFinder(vec3 p){\n     vec3 prevP = p;\n     float d = sdBox(p,vec3(0.035));\n     float d2 = sdCappedCylinderX(p-vec3(-0.03,0.0,0.0),0.025,0.1);\n     d = min(d,d2);\n     d2 = sdCappedCone(p-vec3(-0.15,0.0,0.0),0.03,0.05,0.03);\n     float mask = sdCappedCone(p-vec3(-0.17,0.0,0.0),0.03,0.04,0.02);\n     d2 = max(-mask,d2);\n     d = min(d,d2);\n     return d;\n}\n\nfloat reelParts(vec3 p){\n    p.xy*=Rot(radians(iTime*30.));\n    vec3 prevP = p;\n    p.z = abs(p.z)-0.04;\n    float d = sdCappedCylinderZ(p,0.17,0.01);\n    \n    p.xy = DF(p.xy,1.25);\n    p.xy -= vec2(0.075);\n    float mask = sdCappedCylinderZ(p,0.05,0.1);\n    d = max(-mask,d);\n    \n    p = prevP;\n    float d2 = sdCappedCylinderZ(p,0.1,0.015)-0.01;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat reel(vec3 p){\n    vec3 prevP = p;\n    \n    p.x = abs(p.x);\n    float d = reelParts((p-vec3(0.17,0.0,0.0))* vec3(sign(prevP.x),1,1));\n    \n    p = prevP;\n    p.z = abs(p.z)-0.07;\n    float d2 = sdBox(p-vec3(0.0,-0.15,0.0),vec3(0.15,0.06,0.02));\n    p = prevP;\n    float a = radians(30.);\n    p.x = abs(p.x)-0.1;\n    p.y+=0.1;\n    d2 = max(dot(p,vec3(cos(a),sin(a),0.)),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat body(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p,vec3(0.185,0.15,0.1))-0.015;\n    p.z = abs(p.z)-0.08;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    float d2 = length(p-vec3(0.197,0.13,0.))-0.013;\n    d = min(d,d2);\n    p = prevP;\n    d2 = reel(p-vec3(0.0,0.34,0.0));\n    d = min(d,d2);\n    \n    p.x+=0.05;\n    p.x = abs(p.x)-0.05;\n    d2 = sdCappedCylinderZ(p,0.03,0.13)-0.01;\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x-=0.11;\n    p.y = abs(p.y)-0.05;\n    d2 = sdCappedCylinderZ(p,0.015,0.13)-0.01;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat triPods(vec3 p){\n    vec3 prevP = p;\n    float d = sdCappedCylinderY(p,0.05,0.015)-0.01;\n    \n    p.x = abs(p.x)-0.02;\n    p.xy*=Rot(radians(-30.));\n    float d2 = sdCappedCylinderY(p-vec3(0.,-0.12,0.),0.005,0.1)-0.01;\n    d = min(d,d2);\n    p = prevP;\n    p.z = abs(p.z)-0.02;\n    p.zy*=Rot(radians(-30.));\n    d2 = sdCappedCylinderY(p-vec3(0.,-0.12,0.),0.005,0.1)-0.01;\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.y+=0.05;\n    float d = body(p);\n    float d2 = mainLens(p-vec3(0.24,0.05,0.0));\n    d = min(d,d2);\n    d2 = viewFinder(p-vec3(-0.23,0.0,0.0));\n    d = min(d,d2);\n    d2 = triPods(p-vec3(0.0,-0.17,0.0));\n    d = min(d,d2);\n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(1.0,1.0,0.95)*skyDiff*occ;\n    diffCol += col*vec3(0.95)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.));\n    return col;\n}\n\nfloat bgItem(vec2 p){\n    p*=Rot(radians(90.));\n    p.y = abs(p.y)-0.05;\n    float d = abs(Tri(p,vec2(0.05),radians(30.)))-0.0001;\n    return d;\n}\n\nfloat bg(vec2 p){\n    vec2 prevP = p;\n    p-=iTime*0.05;\n    p*=0.8;\n    p.x = mod(p.x,0.095)-0.0475;\n    p.y = mod(p.y,0.055)-0.0275;\n    float d = bgItem(p);\n    return d;\n}\n\nfloat filmItem(vec2 p, float dir){\n    vec2 prevP = p;\n    float d = B(p,vec2(2.,0.07));\n    \n    p.x+=iTime*0.1*dir;\n    p.x = mod(p.x,0.16)-0.08;\n    float d2 = B(p,vec2(0.075,0.035));\n    d = max(-d2,d);\n    p = prevP;\n    p.x+=iTime*0.1*dir;\n    p.y = abs(p.y)-0.0525;\n    p.x = mod(p.x,0.03)-0.015;\n    d2 =  B(p,vec2(0.012));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat icon0(vec2 p){\n    p*=Rot(radians(30.*iTime));\n    vec2 prevP = p;\n    float thickness = 0.002;\n    float d = abs(length(p)-0.06)-thickness;\n    p.x-=0.033;\n    p*=Rot(radians(90.));\n    float d2 = abs(Tri(p,vec2(0.05),radians(30.)))-thickness;\n    d = min(d,d2);\n    return d;\n}\n\nfloat icon1(vec2 p){\n    p*=Rot(radians(-22.*iTime));\n    vec2 prevP = p;\n    p.x*=3.;\n    float d = abs(length(p)-0.06)-0.003;\n    p = prevP;\n    p.y*=3.;\n    float d2 = abs(length(p)-0.06)-0.003;\n    d = min(d,d2);\n    p = prevP;\n    p*= Rot(radians(45.));\n    p.x*=3.;\n    d2 = abs(length(p)-0.06)-0.003;\n    d = min(d,d2);\n    p = prevP;\n    p*= Rot(radians(-45.));\n    p.x*=3.;\n    d2 = abs(length(p)-0.06)-0.003;\n    d = min(d,d2);\n    return d;\n}\n\nfloat icon2(vec2 p){\n    p*=Rot(radians(25.*iTime));\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p -= vec2(0.045);\n    float d = Tri(p,vec2(0.06),radians(45.));\n    return d;\n}\n\nfloat icon3(vec2 p){\n    p*=Rot(radians(-15.*iTime));\n    vec2 prevP = p;\n    p = DF(p.xy,2.);\n    p -= vec2(0.045);\n    float d = Tri(p,vec2(0.06),radians(30.));\n    p = prevP;\n    d = min(abs(length(p)-0.015)-0.002,d);\n    return d;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat items(vec2 p){\n    vec2 prevP = p;\n    p*=6.;\n    p-=iTime*0.2;\n    vec2 id = floor(p);\n    vec2 grd = fract(p)-0.5;\n    grd*=0.15;\n    float n = random(id);\n    float d = 10.;\n    if(n<0.1){\n        d = icon0(grd);\n    } else if(n>=0.1 && n<0.2){\n        d = icon1(grd);\n    } else if(n>=0.2 && n<0.3){\n        d = icon2(grd);\n    } else if(n>=0.3&& n<0.4){\n        d = icon3(grd);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = mix(col,vec3(0.2),S(bg(uv),0.0));\n        col = mix(col,vec3(0.4),S(items(uv),0.0));\n    }\n    \n    \n    uv.y = abs(uv.y);\n    \n    float dd = filmItem(uv-vec2(0.0,0.43),sign(prevUV.y));\n    col = mix(col,vec3(0.9),S(dd,0.0));\n    \n    /*\n    uv = prevUV;\n    dd = icon4(uv-vec2(0.6,0.0));\n    col = mix(col,vec3(0.9),S(dd,0.0));\n    */\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 584, 584, 603], [605, 665, 708, 708, 808], [810, 868, 899, 899, 990], [992, 1050, 1103, 1103, 1214], [1216, 1274, 1327, 1327, 1438], [1440, 1498, 1551, 1551, 1662], [1664, 1776, 1831, 1831, 1904], [1906, 1964, 2023, 2023, 2336], [2338, 2338, 2367, 2367, 2676], [2678, 2678, 2702, 2702, 2956], [2958, 2958, 2981, 2981, 3654], [3656, 3656, 3681, 3681, 4021], [4023, 4023, 4047, 4047, 4411], [4413, 4413, 4432, 4432, 4831], [4833, 4833, 4852, 4852, 5387], [5389, 5389, 5411, 5411, 5806], [5808, 5808, 5830, 5830, 6102], [6104, 6104, 6162, 6162, 6429], [6431, 6431, 6455, 6455, 6656], [6658, 6658, 6700, 6700, 6895], [6897, 6938, 6987, 6987, 7281], [7283, 7283, 7340, 7340, 7880], [7882, 7882, 7941, 7941, 8003], [8005, 8005, 8026, 8026, 8151], [8153, 8153, 8170, 8170, 8328], [8330, 8330, 8364, 8364, 8697], [8699, 8699, 8719, 8719, 8984], [8986, 8986, 9006, 9006, 9439], [9441, 9441, 9461, 9461, 9615], [9617, 9617, 9637, 9637, 9853], [9855, 9855, 9878, 9878, 9951], [9953, 9953, 9973, 9973, 10363], [10365, 10365, 10422, 10422, 11489]], "test": "untested"}
{"id": "mt23R3", "name": "Local Light Source Ball Pit", "author": "fenix", "description": "5000 particle-balls in a rotating cube, rendered via voronoi tracking with 200 local light sources + shadows.\n\n*mouse to control cube rotation* \n*click-drag-release to \"throw\" cube*\n*space to resume automatic rotation*\n*shift to disable occlusion*", "tags": ["3d", "simulation", "shadow", "particles", "dynamics", "lights", "soft", "physics", "deferred"], "likes": 64, "viewed": 941, "published": 3, "date": "1673749189", "time_retrieved": "2024-07-30T18:15:51.435733", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  5000 particles lit by 200 local light sources. This is very nearly the same particle\n//  sim as its predecessor, just with new lighting.\n//\n//    SSAO Rotating Ball Pit            https://shadertoy.com/view/cl23Ww\n//\n//  Deferred rendering can do more than just screen space ambient occlusion! It's good\n//  for rendering lots of lights as well. I've done that before in other shaders like\n//\n//    Arctic Fireflies                  https://shadertoy.com/view/cssSRs\n//    Sparks on Swiss Cheese Mountain   https://shadertoy.com/view/7tyyW1\n//    Spark Volcano 2                   https://shadertoy.com/view/7lKczD\n//\n//  The new thing in this shader is screen-space shadows. Press shift to disable to see\n//  the difference. I'm doing a DDA-type traversal of the screen between each light\n//  source and each rendered pixel, looking for depth that should occlude some or all of\n//  the light. This results in passable soft shadows that can be cast quite a distance.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D computes nearest lights to each screen pixel\n//  Image performs lighting and occlusion\n//\n//  Update 1/15/23: fixed normals on two walls, doubled light sources\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\nvec3 materialColor(float c)\n{\n    if (c <= 1.) return mix(vec3(1), vec3(.5), c); // color between 0 and 1 is the box\n    switch(int(c / float(LIGHT_RATIO)) % 2)\n    {\n        case 0: return vec3(.5);\n        case 1: return vec3(1);\n    }\n}\n\n// decode emissivity from G buffer material\nvec3 materialEmis(float c)\n{\n    if ((int(c) % LIGHT_RATIO) != 2) return vec3(0);\n    switch(int(c / float(LIGHT_RATIO)) % 3)\n    {\n        case 0: return vec3(1,.5,.1);\n        case 1: return vec3(1,.3,1);\n        case 2: return vec3(0,1,.5);\n    }\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec2 intersectXY(ivec2 xy, vec2 from, vec2 dir) { return (vec2(xy) - from) / dir; }\nfloat sum(vec2 x) { return x.x + x.y; }\n\nfloat occluded(fxParticle light, vec2 fragCoord, float t, mat4 w2c)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 lc = (w2c * vec4(light.pos,1.0)).xyz;\n    lc.xy = ((lc.xy / lc.z) * iResolution.y + iResolution.xy) * .5;\n    \n    // account for particle size \n    t += PARTICLE_SIZE;\n    \n    // get the depth at light source\n    fxGBufferPixel lp = fxUnpackGBuffer(texture(iChannel1, (lc.xy) / iResolution.xy));\n    \n    // compute the gradient of t\n    float tDelta = (lp.t - t) / length(fragCoord - lc.xy);\n    \n    // don't bother searching past some distance, light will be very dim anyway\n    if (distance(lc.xy, fragCoord) > 500.) return 1.;\n\n    // setup traversal\n    vec2 rayDir = lc.xy - fragCoord;\n    vec2 cur = fragCoord;\n\tivec2 mapPos = ivec2(floor(fragCoord));\n\tivec2 finalMapPos = ivec2(floor(lc.xy));\n\tvec2 deltaDist = abs(length(rayDir) / rayDir);\n    ivec2 rayStep = ivec2(sign(rayDir));\n    vec2 fixup = sign(rayDir) * 0.5 + 0.5;\n\tvec2 sideDist = (sign(rayDir) * (vec2(mapPos) - fragCoord) + fixup) * deltaDist; \n\t\n    float occ = 0.;\n\n    const int MAX_RAY_STEPS = 64;\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n\t\tif (mapPos == finalMapPos)\n        {\n            break;\n        }\n        \n        bvec2 mask = lessThanEqual(sideDist.xy, sideDist.yx);\n\n        vec2 ts = intersectXY(mapPos + ivec2(fixup), fragCoord, rayDir);\n        vec2 next = fragCoord + rayDir * sum(vec2(mask) * ts);\n        \n        fxGBufferPixel pix = fxUnpackGBuffer(texelFetch(iChannel1, mapPos, 0));\n        \n        // compute curent t\n        t += length(cur - next) * tDelta;\n\n        // add up occlusion\n        occ += t - pix.t;\n        \n        // go to the next pixel\n        cur = next;\n\t\tsideDist += vec2(mask) * deltaDist;\n\t\tmapPos += ivec2(vec2(mask)) * rayStep;\n\t}\n\n    return 1. - clamp(occ, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel1, fragCoord/iResolution.xy));\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    \n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (pix.t >= FAR_CLIP)\n    {\n        // background\n        fragColor = vec4(.2);\n    }\n    else\n    {\n        // ssao model inspired by SSAO (basic) by iq: https://www.shadertoy.com/view/Ms23Wm\n        // sample neighbor pixels\n        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n        mat4 w2c = inverse(c2w);\n\n        vec3 pixelPos = cameraPos + rayDir * pix.t;\n        //vec3 lightColor = vec3(0);\n        vec3 pixel = materialEmis(pix.m);\n        \n        // lighting\n        ivec4 old = fxGetClosestLights( ivec2(fragCoord) );\n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            fxParticle light = fxGetParticle(id);\n            \n            float occ = occluded(light, fragCoord, pix.t, w2c);\n            if (keyDown(KEY_SHIFT)) occ = 1.;\n            \n            //renderParticle(id, data, cameraPos, rayDir, pix);\n            vec3 lightDelta = light.pos - pixelPos;\n            vec3 lightColor = .5 * materialEmis(float(id + 2)) / pow(length2(lightDelta), .8);\n            \n            float nDotL = max(dot(pix.n, normalize(lightDelta)), .0);\n            float dif = occ * (nDotL * nDotL * .05 + .001) + .002;\n            pixel += (lightColor * dif + .01) * materialColor(pix.m);\n        }\n\n        fragColor.xyz = pixel;\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 5.; // multiply with sth for intensity\n    vig = sqrt(vig); // change pow for modifying the extend of the  vignette\n    fragColor *= vig;\n\n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .03;\nconst float FAR_CLIP = 1e6;\nconst int LIGHT_RATIO = 25;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n#define fxGetClosestLights(X) fxGetClosestImpl(iChannel2, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    ivec4 nbs[4];\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.vel = particleData5.xyz;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 5000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, -.5, 0);\n    cameraPos\t = vec3(0, 1, 1);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 boxRot;\n    vec2 boxVel;\n    vec2 lastMouse;\n    float resolution;\n    bool autoRotate;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.boxRot = vec2(0);\n    state.boxVel = vec2(0);\n    state.lastMouse = vec2(0);\n    state.resolution = -iResolution.x * iResolution.y;\n    state.autoRotate = true;\n}\n\n#define fxInitState(state) fxGetStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    \n    fxState state;\n    state.boxRot = data0.xy;\n    state.boxVel = data0.zw;\n    state.lastMouse = data1.xy;\n    state.resolution = data1.z;\n    state.autoRotate = data1.w != 0.;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(state.boxRot, state.boxVel);\n    else\n        return vec4(state.lastMouse, state.resolution, state.autoRotate ? 1. : 0.);\n}\n\n// PHYSICS BOUNDARY SCENE\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// compute a matrix from the boxRot euler angles\nmat4 boxMat(vec2 boxRot)\n{\n    const float ROTATE_SPEED = .2;\n    vec2 scA = vec2(sin(boxRot.x * ROTATE_SPEED), cos(boxRot.x * ROTATE_SPEED));\n    vec2 scB = vec2(sin(boxRot.y * ROTATE_SPEED), cos(boxRot.y * ROTATE_SPEED));\n    vec2 scC = vec2(sin(.001 * ROTATE_SPEED), cos(.001 * ROTATE_SPEED));\n    mat4 matA = mat4(scA.y, -scA.x, 0, 0, scA.x, scA.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    mat4 matB = mat4(scB.y, 0, scB.x, 0, 0, 1, 0, 0, -scB.x, 0, scB.y, 0, 0, 0, 0, 1);\n    mat4 matC = mat4(0, scC.y, -scC.x, 0, 1, 0, 0, 0, 0, scC.x, scC.y, 0, 0, 0, 0, 1);\n    \n    return matA * matB * matC;\n}\n\nvoid rotateBox(inout vec3 p, vec2 boxRot)\n{\n    p = (vec4(p, 1) * boxMat(boxRot)).xyz;\n}\n\nfloat scene(vec3 p, fxState state)\n{\n    rotateBox(p, state.boxRot);\n    return -sdBox(p - vec3(0, 0, 0), vec3(1, 1, 1));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 p, fxState state)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, state) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, state) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, state) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, state) );\n}\n\n// G BUFFER\n\n// note there are five dwords here...c is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    \n    pix.m = abs(fragColor.z);\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-.0005,0);\n\nvoid particleStep(inout fxParticle p, fxState state, vec2 fragCoord)\n{\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(fragCoord, iFrame) );\n\n        p.pos = h * 2. - 1.;\n        p.vel = vec3(0);\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .995; // damping\n    const float MAX_SPEED = .025; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n    p.vel += GRAVITY;\n\n    for (int iter = 0; iter < 3; ++iter)\n    {\n        // collide with neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                fxParticle nb = fxGetParticle(nid);\n\n                if (nb.pos.y < p.pos.y && // only react to particles below us (stability hack)\n                    distance(nb.pos, p.pos) < PARTICLE_SIZE * 2.)\n                {\n                    vec3 dir = normalize(p.pos - nb.pos);\n\n                    // position correction\n                    p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .05);\n\n                    // clip velocity (stability hack, should be relative velocity)\n                    p.vel -= dot(p.vel, dir) * dir;\n                }\n            }\n        }\n\n        // collide with boundary\n        float boundary = scene(p.pos, state);\n        if (boundary < PARTICLE_SIZE)\n        {\n            vec3 normal = sceneNormal(p.pos, state);\n\n            // position correction\n            p.pos += normal * (PARTICLE_SIZE - boundary);\n\n            // clip velocity\n            vec3 boxVel = .01*cross(p.pos, vec3(-state.boxVel.y, 0, state.boxVel.x));\n            p.vel -= min(0., dot(p.vel - boxVel, normal)) * normal;\n        }\n    }\n\n    p.pos += p.vel; // integrate\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // randomly consider one of the neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % 4;\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n                for (int y = 0; y < 4; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, state, fragCoord);\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    \n    // throw away particles too far away\n    vec2 delta = screenPos.xy-fragCoord;\n    if (length2(delta) > (PARTICLE_SIZE * PARTICLE_SIZE * 2.0)) return 1e6;\n    \n    // favor particles in the front\n    return length2(delta) + screenPos.z * .01;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            state.autoRotate = false;\n            \n            if (iMouse.w < 0.)\n            {\n                vec2 delta = 3. * (iMouse.xy - state.lastMouse) / iResolution.y;;\n                state.boxVel = delta;\n            }\n            \n            state.lastMouse = iMouse.xy;\n        }\n        else if (state.autoRotate)\n        {\n            state.boxVel = mix(state.boxVel, vec2(-.01), .01);\n        }\n        \n        state.boxVel = clamp(state.boxVel, -.1, .1);\n        \n        if (keyDown(KEY_SPACE)) state.autoRotate = true;\n        \n        state.boxRot += state.boxVel;\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float dis2 = distance2Particle(nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 48u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n        }\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// draw one ball\nvoid renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_SIZE));\n    if (t > 0. && t < pix.t)\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.pos);\n\n        pix.n = normal;\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.t = t;\n    }\n}\n\n// Derived from iq, but DO NOT COPY FROM HERE (modified to return interior results):\n// https://iquilezles.org/articles/boxfunctions/\n// Calcs intersection and exit distances, normal, face and UVs\n// row is the ray origin in world space\n// rdw is the ray direction in world space\n// txx is the world-to-box transformation\n// txi is the box-to-world transformation\n// ro and rd are in world space\n// rad is the half-length of the box\n//\n// oT contains the entry and exit points\n// oN is the normal in world space\n// oU contains the UVs at the intersection point\nbool boxIntersect( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad,\n                   out vec2 oT, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n    if( t2.x<t2.y && t2.x<t2.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t2.x; }\n    else if( t2.y<t2.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t2.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t2.z; }\n\n    oT = vec2(tN,tF);\n    \n    return true;\n}\n\nfloat boxDist(vec2 a, vec2 b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }\n\n// generates a checkerboard pattern\n// aa allows reduction of aliasing at steep angles\nfloat checker(vec2 p, float aa)\n{\n    vec2 m = mod(p, vec2(2.));\n    float sd = min(boxDist(vec2(.5, 1.5), m), boxDist(vec2(1.5, .5), m));\n    return smoothstep(-aa, aa, .5 - sd) * .5 + .5;\n}\n\n// draws an inside-out antialiased checkered box\nvoid drawBox(fxState state, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    vec2 t, uv;\n    vec3 n;\n    mat4 m = boxMat(state.boxRot);\n    if (boxIntersect(ro, rd, inverse(m), m, vec3(1), t, n, uv))\n    {\n        float x = 1.2 + dot(n, rd);\n        float aa = x * 20./iResolution.y;\n        float ch = checker(uv * 4.25 - .5, aa);\n        \n        pix.n = n;\n        pix.t = t.y;\n        pix.m = ch;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n    \n    // render box\n    drawBox(state, cameraPos, rayDir, pix);\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, cameraPos, rayDir, pix);\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Voronoi light tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id < 0) return FAR_CLIP;\n    if ((id % LIGHT_RATIO) != 0) return 1e6; // Don't allow particles that are not lights\n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    \n    // throw away particles too far away\n    vec2 delta = screenPos.xy-fragCoord;\n    //if (length2(delta) > (PARTICLE_SIZE * PARTICLE_SIZE * 10.0)) return 1e6;\n    \n    // favor particles in the front\n    return length2(delta) + screenPos.z * .1;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            state.autoRotate = false;\n            \n            if (iMouse.w < 0.)\n            {\n                vec2 delta = 3. * (iMouse.xy - state.lastMouse) / iResolution.y;;\n                state.boxVel = delta;\n            }\n            \n            state.lastMouse = iMouse.xy;\n        }\n        else if (state.autoRotate)\n        {\n            state.boxVel = mix(state.boxVel, vec2(-.01), .01);\n        }\n        \n        state.boxVel = clamp(state.boxVel, -.1, .1);\n        \n        if (keyDown(KEY_SPACE)) state.autoRotate = true;\n        \n        state.boxRot += state.boxVel;\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosestLights(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0 && (nid + 1) % LIGHT_RATIO == 0)\n            {\n                float dis2 = distance2Particle(nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 8u;\n        uint searchCount = 48u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosestLights( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 2 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = (int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % (MAX_PARTICLES / LIGHT_RATIO)) * LIGHT_RATIO; // search only lights\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n        }\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt23R3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1608, 1647, 1676, 1676, 1886], [2185, 2269, 2292, 2292, 2452], [2454, 2454, 2503, 2503, 2537], [2538, 2538, 2557, 2557, 2577], [2579, 2579, 2648, 2648, 4418], [4420, 4420, 4477, 4477, 6626]], "test": "untested"}
{"id": "mtSGzt", "name": "Moebius Spiral iso-bands golfed", "author": "FabriceNeyret2", "description": "Golfed variant of 1982 chars [url]https://shadertoy.com/view/llsfRj[/url]\n( See original for comments )", "tags": ["spiral", "mobius", "illusion", "complex", "isolines", "screenspace", "tuto", "short", "weave", "balanced"], "likes": 39, "viewed": 479, "published": 3, "date": "1673722369", "time_retrieved": "2024-07-30T18:15:52.269504", "image_code": "// golfed variant of 1982/ 1759 chars   https://shadertoy.com/view/llsfRj\n// ( See original for comments )\n      \n#define f(d) fract( d(U) + .5 ) - .5//\n#define t iTime/4.//\n#define d(l) smoothstep( 2./R.y, 0., length( p/2. - D( vec2( floor( i + U.x*l ) / l , U.y ) )) -.005 )\n\nmat2 M = mat2(5,1, .628,-.5);\n\nvec2 D(vec2 q)\n{\n    q = inverse(M) * ( q - vec2(-t, t) ) ;\n    float a = 3.125,\n          l = dot( q = exp(q.y) * cos( (q.x - t/8.) *6.283 + vec2(0,11)) -.5 , q ),\n          v = 1.7225 / ( 1.+ l -q-q ).x,\n          b = ( v - v*l + .885 ) / .8,\n          A = 1. +  a*a,\n          B = ( b*a -.765625 ) / A,  // could del max, but some rare negatives\n          x = sign(q.y)* sqrt( max(0., B*B - ( b*b -1.05*b + 1.04125 - v*l ) / A ) ) - B; \n    return vec2( x , -b - a*x );\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n         p = ( U+U - R ) / R.y,\n         z = p + vec2(1.75,1.05), q = p - vec2(.75, -.25);\n    q = mat2(z,z.y,-z) * q / dot(q,q) + .5;      \n\tU = M * vec2( atan(q.y,q.x)/6.283 + t/8., \n                  log( length(q) )  ) \n        + vec2(-t, t);   \n    float l = log2( 20.* length( inverse(mat2(f(dFdx),f(dFdy)))[1] )/ max(360.,R.y) ),\n          a = fract(l), i = 0.;\n    l = exp2(l-a);\n    for (O *= 0. ; i<2.; i++)\n        O += mix( d(l), d((l+l)), a );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 325, 325, 783], [785, 785, 821, 821, 1306]], "test": "untested"}
{"id": "dlB3zt", "name": "tex3d fixed", "author": "starea", "description": "trilinear filtering 2d atlas", "tags": ["trilinearfiltering"], "likes": 3, "viewed": 175, "published": 3, "date": "1673721870", "time_retrieved": "2024-07-30T18:15:53.039445", "image_code": "// Fork of \"tex3d\" by tikabom. https://shadertoy.com/view/sd3fDN\n// Quick fix of its plain cyan.\n// 2023-01-14 18:44:04\n\nvec2 get_2D_atlas_coordinate(in vec3 uvw) {\n    float z = uvw.z * 64.0;\n    float c = floor(mod(z, 8.0));\n    float r = floor(uvw.z * 8.0);\n    float normalized_x = (c + uvw.x) / 8.0;\n    float normalized_y = (r + uvw.y) / 8.0;\n    return vec2(normalized_x, normalized_y);\n}\n\nvec4 tex3D(in sampler2D atlas, in vec3 uvw) {\n    vec2 sample1 = get_2D_atlas_coordinate(uvw); \n    vec2 sample2 = get_2D_atlas_coordinate(vec3(uvw.xy, min(1.0, uvw.z + (1.0 / 64.0))));\n    \n    vec4 color1 = texture(atlas, sample1);\n    vec4 color2 = texture(atlas, sample2);\n    \n    float z = uvw.z * 64.0;\n    float fraction = fract(z);\n    vec4 colorz = color1 * (1.0 - fraction)  + color2 * (fraction);\n    \n    return colorz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uvw = vec3(fragCoord / iResolution.xy, fract(iTime * 0.01));\n    \n    fragColor = tex3D(iChannel0, uvw);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlB3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 164, 164, 395], [397, 397, 442, 442, 831], [834, 834, 891, 891, 1007]], "test": "untested"}
{"id": "dlBGRc", "name": "Compact SVO representation", "author": "toomuchvoltage", "description": "Compact SVO representation using bitstreams. If your ANGLE backend is not OpenGL uncomment #define HIRES.", "tags": ["voxel", "tracing", "octree", "svo", "sparse", "bitstream", "octrees"], "likes": 34, "viewed": 1286, "published": 3, "date": "1673707396", "time_retrieved": "2024-07-30T18:15:54.180395", "image_code": "/***********************************************************\n\n   Compact Sparse-Voxel Octree representation in ShaderToy/GLSL using bitstreams\n   The layout is like so: 0s represents an empty top-level brick.\n   If a top-level brick is occupied, it will be a 1 followed by 8 bits representing occupancy by mid-level bricks.\n   Every mid-level brick that is occupied will be followed by 8 bits describing voxel occupancies.\n   This way we never spend any space for top-level or mid-level bricks that are empty.\n   I tried laying everything out using a space-filling curve, but top-level brick matching ended up being slower during trace.\n   Created using Shadertoy-utils by yours truly :) : https://github.com/toomuchvoltage/shadertoy-utils\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n//#define HIRES\n\nbool rayBoxIntersectTime (vec3 l1,vec3 invm,vec3 bmin,vec3 bmax, out float tMin, out float tMax)\n{\n\tvec3 bmin_l1 = (bmin - l1)*invm;\n\tvec3 bmax_l1 = (bmax - l1)*invm;\n\tvec3 minVec = min (bmin_l1, bmax_l1);\n\tvec3 maxVec = max (bmin_l1, bmax_l1);\n\n\tfloat tmin = max(max(minVec.x, minVec.y), minVec.z);\n\tfloat tmax = min(min(maxVec.x, maxVec.y), maxVec.z);\n\n\tbool retVal = ((tmax >= tmin) && (tmin < 1.0) && (tmax > 0.0));\n\ttMin = tmin;\n\ttMax = tmax;\n\treturn retVal;\n}\n\nuint countSetBits(uint n)\n{\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nuint countSetBitsBefore(uint n, uint comp)\n{\n    uint beforeMask = comp ^ (comp - 1u); // See: https://realtimecollisiondetection.net/blog/?p=78\n    n &= (~beforeMask);\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\n#ifdef HIRES\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[480] = uint[](128u,2210513095u,3479298144u,1206382640u,2955944416u,2948644703u,3759157328u,4287565583u,3759675512u,2139587772u,802340674u,3188982804u,141045714u,2138838076u,868254667u,3286638110u,504914401u,2400088239u,4111435140u,25231882u,717225475u,1058011896u,3229678206u,2130212960u,2131742716u,1009857343u,2275802654u,3097205408u,547535824u,2192417534u,3288236371u,3896412222u,505289727u,4279177016u,4043288476u,2021159043u,2386045908u,708321408u,3052425285u,4261731647u,2600436334u,1905893279u,4231802947u,3476757529u,3877378112u,1105215936u,34434u,4289098691u,3288284978u,4058111969u,1368453360u,4030781552u,2018533408u,540094515u,863606808u,301587464u,2349928471u,3958414079u,1086318151u,2701128451u,61471098u,2156002367u,62979548u,3180696977u,2123695444u,358083563u,1106362448u,272611232u,1587628053u,2095138053u,3746421117u,802705685u,17108991u,944109840u,2236852288u,1090600768u,3208819995u,1789041304u,2577271807u,4244787370u,4078985120u,265989392u,626174633u,277056386u,2952430954u,532654112u,573780048u,4286382072u,404256888u,2308730983u,4027342703u,3436158974u,2146558435u,2551187007u,867382067u,865704345u,2576993484u,3704409341u,3258775938u,3176781832u,2297956543u,3808397308u,71073779u,4062383231u,4001299939u,3858923261u,4294504910u,2281914348u,3370546118u,1063543298u,537132546u,4261943487u,4271477196u,4224646856u,3292938240u,272650234u,4016187103u,4133678343u,4080218316u,3476239359u,3120287513u,2441110503u,4294757583u,4090285104u,553641598u,4193511022u,2294243840u,2818752010u,1848374463u,3254062863u,2127319104u,2682678906u,2545967183u,3435708155u,4231000385u,432095607u,285339157u,284091511u,1148523596u,1145953754u,626850341u,3632174440u,359142741u,1118551722u,2863275440u,1521198420u,1252047863u,717509418u,3288667447u,1947428677u,3120952896u,1094996991u,1600391359u,1428034056u,16427093u,542637738u,1119939523u,3764511729u,4050662903u,4002366143u,130351256u,410541068u,1010581182u,515774602u,737923627u,3004883152u,1509530008u,2144597893u,4231843327u,3263414787u,1106579704u,410548344u,2084322364u,809377310u,403708943u,235416312u,1731735602u,3482858001u,3677724u,166411u,4256956382u,4232957900u,3451073271u,1986419065u,4052775731u,858829601u,2441190596u,1288490207u,4268161167u,1449650319u,1009265720u,1162105604u,4116665695u,4114841579u,3926179344u,2856591392u,4126637728u,938539692u,67170282u,357892821u,39127072u,1874417153u,2105410472u,717184855u,1470217045u,1428347733u,571195218u,3158670264u,1079326545u,1072002912u,1604612128u,680036493u,3712343713u,1440621329u,286263846u,1713861618u,4144182067u,4169136513u,2174327168u,4026721826u,601629663u,4084412932u,4208664577u,85018111u,2945462233u,4110471175u,4286675613u,3793592382u,2151743801u,2155977084u,4169173120u,717083454u,3154037963u,3003960254u,1637456281u,2670775436u,3436157319u,3060164556u,4088607539u,3996247560u,434274295u,717079091u,1787128459u,4164421880u,257162247u,3278619619u,3275833600u,1052572127u,3781082648u,2693315316u,341137392u,804388289u,3519082624u,262318170u,99517628u,787753794u,2906981461u,83750360u,653103197u,2554865794u,2750130721u,3876522510u,4117868073u,2155911579u,2880295434u,2916137919u,2831494024u,3577881349u,871633902u,1738041274u,1731343139u,848857241u,2564676733u,3808693497u,2974916321u,7540787u,858995097u,2417596816u,2155881986u,645005824u,359751649u,823902198u,1639497159u,4292310531u,2818932589u,830078335u,4294246389u,2635153856u,44739310u,552586956u,3186548104u,3860437401u,2582842572u,3436181894u,1718085244u,3274912563u,1047109219u,3059754667u,2113579688u,4146775159u,684012417u,3185398955u,1420475220u,1414874165u,1363219957u,1079339767u,2102744389u,1413815632u,366826968u,357914485u,1467193481u,2592717738u,2732401341u,179015024u,2411672478u,568205431u,1362022673u,785458779u,1717003460u,1103939548u,3809811491u,1440483938u,1646683955u,926936271u,2579996262u,1741474824u,4002152450u,570564978u,863502128u,3493413888u,2855251616u,2050484286u,536879654u,1648291565u,3366878410u,2925648319u,3882300403u,858915737u,2583200137u,3426431964u,4243502958u,2724621994u,3903335624u,2343400104u,1463636000u,2157835338u,2847797764u,1512267499u,1587762346u,335902077u,1410509800u,3755666049u,706029661u,2170508670u,33166762u,948444056u,2595470683u,3041042603u,2297890824u,4151451042u,998733074u,3977315069u,306673526u,1145324621u,4248974685u,3405070562u,40265331u,785182542u,4186334822u,1727842172u,3471343616u,499u,1357113102u,284424167u,3884189752u,4056380211u,590590777u,2156501401u,2631716047u,993058526u,2107101574u,3707808442u,4203227235u,3812451259u,3256942850u,2677709668u,163029666u,4196412085u,4155116048u,2868572290u,2947481239u,3356977160u,747284398u,2726734856u,2864641032u,547417086u,2776108975u,2852240829u,1153389611u,3716223248u,270268584u,2943355891u,4228260522u,5584208u,272098427u,2272765032u,462565435u,3287848969u,4194171908u,1308099677u,4087566845u,290458114u,118698865u,59898265u,2172700672u,11u,2290648947u,3208630076u,3234740275u,2678056550u,1712855483u,860142112u,3450012993u,1138225127u,337383764u,3791279575u,3244245119u,3059112932u,67235856u,2941298647u,2231728215u,4161258114u,3286278176u,2431680288u,4289712893u,41780485u,8213547u,3492795408u,635461281u,4272287920u,2968533048u,947420220u,1072201707u,4095726655u,1363230741u,218369513u,2112387719u,2919545868u,3158299634u,1040326207u,4192304903u,125730528u,4034981951u,1078985600u,2180641853u,1069596736u,4229930976u,1616934975u,941621248u,0u,2282245244u,4039911032u,2036729363u,187826218u,3170083338u,418434846u,1045493886u,2123921535u,3912681479u,2865489930u,36173420u,2302931796u,3205692963u,4193787455u,2575403127u,4160876624u,4030787824u,2021154816u,0u,0u);\n#else\nconst vec3 grid0Min = vec3 (-4.00, -4.00, -4.00);\nconst vec3 grid0Max = vec3 (4.00, 4.00, 4.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[304] = uint[](1052696u,404241420u,202117616u,270000383u,2414872600u,2021648262u,116657212u,1070856002u,509478378u,336916560u,4280307135u,2423814248u,2106053692u,1010579521u,3256871445u,4269151568u,274069423u,3237995263u,2265437170u,4089692931u,4194171361u,3783360943u,732929282u,1420431477u,4030070746u,2140676349u,126945219u,3285173239u,3888111390u,471918478u,242322062u,1086341601u,3768705505u,4042322160u,3230294630u,2141139762u,818925336u,295506050u,2206614275u,3282108800u,366276676u,1609359359u,4286079078u,1726373503u,1009259519u,4196479902u,504756729u,2677869226u,135491603u,4048780943u,4027064294u,1643764743u,4094430195u,4107046674u,1719010746u,1143644200u,2867592847u,3892979843u,2880002027u,3129551370u,44705952u,2884287275u,2914126370u,2884336802u,4010322464u,2157966426u,538619314u,4891290u,2550920895u,4207911431u,2863722564u,73819750u,1644566394u,2951383799u,265818130u,3188338223u,4037010920u,2139155072u,4286622599u,2944931960u,2021654463u,1010326588u,1010581502u,504391422u,505290271u,3893575404u,3473886222u,1905892825u,2556899532u,3435978648u,4019256576u,4279238054u,1719171168u,2066742048u,808466457u,2415929824u,3154083993u,3220044996u,1538252029u,3202770531u,2254727123u,51634113u,872126872u,1659738554u,4020808328u,2854232639u,2707392488u,89844230u,117666755u,3947500937u,1467984426u,2935312125u,1476952746u,2852825771u,2720180906u,716528565u,1474472490u,4004183432u,2852661384u,2291907492u,3409624131u,3105362329u,2622233807u,3153899344u,3208703760u,269819205u,286259576u,2105080326u,26281968u,1023407043u,33800689u,20977141u,4126220005u,4195350787u,4290527981u,318506755u,3280142592u,348144860u,4232070768u,1071504313u,3061709759u,3737858867u,590560867u,507091359u,859783118u,3485177740u,3865494625u,4294773487u,147630711u,2286239813u,4290724067u,3825179920u,437234178u,2876635105u,2702159618u,4245312835u,3286937278u,522066804u,44612266u,2175732527u,4039069943u,1091779497u,3042409316u,1466081826u,4008414890u,3884746792u,2290654139u,3025128244u,1306106329u,2644090060u,3752972223u,3706654992u,3810334720u,572531263u,4045291239u,1896038398u,3981809473u,67120096u,2692759520u,3154115583u,4106801122u,262671365u,4457597u,3401293258u,3114130627u,3007034174u,1637456379u,3878735054u,4109342822u,3429292539u,3718282626u,4208796245u,1575720317u,1628504533u,1353428923u,1432185488u,715910081u,1440044373u,1431385973u,1067869248u,2538038357u,1646438955u,3996380810u,871279144u,2308684723u,617329196u,3275329945u,2165621956u,3435654689u,3486257390u,4010806880u,644245095u,842015539u,807536243u,254279742u,251649983u,403177532u,3927826174u,3929398511u,3486317792u,2389075462u,1615278867u,4046664602u,2140772798u,2881137375u,581089876u,68515157u,1365112289u,3741629023u,3751829410u,1410684277u,1094800887u,2707382111u,95049128u,1343241143u,2757229205u,1538269218u,581857262u,937986175u,2156406922u,2820403756u,3283857452u,1339627793u,3650899020u,3439320067u,4243467093u,3624822374u,1644562227u,857932288u,8718u,1062274844u,2028019454u,1719034782u,2134324087u,1858868213u,3831503860u,1098268330u,350885346u,169406671u,448688354u,3200134079u,1075836320u,2695904938u,99227114u,168885872u,2733671102u,168435700u,536191226u,4197095352u,2283466923u,3218128203u,3625547900u,471612670u,4264431580u,3218206977u,2699591709u,1296301069u,266344478u,3890718695u,4027342835u,3019105232u,4244701440u,17u,391188377u,2174644323u,2409614536u,2167619532u,3393283093u,1542931716u,159243640u,2112454140u,273013823u,1820195669u,3578872064u,353308431u,3886415751u,2181457907u,4226008003u,839074113u,1075055887u,2273805830u,126075843u,50397184u,0u);\n#endif\nuint readBitsSVO0 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject0[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject0[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject0[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO0 (vec3 samplePos, vec3 sampleDir, out vec3 skipPos) {\n    skipPos = vec3 (10000.0);\n    if ( any(lessThan(samplePos, grid0Min)) || any(greaterThan(samplePos, grid0Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid0Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO0 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO0 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO0 (streamReadPos, 1u);\n    if (topBrick == 0u) {\n        vec3 topBrickMin = grid0Min + vec3 (topBrickPos);\n        vec3 topBrickMax = topBrickMin + vec3 (1.0);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, topBrickMin, topBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO0 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid0Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) {\n        vec3 midBrickMin = grid0Min + vec3 (topBrickPos) + midBrickPos;\n        vec3 midBrickMax = midBrickMin + vec3 (0.5);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, midBrickMin, midBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO0 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n    checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    skipPos = samplePos + sampleDir * 0.25;\n    return false;\n}\n\nbool traceRaySVO0(vec3 p1, vec3 p2, out vec3 hitPos) {\n    vec3 m = p2 - p1;\n    float hitMin, hitMax;\n    if ( !rayBoxIntersectTime (p1, vec3(1.0)/m, grid0Min, grid0Max, hitMin, hitMax) ) {\n        hitPos = vec3 (-1.0);\n        return false;\n    }\n    \n    hitMin += 0.00001;\n    hitMax -= 0.00001;\n    vec3 curPos = p1 + hitMin * m;\n    vec3 curDir = normalize (m);\n    vec3 skipPos = vec3 (0.0);\n    for (int i = 0; i != 100; i++) {\n        if (readLeafSVO0 (curPos, curDir, skipPos)) {\n            hitPos = curPos;\n            return true;\n        }\n        if ( skipPos == vec3(10000.0) ) break;\n        curPos = skipPos;\n    }\n    return false;\n}\n\n#ifdef HIRES\nconst vec3 grid1Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid1Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid1Range = grid1Max - grid1Min;\nuint svoObject1[592] = uint[](559947905u,130u,46269312u,514u,536913538u,2184161023u,3622749043u,4147064396u,4293156985u,3790071392u,1651699907u,872103072u,1078026339u,3887358020u,1128162041u,4268123168u,537552954u,1738155708u,741593847u,1070472734u,533601546u,34078727u,3696020863u,3435217855u,4268124129u,3764412824u,431961079u,255014664u,3231647631u,2680045679u,9421823u,803594597u,1618485168u,816871512u,142111045u,72090087u,3865470951u,2275311235u,1203885758u,3091078942u,505290511u,256839439u,2850578305u,2055373886u,3158228000u,1090609643u,1577713279u,2701099229u,2852786055u,2240251783u,3250832323u,3287015775u,3927875747u,179210760u,539454485u,742320490u,2212619744u,2678583536u,4089909235u,3347384179u,3099918671u,72348164u,1340573191u,2551735777u,4089676300u,1014219681u,1354825761u,2172752000u,2148855824u,1607523583u,4294926950u,3867049598u,2684302130u,3973005116u,3436183449u,3093720967u,4025457130u,4293983266u,2148018184u,805045324u,326958287u,1019999844u,1640872517u,2576956195u,51166268u,2576064246u,1724418184u,2165252088u,202174374u,1436711000u,128450449u,3006222284u,1334034329u,2122127391u,2644021224u,22464u,3615870869u,1748467833u,2575820798u,3279865870u,3436078694u,1717989171u,858995507u,2579003289u,872364028u,3502273487u,201911934u,2117625831u,2146386109u,179750935u,3893712383u,2863316241u,67113052u,1409563596u,2122219105u,2166258174u,4013945029u,3926689106u,3977466495u,2021621334u,2173250306u,45943586u,1644175487u,1997581936u,2339600512u,2829189768u,3951733437u,1138987248u,275792123u,4206366032u,4285725702u,572653610u,2694884031u,1535815587u,8705089u,3291764692u,3943765237u,1342842926u,3539979567u,1278228416u,3286755302u,471359713u,4024929288u,283567880u,46050974u,804831041u,4244354034u,837873910u,429496440u,2063027404u,3469659377u,2143745606u,4110828559u,1090848015u,4278225794u,4248813684u,1965510609u,71297433u,2576975390u,135798780u,3235695823u,511462605u,3495325652u,1204830535u,3556466879u,1234639321u,2603748569u,999504281u,2576980381u,3703955248u,1576739793u,3707769168u,665610u,2284321723u,862194491u,854301081u,2577375180u,3435973708u,3865503718u,1718827827u,858995609u,2540214679u,4091404275u,3285979088u,2207244192u,1606320834u,2715632831u,3227104005u,3573644945u,1560807484u,1549565055u,3824192436u,4191287680u,2688614713u,3901979492u,12319539u,617479971u,159911945u,2227981516u,3318676486u,4260889597u,2650543998u,3363889280u,136340981u,1363385407u,1816132987u,4190101902u,505019632u,3232768012u,134390307u,3458330599u,235409652u,3889163655u,3884322936u,2021405932u,335020275u,2865048571u,3100066627u,2210472425u,4265733119u,2698683736u,168427648u,2162017473u,2131509235u,4125052956u,3776047208u,578299901u,1357383035u,3363929728u,547365567u,4118676986u,250673840u,4166547832u,1410073614u,67492609u,3940177759u,2148016175u,4048997443u,3942509562u,101040571u,3782930239u,808791871u,267558815u,2644349408u,1795146106u,3118634976u,1040712128u,1149805058u,2801778361u,4089589754u,1008765072u,2357230604u,205274366u,637933681u,3860758076u,4035120910u,1048475233u,2173075071u,1865886736u,3274689503u,4019722273u,3823312863u,3435934147u,4077878997u,1861709888u,487394042u,4286083136u,1099407160u,1949449266u,404232461u,223285167u,2566374279u,2277407628u,4221767592u,939874293u,339826516u,1097161744u,1162625345u,2110403037u,3478920513u,1157911893u,4184692743u,3914361864u,1009266182u,236863351u,242020517u,1359931460u,4280641u,2069922273u,2518644255u,230622463u,2141166712u,2019591046u,943310379u,2618310728u,4219502224u,578813684u,3151151744u,3284901726u,272753615u,505219214u,142640258u,2192172014u,436009200u,2062569230u,4260894842u,4018415696u,1210581536u,2711621872u,2826856572u,1010580536u,1073081333u,1793197594u,3172600330u,11012128u,1611147784u,104466435u,249867258u,42796546u,2148432557u,4221539940u,1174644737u,50398081u,21056593u,1776329854u,1979674867u,859733052u,1347788400u,2291663487u,3290184880u,3284321219u,4283305496u,2053235163u,51317248u,1141128718u,519889407u,4042322112u,2160131855u,249067640u,1749516551u,3278553407u,3222603031u,1601992768u,1082623879u,473940938u,1010736649u,3789592545u,4061133325u,3936355670u,4293477270u,491658781u,202247559u,2280489479u,4269894293u,1648113281u,1432047022u,3134722169u,270959118u,10137434u,3854491729u,1092075839u,1769881737u,2753263199u,318967608u,3809427358u,2019725214u,1981817384u,136474160u,870199824u,268435600u,1342218112u,2231730442u,3745566404u,4007682815u,2398019871u,3279154956u,214749153u,3791619974u,1718090812u,737276727u,4027589630u,1650948199u,4168581217u,4281545591u,4008697652u,4258598976u,361046440u,2611486705u,1919992030u,1007471535u,2214037445u,2212528608u,568455664u,4042321923u,4202190840u,3349171136u,3162307851u,3781255649u,1163138067u,3949715957u,3786925552u,806416624u,4172837873u,2267575219u,2736650018u,3114377607u,3999305983u,418435304u,1350058245u,1594156934u,2279084133u,4168938481u,3271765052u,903995650u,515775728u,2694882352u,338178022u,238838185u,3768844275u,51150653u,1043592185u,4286645368u,2021150741u,1461379358u,1852076099u,4265938961u,62527926u,160003721u,2720049834u,89566070u,2859877476u,1149811643u,3937051178u,2717967910u,1822842363u,2356405004u,3719508377u,2576416768u,1016705u,2257042639u,1055998918u,4267891992u,577216261u,3435646015u,3975046767u,2733008507u,926545651u,994023899u,2172680601u,2681467183u,50121653u,219644165u,1384219101u,3173248832u,4031809502u,133701571u,3233861566u,601890912u,2141167600u,2418029371u,34078523u,2552756206u,511696239u,4013703119u,1048278372u,2672104512u,1429175632u,903897438u,504241680u,4279177022u,2063087663u,2399305095u,2214199979u,2711743361u,4144957614u,1357926640u,4287135736u,2079854712u,1343576701u,4043659391u,410548292u,809251354u,464953258u,2864390306u,3090852095u,4294884414u,4215028784u,540909169u,1369313285u,1433763159u,3612426560u,346687544u,40548715u,4271291934u,2684227608u,142693727u,3958756801u,1074112682u,2161322u,4210536096u,1429173524u,669507653u,2690258928u,850656248u,144437275u,4293265058u,2852257806u,570878471u,2968500995u,4060283280u,62u,35529246u,2682059979u,4038135565u,259941984u,377389033u,2134848307u,801913919u,2677643751u,3860733903u,3436950320u,265015568u,1574439426u,117654483u,2581199489u,3925816066u,1085882146u,96114712u,407718972u,1124103518u,4049556800u,2155929553u,1094960506u,530595448u,4192321926u,102694128u,3766552447u,411583488u,2550691964u,203177059u,4294836283u,4123013071u,3659067627u,252645144u,2139602544u,1143087166u,505167361u,4269338848u,4294269071u,3132080255u,2273543998u,3095561158u,941625223u,2172618159u,4230480940u,536101205u,3422437344u,4125223441u,1308983424u,58753505u,4106059472u,3222136688u,1074234630u,0u,4459558u,101061121u,2031887u,84811655u,2273605759u,3284320575u,3393257480u,2156380610u,1050427360u,505290271u,4028625018u,2147737633u,3823193072u,252645182u,4161781108u,1080041473u,1884295408u,4168645240u,1886928672u,536902996u,970197636u,473398248u,2504408564u,1075072469u,267984894u,3829919706u,106954752u,0u);\n#else\nconst vec3 grid1Min = vec3 (-4.00, -4.00, -4.00);\nconst vec3 grid1Max = vec3 (4.00, 4.00, 4.00);\nconst vec3 grid1Range = grid1Max - grid1Min;\nuint svoObject1[377] = uint[](1136706755u,1138876512u,1105285168u,276306008u,404758704u,4042322160u,4168644728u,2021402664u,673218704u,4042322112u,4168644728u,2019827752u,272646161u,806359865u,412719516u,202116612u,1712648256u,1303392383u,4269799458u,1805521414u,1744632895u,4240129919u,4079161373u,3693117589u,4029734911u,3561872888u,276304280u,196602940u,470547640u,174080614u,1680015528u,136347596u,3438235328u,1154973247u,3328599662u,1181736351u,3253993228u,214749153u,4194174854u,1718023183u,4096521439u,1109392889u,3789623293u,49332055u,3225671166u,392740609u,4283170328u,403179479u,1119699641u,1096162759u,2652179660u,3427860791u,2135555648u,2605181619u,184682881u,2206719942u,731653021u,1579290640u,736747658u,3020471903u,1061093620u,4060286911u,2268622944u,2173156904u,733618211u,3760241122u,1725166387u,1018966208u,2314312094u,2017526984u,3435677760u,1081073824u,577503119u,4294966779u,858836940u,3472683001u,2164155974u,1743152751u,3103779075u,4261552193u,1094795232u,2581627323u,1410037375u,3951026429u,4241277711u,4193907199u,3865471903u,4294686443u,3005480578u,2130320u,3435974214u,67387554u,2158928507u,2680104691u,858716559u,3650722204u,3435977932u,3462821478u,1718056821u,3425924239u,67080094u,404227621u,2314730205u,2685903088u,3766452034u,3509539647u,3513148768u,1447298060u,1560271906u,1742487537u,3519577984u,2152730687u,3130499612u,3787055643u,4037050459u,859819791u,3758626936u,4187748336u,2113659395u,587399440u,1039065503u,3256761585u,3506290432u,4244559978u,4227663761u,100827221u,1094800477u,4146028382u,299065103u,282074971u,2371123922u,3640689280u,2197782615u,3244203490u,3124501528u,337579020u,1124274174u,1728024442u,1833086214u,41976458u,2189411710u,92203520u,4151256422u,1615323316u,1006744127u,4263966879u,1387070204u,100827251u,50477088u,971020715u,2800401884u,3435974316u,1547961968u,2821237500u,2096942019u,3426614521u,3238137374u,956103884u,3474927856u,4269696623u,2172813279u,1065038799u,1044135933u,3109322577u,3208699007u,2011698540u,2419944417u,2447476840u,1618509820u,1441921536u,2142890499u,298909815u,3241591748u,1788176446u,369499134u,386074382u,1069123516u,2017720455u,1445077504u,1405157758u,2165768033u,3957362660u,504635262u,1895493761u,51321968u,1202214008u,1163133761u,1072577404u,3925573121u,4278189835u,263130942u,1894828096u,1621629096u,2081168444u,1010800097u,4125220993u,2683370992u,4031841029u,252511639u,3500703741u,4164828208u,1041743642u,505412592u,1548473679u,2215415047u,1161843008u,1146355039u,4282488409u,335875073u,4210785u,3760218595u,4092723968u,808644856u,2014681214u,4286321704u,550424379u,865995280u,4282751248u,1197212163u,3288329758u,473555455u,1105854463u,252509438u,1357967613u,4287075584u,2021154916u,540564796u,1415823677u,3789676993u,3825082013u,4042322130u,4035906319u,2262631165u,7984451u,2507936889u,3791551073u,3786473263u,16629586u,4244826373u,8361320u,25089346u,358876695u,1090719504u,3713481813u,1431327571u,1366070079u,2055086481u,2216389758u,4269334657u,125618376u,1145053313u,4466688u,4286873899u,3757677038u,2145304655u,3750245307u,1037032848u,242864412u,3704474829u,3494903781u,3926263542u,2052073468u,4294955839u,989082975u,4290381214u,98910710u,1084370848u,2147280917u,1748976277u,1120999168u,1509900248u,2040526343u,4257413070u,1020018644u,1071521300u,471824057u,4211255935u,3514597683u,3577976138u,906370654u,525406047u,418402573u,1347437909u,1463554097u,66904046u,534897639u,487066199u,3276018044u,2172567105u,4058507252u,527495410u,4035249423u,142430341u,1923890175u,3149533200u,2072279445u,1434064240u,295455951u,3171505493u,1431336789u,1219695946u,4045829734u,2007168881u,377275262u,3431744597u,1077512337u,135331840u,1544354875u,2146434945u,3766361336u,513801420u,3224382716u,3419651942u,1717634662u,2134061875u,926906226u,3927275017u,1416892476u,1010698223u,4263386959u,3420393220u,3472882072u,1726550031u,3620523468u,807650247u,4288549361u,1617122766u,274471940u,1040088638u,1910628878u,524058528u,3451851385u,2097166968u,2021489091u,3275504699u,4058112481u,1080404u,601179028u,836836894u,1041561076u,3495815925u,1610446167u,1350062144u,2098528980u,735323616u,1577156119u,4159721489u,4294938600u,218453312u,1346191239u,3799654280u,505316351u,2349334528u,1904399u,219121025u,2273779648u,3234008846u,1642348559u,2393406392u,1938279484u,1009795010u,63029056u,4229367633u,519961976u,1488684934u,2265442325u,4261290946u,50401322u,34488078u,1895430095u,16741952u,716569506u,169866698u,2804596498u,737914908u,3453680975u,4026531840u);\n#endif\nuint readBitsSVO1 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject1[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject1[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject1[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO1 (vec3 samplePos, vec3 sampleDir, out vec3 skipPos) {\n    skipPos = vec3 (10000.0);\n    if ( any(lessThan(samplePos, grid1Min)) || any(greaterThan(samplePos, grid1Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid1Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO1 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO1 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO1 (streamReadPos, 1u);\n    if (topBrick == 0u) {\n        vec3 topBrickMin = grid1Min + vec3 (topBrickPos);\n        vec3 topBrickMax = topBrickMin + vec3 (1.0);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, topBrickMin, topBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO1 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid1Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) {\n        vec3 midBrickMin = grid1Min + vec3 (topBrickPos) + midBrickPos;\n        vec3 midBrickMax = midBrickMin + vec3 (0.5);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, midBrickMin, midBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO1 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n    checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    skipPos = samplePos + sampleDir * 0.25;\n    return false;\n}\n\nbool traceRaySVO1(vec3 p1, vec3 p2, out vec3 hitPos) {\n    vec3 m = p2 - p1;\n    float hitMin, hitMax;\n    if ( !rayBoxIntersectTime (p1, vec3(1.0)/m, grid1Min, grid1Max, hitMin, hitMax) ) {\n        hitPos = vec3 (-1.0);\n        return false;\n    }\n    \n    hitMin += 0.00001;\n    hitMax -= 0.00001;\n    vec3 curPos = p1 + hitMin * m;\n    vec3 curDir = normalize (m);\n    vec3 skipPos = vec3 (0.0);\n    for (int i = 0; i != 100; i++) {\n        if (readLeafSVO1 (curPos, curDir, skipPos)) {\n            hitPos = curPos;\n            return true;\n        }\n        if ( skipPos == vec3(10000.0) ) break;\n        curPos = skipPos;\n    }\n    return false;\n}\n#ifdef HIRES\nconst vec3 grid2Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid2Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid2Range = grid2Max - grid2Min;\nuint svoObject2[406] = uint[](140517500u,872168448u,0u,131619u,53674755u,4261815835u,3193971175u,3791598371u,4042534961u,4090494731u,2684352639u,1711570767u,3405523952u,924066117u,1975578498u,663121657u,2724626430u,4233327587u,3288326141u,4261011714u,1719239068u,3430467388u,3896524816u,2361393382u,545254143u,4294967171u,859550515u,938866161u,530668769u,1074819313u,2146990200u,2147055624u,180108799u,3287531039u,3995016208u,34118415u,3482259215u,2231732096u,1090724097u,8742u,571683635u,855849369u,2568616444u,217843729u,17805197u,2141745799u,2369586110u,716992487u,2716594078u,1726459658u,150319087u,135069826u,96584131u,60422774u,2716453943u,4009543876u,1145045376u,3221228167u,2852648895u,993192259u,3621765017u,4226523032u,348105258u,145721345u,4262849143u,2153090799u,2867505834u,2884272770u,2820669610u,2864351272u,3941245482u,3955372014u,4273012783u,3954524202u,3131746986u,3145861922u,9416609u,1535475690u,2754087592u,169878063u,2139081778u,3967882047u,4024917528u,283352989u,178915328u,17830297u,4159060967u,1341599424u,3237166881u,3764414433u,4028670077u,71128117u,1412915527u,1718968294u,2000638782u,3812035704u,1470496647u,3156749372u,140517484u,826228253u,2652770568u,134217796u,71174686u,505289226u,134225665u,253173503u,2281669375u,2147993554u,4257467459u,3841802726u,1077936802u,2729091567u,4010543152u,4159638758u,2188306393u,2800257198u,3934298794u,537063050u,3085740718u,2785414714u,2935533535u,1881333792u,2725249008u,1290809597u,3121596431u,2927392888u,2055374396u,603204564u,672485392u,1434451936u,4227323399u,1141310451u,4088002942u,2156002619u,49613812u,3218375937u,1426589709u,1565875540u,232739157u,1681948028u,735849428u,337728853u,1107823439u,72350479u,1307568121u,1717047407u,4194094092u,863239372u,1046875705u,4192601662u,4268794049u,259946728u,1077985152u,2291630251u,2868888235u,3953229953u,2428820728u,1719563296u,536870912u,71568588u,322117491u,859806081u,109042049u,2627502157u,3756138239u,4193229262u,84869119u,3423254666u,4223143767u,3015188995u,2719127689u,2576465405u,1412092135u,2860778500u,1078459402u,4235186347u,301757776u,720371415u,1107699205u,1433910133u,3587523585u,1158681677u,1432178965u,3642161674u,34209537u,50597175u,4258249727u,25276414u,2122193279u,14540798u,1060832085u,3958287018u,1090600809u,4282425207u,1754755887u,185608449u,2440122385u,3883390295u,74925071u,2729441799u,3794252623u,3148084207u,2680153958u,1720261119u,4080206860u,822267084u,4145675140u,161080947u,864172962u,1081584u,142084112u,2018509328u,402734899u,922951550u,4171210649u,2676091486u,3700169981u,3367898654u,521673227u,134265528u,2289535146u,3803949696u,2954370992u,3735308973u,3581018176u,1144908465u,3722583726u,4124092576u,2239688564u,380114924u,604378453u,1977048412u,1162101085u,1564738781u,1171591551u,2422024706u,681572221u,4291031811u,202182654u,2130188321u,2173142975u,3757030448u,567791550u,353637429u,1252704095u,1157698555u,4261710207u,3791650607u,571411503u,528555921u,2003915071u,3980883015u,1353097218u,4289098675u,926874275u,1067427432u,404398015u,3274783756u,3287547745u,2577285627u,4147362339u,838862880u,2105293843u,4293989171u,4240439487u,4120484343u,4294770677u,2328881749u,2718005015u,33453847u,3942416248u,2021147771u,4249009092u,1788698624u,2158690177u,2009595807u,3359260350u,2130158918u,1071155374u,3760890538u,2863316623u,3993634830u,2919754374u,3894847498u,2827659274u,2720137894u,2930441903u,1392422402u,242154993u,2835016362u,39870951u,4160008167u,2411737136u,4278691719u,2817540184u,1816051336u,22040661u,4160194309u,142145783u,1673739516u,3271768544u,2174352353u,2852109531u,2689466127u,3121152256u,1414861892u,905278814u,2690557296u,539506808u,142441853u,2105442686u,2202091840u,520949583u,1041230329u,2122710535u,3993435146u,4244569343u,51543590u,1853784057u,3254650366u,4271962240u,2160082959u,2290321967u,4221545470u,2209907330u,2172764352u,3235931744u,1612710114u,578694911u,2147193139u,1069535295u,3650879423u,4294187034u,185540631u,387389671u,264206456u,1613334407u,2273541633u,4228556938u,2827126783u,3156346885u,3284386755u,4228279871u,1440858433u,2162819744u,2863378186u,737542128u,4244440829u,2192570488u,1210581119u,1062195248u,271597315u,4292349976u,403177472u,161001331u,4268019507u,859012709u,4131472388u,68417194u,1141504950u,2579183411u,923090942u,4247507071u,1349862400u,1882206264u,403701760u,117507008u,0u,307u,20123955u,2583422873u,2571941868u,2348843691u,2281609214u,2172649406u,3082034750u,3768315647u,2690624744u,252444704u,2694970608u,1560257284u,4241389168u,1203519552u,272693360u,947414048u,536870912u,0u,1245443u,151093259u,3146255856u,2156896063u,3207643591u,1044365211u,1996482112u,3208644092u,348961863u,3742626814u,4292998467u,2652798717u,4261483383u,3439262968u,4131112000u,2118123972u,1157480694u,2147360864u,1616917248u);\n#else\nconst vec3 grid2Min = vec3 (-4.00, -4.00, -4.00);\nconst vec3 grid2Max = vec3 (4.00, 4.00, 4.00);\nconst vec3 grid2Range = grid2Max - grid2Min;\nuint svoObject2[254] = uint[](273480800u,1207793664u,152u,161074380u,3317964262u,3890733177u,3650236971u,3505455015u,4287033240u,947648639u,4265557243u,4234936271u,4278066745u,4186050553u,2565517168u,3363865130u,4077060667u,2684361796u,1308581887u,4294452863u,4268142550u,3200003954u,2882840592u,287305768u,2021161980u,123124796u,1027779014u,2819969104u,1163223032u,2020636796u,1132824454u,740540156u,135282766u,2015381471u,2552259643u,3156750336u,1141124836u,1052361218u,507503411u,1015890739u,955119645u,2018613522u,91771924u,289382368u,2107214366u,516374392u,200490084u,2008834048u,260736824u,2407237627u,1073493675u,3263348753u,17825592u,1163401863u,2273806312u,380198531u,3279951125u,357900157u,2020098439u,2675468015u,3981618377u,921179205u,1432213782u,1876514777u,131875519u,3727422659u,3155177783u,4227358744u,444585959u,3325830102u,1073004036u,69247008u,2665550847u,1609437102u,3791257220u,34075900u,804437763u,4047656453u,1610220576u,2686492093u,4222671788u,4290746775u,2256437145u,2279589566u,1008812483u,3743158750u,287064133u,1642111325u,3780133064u,1651407923u,1009778688u,159614908u,3352068102u,116391695u,24379374u,290804063u,4016535653u,1207332725u,871192443u,4043463701u,4279850015u,4027971564u,2166269816u,218432517u,1094796117u,1434417146u,2156511437u,4289391272u,2853695482u,2829757098u,2214308436u,2706680645u,1417815671u,1090732851u,4273438687u,4026269272u,402938634u,2197947456u,1139712853u,3994113187u,1414792277u,1072693183u,4120880760u,270515711u,809550644u,1288675225u,2556454502u,1740230556u,809881395u,286907400u,135019580u,1010581008u,336079096u,2084355132u,1008734224u,1509427224u,947648484u,3959963695u,4104806625u,3777032213u,1361015125u,1599567456u,1196513143u,863835395u,4253009377u,22298655u,1897592688u,2266463464u,1433953301u,2105496951u,4282512520u,416087547u,3289132672u,3212732954u,2863311594u,3015621205u,1438531723u,1419797111u,2131490640u,875576801u,2173009470u,2123886778u,4092766224u,335808253u,1412125739u,1425948996u,1094319031u,2130704889u,3754160180u,214895613u,4162741857u,4194174471u,3092045616u,4294050577u,3641709632u,1305475839u,4163108863u,2047340543u,3006767443u,1072349039u,1163220032u,269557752u,2406677890u,2407495757u,4258580412u,964448251u,286326805u,1364546901u,1601689092u,68167766u,4023718571u,4252925972u,1163218425u,401169912u,505931259u,3120472446u,2746225409u,119505543u,3885998019u,3800288970u,1077944191u,1560105127u,1884991080u,1617422296u,805059964u,272547971u,3934470501u,4095692754u,3155156957u,4161927673u,3690857989u,4231855615u,3800236547u,1106575428u,339608084u,519377932u,235275815u,52625428u,89024487u,4194567683u,3893428491u,2172880775u,3284304834u,1312015u,2273806215u,2256568960u,235308934u,41943074u,3768721599u,4293990261u,4194513724u,3235831773u,2465831677u,75628585u,2692779001u,4243913931u,259846286u,1206339168u,0u,11874u,251249166u,993201359u,3208315008u,2287845440u,1204617211u,4160708438u,2129781759u,3623319416u,2164240072u,10486399u,257945907u,809450910u,1976639376u,0u);\n#endif\nuint readBitsSVO2 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject2[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject2[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject2[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO2 (vec3 samplePos, vec3 sampleDir, out vec3 skipPos) {\n    skipPos = vec3 (10000.0);\n    if ( any(lessThan(samplePos, grid2Min)) || any(greaterThan(samplePos, grid2Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid2Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO2 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO2 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO2 (streamReadPos, 1u);\n    if (topBrick == 0u) {\n        vec3 topBrickMin = grid2Min + vec3 (topBrickPos);\n        vec3 topBrickMax = topBrickMin + vec3 (1.0);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, topBrickMin, topBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO2 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid2Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) {\n        vec3 midBrickMin = grid2Min + vec3 (topBrickPos) + midBrickPos;\n        vec3 midBrickMax = midBrickMin + vec3 (0.5);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, midBrickMin, midBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO2 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n    checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    skipPos = samplePos + sampleDir * 0.25;\n    return false;\n}\n\nbool traceRaySVO2(vec3 p1, vec3 p2, out vec3 hitPos) {\n    vec3 m = p2 - p1;\n    float hitMin, hitMax;\n    if ( !rayBoxIntersectTime (p1, vec3(1.0)/m, grid2Min, grid2Max, hitMin, hitMax) ) {\n        hitPos = vec3 (-1.0);\n        return false;\n    }\n    \n    hitMin += 0.00001;\n    hitMax -= 0.00001;\n    vec3 curPos = p1 + hitMin * m;\n    vec3 curDir = normalize (m);\n    vec3 skipPos = vec3 (0.0);\n    for (int i = 0; i != 100; i++) {\n        if (readLeafSVO2 (curPos, curDir, skipPos)) {\n            hitPos = curPos;\n            return true;\n        }\n        if ( skipPos == vec3(10000.0) ) break;\n        curPos = skipPos;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fetchUV = fragCoord.xy / iResolution.xy;\n    vec2 uvDenorm =(fetchUV - vec2 (0.5)) * 2.0;\n    float curTime = iTime * 0.5;\n    vec3 curEye = vec3 (sin(curTime) * 20.0, 3.0, cos(curTime) * 20.0);\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (vec3 (0.0, 1.0, 0.0), curLook));\n    vec3 curUp = cross (curLook, curSide) * (iResolution.y / iResolution.x);\n    vec3 curDir = curLook + curSide * uvDenorm.x + curUp * uvDenorm.y;\n    vec3 curEndSight = curEye + curDir * 1000.0;\n    vec3 curSightSeg = curEndSight - curEye;\n    \n    vec3 hitPos = vec3(0.0);\n    bool rt;\n    if ( mod(iTime, 3.0) < 1.0 ) rt = traceRaySVO0(curEye, curSightSeg, hitPos);\n    else if ( mod(iTime, 3.0) < 2.0 ) rt = traceRaySVO1(curEye, curSightSeg, hitPos);\n    else rt = traceRaySVO2(curEye, curSightSeg, hitPos);\n    if ( !rt ) {\n        if ( hitPos == vec3 (-1.0) ) fragColor = vec4 (fetchUV.x, fetchUV.y, 0.0, 1.0);\n        else fragColor = vec4(0.0);\n     }\n    else fragColor = vec4 (length(hitPos - curEye) * 0.05);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGRc.jpg", "access": "api", "license": "mit", "functions": [[2144, 2144, 2242, 2242, 2609], [2611, 2611, 2638, 2638, 2728], [2730, 2730, 2774, 2774, 2988], [12442, 12442, 12489, 12489, 13366], [13368, 13368, 13438, 13438, 16445], [16447, 16447, 16501, 16501, 17099], [28720, 28720, 28767, 28767, 29644], [29646, 29646, 29716, 29716, 32723], [32725, 32725, 32779, 32779, 33377], [41376, 41376, 41423, 41423, 42300], [42302, 42302, 42372, 42372, 45379], [45381, 45381, 45435, 45435, 46033], [46035, 46035, 46092, 46092, 47129]], "test": "untested"}
{"id": "ctBGzd", "name": "Duo-level truchet", "author": "mrange", "description": "CC0: Duo-level truchet\nExperimenting with duo level truchet with multiple tiles\n", "tags": ["truchet"], "likes": 16, "viewed": 276, "published": 3, "date": "1673704822", "time_retrieved": "2024-07-30T18:15:55.040096", "image_code": "// CC0: Duo-level truchet\n//  Experimenting with duo level truchet with multiple tiles\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float w_0 = 0.11;\nconst float w_1 = 0.195;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  p += 0.5;\n  vec2 c = floor(p);\n  p = fract(p) - 0.5;\n  return c;\n}\n\nfloat df_0_0(vec2 p) {\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_0_1(vec2 p) {\n  vec2 ap = abs(p);\n  float d0 = ap.x;\n  float d1 = ap.y;\n  float d2 = circle(p, 2.0*w_0);\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  d = abs(d) - w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_0_2(vec2 p) {\n  vec2 ap = abs(p);\n  float d0 = length(ap-vec2(0.5, 0.0));\n  float d1 = length(ap-vec2(0.0, 0.5));\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_0_3(vec2 p) {\n  float d0 = length((p)-vec2(0.5, 0.0));\n  float d1 = length((p)-vec2(0.0, 0.5));\n  float d2 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  d = abs(d) - w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_0_4(vec2 p) {\n  vec2 ap = p;\n  ap.x = abs(ap.x);\n  float d0 = length(ap-vec2(0.5, 0.0));\n  float d1 = ap.x;\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_1_0(vec2 p) {\n  vec2 ap = abs(p);\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d2 = circle(ap-0.5, w_1);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - w_1;\n  d = min(d, d2);\n  return d;\n}\n\nfloat df_1_1(vec2 p) {\n  vec2 ap = abs(p);\n  float d0 = circle(ap-vec2(0.5, 0.0), (0.25));\n  float d1 = circle(ap-vec2(0.0, 0.5), (0.25));\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.5*w_0;\n  d = -d;\n  return d;\n}\n\nfloat df_1_2(vec2 p) {\n  vec2 ap = (p);\n  ap.x = abs(p.x);\n  float d0 = circle(ap-vec2(0.5, 0.0), (0.25));\n  float d1 = abs(ap.x-0.25);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.5*w_0;\n  d = -d;\n  return d;\n}\n\n\nfloat df_1_3(vec2 p) {\n  float d0 = (circle(p-0.5, 0.75));\n  float d1 = (circle(p-vec2(-0.5, 0.0), (0.25)));\n  float d2 = (circle(p-vec2(0.0, -0.5), (0.25)));\n  float d3 = abs(circle(p-0.5, 0.25))-0.5*w_0;\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  d = abs(d) - 0.5*w_0;\n  d = min(d, d3);\n  d = -d;\n  return d;\n}\n\nconst mat2 rots[4] = mat2[4](\n    ROT(0.0*TAU/4.0)\n  , ROT(1.0*TAU/4.0)\n  , ROT(2.0*TAU/4.0)\n  , ROT(3.0*TAU/4.0))\n  ;\n\nfloat df(vec2 p) {\n  vec2 pp0 = p;\n  vec2 np0 = mod2_1(pp0);\n  float h0_0 = hash(np0);\n  float h1_0 = fract(8677.0*h0_0);\n  float h2_0 = fract(3677.0*h0_0);\n\n  if (h2_0 > 0.5) {\n    vec2 pp1 = p*2.0;\n    pp1 += 0.5;\n    vec2 np1 = mod2_1(pp1);\n    float h1_0 = hash(np1);\n    float h1_1 = fract(8677.0*h1_0);\n    pp1 *= rots[int(h1_0*4.0)];\n    float d1 = 0.0;\n    if (h1_1 > 0.85) {\n      d1 = df_0_4(pp1);\n    } else if (h1_1 > 0.75) {\n      d1 = df_0_3(pp1);\n    } else if (h1_1 > 0.55) {\n      d1 = df_0_2(pp1);\n    } else if (h1_1 > 0.4) {\n      d1 = df_0_1(pp1);\n    } else {\n      d1 = df_0_0(pp1);\n    }\n    d1 *= 0.5;\n    return d1;\n  }\n  \n  pp0 *= rots[int(h0_0*4.0)];\n  float d0 = 0.0;\n  if (h1_0 > 0.9) {\n    d0 = df_1_3(pp0);\n  } else if (h1_0 > 0.7){\n    d0 = df_1_2(pp0);  \n  } else if (h1_0 > 0.5){\n    d0 = df_1_1(pp0);  \n  } else {\n    d0 = df_1_0(pp0);\n  }\n  return d0;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float ll = length(pp);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  const float sz = 0.333;\n\n  const float a = 10.0;\n  p += sin(0.25*vec2(1.0, sqrt(0.5))*TIME/a)*a;\n  float d = df(p/sz)*sz;\n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  col *= smoothstep(1.5, 0.5, ll);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 377, 398, 398, 468], [470, 470, 501, 501, 527], [529, 529, 556, 556, 625], [627, 627, 649, 649, 793], [795, 795, 817, 817, 1004], [1006, 1006, 1028, 1028, 1206], [1208, 1208, 1230, 1230, 1441], [1443, 1443, 1465, 1465, 1637], [1639, 1639, 1661, 1661, 1867], [1869, 1869, 1891, 1891, 2089], [2091, 2091, 2113, 2113, 2308], [2311, 2311, 2333, 2333, 2637], [2759, 2759, 2777, 2777, 3649], [3651, 3651, 3681, 3681, 3991], [3993, 3993, 4050, 4050, 4243]], "test": "untested"}
{"id": "dtjGzV", "name": "Pulsating Pyramid", "author": "A_Toaster", "description": "My first shader featuring noise-based terrain. I did some *interesting* things with the raymarching code as well, since the terrain noise function doesn't play well otherwise. Not well optimized or documented because I couldn't be bothered to do so.", "tags": ["raymarching", "noise", "terrain", "sky", "fog", "mountains", "lights"], "likes": 6, "viewed": 225, "published": 3, "date": "1673665767", "time_retrieved": "2024-07-30T18:15:56.026459", "image_code": "#define EPS 0.00001\n#define MAX_DIST 1500.\n\nconst float fog_density = 0.75;\nconst float fog_falloff = 4.;\nconst float atmo_density = 0.001;\nconst float atmo_falloff = 0.02;\n\nconst vec3 moon_dir = normalize(vec3(0.3, 0.5, 1.));\n\nconst vec3 moon_col =  vec3(0.20, 0.27, 0.75) * 0.1;\n//const vec3 moon_col =  vec3(1.);\n\nconst vec3 orb_col =  vec3(1., 0.6, 0.1);\n\nconst float moon_size = 0.1;\n\nconst vec3 flat_albedo = vec3(0.9, 0.9, 0.9);\nconst vec3 wall_albedo = vec3(0.3, 0.15, 0.15);\nconst vec3 low_albedo = vec3(0.7, 0.7, 0.7);\nconst vec3 pyr_albedo = vec3(0.05, 0.05, 0.05);\nconst vec3 pyr_top_albedo = vec3(1., 1., 0.5);\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nfloat mountain( in vec2 x )\n{\n    vec2 n1 = texture(iChannel0, x * 0.01).xy;\n    vec2 n2 = texture(iChannel0, (x + n1) * 0.005).xy;\n    float n3 = texture(iChannel0, (x - n2 * 1.) * 0.2).z;\n    float n4 = texture(iChannel0, (x - n2 * 0.5) * 0.4).y;\n    float n5 = texture(iChannel0, x * 0.8).x;\n    x.y = x.y * 0.5;\n    x = x + n2 * 0.25;\n    \n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    vec2 res = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) - f + hash2(p + b);\n        float d = dot(r, r);\n\n        if( d < res.x )\n        {\n            res.y = res.x;\n            res.x = d;\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    float h = smoothstep(0., 1.75, -res.x + res.y);\n    h = h + ( h * n3 * 0.05) + n4 * 0.005 + n5 * 0.005;\n    return h;\n}\n\nfloat mountain_ring( in vec2 x ) {\n    x = x * 0.2;\n    float circle = smoothstep(2. * 2., 10. * 10., dot(x, x)) + 0.05;\n    float m  = mountain(x * 0.3) * 1.0;\n    return m * circle * 5.;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Bound, not exact\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    float m = (p.x + p.y + p.z - s) / 3.0;\n    vec3 o = p - m;\n    vec3 k = min(o, 0.0);\n    o = o + (k.x + k.y + k.z) * 0.5 - k * 1.5;\n    o = clamp(o, 0.0, s); \n    return length(p - o) * sign(m);\n}\n\nfloat map( in vec3 p ) {\n    float mtn_dist = p.y - mountain_ring(p.xz);\n    if(dot(p, p) < 20.){\n        return min(\n            min(\n                p.y - mountain_ring(p.xz),\n                min(\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(2.5, 0.4, 1.1), 0.15),\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(1.1, 0.4, 2.5), 0.15)\n                )\n            ),\n            min(\n                sdPyramid(p * 0.75, 0.75),\n                sdBox(p, vec3(0.8, 0.05, 0.8))\n            )\n        );\n    }\n    return mtn_dist;\n}\n\nbool mat_pyramid( in vec3 p ){\n    if(dot(p, p) > 20.) return false;\n    float mtn_dist = p.y - mountain_ring(p.xz);\n    float pyr_dist = \n            min(\n                min(\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(2.5, 0.4, 1.1), 0.15),\n                    sdOctahedron(abs(p) * vec3(1., 0.5, 1.) - vec3(1.1, 0.4, 2.5), 0.15)\n                ),\n                min(\n                    sdPyramid(p * 0.75, 0.75),\n                    sdBox(p, vec3(0.8, 0.05, 0.8))\n                )\n            );\n    return pyr_dist < mtn_dist;\n}\n\n\n// From https://www.shadertoy.com/view/XdsGDB\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos, float dist )\n{\n    float h = max(0.01, 0.001 * dist);\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1. );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat softshadow_point( in vec3 ro, in vec3 rd, float mint, float k, float max_dist)\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + rd*t;\n        \n        h = map(p);\n        res = min( res, k*h/t );\n\t\tt = t + clamp( h, 0.02 + 0.5 * step(20., dot(p, p)), 2. );\n        if(t > max_dist) {\n            break;\n        }\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n\nbool intersect_precise( in vec3 ro, in vec3 rd, out float dist , out vec3 norm, out int i)\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for(  i=0; i<256; i++ )\n    {\n\t\tif( h < EPS * dist){\n            norm = calcNormal(ro + rd * dist, dist);\n            return true;\n        }\n\t\th = map(ro + rd * dist);\n        dist += h;\n\t\tif( dist > MAX_DIST) return false;\n    }\n    norm = calcNormal(ro + rd * dist, dist);\n    return dot(norm, rd) < 0.2;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist,     // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float fogAmount = (fog_density/fog_falloff) * exp(-rayOri.y*fog_falloff) * (1.0-exp( -dist*rayDir.y*fog_falloff ))/rayDir.y;\n    float atmosAmount = (atmo_density/atmo_falloff) * exp(-rayOri.y*atmo_falloff) * (1.0-exp( -dist*rayDir.y*atmo_falloff ))/rayDir.y;\n    float amount = fogAmount + atmosAmount;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nvec3 sky( in vec3  rgb,      // original color of the pixel\n          in vec3  rayDir )\n{\n    float yi = 1./clamp(rayDir.y, 0.01, 1.);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., texture(iChannel1, cloud_uv * vec2(0.1, 0.02)).r - 0.3) * texture(iChannel1, cloud_uv * vec2(0.2, 0.1)).r * rayDir.y * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi;\n    return mix(moon_col, rgb, exp(-amount)) + vec3(1.) * cloud;\n}\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat glare(vec2 uv, vec2 pos, float size, float origin_size)\n{\n    float dist = length(pos - uv);\n    float strength = clamp((size - dist) / size, 0., 1.);\n    strength = pow5(strength);\n    \n    float angle = atan(uv.y - pos.y, uv.x - pos.x);\n    float noise = mix(0.5, texture(iChannel0, vec2(0., angle * 0.07)).x, dist / origin_size);\n    return strength * noise;\n}\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n    \n    //float m = mountain_ring(uv * 20.);\n    \n    \n    vec2 camRot = vec2(.5,.5)+vec2(-.6,4.5)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0., 1.2, 0.), camRot, 15.0, 1.0, fragCoord );\n    \n    float orb_seq = pow(fract(iTime * 0.08), 2.);\n    float orb_radius = 0.02 / (orb_seq * orb_seq) + 0.01;\n    orb_radius += max(0., (orb_seq - 0.5) * 100.);\n    float orb_intensity = max(0., 0.5 / (orb_radius * orb_radius) - 0.005);\n\n    if(orb_seq > 0.5){\n        orb_intensity = 120. * pow(1. - smoothstep(0.3, 1., orb_seq), 3.);\n    }\n    \n    vec2 orb = sphDistances(pos, ray, vec3(0., 1.2 + 0.25 * orb_radius, 0.), orb_radius);\n    vec2 orb2 = sphDistances(pos, ray, vec3(0., 1.2 + 0.25 * orb_radius, 0.), orb_radius - 0.05);\n    \n    float orb_power = glare(uv, vec2(0.), 0.75, orb_radius * 20.) * orb_intensity * 0.1;\n    \n    float point_light_r = max(20. / orb_radius, 5.);\n    float point_light_height = 1.2 + orb_radius * 0.25;\n    float point_light_power = pow(orb_intensity * orb_radius * 10., 1.);\n    \n    float dist;\n    int i;\n    vec3 normal;\n    bool hit = intersect_precise(pos, ray, dist, normal, i);\n    vec3 col;\n    if(hit) {\n        vec3 hp = pos + ray * dist;\n        \n        \n        vec3 albedo;\n        float spec;\n        if(mat_pyramid(hp)){\n            float tip = smoothstep(0.8, 0.805, hp.y);\n            spec = tip * 0.9;\n            albedo = mix(pyr_albedo, pyr_top_albedo, tip);\n        } else {\n            float wall_amount = smoothstep(0.7, 0.9, dot(normal, vec3(0., 1., 0.)));\n            float low_amount = smoothstep(0.0, 0.02, hp.y);\n        \n            albedo = mix(wall_albedo, mix(low_albedo, flat_albedo, low_amount), wall_amount);\n            spec = mix(0.4, 0.0, wall_amount);\n        }\n        \n        float ao = calcAO(hp, normal);\n        float shadow = softshadow(hp, moon_dir, 0.01, 20.);\n        float diffuse = smoothstep(-1., 1., dot(normal, moon_dir));\n        float spec_brightness = pow5(dot(reflect(ray, normal), moon_dir));\n        \n        vec3 moonlit_col = shadow * ao * mix(albedo * moon_col * diffuse, moon_col * spec_brightness, spec);\n        vec3 pointlit_col = vec3(0.);\n        \n        \n        vec3 point_light_col = orb_col * point_light_power;\n        if(point_light_power > 0.){\n            vec3 point_light_ro = vec3(0., point_light_height, 0.);\n\n            vec3 point_light_dir = point_light_ro - hp;\n            float point_light_dist = length(point_light_dir);\n            float distance_atten = 1. / (point_light_dist );\n            point_light_dir = point_light_dir / point_light_dist;\n\n            float point_shadow = softshadow_point(hp, point_light_dir, 0.01, point_light_r, point_light_dist - 1.);\n\n            float pt_diffuse = smoothstep(-1., 1., dot(normal, point_light_dir));\n            float pt_spec_brightness = pow5(dot(reflect(ray, normal), point_light_dir));\n            \n            pointlit_col = distance_atten * point_shadow * mix(albedo * point_light_col * pt_diffuse, point_light_col * pt_spec_brightness, spec);\n        }\n        \n        float orb_occ = (smoothstep(orb.x, orb.x + 0.3 * orb_radius, dist) * smoothstep(0., 2., orb.x) + smoothstep(orb.y, orb.y + 0.3 * orb_radius, dist)) * 0.5;\n        //if(orb2.y > orb2.x)\n        orb_power += max(0., orb.y - orb.x - orb2.y + orb2.x) * orb_intensity * 10. * orb_occ;\n        \n        col = moonlit_col + pointlit_col;\n        col = applyFog(col, dist, pos, ray);\n    } else {\n        col = sky(vec3(0.), ray);\n        \n        orb_power += max(0., orb.y - orb.x - orb2.y + orb2.x) * orb_intensity * 10.;\n    }\n    \n    col += orb_col * orb_power;\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 647, 677, 858], [861, 861, 890, 890, 1754], [1756, 1756, 1790, 1790, 1946], [1948, 1998, 2033, 2033, 2518], [2520, 2520, 2551, 2551, 2638], [2640, 2660, 2698, 2698, 2915], [2917, 2917, 2941, 2941, 3488], [3490, 3490, 3520, 3520, 4050], [4053, 4392, 4524, 4554, 5020], [5022, 5074, 5118, 5118, 5408], [5411, 5411, 5476, 5476, 5698], [5700, 5700, 5786, 5786, 6125], [6127, 6127, 6169, 6169, 6451], [6454, 6454, 6546, 6546, 6888], [6890, 6942, 7009, 7009, 7227], [7229, 7229, 7470, 7470, 7825], [7827, 7827, 7916, 7916, 8332], [8334, 8334, 8355, 8355, 8403], [8405, 8405, 8468, 8468, 8774], [8776, 8776, 8809, 8809, 8977], [8981, 8981, 9038, 9038, 12805]], "test": "untested"}
{"id": "ml2Gzc", "name": "Simple meteor shower", "author": "jarble", "description": "Thanks to [url=https://www.shadertoy.com/user/JB_0x0003]JB_0x0003[/url] for finding this pattern!", "tags": ["fast", "rain", "janky"], "likes": 13, "viewed": 312, "published": 3, "date": "1673665584", "time_retrieved": "2024-07-30T18:15:56.798395", "image_code": "void mainImage(out vec4 outColor, vec2 fragCoord)\n{\n    outColor = vec4(0.);\n    vec2 st = fragCoord.xy / iResolution.y/16.;\n\n    vec2 b = vec2(0,.2), p;\n\n    mat2 rotation;\n    \n    for(float i=.9; i<5.0 ;++i){\n        rotation = mat2(cos(i + vec4(0,33,11,0)));\n        st = rotation * (fract((vec2(st.x,st.y+iTime * (0.18)/8.) * (i))*rotation)-.5);\n        outColor += 0.001/ length(clamp(st,-b,b)-st);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2Gzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 412]], "test": "untested"}
{"id": "dt2Gzc", "name": "春节烟花", "author": "koerriva", "description": "春节烟花特效", "tags": [], "likes": 9, "viewed": 199, "published": 3, "date": "1673664518", "time_retrieved": "2024-07-30T18:15:57.562352", "image_code": "\n#define rad(x) radians(x)\nfloat np = 100.;\nfloat snp = 20.;\nfloat R = 0.032;\nfloat R_RATIO = 0.04;\nfloat ACC_RATIO = 0.03;\nfloat ANG = 90.;\n\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec3 burst(vec2 st,vec2 pos,float r,vec3 col){\n    st -= pos;\n    r = 0.6*r*r;\n    return (r/dot(st,st))*0.6*col;\n}\n\nvec2 get_pos(vec2 u,vec2 a,vec2 p0,float t,float ang){\n    vec2 d = p0 + vec2(u.x*cos(ang),u.y*sin(ang)) * t + 0.5*a*t*t;\n    return d;\n}\n\nvec2 get_velocity(vec2 u,vec2 a,float t,float ang){\n    return vec2(u.x*cos(ang),u.y*sin(ang)) + a*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 10.);\n\n    vec2 u = vec2(0.);                ///< 初速度\n    const vec2 acc = vec2(0.0, -9.8); ///< 重力加速度 acc\n    float ang = rad(ANG);             ///< 上升粒子的发射角度\n\n    vec3 particles = vec3(0.0); //particle\n\n    for (float i = 0.; i < np; i++)\n    {\n        float r = R;\n        vec2 rand = N22(vec2(i));\n\n        /// @note 爆炸前的粒子上升\n\n        /// 初始位置\n        vec2 ip = vec2(sin(30.*rand.x) * aspect, -1. + r);\n\n        /// 真正初始化速度\n        u = vec2(sin(5.*rand.x), 5. + sin(4.*rand.y));\n\n        float t_i = t - i / 5.; ///< 时间差异化\n        vec2 s = get_pos(u, acc, ip, t_i, ang);\n        vec2 v = get_velocity(u, acc, t_i, ang);\n\n        /// 计算竖直向上的运动时间\n        float t_up = u.y * sin(ang) / abs(acc.y);\n        /// 根据时间计算出向上运动的最大高度\n        vec2 h_max = get_pos(u, acc, ip, t_up, ang);\n\n        vec3 pcol = vec3(cos(i), cos(iTime), sin(iTime));\n\n\n        if (v.y < -0.5) ///< 下落速度超过一定大小则消失\n        {\n            r = 0.0;    ///< 隐藏\n        }\n\n        particles += burst(uv, s, r, pcol); ///< 发射上升的粒子\n\n\n        /// @note 爆炸后的粒子扩散\n        /// 当粒子停止上升，且粒子的当前时间已经达到了上升的时间\n\n        if (v.y > -6.5 && v.y < 0.0 && t_i >= t_up /*&& SPAWN == 1*/)\n        {\n            /// 把一个圆根据角度分成若干份扇形\n            float unit = (360. / snp);\n            for (float j = 0.0; j < snp; j++)\n            {\n                float ang = rad(j * unit);\n\n                float r = 0.035;             ///< 心形粒子的半径\n                r -= (t_i - t_up) * R_RATIO; ///< 根据时间差来改变粒子的大小（变小）\n\n                /// --------------------------------------------------\n                /// @note 根据（单位圆的）角度计算笛卡尔坐标\n                float x = cos(ang); //coords of unit circle\n                float y = sin(ang);\n                /// 心形公式\n                y = y + abs(x) * sqrt( (8. - abs(x)) / 50.0 );\n                /// 心形速度向量，随着时间而变小\n                vec2 heart = vec2(x * x + y * y) * (0.4 / (t_i * sqrt(t_i)));\n\n                /// 根据心形的当前速度和加速度、初始位置等更新粒子的位置\n                vec2 S = get_pos(heart, acc * ACC_RATIO, h_max, t_i - (t_up), ang);\n                /// --------------------------------------------------\n\n                //vec3 pcol = vec3(1.);\n                particles += burst(uv, S, max(0.0, r), pcol);\n            }\n        }\n    }\n    col = particles;\n\n    fragColor = vec4(col,  1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2Gzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 160, 160, 294], [296, 296, 342, 342, 411], [413, 413, 467, 467, 550], [552, 552, 603, 603, 655], [657, 657, 714, 714, 3577]], "test": "untested"}
{"id": "dt23Rc", "name": "The Loudest Thunder", "author": "JB_0x0003", "description": "Made this on accident. Looks like rain or tracer bullets in the dark.", "tags": ["fast", "rain", "janky"], "likes": 6, "viewed": 272, "published": 3, "date": "1673661988", "time_retrieved": "2024-07-30T18:15:58.333291", "image_code": "\n\nfloat rand(float seed){\n\n    return fract(sin(seed * 10000.0));\n\n}\nvoid mainImage(out vec4 outColor, vec2 fragCoord)\n{\n    \n    outColor *= 0.;\n    vec2 st = fragCoord.xy / iResolution.y;\n\n\n    vec2 b = vec2(0,.2), p;\n\n    mat2 rotation;\n    \n    if (iTime > 3.0 && iTime < 3.5)\n        st.x += rand(ceil(iTime * 8.0 * st.y * 9.)) * (rand(ceil(iTime * 400.0))<0.3?0.0:1.0);\n    float bitch = iTime * (cos(iTime) + 1.0 )* 0.3 * (iTime <5.0?1.0:0.0);\n    \n    \n    for(float i=.9; i<21.0 ;++i){\n\n        rotation = mat2(cos(i + vec4(0,33,11,0)));\n\n        st = st * (i) * .1 * (min(iTime,11.5) * 0.06 + 0.62);\n\n        st.y += iTime * (0.18) + bitch - 0.1;\n        \n        st = rotation * (fract((st)*rotation)-.5);\n        outColor += 0.001/ length(clamp(st,-b,b)-st);\n        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt23Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 25, 25, 68], [69, 69, 120, 120, 787]], "test": "untested"}
{"id": "wsfGDl", "name": "Grid pattern experiment", "author": "ianwall", "description": "Yeah", "tags": ["test"], "likes": 5, "viewed": 223, "published": 3, "date": "1673661591", "time_retrieved": "2024-07-30T18:15:59.097249", "image_code": "#define PI 3.1415926535\n\nvec3 color( float t )\n{\n    ///t = mod(t, 1.0);\n\tvec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 0.7, 0.4);\n    vec3 d = vec3(0.00, 0.15, 0.20);\n    \n    return a + b*cos(2.0*PI*(c*t+d));\n}\n\nfloat _distance( vec2 p )\n{\n\tfloat x = p.x;\n    float y = p.y;\n    return length(p) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = 2.0*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float x = p.x;\n    float y = p.y;\n\n    float d = _distance( mod(p, 0.4) );\n\t\n    d *= cos(d) + sin(p.x + iTime)*p.y;\n    \n    // Output to screen\n    float mask = sign(d);//color(d);\n    vec3 col  = color(d);\n\n    \n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 48, 72, 253], [255, 255, 282, 282, 347], [349, 349, 406, 456, 877]], "test": "untested"}
{"id": "3lVGzw", "name": "circlenoise", "author": "ianwall", "description": "Offset circle noise", "tags": ["circle"], "likes": 17, "viewed": 286, "published": 3, "date": "1673659156", "time_retrieved": "2024-07-30T18:15:59.866193", "image_code": "\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n#define NUM_CIRCLE 50.0\n\nfloat radial = 1.00; // [0.0 or 1.0]\nfloat out_prop = 4.0; // [-10 .. 10]\nfloat strength = 1.7; // ?\nfloat start = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    uv *= 1.1+start/NUM_CIRCLE;\n\n\n    float c = 0.0;\n    float r = 0.0;\n    float angle = mix(uv.x, 4.0*atan(uv.y, uv.x)/3.1415926, radial);\n    \n    for(float i = start; i < NUM_CIRCLE+start; i+=1.0)\n    {\n        float z = i/NUM_CIRCLE;\n        float str = mix(0.1*strength, 0.05*pow(1.+z, strength), radial);\n        vec2 p = uv + z*str*pnoise(vec2(angle, iTime+out_prop*z), vec2(2.0, 100.0));\n        float d = mix(p.y+0.5, length(p), radial);\n        c += 1.0-smoothstep(0.0, 2.5*fwidth(d-z), abs(d-z));\n        //c += 1.0-smoothstep(0.0, 0.025, abs(angle+3.0));\n        r += c*angle;\n    }\n    \n    //vec3 col = vec3(0.5*pnoise(uv+vec2(0., iTime), vec2(10.,10.))+0.5);\n    //vec3 col = vec3(mod(3.0*c,1.0));\n    //vec3 col = vec3(c)-vec3(1.1,2.0,0.0);\n    vec3 col = vec3(vec3(c));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(0.5*vec3(pnoise(100.*uv, vec2(3.1, 3.0))+1.), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 71], [73, 73, 95, 95, 132], [134, 134, 162, 162, 214], [216, 216, 235, 235, 275], [277, 301, 323, 323, 1365], [1367, 1409, 1441, 1441, 2556], [2704, 2704, 2761, 2811, 3796]], "test": "untested"}
{"id": "WlyyRw", "name": "gridshift", "author": "ianwall", "description": "getting shifty", "tags": ["grid"], "likes": 1, "viewed": 155, "published": 3, "date": "1673659088", "time_retrieved": "2024-07-30T18:16:00.873499", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand(float t)\n{\n    return hash11(t);\n}\n\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = (uv + 0.5) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    float t = iTime/5.0;\n    float step = floor(t);\n    t = smoothstep(0.1, 0.9, t-step);\n\n    float Z = 3.0+8.0*rand(step);\n    float dir = sign(mod(floor(Z*uv.y), 2.0)-0.5);\n\n    vec2 uvg = vec2(uv.x, uv.y);\n    uvg.x = fract(uv.x+dir*t);\n\n\n    //vec2 uv2 = (floor(Z*uv)+offset)/Z;\n   \n\n    // Output to screen\n    fragColor =  texture(iChannel0, uvg);\n    //fragColor =  vec4(uvg.xy, 0.0, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 114], [115, 134, 157, 157, 242], [245, 245, 269, 269, 376], [378, 378, 399, 399, 423], [426, 426, 472, 472, 566], [569, 569, 626, 676, 1181]], "test": "untested"}
{"id": "WtVczW", "name": "gridrotate", "author": "ianwall", "description": "asd", "tags": ["grid"], "likes": 3, "viewed": 110, "published": 3, "date": "1673659071", "time_retrieved": "2024-07-30T18:16:01.722230", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand(float t)\n{\n    return hash11(t);\n}\n\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv + 0.5) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    float t = iTime/5.0;\n\n    float Z = 3.0+5.0*rand(floor(t));\n\n    vec2 uvg = Z*uv;\n\n    uvg = fract(uvg);\n\n    vec2 offset = (uvg-0.5);\n    //float angle = cubicPulse(0.5, 0.2, fract(iTime));\n    float angle = 2.0*3.1415926*smoothstep(0.00, 1.0, fract(t));\n    \n    offset = rotate(offset, angle);\n    offset += 0.5;\n    \n    vec2 uv2 = (floor(Z*uv)+offset)/Z;\n   \n\n    // Output to screen\n    fragColor =  texture(iChannel0, uv2);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 114], [115, 134, 157, 157, 242], [245, 245, 269, 269, 376], [378, 378, 399, 399, 423], [426, 426, 472, 472, 566], [569, 569, 626, 676, 1216]], "test": "untested"}
{"id": "tdVSz1", "name": "Firefly particles", "author": "ianwall", "description": "particles following a random path", "tags": ["lf"], "likes": 1, "viewed": 196, "published": 3, "date": "1673659025", "time_retrieved": "2024-07-30T18:16:02.492172", "image_code": "vec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\n// Source: https://github.com/stegu/webgl-noise/blob/master/src/classicnoise4D.glsl\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\nfloat cnoise4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n    \n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n#define TWO_PI 6.28318530717958647693\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n#define NUM_PART 40U\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tfloat t = fract(0.1*iTime);\n\n    float d = 0.0;\n    for(uint i = 0U; i < NUM_PART; i+=1U)\n    {\n        vec2 s = vec2(0.5);\n        float d0 = cnoise4(vec4(s+541.0*float(i), cos(TWO_PI*t), sin(TWO_PI*t)));\n        float d1 = cnoise4(vec4(s+541.0*float(i), cos(TWO_PI*t), sin(TWO_PI*t))+100.);\n        s += 0.4*vec2(d0, d1);\n        d += 0.5*(1.-smoothstep(0.0, 0.05, length(uv-s)));\n    }\n\n    fragColor = vec4(d, d , d, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 94, 94, 131], [133, 133, 161, 161, 213], [215, 215, 234, 234, 274], [276, 547, 570, 570, 5634], [5675, 5675, 5699, 5742, 5880], [5903, 5903, 5960, 6010, 6485]], "test": "untested"}
{"id": "dtjGRc", "name": "Fractal mosaic 37", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 11, "viewed": 280, "published": 3, "date": "1673657002", "time_retrieved": "2024-07-30T18:16:03.372817", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,.5)\n        //-vec2(1.,.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        vec2 uv1 = uv;\n        uv = (uv+t2)/scale;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        t2 =\n            triangle_wave(uv+.5)\n            //triangle_wave(uv+.5)*sign(.5-uv.x)\n        ;\n        uv = fract(t2+triangle_wave(uv.yx)+.5);\n        col.x =\n            max(max((t2.y+t2.x*sign(uv.x)),abs(uv.y+uv.x))/6.,col.x)\n        ;\n        col =\n            max(abs(col-1.+col.x),col/3.);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n        //if(uv.y < .5) uv.y += .5;\n        //if(uv.x < .5) uv.x += .5;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "//remixed from https://www.shadertoy.com/view/cdXXRB\n\n#define sqmod(x,y) floor(mod(floor(x)/4.,y*y)/y)\n//#define sqmod(x,y) max(floor(mod(floor(x),y*y)/y),mod(floor(x)*floor(x),y))\n//#define sqmod(x,y) max(mod(floor((x)/2.),y),mod(floor((x)*2.),y/2.))\n\n\nvec2 mainSound(int samp, float time){\n float tempo = 1.;\n time /= tempo;\n //time *= (1.+sqmod(time*2.,2.));\n //time /= (1.+sqmod(time*2.,2.));\n \n //time += floor(time*8.+floor(time/8.))/8.;\n\n \n float s1 =\n      4.;\n  \n  float\n  m4 =\n      1.-sqmod(time,2.)\n  ,\n  t=\n      time/(1.+m4)\n  ;\n  //t += floor(t*8.)*8.;\n  float m3 =\n      sqmod(floor(t*s1*2.)+t*(.5-m4)*2.,s1);\n\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + sqmod(t/s1,s1)\n  ;\n  \n  float a = 128.*sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2/(1.+m4),\n\n  nb = time*tempo*pow(2.,(m3+m2)/5.+6.5)*4./(1.+mod(floor(t),s1))/2.;\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //vec2(fract(time*nb*.998*(1.+m4)),fract(time*nb*(1.+m3)))*a\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 151], [153, 153, 210, 210, 1060]], "test": "untested"}
{"id": "mtj3z3", "name": "yet another matrix", "author": "jonasfrey", "description": "yet another matrix\n", "tags": ["matrix"], "likes": 6, "viewed": 246, "published": 3, "date": "1673654242", "time_retrieved": "2024-07-30T18:16:04.152732", "image_code": "vec4 f_o_col_char(vec2 o_trn_fc_nor, vec2 o_char){\n    \n    vec2 o_scl_chars = vec2(16.);\n    vec2 o = (o_trn_fc_nor.xy/o_scl_chars.xy)+vec2(1./16.)*o_char;\n    vec4 o_col = texture(iChannel0, o);\n    return o_col;\n}\n\nfloat f_n_rand(float n){\n    n = n*0.338;\n    n = n+n;\n    n = sin(n*231.234)*1223.23;\n    return fract(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n\n    float n = 40.; \n    vec2 o_tres  = vec2(n*n_ratio_x_to_y, n);//target resolution\n    vec2 o_scl_tres = o_tres / iResolution.xy;\n    vec2 o_ires = iResolution.xy * o_scl_tres;\n    vec2 o_fc = fragCoord.xy * o_scl_tres.xy;\n    //o_fc += iTime;\n    float n_idx_fc = (floor(o_fc.x) + floor(o_fc.y)*floor(o_tres.x));// index\n    float n_idx_fc_nor = n_idx_fc / floor(o_tres.x*o_tres.y);\n    \n    float n_ratio_1to_iresx = 1./ o_ires.x;//we can make a lowres AA\n    float n_ratio_1to_iresolutionx = 1./ iResolution.x;//we need the real resolution for AA\n    //needed for anti aliasing ?\n    \n    float n_speed_max = 10.;\n    float n_speed_min = 5.;\n    float n_random_per_x = f_n_rand(floor(o_fc.x));\n    o_fc.y += iTime*(n_random_per_x*n_speed_max+n_speed_min);\n    vec2 o_trn_fc_nor = o_fc.xy / o_ires.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n        \n        \n    vec2 o_scl_letters = vec2(16.,16.);\n\n    vec2 o_trn_char = vec2(\n        f_n_rand(floor(o_fc.x))*o_scl_letters.x, \n        f_n_rand(floor(o_fc.y))*o_scl_letters.y\n    );\n    float b_showx = float(n_random_per_x > 0.5);\n    float b_showy = float(f_n_rand(floor(o_fc.y)));\n    \n    vec4 o_col_char = f_o_col_char(fract(o_fc), floor(o_trn_char));\n\n    o_col_char *= b_showy;\n    fragColor = o_col_char.xxxx*vec4(0., 1.,0.,1.);\n    \n    //fragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).r);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 216], [218, 218, 242, 242, 327], [329, 329, 386, 386, 2015]], "test": "untested"}
{"id": "dt23R3", "name": "pixel index", "author": "jonasfrey", "description": "if we have a resolution r and a pixel p\nthe index of a pixel  of a given point can be calculated with \np.x + p.y*r.x \n", "tags": ["pixelindex"], "likes": 2, "viewed": 199, "published": 3, "date": "1673648462", "time_retrieved": "2024-07-30T18:16:04.922673", "image_code": "vec2 _0 = vec2(0.,12.);\nvec2 _1 = vec2(1.,12.);\nvec2 _2 = vec2(2.,12.);\nvec2 _3 = vec2(3.,12.);\nvec2 _4 = vec2(4.,12.);\nvec2 _5 = vec2(5.,12.);\nvec2 _6 = vec2(6.,12.);\nvec2 _7 = vec2(7.,12.);\nvec2 _8 = vec2(8.,12.);\nvec2 _9 = vec2(9.,12.);\nvec2 _cln = vec2(10.,12.);\nvec2 _scln = vec2(11.,12.);\n\n\nint f_n_numofdigits(float n)\n{\n    //log10(x) = log(x) / log(10) = (1 / log(10)) * log(x)\n    if(abs(n) == 0.){\n        return 1;\n    }\n    if(abs(n) == 10.){\n        return 2;\n    }\n    return int(floor((1. / log(10.)) * log(n) +1.));\n    \n} \nint f_n_digit(int number, int n_index) {  \n    int n_numofdigits = f_n_numofdigits(float(number));\n    n_index = (n_numofdigits-1) - n_index;\n   return int((floor(float(number)/pow(10.0,float(n_index))))) % 10; \n} \n\nvec4 f_o_col_char(vec2 o_trn_fc_nor, vec2 o_char){\n    \n    vec2 o_scl_chars = vec2(16.);\n    vec2 o = (o_trn_fc_nor.xy/o_scl_chars.xy)+vec2(1./16.)*o_char;\n    vec4 o_col = texture(iChannel0, o);\n    return o_col;\n}\nvec4 f_o_col_num(vec2 o_trn_fc_nor, int n){\n    \n\n    vec2 o_p_start = vec2(0.,12.);\n\n    float n_numofdigits = float(f_n_numofdigits(float(n)));\n    \n    vec2 o = o_trn_fc_nor * vec2(n_numofdigits, 1.);\n    \n    float n_idx_digit = floor(o_trn_fc_nor.x / (1. / n_numofdigits));\n    \n    int n_digit = f_n_digit(int(n), int(n_idx_digit));\n    \n    return f_o_col_char(fract(o), o_p_start+vec2(float(n_digit), 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_tres  = vec2(16,16);//target resolution\n    vec2 o_scl_tres = o_tres / iResolution.xy;\n    vec2 o_ires = iResolution.xy * o_scl_tres;\n    vec2 o_fc = fragCoord.xy * o_scl_tres.xy;\n\n    float n_idx_fc = (floor(o_fc.x) + floor(o_fc.y)*floor(o_tres.x));// index\n    float n_idx_fc_nor = n_idx_fc / floor(o_tres.x*o_tres.y);\n    \n    float n_ratio_1to_iresx = 1./ o_ires.x;//we can make a lowres AA\n    float n_ratio_1to_iresolutionx = 1./ iResolution.x;//we need the real resolution for AA\n    //needed for anti aliasing ?\n    \n    vec2 o_trn_fc_nor = o_fc.xy / o_ires.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    \n    vec2 o_fcfract = fract(o_fc);\n    float n_dist_border_x = abs(o_fcfract.x-0.5);\n    float n_dist_border_y = abs(o_fcfract.y-0.5);\n    float n_dist_border = max(n_dist_border_x,n_dist_border_y);\n    float n_size = 0.5 - (1./o_tres.x)*0.5;\n    float n_aa = n_ratio_1to_iresolutionx*20.;\n    n_dist_border = smoothstep(n_size, n_size+n_aa, n_dist_border);\n    \n       \n    vec4 o_col = texture(iChannel0, o_fc);\n    \n    o_col = f_o_col_num(fract(o_fc), int(n_idx_fc));\n\n    o_col = o_col.xxxx;\n    o_col += n_dist_border;\n    \n    float b_oddf = float(mod((n_idx_fc),2.) == 0.);\n    float b_oddt = 1.-b_oddf;\n    float n_invf = 1.*n_idx_fc_nor;\n    float n_invt = 1.- n_invf;\n    o_col = \n        o_col * vec4(n_invf*b_oddf+n_invt*b_oddt, 0.5, n_invf*b_oddt+n_invt*b_oddf ,  1.);\n\n    fragColor = vec4(o_col);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt23R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 327, 386, 539], [541, 541, 581, 581, 754], [757, 757, 807, 807, 973], [974, 974, 1017, 1017, 1390], [1392, 1392, 1449, 1449, 3138]], "test": "untested"}
{"id": "ml2GR3", "name": "A tragic green attempt", "author": "Hodisfut", "description": "I wanted to make a cube", "tags": ["green"], "likes": 3, "viewed": 173, "published": 3, "date": "1673638114", "time_retrieved": "2024-07-30T18:16:05.688625", "image_code": "#define PI 3.14159265358979323846\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    vec3 res = v;\n    res = res - dot(res, axis) * axis;\n    res = res * cos(angle) + cross(axis, res) * sin(angle) + axis * dot(axis, res) * (1.0 - cos(angle));\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.y) * 2.0 - 1.0;\n    vec3 r = vec3(p,0);\n    vec3 ro = vec3(0,0,0);\n    vec3 ta = vec3(0,0,0);\n    float d = 0.0;\n    vec3 c = vec3(0);\n    float an = iTime*2.;\n    mat2 m2 = mat2(cos(an),-sin(an),sin(an),cos(an));\n    mat3 m3 = mat3(cos(an),-sin(an),0,sin(an),cos(an),0,0,0,1);\n\n    // apply random rotation to the object\n    float random_rotation = fract(sin(iTime) * 12.9898);\n    vec3 random_axis = vec3(fract(sin(iTime) * 43758.5453), fract(cos(iTime) * 4376.5453), fract(sin(iTime + 1.0) * 43758.5453));\n    r = rotate(r, normalize(random_axis), random_rotation * PI * 2.);\n\n    for(int i=0;i<3;i++)\n    {\n        r = m3 * r;\n        d = dot(r,r);\n        if(d<0.05)\n        {\n            c = vec3(0,1,0);\n            break;\n        }\n    }\n    // apply linear dim green light\n    vec3 light = normalize(vec3(0,1,1));\n    float diffuse = dot(normalize(r), light);\n    diffuse = pow(diffuse, 2.);\n    fragColor = vec4(c*diffuse, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 80, 80, 260], [262, 262, 319, 319, 1299]], "test": "untested"}
{"id": "DlBGR3", "name": "Myst Book", "author": "kishimisu", "description": "A tribute to the masterpiece that made me fall in love with open world puzzle games.", "tags": ["2d", "retro", "drawing", "world", "tribute", "exile", "pages", "riven", "age"], "likes": 33, "viewed": 570, "published": 3, "date": "1673630563", "time_retrieved": "2024-07-30T18:16:06.723857", "image_code": "/* \"Myst Book\" by @kishimisu (2023) - https://www.shadertoy.com/view/DlBGR3\n    \n    A tribute to one of my favorite video games\n    https://learn.sparkfun.com/tutorials/myst-linking-book/the-dni-and-the-art-\n    \n    This shader is made in the Image tab and displays the content \n    of Buffer A, so you can input your own scenes inside the \n    Buffer A tab to be displayed inside the book !\n    \n    This retro style fits the Myst series but I'd love to make\n    a more realistic and animated 3D version someday\n*/\n\n#define WORLD_ZOOM 1.1 // Zoom level on the Buffer A texture\n\n// Distance functions - https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdOBox( in vec2 p, in vec2 a, in vec2 b, float th ) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// 2D noise value & fbm - https://www.shadertoy.com/view/lsf3WH\nfloat hash_(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise_( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash_( i + vec2(0.0,0.0) ), hash_( i + vec2(1.0,0.0) ), u.x),\n                mix( hash_( i + vec2(0.0,1.0) ), hash_( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm_(vec2 p) {\n    float f = 1.0, a = 1.0, t = noise_(p);\n    for(int i=1; i<6; i++) {\n        t += a*noise_(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat sdMyst(vec2 u) {\n    const float sm = 0., lg = 0.03;\n    \n    u += vec2(.9, -.15);\n    float M =  sdOBox(u, vec2(0)   , vec2(.0, .2), sm);\n    M = min(M, sdOBox(u, vec2(.104,.03), vec2(.0, .2), lg));\n    M = min(M, sdOBox(u, vec2(.1,.01), vec2(.2, .2), sm));\n    M = min(M, sdOBox(u, vec2(.2,0), vec2(.2, .2), lg));\n    \n    u.x -= .26;\n    float Y =  sdOBox(u, vec2(.075, .1), vec2(0, .2),   lg);\n    Y = min(Y, sdOBox(u, vec2(.075, .1), vec2(.075, 0), lg));\n    Y = min(Y, sdOBox(u, vec2(.075, .1), vec2(.15, .2), sm));\n    \n    u.x -= .26;\n    float S = sdOBox(u + vec2(sin(u.y*30.+3.14)*.06,0), vec2(0), vec2(0, .2), lg);\n    \n    u.x -= .18;\n    float T =  sdOBox(u, vec2(0), vec2(0, .2), lg);\n    T = min(T, sdOBox(u, vec2(-.09, .2), vec2(.09, .2), sm));\n    \n    return min(min(min(M, Y), S), T);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    vec2 R = iResolution.xy, u = (2.*F-R)/R.y*.95;\n    vec3 col;\n     \n    // bottom pages\n    float m = 0., att = 1.;\n    for (float i = 0.; i < 9.; i++) {\n        float rr = abs(u.x) + fbm_(u*10.+i)*(i==0.?4.:2.)*.005 - i*.008 - 1.08;\n        if (rr > 0.) {\n            att *= .9-i*.007 - .5*smoothstep(.04, -.08, rr);\n            m = i+1.;\n        }\n    }\n    \n    float r0 = fbm_(u*5.+m*.2);\n    float r1 = fbm_(u*10.);\n    float rt = fbm_(u*10.+iTime*.4);\n    float r2 = fbm_(u*20.+iTime*.2);  \n    \n    if (u.x > 0.) {\n        // right page\n        col = mix(vec3(0.898,0.843,0.804), vec3(0.824,0.706,0.455), abs(u.x*1.2 - .95) + r0*.2 + r0*smoothstep(0.04, .4, sdBox(u, vec2(1.14, .82)*.7)));\n        col = mix(vec3(0.549,0.388,0.106), col, smoothstep(0., .8, u.x+.2));\n        col *= smoothstep(0., .2+ r0*.1, u.x)*.3+.7;\n        \n        // world portal\n        const vec2 offs = vec2(.55, .2);\n        const vec2 dims = vec2(.37, .27);\n        \n        if (abs(u.x - offs.x) < dims.x + .1 && abs(u.y - offs.y) < dims.y + .1) {\n            float world = -sdBox(u - offs, dims);\n            vec2 uv = (F/R-.5 - vec2(offs.x*R.y/R.x, offs.y)*.5)*WORLD_ZOOM + .5;\n            vec3 wcol = texture(iChannel0, uv).rgb;\n            \n            col *= smoothstep(-.01, .015, abs(world + r2*.015))*.4+.6;\n            col *= smoothstep(.1, .0, world + r2*.02);\n            col = mix(col, wcol, .8*smoothstep(0., .02, world + r2*.02));        \n        }\n    } else {\n        // left page\n        col = mix(vec3(0.796,0.678,0.471), vec3(0.855,0.753,0.631), -sin(u.x*5.5)+sin(u.x*10.)*.2 - r0*.3 - r0*smoothstep(0.04, .3, sdBox(u, vec2(1.14, .82)*.7)));\n        col *= smoothstep(-.1, .2+ r0*.05, -u.x)*.4+.6;\n        \n        // myst text\n        float myst = sdMyst(u);\n        col *= smoothstep(-.01, .035, myst+ rt*.005)*.5+.5;\n        myst = smoothstep(0., .026, myst + r1*.006);\n        col = mix(vec3(0.443,0.314,0.137)*rt, col, myst);\n    }\n    \n    // middle occlusion (this tiny shade really adds a lot to the depth)\n    col *= clamp(pow(abs(u.x)*4., .1), 0., 1.);\n        \n    // bottom pages\n    col *= att;\n     \n    // bottom cover\n    float book = sdBox(u, vec2(1.16, .85));\n    float corners = smoothstep(0.35, .4, abs(abs(abs(u.x)-.2) - abs(u.y)));\n    vec3  bcol = mix(vec3(0.910,0.776,0.412), vec3(0.361,0.208,0.180), corners+r1*.3-.3);\n    bcol *= smoothstep(0., .05, book + r1*.01)*.5+.4;\n    col = mix(col, bcol, smoothstep(0., .01, book + r1*.012));\n    \n    // background\n    float bg = -sdBox(u, vec2(1.23, .9)*.97);\n    vec3 bgcol = texture(iChannel1, F/R).rgb;\n    bgcol *= smoothstep(0.01, 0.1, -bg + r1*.005)*.65+.35;\n    col = mix(bgcol, col, smoothstep(0., .008, bg + r1*.005));\n            \n    O.rgb = col;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Low-res version of my shader \"Aldebaran's Sanctuary\"\n   (https://www.shadertoy.com/view/cslXRs)\n   \n   Replace with any shader code ! */\n\n\n#define ALTERNATE_VIEWS 1 // Set to 0 to prevent camera from switching viewpoints\n\n#define MAX_ITERATIONS 50.\n#define MAX_DISTANCE   40.\n#define EPSILON        .001\n\n#define FBM_LAYERS  4\n#define SHADOW_FBM_LAYERS 3\n#define RELAXATION  2.\n\n#define VOLUME_STEPS    15.\n#define VOLUME_DENSITY  .8\n#define VOLUME_LIGHT    0.6\n\n#define sunCycle (sin(iTime*.4)*.5+.5)\n#define sunColor vec3(1.2,0.671,0.376)*(sunCycle*.9+.15)\n#define skyColor vec3(0.604,0.784,0.976)*(sunCycle*.9+.15)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define treeRep 24.\n\n// Value noise - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://shadertoyunofficial.wordpress.com/2019/01/02/\nvec3 hash33(vec3 p) {\n    return fract(cos((p)*mat3(127.1,311.7,74.7,269.5,183.3,246.1,113.5,271.9,124.6))*43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://www.shadertoy.com/view/3ddGzn\nfloat noise3(vec3 p) {\n\tvec3 ip=floor(p), s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp-=ip; p=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm3(vec3 p) { \n    p += vec3(iTime*.1, iTime*.1, 0.);\n    float f = 1.0, a = 1.0,\n          t = noise3(p);\n    for(int i=1; i<5; i++) {\n        t += a*noise3(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat fastnoise2(vec2 p) {\n    return (sin(p.x)-cos(p.y))*.5+.5;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p) {\n    const vec2 c = vec2(0.198669, 0.980067);\n    vec2   q = vec2( length(p.xz), -p.y );\n    float  d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0) - .1;\n}\nfloat sdArc( in vec2 p, in float ra, float rb ) {\n    const vec2 sc = vec2(0.808496, -0.588501);\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\nfloat sdCircle(vec2 p, float ra, float rb) {\n    return abs(length(p) - ra) - rb;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad)  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// Smarter fbm calculation - https://www.shadertoy.com/view/msXSR2\nfloat fbm(vec2 p, float h, int layers) {\n    float n = fastnoise2(p); \n    float a = 1.;\n    \n    for (int i = 0; i < layers; i++) {\n        if (h > n + a) break;\n        \n        p *= 2.; a *= .5;\n   \n        n -= a*abs(fastnoise2(p)-n);\n      \n    } \n    \n    return n;\n}\n\nfloat terrainH(vec3 p, int layers) {    \n    float mnt =  smoothstep(0., 1., -sdArc(vec2(p.z, -p.x - 4.), 6. , 1.));\n    mnt += 2.2 * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 22., 5.)); \n    mnt += 4.  * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 36., 5.));         \n    return fbm(p.xz*.5, p.y - mnt, layers) + mnt;\n}\n\nvec2 map(vec3 p, int layers, inout vec3 light) {\n    float l = length(p.xz);\n    // Terrain\n    float ground = 1e6;\n    if (p.y < 5.) {\n        float terrain = terrainH(p, layers);\n        ground  = p.y - terrain;\n    }\n    \n    // Trees\n    float trees = 1e6;\n    if (ground < 1.) {\n        float sm  = smoothstep(5.5, 6., l);\n        float rep = mix(treeRep, 10., sm);\n        vec3  fp  = fract(p*rep)-.5; \n        vec3  id  = floor(p*rep)+.5;\n        vec3  r   = hash32(id.xz);\n        float fh  = fbm(id.xz*.5/rep, p.y-.1, layers); \n\n        float h  = 3. + r.y*sm*.4;\n        vec3 off = vec3(1.,0.,1.)*r*.4*sm;\n        fp.y = (p.y - fh) * rep - h;\n        trees = (sdCone(fp - off) + smoothstep(.5, .9, noise2(p.xz))) / rep;  \n    }\n    \n    // Structures\n    float shape = 1e6, cables = 1e6;\n    if (l < 12.) {\n        vec3  sp  = p;\n        float an  = 6.283185 / 16.;\n        float aid = (round((atan(p.z, p.x)-an/2.)/an)*an)+an/2.;\n        vec3  rs  = hash31(aid);\n        sp.xz *= rot(-aid);\n\n        shape = sdBox(sp - vec3(8.5,0,0), vec3(.3,3.,.45));\n        float hole  = sdBox(sp - vec3(8.5,1.8,0), vec3(.35, .9, .3));\n        shape = smax(shape, -hole, .1);\n\n        float center = length(p+vec3(0,.2,0))-.35;\n        float doors = sdBox(sp + vec3(0,.2,0), vec3(.4, .25*(sin(iTime*.1)*.5+.5), .04));\n        center = smax(center, - doors, .03);\n        center = min(center, sdCylinder(sp - vec3(1,-.5,0), .04, .5+rs.z*.2 + sin(.2*iTime+aid*10.)*.06));\n        shape  = min(shape, center) - .01;\n\n        // These aren't real objects, their signed distance is always strictly positive. It's only\n        // captured in lighting as it increases the iteration count near these phantom cables.\n        sp.z = abs(sp.z);\n        cables = sdCapsule(sp, vec3(1,0,0), vec3(9,3,.4), -.01-smoothstep(0.4, 0.6, sunCycle));\n\n        // Lighting\n        vec3 lc = 0.06 * (vec3(.7,.7,1.) - rs*.2);\n        light += lc / (1. + pow(abs(hole), 1.4));\n        light += 1.5*lc * vec3(0.447,0.118,0.600) / (1. + pow(abs(center*5.), 1.4));\n        light += 1.5*lc * vec3(0.118,0.600,0.522) / (1. + pow(abs(doors*5.), 1.4));\n    }\n    \n    vec2 res = vec2(ground, 0.);\n    if (trees < res.x) res = vec2(trees, 1.);\n    if (shape < res.x) res = vec2(shape, 2.);\n    if (cables < res.x) res = vec2(cables,3.);\n    \n    return res; \n}\n\nvec3 ltmp;\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy, FBM_LAYERS,ltmp).x + e.yyx*map(p + e.yyx, FBM_LAYERS,ltmp).x + \n\t\t\t\t\t e.yxy*map(p + e.yxy, FBM_LAYERS,ltmp).x + e.xxx*map(p + e.xxx, FBM_LAYERS,ltmp).x);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.1, res = 1., k = 10.;\n    for (float i = 0.; i < MAX_ITERATIONS*.7; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, SHADOW_FBM_LAYERS,ltmp).x;\n        res = min(res, k*d/t);\n        t += d;\n        if (t > maxt) return res;\n        if (d < EPSILON) return 0.;\n    }\n    return 0.;\n}\n\nvec3 volumeColor(vec3 ro, vec3 rd, float near, float far, vec3 sunDir, vec3 col) {\n    vec3 vcol  = vec3(0.);\n    float mask = 1.;\n    float vstep = (far - near) / VOLUME_STEPS;\n    const float dh = 1./VOLUME_DENSITY;\n\n    for (float t = near, i = 0.; t <= far && i < VOLUME_STEPS; t += vstep, i++) {\n        vec3 p = ro + t*rd;\n        \n        float dens = fbm3(p/6.);\n        dens = smoothstep(dh, dh+1., dens);\n\n        float prev = mask;\n        mask *= exp(-dens * vstep * .3);\n        float absorbed = prev - mask;\n        \n        vec3 light = 1.5-vec3(smoothstep(dh, dh+.6, fbm3((p-sunDir*.1)/6.)));\n        vcol += vec3(.9,1.,.7) * sunColor * absorbed * vstep * light * VOLUME_LIGHT;          \n    }\n    \n    return col*mask + min(vcol, vec3(1.));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy*2.-1.; \n    float t = iTime*.1, tt = 0.;\n    ro = vec3(0., -.1 + cos(t*1.1)*.1, 3. + sin(t*1.2)*.3);\n#if ALTERNATE_VIEWS\n    tt = step(20., mod(iTime, 35.)); \n#endif\n    ro.yz *= rot(cos(t*1.15)*.05-mix(.5, .1, tt));\n    ro.zx *= rot(sin(t)*.3-mix(-1.2, 1.2, tt)); \n    vec3 f = normalize(vec3(cos(t)*.01,.5+cos(t)*.02,sin(t)*.015)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    \n    // Scale down\n    uv *= 2.5;\n    if (abs(uv.x) > iResolution.x/iResolution.y || abs(uv.y) > 1.) {\n        O*=0.;\n        return;\n    }\n    \n    vec2 res;\n    vec3 ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    bool hitWater = false;\n    float t   = 0., i;\n    vec3  p   = ro, \n        col   = skyColor, \n      light   = vec3(0.);  \n        \n    for (i = 0.; i < MAX_ITERATIONS; i++) {\n        res = map(p, hitWater ? 5 : FBM_LAYERS, light);\n        \n        if (p.y < -.33) {\n            // Reflect if ray hit water level\n            p.y += 2.*abs(p.y+.33);\n            rd.y = -rd.y;\n            rd = normalize(rd + (noise2(p.xz*80.+iTime*.2)-.5)*.06);\n            hitWater = true;\n        }\n        \n        float d = res.x > 0. ? res.x*.9 : res.x*.3;\n        t += d;\n        p += rd * d;\n\n        if (res.x < EPSILON*(1. + t*RELAXATION) || t > MAX_DISTANCE) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = -0.00 * 3.14 + 1.27 + (1.-sunCycle)*.2;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n    \n    if (t < MAX_DISTANCE) {\n        // Hit object\n        float th = terrainH(p, FBM_LAYERS);\n        vec3  id = floor(p*treeRep)+.5;\n        vec3   r = hash32(id.xz);\n        vec3   n = getNormal(p - rd*EPSILON*4., t);\n        float sunLight    = max(.1, dot(n, lightDir));\n        float sunShadow   = max(.02, getShadow(p + n*EPSILON*4., lightDir, MAX_DISTANCE));\n        float skyLight    = max(.0, n.y);\n        float bounceLight = max(.0, dot(n, -lightDir));\n        float spec        = max(.0, dot((rd + n)/2., lightDir));\n\n        if (res.y == 0.) {\n            // Terrain\n            col = vec3(1.);\n            col *= .4+smoothstep(.55, .7, skyLight );\n            col *= .05 + 1.*sunColor * sunLight * sunShadow;\n        } else if (res.y == 1.) {\n            // Trees\n            col = mix(\n                vec3(.2,.6 + (r.y-.5)*.5,.4)*.25, \n                vec3(1.)   + (r.x-.5)*.5, \n                smoothstep(0., .13, p.y - th + t * .0) \n            );\n            col *= .25*(sunCycle+.1) + 1.*sunColor * sunLight * sunShadow;  \n        } else {\n            // Structures\n            col = 1. - texture(iChannel1, p.xy*4.).rrr*.4;\n            col *= .2 + 1.*sunColor * sunLight * sunShadow;\n        }\n        \n        col *= smoothstep(.2, .4, length(p + vec3(0,.2,0)));\n\n        col += 0.2*skyColor * skyLight;\n        col += 0.1*vec3(.4,.2,0.) * bounceLight;\n        col += 1.5*pow(spec, 4.)*sunCycle;\n    } \n    \n    // Clouds\n    vec2 hit = boxIntersection(ro - vec3(0, 8, 0), rd, vec3(200., 4., 200.));\n    if (hit.x >= 0. && hit.x < t) {\n        col = volumeColor(ro, rd, hit.x, min(hit.y, t), lightDir, col);\n        t = min(hit.x, t);\n    }\n    \n    // Water occlusion\n    if (hitWater) col *= vec3(.7,.7,.9);\n    col *= mix(0.4, 1., smoothstep(-.35, -.25, p.y));\n    \n    // Apply fog\n    vec3 fog = exp2(-t*0.07*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - vec3(1.,1.5,2.)*abs(rd.y)*.3, vec3(0.), vec3(1.)), col, fog);   \n    \n    // Color adjust\n    col = pow(col, vec3(.99,.88,.95));\n    col = smoothstep(vec3(0.04), vec3(1), col);\n    col = pow(col, vec3(.4545));\n    \n    // Night lighting\n    col += light * smoothstep(.8, 0., sunCycle);\n           \n    // Accumulate frames\n    vec3 ocol = texelFetch( iChannel0, ivec2(F-0.5), 0 ).xyz;\n    if(iFrame==0) ocol = col;\n    col = mix(ocol, col, 1./10.);\n    \n    O = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 654, 691, 691, 771], [772, 772, 831, 831, 1048], [1050, 1114, 1135, 1135, 1230], [1231, 1231, 1258, 1258, 1509], [1510, 1510, 1530, 1530, 1679], [1681, 1681, 1703, 1703, 2492], [2494, 2494, 2535, 2535, 5273]], "test": "untested"}
{"id": "dtB3z3", "name": "Temple Anaglyph", "author": "FifthStateOfMatter", "description": "Was actually surprisingly easy.", "tags": ["3d", "raymarching", "anaglyph"], "likes": 6, "viewed": 170, "published": 3, "date": "1673604742", "time_retrieved": "2024-07-30T18:16:07.544663", "image_code": "//Takes 5 seconds on average to compile, then runs at a steady 60+ FPS for me.\nconst float eyeDist = 0.5;\nconst bool delag = false;\n\n//Light, neutral colors seem to work best.\nconst vec3 fogColor = vec3(0.8);\n\n//The smaller the number, the less reflective the surface.\nconst float reflectiveness = 0.3;\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat perlinNoise(vec3 p){\n    vec3 cellPos = floor(p);\n    vec3 cellFract = fract(p);\n    vec3 cellMix = cellFract*cellFract*(3.0 - 2.0*cellFract);\n    float value;\n\n    vec3 blf = vec3(random3((cellPos + vec3(0, 0, 0))*1.0));\n    vec3 brf = vec3(random3((cellPos + vec3(1, 0, 0))*1.0));\n    vec3 trf = vec3(random3((cellPos + vec3(1, 1, 0))*1.0));\n    vec3 tlf = vec3(random3((cellPos + vec3(0, 1, 0))*1.0));\n\n    vec3 blb = vec3(random3((cellPos + vec3(0, 0, 1))*1.0));\n    vec3 brb = vec3(random3((cellPos + vec3(1, 0, 1))*1.0));\n    vec3 trb = vec3(random3((cellPos + vec3(1, 1, 1))*1.0));\n    vec3 tlb = vec3(random3((cellPos + vec3(0, 1, 1))*1.0));\n\n    value = mix(\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 0), blf), dot(cellFract - vec3(1, 0, 0), brf), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 0), tlf), dot(cellFract - vec3(1, 1, 0), trf), cellMix.x),\n            cellMix.y\n        ),\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 1), blb), dot(cellFract - vec3(1, 0, 1), brb), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 1), tlb), dot(cellFract - vec3(1, 1, 1), trb), cellMix.x),\n            cellMix.y\n        ),\n        cellMix.z\n    );\n    //Should I have to add 0.5 to this? I would think not but it looks weird otherwise.\n    return value;\n}\n\nstruct material{\n    vec3 col;\n    int type;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nSDF sphereSDF(vec3 p, float r, material mat){\n    return SDF(length(p) - r, mat);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF infiniteSpherePatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphereSDF(q, 0.25, mat);\n}\n\nSDF infiniteBoxPatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return boxSDF(q, vec3(0.25), mat);\n}\n\nSDF yPlaneSDF(vec3 p, float y, material mat){\n    return SDF(p.y - y, mat);\n}\n\nSDF cylinderSDF(vec3 p, float h, float r, material mat){\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return SDF(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), mat);\n}\n\nSDF finiteCylinderPatternSDF(in vec3 p, in float c, in vec3 l, material mat){\n    vec3 q = p - c*clamp(round(p/c), -l, l);\n    return cylinderSDF(q, 2.0, 0.4, mat);\n}\n\n//https://www.shadertoy.com/view/Nld3DB\nSDF triPrismSDF(vec3 p, vec3 s, material mat){\n    p.x = abs(p.x);\n    p.xy -= vec2(s.x, -s.y);\n    vec2 e = vec2(-s.x, s.y*2.0);\n    vec2 se = p.xy - e*clamp(dot(p.xy, e)/dot(e, e), 0.0, 1.0);\n    float d1 = length(se);\n    if(max(se.x, se.y) < 0.0){\n        d1 = -min(d1, p.y);\n    }\n    float d2 = abs(p.z) - s.z;\n    return SDF(length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0), mat);\n}\n\nSDF sceneSDF(vec3 p){\n    float xr = 0.0;\n    float yr = iTime*0.3 + (3.1415926535/4.0)*1.0;\n    \n    float sxr = sin(xr);\n    float syr = sin(yr);\n    float cxr = cos(xr);\n    float cyr = cos(yr);\n    \n    mat3 xRot;\n    xRot[0] = vec3(1, 0, 0);\n    xRot[1] = vec3(0, cxr, -sxr);\n    xRot[2] = vec3(0, sxr, cxr);\n    \n    mat3 yRot;\n    yRot[0] = vec3(cyr, 0, -syr);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(syr, 0, cyr);\n    \n    //SDF ground = yPlaneSDF(p, -1.5, material(vec3(1), 1));\n    //ground.dist -= perlinNoise((p - vec3(0, 0, 10))*yRot)*0.15;\n    //SDF s1 = infiniteSpherePatternSDF(p - vec3(0), vec3(2, 0, 2), material(vec3(1), 0));\n    //SDF s1 = sphereSDF(p - vec3(sin(iTime*0.5)*3.0, 0, cos(iTime*0.5)*3.0 + 5.0), 0.25, material(vec3(1), 0));\n    //SDF b1 = infiniteBoxPatternSDF((p - vec3(0, 0, 0))*xRot*yRot, vec3(2), material(vec3(0, 1, 0), 0));\n    //SDF b1 = boxSDF((p - vec3(0, 0, 5))*yRot*xRot, vec3(0.5, 2, 0.5), material(vec3(0, 0, 0.5), 0));\n    SDF pillars = finiteCylinderPatternSDF((p - vec3(0, 0, 10))*yRot, 2.0, vec3(2, 0, 2), material(vec3(0.6), 0));\n    SDF base1 = boxSDF((p - vec3(0, -1.0, 10))*yRot, vec3(4.5, 0.25, 4.5), material(vec3(0.6), 0));\n    SDF base2 = boxSDF((p - vec3(0, -1.55, 10))*yRot, vec3(5, 0.5, 5), material(vec3(0.6), 0));\n    SDF roof1 = boxSDF((p - vec3(0, 2.0, 10))*yRot, vec3(4.75, 0.25, 4.75), material(vec3(0.6), 0));\n    SDF roof2 = triPrismSDF((p - vec3(0, 3.25, 10))*yRot, vec3(4.75, 1.0, 4.75), material(vec3(0.6), 0));\n    SDF inter = boxSDF((p - vec3(0, 0, 10))*yRot, vec3(4.4, 2.0, 2.75), material(vec3(0.6), 0));\n    float closest = min(/*ground.dist, min(*/pillars.dist, min(base1.dist, min(base2.dist, min(roof1.dist, min(roof2.dist, inter.dist)))))/*)*/;\n    if(closest == base1.dist){\n        return base1;\n    }else if(closest == base2.dist){\n        return base2;\n    }else if(closest == pillars.dist){\n        return pillars;\n    }else if(closest == roof1.dist){\n        return roof1;\n    }else if(closest == roof2.dist){\n        return roof2;\n    }else/* if(closest == inter.dist)*/{\n        return inter;\n    }/*else{\n        return ground;\n    }*/\n    //return b1;\n}\n\nbool raymarch(vec3 o, vec3 d, out float t, out material mat, int ms, float eps){\n    t = 0.0;\n    for(int i = 0; i < ms && t < 30.0; i++){\n        SDF s = sceneSDF(o + d*t);\n        t += s.dist;\n        if(s.dist < eps && t >= 0.0){\n            //Gets rid of some strange artifacts\n            t -= s.dist;\n            \n            mat = s.mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormal(vec3 h){\n    return normalize(vec3(\n        sceneSDF(vec3(h.x + 0.01, h.yz)).dist - sceneSDF(vec3(h.x - 0.01, h.yz)).dist,\n        sceneSDF(vec3(h.x, h.y + 0.01, h.z)).dist - sceneSDF(vec3(h.x, h.y - 0.01, h.z)).dist,\n        sceneSDF(vec3(h.xy, h.z + 0.01)).dist - sceneSDF(vec3(h.xy, h.z - 0.01)).dist\n    ));\n}\n\nfloat getLighting(vec3 h, vec3 lpos){\n    vec3 n = getNormal(h);\n    vec3 lRay = normalize(lpos - h);\n    float c = dot(n, lRay);\n    float lt;\n    material mat;\n    bool rl = raymarch(h + n*0.01, lRay, lt, mat, 30, 0.001);\n\n    if(rl){\n        c -= 0.4;\n    }else{\n        c = dot(n, lRay);\n    }\n    return c;\n}\n\nvec3 reflectRay(vec3 h, vec3 d){\n    vec3 n = getNormal(h);\n    return d - 2.0*n*dot(n, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 lPos = vec3(10, 10, -10.0 + iTime*0.0);\n    vec3 o = vec3(0, 0.6, iTime*0.0 - 3.0);\n    vec3 d = normalize(vec3(uv, 1));\n    //https://www.shadertoy.com/view/XslGWn{\n    bool red = mod(fragCoord.xy.x, 2.0) > 0.5;\n    mod(fragCoord.xy.y, 2.0) > 0.5 ? red = !red : red = red;\n    //}\n    \n    if(delag){\n        if(red){\n            float tl;\n            material matl;\n            vec3 ol = o - vec3(eyeDist/2.0, 0, 0);\n            bool rl = raymarch(ol, d, tl, matl, 100, 0.01);\n\n            if(rl){\n                float cl = getLighting(ol + d*tl, lPos);\n                if(matl.type != 1){\n                    float rtl;\n                    material rmatl;\n                    bool rrl = raymarch(ol + d*tl + getNormal(ol + d*tl)*0.01, normalize(reflectRay(ol + d*tl, d)), rtl, rmatl, 30, 0.01);\n                    if(rrl){\n                        float rcl = getLighting(ol + d*tl + getNormal(ol + d*tl)*0.01 + normalize(reflectRay(ol + d*tl, d))*rtl, lPos);\n                        col.r += mix(\n                            mix(matl.col.r, rmatl.col.r*max(rcl, 0.1), reflectiveness)*max(cl, 0.1),\n                            fogColor.r,\n                            min(tl/20.0, 1.0)\n                        );\n                    }else{\n                        col.r += mix(\n                            mix(matl.col.r, 1.0, reflectiveness)*max(cl, 0.1),\n                            fogColor.r,\n                            min(tl/20.0, 1.0)\n                        );\n                    }\n                }else{\n                    col.r += mix(matl.col.r*max(cl, 0.1), fogColor.r, min(tl/20.0, 1.0));\n                }\n            }else{\n                col.r = fogColor.r;\n            }\n        }else{\n            float tr;\n            material matr;\n            vec3 or = o + vec3(eyeDist/2.0, 0, 0);\n            bool rr = raymarch(or, d, tr, matr, 100, 0.01);\n\n            if(rr){\n                float cr = getLighting(or + d*tr, lPos);\n                if(matr.type != 1){\n                    float rtr;\n                    material rmatr;\n                    bool rrr = raymarch(or + d*tr + getNormal(or + d*tr)*0.01, normalize(reflectRay(or + d*tr, d)), rtr, rmatr, 30, 0.01);\n                    if(rrr){\n                        float rcr = getLighting(or + d*tr + getNormal(or + d*tr)*0.01 + normalize(reflectRay(or + d*tr, d))*rtr, lPos);\n                        col.gb += mix(\n                            mix(matr.col.gb, rmatr.col.gb*max(rcr, 0.1), reflectiveness)*max(cr, 0.1),\n                            fogColor.gb,\n                            min(tr/20.0, 1.0)\n                        );\n                    }else{\n                        col.gb += mix(\n                            mix(matr.col.gb, fogColor.gb, reflectiveness)*max(cr, 0.1),\n                            fogColor.gb,\n                            min(tr/20.0, 1.0)\n                        );\n                    }\n                }else{\n                    col.gb += mix(matr.col.gb*max(cr, 0.1), fogColor.gb, min(tr/20.0, 1.0));\n                }\n            }else{\n                col.gb = fogColor.gb;\n            }\n        }\n    }else{\n        float tl;\n        material matl;\n        vec3 ol = o - vec3(eyeDist/2.0, 0, 0);\n        bool rl = raymarch(ol, d, tl, matl, 100, 0.01);\n        \n        if(rl){\n            float cl = getLighting(ol + d*tl, lPos);\n            if(matl.type != 1){\n                float rtl;\n                material rmatl;\n                bool rrl = raymarch(ol + d*tl + getNormal(ol + d*tl)*0.01, normalize(reflectRay(ol + d*tl, d)), rtl, rmatl, 50, 0.01);\n                if(rrl){\n                    float rcl = getLighting(ol + d*tl + getNormal(ol + d*tl)*0.01 + normalize(reflectRay(ol + d*tl, d))*rtl, lPos);\n                    col.r += mix(\n                        mix(matl.col.r, rmatl.col.r*max(rcl, 0.1), reflectiveness)*max(cl, 0.1),\n                        fogColor.r,\n                        min(tl/20.0, 1.0)\n                    );\n                }else{\n                    col.r += mix(\n                        mix(matl.col.r, fogColor.r, reflectiveness)*max(cl, 0.1),\n                        fogColor.r,\n                        min(tl/20.0, 1.0)\n                    );\n                }\n            }else{\n                col.r += mix(matl.col.r*max(cl, 0.1), fogColor.r, min(tl/20.0, 1.0));\n            }\n        }else{\n            col.r = fogColor.r;\n        }\n\n        float tr;\n        material matr;\n        vec3 or = o + vec3(eyeDist/2.0, 0, 0);\n        bool rr = raymarch(or, d, tr, matr, 100, 0.01);\n\n        if(rr){\n            float cr = getLighting(or + d*tr, lPos);\n            if(matr.type != 1){\n                float rtr;\n                material rmatr;\n                bool rrr = raymarch(or + d*tr + getNormal(or + d*tr)*0.01, normalize(reflectRay(or + d*tr, d)), rtr, rmatr, 50, 0.01);\n                if(rrr){\n                    float rcr = getLighting(or + d*tr + getNormal(or + d*tr)*0.01 + normalize(reflectRay(or + d*tr, d))*rtr, lPos);\n                    col.gb += mix(\n                        mix(matr.col.gb, rmatr.col.gb*max(rcr, 0.1), reflectiveness)*max(cr, 0.1),\n                        fogColor.gb,\n                        min(tr/20.0, 1.0)\n                    );\n                }else{\n                    col.gb += mix(\n                        mix(matr.col.gb, fogColor.gb, reflectiveness)*max(cr, 0.1),\n                        fogColor.gb,\n                        min(tr/20.0, 1.0)\n                    );\n                }\n            }else{\n                col.gb += mix(matr.col.gb*max(cr, 0.1), fogColor.gb, min(tr/20.0, 1.0));\n            }\n        }else{\n            col.gb = fogColor.gb;\n        }\n    }\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtB3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 338, 360, 360, 466], [468, 468, 494, 494, 1774], [1875, 1875, 1920, 1920, 1958], [1960, 1960, 2001, 2001, 2106], [2108, 2108, 2167, 2167, 2245], [2247, 2247, 2303, 2303, 2384], [2386, 2386, 2431, 2431, 2463], [2465, 2465, 2521, 2521, 2643], [2645, 2645, 2722, 2722, 2811], [2813, 2853, 2899, 2899, 3248], [3250, 3250, 3271, 3271, 5403], [5405, 5405, 5485, 5485, 5810], [5812, 5812, 5835, 5835, 6140], [6142, 6142, 6179, 6179, 6455], [6457, 6457, 6489, 6489, 6550], [6552, 6552, 6606, 6606, 12434]], "test": "untested"}
{"id": "mtSGz3", "name": "Fruxis, reconstructed", "author": "42yeah", "description": "A remade of iq's fruxis. Check out the blog post here: https://blog.42yeah.is/rendering/2023/01/14/fruxis.html", "tags": ["fruxis"], "likes": 3, "viewed": 356, "published": 3, "date": "1673601924", "time_retrieved": "2024-07-30T18:16:08.308621", "image_code": "//\n// Fruxis, reconstructed - by 42yeah\n//\n\nvec3 hash3(float n)\n{\n    return fract(sin(vec3(n, n + 1.0, n + 2.0)) * vec3(43758.5453123, 22578.1459123, 19642.3490423));\n}\n\nfloat ball(vec3 p, vec3 center, float r)\n{\n    return length(p - center) - r;\n}\n\nfloat suelo(vec3 p, out vec3 uvw)\n{\n    uvw = p;\n    return p.y;\n}\n\nfloat pared(vec3 p, out vec3 uvw)\n{\n    uvw = 4.0 * p;\n    float d1 = 0.6 + p.z;\n    float d2 = 0.6 + p.x;\n    return min(d1, d2);\n}\n\nfloat melon(vec3 p, out vec3 uvw)\n{\n    vec3 c = p - vec3(0.0,0.215,0.0);\n\n    vec3 q = 3.0 * c * vec3(1.0,1.5,1.5);\n    uvw = 3.0 * c;\n\n    float r = 1.0 - 0.007 * sin(30.0 * (-c.x + c.y - c.z));\n    return 0.65 * (length(q) - r) / 3.0;\n}\n\nfloat manzana(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(0.5, 0.1, 0.5);\n    float r = length(q.xz);\n    q.y += 0.05 * (1.0 - clamp(r / 0.1, 0.0, 1.0));\n    q.y -= 0.03 * (1.0 - smoothstep(0.004, 0.005, r));\n    uvw = 10.0 * q;\n    return 0.4 * (length(10.0 * q) - 1.0) / 10.0;\n}\n\nfloat uvas(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.1, 0.6);\n    uvw = 10.0 * q;\n    \n    float d1 = length(q - vec3(-0.09, 0.1, -0.07)) - 0.12;\n    float d2 = length(q - vec3(0.11, 0.05, 0.0)) - 0.09;\n    float d3 = length(q - vec3(-0.07, 0.03, 0.1)) - 0.1;\n    \n    return min(d1, min(d2, d3));\n}\n\nfloat lemon(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(0.7, 0.06, 0.2);\n    uvw = 10.0 * q;\n    \n    float s = 1.35; // ???\n    float r = clamp(abs(q.x) / 0.077, 0.0, 1.0);\n    s += 2.5 * pow(r, 24.0);\n    q *= vec3(1.0, s, s);\n    return 0.5 * (length(12.0 * q) - 1.0) / (12.0 * s);\n}\n\nfloat jarron(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.28, 0.6);\n    uvw = q;\n    \n    float d1 = length(q) - 1.0 / 3.5;\n    d1 = abs(d1 + 0.025 / 3.5) - 0.025 / 3.5;\n    \n    float d2 = q.y + 0.1;\n    return max(d1, d2);\n}\n\nfloat mantelito(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.001, 0.65);\n    q.xz += 0.1 * vec2(\n        0.7 * sin(6.0 * q.z + 2.0) + 0.3 * sin(12.0 * q.x + 5.0),\n        0.7 * sin(6.0 * q.x + 0.7) + 0.3 * sin(12.0 * q.z + 3.0));\n    \n    const mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    q.xz = m2 * q.xz;\n    uvw = q;\n    \n    q.y -= 0.008 * (0.5 - 0.5 * sin(40.0 * q.x) * sin(5.0 * q.z));\n    \n    return length(max(abs(q) - vec3(0.3, 0.001, 0.3), 0.0)) - 0.0005;\n}\n\nfloat botella(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.35, 0.0, 0.3);\n    vec2 w = vec2(length(q.xz), q.y);\n\n    uvw = q;\n    \n    float r = 1.0 - 0.8 * pow(smoothstep(0.5, 0.6, q.y), 4.0);\n    r += 0.1 * smoothstep(0.65, 0.66, q.y);\n    r *= 1.0 - smoothstep(0.675, 0.68, q.y);\n    \n    r -= clamp(q.y - 0.67, 0.0, 1.0) * 1.9;\n\n    return (w.x - 0.11 * r) * 0.5;\n}\n\n// Maps to the closest point in scene.\n// The whole scene is defined in map() function.\n// Components: x: closest distance to surface\n//             y: closest surface ID (so that we can shade it)\nvec2 map(vec3 p, out vec3 uvw)\n{\n    // suelo\n    float id = 0.5;\n    float closest = suelo(p, uvw);\n    vec3 mapped_uvw = vec3(0.0);\n    \n    float dist = pared(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 1.5; uvw = mapped_uvw; }\n    \n    dist = melon(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 2.5; uvw = mapped_uvw; }\n    \n    dist = manzana(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 3.5; uvw = mapped_uvw; }\n    \n    dist = uvas(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 4.5; uvw = mapped_uvw; }\n    \n    dist = lemon(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 5.5; uvw = mapped_uvw; }\n    \n    dist = jarron(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 6.5; uvw = mapped_uvw; }\n    \n    dist = mantelito(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 7.5; uvw = mapped_uvw; }\n    \n    dist = botella(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 8.5; uvw = mapped_uvw; }\n\n    return vec2(closest, id);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 uvw;\n    vec2 del = vec2(0.01, 0.0);\n    float val = map(p, uvw).x;\n\n    return normalize(vec3(val - map(p - del.xyy, uvw).x,\n        val - map(p - del.yxy, uvw).x,\n        val - map(p - del.yyx, uvw).x));\n}\n\nvec2 march(vec3 ro, vec3 rd, out vec3 uvw)\n{\n    int steps = 150;\n    float dist = 0.01;\n    \n    for (int i = 0; i < steps; i++)\n    {\n        vec2 info = map(ro + dist * rd, uvw);\n        if (info.x < 0.001)\n        {\n            return vec2(dist, info.y);\n        }\n        dist += info.x;\n    }\n    return vec2(1.0, -1.0);\n}\n\n\n\n// Shade the particular point of the scene, according to shading informations\n// given in the function parameters.\nvec3 getColor(vec2 info, vec3 uvw, vec3 nor, out vec3 bnor)\n{\n    float id = info.y;\n    if (id < 0.0)\n    {\n        // Shade sky\n        return vec3(0.7, 0.9, 1.0);\n    }\n    else if (id > 0.0 && id < 1.0)\n    {\n        // Floor (suelo)\n        return vec3(0.5, 0.25, 0.0);\n    }\n    else if (id > 1.0 && id < 2.0)\n    {\n        // Wall (pared)\n        return vec3(0.2, 0.1, 0.0);\n    }\n    else if (id > 2.0 && id < 3.0)\n    {\n        // Melon\n        return vec3(0.3, 0.8, 0.3);\n    }\n    else if (id > 3.0 && id < 4.0)\n    {\n        // Apple (manzana)\n        return vec3(0.9, 0.3, 0.2);\n    }\n    else if (id > 4.0 && id < 5.0)\n    {\n        // Oranges (uvas)\n        return vec3(1.0, 0.5, 0.0);\n    }\n    else if (id > 5.0 && id < 6.0)\n    {\n        // Lemon\n        return vec3(1.0, 0.9, 0.0);\n    }\n    else if (id > 6.0 && id < 7.0)\n    {\n        // Bowl (jarron)\n        return vec3(0.3, 0.2, 0.1);\n    }\n    else if (id > 7.0 && id < 8.0)\n    {\n        // Doily (mantelito)\n        return vec3(0.3, 0.4, 0.7);\n    }\n    else if (id > 8.0 && id < 9.0)\n    {\n        // Bottle (botella)\n        return vec3(0.6, 0.5, 0.1);\n    }\n    // Unknown\n    return vec3(1.0, 0.0, 1.0);\n}\n\nconst vec3 rlight = vec3(3.62, 2.99, 0.71);\nvec3 lig = normalize(rlight);\n\n// Shadow marching\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.001;\n    vec3 trash;\n    for (int i = 0; i < 64; i++)\n    {\n        vec2 info = map(ro + rd * t, trash);\n        res = min(res, smoothstep(0.0, 1.0, k * info.x / t));\n        if (res < 0.001)\n        {\n            break;\n        }\n        t += clamp(info.x, 0.01, 1.0);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat directLighting(vec3 pos, vec3 nor)\n{\n    vec3 front = lig;\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, front);\n    \n    float shadowIntensity = softShadow(pos + 0.001 * nor, lig, 10.0);\n    \n    vec3 toLight = rlight - pos;\n    float att = smoothstep(0.985, 0.997, dot(normalize(toLight), lig));\n\n    vec3 pp = pos - front * dot(pos, front);\n    vec2 uv = vec2(dot(pp, right), dot(pp, up));\n    float pat = smoothstep(-0.5, 0.5, sin(10.0 * uv.y));\n    \n    return pat * att * shadowIntensity;\n}\n\nfloat calcAO(vec3 p, vec3 nor, vec2 px)\n{\n    float off = 0.1 * dot(px, vec2(1.2, 5.3));\n    float ao = 0.0;\n    \n    vec3 trash;\n    for (int i = 0; i < 20; i++)\n    {\n        // Generate a random sample point (0 to 1)\n        vec3 aoPos = 2.0 * hash3(float(i) * 213.47 + off) - 1.0;\n        // Moves closer to center of the sphere\n        aoPos = aoPos * aoPos * aoPos;\n        // Flip points so we are now only sampling in the hemisphere\n        aoPos *= sign(dot(aoPos, nor));\n        // Sample those points and magnify them by 48 times\n        ao += clamp(map(p + nor * 0.015 + 0.015 * aoPos, trash).x * 48.0, 0.0, 1.0);\n    }\n    // Calculate the average ambient occlusion value\n    ao /= 20.0;\n    return clamp(ao * ao, 0.0, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(1.0, 0.5, 1.0);\n    vec3 center = vec3(0.0, 0.2, 0.2);\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat3 lookAt = mat3(right, up, front);\n    vec3 rd = lookAt * normalize(vec3(uv, 1.8));\n    vec3 uvw = vec3(0.0);\n    \n    vec2 info = march(ro, rd, uvw);\n    vec3 p = ro + info.x * rd;\n    vec3 nor = getNormal(p);\n    vec3 bnor = vec3(0.0);\n    vec3 obj = getColor(info, uvw, nor, bnor);\n    \n    // Postprocess normal...\n    \n    vec3 ref = reflect(rd, nor);\n    \n    // Lighting components\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 0.0));\n    float occ = calcAO(p, nor, uv * 0.5 + 0.5);\n    float ambient = 1.0;\n    float sha = directLighting(p, nor);\n    float bfl = clamp(-nor.y * 0.8 + 0.2, 0.0, 1.0) * pow(clamp(1.0 - p.y, 0.0, 1.0), 2.0); // Bottom\n    float bce = clamp(nor.y * 0.8 + 0.2, 0.0, 1.0); // Dome\n    float dif = max(dot(nor, lig), 0.0); // Diffuse\n    float bac = max(dot(nor, normalize(-vec3(-lig.x, 0.0, -lig.z))), 0.0); // Back\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 3.0); // Fringe\n    float spe = 0.04 + 0.96 * pow(clamp(dot(ref, lig), 0.0, 1.0), 5.0);\n    \n    float att = 0.1 + 0.9 * smoothstep(0.975, 0.997, dot(normalize(rlight - p), lig));\n    \n    // Lights\n    vec3 lin = vec3(0.0);\n    lin += ambient * vec3(0.08, 0.1, 0.12) * att * occ;\n    lin += bfl * vec3(0.5 + att * 0.5, 0.3, 0.1) * att * occ;\n    lin += bce * vec3(0.3, 0.2, 0.2) * att * occ;\n    lin += bac * vec3(0.4, 0.35, 0.3) * att * occ;\n    lin += dif * vec3(2.5, 1.8, 1.3) * pow(vec3(sha), vec3(1.0, 1.3, 1.6));\n    lin += fre * vec3(3.0, 3.0, 3.0) * occ * att * (0.25 + 0.75 * dif * sha);\n    lin += spe * vec3(3.0, 3.0, 3.0) * occ * att * dif * sha * info.x;\n\n    vec3 color = vec3(0.0);\n    color += lin * obj;\n\n    color = pow(clamp(color, 0.0, 1.0), vec3(0.4545));\n    \n    // Postprocessing\n    // Contrast\n    color = color * 0.6 + 0.4 * color * color * (3.0 - 2.0 * color);\n    // Saturation\n    color = mix(color, vec3(dot(color, vec3(0.33))), 0.2);\n    // Curves\n    color = pow(color, vec3(0.85, 0.95, 1.0));\n    // Vignetting\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color *= 0.7 + 0.3 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 65, 65, 169], [171, 171, 213, 213, 250], [252, 252, 287, 287, 318], [320, 320, 355, 355, 452], [454, 454, 489, 489, 693], [695, 695, 732, 732, 977], [979, 979, 1013, 1013, 1290], [1292, 1292, 1327, 1327, 1580], [1582, 1582, 1618, 1618, 1817], [1819, 1819, 1858, 1858, 2293], [2295, 2295, 2332, 2332, 2668], [2670, 2867, 2899, 2912, 3927], [3929, 3929, 3953, 3953, 4170], [4172, 4172, 4216, 4216, 4500], [4504, 4619, 4680, 4680, 5805], [5882, 5901, 5946, 5946, 6294], [6296, 6296, 6338, 6338, 6842], [6844, 6844, 6885, 6885, 7584], [7587, 7587, 7642, 7642, 10108]], "test": "untested"}
{"id": "dlS3R3", "name": "Trippy Colorful Feel Good 2222", "author": "maxwellcoffee", "description": "psychedelic visuals ", "tags": ["psychedelic"], "likes": 4, "viewed": 261, "published": 3, "date": "1673601195", "time_retrieved": "2024-07-30T18:16:09.085543", "image_code": "/* @maxwellcoffee - 2023 \n\ninspo from + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          e = 0.84+iTime*.11111111;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<1e2;) {\n    /* substitute the 1e2 above to \n    1e1 for faster performance (such as full screen) or \n    1e3 for more detail (could make it choppy)\n*/\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*cos(6.*e);\n        p = fract(p)-.15;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.14,.31,.25,14.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(tan(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlS3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dlBGR3", "name": "shortest circular maze ( 160ch )", "author": "FabriceNeyret2", "description": "circular variant of [url]https://shadertoy.com/view/lt2cRR[/url]\n\nLess clear how to do the equivalent anti-aliased version.", "tags": ["2tweets", "maze", "short", "golf"], "likes": 18, "viewed": 262, "published": 3, "date": "1673600702", "time_retrieved": "2024-07-30T18:16:09.855484", "image_code": "// circular variant of https://shadertoy.com/view/lt2cRR\n\nvoid mainImage(out vec4 O, vec2 U) { \n  U = vec2( ceil(length( U -= iResolution.xy/2. )/8.)*8. * atan(U.y,U.x) +99., length(U) ); // comment → flat maze\n  O = mod( U [ int( 1e4*length(ceil(U/8.)) ) % 2 ] , 8. ) + O*0.; \n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 94, 94, 281]], "test": "untested"}
{"id": "dtSGR3", "name": "Concentric Xor", "author": "mla", "description": "SDF xor, based on [url]https://www.shadertoy.com/view/ctSGzV[/url] by AxisPod.", "tags": ["sdf", "xor", "opart"], "likes": 7, "viewed": 228, "published": 3, "date": "1673599580", "time_retrieved": "2024-07-30T18:16:10.618445", "image_code": "//////////////////////////////////////////////////////////////////\n//\n// Concentric Xor, mla, 2023\n//\n// SDFs are nice for logical combinations of primitives,\n// including xor (aka symmetric difference):\n//\n// xor(A,B) = intersect(union(A,B),complement(intersect(A,B)))\n//\n// 'd': show distance field\n// 'r': randomly perturb radii\n// 'x': show boundaries of regions\n//\n// Based on on https://www.shadertoy.com/view/ctSGzV by AxisPod\n//\n//////////////////////////////////////////////////////////////////\n\n// SDF xor\nfloat xor(float d0, float d1) {\n  // Union minus the intersection\n  return max(min(d0,d1),-max(d0,d1));\n}\n\nfloat repCircle(vec2 p, float t, vec2 centre) {\n  p -= centre;\n  float r = length(p);\n  float i = round(r/t);\n  if (i == 0.0) i = 1.0; // No boundary at 0\n  float s = t*i; // s is nearest boundary\n  if (key(CHAR_R)) s += 0.5*t*(rand(int(i))-0.5); // Random perturbation\n  float sgn = mod(i,2.0) == 0.0 ? -1.0 : 1.0;\n  assert(sgn < 0.0);\n  return sgn*(r-s);\n}\n\nfloat repSquare(vec2 p, float t, vec2 centre) {\n  p -= centre;\n  p = abs(p);\n  float r = min(p.x,p.y);\n  float i = round(r/t);\n  if (i == 0.0) i = 1.0; // No boundary at 0\n  float s = t*i; // s is nearest boundary - adjust here if desired\n  if (key(CHAR_R)) s += 0.5*t*(rand(int(i)*255)-0.5); // Random perturbation\n  float sgn = mod(i,2.0) == 0.0 ? -1.0 : 1.0;\n  float dx = s-p.x;\n  float dy = s-p.y;\n  // We could just return max(dx,dy) but it doesn't cost\n  // much to get an exact distance.\n  float d = dx > 0.0 && dy > 0.0 ? distance(p,vec2(s)) : max(dx,dy);\n  return sgn*d;\n}\n\nvec3 drawScene(vec2 p) {\n  float px = fwidth(p.x);\n  float t = 0.25*iTime;\n  float d1 = repCircle(p, 0.5, vec2(sin(t)*1.0, cos(0.414*t)*1.5));\n  float d2 = repSquare(p, 0.5, vec2(-sin(0.618*t)*1.5, cos(t))*1.0);\n  float d = xor(d1,d2);\n  vec3 col = vec3(smoothstep(-0.5*px,0.5*px,d));\n  if (key(CHAR_D)) col *= 0.75-0.25*cos(0.5*PI*d/px);\n  if (key(CHAR_X)) col = mix(vec3(1,0,0),col,smoothstep(0.0,px,abs(d)-0.005));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  p *= 4.0;\n  vec3 col = drawScene(p);\n  col = pow(col,vec3(0.4545));\n  if (key(CHAR_A) && alert) col.b = 1.0-col.b;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n\nconst float PI = 3.14159;\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(int n) {\n  return float(ihash(uint(n)))/exp2(32.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[505, 516, 547, 581, 621], [623, 623, 670, 670, 981], [983, 983, 1030, 1030, 1564], [1566, 1566, 1590, 1590, 1999], [2001, 2001, 2054, 2054, 2257]], "test": "untested"}
{"id": "clB3zc", "name": "smooth fract / mod / floor", "author": "FabriceNeyret2", "description": "smooth fract:  tunable, 1 pixel ( for AA ), reference fract.\n\nred: smooth floor    ( picky artifact just do to visualization )", "tags": ["interpolation", "utils", "sfract", "sfloor", "smoothmod"], "likes": 11, "viewed": 330, "published": 3, "date": "1673599406", "time_retrieved": "2024-07-30T18:16:11.383399", "image_code": "\n#define sfract(x)      min( fract(x)/(1.-fwidth(x)), fract(-(x))/fwidth(x) ) // or 1.5*fwidth\n#define smod(x,n)     (sfract((x)/(n))*(n))\n#define sfloor(x)      max( floor(x), x - sfract(x) )\n\n//  ---  variant: tunable smooth cliff \n#define sfractN(x,w)   min( fract(x)/(1.-(w)), fract(-x)/(w) )\n#define smodN(x,n,w)  (sfractN((x)/(n),w)*(n))\n#define sfloorN(x,w)   max( floor(x), x - sfractN(x,w) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, V,\n         U = 10.* (u/R - .5);\n\n    float y = floor(U.y), x = U.x,                                            // show funcs ( white )\n          v =  y == -2. ? fract( x )\n             : y == 0. ? sfract( x )\n             : y == 2. ? sfractN( x, .05 )\n             : 0.;\n    O = U.x > 0. \n          ? vec4( fract(U.y) < v )\n          : vec4( smoothstep(0., 1.5*fwidth(v), v - fract(U.y) ) );\n       // : vec4( smoothstep( 1.5*fwidth(v), 0., abs(v - fract(U.y) )) );\n \n    v = sfloorN( x, .1 );                                                     // --- show sfloor (red )\n    O.r += smoothstep( 1.5*max(fwidth(U.y),fwidth(v)), 0., abs(v - U.y ) ); \n    \n    V = (10.*(u-.5*R)/R.y) * mat2(cos( .3*iTime+vec4(0,11,33,0)));            // --- exemple ( green )\n    V = sfract( V );\n    if (y<-2. && U.x>0.) O.g = V.x * V.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clB3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 441, 441, 1293]], "test": "untested"}
{"id": "DtS3zc", "name": "copysignf impl", "author": "shaofun", "description": "I don't want 0 because I'm always unsure what happens when I divide by 0", "tags": ["sign", "copysignf"], "likes": 2, "viewed": 184, "published": 3, "date": "1673597982", "time_retrieved": "2024-07-30T18:16:12.163314", "image_code": "float copysignf(float x, float s) {\n    uint uabs = floatBitsToUint(x) & 0x7fffffffU;\n    uint usig = floatBitsToUint(s) & 0x80000000U;\n    return uintBitsToFloat(uabs | usig);\n}\n\n// given by https://www.shadertoy.com/user/mla\nfloat mulsignf(float x, float s) {\n    uint u = floatBitsToUint(s) & 0x80000000U;\n    u ^= floatBitsToUint(x);\n    return uintBitsToFloat(u);\n}\n\nfloat signed1(float x) {\n    return copysignf(1.0, x);\n}\n\nfloat signed2(float x) {\n    return x >= 0.0 ? 1.0 : -1.0;\n}\n\nfloat signed3(float x) {\n    return sign(sign(x) + 0.5);\n}\n\nfloat signed4(float x) {\n    return float(x >= 0.0) - float(x < 0.0);\n}\n\nfloat signed5(float x) {\n    float t = float(x >= 0.0);\n    return float(t + t - 1.0);\n}\n\nfloat signed6(float x) {\n    uint ix = (floatBitsToUint(x) & 0x80000000U);\n    ix |= 0x3f800000U;\n    return uintBitsToFloat(ix);\n}\n\nfloat signed7(float x) {\n    return mulsignf(1.0, x);\n}\n\nfloat run(float x) {\n    return float(signed7(x - 0.5) == sign(sin(iTime * 5.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col;\n    \n    uv -= 0.5;\n    uv *= 5.0;\n    col = vec3(run(max(floor(abs(uv.x)), floor(abs(uv.y)))));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtS3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 178], [180, 227, 261, 261, 370], [372, 372, 396, 396, 428], [430, 430, 454, 454, 490], [492, 492, 516, 516, 550], [552, 552, 576, 576, 623], [625, 625, 649, 649, 713], [715, 715, 739, 739, 846], [848, 848, 872, 872, 903], [905, 905, 925, 925, 989], [991, 991, 1048, 1048, 1241]], "test": "untested"}
{"id": "cl23Ww", "name": "SSAO Rotating Ball Pit", "author": "fenix", "description": "5000 particle-balls in a rotating cube, rendered via voronoi tracking with screen space ambient occlusion.\n\n*mouse to control cube rotation* \n*click-drag-release to \"throw\" cube*\n*space to resume automatic rotation*\n*shift to disable ambient occlusion*", "tags": ["3d", "simulation", "particles", "dynamics", "physics", "ssao"], "likes": 35, "viewed": 596, "published": 3, "date": "1673584301", "time_retrieved": "2024-07-30T18:16:13.120754", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particle sim rendered via voronoi tracking, with screen space ambient occlusion.\n//\n//  Who doesn't love a good physics-in-a-box shader? But they usually suffer from poor\n//  lighting, making the interior objects in piles appear to glow. I have always been\n//  interested in screen-space ambient occlusion, so I thought I'd give that a go.\n//\n//  The results look pretty good, I think. Definitely alleviates the glowing-pile\n//  problem and gives a more three-dimensional feel. Hold shift to disable it.\n//\n//  Doing the shadows in screen space like this obviates the need for a second voronoi\n//  buffer to track objects from the light source point of view. Of course without\n//  raycast shadows, shadows cannot be transported across the scene. But, for a more\n//  diffuse-lit (and maybe more natural) look, SSAO seems to fit the bill.\n//\n//  I haven't done too many shaders with interacting 3D particles, and I was pleased\n//  to discover that these balls (eventually) settle down to a nice packing pattern when\n//  the box stops spinning. Click and release the mouse to test this, then drag or press\n//  space to resume spinning.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Image performs lighting and SSAO\n//\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\nvec3 materialColor(float c)\n{\n    if (c <= 1.) return mix(vec3(1, .6, .2), vec3(.1, .02, 0), c); // color between 0 and 1 is the box\n    \n    // sphere colors\n    switch(int(c - 1.) % 6)\n    {\n        case 0: return vec3(1,0,0);\n        case 1: return vec3(1,.2,0);\n        case 2: return vec3(1,1,0);\n        case 3: return vec3(0,1,0);\n        case 4: return vec3(0,0,1);\n        case 5: return vec3(1,0,1);\n    }\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel0, fragCoord/iResolution.xy));\n    \n    if (pix.t >= FAR_CLIP)\n    {\n        // background\n        fragColor = vec4(.2);\n    }\n    else\n    {\n        // ssao model inspired by SSAO (basic) by iq: https://www.shadertoy.com/view/Ms23Wm\n        // sample neighbor pixels\n        float ao = 0.0;\n        const float SAMPLES = 20.; // increase for higher quality if your GPU can handle it\n        for( float i=0.; i<SAMPLES; i++ )\n        {\n            vec3 h = hash3(uvec3(fragCoord, 0));\n\n            // get a random 2D offset vector\n            vec2 off = texture(iChannel1, (fragCoord.xy + 23.71*float(i)) / iChannelResolution[1].xy).xz - .5\n                + .1 * pix.n.xz; // shift search in the direction of normal\n            off += sign(off) * .1; // don't waste samples looking at nearby pixels\n\n            // sample the zbuffer at a neightbor pixel\t\t\n            fxGBufferPixel nbPix = fxUnpackGBuffer(texture(iChannel0, fragCoord.xy / iResolution.xy + off * .02));\n            \n            // accumulate occlusion if difference is less than 0.02 units\t\t\n            if (nbPix.m > 1.) // box doesn't cast occlusion\n            {\n                ao += clamp((pix.t-nbPix.t)/.02, 0., 1.);\n            }\n        }\n        \n        // average down the occlusion\t\n        ao = clamp(1. - pow(ao,1.3)/SAMPLES, 0., 1.);\n        if (keyDown(KEY_SHIFT)) ao = 1.;\n        \n        // lighting\n        float nDotL = max(dot(pix.n, normalize(vec3(1))), .0);\n        float dif = ao * (nDotL * nDotL * .9 + .1) + .1;\n        fragColor.xyz = materialColor(pix.m) * dif;\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 5.; // multiply with sth for intensity\n    vig = sqrt(vig); // change pow for modifying the extend of the  vignette\n    fragColor *= vig;\n\n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .03;\nconst float FAR_CLIP = 1e6;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    ivec4 nbs[4];\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.vel = particleData5.xyz;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 5000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, -.5, 0);\n    cameraPos\t = vec3(0, 1, 1);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 boxRot;\n    vec2 boxVel;\n    vec2 lastMouse;\n    float resolution;\n    bool autoRotate;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.boxRot = vec2(0);\n    state.boxVel = vec2(0);\n    state.lastMouse = vec2(0);\n    state.resolution = -iResolution.x * iResolution.y;\n    state.autoRotate = true;\n}\n\n#define fxInitState(state) fxGetStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    \n    fxState state;\n    state.boxRot = data0.xy;\n    state.boxVel = data0.zw;\n    state.lastMouse = data1.xy;\n    state.resolution = data1.z;\n    state.autoRotate = data1.w != 0.;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(state.boxRot, state.boxVel);\n    else\n        return vec4(state.lastMouse, state.resolution, state.autoRotate ? 1. : 0.);\n}\n\n// PHYSICS BOUNDARY SCENE\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// compute a matrix from the boxRot euler angles\nmat4 boxMat(vec2 boxRot)\n{\n    const float ROTATE_SPEED = .2;\n    vec2 scA = vec2(sin(boxRot.x * ROTATE_SPEED), cos(boxRot.x * ROTATE_SPEED));\n    vec2 scB = vec2(sin(boxRot.y * ROTATE_SPEED), cos(boxRot.y * ROTATE_SPEED));\n    vec2 scC = vec2(sin(.001 * ROTATE_SPEED), cos(.001 * ROTATE_SPEED));\n    mat4 matA = mat4(scA.y, -scA.x, 0, 0, scA.x, scA.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    mat4 matB = mat4(scB.y, 0, scB.x, 0, 0, 1, 0, 0, -scB.x, 0, scB.y, 0, 0, 0, 0, 1);\n    mat4 matC = mat4(0, scC.y, -scC.x, 0, 1, 0, 0, 0, 0, scC.x, scC.y, 0, 0, 0, 0, 1);\n    \n    return matA * matB * matC;\n}\n\nvoid rotateBox(inout vec3 p, vec2 boxRot)\n{\n    p = (vec4(p, 1) * boxMat(boxRot)).xyz;\n}\n\nfloat scene(vec3 p, fxState state)\n{\n    rotateBox(p, state.boxRot);\n    return -sdBox(p - vec3(0, 0, 0), vec3(1, 1, 1));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 p, fxState state)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, state) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, state) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, state) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, state) );\n}\n\n// G BUFFER\n\n// note there are five dwords here...c is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    \n    pix.m = abs(fragColor.z);\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-.0005,0);\n\nvoid particleStep(inout fxParticle p, fxState state, vec2 fragCoord)\n{\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(fragCoord, iFrame) );\n\n        p.pos = h * 2. - 1.;\n        p.vel = vec3(0);\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .995; // damping\n    const float MAX_SPEED = .025; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n    p.vel += GRAVITY;\n\n    for (int iter = 0; iter < 3; ++iter)\n    {\n        // collide with neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                fxParticle nb = fxGetParticle(nid);\n\n                if (nb.pos.y < p.pos.y && // only react to particles below us (stability hack)\n                    distance(nb.pos, p.pos) < PARTICLE_SIZE * 2.)\n                {\n                    vec3 dir = normalize(p.pos - nb.pos);\n\n                    // position correction\n                    p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .05);\n\n                    // clip velocity (stability hack, should be relative velocity)\n                    p.vel -= dot(p.vel, dir) * dir;\n                }\n            }\n        }\n\n        // collide with boundary\n        float boundary = scene(p.pos, state);\n        if (boundary < PARTICLE_SIZE)\n        {\n            vec3 normal = sceneNormal(p.pos, state);\n\n            // position correction\n            p.pos += normal * (PARTICLE_SIZE - boundary);\n\n            // clip velocity\n            vec3 boxVel = .01*cross(p.pos, vec3(-state.boxVel.y, 0, state.boxVel.x));\n            p.vel -= min(0., dot(p.vel - boxVel, normal)) * normal;\n        }\n    }\n\n    p.pos += p.vel; // integrate\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // randomly consider one of the neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % 4;\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n                for (int y = 0; y < 4; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, state, fragCoord);\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    \n    // throw away particles too far away\n    vec2 delta = screenPos.xy-fragCoord;\n    if (length2(delta) > (PARTICLE_SIZE * PARTICLE_SIZE * 2.0)) return 1e6;\n    \n    // favor particles in the front\n    return length2(delta) + screenPos.z * .01;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            state.autoRotate = false;\n            \n            if (iMouse.w < 0.)\n            {\n                vec2 delta = 3. * (iMouse.xy - state.lastMouse) / iResolution.y;;\n                state.boxVel = delta;\n            }\n            \n            state.lastMouse = iMouse.xy;\n        }\n        else if (state.autoRotate)\n        {\n            state.boxVel = mix(state.boxVel, vec2(-.01), .01);\n        }\n        \n        state.boxVel = clamp(state.boxVel, -.1, .1);\n        \n        if (keyDown(KEY_SPACE)) state.autoRotate = true;\n        \n        state.boxRot += state.boxVel;\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float dis2 = distance2Particle(nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 48u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n        }\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// draw one ball\nvoid renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_SIZE));\n    if (t > 0. && t < pix.t)\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.pos);\n\n        pix.n = normal;\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.t = t;\n    }\n}\n\n// Derived from iq, but DO NOT COPY FROM HERE (modified to return interior results):\n// https://iquilezles.org/articles/boxfunctions/\n// Calcs intersection and exit distances, normal, face and UVs\n// row is the ray origin in world space\n// rdw is the ray direction in world space\n// txx is the world-to-box transformation\n// txi is the box-to-world transformation\n// ro and rd are in world space\n// rad is the half-length of the box\n//\n// oT contains the entry and exit points\n// oN is the normal in world space\n// oU contains the UVs at the intersection point\nbool boxIntersect( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad,\n                   out vec2 oT, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n    if( t2.x<t2.y && t2.x<t2.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t2.x; }\n    else if( t2.y<t2.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t2.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t2.z; }\n\n    oT = vec2(tN,tF);\n    \n    return true;\n}\n\nfloat boxDist(vec2 a, vec2 b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }\n\n// generates a checkerboard pattern\n// aa allows reduction of aliasing at steep angles\nfloat checker(vec2 p, float aa)\n{\n    vec2 m = mod(p, vec2(2.));\n    float sd = min(boxDist(vec2(.5, 1.5), m), boxDist(vec2(1.5, .5), m));\n    return smoothstep(-aa, aa, .5 - sd) * .5 + .5;\n}\n\n// draws an inside-out antialiased checkered box\nvoid drawBox(fxState state, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    vec2 t, uv;\n    vec3 n;\n    mat4 m = boxMat(state.boxRot);\n    if (boxIntersect(ro, rd, inverse(m), m, vec3(1), t, n, uv))\n    {\n        float x = 1.2 + dot(n, rd);\n        float aa = x * 20./iResolution.y;\n        float ch = checker(uv * 4.25 - .5, aa);\n        \n        pix.n = n;\n        pix.t = t.y;\n        pix.m = ch;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n    \n    // render box\n    drawBox(state, cameraPos, rayDir, pix);\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, cameraPos, rayDir, pix);\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl23Ww.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1641, 1680, 1709, 1709, 2097], [2099, 2183, 2206, 2206, 2366], [2368, 2368, 2425, 2425, 4521]], "test": "untested"}
{"id": "dt2GRV", "name": "Sponge Cells Antialiased", "author": "ersh", "description": "Trippy thing Antialiased", "tags": ["procedural", "2d", "fx", "lsd"], "likes": 6, "viewed": 217, "published": 3, "date": "1673571394", "time_retrieved": "2024-07-30T18:16:13.997410", "image_code": "#define GAMMA   1.6\n#define gamma(X)  pow(X, GAMMA)\n#define degamma(X)  pow(X, 1./GAMMA)\n\n// https://www.shadertoy.com/view/clB3zc\n#define sfractN(x,w)   min( fract(x)/(1.-(w)), fract(-x)/(w) )\n#define smodN(x,n,w)  (sfractN((x)/(n),w)*(n))\n#define sfloorN(x,w)   max( floor(x), x - sfractN(x,w) )\n\nfloat nonzero(float x, float minval) {\n  return x >= 0. ? x+exp(-x)*minval : x-exp(x)*minval;\n}\n\nfloat nonzero(float x) {\n  return nonzero(x, 1.);\n}\n\nfloat powX(float x, float f) {\n  return x > 0. ? pow(x, f) : x < 0. ? -pow(-x, f) : 0.;\n}\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat calc(in vec2 fragCoord, float size, float angle, float kx, float ky, vec2 offset) {\n  vec2 stretch = fragCoord - iResolution.xy * 1.5 / 2.0 * sin(iTime/vec2(11.,19.));\n  //float r = distance(vec2(0), fragCoord.xy) / iResolution.x * 4.;\n  //float rr = 1.+sin(r*6.*(sin(iTime*0.04)/3.))/6.*powX(sin(iTime/3.),14.)*0.5;\n  vec2 p = fragCoord.xy * rotate2d(angle + kx*stretch.x - ky*stretch.y);// * rr;\n  vec2 pmod = smodN(p + offset, size * 2.0, 1./size);\n  return max(pmod.x, pmod.y)/size/2.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float size = iResolution.x / (25.0 + powX(sin(iTime/5.5),9.)*10.);\n  float angle = iTime / 10.0;\n  float kx = sin(iTime/1.)/nonzero(iResolution.x*1.3*(1.-powX(sin(iTime/15.),5.)), 0.01);\n  float ky = powX(sin(iTime/1.4),3.)/nonzero(iResolution.x*1.3*(1.-powX(sin(iTime/22.),7.)), 0.01);\n  vec2 offset = iResolution.xy * cos(iTime/27.) * vec2(cos(iTime/15.), -sin(iTime/11.));\n  vec2 offsetC = iResolution.xy * sin(iTime/37.) * vec2(sin(iTime/31.), cos(iTime/25.)) / 5.;\n  fragCoord = fragCoord.xy - iResolution.xy / 2.0 + offsetC;\n  float k = calc(fragCoord, size, angle, kx, ky, offset);\n  //fragColor = vec4(vec3(gamma(k)), 1.0);\n  //fragColor = vec4(vec3(degamma(k)), 1.0);\n  fragColor = vec4(vec3(k), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2GRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 337, 337, 394], [396, 396, 420, 420, 447], [449, 449, 479, 479, 538], [540, 540, 564, 564, 614], [616, 616, 705, 705, 1113], [1115, 1115, 1170, 1170, 1885]], "test": "untested"}
{"id": "clB3RK", "name": "Neon worm", "author": "sh1boot", "description": "Attempt #2.  An iterated FIR filter generates mouse trails which drift around.\n\nDrag the mouse around the screen, or hold shift and drag to follow mouse faster.", "tags": ["particles", "feedback", "mousetrails"], "likes": 18, "viewed": 563, "published": 3, "date": "1673570806", "time_retrieved": "2024-07-30T18:16:15.059570", "image_code": "// from https://www.shadertoy.com/view/ll2GD3\nvec3 palette(int i) {\n    float t = float(i) * 0.0025;\n    vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0), d = vec3(0.0,0.33,0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 get_point(int i) {\n    return point_array(clamp(i, 0, num_points - 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 mask = texture(iChannel2, fragCoord / (iResolution.xy * bitmap_scale));\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word && (mask.x > 0.0 || DRAW_ALL); ++wo) {\n            int i = w * bins_per_word + wo;\n            int start = i * num_points / num_bins;\n            int end = (i + 1) * num_points / num_bins;\n            if (fract(mask.x) >= 0.5 || DRAW_ALL) {\n                vec2 p1 = get_point(start - 1).xy;\n                for (int j = start; j < end; ++j) {\n                    vec2 p2 = get_point(j).xy;\n                    float trail = 2.0 / line(fragCoord, p1, p2);\n                    trail = max(0., trail - 0.1);\n                    float fade = 1.0 - smoothstep(0.75 * float(num_points), float(num_points), float(j));\n\n                    if (SMOKEY_TRAILS) {\n                        float d = distance(p1, p2);\n                        fade *= smoothstep(-iResolution.x * 0.02, 0.0, -d);\n                    }\n                    trail = min(10., trail);\n\n                    fragColor = max(fragColor, vec4(trail * fade * palette(j), 1.0));\n                    p1 = p2;\n                }\n                if (SHOW_BOXES) fragColor.xyz = max(fragColor.xyz + 0.01, vec3(0.2));\n            }\n            mask.x = fract(mask.x * 2.0);\n        }\n        mask = mask.yzwx;\n    }\n    if (fragCoord.x < 256.0 && fragCoord.y < 192.0 && SHOW_TRANSFER) {\n        fragColor = clamp(fragColor, 0.0, 1.0) * 0.25;\n        fragColor.g += 0.5 - smoothstep(0.0, 1.0, abs(32.0 - fragCoord.y)) * 0.5;\n        float x = fragCoord.x * float(window_length) / 256.0;\n        x = round(x);\n        float y = 96.0 * window(x);\n        fragColor += 1.0 - smoothstep(1.0, 2.0, abs(y + 32.0- fragCoord.y));\n    } \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Set the first particle to the mouse position, then apply a FIR filter with time offset across the list of particles to produce wobbly trails.\n\n\nvec4 random_walk(vec4 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p *= (1.0 / iResolution.xy).xyxy;\n    p += (nrand2(vec2(iTime, 0)) * mat2(c,s,-s,c)).xyxy * 0.008;\n    c = cos(iTime * 3.5), s = sin(iTime * 3.1);\n    p += (nrand2(vec2(iTime, 1)) * mat2(c,s,-s,c)).xyxy * 0.007;\n    p += (0.5 - p) * 0.02;\n    p *= iResolution.xyxy;\n    return p;\n}\n\nvec4 get_mouse_or_whatever() {\n    vec4 previous = iFrame < 1 ? iResolution.xyxy * 0.5 : point_array(0);\n\n    if (RESPONSIVE_MOUSE) return iMouse;\n\n    if (iMouse.z <= 0.0) {\n        return random_walk(previous);\n    }\n\n    previous.xy += (iMouse.xy - previous.xy) * 0.1;\n    return previous;\n}\n\n\nvec4 get_point(int i) {\n    return point_array(clamp(i, 0, num_points - 1));\n}\n\nvec4 get_filtered_point(int i) {\n    vec4 result = vec4(0.0);\n    float window_sum = 0.0;\n    for (int j = 0; j <= window_length; ++j) {\n        float w = window(float(j));\n        window_sum += w;\n        result += w * get_point(i + j - window_offset);\n    }\n    return result / window_sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int i = point_index(fragCoord);\n    if (i >= num_points) discard;\n\n    if (iFrame < 1 || i < 1) {\n        fragColor = get_mouse_or_whatever();\n        return;\n    }\n\n    fragColor = get_filtered_point(i);\n\n    vec2 g = (0.6 * vec2(cos(iTime * 0.27), sin(iTime * 0.27)) + 0.5) * iResolution.xy;\n    fragColor += 0.0003 * (g.xyxy - fragColor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RESPONSIVE_MOUSE KBD_HOLD(16)  // shift -- go directly to mouse, without smoothing filter\n#define DRAW_ALL KBD_TGGL(9)           // tab toggles bounding box optimisation\n#define SHOW_BOXES KBD_TGGL(48)        // '0' toggles bounding box highlight\n#define SMOKEY_TRAILS KBD_TGGL(49)     // '1' toggles fade over-stretched lines[1]\n#define FILTER_2 KBD_TGGL(50)          // '2' toggles filter 2 (overrides filter 3)\n#define FILTER_3 KBD_TGGL(51)          // '3' toggles filter 3\n#define SHOW_TRANSFER KBD_TGGL(57)     // '9' toggles transfer function view\n\n#define KBD_HOLD(key) (texelFetch(iChannel3, ivec2(key,0), 0).x >= 0.5)\n#define KBD_TGGL(key) (texelFetch(iChannel3, ivec2(key,2), 0).x >= 0.5)\n\n\n\n// [1] \"over-stretched lines\" dims line segments according to their length.\n// Look around the tail where it starts to flick out more and you'll see\n// only the corners of the line are visible as they fly away from the body.\n\n\nconst int num_points = 1024;\nconst int point_array_stride = int(sqrt(float(num_points)));\nconst int num_bins = 96;\nconst int bin_array_stride = int(sqrt(float(num_bins)));\n\nconst int window_length = 32;\nconst int window_offset = window_length / 2;\n\nconst int neighbours = 1;  // lines must connect with neighbouring bin points.\nconst float radius = 12.0;  // a bit of slop for line width, glow, and interpolation overshoot\n\nconst float bitmap_scale = 8.0;\n\nconst float pi = 3.14159265358979;\n\n#define point_array(i) array(i, iChannel0, point_array_stride)\n#define bin_array(i) array(i, iChannel1, bin_array_stride)\n\nint point_index(vec2 fc) {\n    return int(fc.x) + int(fc.y) * point_array_stride;\n}\n\nint bin_index(vec2 fc) {\n    return int(fc.x) + int(fc.y) * bin_array_stride;\n}\n\nvec4 array(int i, sampler2D tex, int tw) {\n    return texelFetch(tex, ivec2(i % tw, i / tw), 0);\n}\n\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n * vec2(-3.2145, 1.2345)),\n                                    nrand(n * vec2(-5.4321, 3.4521))); }\nfloat sinc(float x) {\n    if (x == 0.0) return 1.0;\n    x *= pi;\n    return sin(x) / x;\n}\n\nfloat sincshelf(float x, float f0, float f1) {\n    return sinc(x * f1) - sinc(x * f0);\n}\n\nfloat legacy_window(float);\n\n#define window(x) window_ex(x, FILTER_2, FILTER_3)\nfloat window_ex(float x, bool filter_2, bool filter_3) {\n    // Tinker here...`\n\n    if (filter_2) {\n        return legacy_window(x);\n    }\n    x -= float(window_offset);\n    if (filter_3) {\n        return sinc(    (x + 5.00) * 0.30) * 1.0\n             + sincshelf(x + 1.00, 0.01, 0.04) * 0.005\n             - sincshelf(x + 1.50, 0.06, 0.20) * 0.004\n             ;\n    }\n    return sinc(    (x + 5.00) * 0.31) * 1.0\n         + sincshelf(x + 5.55, 0.02, 0.04) * 0.03\n         - sincshelf(x + 0.00, 0.08, 0.20) * 0.05\n       //  + sincshelf(x + 1.03, 0.3, 0.40) * 0.06\n         ;\n}\n\n\nfloat cubic(float t) {\n    const float a = -0.5;\n    t = abs(t);\n    float t3 = t * t * t;\n    float t2 = t * t;\n    if (t <= 1.) return (a + 2.) * t3 - (a + 3.) * t2 + 1.;\n    if (t < 2.) return a * t3 - 5. * a * t2 + 8. * a * t - 4. * a;\n    return 0.;\n}\n\nvec2 interpolate(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\nfloat interpolate(float p0, float p1, float p2, float p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\n\nfloat window_lut(int i) {\n    const float mumble[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    if (!(0 < i && i < mumble.length())) return 0.0;\n    return mumble[i];\n}\n\nfloat legacy_window(float x) {\n    const float window[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    x *= 8.0 / float(window_length);\n    float wf = fract(x);\n    int i = int(x);\n    return interpolate(window_lut(i - 1),\n                       window_lut(i - 0),\n                       window_lut(i + 1),\n                       window_lut(i + 2), wf);\n}\n\n\n// Line SDF from Inigo Quilez\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba);\n}\n\nfloat spline(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 i125 = interpolate(p0, p1, p2, p3, 0.25);\n    vec2 i150 = interpolate(p0, p1, p2, p3, 0.5);\n    vec2 i175 = interpolate(p0, p1, p2, p3, 0.75);\n    float l0 = line(p, p1,   i125);\n    float l1 = line(p, i125, i150);\n    float l2 = line(p, i150, i175);\n    float l3 = line(p, i175, p2);\n    return min(min(l0, l1), min(l2, l3));\n}\n\n", "buffer_b_code": "// Separate particles into a set of bins and generate bounding boxes for each bin.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = bin_index(fragCoord);\n    if (i >= num_bins) discard;\n\n    fragColor = vec4(1,1,-1,-1) * 1000000.0;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    for (int j = start; j < end; j++) {\n        // TODO: Do the cubic interpolation here to make sure we consider overshoot.\n        fragColor.xy = min(fragColor.xy, point_array(j).xy);\n        fragColor.zw = max(fragColor.zw, point_array(j).xy);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// For each pixel, produces a bitmap of bins which are relevant.\n\nconst vec4 test_window = vec4(-1,-1,1,1) * radius + vec4(0,0,1,1) * bitmap_scale;\n\n\nbool near_any_points(vec2 c, int i) {\n    c += bitmap_scale * 0.5;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    vec2 p0 = point_array(start).xy;\n    for (int j = start + 1; j < end; ++j) {\n        vec2 p1 = point_array(j).xy;\n        if (line(c, p0, p1) < (radius + bitmap_scale)) return true;\n        p0 = p1;\n    }\n    return false;\n}\n\nbool small_box(vec4 box) {\n    return distance(box.xy, box.zw) < radius * radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= bitmap_scale;\n    if (!all(lessThan(fragCoord, iResolution.xy))) discard;\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word; ++wo) {\n            int i = w * bins_per_word + wo;\n#if 1\n            vec4 box = bin_array(i) + test_window;\n#else\n            // does buffer B really help?\n            const vec4 box = vec4(-1,-1,1,1) * 1000000.0;\n#endif\n            fragColor.x *= 2.0;\n            if (all(bvec4(lessThan(box.xy, fragCoord), lessThan(fragCoord, box.zw)))) {\n                if (small_box(box) || near_any_points(fragCoord, i)) {\n                    fragColor.x += 1.0;\n                }\n            }\n        }\n        fragColor = fragColor.yzwx;\n    }\n    fragColor *= pow(2.0, -float(num_bins / 4));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clB3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 67, 67, 252], [254, 254, 277, 277, 332], [334, 334, 389, 389, 2201]], "test": "untested"}
{"id": "mtj3zK", "name": "depth of field focus study 34", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 5, "viewed": 207, "published": 3, "date": "1673559662", "time_retrieved": "2024-07-30T18:16:15.890349", "image_code": "// Fork of \"depth of field focus study 32\" by morisil. https://shadertoy.com/view/NlKXzz\n// 2023-01-12 21:37:33\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-12-21 13:06:50\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .6;\nconst float CHROMATIC_ABBERATION = .01;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .5;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    st = vec2((cos(st.x * 3.) * .5 + .5),  (cos(st.y * 3.) * .5 + .5));\n    st *= cos(iTime * .005) * 2.0;\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .05), cos(iTime * .03));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.3 + getColorComponent(center, modScale, blur) * .5;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtj3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 536, 536, 772], [774, 774, 829, 829, 1835]], "test": "untested"}
{"id": "ct23RV", "name": "Mean Curvature Motion", "author": "Gegell", "description": "This implements a simple iterative solver for the MCM differential equation.\nIt tries to shrink the length of the boundaries of segments within the image.\n\nClick + drag for different debug views.", "tags": ["iterative", "segmentation", "mcm"], "likes": 3, "viewed": 255, "published": 3, "date": "1673558594", "time_retrieved": "2024-07-30T18:16:16.736088", "image_code": "#define SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fetch the current iteration data\n    vec4 buffer = vec4(loadTex(fragCoord));\n    \n    // Compute the same intermediate values, which are also used for the actual computation in Buffer A.\n    vec2 gradient = gradient(fragCoord);\n    mat2 hessian = hessian(fragCoord);\n    float laplacian = hessian[0][0] + hessian[1][1];\n    \n    vec2 nGradient = normalizeSafe(gradient);\n    float delta = laplacian - dot(nGradient, hessian*nGradient);\n    \n    \n    switch(int(clamp(iMouse.x / iResolution.x, 0., 1.) * 5.)) {\n    // Actual output\n    case 0: \n        fragColor = buffer;\n        break;\n    // Debug views\n    case 1: // Show hessian matrix entries\n        fragColor = abs(vec4(hessian[0][0], hessian[1][1], hessian[0][1], 0) * 300.);\n        break;\n    case 2: // Show gradient\n        fragColor = vec4(gradient, 0, 0) * 100.;\n        break;\n    case 3: // Laplacian\n        fragColor = vec4(laplacian) * 1000.;\n        break;\n    case 4: // applied delta\n        fragColor = vec4(delta, 0, -delta, 1) * 1000.;\n        break;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prev = vec4(loadTex(fragCoord));\n    if (iFrame < 10) {\n        prev = texture(iChannel1, fragCoord/iResolution.xy).xxxx;\n    }\n    \n    vec2 gradient = gradient(fragCoord);\n    mat2 hessian = hessian(fragCoord);\n    float laplacian = hessian[0][0] + hessian[1][1];\n    \n    // Actually compute the delta as given by the mcm equation\n    // ∂t u = Δu - 1/|∇u|^2 * ∇u^T * Hess(u) * ∇u\n    gradient = normalizeSafe(gradient);\n    float delta = laplacian - 1. * dot(gradient, hessian*gradient);\n    \n    // If the above factor `1.` is increased slightly, e.g. 1.1 we observe a slight sharpening of the boundaries\n\n    // Iteratively apply the smoothing value, semi-stable up to timestep size .5\n    fragColor = prev + .45 * delta;\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define normalizeSafe(v) (v * min(1./length(v), 1e20))\n\nfloat loadTex( sampler2D source, vec2 p ) {\n    vec2 ts = vec2(textureSize(source, 0));\n    return texture(source, p/ts).x;\n}\n\nuniform sampler2D SOURCE_TEXTURE;\nfloat loadTex( vec2 p ) {\n    return loadTex(SOURCE_TEXTURE, p);\n}\n\nvec2 gradient( vec2 p ) {\n    return vec2(\n        loadTex(p + vec2(1, 0)) - loadTex(p + vec2(-1, 0)),\n        loadTex(p + vec2(0, 1)) - loadTex(p + vec2(0, -1))\n    ) * 0.5;\n}\n\nmat2 hessian( vec2 p ) {\n    mat2x2 hessian;\n    hessian[0][0] = loadTex(p + vec2(-1,  0)) - 2. * loadTex(p) + loadTex(p + vec2(1, 0));\n    hessian[1][1] = loadTex(p + vec2( 0, -1)) - 2. * loadTex(p) + loadTex(p + vec2(0, 1));\n    hessian[0][1] = 0.25*(loadTex(p + vec2(-1, -1)) - loadTex(p + vec2(1, -1)) - loadTex(p + vec2(-1, 1)) + loadTex(p + vec2(1, 1)));\n    hessian[1][0] = hessian[0][1];\n    return hessian;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct23RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 131, 1133]], "test": "untested"}
{"id": "Dt23zV", "name": "Corner audio link", "author": "Iliana", "description": "Corner color flash", "tags": ["audiolink"], "likes": 1, "viewed": 108, "published": 3, "date": "1673553974", "time_retrieved": "2024-07-30T18:16:17.592797", "image_code": "\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = I/iResolution.xy;\n    \n    // Read data\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    Data data = readData(iChannel0, invRes);\n    \n\n    float tr = uv.x*uv.y;\n    float tl = (1.-uv.x)*uv.y;\n    float br = uv.x*(1.-uv.y);\n    float bl = (1.-uv.x)*(1.-uv.y);\n    \n\n    // Get data\n    float bands[4] = toArr(data.bands);\n    float facs[4] = toArr(data.correctedFac);\n    float avgs[4] = toArr(data.averages);\n    float mins[4] = toArr(data.mins);\n    float maxs[4] = toArr(data.maxs);\n    \n    vec3 col =  vec3(0.8,0.8,0.4)*tr * bands[0] + \n                vec3(0.2,0.6,0.9)*tl * bands[1] + \n                vec3(0.9,0.4,0.9)*br * bands[2] +\n                vec3(0.2,0.8,0.2)*bl * bands[3];\n    \n    vec3 dbgCol = debugBands(bands, facs, avgs, mins, maxs, I, iResolution);\n    col = mix(col, dbgCol, 0.);\n    O = vec4(col, 1.);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float readData1(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).r;\n}\nvec3 readData3(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value) {\n    if (floor(fragCoord.x) == float(id))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value) {\n    if (floor(fragCoord.x) == float(id))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value) {\n    if (floor(fragCoord.x) == float(id))\n        col = value;\n        \n    return col;\n}\n\n// Convert vec4 to float[4]\nfloat[4] toArr(vec4 values)\n{\n    float res[4];\n    res[0]=values.r;\n    res[1]=values.g;\n    res[2]=values.b;\n    res[3]=values.a;\n    return res;\n}\n\n\n// Convert float[4] to vec4\nvec4 toVec(float arr[4])\n{\n    return vec4(arr[0],arr[1],arr[2],arr[3]);\n}\n\n// Data for transmission\nstruct Data\n{\n    float volume;\n    vec4 bands;\n    vec4 lastBands;\n    vec4 averages;\n    vec4 correctedFac;\n    vec4 mins;\n    vec4 maxs;\n};\n\n\n// Read data\nData readData(sampler2D tex, vec2 invRes) {\n\tData data;\n    data.volume = readData1(tex, 0);\n    data.bands = readData4(tex, 1);\n    data.lastBands = readData4(tex, 2);\n    data.averages = readData4(tex, 3);\n    data.correctedFac = readData4(tex, 4);\n    data.mins = readData4(tex, 5);\n    data.maxs = readData4(tex, 6);\n    return data;\n}\n\n// Write data\nvec4 writeData(vec4 col, vec2 fragCoord, Data data) {\n    col = writeData(col, fragCoord.xy, 0, data.volume);\n    col = writeData(col, fragCoord.xy, 1, data.bands);\n    col = writeData(col, fragCoord.xy, 2, data.lastBands);\n    col = writeData(col, fragCoord.xy, 3, data.averages);\n    col = writeData(col, fragCoord.xy, 4, data.correctedFac);\n    col = writeData(col, fragCoord.xy, 5, data.mins);\n    col = writeData(col, fragCoord.xy, 6, data.maxs);\n    return col;\n}\n\n\n\nvec3 debugBands(float bands[4], float facs[4], float avgs[4], float mins[4], float maxs[4], vec2 fragCoord, vec3 iResolution)\n{\n    // Number of values per band\n    int count = 5;\n\n    // Color levels\n    float lvl1 = 0.;\n    float lvl2 = 0.;\n    float lvl3 = 0.;\n    \n    // Get index of the value according to the position on the screen\n    int index = int(floor(fragCoord.x/iResolution.x*4.*float(count)));\n    \n    \n    // Draw bands on screen\n    if (index%count == 0 && bands[index/count]*iResolution.y > fragCoord.y) {lvl1 = 1.;} // Raw band\n    if (index%count == 1 && facs[index/count]*iResolution.y > fragCoord.y) {lvl2 = 1.;} // Output factor\n    //if (index%count == 2 && avgs[index/count]*iResolution.y > fragCoord.y) {lvl3 = 1.;} // Averages\n    //if (index%count == 3 && mins[index/count]*iResolution.y > fragCoord.y) {lvl3 = 1.; lvl2 = 1.;} // Minimums\n    //if (index%count == 4 && maxs[index/count]*iResolution.y > fragCoord.y) {lvl1 = 1.; lvl2 = 1.;} // Maximums\n    \n    // Convert to color\n    return vec3(lvl1, lvl2, lvl3);\n}\n", "buffer_a_code": "\n// Audio functions ----------------------------------------------\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\n\nfloat getVol(float samples) {\n    float avg = 0.5;\n    for (float i = 0.; i < samples; ++i) avg += getLevel(i/samples);\n    return avg / samples;\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --------------------------------------------------------------\n\n// Sample audio from a start freq to end freq (0.0 - 1.0) at *samples* positions\nfloat sampleAvg(float start, float end, float samples, bool mode)\n{\n    float delta = (end - start) / samples;\n    float res = 0.001;\n    if (!mode)\n    {\n    \n        for (float i = start; i < end; i+= delta)\n        {\n            res += getPitch(i, 0.7);\n        }\n        return res / samples;\n    }\n    else\n    {\n        for (float i = start; i < end; i+= delta)\n        {\n            res = max(getPitch(i, 0.7), res);\n        }\n        return res;\n    }\n}\n\n// Compute the minimums for each band with smoothing\nvoid computeMins(inout float mins[4], float bands[4], float avgs[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        mins[i] = min((mins[i]*fsmooth + avgs[i]) / (fsmooth + 1.), bands[i]);\n    }\n}\n\n// Compute the maximums for each dand with smoothing\nvoid computeMaxs(inout float maxs[4], float bands[4], float avgs[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        maxs[i] = max((maxs[i]*fsmooth + avgs[i]) / (fsmooth + 1.), bands[i]);\n    }\n}\n\n// Compute averages with smoothing\nvoid computeAverages(inout float avgs[4], float bands[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        //avgs[i] = smoothstep(avgs[i],bands[i], 0.1);\n        avgs[i] = (avgs[i]*fsmooth + bands[i]) / (fsmooth + 1.);\n    }\n}\n\n// Get thresholds by two methods and make a ratio between the two.\n// Method 1:\n// Use a position between the min and max as the threshold\n// min ........... max\n//             ^\n//             Threshold\n//\n// Method 2:\n// Use the average as the threshold.\nfloat[4] getThresholds(float mins[4], float maxs[4], float avgs[4], float minmaxRatio, float avgsRatio)\n{\n    float res[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        float thresh = smoothstep(mins[i], maxs[i], minmaxRatio);\n        res[i] = smoothstep(thresh, avgs[i], avgsRatio);\n    }\n    return res;\n}\n\n\n// If under threshold, return 0.0, if over, return 1.0\nvoid setCorrectedFacs(out float facs[4], float thresh[4], float bands[4])\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        facs[i] = 0.;\n        if (bands[i] > thresh[i]) facs[i] = 1.;\n    }\n}\n\n\n// Scale the band from 0.0 to 1.0 according to min and max\nvoid setScales(out float facs[4], float bands[4], float mins[4], float maxs[4])\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        facs[i] = (bands[i] - mins[i]) / (maxs[i] - mins[i]);\n    }\n}\n\n\n// If instant peek is found, apply it to the output\nvoid applyDerivative(inout float facs[4], float lastBands[4], float bands[4], float fsmooth)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        if (lastBands[i] < bands[i])\n        {\n            float delta = bands[i] - lastBands[i];\n            facs[i] += delta * fsmooth;\n        }\n    }\n}\n\n// Output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read data\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    Data data = readData(iChannel1, invRes);\n    \n    // Run only once per frame\n    if (fragCoord.y > .5 && fragCoord.x > 0.5)\n    {\n        fragColor = writeData(fragColor, fragCoord, data);\n        return; // Returns if this is not the first pixel\n    }\n    \n    // Frequency separators (0.0-1.0)\n    float s1 = 0.1;\n    float s2 = 0.5;\n    float s3 = 0.8;\n\n    \n    // Get global volume\n    data.volume = getVol(30.);\n    data.lastBands = data.bands;\n    \n    // Get bands from audio\n    float bands[4] = toArr(data.bands);\n    bands[0] = sampleAvg(0.,s1, 5.,true)/(data.volume*.5);\n    bands[1] = sampleAvg(s1,s2, 10.,true)/(data.volume*0.3);\n    bands[2] = sampleAvg(s2,s3, 15.,true)/(data.volume*.2);\n    bands[3] = sampleAvg(s3,1., 20.,true)/(data.volume*.1);\n    \n    // Get values from last frame\n    float[4] mins = toArr(data.mins);\n    float[4] maxs = toArr(data.maxs);\n    float[4] avgs = toArr(data.averages);\n    float[4] lastBands = toArr(data.lastBands);\n    \n    \n    // Compute the new values\n    computeAverages(avgs, bands, 20.);\n    computeMins(mins, bands, avgs, 20.);\n    computeMaxs(maxs, bands, avgs, 20.);\n    \n    // Get thresholds for bands\n    float thresh[4] = getThresholds(mins, maxs, avgs, 0.1, 0.4);\n    \n    // Get factors calculated from thresholds\n    float facs[4];\n    setCorrectedFacs(facs, thresh, bands);\n    applyDerivative(facs, lastBands, bands, 5.);\n    \n    // Get factors scaled from 0.0 to 1.0 from min and max\n    float facs2[4];\n    setScales(facs2, bands, mins, maxs);\n    \n\n    // Update data\n    data.bands = toVec(bands);\n    data.mins = toVec(mins);\n    data.maxs = toVec(maxs);\n    data.averages = toVec(avgs);\n    \n    // If global volume is close to zero, prevent x / ~0 = almost infinity;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (data.volume < 0.8) facs[i] = smoothstep(facs[i], 0., data.volume/.8);\n    }\n    \n    // Set new corrected data band\n    data.correctedFac = toVec(facs) * toVec(facs2);\n    \n    // Write data\n    fragColor = writeData(fragColor, fragCoord, data);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt23zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 92, 937]], "test": "untested"}
{"id": "clj3zV", "name": "SDF raymarching w/ materials", "author": "balt", "description": "Heavily based off of https://www.shadertoy.com/view/4tcGDr.", "tags": ["3d", "raymarching", "distancefield"], "likes": 0, "viewed": 149, "published": 3, "date": "1673550895", "time_retrieved": "2024-07-30T18:16:18.354760", "image_code": "const float EPSILON = 0.001;\nconst int STEPS = 256;\nconst float NEAR_PLANE = 0.0;\nconst float FAR_PLANE = 100.0;\n\n// Utility\n\nfloat lerp(float a, float b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec2 angleToVec2(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Rotation matrices\n\nmat3 rotX(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  1.0,  0.0,  0.0),\n        vec3(  0.0,  v.x, -v.y),\n        vec3(  0.0,  v.y,  v.x)\n    );\n}\n\nmat3 rotY(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  v.x,  0.0,  v.y),\n        vec3(  0.0,  1.0,  0.0),\n        vec3( -v.y,  0.0,  v.x)\n    );\n}\n\nmat3 rotZ(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  v.x, -v.y,  0.0),\n        vec3(  v.y,  v.x,  0.0),\n        vec3(  0.0,  0.0,  1.0)\n    );\n}\n\n// Transformations\n\nvec3 screenToCameraRay(float fov, vec2 pos) {\n    vec2 xy = pos - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat3 makeCameraWorldMatrix(vec3 e, vec3 c, vec3 up) {\n    vec3 f = normalize(c - e);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// Signed Distance Functions - Primitives\n\nstruct sdfOutput {\n    float signedDistance;\n    vec3 diffuseColor;\n    float roughness;\n    float specularStrength;\n};\n\nsdfOutput sphereSDF(vec3 pos, float radius, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        length(pos) - radius, \n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput metaballSDF(vec3 pos, float threshold, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        (-threshold / length(pos)) + 1.0, \n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput boxSDF(vec3 pos, vec3 size, vec3 color, float roughness, float specularStrength){\n    vec3 q = abs(pos) - size;\n    return sdfOutput(\n        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),\n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput planeSDF(vec3 pos, vec3 normal, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        dot(pos, normal),\n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput coneSDF(vec3 p, vec2 rh, vec3 color, float roughness, float specularStrength){\n    vec2 q = rh.y*vec2(rh.x,-1.0);\n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sdfOutput(\n        sqrt(d)*sign(s),\n        color, roughness, specularStrength\n    );\n}\n\n// Signed Distance Functions - Operations\n\nsdfOutput unionSDF(sdfOutput a, sdfOutput b) {\n    if (a.signedDistance < b.signedDistance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nsdfOutput intersectSDF(sdfOutput a, sdfOutput b) {\n    if (a.signedDistance > b.signedDistance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nsdfOutput differenceSDF(sdfOutput a, sdfOutput b) {\n    return intersectSDF(a, sdfOutput(\n        -b.signedDistance,\n        b.diffuseColor,\n        b.roughness,\n        b.specularStrength)\n    );\n}\n\nsdfOutput addSDF(sdfOutput a, sdfOutput b) {\n    return sdfOutput(\n        a.signedDistance + b.signedDistance,\n        lerp(a.diffuseColor, b.diffuseColor, 0.5),\n        lerp(a.roughness, b.roughness, 0.5),\n        lerp(a.specularStrength, b.specularStrength, 0.5)\n    );\n}\n\nsdfOutput lerpSDF(sdfOutput a, sdfOutput b, float t) {\n    return sdfOutput(\n        lerp(a.signedDistance, b.signedDistance, t),\n        lerp(a.diffuseColor, b.diffuseColor, t),\n        lerp(a.roughness, b.roughness, t),\n        lerp(a.specularStrength, b.specularStrength, t)\n    );\n}\n\nsdfOutput invertSDF(sdfOutput a) {\n    return sdfOutput(\n        -a.signedDistance,\n        a.diffuseColor,\n        a.roughness,\n        a.specularStrength\n    );\n}\n\n\n\n// Signed Distance Functions - Scene\n\nsdfOutput sceneSDF(vec3 samplePoint) {   \n    return unionSDF(\n        unionSDF(\n        unionSDF(\n        sphereSDF(\n            samplePoint + vec3(2.0, -1.0, 0.0),\n            1.0,\n            vec3(0.2, 0.7, 0.1),\n            0.7,\n            16.0\n        ),\n        boxSDF(\n            rotY(radians(20.0)) * rotX(radians(10.0)) * (samplePoint + vec3(-1.2, 1.0, 2.0)),\n            vec3(1.0),\n            vec3(0.1, 0.6, 1.0),\n            0.7,\n            2.0\n        )),\n        planeSDF(\n            samplePoint + vec3(0.0, 3.0, 0.0),\n            vec3(0.0, 1.0, 0.0),\n            vec3(ceil((sin((rotY(radians(45.0)) * samplePoint).x * 4.0) + sin((rotY(radians(45.0)) * samplePoint).z * 4.0)) / 2.0)),\n            1.0,\n            16.0\n        )),\n        coneSDF(\n            samplePoint + vec3(-3.0, -2.0, -2.0),\n            vec2(0.5, 2.0),\n            vec3(1.0, 0.1, 0.1),\n            0.7,\n            32.0\n        )\n    );\n}\n\n// Signed Distance Function - Calculation\n\nvec3 calcNormal(vec3 pos) {\n    return normalize(vec3(\n        sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z)).signedDistance - sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z)).signedDistance,\n        sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z)).signedDistance - sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z)).signedDistance,\n        sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON)).signedDistance - sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON)).signedDistance\n    ));\n}\n\n// Illumination\n\nconst vec3 GLOBAL_COLOR = vec3(0.0);\nconst vec3 CLEAR_COLOR = vec3(0.0);\nconst vec3 AMBIENT_COLOR = vec3(0.2);\n\nstruct light{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nvec3 lightSDF(vec3 cameraRay, vec3 position, vec3 normal, vec3 diffuse, float roughness, float specularity) {\n    light[] LIGHTS = light[](\n        light(\n            vec3(0.0, 5.0, 0.0),\n            vec3(1.0),\n            20.0\n        )\n    );\n    vec3 finalColor = GLOBAL_COLOR;\n    for (int i = 0; i < LIGHTS.length(); i++) {\n        vec3 lightDir = normalize(LIGHTS[i].position - position);\n        \n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 diffuseLight = diff * LIGHTS[i].color;\n        \n        float lightDistance = distance(position, LIGHTS[i].position); \n        vec3 reflectDir = reflect(lightDir, normal);\n        float spec = pow(max(dot(cameraRay, reflectDir), 0.0), specularity);\n        vec3 specularLight = roughness * spec * LIGHTS[i].color;\n        \n        float lightStrength = (1.0 - (lightDistance / LIGHTS[i].radius));\n        finalColor += diffuse * (diffuseLight * lightStrength) +\n            (diffuse * AMBIENT_COLOR) +\n            specularLight * lightStrength;\n    }\n    \n    return finalColor;\n}\n\n// Main\n\nstruct sdOutput{\n    float depth;\n    sdfOutput sdf;\n};\n\nsdOutput surfaceDist(vec3 camera, vec3 ray) {\n    float depth = NEAR_PLANE;\n    for (int i = 0; i < STEPS; i++) {\n        sdfOutput sdf = sceneSDF(camera + depth * ray);\n        float dist = sdf.signedDistance;\n        if (dist < EPSILON) {\n            return sdOutput(depth, sdf);\n        }\n        depth += dist;\n        if (depth >= FAR_PLANE) {\n            return sdOutput(FAR_PLANE, sdfOutput(0.0, vec3(0.0), 0.0, 0.0));\n        }\n    }\n    return sdOutput(FAR_PLANE, sdfOutput(0.0, vec3(0.0), 0.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(CLEAR_COLOR, 1.0);\n    vec3 cameraRay = screenToCameraRay(65.0, fragCoord);\n    vec3 cameraFocus = vec3(0.0, (sin(iTime / 2.0) * 1.5), 0.0);\n    vec3 cameraPos = vec3(sin(iTime) * 12.0, 3.0, cos(iTime) * 12.0);\n    mat3 cameraWorldMatrix = makeCameraWorldMatrix(\n        cameraPos,\n        -cameraFocus,\n        vec3(0.0, 1.0, 0.0)\n    );\n    vec3 worldRay = cameraWorldMatrix * cameraRay;\n    sdOutput sdOut = surfaceDist(cameraPos, worldRay);\n    float d = sdOut.depth;\n    vec3 hitPos = cameraPos + d * worldRay;\n    \n    if (d > FAR_PLANE - EPSILON) {\n        return;\n    }\n    \n    vec3 normal = calcNormal(hitPos);\n    // Output to screen\n    fragColor = vec4(lightSDF(worldRay, hitPos, normal, sdOut.sdf.diffuseColor, sdOut.sdf.roughness, sdOut.sdf.specularStrength), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clj3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 165, 165, 201], [203, 203, 239, 239, 275], [277, 277, 313, 313, 349], [351, 351, 387, 387, 423], [425, 425, 456, 456, 499], [501, 501, 523, 523, 692], [716, 716, 740, 740, 897], [899, 899, 923, 923, 1080], [1082, 1082, 1106, 1106, 1263], [1285, 1285, 1330, 1330, 1465], [1468, 1468, 1521, 1521, 1645], [1811, 1811, 1908, 1908, 2013], [2015, 2015, 2117, 2117, 2234], [2236, 2236, 2327, 2327, 2492], [2494, 2494, 2589, 2589, 2689], [2691, 2691, 2779, 2779, 3194], [3239, 3239, 3285, 3285, 3389], [3391, 3391, 3441, 3441, 3545], [3547, 3547, 3598, 3598, 3745], [3747, 3747, 3791, 3791, 4021], [4023, 4023, 4077, 4077, 4309], [4311, 4311, 4345, 4345, 4475], [4517, 4517, 4555, 4555, 5446], [5491, 5491, 5518, 5518, 5953], [7274, 7274, 7319, 7319, 7786], [7788, 7788, 7845, 7845, 8649]], "test": "untested"}
{"id": "ctjGRK", "name": "Wave flow", "author": "michael0884", "description": "Direction of k vector for waves", "tags": ["wave"], "likes": 8, "viewed": 261, "published": 3, "date": "1673547030", "time_retrieved": "2024-07-30T18:16:19.247374", "image_code": "vec2 kvec(vec2 U)\n{\n    vec2 dadxy = vec2(A(U + vec2(1.0, 0.0)).x, A(U + vec2(0.0, 1.0)).x) - vec2(A(U - vec2(1.0, 0.0)).x, A(U - vec2(0.0, 1.0)).x);\n    float dadt = A(U).y;\n    \n    vec2 d2adtxy = vec2(A(U + vec2(1.0, 0.0)).y, A(U + vec2(0.0, 1.0)).y) - vec2(A(U - vec2(1.0, 0.0)).y, A(U - vec2(0.0, 1.0)).y);\n    float a = A(U).x;\n    \n    vec2 dir2 = -normalize(d2adtxy*a/(a*a+0.001));\n    vec2 dir1 = normalize(dadxy*dadt/(dadt*dadt+0.00001));\n    \n    return (abs(dadt) < 0.5*abs(a))?dir2:dir1;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 coloring(vec2 delta)\n{\n    float ang = atan(delta.y, delta.x);\n    float d = length(delta);\n    return hsv2rgb(vec3(ang/(2.0*3.14159), 1., d));\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    //render\n    vec4 t = 10.*A(U); \n    //color = amplitude\n    Q.xyz = vec3(1,0,0)*t.x - vec3(0,0,1)*t.x + vec3(0.,0.5,0.)*abs(t.x);\n    vec2 f = vec2(t.x, t.y*2.0);\n    Q.xyz  = coloring(kvec(U));\n    //Q.xyz = vec3(0.25*dot(f,f));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n//a way to sample pixels shorthand \n#define A(U) texelFetch(iChannel0,ivec2(clamp(U, vec2(0.0), R-1.0)),0)\n", "buffer_a_code": "//the time step\n#define dt 0.4\n\n//boundary thickness\n#define l 0.0\n\n\nfloat laplacian(vec2 pos)\n{\n    return A(pos+vec2(0,1)).x + A(pos-vec2(0,1)).x + A(pos+vec2(1,0)).x + A(pos-vec2(1,0)).x - 4.0*A(pos).x;\n}\n\nvec2 kvec(vec2 U)\n{\n    vec2 dadxy = vec2(A(U + vec2(1.0, 0.0)).x, A(U + vec2(0.0, 1.0)).x) - vec2(A(U - vec2(1.0, 0.0)).x, A(U - vec2(0.0, 1.0)).x);\n    float dadt = A(U).y;\n    \n    vec2 d2adtxy = vec2(A(U + vec2(1.0, 0.0)).y, A(U + vec2(0.0, 1.0)).y) - vec2(A(U - vec2(1.0, 0.0)).y, A(U - vec2(0.0, 1.0)).y);\n    float a = A(U).x;\n    \n    vec2 dir2 = -normalize(d2adtxy*a/(a*a+0.001));\n    vec2 dir1 = normalize(dadxy*dadt/(dadt*dadt+0.00001));\n    \n    return (abs(dadt) < 0.5*abs(a))?dir2:dir1;\n}\n\nvec2 newField(vec2 pos)\n{\n    vec2 field = A(pos).xy;\n    float time = float(iFrame) * dt;\n    float force = 0.01*exp(-0.1*dot(pos-0.5*R,pos-0.5*R))*cos(0.5*time);\n    force += 0.01*exp(-0.1*dot(pos-0.4*R,pos-0.4*R))*cos(0.25*time);\n    //force += 0.025*exp(-0.025*dot(pos-0.6*R,pos-0.6*R))*cos(0.125*time);\n    field.y += dt*(laplacian(pos) + force); //velocity += force * time step\n    field.x += dt*field.y; //position += velocity*time step\n    return field;\n}\n\nvec2 newAbsorbed(vec2 pos, vec2 n)\n{\n    float uS = 1.0 * dt / 1.0;\n    vec2 field = A(pos).xy;\n    field.x = A(pos + n).x + (newField(pos + n).x - A(pos).x) * (uS - 1.0) / (uS + 1.0);\n    return field;\n}\n\nvoid mainImage( out vec4 field, in vec2 pos )\n{\n    pos = floor(pos);\n\n    //boundary condition\n    if(pos.x <= l) \n        field.xy = newAbsorbed(pos, vec2(1,0));\n    else if(pos.x >= R.x - 1.0 - l)\n        field.xy = newAbsorbed(pos, vec2(-1,0));\n    else if(pos.y <= l)\n        field.xy = newAbsorbed(pos, vec2(0,1));\n    else if(pos.y >= R.y - 1.0 - l)\n        field.xy = newAbsorbed(pos, vec2(0,-1));\n    else\n        field.xy = newField(pos);\n\n    //initial conditions\n    if (iFrame < 1) {\n        field.xy = vec2(0.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 502], [504, 504, 531, 531, 709], [711, 711, 738, 738, 861], [863, 863, 904, 917, 1141]], "test": "untested"}
{"id": "cljGRV", "name": "Limited Mandelbrot Zoom", "author": "megamaz", "description": "Very basic Mandelbrot zoom with limited precision. Code based off of cgmatter's fractal video. \nnote: I could probably make this faster and better somehow. not sure how though.", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 188, "published": 3, "date": "1673546390", "time_retrieved": "2024-07-30T18:16:20.042248", "image_code": "float lerp(float factor, float a, float b) {\n    return a + (b - a) * factor;\n}\n\n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // VALUES YOU CAN PLAY AROUND WITH\n    vec2 pos = vec2(-1.0121f, 0.2556f);\n    float zoomspeed = 3.0f;\n    float iter = 400.0f;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float real = uv[0];\n    float imag = uv[1];\n    \n    float col = 0.0f;\n    \n    // scalor\n    float zoom = 1.0f;\n    if(iTime >= 1.0f) {\n           zoom = pow(iTime, zoomspeed);\n    }\n    \n    real = lerp(uv[0], pos[0]-(2.2f/zoom), pos[0]+(1.0f/zoom));\n    imag = lerp(uv[1], pos[1]-(1.0f/zoom), pos[1]+(1.0f/zoom));\n    \n    float creal = real;\n    float cimag = imag;\n    \n    for(float i = 0.0f; i < iter; i++){\n        float realtemp = real;\n        real = (real*real)-(imag*imag)+creal;\n        imag = 2.0f*(realtemp*imag)+cimag;\n        if(sqrt((real*real) + (imag*imag)) > 4.0f){\n            col = i/iter;\n        }\n    }\n    // Output to screen\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    if(col != 0.0f) {\n        color = hsv2rgb(vec3(col*2.0f, 1.0f, 1.0f));\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 79], [81, 133, 155, 155, 324], [326, 326, 383, 422, 1430]], "test": "untested"}
{"id": "mlS3RV", "name": "vonoroi 3", "author": "jonasfrey", "description": "vonoroi", "tags": ["vonoroi"], "likes": 5, "viewed": 139, "published": 3, "date": "1673533635", "time_retrieved": "2024-07-30T18:16:20.893971", "image_code": "float f_n_rand(float n){\n    n = n+n+n*.2133;\n    n = n*n*0.231;\n    n = sin(n*1.2324+123.1*n)*124.123;\n    return fract(n);\n}\nfloat f_n_dist(vec2 o_trn_fc_nor_offset, vec2 o_scl, vec2 o_trn){\n    o_trn_fc_nor_offset*=o_scl;\n    \n    float n_index = (o_trn_fc_nor_offset.x)\n        + floor(o_trn_fc_nor_offset.y) * o_scl.x;\n        \n    vec2 o = o_trn_fc_nor_offset+floor(o_trn);\n    \n    float n_index_floor = floor(o.x)\n        + floor(o.y) * o_scl.x;\n        \n    float n_rand = f_n_rand(n_index_floor/(o_scl.x*o_scl.y))-0.5;\n    //n_rand = 0.;\n    float n_dist = length((fract(o_trn_fc_nor_offset)-(o_trn))-0.5+n_rand);\n    //n_dist = pow(n_dist, 1./5.)*1.;\n    //n_dist = 1.-n_dist;\n    //return n_index_floor / (o_scl.x * o_scl.y);\n    float ns = (sin(iTime)*0.5+0.5)+.02;\n    float nz = 1.-ns;\n    float nrs = (ns+(n_rand+0.5)*nz);\n    n_dist = n_dist * nrs;\n    return n_dist;\n}\nvec2 f_o_index(vec2 o_trn, vec2 o_scl){\n    float n_index_floor = floor(o_trn.x)\n        + floor(o_trn.y) * o_scl.x;\n    return vec2(\n        n_index_floor, \n        n_index_floor / floor(o_scl.x*o_scl.y)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    if(iMouse.z == 0.){\n        o_trn_mo_nor_offset = vec2(sin(iTime*0.5), 1.);\n    }\n    vec2 o_scl = vec2(66.,66.);\n    \n    vec2 o_scl_krn = vec2(9.,9.);\n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    vec2 omin = vec2(0.);\n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        float n_dist = f_n_dist(o_trn_fc_nor_offset, o_scl, vec2(n_x, n_y));\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            omin = (o_trn_fc_nor_offset*o_scl) + vec2(n_x, n_y);\n        }\n        //n_dmin = n_dist;\n    }\n    n_dmin = sqrt(n_dmin);\n    fragColor = vec4(n_dmin);\n    \n    if(o_trn_fc_nor_offset.x > o_trn_mo_nor_offset.x){\n        vec2 o_index = f_o_index(floor(omin), o_scl);\n        float nr = f_n_rand(abs(o_index.g)*2.);\n        float nr2 = f_n_rand(nr);\n        float nr3 = f_n_rand(nr*nr2);\n        \n        fragColor = vec4(nr, nr2, nr3, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 126], [127, 127, 192, 192, 886], [887, 887, 926, 926, 1100], [1101, 1101, 1158, 1158, 2658]], "test": "untested"}
{"id": "DtB3zV", "name": "Jukebox", "author": "dr2", "description": "Ancient music player, upgraded for the modern era;  plays fast for the impatient; mouseable.", "tags": ["mechanism", "phonograph", "gramophone"], "likes": 27, "viewed": 330, "published": 3, "date": "1673525975", "time_retrieved": "2024-07-30T18:16:22.011982", "image_code": "// \"Jukebox\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 HsvToRgb (vec3 c);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, objOrg, cabSize;\nfloat tCur, dstFar, tLoop, tCyc, abSide, nRec, selRec, cRec, nLoop, carslAng, \n   bCylRad, bCylHt;\nint idObj;\nbool haveRec, showPick, showVol;\nconst int idCarsl = 1, idRec = 2, idGrab = 3, idGrabS = 4, idPlat = 5, idArm = 6, idNeed = 7,\n   idSup = 8, idLeg = 9, idBase = 10, idPick = 11, idVol = 12, idArc = 13, idCab = 14,\n   idSpkr = 15, idGril = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct CS {\n  vec2 carslAng, armAng, armAngV, platAng, platAngS, recAng, recTwAng, grabAng, grabTwAng;\n} cs;\n\nvoid SetConf ()\n{\n  vec3 armLim;\n  vec2 tpLim, taLim;\n  float armAng, armAngV, grabAng, recAng, platAng, ti, tg, platSpd;\n  nRec = 64.;\n  selRec = mod (nLoop * (floor (nRec / 2.) - 5.), nRec);\n  abSide = 1. - 2. * mod (floor (nLoop * 2.3), 2.);\n  ti = tLoop / tCyc;\n  tg = 0.05;\n  platSpd = 7.;\n  tpLim = 0.05 + (selRec / nRec) * 0.2 + vec2 (0., 0.7);\n  if (ti < 0.05 || ti > 1. - 0.05) carslAng = 0.;\n  else if (ti < tpLim.x) carslAng = 5. * (ti - 0.05);\n  else if (ti < tpLim.y) carslAng = selRec / nRec;\n  else carslAng = 5. * (ti - 0.05) - 5. * 0.7;\n  armLim = vec3 (0., 0.14, 0.195) * pi;\n  taLim = tpLim + vec2 (1., -1.) * 4. * tg;\n  if (ti < taLim.x || ti >= taLim.y) armAng = armLim.x;\n  else if (ti < taLim.x + tg) armAng = mix (armLim.x, armLim.y, (ti - taLim.x) / tg);\n  else if (ti < taLim.y - tg) armAng = mix (armLim.y, armLim.z, (ti - (taLim.x + tg)) /\n     (tpLim.y - tpLim.x - 10. * tg));\n  else if (ti < taLim.y) armAng = mix (armLim.z, armLim.x, (ti - (taLim.y - tg)) / tg);\n  armAngV = -0.02 * pi * (1. - smoothstep (-0.2 * tg, 0., ti - (taLim.x + tg)) +\n     smoothstep (0., 0.2 * tg, ti - (taLim.y - tg)));\n  platAng = (ti > tpLim.x + 4. * tg && ti < tpLim.y - 4. * tg) ? platSpd * 2. * pi *\n     (ti - (tpLim.x + 4. * tg)) / (tpLim.y - tpLim.x - 8. * tg) : 0.;\n  recAng = pi * (smoothstep (tpLim.x + tg, tpLim.x + 3. * tg, ti) - smoothstep (tpLim.y - 3. * tg,\n     tpLim.y - tg, ti));\n  grabAng = recAng + 0.5 * pi * (1. - smoothstep (tpLim.x, tpLim.x + tg, ti) -\n     smoothstep (tpLim.x + 3. * tg, tpLim.x + 4. * tg, ti) +\n     smoothstep (tpLim.y - 4. * tg, tpLim.y - 3. * tg, ti) +\n     smoothstep (tpLim.y - tg, tpLim.y, ti));\n  cs.carslAng = CosSin (2. * pi * carslAng);\n  cs.recAng = CosSin (recAng);\n  cs.recTwAng = CosSin (-0.5 * pi * abSide * smoothstep (0.5 * pi, 0.8 * pi, recAng));\n  cs.platAng = CosSin (platAng);\n  cs.platAngS = CosSin (- abSide * platAng);\n  cs.grabAng = CosSin (grabAng);\n  cs.grabTwAng = CosSin (-0.5 * pi * abSide * smoothstep (0.5 * pi, 0.8 * pi, grabAng));\n  cs.armAng = CosSin (armAng);\n  cs.armAngV = CosSin (armAngV);\n  haveRec = (ti > tpLim.x + tg && ti < tpLim.y - tg);\n  showPick = (ti > 0.05 && ti < 1. - 0.05);\n  showVol = (armAngV == 0.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dd, dr, r, a, s, rRec, tRec, rHole, cRecT;\n  rRec = 0.49;\n  tRec = 0.008;\n  rHole = 0.05;\n  dMin = dstFar;\n  p -= objOrg;\n  q = p;\n  q.x -= -1.2;\n  q.xz = Rot2Cs (q.xz, cs.carslAng);\n  d = min (PrCylDf (vec3 (((abs (q.x) > abs (q.z)) ? q.xz : q.zx), q.y + 0.07).yzx, 0.02, 0.5),\n     PrCylDf (vec3 (q.xz, q.y + 0.3), 0.1, 0.3));\n  d = min (d, PrCylDf (vec3 (q.x - 1.5, q.y + 0.06, q.z).yzx, 0.03, 0.06));\n  DMINQ (idCarsl);\n  q.xz = Rot2Cs (q.xz, sin (pi / nRec +  + vec2 (0.5 * pi, 0.)));\n  a = atan (q.z, - q.x) / (2. * pi);\n  cRecT = (floor (nRec * (nRec * (a + 0.5) - carslAng) + 0.5) - 0.5) / nRec;\n  q.xz = Rot2Cs (q.xz, sin (2. * pi * (floor (nRec * a) + 0.5) / nRec + vec2 (0.5 * pi, 0.)));\n  q.x -= -1.;\n  r = length (q.xy);\n  dd = max (r - 0.55, abs (q.z) - 1.8 * tRec);\n  qq = q;\n  dr = max (abs (r - 0.5 * (rRec + rHole)) - 0.5 * (rRec - rHole), abs (q.z) - tRec);\n  q = p;\n  q.x -= -1.2;\n  r = length (q.xz) - 1.;\n  s = length (vec2 (r, q.y));\n  d = max (min (max (abs (s - 0.45) - 0.05, - dd), max (abs (s - rRec - 0.02) - 0.01,\n     min (abs (r) - 0.1, - q.y - 0.1))), q.y + 0.02);\n  DMINQ (idCarsl);\n  d = dr;\n  if (haveRec) d = max (d, min (q.x, 4. * tRec - abs (q.z)));\n  q = qq;\n  if (d < dMin) cRec = cRecT;\n  DMINQ (idRec);\n  if (haveRec) {\n    q = p;\n    q.x -= 0.9;\n    q.xy = Rot2Cs (q.xy, cs.recAng);\n    q.x -= -1.1;\n    q.yz = Rot2Cs (q.yz, cs.recTwAng);\n    d = max (abs (length (q.xy) - 0.5 * (rRec + rHole)) - 0.5 * (rRec - rHole), abs (q.z) - tRec);\n    q.xy = Rot2Cs (q.xy, cs.platAngS);\n    if (d < dMin) cRec = nRec - 1. - selRec;\n    DMINQ (idRec);\n  }\n  q = p;\n  q.x -= 0.9;\n  d = PrCylDf (q, 0.02, 0.25);\n  DMINQ (idGrabS);\n  q.z = abs (q.z);\n  q.yz -= vec2 (-0.1, 0.2);\n  d = PrCylDf (q.xzy, 0.03, 0.13);\n  DMINQ (idSup);\n  q = p;\n  q.x -= 0.9;\n  q.xy = Rot2Cs (q.xy, cs.grabAng);\n  q.x -= -1.1;\n  q.yz = Rot2Cs (q.yz, cs.grabTwAng);\n  d = max (max (abs (length (q.xy) - rRec - 0.03) - 0.03, abs (q.z) - 1.3 * tRec), -0.01 - q.y); \n  DMINQ (idGrab);\n  d = PrCylDf (vec3 (q.yz, q.x - 0.83), 0.04, 0.31);\n  DMINQ (idGrabS);\n  q = p;\n  q.xy -= vec2 (2., -0.05 - tRec);\n  q.xz = Rot2Cs (q.xz, cs.platAng);\n  r = length (q.xz);\n  d = min (max (r - (rRec - 0.02), abs (q.y) - 0.05), max (r - rHole, abs (q.y) - 0.08));\n  DMINQ (idPlat);\n  q = p;\n  q.xz = Rot2Cs (q.xz - vec2 (2.7, 0.5), cs.armAng);\n  d = PrCylDf (q.xzy, 0.06, 0.17);\n  q.y -= 0.1;\n  d = max (d, 0.027 - length (q.xy));\n  DMINQ (idSup);\n  d = PrCylDf (q.yzx, 0.02, 0.08);\n  DMINQ (idArm);\n  q.yz = Rot2Cs (q.yz, cs.armAngV);\n  r = length (q.xy);\n  d = min (min (max (r - 0.08, abs (q.z - 0.17) - 0.03), max (r - 0.02, abs (q.z + 0.31) - 0.54)),\n     max (r - 0.03, abs (q.z + 0.81) - 0.035));\n  DMINQ (idArm);\n  q.yz -= vec2 (-0.04, -0.81);\n  d = PrCapsDf (q.xzy, 0.005, 0.04);\n  DMINQ (idNeed);\n  q = p;\n  q -= vec3 (1.5, -0.5, -1.3);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.03, 0.2), 0.02);\n  DMINQ (idPick);\n  q = p;\n  q -= vec3 (0.5, -0.5, -1.3);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.03, 0.4), 0.02);\n  DMINQ (idVol);\n  q = p;\n  q.y -= -0.6;\n  d = PrBoxDf (q, vec3 (cabSize.xz - 0.1, 0.05).xzy);\n  d = min (d, PrBoxDf (vec3 (q.x - 1.8, q.y - 0.38, q.z), vec3 (1.1, 0.1, 0.7)));\n  DMINQ (idBase);\n  d = PrCylDf (vec3 (abs (vec2 (q.x - 1.8, q.z)) - vec2 (0.85, 0.4), q.y - 0.15), 0.15, 0.13);\n  DMINQ (idLeg);\n  q = p;\n  q.yz -= vec2 (-0.6, cabSize.z - 0.25);\n  d = max (PrTorusDf (q, 0.1, cabSize.x - 0.25), - q.y);\n  DMINQ (idArc);\n  q = p;\n  q.y -= - cabSize.y - 0.65;\n  d = PrRoundBoxDf (q, cabSize - 0.03, 0.03);\n  dd = PrRoundBox2Df (vec2 (abs (q.x) - 1.5, q.y), vec2 (0.82, 1.98), 0.03);\n  d = max (d, - max (dd, q.z));\n  DMINQ (idCab);\n  q.z -= -1.7;\n  d = max (dd, abs (q.z) - 0.05);\n  DMINQ (idSpkr);\n  q.xy = (fract (3. * q.xy + 0.5) - 0.5) / 3.;\n  q.z -= -0.15;\n  d = max (min (length (q.xz), length (q.yz)) - 0.02, dd);\n  DMINQ (idGril);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p -= objOrg;\n  q = p;\n  q.y -= -0.67;\n  d = max (PrRoundCylDf (q, cabSize.x - 0.13, 0.1, cabSize.z - 0.13), - q.y);\n  DMINQ (0);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (out vec2 vf, out bool isMet)\n{\n  vec4 col4, cVol4;\n  vec3 c;\n  vec2 w, iw;\n  float r, t, tVol;\n  vf = vec2 (0.);\n  isMet = false;\n  if (idObj <= idSup) {\n    if (idObj == idCarsl) {\n      col4 = vec4 (0.7, 0.4, 0.2, 0.1);\n      isMet = true;\n    } else if (idObj == idRec) {\n      r = length (qHit.xy);\n      if (qHit.y > 0. && r < 0.22 || r > 0.48)\n         col4 = vec4 (HsvToRgb (vec3 (cRec / nRec, 0.8, 1.)), 0.1);\n      else if (qHit.y < 0. && r < 0.22) col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n      else col4 = vec4 (0.4, 0.4, 0.45, 0.1) * (0.8 + 0.2 * step (abs (r - 0.35), 0.06));\n      col4 *= 1. - 0.8 * step (length (vec2 (((qHit.z > 0.) ? qHit.x : abs (qHit.x) - 0.04),\n         qHit.y + 0.15)), 0.02);\n      col4 *= 1. - 0.8 * step (0.001, ShowIntPZ (vec2 (sign (qHit.z) * qHit.x - 0.075,\n         - (qHit.y - 0.15)), 0.3 * vec2 (0.5, 0.25), 2., selRec + 1.));\n      if (abs (qHit.x) < 0.08 && abs (qHit.y - 0.18) < 0.006) col4 *= 0.2;\n    } else if (idObj == idGrab) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1) * (0.5 + 0.5 * step (0.02, Minv2 (abs (qHit.xy))));\n      isMet = true;\n    } else if (idObj == idGrabS) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1);;\n      isMet = true;\n    } else if (idObj == idPlat) {\n      r = length (qHit.xz);\n      if (r > 0.055 && r < 0.43) {\n        col4 = vec4 (0.4, 0.4, 0.5, 0.1) * (0.8 + 0.2 * smoothstep (0.01, 0.02,\n           Minv2 (abs (qHit.xz))));\n        vf = vec2 (128., 0.2);\n      } else {\n        col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n        if (abs (qHit.y) < 0.04) col4 *= 0.8 + 0.2 * smoothstep (0.02, 0.3, fract (32. *\n           (atan (qHit.z, - qHit.x) / (2. * pi) + 0.5)));\n        isMet = true;\n      }\n    } else if (idObj == idArm) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1);\n      isMet = true;\n    } else if (idObj == idNeed) {\n      col4 = vec4 (0.9, 0.9, 0., -1.);\n      isMet = true;\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      isMet = true;\n    }\n  } else {\n    if (idObj == idVol || idObj == idCab) {\n      tVol = floor (16. * clamp (1.3 * Fbm1 (8. * floor (16. * tCur) / 16.) - 0.1, 0., 1.)) / 16.;\n      cVol4 = vec4 (HsvToRgb (vec3 (0.7 - 0.7 * tVol, 1., 1.)), -1.);\n    }\n    if (idObj == idLeg) {\n      col4 = vec4 (0.9, 0.9, 1., 0.1) * (0.8 + 0.2 * step (0.2, fract (32. * qHit.y)));\n      isMet = true;\n    } else if (idObj == idBase) {\n      col4 = vec4 (vec3 (0.5), 0.1);\n      if (min (abs (qHit.y - 0.05), abs (qHit.y - 0.48)) < 0.01) {\n        w = 12. * qHit.zx;\n        col4 *= mix (1.8, 1., step (0.1, HexEdgeDist (w - HexToPix (PixToHex (w)))));\n      }\n      col4 *= 0.7 + 0.3 * step (1.1, length (vec2 (qHit.x + 1.2, qHit.z)));\n    } else if (idObj == idPick) {\n      col4 = vec4 (1., 1., 0.7, -1.);\n      if (showPick) {\n        col4.rgb *= 1. - 0.8 * step (0.001, ShowIntPZ (qHit.xz - vec2 (0.13, -0.08),\n           0.7 * vec2 (0.5, 0.25), 2., selRec + 1.));\n        col4.rgb *= 1. - 0.8 * step (length (vec2 (qHit.x - 0.22, ((abSide > 0.) ? qHit.z :\n           abs (qHit.z) - 0.05))), 0.03);\n      }\n    } else if (idObj == idVol) {\n      col4 = vec4 (1., 1., 0.7, 0.);\n      if (PrBox2Df (qHit.xz, vec2 (0.15, 0.4) - 0.01) < 0.) { \n        col4 = vec4 (0.2, 0.2, 0.2, -1.);\n        if (showVol && (qHit.z + 0.4) / 0.8 < tVol) col4 = cVol4;\n      }\n    } else if (idObj == idArc) {\n      t = fract (2. * (atan (qHit.y, - qHit.x) / (2. * pi) + 0.5) + 0.5 * sin (0.5 * pi * tCur));\n      col4 = (showVol) ? vec4 (HsvToRgb (vec3 (t, 1., 1.)), -1.) : vec4 (vec3 (1., 1., 0.7) * \n         (0.8 + 0.2 * sin (16. * pi * t)), -1.);\n    } else if (idObj == idCab) {\n      col4 = vec4 (1., 0.9, 1., 0.1) * (0.8 + 0.2 * Fbm2 (vec2 (4., 1.) *\n         vec2 (((abs (qHit.x) < cabSize.x - 0.01) ? qHit.x : qHit.z), qHit.y)));\n      if (qHit.x > 0. && length (vec2 (abs (qHit.z - cabSize.z + 0.6) - 0.1,\n         qHit.y + cabSize.y - 0.15)) < 0.05) col4 = vec4 (0.2, 1., 0.2, -1.);\n      t = Minv3 (vec3 (abs (qHit.xz) - cabSize.xz + 0.2, cabSize.y - 0.3 - abs (qHit.y)));\n      if (t < 0.) {\n        r = length (qHit.yz) - 1.5;\n        if (r < 0.) {\n          w = 8. * Rot2D (qHit.yz, pi / 12.);\n          iw = PixToHex (w);\n          t = mod (dot (mod (2. * iw + iw.yx, 3.), vec2 (1., 2.)), 3.);\n          c = vec3 (0.9, 0.9, 0.);\n          if (t > 0.) c = mix (c.xzz, c.zxz, t - 1.);\n          c = mix (vec3 (0., 0., 1.), c, smoothstep (0.05, 0.1, HexEdgeDist (w - HexToPix (iw))));\n          col4 = vec4 (c, 0.1);\n        } else if (r < 0.05) col4 *= 0.8;\n      } else if (t > 0.03) {\n        col4 = (showVol) ? cVol4 : vec4 (vec3 (1., 1., 0.9) * (0.8 + 0.2 * sin (4. * pi *\n           (qHit.y + tCur))), -1.);\n      } else col4 *= 0.7;\n    } else if (idObj == idSpkr) {\n      w = 6. * qHit.yx;\n      col4 = vec4 (0.6, 0.2, 0., 0.) * (1. + 0.3 * step (HexEdgeDist (w -\n         HexToPix (PixToHex (w))), 0.07));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idGril) {\n      col4 = vec4 (0.9, 0.9, 0.2, 0.2);\n      isMet = true;\n    }\n  }\n  return col4;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = len;\n    if (abs (s.y) < len) vn.xz = - s.xz / rad;\n    else {\n      d = (- srdy * ro.y + len) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd, out bool needSh)\n{  // (from \"Soup Can Dynamics\")\n  vec4 vc, db4, col4;\n  vec3 vn, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, ga;\n  db4 = InCylHit (ro - vec3 (0., bCylHt, 0.), rd, bCylRad, bCylHt);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  ro += dCyl * rd;\n  needSh = false;\n  if (vnCyl.y == 0.) {\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col4 = vec4 (0.5, 0.5, 1., -1.);\n    } else {\n      col4 = vec4 (0.2, 0.4, 0.2, -1.);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        col4 = vec4 (0.4, 0.2, 0., 0.);\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col4 *= 0.8;\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col4 *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    vc = HexVor (ro.xz);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.yz, 4.)).xzy,\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col4 = vec4 (HsvToRgb (vec3 (0.8 * floor (8. * vc.w) / 8., 0.5 * smoothstep (0.06, 0.08, vc.x),\n       0.9)) * (0.5 + 0.5 * b * step (0.06 + 0.03 * vc.w, vc.x) * (1. -\n       0.2 * Noisefv2 (16. * ro.xz))), 0.1);\n    needSh = true;\n  } else {\n    b = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) b += 1. - step (0.015,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col4 = mix (vec4 (0.3, 0.3, 0.8, 0.), vec4 (1., 1., 0.4, -1.), b);\n  }\n  return (col4.a >= 0.) ? col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) : col4.rgb;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  vec2 vf;\n  float dstObj, dstTrObj, nDotL, sh;\n  bool isMet, needSh;\n  HexVorInit ();\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (vf, isMet);\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (isMet) nDotL *= nDotL;\n    }\n  } else {\n    col = BgCol (ro, rd, needSh);\n    if (needSh) {\n      ro += (- ro.y / rd.y) * rd;\n      vn = vec3 (0., 1., 0.);\n    }\n  }\n  sh = (dstObj < dstFar && col4.a >= 0. || dstObj >= dstFar && needSh) ?\n     ObjSShadow (ro + 0.01 * vn, ltDir) : 1.;\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n  } else {\n    col = 0.2 + 0.4 * (0.5 + 0.5 * sh) * col;\n  }\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (col, BgCol (ro, reflect (rd, vn), needSh), 0.05 + 0.95 *\n       pow (1. - abs (dot (vn, rd)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = max (tCur - 1., 0.);\n  tCyc = 30.;\n  tCur += floor (20. * tCyc * floor (dateCur.w / (20. * tCyc)) / tCyc) * tCyc;\n  tLoop = mod (tCur, tCyc);\n  nLoop = 1. + floor (tCur / tCyc);\n  SetConf ();\n  t = SmoothBump (0.15, 0.85, 0.1, tLoop / tCyc);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * (mPtr.y - 0.25);\n  } else {\n    az = 0.15 * pi * sign (mod (nLoop, 2.) - 0.5) * sign (tLoop / tCyc - 0.5) * (1. - t);\n    el = - pi * (0.25 + 0.17 * t);\n  }\n  el = clamp (el, -0.47 * pi, -0.05 * pi);\n  bCylRad = 40.;\n  bCylHt = 15.;\n  cabSize = vec3 (3.1, 3., 1.9);\n  objOrg = vec3 (0., 2. * cabSize.y + 0.75, 0.);\n  ro = vec3 (0., objOrg.y - 3., -0.9 * bCylRad);\n  vd = normalize (objOrg + vec3 (0., 10., 0.) - ro);\n  az += atan (vd.z, - vd.x) - 0.5 * pi;\n  el += asin (vd.y);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  ro.y = max (ro.y, 1.);\n  vd.xz = Rot2D (vd.xz, 0.1 * pi);\n  vd.yz = Rot2D (vd.yz, 0.2 * pi);\n  ltDir = - vuMat * vd;\n  zmFac = mix (4.5, 12., smoothstep (0., 0.5 * pi, - el));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtB3zV.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1882, 1882, 1899, 1899, 4092], [4094, 4094, 4116, 4116, 8011], [8013, 8013, 8046, 8046, 8230], [8232, 8232, 8253, 8253, 8508], [8510, 8510, 8547, 8547, 8776], [8778, 8778, 8802, 8802, 8994], [8996, 8996, 9031, 9031, 9217], [9219, 9219, 9242, 9242, 9499], [9501, 9501, 9544, 9544, 14483], [14485, 14485, 14541, 14541, 15012], [15014, 15014, 15040, 15040, 15390], [15392, 15392, 15440, 15471, 17894], [17896, 17896, 17931, 17931, 19194], [19196, 19196, 19252, 19252, 21029], [21031, 21031, 21063, 21063, 21147], [21149, 21149, 21182, 21182, 21266], [21268, 21268, 21314, 21314, 21361], [21363, 21363, 21410, 21410, 21457], [21459, 21459, 21501, 21501, 21552], [21554, 21554, 21611, 21611, 21687], [21689, 21689, 21732, 21732, 21796], [21798, 21798, 21844, 21844, 21901], [21903, 21903, 21925, 21925, 21952], [21954, 21954, 21976, 21976, 22003], [22005, 22005, 22027, 22027, 22065], [22067, 22067, 22089, 22089, 22127], [22129, 22129, 22174, 22174, 22266], [22268, 22268, 22325, 22325, 22408], [22410, 22410, 22433, 22433, 22537], [22610, 22610, 22642, 22642, 23190], [23192, 23192, 23254, 23254, 23621], [23623, 23623, 23647, 23647, 23764], [23766, 23766, 23790, 23790, 24020], [24022, 24022, 24046, 24046, 24106], [24108, 24108, 24136, 24136, 24216], [24242, 24242, 24262, 24262, 24482], [24484, 24484, 24506, 24506, 25101], [25103, 25103, 25139, 25139, 25345], [25347, 25347, 25377, 25377, 25490], [25492, 25492, 25523, 25523, 25587], [25621, 25621, 25645, 25645, 25705], [25707, 25707, 25731, 25731, 25784], [25786, 25786, 25810, 25810, 25922], [25924, 25924, 25948, 25948, 26008], [26010, 26010, 26035, 26035, 26181], [26183, 26183, 26208, 26208, 26394], [26396, 26396, 26418, 26418, 26572], [26574, 26574, 26595, 26595, 26750], [26752, 26752, 26781, 26781, 26993], [26995, 26995, 27034, 27034, 27286]], "test": "untested"}
{"id": "ctS3zV", "name": "Loop", "author": "mla", "description": "Just playing around really. Mouse changes colour parameters. I can't believe no one has made a shader called \"Loop\" before!", "tags": ["sdf", "loop", "xor"], "likes": 10, "viewed": 228, "published": 3, "date": "1673523554", "time_retrieved": "2024-07-30T18:16:22.984381", "image_code": "float circle(vec2 p, vec2 centre, float r) {\n  p -= centre;\n  return length(p) - r;\n}\n\nfloat xor(float d0, float d1) {\n  return min(max(d0,d1),max(-d0,-d1));\n}\n\nvec2 dup(vec2 p, float k) {\n  return mod(p+k,2.0*k)-k;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float scale = 10.0;\n  if (key(CHAR_Z)) scale *= 2.0;\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p *= scale;\n  float px = 0.5*fwidth(p.x);\n  float d = 1e8;\n  float t = -log2(length(p));\n  float loop = 64.0;\n  t += mod(0.5*iTime,loop);\n  t = round(t);\n  int t0 = int(mod(t,loop));\n  t -= mod(0.5*iTime,loop);\n  float r = exp2(-t);\n  float k = 0.25;\n  k *= 2.0*float(ihash(uint(t0)))/exp2(32.0);\n  k = exp2(k);\n  float e = circle(p,vec2(0),r/k);\n  float f = circle(p,vec2(0),r*k);\n  d = min(d,max(f,-e));\n  vec3 fg = vec3(0.5);\n  vec3 bg = vec3(1);\n  if (!key(CHAR_C) && d < 0.0) {\n    float h = float(ihash(uint(t0^1)))/exp2(32.0);\n    float inc = iMouse.x <= 0.0 ? 0.5 : iMouse.x/iResolution.x;\n    float s = iMouse.x <= 0.0 ? 1.0 : iMouse.y/iResolution.y;\n    fg = hsv2rgb(h,s,1.0); bg = hsv2rgb(h+inc,s,1.0);\n  }\n  vec2 p1 = dup(p,1.0);\n  float d1 = circle(p1,vec2(0),1.0);\n  d = xor(d,d1);\n  float s = max(abs(p.x),abs(p.y));\n  s -= 2.0;\n  s *= 0.25;\n  s = round(s);\n  s /= 0.25;\n  s += 2.0;\n  e = max(abs(p.y)-s+1.0,abs(p.x)-s+1.0);\n  f = max(abs(p.y)-s-1.0,abs(p.x)-s-1.0);\n  d = xor(d,max(f,-e));\n  vec3 col = mix(fg,bg,smoothstep(-px,px,d));\n  col *= smoothstep(0.0,2.0*px,abs(d)-0.01);\n  float dir = mod(0.5*dot(round(p-p1),vec2(1)),2.0) < 0.5 ? -1.0 : 1.0;\n  if (length(p1) < 1.0) col *= 0.5-0.5*cos(0.3*PI*d1/px+2.0*dir*(PI*iTime+atan(p1.y,p1.x)));\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.141592654;\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctS3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 85], [87, 87, 118, 118, 159], [161, 161, 188, 188, 217], [219, 219, 271, 271, 1707]], "test": "untested"}
{"id": "mljGRG", "name": "Copy Of ocean by alf_ext", "author": "syndel", "description": "for wallpaper engine, just slower. ", "tags": ["wallpaper"], "likes": 3, "viewed": 264, "published": 3, "date": "1673493598", "time_retrieved": "2024-07-30T18:16:23.894947", "image_code": "//afl_ext 2017-2019\n\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = .6;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, Time);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross((a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \n                           (a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(Resolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 100.0), 3.0 * ((Mouse.x + 0.5) * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 100.0), 1.5 * ((Mouse.y + 0.5) * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\tsundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n\tfloat mymie = sundt * special_trick * 0.2;\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \t\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\n        //tonemapping\n    \tC = aces_tonemap(C);\n     \tfragColor = vec4( C,1.0);   \n        return;\n    }\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R) + vec3(0.0293, 0.0698, 0.1717);\n    //tonemapping\n    C = aces_tonemap(C);\n    \n\tfragColor = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 298, 298, 466], [468, 468, 514, 514, 1019], [1021, 1021, 1089, 1089, 1488], [1505, 1505, 1549, 1549, 1915], [1916, 1916, 1953, 1953, 2342], [2344, 2344, 2365, 2365, 2753], [2755, 2755, 2831, 2831, 2924], [2926, 2926, 2980, 2980, 3695], [3697, 3697, 3719, 3719, 3792], [3794, 3794, 3814, 3814, 3908], [3909, 3909, 3939, 3939, 4386], [4387, 4387, 4444, 4444, 5574]], "test": "untested"}
{"id": "cl2GDw", "name": "Hilbert Path", "author": "wyatt", "description": "curve", "tags": ["curve"], "likes": 38, "viewed": 361, "published": 3, "date": "1673492675", "time_retrieved": "2024-07-30T18:16:25.006974", "image_code": "#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define light vec3(.5,.2,-1.)\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat m2 (vec3 p, vec2 u) {\n    float h = .5*abs(sin(iTime))*(.5-.5*cos(iTime*texture(iChannel0,u).x));\n    if (u.x<0.||u.y<0.||u.x>1.||u.y>1.)\n    return box(p-vec3(.5,.5,0),vec3(.5,.5,.1));\n    return box(p-vec3(u,-h),vec3(.5/200.,.5/200.,.5/100.));\n}\nfloat map (vec3 p) {\n    p.xy += .5;\n    vec2 u = round(p.xy*300.)/300.;\n    return min(min(m2(p,u),length(p-light)-.05),abs(p.z-.1)-.1);\n}\nvec3 normal (vec3 p) {\n    return normalize(vec3(\n        map(p+vec3(1e-3,0,0))-map(p-vec3(1e-3,0,0)),\n        map(p+vec3(0,1e-3,0))-map(p-vec3(0,1e-3,0)),\n        map(p+vec3(0,0,1e-3))-map(p-vec3(0,0,1e-3))\n    ));\n}\nMain {\n    vec3 p = vec3(0,0,-1.2);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,2));\n    if (iMouse.z>0.) {\n    \n        p.yz *= ei(iMouse.y/R.y);\n        d.yz *= ei(iMouse.y/R.y);\n        p.xy *= ei(6.2*iMouse.x/R.x);\n        d.xy *= ei(6.2*iMouse.x/R.x);\n    } else {\n        p.yz *= ei(.7);\n        d.yz *= ei(.7);\n        p.xy *= ei(iTime);\n        d.xy *= ei(iTime);\n    }\n    for (float i = 0.; i < 200.; i++) {\n        float m = map(p);\n        p += .5*min(m,.03)*d;\n    }\n    \n    Q = texture(iChannel1,normal(p));\n    \n    if (map(p)>.01) Q = vec4(.5);\n    else {\n    d = normalize(light-p);\n    p += .01*d;\n    for (float i = 0.; i < 50.; i++) {\n        float m = map(p);\n        p += .5*min(m,.03)*d;\n    }\n    Q *= exp(-abs(length(p-light)-.1));\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define A(U) texture(iChannel0,(U)/R)\n#define N 10.", "buffer_a_code": "Main {\n    U = 2.*(U-.5*R)/R;\n    \n    float n = 0.;\n    mat2 u = mat2(0,0,0,0);\n    \n    for (float i = 0.; i < N; i++) {\n        if (U.x<0.&&U.y<0.)\n            n=n*4.+0., u = mat2(0,1,1,0);\n        if (U.x<0.&&U.y>=0.)\n            n=n*4.+1., u = mat2(1,0,0,1);\n        if (U.x>=0.&&U.y>=0.)\n            n=n*4.+2., u = mat2(1,0,0,1);\n        if (U.x>=0.&&U.y<0.)\n            n=n*4.+3., u = mat2(0,-1,-1,0);\n        \n        U = (2.*fract(U)-1.)*u;\n    }\n    Q = vec4(n)/exp2(2.*N);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2GDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 108, 108, 195], [196, 196, 223, 223, 449], [450, 450, 470, 470, 589], [590, 590, 612, 612, 807]], "test": "untested"}
{"id": "Dl23WW", "name": "remaindeer v1", "author": "remaindeer", "description": "𐂂, simple model/code, will try and 3D print using [url]https://tdhooper.github.io/glsl-marching-cubes/[/url]\n", "tags": ["raymarch", "sdf", "remaindeer", "keychain"], "likes": 4, "viewed": 182, "published": 3, "date": "1673491217", "time_retrieved": "2024-07-30T18:16:25.946462", "image_code": "float scene(vec3 p) {\n    float d;\n    vec3 q;\n    \n    // 𐂂\n    //// cabeza\n    q = rotmat3(vec3(0, 0, radians(75.0))) * p;\n    d = sdRoundCone(q - vec3(0), 0.15, 0.25, 0.35);\n    //// ojos\n    q = p; q.x = abs(q.x);\n    d = min(d, sdSphere(q - vec3(+0.175, 0.25, -0.205), 0.10));\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(0, 0, radians(90.0))) * q;\n    d = min(d, sdCutHollowSphere(q - vec3(+0.175, 0.205, 0.25), 0.10, -0.085, 0.01));\n    //// orejas\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(radians(10.0), radians(15.0), radians(90.0))) * q;\n    d = min(d, sdRhombus(q - vec3(+0.35, +0.40, 0.20), 0.25, 0.15, 0.05, 0.001));\n    //// astas\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(radians(15.0), 0, 0)) * q;\n    d = min(d, sdVerticalCapsule(q - vec3(+0.015, 0.3, -0.325), 0.35, 0.05));\n    //// sejas\n    q = p; q.x = abs(q.x);\n    d = min(d, sdCappedTorus(q - vec3(+0.175, 0.25, -0.205), vec2(0.25), 0.10, 0.05));\n    //// nariz (%)\n    q = p;\n    d = min(d, sdCappedTorus(q - vec3(-0.025, +0.015, 0.15), vec2(0), 0.0125, 0.0075));\n    d = min(d, sdCappedTorus(q - vec3(+0.025, -0.015, 0.15), vec2(0), 0.0125, 0.0075));\n    q = rotmat3(vec3(radians(30.0), 0, 0)) * p;\n    d = min(d, sdVerticalCapsule(q - vec3(0, -0.030, 0.15), 0.060, 0.0075));\n    //// blep\n    q = p; q = rotmat3(vec3(0, 0, radians(80.0))) * (q - vec3(0, -0.075, 0));\n    d = min(d, sdLink(q, 0.10, 0.040, 0.025));\n    \n    // cadena\n    q = rotmat3(vec3(0, 0, radians(30.0))) * (p - vec3(0, 0.15, -0.5));\n    d = min(d, sdLink(q, 0.15, 0.045, 0.025));\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    float d;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + depth * rd;\n        d = scene(p);\n        depth += d;\n        if (d < PRECISION || depth > MAX_DIST) {\n            break;\n        }\n    }\n\n    d = depth;\n\n    return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n        e.xyy * scene(p + e.xyy) +\n        e.yyx * scene(p + e.yyx) +\n        e.yxy * scene(p + e.yxy) +\n        e.xxx * scene(p + e.xxx)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 1.5);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI / 2.0, PI / 2.0, m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 1, 1);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        rnd.xy = vec2(0.0);\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "// ray marching\n#define MAX_ITER 500\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\n// math\n//// constants\n#define PI 3.1415926535897932384626433\n#define PHI (1.0 + sqrt(5.0)) / 2.0\n#define ICO_CIRCUMRADIUS sin((2.0 * PI) / 5.0)\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n\n//// rotations\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi, sintht * cospsi, -sinpsi, \n        costht * sinpsi * sinphi - sintht * cosphi, sintht * sinpsi * sinphi + costht * cosphi, cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi, sintht * sinpsi * cosphi - costht * sinphi, cospsi * cosphi\n    );\n}\n\n\n//// ---------------------------------------------------\n//// iq (https://iquilezles.org/articles/distfunctions/)\n//// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n \n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n//// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//// ---------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 1556], [1558, 1558, 1589, 1589, 1865], [1867, 1867, 1891, 1891, 2096], [2098, 2098, 2145, 2145, 2307], [2309, 2309, 2364, 2364, 3318]], "test": "untested"}
{"id": "DtjGRG", "name": "vonoroi neighbors 2", "author": "jonasfrey", "description": "vonoroi", "tags": ["vonoroi"], "likes": 4, "viewed": 193, "published": 3, "date": "1673480562", "time_retrieved": "2024-07-30T18:16:26.765273", "image_code": "float f_n_rand(float n){\n    n = n+n+n*.2133;\n    n = n*n*0.231;\n    n = sin(n*1.2324+123.1*n)*124.123;\n    return fract(n);\n}\nfloat f_n_dist(vec2 o_trn_fc_nor_offset, vec2 o_scl, vec2 o_trn){\n    o_trn_fc_nor_offset*=o_scl;\n    \n    float n_index = (o_trn_fc_nor_offset.x)\n        + floor(o_trn_fc_nor_offset.y) * o_scl.x;\n        \n    vec2 o = o_trn_fc_nor_offset+floor(o_trn);\n    \n    float n_index_floor = floor(o.x)\n        + floor(o.y) * o_scl.x;\n        \n    float n_rand = f_n_rand(iTime*0.0001+n_index_floor/(o_scl.x*o_scl.y))-0.5;\n    //n_rand = 0.;\n    float n_dist = length((fract(o_trn_fc_nor_offset)-(o_trn))-0.5+n_rand*sin(iTime));\n    //n_dist = pow(n_dist, 1./5.)*1.;\n    //n_dist = 1.-n_dist;\n    //return n_index_floor / (o_scl.x * o_scl.y);\n    return n_dist;\n}\nvec2 f_o_index(vec2 o_trn, vec2 o_scl){\n    float n_index_floor = floor(o_trn.x)\n        + floor(o_trn.y) * o_scl.x;\n    return vec2(\n        n_index_floor, \n        n_index_floor / floor(o_scl.x*o_scl.y)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    vec2 o_scl = vec2(33.,33.);\n    \n    vec2 o_scl_krn = vec2(3.,3.);\n    float n_krn_xty = o_scl_krn.x*o_scl_krn.y;\n    float n_dmin = 1.;\n    vec2 omin = vec2(0.);\n    for(float n = 0.; n < n_krn_xty; n+=1.){\n        float n_x = floor(mod(n, o_scl_krn.x) - floor(o_scl_krn.x/2.));\n        float n_y = floor(n / o_scl_krn.x) - floor(o_scl_krn.y/2.);\n        float n_dist = f_n_dist(o_trn_fc_nor_offset, o_scl, vec2(n_x, n_y));\n        //n_dmin = min(n_dist, n_dmin);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist;\n            omin = (o_trn_fc_nor_offset*o_scl) + vec2(n_x, n_y);\n        }\n        //n_dmin = n_dist;\n    }\n    \n    fragColor = vec4(n_dmin);\n    \n    if(o_trn_fc_nor_offset.x > 0.){\n        vec2 o_index = f_o_index(floor(omin), o_scl);\n        float nr = f_n_rand(abs(o_index.g)*2.);\n        float nr2 = f_n_rand(nr);\n        fragColor = vec4(nr, nr2, 0.5, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 126], [127, 127, 192, 192, 782], [783, 783, 822, 822, 996], [997, 997, 1054, 1054, 2380]], "test": "untested"}
{"id": "dtS3zy", "name": "another clock 5", "author": "jonasfrey", "description": "the classic one", "tags": ["classic", "shaderclockdenodev"], "likes": 2, "viewed": 216, "published": 3, "date": "1673472007", "time_retrieved": "2024-07-30T18:16:27.563140", "image_code": "\n\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n//IMPORTANT START, keep the lines with and between IMPORTANT START and IMPORTANT END\n// and add the tag 'shaderclockdenodev' to the shader\n// otherwise the shader will not work on https://shaderclock.deno.dev/\n// also at the moment only the following variables are available iTime, iResolution,fragCoord,iDate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//IMPORTANT END\n\n\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    // by default the rotation starts between quadrant II and quadrant III\n    // so this rotation compensates one quadrant\n    o_trn_fc_nor_offset = f_o_rotd(o_trn_fc_nor_offset, (1./4.)*3.);\n    \n    o_trn_fc_nor_offset *= 1.2;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.283185;\n    float n_freq_sec = fract(iTime)*n_tau;\n    //float n_t_sec = (iTime);\n    //n_t_sec = floor(iTime);// for snapping handle\n    float n_ang_nor = fract(atan(o_trn_fc_nor_offset.y, o_trn_fc_nor_offset.x)/n_tau);\n    vec4 o_col = vec4(0.);\n    float n_t_yea = (iDate.x);//year-1\n    float n_t_mon = (iDate.y);//month-1\n    float n_t_day = (iDate.z);//day-1\n    float n_t_sec_since_midnight = (iDate.w);//secs since midnight\n    \n    float n_w, n_dcenter, n_radius, n_pointerstart, n_pointerend, n, n_radians_nor,n_divisor, n_glow; \n    vec2 o;\n    n_dcenter = length(vec2(0.)-o_trn_fc_nor_offset);\n    \n    float n_aa = n_ratio_1to_iresx*20.;\n    \n    //sec\n    n_pointerstart = 0.;\n    n_pointerend = 0.5;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/60.;\n    n_radians_nor = -floor(n_t_sec_since_midnight)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nsec = length(o-o_trn_fc_nor_offset);\n    n_w = 0.01;\n    nsec = smoothstep(n_w+n_aa, n_w, nsec);\n\n    //min\n    n_pointerstart = 0.0;\n    n_pointerend = 0.3;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/n_divisor;\n    n_radians_nor = -floor(n_t_sec_since_midnight/60.)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nmin = length(o-o_trn_fc_nor_offset);\n    n_w = 0.01;\n    nmin = smoothstep(n_w+n_aa, n_w, nmin);\n\n\n    //hou\n    n_pointerstart = 0.0;\n    n_pointerend = 0.2;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -(n_t_sec_since_midnight/60./60./12.);\n    n_radians_nor = -floor(n_t_sec_since_midnight/60./60.)/12.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nhou = length(o-o_trn_fc_nor_offset);\n    n_w = 0.01;\n    nhou = smoothstep(n_w+n_aa, n_w,nhou);\n    \n    //minutes indicators\n    n_pointerstart = 0.45;\n    n_pointerend = 0.5;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = floor(n_ang_nor*60.+0.5)/60.;\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nminind = length(o-o_trn_fc_nor_offset);\n    n_w = 0.001;\n    n_aa = n_ratio_1to_iresx*20.;\n    nminind = smoothstep(n_w+n_aa,n_w, nminind);\n    \n    //hours indicators\n    n_pointerstart = 0.35;\n    n_pointerend = 0.5;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = floor(n_ang_nor*12.+0.5)/12.;\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nhouind = length(o-o_trn_fc_nor_offset);\n    n_w = 0.001;\n    n_aa = n_ratio_1to_iresx*20.;\n    nhouind = smoothstep(n_w+n_aa,n_w, nhouind);\n    \n    //border\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nborder = length(vec2(0.)-o_trn_fc_nor_offset);\n    nborder=sin(nborder*n_tau+1.5)*0.5+0.5;\n    nborder= pow(nborder, 1./3.);\n    n_w = 0.1;\n    n_aa = n_ratio_1to_iresx*123.;\n    nborder = smoothstep(n_w+n_aa,n_w, nborder);\n    //n = min(pow(nsec,1.),nmin);\n    //n = min(n, nhou);\n    //n = 1.-sqrt(n);\n    //n_glow = 1.;\n    //n = pow(n, 1./n_glow);\n    n = nsec;\n    n += nmin;\n    n += nhou;\n    n += nminind;\n    n += nhouind;\n    n += nborder;\n    fragColor = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 43, 43, 238], [239, 549, 606, 622, 4936]], "test": "untested"}
{"id": "mlS3RG", "name": "Colourful Thin Spiral", "author": "mla", "description": "Draw as thin a spiral as possible, while minimizing aliasing artefacts. This one has colours and uses gamma correction as it makes colour bands wider and helps reduce artefacts ('x' to toggle). Colour palette is just an oblique line through RGB space.", "tags": ["spiral"], "likes": 12, "viewed": 215, "published": 3, "date": "1673470195", "time_retrieved": "2024-07-30T18:16:28.395913", "image_code": "// Colourful Thin Spiral, mla, 2023\n// Draw as thin a spiral as possible, while minimizing\n// aliasing artefacts. This one has colours and uses gamma\n// correction as it makes colour bands wider and helps\n// reduce artefacts.\n//\n// Colour palette is just an oblique line through RGB space.\n//\n// 'c': colours\n// 'x': gamma\n// 't': triangle wave (+ smoothstep)\n// 'z': disable mouse control\n\nfloat spiral = 2.0; // Number of arms on spiral, 0 for no spiral\nfloat scale = 1.0;  // This can be any value in fact\nfloat k = 0.55;     // Magic number, can be set with mouse-x\n\nvec3 palette(float t) {\n  vec3 col = t*vec3(0.414,0.618,1);\n  col = mod(col,2.0);\n  col = min(col,2.0-col);\n  //col = hsv2rgb(col);\n  if (!key(CHAR_X)) col *= col;\n  return col;\n}\n\nfloat wave(float t) {\n  if (!key(CHAR_T)) return 0.5*(1.0-cos(TWOPI*t));\n  // Triangle wave + smoothstep - without smoothing not enough\n  // at top and bottom & worse aliasing. With smoothing, I can't\n  // tell this from the cos curve though (smoothstep is a good\n  // approximation to an offset cosine).\n  t *= 2.0;\n  t = mod(t,2.0);\n  t = min(t,2.0-t);\n  t = smoothstep(0.0,1.0,t); // Cubic smoothing\n  return t;\n}\n\nvoid mainImage(out vec4 o, vec2 p) {\n    if (!key(CHAR_Z) && iMouse.x > 1.0) k = iMouse.x/iResolution.x; // Set k from mouse\n    p -= 0.5*iResolution.xy;\n    p /= scale;\n    float d = length(p);\n    float px = fwidth(p.x); // Same as 1.0/scale\n    float angle = spiral*atan(p.y,p.x)/TWOPI;\n    float h = 0.5*k*d/px;\n    h -= 1.0*iTime;\n    h += angle;\n    float h0 = h;\n    h = floor(h);\n    h -= angle;\n    //h -= 1.0*iTime; // How fast colours travel in the spiral\n    o = vec4(0.8);\n    if (!key(CHAR_C)) o.rgb = palette(h);\n    o *= wave(h0);\n    //o *= 2.0/(1.0+o); // tone mapping\n    float g = 0.4545;\n    //if (iMouse.y > 0.0) g = iMouse.y/iResolution.y;\n    if (!key(CHAR_X)) o = pow(o,vec4(g)); // Gamma correction if desired.\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[571, 571, 594, 594, 750], [752, 752, 773, 773, 1168], [1170, 1170, 1206, 1206, 1908]], "test": "untested"}
{"id": "DtBGWW", "name": "Rough Seas Porthole", "author": "Dave_Hoskins", "description": "Used my Rough Seas shader and added a cabin porthole, underwater effects, foam and distortion.\nIncludes GPU Audio - rewind ⏪ the shader if it's not playing.\nThe light dims when underwater, to give the impression of other portholes.\n", "tags": ["3d", "waves", "raymarch", "sound", "sea", "water", "ocean", "foam", "rough", "spray", "porthole"], "likes": 108, "viewed": 1785, "published": 3, "date": "1673467993", "time_retrieved": "2024-07-30T18:16:29.447102", "image_code": "// Rough Seas Porthole 🌊, by Dave Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2023.\n\n// This shader is  https://www.shadertoy.com/view/DtBGWW\n// Forked from     https://www.shadertoy.com/view/dtXGW4\n// Used my Rough Seas shader and added a cabin porthole, underwater effects, foam and distortion.\n\n// Inspiration was from: https://www.istockphoto.com/search/more-like-this/882229368?assettype=film&phrase=rough%20sea\n\n\n#define FAR 1400.\n#define FOG_COLOUR vec3(.33,.31,.3)\n#define SKY_TOP vec3(.1, .13, 0.13)\n#define FOAM_COLOUR vec3(.51,.55,.6)\n#define PI 3.141592653\n#define ZERO min(iFrame, 0)\n\n\nvec3 camPos;\nfloat time;\nvec3 surf;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n//#define EXPORT_VERSON\n\n//------------------------------------------------------------------------------\n\n// Hashes from here:\n// https://www.shadertoy.com/view/XdGfRR\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12i(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22i(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash13i(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33i(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// Smoothed noise overridden as 2D & 3D...\n//------------------------------------------------------------------------------\nfloat noise(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float res = mix(mix(hash12i(p),\n\t\t\t\t\t\thash12i(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(hash12i(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\thash12i(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13i(p), hash13i (p + add.xyy),f.x),\n                        mix(hash13i(p + add.yxy), hash13i(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13i(p + add.yyx), hash13i(p + add.xyx),f.x),\n                        mix(hash13i(p + add.yxx), hash13i(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n//-----------------------------------------------------------------\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat fbm(in vec2 p)\n{\n    float a = 1.;\n    float y = 0.0;\n    for (int i = ZERO; i< 5; i++)\n    {\n        y += noise(p) * a;\n        a *= .53;\n        p *= rot2D;\n        p.y += 9.1;\n    }\n    return y;\n}\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(in vec3 p, in vec3 dir)\n{\n    dir.y+=.02;\n    \n    dir.y = max(dir.y,0.001);\n    float d = 20.0/dir.y;\n    p = p + dir * d;\n    vec3 s = vec3(fbm(p.xz*.06))*.2;\n    s*=s;\n    s = mix(s, FOG_COLOUR, max(1.-dir.y*3.,0.0));\n    return mix(s, SKY_TOP ,abs(dir.y)*2.);\n    //return s;\n    \n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\n\nfloat oceanFundamental(in vec2 p, const in float tim, const in float iter)\n{\n    float a =noise(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n\n    p *= .035;// ...Scale it\n\n    for (float i = min(iTime,0.0); i <= 1.0; i += it)\n    {\n        float t = (1.08-i) * tim;\n        float r =noise(p*2.33+t) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .54;\n        p = p * rot2D;\n        \n        p += 37.7;\n    }\n\n    return h;\n}\n\n//-----------------------------------------------------------------\nfloat fbm(in vec3 p)\n{\n    float a = 1.;\n    float y = 0.0;\n    for (int i = ZERO; i< 5; i++)\n    {\n        y += noise(p) * a;\n\n        a *= .53;\n        p.xz *= rot2D;\n        p.y += 9.1;\n    }\n    return y;\n}\n\n// Do a warped multi FBM...\nfloat multiFbm(in vec3 p)\n{\n/*\n    float f = 0.0;\n    f = fbm(p*.87);\n    f = fbm(p + f);\n    f = fbm(p*.5 + f*.4);\n*/\n    // Thanks for shortening the code, iq, it looks mad but it's certaining faster compiling on Windows ANGLE machines.\n    float f = 0.0;\n    const vec3 fre = vec3(0.87,1.0,0.5);\n    const vec3 off = vec3(0.0 ,1.0,0.4);\n    for( int i=0; i<3; i++ )\n    {\n        f = fbm(p*fre[i] + f*off[i]);\n    }\n \n    return f;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(const in vec3 p, const float iter)\n{\n    float h = oceanFundamental(p.xz, time, iter);\n    return p.y-h;\n}\n \n// March across the sea...\n//-----------------------------------------------------------------\nvec2 rayMarchSea(in vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = ZERO; i < 100 && d < FAR; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, time, 8.);\n        float h = pos.y-hh;\n        \n        if (h < .2)\n        {\n            break;\n        }\n        float wind = (noise(pos*.03)) * fbm(pos*2.+vec3(-time*12., time*.11,0));\n        spr += max(25.-h, 0.0) * smoothstep(40.0, .0,max(h, 0.0))*smoothstep(FAR, 0.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n\n\n//==============================================================================\n#define FARCAB 100.0\n//------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n#define rotate(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec2 nutCut(in vec2 p, float s)\n{\n    float k = s / PI / 2.;\n    return rotate(p, floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\nfloat nut(vec3 p, vec3 size, float r)\n{\n    rotate(p.xy,r);\n    p.xy = nutCut(p.xy, 6.0);\n\n    // Now rounded box has 6 sides..\n    float t = roundedBox(p, size,.08);\n    t = min( t, length(p+vec3(0,0,.2))- size.x );\n\n    return t;\n}\n\n//------------------------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions/\nfloat length6( vec2 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y,1.0/6.); }\n// Distance to a squarish torus..\nfloat sdTorusFlat(vec3 p, vec2 t)\n{\n  float x = length(p.xy)-t.x;\n  return length6(vec2(x,p.z))-t.y;\n}\n\n//------------------------------------------------------------------------------\n// Min/max functions with material swap...\nvec2 maxV2(in vec2 v1, in vec2 v2)\n{\n    return (v2.x > v1.x) ? v2:v1;\n}\n    \nvec2 minV2(in vec2 v1, in vec2 v2)\n{\n   return (v2.x < v1.x) ? v2:v1;\n}\n\n//------------------------------------------------------------------------------\nvec2 mapCab(in vec3 p)\n{\n    // Do porthole rim as a flattened tourus...\n    vec2 d = vec2(sdTorusFlat(p-vec3(0,0,.4), vec2(9.1,1.1)), 0);\n    // Back wall...\n    d = minV2(d, vec2(.0-p.z, 2.0));\n    // Do the nuts as a mirrored configuration...\n    p.xy = abs(p.xy);\n    d = minV2(d, vec2(nut(p - vec3(6.2, 6.5, -.8),vec3(.15, .15, .12), .5), 1.0));\n    d = minV2(d, vec2(nut(p - vec3(8.9,.0,-.8),   vec3(.15, .15, .12), 0.0), 1.));\n\n    return d;\n}\n\n//------------------------------------------------------------------------------\n//Sped up for ANGLE with example from iq:  //https://www.shadertoy.com/view/3lsSzf\nvec3 normalCab(const in vec3 pos, float ds)\n{\n    ds *= .5/iResolution.y;\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapCab(pos+ds*e).x;\n    }\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\nfloat shadowCab(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .01;\n    for( int i = ZERO; i < 10; i++ )\n    {\n\t\tfloat h = mapCab(ro + rd*t).x;\n\n        res = min( res, 4.*h/t );\n        t += h;\n        if (res < .1) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n//------------------------------------------------------------------------------\nvec3 lightCab(in vec3 pos, const in vec3 nor,  const in vec3 dir, const in vec4 mat, const in float wat)\n{\n    vec3 lamp = vec3((noise(vec2(time*.5))-.5)*30.,wat*.2,-15);\n\n    vec3 ldir = normalize(lamp-pos);\n    float a = smoothstep(-10.0, 4.0, wat)*.3+.05;\n    float sha = shadowCab(pos, ldir);\n    vec3 col = mat.xyz * max(dot(nor, ldir), 0.0)*4.*a*sha;\n    vec3 ref = reflect(dir, nor);\n    col += vec3(1.,.8, .7) * pow(max(dot(ref, ldir), 0.0), 2.0) * mat.w * sha;\n    return min(col, 1.0);\n} \n\n//------------------------------------------------------------------------------\nvec2 marchCabin(const in vec3 ro, const in vec3 rd)\n{\n    vec2 d = vec2(0);\n    for (int i = ZERO; i < 30 && d.x < FARCAB; i++)\n    {\n        vec3 p = ro+rd*d.x;\n        vec2 m = mapCab(p);\n        d.y = m.y;\n        if ((m.x) < .05 ||  d.x > FARCAB) break;\n        d += m.x*.8;\n        \n\n    }\n    return d;\n}\n\n//==============================================================================\n\n//------------------------------------------------------------------------------\n// Get a view ray of pixel using Euler...not a flat projection...\nmat3 viewMat ( const in float ay, const in float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// Sped up for ANGLE with example from iq:  //https://www.shadertoy.com/view/3lsSzf\n// Uses a higher iteration cound for details...\nvec3 normal(const in vec3 pos, in float ds)\n{\n    ds *= 1./iResolution.y;\n    ds = max(ds*ds, .1);\n                          \n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+ds*e, 14.0);\n    }\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// Super fast water caustic...\n// https://www.shadertoy.com/view/MdKXDm\n#define F length(.5-fract(k.xyw*=mat3(-2,-1,2, 3,-2,1, 1,2,2)*\nfloat waterPattern(vec2 p)\n{\n    vec4 k;\n    k.xy = p*(sin(k).w+2.)*.009;\n    return pow(min(min(F.5)),F.4))),F.3))), 7.)*20.;\n}\n\n//------------------------------------------------------------------------------\n// Juggled for just artistic reasons...\nfloat waveDepth(const in vec3 p, const in vec3 dir)\n{\n    float d = 0.0;\n    for( float i = min(time,3.0); i <= 23.0; i+=5.)\n    {\n        float h = map(p + dir*i, 8.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n// Standard lighting...\n//------------------------------------------------------------------------------\nvec3 lighting(const in vec3 pos, const in vec3 nor, const in vec3 dir, const in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 7. ), 0.0, 1.0)*.6;\n\n    col = mix(col, sky(pos, nor), .3);\n    col = mix(col, sky(pos, ref), fres);\n    return col;\n}\n\n\n// Get the sea colour...\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.3;\n    vec3 mat = vec3(.1,.1,.12);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.3,.7,.7), dep);\n    pos.x += time * 4.;\n    pos*=3.5;\n     \n\n    // Add different frequencies of voronoi cells...\n    float ny = clamp(nor.y, 0.4, 1.0);\n    float foam = waterPattern(pos.xz +pos.y*.3) * 3.;\n    foam += waterPattern(pos.xz*.37)*5.;\n    foam = clamp(foam, 0.0, 1.0);\n    mat = mat+foam * (dep*dep*1.5+ny*.01);\n    return mat;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat distanceRayPoint( const in vec3 ro, const in vec3 rd, in vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return length(p-rd*h);\n}\n\n#define tri(x) abs(fract(x)-.5)*2.\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(const in vec3 id)\n{\n    return tri(id+time*.5);\n}\n\nvec3 getColour(const in vec2 id)\n{\n    float t1 = id.x*.4;\n    float t2 = id.y*.4;\n    return vec3(.75,.6+t1, .6+t2);\n}\n\n//----------------------------------------------------------------------------------------------------------\n#define BUBBLES 65\n#define BUBBLE_SIZE 50.0\n// I believe I was inspired by iapafoto, who does the same here:\n// https://www.shadertoy.com/view/Xl2BRR\nvec3 bubbles(in vec3 ro, const in vec3 rd)\n{ \n    float d;\n    \n    ro *= .00002;\n    ro.x+=time*5.;\n    float fade = 1.0;\n    \n\tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n\tfor( int i = ZERO; i < BUBBLES; i++ )\n    {\n        vec3 id = hash33i(pos*19.31);\n        float si = (id.x+id.z)*.25+.08;\n        vec3 offset = getOffset(id);\n        d = distanceRayPoint(ro, rd, pos+offset);\n        vec3 mat =  getColour(id.xy);\n        col = mat * pow(smoothstep(si, 0.0,d),8.)*10. *fade;\n        sum += col;\n        fade*= .98;\n\t\tvec3 mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(const in float edge0, const in float edge1, const in float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\n// Surface foam.\nvoid surfFoam(const in vec3 p, const in float water)\n{\n     float w = -(water-4.0)*pow(multiFbm(p*2.+vec3(0, time*8., time*4.)), 2.0)*.5;\n     surf += FOAM_COLOUR*fbm(camPos*8.3+vec3(0,0,time*6.))* .35 * w;\n     surf *= FOAM_COLOUR*smoothstep(-10.,1.0, water);\n}\n\n//------------------------------------------------------------------------------\n// Get p's position in water at time ti.\nfloat underWaterAtTime(const in vec3 p,  const in float ti)\n{\n    float h = oceanFundamental(p.xz, ti, 8.0)+multiFbm(camPos*5.3+ti*7.);\n     \n    return p.y-h-4.;\n}\n\n\n// Get the camera at time ti\nvec3 cameraLocation(const in float ti)\n{\n     vec3 p = vec3(ti*10.,100,0);\n     float h = (sin(ti*.65)+1.0)*40. + (sin(ti*1.37))*10. + 20.;\n     p.y = h;\n        \n     // Don't spend too long in the water?..\n//     float w = (map(p, 8.0));\n//     if (w < 0.0) p.y  += w*w*.04;\n     return p;\n}\n\n// Do a bump map of sorts...\nvec3 bumpmap(in vec3 p, in vec3 dir, in float a)\n{\n    p *= 5.;\n    float v0 = multiFbm(p);\n    float v1 = multiFbm(p+vec3(.1,0.,0));\n    float v2 = multiFbm(p+vec3(0,0.,.1));\n    vec3 grad = normalize(vec3(v1-v0, 0.0, v2-v0));\n    grad -= dir*dot(dir, grad);          \n\n    \n    return normalize( dir + grad*a );\n}\n \n//------------------------------------------------------------------------------\n// Grab the vec4 diffuse texture with specular in .w...\n// You can also adjust the normal here..\nvec4 getMaterial(const in int id, const in vec3 p, inout vec3 nor)\n{\n    vec4 col = vec4(0);\n    vec2 bn = vec2(0.0);\n    float d = 0.0;\n    switch (id)\n    {\n        case 0: // Porthole rim...\n            col = vec4(.1, .07, .04, .5);\n            col = col*(.6+.4*multiFbm(p*5.+30.));\n            col.w = col.w*col.w*multiFbm(p*3.);\n            bn = vec2(3.0,0.08);\n            break;\n        case 1: // Nuts\n            col = vec4(.05, .05, .06, .3);\n            col.w = col.w*(.4+.6*multiFbm(p*21.));\n            break;\n        case 2: // Backwall.\n        \n            col = texture(iChannel0, p.xy*.15) * vec4(.6,1.2,15.,1.);\n            vec2 uv = fract(-p.xy*.15);\n            col *= smoothstep(0.0, .05, uv.y)*smoothstep(1., .95, uv.y)+.1;\n            col *= vec4(.1,.05,.01,.1);\n            col.w = pow(col.x*10., 5.);\n//            Metal...\n//            col = vec4(.0, .01, multiFbm(p*.5-300.)*0.02, .2 );\n//            float f = multiFbm(p+999.);\n//            col = mix(col, col, smoothstep(.5, .52, f));\n//            bn = vec2(4.,0.1);\n//            col =mix(col, vec4(0.03, 0.01,0,.1), (max(fbm(p*1.53)-0.2,0.))*.2);\n            break;\n    }    \n    nor = bumpmap(p * bn.x, nor, bn.y);\n    return col;\n}\n\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    time = iTime+232.;\n    uv*= .8+sin(clamp(iTime*.5-0.3, 0.,3.5))*.3;\n    // Reset colours...\n    vec3 colour = vec3(0);\n    surf = vec3(0.0);\n    // Make simple camera shade with uv movements...\n    vec2 shake = vec2(noise(vec2(time*.6))-.5, noise(vec2(time*.7+233.))-.5) * vec2(.1, .1);\n    uv += shake;\n    \n    camPos = cameraLocation(time);\n    float porthole = length(uv)*2.;\n    \n    // Don't do things unnecessarily layered, only render sea in porthole...\n    if (porthole < 1.0)\n    {\n        // Camera...\n        // We need to start the ray from the porthole, because a single camera point will all go underwater at the same time,\n        // and it needs to have the window wash effect.\n        camPos.xy += uv*10.;\n\n        vec3 dir  = vec3(0,0, 1.);\n        dir = viewMat (uv.y +.0, uv.x+.5) * dir;\n        // Simmulate pitching of the boat....\n        rotate(dir.zy, (sin(time*.5)*sin(time*.37)*.6));\n        \n        float water = (underWaterAtTime(camPos, time));\n        \n        if(water < 4.0) //...Minus values under water\n        {\n            \n            // Tint water colour to green sea...\n            colour  = mix(FOAM_COLOUR, vec3(.0, .04,.03),clamp(pow(-(water-4.0), .4)*.3, 0.0, 1.0));\n            // With a deeper blue...\n            colour  = mix(colour, vec3(.0, .0,.02),clamp((-3.0-water)*.015, 0.0, 1.0));\n            // Top white foam band..\n            colour  = mix(colour, FOAM_COLOUR,clamp(2.-(water*water*.4)*multiFbm(camPos*3.3), 0.0, 1.0));\n            \n            // Do 2D surf Foam...\n            surfFoam(camPos, water);\n            \n            // If under water, do bubbles...\n            if (water < .0) surf += bubbles(camPos*25000., dir)*.3*clamp(4.0+water*.1,0.1, 3.0)*.03;\n        }\n        if (water >= 0.)\n        {\n            // Get camera location from 1 second ago, so the disorted drips appear after a water wipe...\n            vec3 p = cameraLocation(time-1.);\n\n            float past = underWaterAtTime(p, time-1.); // ...Did we go underwater a second ago?\n            // Determine an amount of water distortion...\n            float f = smoothstep(25.0, -8.0, past)*.15;\n            // Make the distortion less as we go down the screen...\n            float w = smoothstep(.6, -.3, uv.y);\n            f = f*f*3. * w;\n            float d =0.0;\n            if (f > 0.0)\n            {\n                dir = bumpmap(vec3(uv.x,time*.5,uv.y*.5), dir, f);\n            }\n\n            // March the sea\n            vec2 dis = rayMarchSea(camPos, dir);\n            if (dis.x < FAR)\n            {\n                // The position is the start position plus the normalised direction X distance...\n                vec3  pos = camPos + dir * dis.x; // ...wave hit position\n                vec3  nor = normal(pos, dis.x);   // ... Normal\n                 // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n                float dep = waveDepth(pos, dir);\n                vec3  mat = diffuse(pos, nor, dep);\n                \n                colour = lighting(pos, nor, dir, mat);\n                colour = mix(FOG_COLOUR, colour, exp(-dis.x*.001));\n            }else\n            {\n                colour = sky(camPos, dir);\n            }\n\n           colour = mix(colour, FOAM_COLOUR, dis.y);\n\n            \n         }\n    }else \n    {   // Everything outside the portal...\n        float water = (underWaterAtTime(camPos, time));\n     \n        vec3 dir  = vec3(0,0, 1.);\n        dir = viewMat (uv.y, uv.x) * dir;\n        camPos = vec3(0,0,-15);\n        vec2 dis = marchCabin(camPos, dir);\n        if (dis.x < FARCAB)\n        {\n            vec3 pos = camPos + dir * dis.x;\n            vec3 nor = normalCab(pos, dis.x);\n            int matID = int(dis.y);\n            vec4 mat = getMaterial(matID, pos, nor);\n            colour = lightCab(pos, nor, dir, mat, water);\n        }\n    }\n    colour += surf;\n\n    if (porthole < 1.0) colour = mix(colour, colour*.1, smoothstep(0.9, 1.,porthole));\n    \n    // Some adjustment..\n    colour = clamp(colour*.2 + smoothstep(0.0, 1.0, colour)*.8,0.0, 1.0);\n\n    colour = sqrt(colour);\n    colour += hash12i(coord+time)/256.0; //...Dither those 8bit limitations away\n    \n    \n#ifdef EXPORT_VERSON\n    outCol = vec4(fader(0.0, 4.0, iTime) * fader(299.0, 294.0, iTime)*colour, 1);\n#else\n    outCol = vec4(fader(0.0, 4.0, iTime) * colour, 1);\n#endif\n    outCol += hash12i(coord+time)/256.0; //...Dither those 8bit limitations away\n}\n\n//-----------------------------------------------------------------\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n\n// Rough Seas 🌊, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nvec2 ihash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n*/\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t = time;\n    \n    \n    // Add vary volumes of different frequencies...\n    // Magic numbers again, sorry folks...\n    v = noise2D(t*.6)*.5+.5;\n    v = v*v*3.0;\n    aud = noise2D(t*320.+sin(t*.1)*100.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    v = v*v*3.0;\n    aud += noise2D(t*600.)*v;\n\n    v = noise2D(-t*.3)*.8;\n    aud += noise2D(t*1300.)*v;\n\n    v = noise2D(-t*.5)*.6;\n    aud += noise2D(t*2200.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*7500.)*v;\n    \n    v = (noise2D(t*.4) +noise2D(t*.3))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*10000.)*v;\n    \n\n\n    aud = clamp(aud*.9, -1.0, 1.0);// Clamp it properly\n    aud = 1.5*aud-.5*aud*aud*aud; // Loudness\n    aud *= fader(.0, 3.0,time) * fader(180.0, 170.0,time); // Fade in and out.\n    \n    return aud;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1098, 1098, 1121, 1121, 1210], [1212, 1212, 1234, 1234, 1315], [1317, 1317, 1340, 1340, 1435], [1437, 1437, 1459, 1459, 1546], [1549, 1673, 1697, 1697, 1948], [1950, 1950, 1974, 1974, 2457], [2641, 2641, 2663, 2663, 2847], [2849, 2953, 2987, 2987, 3248], [4027, 4095, 4117, 4117, 4305], [4307, 4335, 4362, 4573, 4771], [5002, 5097, 5136, 5136, 5690], [5796, 5877, 5922, 5922, 5961], [6017, 6017, 6050, 6050, 6139], [6141, 6141, 6180, 6180, 6374], [6376, 6507, 6532, 6532, 6578], [6579, 6613, 6648, 6648, 6715], [6717, 6841, 6877, 6877, 6913], [6919, 6919, 6955, 6955, 6990], [6992, 7073, 7097, 7145, 7523], [7965, 8046, 8087, 8087, 8323], [11509, 11615, 11669, 11669, 12156], [14998, 15027, 15077, 15077, 15342], [16744, 16825, 16875, 16996, 21525]], "test": "untested"}
{"id": "clBGRy", "name": "another clock 4", "author": "jonasfrey", "description": "classic", "tags": ["clock", "shaderclockdenodev"], "likes": 4, "viewed": 229, "published": 3, "date": "1673456305", "time_retrieved": "2024-07-30T18:16:30.212057", "image_code": "\n\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n//IMPORTANT START, keep the lines with and between IMPORTANT START and IMPORTANT END\n// and add the tag 'shaderclockdenodev' to the shader\n// otherwise the shader will not work on https://shaderclock.deno.dev/\n// also at the moment only the following variables are available iTime, iResolution,fragCoord,iDate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//IMPORTANT END\n\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    // by default the rotation starts between quadrant II and quadrant III\n    // so this rotation compensates one quadrant\n    o_trn_fc_nor_offset = f_o_rotd(o_trn_fc_nor_offset, (1./4.)*3.);\n    \n\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.283185;\n    float n_freq_sec = fract(iTime)*n_tau;\n    //float n_t_sec = (iTime);\n    //n_t_sec = floor(iTime);// for snapping handle\n    float n_ang_nor = fract(atan(o_trn_fc_nor_offset.y, o_trn_fc_nor_offset.x)/n_tau);\n    vec4 o_col = vec4(0.);\n    float n_t_yea = (iDate.x);//year-1\n    float n_t_mon = (iDate.y);//month-1\n    float n_t_day = (iDate.z);//day-1\n    float n_t_sec_since_midnight = (iDate.w);//secs since midnight\n    \n    float n_dcenter, n_radius, n_pointerstart, n_pointerend, n, n_radians_nor,n_divisor, n_glow; \n    vec2 o;\n    n_dcenter = length(vec2(0.)-o_trn_fc_nor_offset);\n    \n    //sec\n    n_pointerstart = 0.4;\n    n_pointerend = 0.5;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/60.;\n    n_radians_nor = -floor(n_t_sec_since_midnight)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nsec = length(o-o_trn_fc_nor_offset);\n    \n\n    //min\n    n_pointerstart = 0.3;\n    n_pointerend = 0.4;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -n_t_sec_since_midnight/n_divisor;\n    n_radians_nor = -floor(n_t_sec_since_midnight/60.)/60.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nmin = length(o-o_trn_fc_nor_offset);\n    \n\n    //hou\n    n_pointerstart = 0.0;\n    n_pointerend = 0.3;\n    n_radius = max(n_dcenter, n_pointerstart);\n    n_radius = min(n_radius, n_pointerend);\n    n_radians_nor = -(n_t_sec_since_midnight/60./60./12.);\n    n_radians_nor = -floor(n_t_sec_since_midnight/60./60.)/12.;//make it tick tock!\n    o = vec2(cos(n_radians_nor*n_tau)*n_radius,sin(n_radians_nor*n_tau)*n_radius);\n    float nhou = length(o-o_trn_fc_nor_offset);\n\n    \n    n = min(pow(nsec,1.),nmin);\n    n = min(n, nhou);\n    n = 1.-sqrt(n);\n    n_glow = 1.;\n    n = pow(n, 1./n_glow);\n    fragColor = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 43, 43, 238], [239, 549, 606, 622, 3337]], "test": "untested"}
{"id": "ctSGzG", "name": "Cubemap To HDRi map", "author": "shaofun", "description": "Cubemap To spherical map", "tags": ["camera", "cubemap", "map", "spherical", "hdri"], "likes": 4, "viewed": 1417, "published": 3, "date": "1673443533", "time_retrieved": "2024-07-30T18:16:31.107663", "image_code": "// #define USE_CAMERA\n\nvec2 spherical_map(vec3 p) {\n    vec2 uv = vec2(atan(p.z, p.x), asin(p.y));\n    uv *= vec2(1.0 / TAU, 1.0 / PI); uv += 0.5;\n    return uv;\n}\n\nvec3 spherical_map(vec2 uv) {\n    uv -= 0.5; uv *= vec2(TAU, PI);\n    vec2 s = sin(uv), c = cos(uv);\n    return vec3(c.x*c.y, s.y, s.x*c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    if (all(equal(mouse, vec2(0)))) mouse = vec2(0.5);\n\n#if defined(USE_CAMERA)\n    camera cam;\n    cam.lookfrom = vec3(0, 0, 0);\n    cam.lookat   = CameraRotation((mouse - 0.5) * vec2(PI)) * vec3(0, 0, 1);\n    cam.aspect   = iResolution.x / iResolution.y;\n    cam.vfov     = 50.0;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = 1.0;\n    cam.aperture = 0.0;\n    \n    vec3 p = spherical_map(uv);\n    \n    vec2 uvv = spherical_map(p);\n    \n    ray r = get_ray(cam, uvv, vec3(1));\n    \n    vec3 col = texture(iChannel0, r.direction).rgb;\n#else\n    vec3 p = spherical_map(uv);\n    p *= CameraRotation((mouse - 0.5) * vec2(PI));\n    \n    vec3 col = texture(iChannel0, p).rgb;\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 51, 51, 163], [165, 165, 194, 194, 307], [309, 309, 364, 364, 1182]], "test": "untested"}
{"id": "dlj3Dw", "name": "Thin Spiral", "author": "mla", "description": "Drawing as thin a spiral as possible, while minimizing aliasing artefacts. k chosen to balance out the various effects that do appear.\n\nObviously this could be made shorter, I'm not particularly interested in suggestions for doing so.", "tags": ["spiral"], "likes": 12, "viewed": 281, "published": 3, "date": "1673429367", "time_retrieved": "2024-07-30T18:16:32.218692", "image_code": "// Thin Spiral, mla, 2023\n\nconst float PI = 3.141592654;\nfloat spiral = 1.0; // Number of arms on spiral, 0 for no spiral\nfloat scale = 1.0;  // This can be any value in fact\nfloat k = 0.6;      // Magic number - determined by experiment\n\nvoid mainImage(out vec4 o, vec2 p) {\n    if (iMouse.x > 1.0) k = iMouse.x/iResolution.x; // Set k from mouse\n    p -= 0.5*iResolution.xy;\n    p /= scale;\n    float d = length(p);\n    float px = fwidth(p.x); // Same as 1.0/scale\n    o = vec4(0.5+0.5*cos(k*PI*d/px-2.0*PI*iTime+spiral*atan(p.y,p.x)));\n    //o *= 2.0/(1.0+o); // Maybe simple tone-mapping?\n    float g = 0.4545; // 0.7 for more balanced stripes\n    //if (iMouse.y > 0.0) g = iMouse.y/iResolution.y;\n    if (!key(CHAR_X)) o = pow(o,vec4(g)); // Gamma correction always nice.\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlj3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 275, 275, 778]], "test": "untested"}
{"id": "mtjGWw", "name": "Cheaper orthonormal basis?", "author": "shaofun", "description": "faster and seems bug free?\n\nit's wrong and it can't normalize vec3. but i think the case of a common line with vec3(1) is usually much rarer.\n\nAMD Radeon Pro 5500 XT 8 GB 20000 TIMES 840x472\nOLD 17.7 FPS | NEW 33.1 FPS", "tags": ["technique", "tangent", "orthonormal"], "likes": 10, "viewed": 417, "published": 3, "date": "1673422301", "time_retrieved": "2024-07-30T18:16:33.154191", "image_code": "// modified from https://www.shadertoy.com/view/4sSSW3\n\n//#define NEW_WAY\n#define TIMES 20000\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n#if defined(NEW_WAY)\nvoid TBN(in vec3 N, out vec3 T, out vec3 B) {\n    // it's wrong and it can't normalize vec3. \n    // but i think the case of a common line with vec3(1) is usually much rarer.\n    // from HK-SHAO https://www.shadertoy.com/view/ddSSWy\n    \n    // T = cross(N, normalize(vec3(1))); // slower\n    // T = vec3(-N.z, 0, N.x); // bug\n    // T = cross(N, vec3(1)); // it is ok\n    // T = vec3(N.y-N.z, N.z-N.x, N.x-N.y); // cheaper\n    // B = cross(N, T);\n    \n    // thxs iq and elenzil\n    // from https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = sign(sign(N.z) + 0.5);\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    B = vec3(b, s + N.y * N.y * a, -N.y);\n}\n\n\n\n#else\n// from https://doi.org/10.1080/2165347X.2012.689606\nvoid TBN(in vec3 N, out vec3 T, out vec3 B) {\n    if (N.z < -0.999999) {\n        T = vec3(0, -1, 0);\n        B = vec3(-1, 0, 0);\n    } else {\n        float a = 1.0 / (1.0 + N.z);\n        float b = -N.x*N.y*a;\n        \n        T = vec3(1.0 - N.x*N.x*a, b, -N.x);\n        B = vec3(b, 1.0 - N.y*N.y*a, -N.y);\n    }\n}\n#endif\n\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    \n    for (int i = 0; i < TIMES; i++) {\n        TBN(nor,f,r);\n    }\n    \n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 167, 167, 219], [221, 221, 240, 240, 310], [312, 312, 349, 349, 578], [1928, 1978, 2036, 2036, 2410], [2413, 2413, 2470, 2470, 4568]], "test": "untested"}
{"id": "ctj3Wm", "name": "CubeMapBuffer IBL", "author": "shaofun", "description": "Using cubemap buffer as IBL", "tags": ["3d", "interactive", "sdf", "camera", "cubemap", "pathtracing", "ibl", "pbr"], "likes": 2, "viewed": 241, "published": 3, "date": "1673408901", "time_retrieved": "2024-07-30T18:16:34.349993", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.rgb / color.a, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A),\n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(0.0, 0.2, 6.0, 0.0));\n        store(ROTATION, vec4(0.0, 0.0, 0.0, 0.0));\n        \n        store(TARGET,   vec4(9.0, 2.0, 9.0, 0.0));\n        store(TMOUSE,   vec4(PI/4.0, PI/15.1, 0.0, 0.0));\n        store(PMOUSE,   vec4(PI/4.0, PI/15.1, 0.0, 0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// 2022.12.30\n// 1. fix blackened colors caused by incorrect light absorption.\n// 2. that also improved the frame rate.\n// 3. correct cumulative brightness in the alpha channel instead of always being one.\n// 4. which reduces noise.\n// 5. ~~discard pixels that are too dark, it brighten the pixel quality.~~\n\n// 2022.12.26\n// 1. enables metal to be used in IOR.\n// 2. small optimization of performance.\n// 3. simplified reflection operations.\n// 4. use plain black background.\n\n// 2022.12.24\n// 1. fixed camera jamming when looking up and down.\n\n// 2022.12.23\n// 1. fix the blackening of rough transparent material, it improved the frame rate.\n// 2. fix the camera misalignment when full screen.\n// 3. fix the inability to propagate reflected light inside an object.\n// 4. optimize the judgment about self-luminous light source.\n// 5. some formatting optimizations and minor efficiency optimizations.\n// 6. gamma correction for skybox.\n\n// 2022.12.21\n// 1. make the rotation of the view smooth.\n// 2. automatically perform noise reduction when stopping movement.\n// 3. hold down space to force a screen refresh.", "buffer_b_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 摄像机参数\nconst float camera_vfov       = 30.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 2.0;                  // 摄像机的对焦距离\nconst float camera_aperture   = 0.002;                // 摄像机的光圈大小\nconst float camera_exposure   = 1.0;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.0005;                    // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 2000.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.000005;                  // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = pow(camera_exposure / 256.0, gamma);   // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    vec3  normal;       // 切线空间法线\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.02;\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 地图列表\nconst object[] map = object[] (\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, -1.051, 0),\n                    vec3(0, 0, 0),\n                    vec3(3, 0.5, 3)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.6, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.9, // 粗糙度\n                    0.1, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.5, 0.5, 0.5)\n        ),\n        material(   vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(0.1, 1.0, 0.1)*10.0, // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.000  // 折射率 （真空）\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(-1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 0.2, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.1, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.460  // 折射率 （塑料）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(0.2, 0.2, 1.0), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.2, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.100  // 折射率 （铜）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0.0, -0.2, 2),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    0.0, // 金属度\n                    1.0, // 透明度\n                    1.500  // 折射率 （玻璃）\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    // 会重复的将欧拉角转换成旋转矩阵，实际上只用在第一次计算就行了\n    // 也有可能被编译器优化掉了\n    p *= angle(radians(rotation));\n    \n    switch(obj.shape) {\n        case SHAPE_SPHERE:\n            return sd_sphere(p, scale.x);\n        case SHAPE_BOX:\n            return sd_box(p, scale);\n        case SHAPE_CYLINDER:\n            return sd_cylinder(p, scale.xy);\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o; o.dis = TMAX;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 构建正交基旋转矩阵 from https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nmat3 TBN(vec3 N) {\n    float s = sign(N.z);\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    vec3  T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    vec3  B = vec3(b, s + N.y * N.y * a, -N.y);\n    \n    return mat3(T, B, N);\n}\n\n// 使用光线步进 (Ray March) 检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis;\n    }\n    return rec;\n}\n\n// 采样立方体贴图\nvec4 mix_cube_lod(samplerCube sharp, samplerCube blur, vec3 dir, float lod) {\n    return mix(textureLod(sharp, dir, lod), textureLod(blur, dir, lod), lod);\n}\n\n// 采样天空\nvec3 sky(ray r) {\n    return texture(iChannel2, r.direction).rgb * 1.0;\n}\n\n// 快速计算五次方\nfloat pow5(float x) {\n    float t = x*x; t *= t;\n    return t*x;\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float cosine, float F0) {\n    return mix(pow5(abs(1.0 - cosine)), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float cosine, float F0, float roughness) {\n    return mix(fresnel_schlick(cosine, F0), F0, roughness);\n}\n\n// 以 n 为法线进行半球采样\nvec3 hemispheric_sampling() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v; \n\n    return vec3(xy, z);\n}\n\n// 用粗糙度采样沿向量 n 半球采样\nvec3 hemispheric_sampling(float roughness) {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    float shiny = pow5(roughness); // 光感越大高光越锐利\n    \n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt((1.0 - r.x) / (1.0 + (shiny - 1.0) * r.x));\n    vec2 xy = sqrt(abs(1.0 - z*z)) * v;\n    \n    return vec3(xy, z);\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    vec3  normal       = rec.obj.mtl.normal;\n    float ior          = rec.obj.mtl.ior;\n    \n    normal = TBN(rec.normal) * normal; // 将切线空间法线转换到世界空间\n    float outer = -sign(dot(normal, r.direction)); // 光正在从外面穿入物体表面\n    \n    // 光线和物体表面参数\n    vec3 I  =  r.direction;\n    vec3 V  = -r.direction;\n    vec3 N  =  normal *= outer; // 如果处于 SDF 物体内部就反过来\n    vec3 C  =  r.color;\n    vec3 L;\n    \n    N = TBN(N) * hemispheric_sampling(roughness); // 用粗糙度半球采样\n    float NoV = dot(N, V);\n\n    float eta = outer > 0.0 ? ENV_IOR / ior : ior / ENV_IOR; // 计算折射率之比\n    float k   = 1.0 - eta * eta * (1.0 - NoV * NoV); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 3.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoV, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.y < F + metallic || k < 0.0) {\n            L = I + 2.0 * NoV * N; // 包含镜面反射、菲涅尔反射、全反射\n            // 下面可以提高帧数，但是会导致透明材质发黑，需要优化\n            C *= float(dot(L, normal) > 0.0); // 如果光穿入或穿出表面就直接吸收掉\n    } else {\n        if (rand2.x < transmission) {\n            L = eta * I - (sqrt(k)- eta * NoV) * N; // 斯涅尔折射\n        } else {\n            L = TBN(normal) * hemispheric_sampling(); // 漫反射\n        }\n    }\n\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r, inout bool hit_sky) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) { // discard;\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 能量守恒\n        r.color *= inv_pdf;\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        hit_sky = false;\n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            // r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r);\n            hit_sky = i == 0U;\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 更新光子的位置\n        r.origin = rec.pos;\n        \n        // 应用 PBR 材质更新光线\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n        r.color        *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        if (visible > intensity || visible < VISIBILITY) break; // 光太暗碰到光源\n    }\n\n    return r;\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color  = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE, inout bool hit_sky) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, iTime*iTimeDelta));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r, hit_sky).color;\n    \n    if (hit_sky) {\n        return vec4(color, brightness(r.color));\n    }\n\n    // 色调映射\n    color *= camera_exposure;\n    color  = ACESFitted(color);\n    \n    // 伽马矫正\n    color = pow(color, vec3(1.0 / gamma));\n\n    return vec4(color, brightness(r.color));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    bool hit_sky = false;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE, hit_sky); // 获取片元颜色\n    \n    if (bool(load(MOVING).x) || hit_sky) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// from https://www.shadertoy.com/view/4sKGWt\n\n// License: BSD\n// by Morgan McGuire, @CasualEffects\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nvec3 render(in vec3 light, in vec3 ro, in vec3 rd, in float resolution) {\n    vec3 col;\n    \n    if (rd.y < 0.0) {\n        // Hit ground plane y = 0 at this distance       \n    \tfloat t = -ro.y / rd.y;\n        \n        // Convert the hit point to a texture coordinate at meter scale\n        vec2 P = ro.xz + t * rd.xz;\n        vec2 Q = floor(P);\n        P = mod(P, 1.0);\n\n\n        // Apply procedural grid texture\n        const float gridLineWidth = 0.1;\n        \n        float res = clamp(2048.0 / resolution, 1.0, 3.0);\n        P = 1.0 - abs(P - 0.5) * 2.0;\n        float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(t + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n \n        float shade = mix(hash(100.0 + Q * 0.1) * 0.4, 0.3, min(t * t * 0.001, 1.0)) + 0.6;\n        col = vec3(pow(d, \n                       clamp(150.0 / (pow(max(t - 2.0, 0.1), res) + 1.0), 0.1, 15.0)\n                  )) * shade + 0.1;\n        \n    } else {        \n        // Sky with haze\t\t\n        col = vec3(0.3, 0.55, 0.8) * (1.0 - 0.8 * rd.y) * 0.9;\n        \n        // Sun\n        float sundot = clamp(dot(rd, light), 0.0, 1.0);\n        col += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);\n        col += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);\n        // col += 10.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 512.0);\n        col += 100.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 1024.0);\n        col += 1000.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 2048.0);\n\n        // Clouds\n        col = mix(col, vec3(1.0, 0.95, 1.0), 0.5 * \n                  smoothstep(0.5, 0.8, fbm((ro.xz + rd.xz * (250000.0 - ro.y) / rd.y) * 0.000008)));\n    }\n\t\n    // Horizon/atmospheric perspective\n    col = mix(col, vec3(0.7, 0.75, 0.8), pow(1.0 - max(abs(rd.y), 0.0), 8.0));\n    \n\treturn col;\n}\n\n\nvec4 mainImage(in vec3 ro, in vec3 rd) {\n\n    vec3 light = normalize(vec3(0.8, 0.3, -0.3));\n\n    vec3 col = render(light, ro, rd, iResolution.y);\n \n    // Gamma encode\n\tcol = pow(col, vec3(0.4545));\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    vec3 ro = vec3(iTime, 2.0 + sin(iTime), 0.0);\n\n    fragColor = mainImage(ro, rayDir);\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 188]], "test": "untested"}
{"id": "mlB3Dw", "name": "Perlin Noise V1.0", "author": "FifthStateOfMatter", "description": "Perlin Noise\nI'm not sure if my math is correct.", "tags": ["noise", "perlin"], "likes": 3, "viewed": 218, "published": 3, "date": "1673404969", "time_retrieved": "2024-07-30T18:16:35.237620", "image_code": "//I'm almost positive some of my math is wrong.\n//There were some things I just messed with until it looked right.\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat perlinNoise(vec3 p){\n    vec3 cellPos = floor(p);\n    vec3 cellFract = fract(p);\n    vec3 cellMix = cellFract*cellFract*(3.0 - 2.0*cellFract);\n    float value;\n    \n    vec3 blf = vec3(random3((cellPos + vec3(0, 0, 0))*1.0));\n    vec3 brf = vec3(random3((cellPos + vec3(1, 0, 0))*1.0));\n    vec3 trf = vec3(random3((cellPos + vec3(1, 1, 0))*1.0));\n    vec3 tlf = vec3(random3((cellPos + vec3(0, 1, 0))*1.0));\n    \n    vec3 blb = vec3(random3((cellPos + vec3(0, 0, 1))*1.0));\n    vec3 brb = vec3(random3((cellPos + vec3(1, 0, 1))*1.0));\n    vec3 trb = vec3(random3((cellPos + vec3(1, 1, 1))*1.0));\n    vec3 tlb = vec3(random3((cellPos + vec3(0, 1, 1))*1.0));\n    \n    value = mix(\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 0), blf), dot(cellFract - vec3(1, 0, 0), brf), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 0), tlf), dot(cellFract - vec3(1, 1, 0), trf), cellMix.x),\n            cellMix.y\n        ),\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 1), blb), dot(cellFract - vec3(1, 0, 1), brb), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 1), tlb), dot(cellFract - vec3(1, 1, 1), trb), cellMix.x),\n            cellMix.y\n        ),\n        cellMix.z\n    );\n    //Should I have to add 0.5 to this? I would think not but it looks weird otherwise.\n    return value + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float f = 30.0;\n    float h = 1.0;\n    float v = 0.5;\n    int d = 10;\n    \n    float n = perlinNoise(vec3(uv.x*f, uv.y*f, 1.0 + iTime*v))/h;\n    for(int i = 0; i < d; i++){\n        h *= 2.0;\n        f *= 2.0;\n        v *= 2.0;\n        n += perlinNoise(vec3(uv.x*f + float(i)*10.0, uv.y*f + float(i)*10.0, 1.0 + iTime*v + float(i)*10.0))/h;\n    }\n    vec3 col = vec3(n/(float(d)/5.0));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 150, 172, 172, 278], [280, 280, 306, 306, 1604]], "test": "untested"}
{"id": "Dl2GWm", "name": "Domain Warping V1.2", "author": "FifthStateOfMatter", "description": "Domain Warping with Perlin noise.", "tags": ["noise"], "likes": 2, "viewed": 263, "published": 3, "date": "1673404941", "time_retrieved": "2024-07-30T18:16:36.001577", "image_code": "//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat perlinNoise(vec3 p){\n    vec3 cellPos = floor(p);\n    vec3 cellFract = fract(p);\n    vec3 cellMix = cellFract*cellFract*(3.0 - 2.0*cellFract);\n    float value;\n\n    vec3 blf = vec3(random3((cellPos + vec3(0, 0, 0))*1.0));\n    vec3 brf = vec3(random3((cellPos + vec3(1, 0, 0))*1.0));\n    vec3 trf = vec3(random3((cellPos + vec3(1, 1, 0))*1.0));\n    vec3 tlf = vec3(random3((cellPos + vec3(0, 1, 0))*1.0));\n\n    vec3 blb = vec3(random3((cellPos + vec3(0, 0, 1))*1.0));\n    vec3 brb = vec3(random3((cellPos + vec3(1, 0, 1))*1.0));\n    vec3 trb = vec3(random3((cellPos + vec3(1, 1, 1))*1.0));\n    vec3 tlb = vec3(random3((cellPos + vec3(0, 1, 1))*1.0));\n\n    value = mix(\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 0), blf), dot(cellFract - vec3(1, 0, 0), brf), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 0), tlf), dot(cellFract - vec3(1, 1, 0), trf), cellMix.x),\n            cellMix.y\n        ),\n        mix(\n            mix(dot(cellFract - vec3(0, 0, 1), blb), dot(cellFract - vec3(1, 0, 1), brb), cellMix.x),\n            mix(dot(cellFract - vec3(0, 1, 1), tlb), dot(cellFract - vec3(1, 1, 1), trb), cellMix.x),\n            cellMix.y\n        ),\n        cellMix.z\n    );\n    return value + 0.5;\n}\n\nfloat domainWarp(vec2 p, float z){\n    float c = perlinNoise(vec3(p*10.0, z))*1.0;\n    for(int i = 0; i < 2; i++){\n        c = perlinNoise(vec3(c*5.0, c*5.0, z*5.0) + 10.0)*1.0;\n    }\n    return c/1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = mix(vec3(1, 0.3, 0), vec3(0.8, 0, 0), domainWarp(uv, iTime*0.1));\n\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 56, 56, 162], [164, 164, 190, 190, 1388], [1390, 1390, 1424, 1424, 1593], [1595, 1595, 1649, 1649, 1845]], "test": "untested"}
{"id": "DtjGWm", "name": "Fractal mosaic 36", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 17, "viewed": 334, "published": 3, "date": "1673402078", "time_retrieved": "2024-07-30T18:16:36.911145", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        vec2 uv1 = uv;\n        uv = (uv+t2)/scale;\n        t2 = triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        col.x =\n            max(max((t2.y-t2.x*sign(uv.x)),abs(uv.y-uv.x))/3.,col.x)\n        ;\n        col =\n            max(abs(col-1.+col.x),col/4.);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "//remixed from https://www.shadertoy.com/view/cdXXRB\n\n#define sqmod(x,y) floor(mod(floor(x)/4.,y*y)/y)\n//#define sqmod(x,y) max(floor(mod(floor(x),y*y)/y),mod(floor(x)*floor(x),y))\n\n\nvec2 mainSound(int samp, float time){\n time *= 4.;\n float s1 =\n      4.;\n  \n  float\n  m4 =\n      pow(2.,-2.+sqmod(floor(time/s1),3.))\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      sqmod(floor(t*s1)/s1,s1)\n  ,\n  m3 =\n      sqmod(floor(t*s1*2.)+t*(.5-m4)*2.,s1-m1);\n  t *=\n      s1*s1/(1.+m4)\n  ;\n  float m2 =\n      1. + sqmod(t/s1,s1)\n  ;\n  \n  float a=sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2/(1.+m4),\n\n  nb = pow(2.,(m3+m2)/5.+6.5)*4./(1.+mod(floor(t),s1))/2.;\n\n  return vec2(fract(time*nb*.998/2.)*a\n   ,fract(time*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 128], [130, 130, 187, 187, 825]], "test": "untested"}
{"id": "Dl2GDw", "name": "Fractal mosaic 35", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 20, "viewed": 387, "published": 3, "date": "1673399011", "time_retrieved": "2024-07-30T18:16:37.725967", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,.5)\n        //-vec2(1.,.5)\n        //vec2(1.5,0.)\n        //vec2(0.,2.)\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)))/1.5;\n\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n        //abs(abs(fract((a1)*(a2.x+a2.y))-.5)-.5)\n        //abs(abs(fract((a1)*(a2.x+a2.y))-.5)+.125)/1.125\n    ;\n}\n\nconst float scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n    uv = (uv+t2)/scale;\n    //uv += (distance(floor(uv),round(uv+.5)));\n\n    //uv *= sign(uv1-uv1.yx);\n    //uv *= sign(uv-uv.yx);\n\n    //if(uv.y>uv.x) uv = uv.yx;\n    t2 = triangle_wave(uv+.5);\n\n    //uv += floor(uv.y-uv.x);\n    uv = t2-triangle_wave(uv.yx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        //uv += pow(floor(uv.x*2.),3.)/2.;\n\n        //uv.x -= floor(uv.y*1.5)/1.5;\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        //if(uv.x>uv.y)\n        float warp_scale = 16.;\n        vec2 warp =\n            vec2(0.)\n            //vec2(sin((t2.x)*warp_scale),cos((t2.y)*warp_scale))\n            //vec2(sin((uv.x)*warp_scale),cos((uv.y)*warp_scale))\n        \n        ;\n        warp = warp*warp/warp_scale;\n        vec2 uv_1 = uv+warp,\n        t2_1 = t2+warp;\n        \n        transform(uv,t2);\n        transform(uv_1,t2_1);\n        \n        //uv.x += sign(uv.y-uv.x-.5)+.5;\n        \n        //another really interesting pattern\n        //uv.x +=\n            //floor(uv1.x)/1.5\n            //.5\n        //;\n        \n        //uv += dot(uv,uv); //makes another interesting pattern\n        col.x =\n            max(max(abs(t2_1.y*sign(uv_1.y)-t2_1.x),abs(uv_1.y*sign(uv_1.y)-uv_1.x))/3.,col.x)\n            //max(max(abs(t2.y*(uv.y)-t2.x),abs(uv.y*(uv.y)-uv.x))/3.,col.x)\n            //max(max(fract(t2.y-t2.x+.5),fract(uv.y-uv.x+.5))/3.,col.x)\n            //max(max(abs(t2.y-t2.x),abs(uv.y*sign(uv.x)-uv.x))/3.,col.x)\n        ;\n        col =\n            abs(col-(1.-col.x))\n            //abs(col-(1.-max(col.x,max(col.y,col.z)))).yzx\n            //max(abs(col-(1.-col.x)),col/4.)\n        ;\n            //abs(col*col.yzx-(1.-col.x));\n        //{uv=uv.yx;t2=t2.yx;}\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "#define fract1(a) abs(1.-fract(-a)*fract(-a))\n\nfloat fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nfloat fmod(float a, float b){\n    //a += floor(a/8./pow(8.,fmod2(a,8.)));\n    //a = a/2. + floor(a)/b*8.;\n    //a += pow(b/2.,2.);\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(a)/3.*b),b)\n        //mod(mod(floor(a)+4.,floor(a/4.)+4.),b)\n        //floor((mod(floor(a+b/2.),b)+mod(floor(a+b/4.),b/2.)))\n        //max(mod(floor(-a),b),mod(floor(a/2.),b))\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n//#define fmod(a, b) mod(mod(floor(a),floor(1.+(a)/2.)),b)\n\n//#define fmod(x,y) mod(floor(floor(x)+mod((x)/8.,8.)/8.),y)\n//#define fmod(x,y) mod(floor(x+floor((x)/y/y)*floor((x)/y/y)),y)\n//#define fmod(x,y) max(floor(mod(floor(x)*(y*y+2.),y*y)/y),floor(mod(floor(x)*(y*y-2.),y*y)/y))\n\nvec2 mainSound(int samp, float time){\n  \n  float tempo = 1.;\n  time /= tempo;\n  \n  //time = (time + pow(2.,fmod(time*2.,3.)));\n  \n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time*8.),2.); }\n  //time = time+floor(time)*floor(floor(time));\n  float s1 =\n      8.,\n  m4 =\n      fmod(floor(time/4.)*floor(time/s1/2.),2.)\n  ,\n  s2 = s1,\n  t=\n      time/4.\n      //(time/2.+fmod(time/2.+.5,2.))*2.\n  ,\n  m1 =\n      fmod(floor(t*(.5-m4)*2.),s2)\n  ,\n  m3 =\n      fmod(floor(t)/(m1+.5),s2);\n\n  t *=\n      s1*s1/2./(1.+fmod(t,2.))\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a=\n      //pow(2.,log(1.)-log(fract(t/s1)/2.))\n      //log(.125/4.+fract1(t/s1)/8.)\n      -(log(1./64.+fract1(t/s1)/4.))\n  ,\n\n  nb =\n      time*pow(2.,(m3+m2)/7.+6.)*tempo\n      //pow(2.,(m3+m2+mod(m3/2.-m2,2.)*2.)/5.+5.5)\n  ;\n\n  return\n      //abs(.5-vec2(fract(nb*.998*2.),fract(nb*(1.+fmod(t/s1/s1,2.)))))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a))\n      \n      //oud\n      a/16./2.*abs(\n      log(.5+a*abs(abs(.5-vec2(fract1(nb*.998*2.),fract1(nb*2.)))/2.))\n      +.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n\n      \n      //vec2(fract(nb*.998/4.*m2*s1)*a,fract(nb/4.*m2)*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 503], [531, 531, 576, 576, 838], [840, 840, 897, 897, 2572]], "test": "untested"}
{"id": "clj3Ww", "name": "mouse speed", "author": "jonasfrey", "description": "mouse speed ", "tags": ["mouse", "speed", "buffer"], "likes": 7, "viewed": 191, "published": 3, "date": "1673394918", "time_retrieved": "2024-07-30T18:16:38.496906", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n \n    vec4 o_col = texture(iChannel0, o_trn_fc_nor);\n    // Output to screen\n    fragColor = o_col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float f_n_rand(float n){\n    n += 1.23;\n    n *= 3.12;\n    n = sin(1234.23*n+n)*123.;\n    n = cos(n*0.123);\n    return fract(n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the info of the mouse will be stored in the first pixel\n    ivec2 o_p_o_trn_mo_nor_offset = ivec2(0.,0.);\n    \n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    if(iMouse.z == 0.){\n        float n_rand = f_n_rand(iTime);\n        o_trn_mo_nor_offset = vec2(\n            cos((iTime+((n_rand-0.5)*0.02))*3.)*0.3,\n            sin(iTime+((n_rand-0.5)*0.02))*0.3\n        );\n    }\n    float n_d = length(o_trn_fc_nor_offset - o_trn_mo_nor_offset);\n    \n    vec4 o_col_last = texture(iChannel0, o_trn_fc_nor);\n    \n    float n_length_mouse = length(o_trn_mo_nor_offset);\n    vec4 o_trn_mo_nor_offset_last = texelFetch(iChannel0, o_p_o_trn_mo_nor_offset, 0);\n    vec2 o_trn_mo_nor_offset_delta = abs(o_trn_mo_nor_offset.xy - o_trn_mo_nor_offset_last.xy);\n    //n_d = smoothstep(0.1, 0.11, n_d);\n    float n_mouse_speed = o_trn_mo_nor_offset_delta.x;\n    \n    //n_d = (1.-n_d)*(1.+n_mouse_speed*100.);\n    float n_sms = n_mouse_speed*0.2;\n    float n_aa = n_ratio_1to_iresx*50.+n_ratio_1to_iresx*n_mouse_speed*20.+n_mouse_speed*2.;\n    n_d = smoothstep(n_sms+n_aa, n_sms, n_d);\n    vec4 o_col = mix(o_col_last, vec4(n_d),0.01+n_mouse_speed*0.1);\n    o_col += vec4(n_d);\n    fragColor = o_col;\n    //fragColor = vec4(o_trn_mo_nor_offset_delta.x);\n    \n\n    if(ivec2(fragCoord.xy) == ivec2(o_p_o_trn_mo_nor_offset)){\n        fragColor = o_trn_mo_nor_offset.xyxy;//swizzeling :0\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clj3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 586]], "test": "untested"}
{"id": "mls3zj", "name": "The Root of Reality", "author": "derSchamane", "description": "drag mouse for camera rotation\n\nmusic: der Schamane - \"The Cube\" \nsubstance reference: 2C-B", "tags": ["3d", "tunnel", "transparent"], "likes": 7, "viewed": 325, "published": 3, "date": "1673384845", "time_retrieved": "2024-07-30T18:16:39.372565", "image_code": "//                  = The Root of Reality =         \n//               by Maximilian Knape ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define MAX_STEPS 500\n#define MAX_DIST 350.\n#define MIN_DIST 20.\n#define STEP_FAC 1.1\n\n#define SURF_DIST .03\n#define SURF_MUL 500.\n#define SURF_EXP 12.\n\n#define PP_CONT 1.4\n#define PP_VIGN 2.0\n\n#define iTime iTime*1.3\n#define PI 3.14159265358979\n#define TAU 6.28318530717958\n#define S(x,y,t) smoothstep(x,y,t)\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max(k-abs(a-b),0.);\n    return min(a, b) - h*h*.25/k;\n}\n\nvec2 Map(vec3 p) \n{    \n    float d = MAX_DIST, col = 0.85;\n    vec3 pos = p;\n\n    if (length(p - 100. + vec3(pow(sin(iTime*3./4.5), 3.)*20.)) < 50.)\n        for(float i = 0.; i < 5.; i++)\n        {\n            float t = (iTime + 2.*pow(sin(iTime/23.),3.))*3. - i*.8;\n            p = pos - 100. + vec3(pow(sin(t/4.5), 3.)*20. + i);\n            float s = length(p + sin(t / vec3(4.1,6.3,2.2)) * vec3(11,19,8));\n            s -= (4. / (i*i*.1 + 1.)); \n            d = smin(s *.6, d, 3. - i*.5);\n        }\n    \n    pos = pos + vec3(iTime*10. + pow(sin(iTime/15.), 3.));\n    p = pos / 12.;\n    \n    float n1 = length(dot(sin(p/2.5), cos(p*1.8))) + .2 + 1./(iTime/2.+.01);\n    col = mix(col, 1.0, step(n1, d));\n    d = min(n1, d);\n    \n    p =  pos / 72. + pow(sin(iTime/124.), 3.)*10.;\n    float n2 = length(dot(sin(p/14.5), cos(p))) - (.3 + sin(iTime/13.)*.1);\n    col = mix(col, 2.0, step(n2, d));\n    d = min(n1, d);\n   \n    \n    return vec2(d, col);\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(.85, .15, .3);\n        case 2: return vec3(.3, .65, 1.);\n        case 3: return vec3(1., .8, .3);\n    }\n    return vec3(0.);\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIST;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0), col = vec3(1);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIST * (pow(d/MAX_DIST, SURF_EXP)*SURF_MUL + 1.));\n        if (s < sd || d > MAX_DIST) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        \n        vec2 map = Map(p);\n        col = mix(col, Palette(int(floor(map.y))), .02 * (1.-sum));\n        \n        s = max(abs(map.x), 2. * sd);\n        d += s * STEP_FAC * (1.1 - fract(map.y));\n        \n        sum += a;\n    }\n    \n    col *= sum - pow(1. - (length(ro - p) / MAX_DIST), SURF_EXP);\n    \n    return col;\n}\n\nmat2 Rot(in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(.9)); //vec3(.4545)\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(-1);\n    ro.yz *= Rot(-PI/2. + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0), .8);\n    \n    vec3 col = RTM(ro, rd);\n    \n    float dr = dot(rd, vec3(.57735));\n    col += pow(max(dr, 0.), 100.+sin(iTime*.9)*20.)*Palette(3)*.65;\n    col *= pow(dr*.5+.5, .5+sin(iTime/5.)*.2)*S(0., 1., iTime);\n    col -= S(1.-1e-3, 1., dr)*.2*sin(iTime/5.);\n    col += S(1.-5e-5, 1., dr)*.3;\n    \n    col += .2 * S(0., 10., iTime) * ((S(-1., 1., dr) - S(0.99, 1., dr)) *\n           S(0.3, 3., length(sin(10.*normalize(vec2(-abs(rd.z-rd.x), abs(rd.y-rd.x)) * Rot(iTime/31.))))));  \n\n    fragColor = PP(col, uv);\n}", "image_inputs": [{"id": 31961, "src": "https://soundcloud.com/derschamane/der-wurfel", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mls3zj.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[609, 609, 655, 655, 725], [727, 727, 746, 746, 1678], [1680, 1680, 1705, 1705, 1926], [1928, 1928, 1957, 1957, 2665], [2667, 2667, 2689, 2689, 2765], [2767, 2767, 2821, 2821, 3016], [3018, 3018, 3046, 3046, 3232], [3234, 3234, 3291, 3291, 4076]], "test": "untested"}
{"id": "dlSGWm", "name": "Warping boxes", "author": "mrange", "description": "CC0: Warping boxes\nI tinkered with the multi-level metaballs of yesterday\nand used boxes instead of circles. This + random tinkering\nturned out quite nice in the end IMHO.\n\n", "tags": ["2d", "warping"], "likes": 35, "viewed": 550, "published": 3, "date": "1673381999", "time_retrieved": "2024-07-30T18:16:40.486586", "image_code": "// CC0: Warping boxes\n//  I tinkered with the multi-level metaballs of yesterday\n//  and used boxes instead of circles. This + random tinkering\n//  turned out quite nice in the end IMHO.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec2 df(vec2 p, float aa, out float h, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d0 = box(pp, vec2(1.45*sz-0.75*aa))-0.05*sz;\n  float d1 = sqrt(sqrt(dot2(pp*pp)));\n  h = fract(r);\n  sc = sz;\n  return vec2(d0, d1);\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 transform(vec2 p) {\n  p *= 2.0;\n  const mat2 rot0 = ROT(1.0);\n  const mat2 rot1 = ROT(-2.0);\n  vec2 off0 = 4.0*cos(vec2(1.0, sqrt(0.5))*0.23*TIME);\n  vec2 off1 = 3.0*cos(vec2(1.0, sqrt(0.5))*0.13*TIME);\n  vec2 sp0 = toSmith(p);\n  vec2 sp1 = toSmith((p+off0)*rot0);\n  vec2 sp2 = toSmith((p-off1)*rot1);\n  vec2 pp = fromSmith(sp0+sp1-sp2);\n  p = pp;\n  p += 0.25*TIME;\n  \n  return p;\n}\n\nvec3 effect(vec2 p, vec2 np, vec2 pp) {\n  p = transform(p);\n  np = transform(np);\n  float aa = distance(p, np)*sqrt(2.0); \n\n  float h = 0.0;\n  float sc = 0.0;\n  vec2 d2 = df(p, aa, h, sc);\n\n  vec3 col = vec3(0.0);\n\n  vec3 rgb = ((2.0/3.0)*(cos(TAU*h+vec3(0.0, 1.0, 2.0))+vec3(1.0))-d2.y/(3.0*sc));\n  col = mix(col, rgb, smoothstep(aa, -aa, d2.x));\n  \n  const vec3 gcol1 = vec3(.5, 2.0, 3.0);\n  col += gcol1*tanh_approx(0.025*aa);\n\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p+1.0/RESOLUTION.y;\n  vec3 col = effect(p, np, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 484, 511, 511, 587], [589, 675, 711, 711, 805], [807, 873, 894, 894, 962], [964, 1024, 1052, 1118, 1194], [1196, 1196, 1216, 1216, 1238], [1240, 1240, 1294, 1294, 1653], [1655, 1655, 1678, 1758, 1897], [1899, 1899, 1924, 2003, 2142], [2144, 2144, 2168, 2168, 2531], [2533, 2533, 2572, 2572, 3031], [3033, 3033, 3090, 3090, 3298]], "test": "untested"}
{"id": "dtS3Dw", "name": "wiggly worm", "author": "sh1boot", "description": "An iterated FIR filter generates mouse trails which drlift around.\n\nUse (shift)-click-and-drag.\n\nParticles binned into bounding boxes to avoid excess computation at each pixel (0 view, tab disables).\n\nBased on: https://scratch.mit.edu/projects/783499452/", "tags": ["particles", "feedback", "mousetrails"], "likes": 9, "viewed": 311, "published": 3, "date": "1673379478", "time_retrieved": "2024-07-30T18:16:41.539770", "image_code": "\n\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 palette(int i) {\n    float t = float(i) * 0.01;\n    vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0), d = vec3(0.0,0.33,0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 get_point(int i) {\n    return array0(clamp(i, 0, num_points - 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 mask = texture(iChannel1, fragCoord / (iResolution.xy * bitmap_scale));\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word && (mask.x > 0.0 || DRAW_ALL); ++wo) {\n            int i = w * bins_per_word + wo;\n            int start = i * num_points / num_bins;\n            int end = (i + 1) * num_points / num_bins;\n            if (fract(mask.x) >= 0.5 || DRAW_ALL) {\n                vec2 p0 = get_point(start - 2).xy;\n                vec2 p1 = get_point(start - 1).xy;\n                vec2 p2 = get_point(start - 0).xy;\n                for (int j = start; j < end; ++j) {\n                    vec2 p3 = get_point(j + 1).xy;\n                    float trail = 2.0 / \n                        (NO_CUBIC ? line(fragCoord, p1, p2) : spline(fragCoord, p0, p1, p2, p3));\n                    float fade = 1.0 - smoothstep(0.75 * float(num_points), float(num_points), float(j));\n                    trail = max(0., trail - 0.1);\n\n                    fragColor = max(fragColor, vec4(trail * fade * palette(j), 1.0));\n\n                    p0 = p1;\n                    p1 = p2;\n                    p2 = p3;\n                }\n                if (SHOW_BOXES) fragColor.xyz = max(fragColor.xyz + 0.01, vec3(0.2));\n            }\n            mask.x = fract(mask.x * 2.0);\n        }\n        mask = mask.yzwx;\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Set the first particle to the mouse position, then apply a FIR filter with time offset across the list of particles to produce wobbly trails.\n\n\nconst int window_length = 8;\nconst float window_offset = 4.2;\n\nfloat window_lut(int i) {\n    const float window[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    if (i < 0 || window.length() <= i) return 0.0;\n    return window[i];\n}\n\nfloat window(int i) {\n    const float window[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    float wf = fract(window_offset);\n    return interpolate(window_lut(i - 1),\n                       window_lut(i - 0),\n                       window_lut(i + 1),\n                       window_lut(i + 2), wf);\n}\n\n\nvec4 random_walk(vec4 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p *= (1.0 / iResolution.xy).xyxy;\n    p += (nrand2(vec2(iTime, 0)) * mat2(c,s,-s,c)).xyxy * 0.008;\n    c = cos(iTime * 3.5), s = sin(iTime * 3.1);\n    p += (nrand2(vec2(iTime, 1)) * mat2(c,s,-s,c)).xyxy * 0.007;\n    p += (0.5 - p) * 0.02;\n    p *= iResolution.xyxy;\n    return p;\n}\n\nvec4 get_mouse_or_whatever() {\n    vec4 previous = iFrame < 1 ? iResolution.xyxy * 0.5 : array0(0);\n\n    if (RESPONSIVE_MOUSE) return iMouse;\n\n    if (all(lessThan(iMouse.xy, vec2(3)))) {\n        return random_walk(previous);\n    }\n\n    previous.xy += (iMouse.xy - previous.xy) * 0.1;\n    return previous;\n}\n\n\nvec4 get_point(int i) {\n    return array0(clamp(i, 0, num_points - 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 g = 0.5 * (vec2(cos(iTime * 1.1), sin(iTime * 1.1)) + 0.5) * iResolution.xy;\n    int i = index(fragCoord);\n    if (i >= num_points) discard;\n\n    if (iFrame < 1 || i < 1) {\n        fragColor = get_mouse_or_whatever();\n        return;\n    }\n\n    fragColor = vec4(0.0);\n    float window_sum = 0.0;\n    for (int j = 0; j < window_length; ++j) {\n        float w = window(j);\n        window_sum += w;\n        fragColor += w * get_point(i + j - int(window_offset));\n    }\n    fragColor *= 1.0 / window_sum;\n    fragColor += 0.001 * (g.xyxy - fragColor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int num_points = 256;\nconst int num_bins = 64;\n\nconst int neighbours = 1;  // lines must connect with neighbouring bin points.\nconst float radius = 16.0;  // a bit of slop for line width, glow, and interpolation overshoot\n\nconst float bitmap_scale = 8.0;\n\n#define RESPONSIVE_MOUSE (texelFetch(iChannel3, ivec2(16,0),0).x >= 0.5)  // shift -- go directly to mouse, without smoothing filter\n#define DRAW_ALL (texelFetch(iChannel3, ivec2(9,2),0).x >= 0.5)      // tab toggles bounding box optimisation\n#define SHOW_BOXES (texelFetch(iChannel3, ivec2(48,2),0).x >= 0.5)   // '0' toggles bounding box highlight\n#define NO_CUBIC (texelFetch(iChannel3, ivec2(49,2),0).x >= 0.5)     // '1' toggles cubic/linear interpolation\n\n#define index(fc) int(floor(fragCoord.x) + floor(fragCoord.y) * iResolution.x)\n#define array0(i) array(i, iChannel0, int(iResolution.x))\n#define array1(i) array(i, iChannel1, int(iResolution.x))\n\nvec4 array(int i, sampler2D tex, int tw) {\n    return texelFetch(tex, ivec2(i % tw, i / tw), 0);\n}\n\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n * vec2(-3.2145, 1.2345)),\n                                    nrand(n * vec2(-5.4321, 3.4521))); }\n\n\nfloat cubic(float t) {\n    const float a = -0.5;\n    t = abs(t);\n    float t3 = t * t * t;\n    float t2 = t * t;\n    if (t <= 1.) return (a + 2.) * t3 - (a + 3.) * t2 + 1.;\n    if (t < 2.) return a * t3 - 5. * a * t2 + 8. * a * t - 4. * a;\n    return 0.;\n}\n\nvec2 interpolate(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\nfloat interpolate(float p0, float p1, float p2, float p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\n// Line SDF from Inigo Quilez\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba);\n}\n\nfloat spline(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 i125 = interpolate(p0, p1, p2, p3, 0.25);\n    vec2 i150 = interpolate(p0, p1, p2, p3, 0.5);\n    vec2 i175 = interpolate(p0, p1, p2, p3, 0.75);\n    float l0 = line(p, p1,   i125);\n    float l1 = line(p, i125, i150);\n    float l2 = line(p, i150, i175);\n    float l3 = line(p, i175, p2);\n    return min(min(l0, l1), min(l2, l3));\n}\n\n", "buffer_b_code": "// Separate particles into a set of bins and generate bounding boxes for each bin.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = index(fragCoord);\n    if (i >= num_bins) discard;\n\n    fragColor = vec4(1,1,-1,-1) * 1000000.0;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    for (int j = start; j < end; j++) {\n        // TODO: Do the cubic interpolation here to make sure we consider overshoot.\n        fragColor.xy = min(fragColor.xy, array0(j).xy);\n        fragColor.zw = max(fragColor.zw, array0(j).xy);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// For each pixel, produces a bitmap of bins which are relevant.\n\nconst vec4 test_window = vec4(-1,-1,1,1) * radius + vec4(0,0,1,1) * bitmap_scale;\n\n\nbool near_any_points(vec2 c, int i) {\n    c += bitmap_scale * 0.5;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    vec2 p0 = array1(start).xy;\n    for (int j = start + 1; j < end; ++j) {\n        vec2 p1 = array1(j).xy;\n        if (line(c, p0, p1) < (radius + bitmap_scale)) return true;\n        p0 = p1;\n    }\n    return false;\n}\n\nbool small_box(vec4 box) {\n    return distance(box.xy, box.zw) < radius * radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= bitmap_scale;\n    if (!all(lessThan(fragCoord, iResolution.xy))) discard;\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word; ++wo) {\n            int i = w * bins_per_word + wo;\n            vec4 box = array0(i) + test_window;\n            fragColor.x *= 2.0;\n            if (all(bvec4(lessThan(box.xy, fragCoord), lessThan(fragCoord, box.zw)))) {\n                if (small_box(box) || near_any_points(fragCoord, i)) {\n                    fragColor.x += 1.0;\n                }\n            }\n        }\n        fragColor = fragColor.yzwx;\n    }\n    fragColor *= pow(2.0, -float(num_bins / 4));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 48, 69, 69, 252], [254, 254, 277, 277, 327], [329, 329, 384, 384, 1786]], "test": "untested"}
{"id": "Dl2GR1", "name": "Colored Stars", "author": "deni_de", "description": "my first particles & arrays in shaders", "tags": ["particles", "array"], "likes": 5, "viewed": 267, "published": 3, "date": "1673374722", "time_retrieved": "2024-07-30T18:16:42.409445", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2[] arvec = vec2[9](vec2(.2,.1),vec2(.4,.5),vec2(1.,.3),vec2(1.4,.3),vec2(1.2,.2),vec2(.8,.6),vec2(.2,0.7),vec2(.4,.3),vec2(1.5,.5));\n    vec3[] arcol = vec3[9](c1,c2,c3,c4,c5,c6,c7,c8,c9);\n    \n    int l = arvec.length(); vec2 r = iResolution.xy; O *= 0.; vec2 u;\n    \n    for(float i = 1.,z = 1.0 - Random(u + i + iTime*0.001) * 0.35; i < float(l)+1.;\n          //uv |     particle pos    |                          offset animation                             |\n    u = (U/r.y - arvec[int(i-1.)].xy + vec2(-sin(iTime * 1.0 + i )  * .2, sin(iTime + i) * .2) * Rotate(iTime))\n        //    scale | half scaled  animation                      |           rotate          | return pos\n    * vec2(6.5 * z) * (1. - vec2(abs(sin(iTime  * 5. + i))) * .5) * Rotate(iTime * 2. +i-1.)  + vec2(.5),\n      //         texture        |       color               | col power|       alpha                               |\n    O += texture(iChannel0, u ) * vec4(arcol[int(i-1.)],1.) * 2.       * abs(1. - fract(iTime + i * i * .777) - .5)+i++*0.){}\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 n = U/r;\n    vec4 tex = textureLod(iChannel0, n, 3.);\n    vec3 crs = pow( vec3(1. - abs((n.y - .5) * (n.x - .5) )), vec3(255.6)) \n    * (1. - smoothstep(.1,.6,length(n-vec2(.5,.5))) /*add here*/ ) * tex.rgb;\n    crs = pow(crs, vec3(.5) / crs);\n    O.rgb = crs + crs + (1.-smoothstep(.01,.5,pow(length(n - vec2(.5)), .6)));\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define c1 vec3(1.,1.,1.)\n#define c2 vec3(.2,.5,.5)\n#define c3 vec3(.5,.3,.3)\n#define c4 vec3(.7,.3,.8)\n#define c5 vec3(.6,.2,.2)\n#define c6 vec3(.4,.6,.6)\n#define c7 vec3(.1,.7,.4)\n#define c8 vec3(.2,.3,.9)\n#define c9 vec3(.9,.2,.1)\n\nmat2 Rotate(float angle)\n{\n    float s = sin(angle); float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat Random (vec2 uv) \n{\n    return fract(sin(dot(uv.xy,vec2(1231.845679823,14351.130895732)))*43758.0456098);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ctB3Wm", "name": "L-inf raymarching", "author": "me_123", "description": "Ray marching in L-inf space is faster.", "tags": ["3d", "raymarching", "linf"], "likes": 35, "viewed": 524, "published": 3, "date": "1673372550", "time_retrieved": "2024-07-30T18:16:43.304053", "image_code": "const int it = 18; //transform iterations\nconst float eps = 0.001; //amout of detail\n#define LINF 1\n#define PI 3.141592653\nfloat linf(in vec3 rd) { //project direction onto cube\n\tvec3 k = -vec3(1.0)/abs(rd);\n\treturn -max(max(k.x, k.y), k.z);\n}\nvec3 transform(in vec3 p) {\n    //the fractal\n    float d = 100000.;\n    int i;\n    for (i = 0; i < it; i += 1) {\n        p = abs(p);\n        p *= 2.0;\n        p -= vec3(1);\n        p.xy = vec2(abs(1.-max(p.x, -p.y)), (min(p.x, -p.y)))+vec2(0.75, 0.45);\n        p.y = abs(p.y);\n        p.yz = vec2(min(p.y, -p.z), max(p.y, -p.z))-vec2(1.0, 0.5);\n        p.xz = vec2(min(p.x, p.z), max(p.x, p.z))-0.9;\n    }\n    return p;\n}\nvec3 color(in vec3 p) {\n    //the fractal\n    float d = 100000.;\n    int i;\n    vec3 v = vec3(0);\n    float ao = 0.0;\n    float v1 = 0.0;\n    for (i = 0; i < 12; i += 1) {\n        p = abs(p);\n        p *= 2.0;\n        p -= vec3(1);\n        p.xy = vec2(abs(1.-max(p.x, -p.y)), (min(p.x, -p.y)))+vec2(0.75, 0.45);\n        p.y = abs(p.y);\n        p.yz = vec2(min(p.y, -p.z), max(p.y, -p.z))-vec2(1.0, 0.5);\n        p.xz = vec2(min(p.x, p.z), max(p.x, p.z))-0.9;\n        ao += length(p);\n        v1 += dot(p, p);\n    }\n    v = p;\n    vec3 color = vec3(1);\n    if (1.8+v.y > 0.0) color = vec3(0.5, 1.0, 0.5);\n    if (0.6+v.x > 0.0) color = vec3(0, 1, 0.5);\n    if (-0.8+v.z > 0.0) color = vec3(0.1, 0.1, 1);\n    //if (ao > 8.0) color = vec3(0);\n    return vec3(color*(v1-20.0)*0.05);//vec3(color*(1.-3.0/(ao-12.0))*1.0);//vec3(color*(1.-12./ao)*3.0);//color*vec3(1.0-0.13*(ao-4.0))*2.0;\n}\nfloat sdf(in vec3 p) {\n    p = abs(transform(p))-1.0;\n    #if LINF\n\treturn ((max(max(p.x, p.y), p.z)))*pow(2., -float(it)); //linf distance to box\n    #else\n    return min(max(p.x,max(p.y,p.z)),0.0) + length(max(p,0.0))*pow(2., -float(it)); //euclidean dis\n    #endif\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float d0 = 0.0;\n    int i;\n    float m = linf(rd);\n    for (i = 0; i < 1000; i += 1) {\n        #if LINF\n        float d = sdf(ro+rd*d0)*m;\n        #else\n        float d = sdf(ro+rd*d0);\n        #endif\n        d0 += d;\n        if (d < d0*eps || d0 > 100.) break;\n    }\n    if (d0 > 100.) return vec3(0); //no hit\n    return mix(color(ro+rd*d0)/(float(i+1)*0.1), vec3(0), 1.-exp(-d0*5.0));//mix(5.0/(vec3(i)+2.0), vec3(1, 0.5, 0), 1.-exp(-d0)); //hit\n}\n#define AA 0\n#if AA\nconst float a = 1./pow(float(AA)*2.+1., 2.);\nconst float a1 = 1./(float(AA)*2.+1.);\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    #if AA\n    for (int x = -AA; x <= AA; x += 1) {\n        for (int y = -AA; y <= AA; y += 1) {\n            vec2 uv = ((vec2(x,y)*a1+fragCoord.xy)/iResolution.xy)-0.5;\n    #else\n    vec2 uv = ((fragCoord.xy)/iResolution.xy)-0.5;\n    #endif\n            uv.x *= iResolution.x/iResolution.y;\n            uv.y = -uv.y;\n            vec2 m = iMouse.z>0.0?((iMouse.xy)/iResolution.xy)*vec2(PI*2., PI):vec2(iTime*0.125, 2.0+sin(iTime*0.25)*0.5);\n            vec3 ro = vec3(sin(m.y)*cos(-m.x),sin(m.y)*sin(-m.x),cos(m.y))*0.05;\n            vec3 rd = -normalize(ro);\n            vec3 u = vec3(normalize(vec2(rd.y, -rd.x)), 0);\n            vec3 v = cross(u, rd);\n            rd = normalize(1.0*rd+u*uv.x+v*uv.y);\n            ro -= vec3(-0.6625000371078297,1.6874999810014544,0.4951437083081428);\n            fragColor += vec4(getColor(ro, rd), 1);\n   #if AA\n        }\n    }\n    fragColor *= a;\n    #endif\n    fragColor = 1.-exp(-fragColor*3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctB3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 147, 177, 243], [244, 244, 271, 289, 666], [667, 667, 690, 708, 1550], [1551, 1551, 1573, 1573, 1820]], "test": "untested"}
{"id": "clBGWw", "name": "Square Pulse", "author": "drliquidglitch", "description": "Forked from A20DC541\n\nadded fuzz", "tags": ["a"], "likes": 7, "viewed": 348, "published": 3, "date": "1673358210", "time_retrieved": "2024-07-30T18:16:44.069007", "image_code": "void mainImage(out vec4 O, vec2 u) {\n\n    vec2 wavy = vec2(0.5, 1.0);\n        \n\tu.x += wavy.x*sin(u.y*wavy.y)*6.0;\n\tu.y += wavy.y*cos(u.x*wavy.x)*8.0;\n    \n    u = abs(u+u-(O.xy=iResolution.xy))/O.y;\n    O -= O;\n    for (float i = 0., t = .5*iTime; i < 50.; O += .001\n    /abs(abs(u.x + .75*sin(t+i*.20)) + u.y - 1.0*tan(t+i*0.5))\n    *(3.0+sin(i+++vec4(0,1,2,3))));       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 375]], "test": "untested"}
{"id": "mljGDD", "name": "Flying butter noodles", "author": "brainsandwich", "description": "They wonk around helplessly, but smeared", "tags": ["2d", "distancefield", "sdf", "squares"], "likes": 3, "viewed": 307, "published": 3, "date": "1673351095", "time_retrieved": "2024-07-30T18:16:44.830970", "image_code": "// https://stackoverflow.com/a/4275343/4296866\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdf_rect(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    return min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 1.);\n}\n\nfloat sdf_rect_rounded(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.);\n    return outsideDistance + insideDistance;\n}\n\nstruct rect {\n    vec3 color;\n    vec2 center;\n    vec2 halfsize;\n};\n\nvec3 mixfn(in vec3 pixel, in vec3 color, in float mixer)\n{\n    vec3 cp = color; //color-pixel;\n    return mix(pixel, cp, mixer);\n}\n\nfloat antialias(in float dist)\n{\n    return smoothstep(-1., 1., (dist-.04)/fwidth(dist));\n}\n\nvoid draw_rect(inout vec3 pixel, in vec2 position, rect r)\n{\n    float dist = sdf_rect_rounded(position, r.center, r.halfsize);\n    float clampd = 1.-antialias(dist); // 1.-step(0.01, dist);\n    pixel = mixfn(pixel, r.color, clampd);\n}\n\nfloat wobble(in float d)\n{\n    float c1 = sin(0.2*iTime+d*10.0);\n    float c2 = sin(-0.1*iTime+d*24.0);\n    float c3 = sin(-0.5*iTime+d*2.0*sin(c1));\n    return 0.5*(3.0*c1 + 1.0*c2 + 5.0*c3 + d);\n}\n\n// Very sensitive, cool at limit of float precision\n#define TIMEFACTOR 0.000000001\n#define BACKGROUND vec3(0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Smear pixel pos\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n\n    // Background color\n    vec3 col = BACKGROUND;\n    for (int i = 0; i < 32; i++)\n    {\n        float fi = float(i)*sin(TIMEFACTOR*iTime+0.001);\n        \n        rect r;\n        r.color = vec3(rand(10.*vec2(fi)), rand(vec2(4.501*fi)), rand(vec2(-fi*.99)));\n        r.center = 5.*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(0.1*fi)))-2.;\n        r.halfsize = 0.6*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(2.*fi)));\n        \n        draw_rect(col, uv, r);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 67, 67, 137], [139, 139, 203, 203, 356], [358, 358, 430, 430, 716], [788, 788, 846, 846, 918], [920, 920, 952, 952, 1011], [1013, 1013, 1073, 1073, 1248], [1250, 1250, 1276, 1276, 1448], [1562, 1562, 1619, 1669, 2465]], "test": "untested"}
{"id": "dljGDD", "name": "Flying butter boxes", "author": "brainsandwich", "description": "They wonk around helplessly", "tags": ["2d", "distancefield", "sdf", "squares"], "likes": 1, "viewed": 255, "published": 3, "date": "1673350788", "time_retrieved": "2024-07-30T18:16:45.601909", "image_code": "// https://stackoverflow.com/a/4275343/4296866\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdf_rect(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    return min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 1.);\n}\n\nfloat sdf_rect_rounded(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.);\n    return outsideDistance + insideDistance;\n}\n\nstruct rect {\n    vec3 color;\n    vec2 center;\n    vec2 halfsize;\n};\n\nvec3 mixfn(in vec3 pixel, in vec3 color, in float mixer)\n{\n    vec3 cp = color; //color-pixel;\n    return mix(pixel, cp, mixer);\n}\n\nfloat antialias(in float dist)\n{\n    return smoothstep(-1., 1., (dist-.04)/fwidth(dist));\n}\n\nvoid draw_rect(inout vec3 pixel, in vec2 position, rect r)\n{\n    float dist = sdf_rect_rounded(position, r.center, r.halfsize);\n    float clampd = 1.-antialias(dist); // 1.-step(0.01, dist);\n    pixel = mixfn(pixel, r.color, clampd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(1.);\n    \n    for (int i = 0; i < 32; i++)\n    {\n        float fi = float(i)*sin(0.00000001*iTime+0.001);\n        rect r;\n        r.color = vec3(rand(10.*vec2(fi)), rand(vec2(4.501*fi)), rand(vec2(-fi*.99)));\n        r.center = 1.*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(0.1*fi)));\n        r.halfsize = 0.2*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(2.*fi)));\n        \n        draw_rect(col, uv, r);\n    }\n    \n    // const int RECTS=3;\n    // rect rects[RECTS];\n    // \n    // rects[0].color = vec3(1.0);\n    // rects[0].center = vec2(0.3);\n    // rects[0].halfsize = vec2(0.2);\n    // \n    // rects[1].color = vec3(1.0, 0.4, 0.1);\n    // rects[1].center = vec2(0.5, 0.15);\n    // rects[1].halfsize = vec2(0.08);\n    // \n    // rects[2].color = vec3(0.4, 0.4, 0.41);\n    // rects[2].center = vec2(0.7, 0.4);\n    // rects[2].halfsize = vec2(0.01);\n    // \n    // for (int i = 0; i < RECTS; i++)\n    // {\n    //     draw_rect(col, uv, rects[i]);\n    // }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 67, 67, 137], [139, 139, 203, 203, 356], [358, 358, 430, 430, 716], [788, 788, 846, 846, 918], [920, 920, 952, 952, 1011], [1013, 1013, 1073, 1073, 1248], [1250, 1250, 1307, 1357, 2520]], "test": "untested"}
{"id": "dl23WD", "name": "Fork Hellscape by Reymenta", "author": "Reymenta", "description": "it was supposed to be a calm snow walk, it ended up being a fly-through over the end of the world", "tags": ["noise", "cloud", "mountain"], "likes": 0, "viewed": 223, "published": 3, "date": "1673350330", "time_retrieved": "2024-07-30T18:16:46.508485", "image_code": "\n\n// Hellscape Airline by Leon Denise\n// an abundance of noise patterns\n// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins\n// and many more\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// globals\nfloat material;\n\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid (vec3 s) { return dot(sin(s),cos(s.yzx)); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}", "buffer_a_code": "\n\n// Hellscape Airline by Leon Denise\n// an abundance of noise patterns\n// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins\n// and many more\n\n\n// gyroid flavoured FBMs\nfloat fbmCloud (vec3 p) {\n    p.z *= .3;\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 8.; ++i, a /= 2.) {\n        p.z -= iTime * .1;\n        result += abs(gyroid(p/a))*a; }\n    return result;\n}\n\nfloat fbmGround (vec3 p) {\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 8.; ++i, a /= 2.) {\n        p.z += result * .5 + iTime * .001;\n        result += gyroid(p/a)*a; }\n    return result;\n}\n\nfloat fbmHorizon (vec3 p) {\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 3.; ++i, a /= 2.) {\n        p.z += result * .5 - iTime*.2;\n        result += abs(gyroid(p/a))*a; }\n    return result;\n}\n\nfloat map(vec3 p)\n{\n    float d = 100.;\n    vec3 seed = p * .5;\n    \n    // traveling\n    seed.z -= iTime * .1;\n    \n    // shapes\n    float ground = p.y+1.-fbmGround(seed);\n    float cloud = -p.y+2.5-fbmCloud(seed*.5);\n    \n    material = ground < cloud ? 0. : 1.;\n    return min(ground, cloud);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat getAO(vec3 p, vec3 n, float scale, float intensity)\n{\n    float ao = 0.;\n    for (float i = 1.; i <= 4.; ++i)\n        ao += (i*scale-map(p + n * i * scale));\n    return clamp(1.-ao*intensity, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // pixels positions\n    vec2 p = (fragCoord.xy-iResolution.xy/2.) / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // noises\n    vec3 seed = vec3(fragCoord.xy, iFrame);\n    float rng = hash13(seed);\n    vec3 blur = hash33(seed)*2.-1.;\n    \n    // coordinates\n    vec3 pos = vec3(-1,0,4);\n    float fov = .2 * sin(iTime*.2);\n    vec3 ray = normalize(vec3(p, -0.8+fov));\n    \n    // camera look\n    vec2 angle = vec2(\n        sin(-iTime*.05)*.4,\n        sin(-iTime*.1)*.15-.08);\n        \n    // mouse look\n    if (iMouse.z > 0.)\n        angle = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        \n    ray.yz *= rot(angle.y);\n    ray.xz *= rot(angle.x);\n    \n    // start ahead\n    pos += ray * rng;\n    \n    // blur edge\n    pos += blur * ss(0.5,1.,length(p)) * .02;\n    \n    // raymarch\n    float shade = 0.;\n    float total = 0.;\n    float maxDist = 30.;\n    const float count = 60.;\n    for (float index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001 || total > maxDist)\n        {\n            shade = index/count;\n            break;\n        }\n        dist *= 0.9 + 0.1 * rng;\n        total += dist;\n        ray += blur*.0005;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    if (shade > 0.1 && total < maxDist)\n    {\n        float mat = material;\n        \n        // NuSan\n        // https://www.shadertoy.com/view/3sBGzV\n        vec2 e = vec2(0.01,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-e.xyy),map(pos-e.yxy),map(pos-e.yyx)));\n        vec3 rf = reflect(ray, normal);\n        \n        // ground\n        if (mat == 0.)\n        {\n           \n        }\n        // cloud\n        else\n        {\n            color = .5+.5*cos(vec3(1,2,3)*5.8+pos.y*2.-0.0-rf.y*1.);\n        }\n    }\n    // horizon\n    else if (total > maxDist)\n    {\n        float noise = fbmHorizon(vec3(pos)*0.4);\n        color = .5+.5*cos(vec3(1,2,3)*5.5-noise*2.+abs(ray.y)*12.);\n        color *= ss(.1,-.1,abs(ray.y));\n    }\n\n    // smooth frame\n    color = mix(color, texture(iChannel0, uv).rgb, .9);\n    \n    fragColor = vec4(color, 1);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl23WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 300]], "test": "untested"}
{"id": "dljGWW", "name": "vonoroi polygon", "author": "jonasfrey", "description": "it is possible to create a polygon by using the closes distance to a set of points which are located at the corners of a polygon, ", "tags": ["vonoroi"], "likes": 2, "viewed": 154, "published": 3, "date": "1673345526", "time_retrieved": "2024-07-30T18:16:47.374170", "image_code": "vec2 f_o_p(\n     float n_radians, \n     float n_radius\n){\n    vec2 o_p = vec2(\n        sin(n_radians)*n_radius,\n        cos(n_radians)*n_radius\n    );\n    return o_p;\n}\nvec4 f_o_less_efficient_way(\n    vec2 o_trn_fc_nor_offset,\n    float n_its,\n    float n_radius\n){\n\n    // the less efficient way is to iterate over all corners of the polygon\n    // the advantage is that the distance of the fragCoord to all the points\n    // can by added up to a sum or be multiplied with each other\n    float n_tau = 6.283158;\n\n    float n_dmin = 1.;\n    float n_it_dmin = 0.;\n    float n_ang_nor = atan(o_trn_fc_nor_offset.x, o_trn_fc_nor_offset.y)/n_tau+0.5;\n    \n    float n_dsum = 0.;\n    float n_dprod = 1.;\n    \n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n\n        float n_it_nor = n_it / n_its;\n        //point in the middle \n        if(n_it == 0.){\n            n_radius = 0.;\n        }\n        vec2 o_p = f_o_p(n_it_nor*n_tau, n_radius);\n        float n_d = length(o_trn_fc_nor_offset - o_p);\n        if(n_d < n_dmin){\n            n_dmin = n_d; \n            n_it_dmin = n_it;\n            if(n_it == 0.){\n                n_it_dmin = -1.;\n            }\n        }\n        n_dsum+=n_d;\n        n_dprod*=n_d;\n    }\n    return vec4(\n        n_dmin, \n        n_it_dmin/n_its,\n        n_dsum, \n        n_dprod\n    );\n    \n}\nvec4 f_o_more_efficient(\n    vec2 o_trn_fc_nor_offset,\n    float n_its,\n    float n_radius\n){\n    float n_tau = 6.283158;\n\n    float n_dmin = 1.;\n    float n_it_dmin = 0.;\n    float n_ang_nor = (atan(o_trn_fc_nor_offset.x, o_trn_fc_nor_offset.y)/n_tau)+0.5;\n    \n    float n_one_it_nor = (1./ n_its);\n    float n_it = floor(n_ang_nor/n_one_it_nor);\n    float n_it_nor = n_it/n_its;\n    \n    float n_max = 3.;\n        \n    float n_dsum = 0.;\n    float n_dprod = 1.;\n    \n    for(float n = 0.;n < n_max;n+=1.){\n\n        float n_pm = (n - 1.);\n        float n_radians = ((n_it_nor)+(n_pm*n_one_it_nor))*n_tau+n_tau/2.;\n\n        vec2 o_p = f_o_p(n_radians, n_radius);\n        float n_d = length(o_trn_fc_nor_offset - o_p);\n        if(n_d < n_dmin){\n            n_dmin = n_d; \n            n_it_dmin = mod(n_it+n_pm, n_its);\n        }\n        n_dsum+=n_d;\n        n_dprod*=n_d;\n    }\n    float n_d = length(o_trn_fc_nor_offset - vec2(0.));\n    if(n_d < n_dmin){\n        n_dmin = n_d; \n        n_it_dmin = -1.;\n    }\n    n_dsum+=n_d;\n    n_dprod*=n_d;\n    \n    return vec4(\n        n_dmin, \n        n_it_dmin/n_its,\n        n_dsum, \n        n_dprod\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    float n_its = floor((sin(iTime)*0.5+0.5)*9.+3.);\n    vec4 o_dvonoroipoly;\n    float n_radius = 0.5;\n    o_dvonoroipoly = f_o_less_efficient_way(o_trn_fc_nor_offset, n_its, n_radius);\n    o_dvonoroipoly = f_o_more_efficient(o_trn_fc_nor_offset, n_its, n_radius);\n    \n    fragColor = vec4(o_dvonoroipoly.y);\n    float b_polygon = float(o_dvonoroipoly.y < 0.);\n    fragColor = vec4(b_polygon);\n    \n    if(o_trn_fc_nor.y > 1./3.*1.){\n        fragColor = vec4(o_dvonoroipoly.x);\n        \n        //if(o_trn_fc_nor.x > (o_trn_mo_nor.x/2.)*1.){\n        //     fragColor = vec4(o_dvonoroipoly.x);\n        // }\n        // float n_tau = 6.2831;\n        // if(o_trn_fc_nor.x > (o_trn_mo_nor.x/2.)*2.){\n        //     float n = pow(o_dvonoroipoly.w, 1./10.);\n        //     float nss = n_tau/n_its*0.2;\n        //     n = smoothstep(nss,nss*3., n);\n        //     fragColor = vec4(n);\n        // }\n        // fragColor = sqrt(fragColor);\n    }\n    \n    if(o_trn_fc_nor.y > 1./3.*2.){\n        fragColor = vec4(o_dvonoroipoly.y);\n    }\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168], [169, 169, 266, 485, 1316], [1317, 1317, 1410, 1410, 2467], [2468, 2468, 2525, 2525, 3985]], "test": "untested"}
{"id": "dtB3DD", "name": "Hellscape Airline", "author": "leon", "description": "it was supposed to be a calm snow walk, it ended up being a fly-through over the end of the world", "tags": ["noise", "cloud", "mountain"], "likes": 44, "viewed": 662, "published": 3, "date": "1673343087", "time_retrieved": "2024-07-30T18:16:48.363525", "image_code": "\n\n// Hellscape Airline by Leon Denise\n// an abundance of noise patterns\n// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins\n// and many more\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// globals\nfloat material;\n\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid (vec3 s) { return dot(sin(s),cos(s.yzx)); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}", "buffer_a_code": "\n\n// Hellscape Airline by Leon Denise\n// an abundance of noise patterns\n// using code from Inigo Quilez, Antoine Zanuttini, Dave Hoskins\n// and many more\n\n\n// gyroid flavoured FBMs\nfloat fbmCloud (vec3 p) {\n    p.z *= .3;\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 8.; ++i, a /= 2.) {\n        p.z -= iTime * .1;\n        result += abs(gyroid(p/a))*a; }\n    return result;\n}\n\nfloat fbmGround (vec3 p) {\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 8.; ++i, a /= 2.) {\n        p.z += result * .5 + iTime * .001;\n        result += gyroid(p/a)*a; }\n    return result;\n}\n\nfloat fbmHorizon (vec3 p) {\n    float result = 0., a = 0.5;\n    for (float i = 0.; i < 3.; ++i, a /= 2.) {\n        p.z += result * .5 - iTime*.2;\n        result += abs(gyroid(p/a))*a; }\n    return result;\n}\n\nfloat map(vec3 p)\n{\n    float d = 100.;\n    vec3 seed = p * .5;\n    \n    // traveling\n    seed.z -= iTime * .1;\n    \n    // shapes\n    float ground = p.y+1.-fbmGround(seed);\n    float cloud = -p.y+2.5-fbmCloud(seed*.5);\n    \n    material = ground < cloud ? 0. : 1.;\n    return min(ground, cloud);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat getAO(vec3 p, vec3 n, float scale, float intensity)\n{\n    float ao = 0.;\n    for (float i = 1.; i <= 4.; ++i)\n        ao += (i*scale-map(p + n * i * scale));\n    return clamp(1.-ao*intensity, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // pixels positions\n    vec2 p = (fragCoord.xy-iResolution.xy/2.) / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // noises\n    vec3 seed = vec3(fragCoord.xy, iFrame);\n    float rng = hash13(seed);\n    vec3 blur = hash33(seed)*2.-1.;\n    \n    // coordinates\n    vec3 pos = vec3(-1,0,4);\n    float fov = .2 * sin(iTime*.2);\n    vec3 ray = normalize(vec3(p, -0.8+fov));\n    \n    // camera look\n    vec2 angle = vec2(\n        sin(-iTime*.05)*.4,\n        sin(-iTime*.1)*.15-.08);\n        \n    // mouse look\n    if (iMouse.z > 0.)\n        angle = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        \n    ray.yz *= rot(angle.y);\n    ray.xz *= rot(angle.x);\n    \n    // start ahead\n    pos += ray * rng;\n    \n    // blur edge\n    pos += blur * ss(0.5,1.,length(p)) * .02;\n    \n    // raymarch\n    float shade = 0.;\n    float total = 0.;\n    float maxDist = 30.;\n    const float count = 60.;\n    for (float index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001 || total > maxDist)\n        {\n            shade = index/count;\n            break;\n        }\n        dist *= 0.9 + 0.1 * rng;\n        total += dist;\n        ray += blur*.0005;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    if (shade > 0.1 && total < maxDist)\n    {\n        float mat = material;\n        \n        // NuSan\n        // https://www.shadertoy.com/view/3sBGzV\n        vec2 e = vec2(0.01,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-e.xyy),map(pos-e.yxy),map(pos-e.yyx)));\n        vec3 rf = reflect(ray, normal);\n        \n        // ground\n        if (mat == 0.)\n        {\n            // Inigo Quilez\n            // https://iquilezles.org/articles/palettes\n            color = .5+.5*cos(vec3(1,2,3)*5.8-pos.y*2.-4.+rf.z);\n            color.gb *= getAO(pos, normal, .05, 2.);\n            color *= shade;\n        }\n        // cloud\n        else\n        {\n            color = .5+.5*cos(vec3(1,2,3)*5.8+pos.y*2.-0.0-rf.y*1.);\n        }\n    }\n    // horizon\n    else if (total > maxDist)\n    {\n        float noise = fbmHorizon(vec3(pos)*0.4);\n        color = .5+.5*cos(vec3(1,2,3)*5.5-noise*2.+abs(ray.y)*12.);\n        color *= ss(.1,-.1,abs(ray.y));\n    }\n\n    // smooth frame\n    color = mix(color, texture(iChannel0, uv).rgb, .9);\n    \n    fragColor = vec4(color, 1);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtB3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 300]], "test": "untested"}
{"id": "ct23WD", "name": "Zooming Plaid", "author": "lmno", "description": "A bit abrasive.", "tags": ["infinite", "plaid"], "likes": 0, "viewed": 138, "published": 3, "date": "1673332011", "time_retrieved": "2024-07-30T18:16:49.129477", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5+cos(iTime*+uv.xyx*+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct23WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 296]], "test": "untested"}
{"id": "Dtj3WD", "name": "CRT Rainbow", "author": "lmno", "description": "My first shader in years. Just the new shader with some z's instead of x's or y's.", "tags": ["crt", "rainbow"], "likes": 2, "viewed": 175, "published": 3, "date": "1673331662", "time_retrieved": "2024-07-30T18:16:50.631462", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yz;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xxy+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtj3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "dlSGDD", "name": "circular wave 2 ", "author": "jonasfrey", "description": "segment", "tags": ["circle", "segment"], "likes": 5, "viewed": 182, "published": 3, "date": "1673305481", "time_retrieved": "2024-07-30T18:16:51.557984", "image_code": "float f_n_rand(float n){\n    n = n + 2.213*n;\n    n = n * n;\n    n = sin(11235.*n+n*3.13)*1.3425;\n    return fract(n);\n}\nvec2 f_o_rotd(\n    vec2 o, \n    float n_rot_nor\n){\n    float n_radians = 6.283158 * n_rot_nor;\n    float n_cos = cos(n_radians);\n    \n    float n_sin = sin(n_radians);\n\n    return vec2(\n        n_cos*o.x - n_sin*o.y,\n        n_sin*o.x + n_cos*o.y\n    );\n}\nfloat f_n_dist_segment(\n    vec2 o, \n    float n_ang_nor, \n    float n_radius_start, \n    float n_radius_end\n){\n    float n_tau = 6.28318530;\n    //float n_ang_nor_current = (atan(o.x, o.y))/n_tau));\n    float n_ang_nor_current = fract(((atan(o.y, o.x)+(n_tau/2.))/n_tau)+0.5);\n    float n_an = min(n_ang_nor, n_ang_nor_current);\n    n_an = n_ang_nor_current;\n    float n_len = length(o);\n    float n_radius = 0.5;\n    n_radius = max(n_len, n_radius_start);\n    n_radius = min(n_radius, n_radius_end);\n    vec2 o_p = vec2(\n        cos(n_an*n_tau)*n_radius,\n        sin(n_an*n_tau)*n_radius\n    );\n    vec2 o_pstart = vec2(\n        cos(0.*n_tau)*n_radius,\n        sin(0.*n_tau)*n_radius\n    );\n    vec2 o_pend = vec2(\n        cos(n_ang_nor*n_tau)*n_radius,\n        sin(n_ang_nor*n_tau)*n_radius\n    );\n    float n_len_start = length(o_pstart-o);\n    float n_len_end = length(o_pend-o);\n    \n    \n    float n_dist = length(o_p-o);\n    if(n_ang_nor_current > n_ang_nor){\n        return min(n_len_start, n_len_end);\n    }\n    return n_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    //needed for anti aliasing ?\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset*=5.5;\n\n    float n_tau = 6.2831;\n    float n_dist_prod = 1.;\n    float n_dist_prod2 = 1.;\n    float n_dist_min = 1.;\n    float n_it_nor_dmin = 0.;\n\n    \n    float n_its = 20.;\n    float n_dist_center = length(o_trn_fc_nor_offset);\n    \n    float n_one_it_nor = (1./n_its);\n    float n_it = floor(n_dist_center/n_one_it_nor);\n    float n_it_nor = n_it / n_its;\n        \n      \n    float n_radiu_start = n_it_nor+n_one_it_nor*0.5;\n    float n_radiu_end = n_radiu_start;\n    float n_ang_nor = n_it_nor*0.2;//f_n_rand(n_it);\n    \n    float n_dist_segment1 = f_n_dist_segment(\n        //f_o_rotd(o_trn_fc_nor_offset, sin(n_it_nor*n_tau*0.1+iTime*0.2)), \n        f_o_rotd(o_trn_fc_nor_offset, sin(iTime+n_it_nor)), \n        n_ang_nor,//n_ang_nor, //n_ang_nor\n        n_radiu_start,//n_radiu_start,\n        n_radiu_end//n_radiu_end\n    );\n    n_dist_segment1 = pow(n_dist_segment1, 1./3.);\n    float nss = 1./n_its; \n    n_dist_segment1 = smoothstep(nss, nss*7.+n_ratio_1to_iresx*20., n_dist_segment1);\n    fragColor = vec4(vec3(1.-n_dist_segment1), 1.);\n    \n    //fragColor = vec4(f_n_rand(o_trn_fc_nor_offset.x+o_trn_fc_nor_offset.y*o_trn_fc_nor_offset.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 120], [121, 121, 171, 171, 376], [377, 377, 488, 488, 1415], [1417, 1417, 1474, 1474, 3080]], "test": "untested"}
{"id": "mlSGDD", "name": "Box outline", "author": "fishy", "description": "Had this idea for a while... seems OK except where the two boxes intersect", "tags": ["raymarching"], "likes": 9, "viewed": 218, "published": 3, "date": "1673303864", "time_retrieved": "2024-07-30T18:16:52.325931", "image_code": "#define AA 6.0\n#define FOCAL_LEN 5.\n\n#define AO_STR 0.\n#define AO_DIST 0.03\n#define AO_POW 2.\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#define saturate(x) clamp(0.0, 1.0, x)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    float scale = 0.02;\n    p /= scale;\n    //p = rotZ(p, iTime);\n    float d = 1e20;\n    join(d, sdBox(p, vec3(20.)));\n    join(d, sdBox(p, vec3(10., 30., 10.)));\n    outMat = marchMat(vec3(0.9), 0);\n    d *= scale;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p, float h) // by iq\n{\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    mat3 o = mat3(h);\n    for( int i=ZERO; i<3; i++ )\n    {\n        vec3 oi = o[i];\n        float a = sceneDist(p+oi)-sceneDist(p-oi);\n        n += oi*a;\n    }\n    return normalize(n);\n}\n\n#define displayVarH(n) mix(vec4(.9), displayVar(n), vec4(res.hit))\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982+iTime*0.2*step(-0.01, -m.z)) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    vec3 lgt = normalize(vec3(1, 1, 0));\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    float strokeSize = (sin(iTime)*0.5+0.5)*0.03+0.01;\n    vec3 n = calcNormal(res.pos, 1e-6);\n    float lighting = 1.;\n    float ao = 1.-pow(0.9-saturate(sceneDist(res.pos+AO_DIST*n)/AO_DIST), AO_POW);\n    \n    vec3 col = res.mat.color*lighting*mix(1., ao, AO_STR);\n    col *= 1.-step(1e-4, length(calcNormal(res.pos, strokeSize)-n));\n\n    return displayVarH(col);\n    //return displayVarH(length(calcNormal(res.pos, strokeSize)-n));\n    //return displayVarH(n);\n}\n\n#undef displayVarH\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    res += getColorAtPix(fc, m);\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            res += getColorAtPix(fc + (hash22((x+iTime+fc)*25.)-0.5), m);\n        }\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = sqrt(col) + displayVar(printFR((fragCoord-iResolution.xy*0.5)/iResolution.y*0.55, iFrameRate));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 117, 117, 255], [257, 257, 278, 278, 414], [456, 456, 500, 500, 536], [538, 538, 577, 577, 617], [619, 619, 668, 668, 765], [767, 767, 788, 788, 837], [840, 840, 868, 868, 903], [905, 905, 933, 933, 968], [970, 970, 998, 998, 1033], [1035, 1035, 1181, 1181, 1265], [1402, 1402, 1436, 1436, 1454], [1455, 1455, 1495, 1495, 1512], [1514, 1514, 1569, 1569, 1650], [1652, 1652, 1708, 1708, 1806], [1808, 1808, 1868, 1868, 1909], [1911, 1911, 1971, 1971, 2015], [2017, 2017, 2050, 2050, 2076], [2078, 2078, 2118, 2118, 2205], [2207, 2207, 2247, 2247, 2325], [2327, 2327, 2365, 2365, 2395], [2397, 2397, 2431, 2431, 2478], [2480, 2480, 2523, 2523, 2574], [2576, 2576, 2641, 2641, 2753], [2755, 2755, 2801, 2801, 3034], [3036, 3036, 3061, 3061, 3107], [3109, 3109, 3183, 3183, 3564], [3566, 3566, 3613, 3613, 3857], [3927, 3927, 3964, 3964, 4882], [4904, 4904, 4936, 4936, 5155], [5157, 5157, 5193, 5193, 5464], [5466, 5466, 5523, 5523, 5685]], "test": "untested"}
{"id": "mlS3WD", "name": "EYE OF RA", "author": "maxwellcoffee", "description": "Click on different areas to witness RA in their many forms. \nRide on the shoulders of the giant.\n\nRA is pleased when you are on full screen.", "tags": ["psychedelic"], "likes": 3, "viewed": 218, "published": 3, "date": "1673302309", "time_retrieved": "2024-07-30T18:16:53.203584", "image_code": "/* \n@maxwellcoffee - 2023 \n\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec4 m = iMouse / iResolution.x;\n    float c, \n          o,\n          d,\n          complex = iFrameRate,\n          e = 1.4+11.962+(iTime+ 699.3)*0.0001111;\n         \n          if (e > 13.43) {e =+ iTime*.00111111 + 11.62;complex += .1*iTime;}\n           if( m.x>0.0 ) // button is down\n            {\n                e += m.y * 10000.;\n                e += (m.x / 10000.) * iTime * iTime;\n            }\n          \n            \n          \n    vec2  r = iResolution.xy; \n    \n    for (;o++<complex;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*tan(2.*e);\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += d =(length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.4,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clB3DD", "name": "Pathagorean Portal", "author": "maxwellcoffee", "description": "[full screen] Pathagoras grabs your hand and leads you somewhere else", "tags": ["psychedelic"], "likes": 1, "viewed": 228, "published": 3, "date": "1673299155", "time_retrieved": "2024-07-30T18:16:53.954576", "image_code": "/* @maxwellcoffee - 2023 \n\ninspo from + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o ,\n          complex = 30.,\n          e = 1.4+11.962+(iTime+ 59.2)*0.001111;\n          if (e > 13.43) {e =+ iTime*.111111 + 11.54;complex += .1*iTime;}\n          \n    vec2  r = iResolution.xy; \n    \n    for (;o++<complex;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*tan(2.*e);\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.4,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clB3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtB3DW", "name": "Multi-level metaballs", "author": "mrange", "description": "CC0: Multi-level metaballs\nContinuing yesterday experiments + an old shader\n", "tags": ["2d"], "likes": 22, "viewed": 381, "published": 3, "date": "1673298299", "time_retrieved": "2024-07-30T18:16:54.778375", "image_code": "// CC0: Multi-level metaballs\n//  Continuing yesterday experiments + an old shader\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat df(vec2 p, out float n, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d = circle(pp, 1.25*sz);\n  \n  n = fract(r);\n  sc = sz;\n  return d;\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 transform(vec2 p) {\n  p *= 3.0;\n  const mat2 rot0 = ROT(1.0);\n  const mat2 rot1 = ROT(-2.0);\n  vec2 off0 = 4.0*cos(vec2(1.0, sqrt(0.5))*0.23*TIME);\n  vec2 off1 = 3.0*cos(vec2(1.0, sqrt(0.5))*0.13*TIME);\n  vec2 sp0 = toSmith(p);\n  vec2 sp1 = toSmith((p+off0)*rot0);\n  vec2 sp2 = toSmith((p-off1)*rot1);\n  vec2 pp = fromSmith(sp0+sp1-sp2);\n  pp += 0.25*TIME;\n  return pp;\n}\n\nvec3 effect(vec2 p, vec2 np, vec2 pp) {\n  p = transform(p);\n  np = transform(np);\n  float aa = distance(p, np)*sqrt(2.0); \n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  float n = 0.0;\n  float sc = 0.0;\n  float d = df(p, n, sc)*z;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3(n-0.25*d/sc, 0.5+0.5*d/sc, 1.0);\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n  \n  const vec3 gcol1 = HSV2RGB(vec3(0.55, 0.6667, 3.0)); \n  \n  col *= smoothstep(0.25, 0., aa);\n  col += gcol1*tanh_approx(0.05*aa);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  \n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p+1.0/RESOLUTION.y;\n  vec3 col = effect(p, np, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtB3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 414, 436, 436, 582], [878, 878, 909, 909, 935], [937, 1023, 1059, 1059, 1153], [1155, 1221, 1242, 1242, 1310], [1312, 1372, 1400, 1466, 1542], [1544, 1544, 1589, 1589, 1882], [1884, 1884, 1907, 1987, 2126], [2128, 2128, 2153, 2232, 2371], [2373, 2373, 2397, 2397, 2749], [2751, 2751, 2790, 2790, 3388], [3390, 3390, 3447, 3447, 3655]], "test": "untested"}
{"id": "clBGDD", "name": "Shiny Pebbles", "author": "fishy", "description": "pebbles. Inspired by iq's sdf fbm terrain", "tags": ["raymarching"], "likes": 7, "viewed": 313, "published": 3, "date": "1673293441", "time_retrieved": "2024-07-30T18:16:55.584219", "image_code": "#define AA 1.0\n#define FOCAL_LEN 1.\n\n#define AO_STR 0.2\n#define AO_DIST 0.05\n#define AO_POW 2.\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat mRange(float ai, float aa, float bi, float ba, float x) { return (x-ai)/(aa-ai)*(ba-bi)+bi; } // Maps x between a range of ai-aa to bi-ba\nfloat mRange(vec2 a, vec2 b, float x) { return mRange(a.x, a.y, b.x, b.y, x); }\nfloat sRange(float i, float a, float x) { return x*(a-i)+i; } // Maps x between a range of 0-1 to i-a\nfloat sRange(vec2 a, float x) { return sRange(a.x, a.y, x); }\nfloat eRange(float i, float a, float x) { return (x-i)/(a-i); } // Maps x between a range of i-a to 0-1\nfloat eRange(vec2 a, float x) { return eRange(a.x, a.y, x); }\n\n#define saturate(x) clamp(0.0, 1.0, x)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvoid sintersect( inout float d2, float d1, float k ) { // by iq\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    d2 =  mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvoid marginIntersect(inout float a, float b, float k) { a = max(a-k, b); }\nvoid smarginIntersect(inout float a, float b, float k1, float k2) { a = a-k1; sintersect(a, b, k2); }\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nfloat sdFloor(vec3 p, float y)\n{\n    return p.y-y;\n}\n\nfloat sdPlane(vec3 p, float y)\n{\n    return abs(p.y-y);\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\n#define SEARCH 2.\n\nfloat sdFbmBase(in vec3 p, float j, vec2 r, float s)\n{\n    float res = 1e20;\n    for(vec2 x = vec2(-SEARCH); x.x <= SEARCH; x.x++)\n    for(x.y = -SEARCH; x.y <= SEARCH; x.y++)\n    {\n        vec2 currentCell = (floor(p.xz/s)+x)*s;\n        vec2 currentCellOffset = (hash22(currentCell)-0.5)*j;\n        float rad = sRange(r, hash22(currentCell+10.).x);\n        float currentCellDist = sdSphere(p-vec3(currentCell-currentCellOffset, 0.).xzy, rad);\n        sjoin(res, currentCellDist, 1.5);\n    }\n    return res;\n}\n\nfloat sdFbmBase(in vec3 p, float j, vec2 r, float s, float scale) { return sdFbmBase(p/scale, j, r, s)*scale; }\n\nfloat sdFbm(vec3 p, float j, vec2 r, float s, float o, float b)\n{\n    float res = sdPlane(p, 0.);\n    float ex = 1.;\n    for(float i = 0.; i < o; i++)\n    {\n        sjoin(res, sdFbmBase(p, j, r, s, ex*2.), b);\n        ex *= 0.5;\n    }\n    return res;\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    float scale = 0.05;\n    p /= scale;\n    //p = rotZ(p, iTime);\n    float d = 1e20;\n    join(d, sdFbm(p, 5.,vec2(0., 5.), 5., 2., 1.));\n    outMat = marchMat(vec3(0.9), 0);\n    d *= scale;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.00001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982+iTime*0.2) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    float lighting = dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))+0.1*max(0., n.z);\n    float ao = 1.-pow(0.9-saturate(sceneDist(res.pos+AO_DIST*n)/AO_DIST), AO_POW);\n    \n    vec3 envMap = texture(iChannel0, reflect(rd, n), texture(iChannel2, res.pos*0.5).r*10.0).rgb;\n    envMap *= envMap;\n    \n    res.mat.color = res.mat.color + envMap*1.0;\n\n    return sqrt(displayVar(mix(vec3(0.9), res.mat.color*lighting*mix(1., ao, AO_STR), vec3(res.hit))));\n    //return displayVar(ao);\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    res += getColorAtPix(fc, m);\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            res += getColorAtPix(fc + (hash22((x+iTime+fc)*25.)-0.5), m);\n        }\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = col + displayVar(printFR((fragCoord-iResolution.xy*0.5)/iResolution.y*0.55, iFrameRate));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 118, 118, 256], [258, 258, 279, 279, 415], [417, 417, 480, 480, 516], [517, 561, 600, 600, 640], [641, 641, 682, 682, 702], [703, 743, 774, 774, 804], [805, 805, 846, 846, 868], [869, 909, 940, 940, 970], [1012, 1012, 1056, 1056, 1092], [1094, 1094, 1133, 1133, 1173], [1175, 1175, 1224, 1224, 1321], [1323, 1323, 1344, 1344, 1393], [1396, 1396, 1424, 1424, 1459], [1461, 1461, 1489, 1489, 1524], [1526, 1526, 1554, 1554, 1589], [1591, 1591, 1737, 1737, 1821], [1958, 1958, 1992, 1992, 2010], [2011, 2011, 2051, 2051, 2068], [2070, 2070, 2125, 2125, 2206], [2208, 2208, 2264, 2264, 2362], [2364, 2364, 2418, 2427, 2525], [2527, 2527, 2582, 2582, 2601], [2602, 2602, 2669, 2669, 2703], [2705, 2705, 2765, 2765, 2806], [2808, 2808, 2868, 2868, 2912], [2914, 2914, 2947, 2947, 2973], [2975, 2975, 3015, 3015, 3102], [3104, 3104, 3144, 3144, 3222], [3224, 3224, 3262, 3262, 3292], [3294, 3294, 3328, 3328, 3375], [3377, 3377, 3420, 3420, 3471], [3473, 3473, 3505, 3505, 3525], [3527, 3527, 3559, 3559, 3584], [3586, 3586, 3651, 3651, 3763], [3784, 3784, 3838, 3838, 4293], [4295, 4295, 4362, 4362, 4406], [4408, 4408, 4473, 4473, 4660], [4662, 4662, 4708, 4708, 4915], [4917, 4917, 4942, 4942, 4988], [4990, 4990, 5064, 5064, 5445], [5447, 5447, 5486, 5486, 5749], [5751, 5751, 5788, 5788, 6719], [6721, 6721, 6753, 6753, 6972], [6974, 6974, 7010, 7010, 7281], [7283, 7283, 7340, 7340, 7496]], "test": "untested"}
{"id": "clS3WW", "name": "random points variations", "author": "jonasfrey", "description": "vonoroi", "tags": ["vonoroi"], "likes": 5, "viewed": 251, "published": 3, "date": "1673281826", "time_retrieved": "2024-07-30T18:16:56.337207", "image_code": "float f_n_rand(float n){\n    n += n*0.1338;\n    n *= n+ 0.2193;\n    n = sin(n*396.393+n*2.34)*2341.123;\n    return fract(n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset*=2.5;\n\n    float n_its = 50.;\n    float n_dmin = 1.;\n    float n_it_dmin = 0.;\n    float n_dprod = 1.;\n    float n_dsqrtprod = 1.;\n    float n_dist_secondmin = 1.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_t = floor(iTime)*0.1;\n        vec2 o_prand = vec2(\n            (f_n_rand(n_it+n_t)-0.5)*(2.+(iResolution.x/iResolution.y)), \n            (f_n_rand(n_it*3.123+n_t)-0.5)*2.\n        );\n        \n        float n_dist = length(o_trn_fc_nor_offset - o_prand);\n        n_dprod *= n_dist;\n        n_dsqrtprod *= pow(n_dist, 1./10.);\n        if(n_dist < n_dmin){\n            n_dmin = n_dist; \n            n_it_dmin = n_it;\n        }\n        if(n_dist < n_dist_secondmin && n_dist > n_dmin){\n            n_dist_secondmin = n_dist;\n        }\n    }\n    \n    float[] a_n = float[](\n        n_dmin, \n        sqrt(n_dmin), \n        n_it_dmin /n_its, \n        sin(n_dmin*6.2831*20.), \n        sqrt(n_dsqrtprod/n_its), \n        n_dprod/ 100000000000., \n        n_dist_secondmin\n        \n    );\n    float n_index = o_trn_fc_nor.x / (1. / float(a_n.length()));\n    float n = a_n[int(n_index)];\n    fragColor = vec4(n);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clS3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 126]], "test": "untested"}
{"id": "mlSGRW", "name": "CornelBox Pathmarching", "author": "NoxWings", "description": "Path tracing raymarching", "tags": ["pathtracing", "cornerlbox"], "likes": 0, "viewed": 49, "published": 3, "date": "1673273612", "time_retrieved": "2024-07-30T18:16:57.096177", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float INF = 1e15;\nconst float M_PI = 3.14159;\nconst float HIT_EPS = 0.001;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\n// Basic SDFs\n\nfloat sdSphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Random numbers\n\nvec2 get_random_numbers(inout uvec2 seed) \n{\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n// Sampling \n\nvec3 sample_sphere(vec2 random_numbers) \n{\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal)\n{\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)         \n        direction -= 2.0 * dot(normal, direction) * normal;     \n    return direction;\n}\n\n// Hit & Rays\n\nstruct Hit \n{\n    int matId;\n    float d;\n};\n\nstruct RayResult \n{\n    float t;\n    int steps;\n    Hit hit;\n};\n\nHit hmin(Hit a, Hit b) { if (a.d < b.d) return a; return b; } \nHit hmax(Hit a, Hit b) { if (a.d > b.d) return a; return b; }\n\n// Materials\n\nstruct Material {\n    vec3 color;\n    vec3 emissive;\n};\n\nconst int MATERIALS = 6;\nconst float LIGHT_INTENSITY = 3.0;\nMaterial mats[MATERIALS] = Material[MATERIALS]( \n    Material(vec3(0,0,0), vec3(0,0,0)),        // 0- NONE\n    Material(vec3(0.839, 0.839, 0.84), vec3(0,0,0)),  // 1- Balls\n    Material(vec3(0.73, 0.246, 0.251), vec3(0,0,0)),  // 2- Red wall\n    Material(vec3(0.29, 0.664, 0.325), vec3(0,0,0)),  // 3- Green wall\n    Material(vec3(0.0,0.0,0.0), vec3(LIGHT_INTENSITY)),  // 4- Light ceiling\n    Material(vec3(0.874, 0.874, 0.875), vec3(0,0,0))   // 6- White walls\n);\n\nHit map(vec3 p) \n{\n    vec3 boxSize = vec3(1.0, 1.0, 1.0);\n    vec4 bs = vec4(boxSize, 0.01);\n    \n    Hit h = Hit(0, INF);\n\n    // floor\n    h = hmin(h, Hit(5, sdBox(p - vec3(0,0,0), bs.xwz)));\n    // back\n    h = hmin(h, Hit(5, sdBox(p - vec3(0, bs.y, -bs.z), bs.xyw)));\n    // left\n    h = hmin(h, Hit(2, sdBox(p - vec3(-bs.x, bs.y, 0), bs.wyz)));\n    // right\n    h = hmin(h, Hit(3, sdBox(p - vec3(bs.x, bs.y, 0), bs.wyz)));\n    // top\n    h = hmin(h, Hit(4, sdBox(p - vec3(0,bs.y*2.0,0), bs.xwz)));\n    \n    // Left box \n    vec3 q = p;\n    q -= vec3(-.3,0.6,-.2);\n    q.xz *= r2d(0.13 * M_PI);\n    h = hmin(h, Hit(1, sdBox(q, vec3(0.30, 0.60, 0.30))));\n    // Right box\n    q = p;\n    q -= vec3(0.4,0.30,0.2);\n    q.xz *= r2d(-0.13 * M_PI);\n    h = hmin(h, Hit(1, sdBox(q, vec3(0.30, 0.30, 0.30))));\n    \n    \n    return h;\n}\n\nvec3 mapNormal(vec3 p) \n{\n    vec2 eps = vec2(0.001, 0.0);\n    float d = map(p).d;\n    return normalize(vec3(\n        d - map(p - eps.xyy).d,\n        d - map(p - eps.yxy).d,\n        d - map(p - eps.yyx).d\n    ));\n}\n\nRayResult raymarch(vec3 ro, vec3 rd, int maxSteps, float far) \n{\n    int steps = 0;\n    float t = 0.0;\n    float minD = INF;\n    Hit hit = Hit(0, INF);\n    \n    for (steps = 0; steps < maxSteps; steps++) \n    {\n        vec3 p = ro + rd * t;\n        hit = map(p);\n        \n        if (hit.d < minD) minD = hit.d;\n        if (hit.d < HIT_EPS) \n        {\n            return RayResult(t, steps, hit);\n        }\n\n        t += hit.d;\n        if (t >= far) \n        {\n            break;\n        }\n    }\n\n    return RayResult(INF, steps, hit);\n}\n\n\nvec3 pathTrace(vec3 ro, vec3 rd, uvec2 pixel) \n{\n    int maxSteps = 128;\n    float far = 10.0;\n    \n    uvec2 seed = pixel;\n    vec3 radiance = vec3(0);\n    vec3 throughput = vec3(1);\n\n    for (int bounces = 0; bounces < 5; bounces++)\n    {\n        RayResult res = raymarch(ro, rd, maxSteps, far);\n        if (res.t < INF) \n        {\n            Material m = mats[res.hit.matId];\n            radiance += m.emissive * throughput;\n        \n            vec3 hit_point = ro + rd * res.t;\n            vec3 hit_normal = mapNormal(hit_point);\n            \n            ro = hit_point + hit_normal * HIT_EPS * 2.0;\n            rd = sample_hemisphere(get_random_numbers(seed), hit_normal);\n            \n            throughput *= m.color * 2.0 * dot(hit_normal, rd);\n        }\n        else \n        {\n            break;\n        }\n    }\n    \n    return radiance;\n}\n\nfloat camZoom(float fovDegrees) \n{\n    const float DEG2RAD = M_PI / 180.0;\n    float halfFov = fovDegrees * 0.5;\n    float rad = halfFov * DEG2RAD;\n    return -cos(rad) / sin(rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 seed = uvec2(fragCoord) ^ uvec2(iFrame << 16);\n    vec2 rand1 = get_random_numbers(seed) * 2.0 - 1.0;\n      \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvJit = (fragCoord + rand1)/iResolution.xy;\n    vec2 fakeScreen = (uvJit * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);;\n\n    vec3 ro = vec3(0, 1.0, 3.5);\n    vec3 rd = normalize(vec3(fakeScreen, camZoom(40.0)));\n\n    vec3 color = pathTrace(ro, rd, seed);\n    \n    if (iFrame > 0) \n    {\n        float weight = 1.0 / float(iFrame+1);\n        vec3 prevColor = texture(iChannel0, uv).rgb;\n        vec3 newColor = max(vec3(0.0), color);\n        color = mix(prevColor, newColor, vec3(weight));\n    } \n    \n    fragColor = vec4(color,1.0);\n}\n ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "dt2GDh", "name": "circle segment", "author": "jonasfrey", "description": "segment", "tags": ["circle", "segment"], "likes": 4, "viewed": 201, "published": 3, "date": "1673266808", "time_retrieved": "2024-07-30T18:16:57.848166", "image_code": "float f_n_dist_segment(\n    vec2 o, \n    float n_ang_nor, \n    float n_radius_start, \n    float n_radius_end\n){\n    float n_tau = 6.28318530;\n    //float n_ang_nor_current = (atan(o.x, o.y))/n_tau));\n    float n_ang_nor_current = fract(((atan(o.y, o.x)+(n_tau/2.))/n_tau)+0.5);\n    float n_an = min(n_ang_nor, n_ang_nor_current);\n    n_an = n_ang_nor_current;\n    float n_len = length(o);\n    float n_radius = 0.5;\n    n_radius = max(n_len, n_radius_start);\n    n_radius = min(n_radius, n_radius_end);\n    vec2 o_p = vec2(\n        cos(n_an*n_tau)*n_radius,\n        sin(n_an*n_tau)*n_radius\n    );\n    vec2 o_pstart = vec2(\n        cos(0.*n_tau)*n_radius,\n        sin(0.*n_tau)*n_radius\n    );\n    vec2 o_pend = vec2(\n        cos(n_ang_nor*n_tau)*n_radius,\n        sin(n_ang_nor*n_tau)*n_radius\n    );\n    float n_len_start = length(o_pstart-o);\n    float n_len_end = length(o_pend-o);\n    \n    \n    float n_dist = length(o_p-o);\n    if(n_ang_nor_current > n_ang_nor){\n        return min(n_len_start, n_len_end);\n    }\n    return n_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset*=2.5;\n\n    float n_its = 50.;\n    float n_tau = 6.2831;\n    float n_dist_prod = 1.;\n    float n_dist_prod2 = 1.;\n    float n_dist_min = 1.;\n    float n_it_nor_dmin = 0.;\n    \n    float n_radiu_start = sin(iTime)*0.5+0.5;\n    float n_radiu_end = 1.;//fract(n_radiu_start+0.5);\n    \n    float n_dist_segment = f_n_dist_segment(\n        o_trn_fc_nor_offset, \n        sin(iTime)*.5+0.5, \n        n_radiu_start,\n        n_radiu_end\n    );\n    \n    fragColor = vec4(vec3(n_dist_segment), 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2GDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 111, 111, 1038], [1040, 1040, 1097, 1130, 2046]], "test": "untested"}
{"id": "Dt23D1", "name": "telepathy", "author": "maxwellcoffee", "description": "I see you when I see myself.", "tags": ["psychedelic"], "likes": 1, "viewed": 166, "published": 3, "date": "1673258062", "time_retrieved": "2024-07-30T18:16:58.669969", "image_code": "/* @maxwellcoffee - 2023 + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          e = 0.84+iTime*0.111111;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<1e2;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*tan(2.*e);\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.4,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt23D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dlj3D1", "name": "everything all at once ", "author": "maxwellcoffee", "description": "a reflection of a reflection of a reflection of a reflection...", "tags": ["psychedelic"], "likes": 2, "viewed": 221, "published": 3, "date": "1673257549", "time_retrieved": "2024-07-30T18:16:59.566572", "image_code": "/* @maxwellcoffee - 2023 \n\ninspo from + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          e = 0.84+iTime*0.0111111;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<2e2;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*tan(2.*e);\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.04,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cl2GW1", "name": "gradient color", "author": "tianluo97", "description": "gradient color", "tags": ["gradient"], "likes": 1, "viewed": 165, "published": 3, "date": "1673253189", "time_retrieved": "2024-07-30T18:17:00.417298", "image_code": "float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n// Copied from the book of shaders: https://thebookofshaders.com/13/\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n//Copied from the same book of shaders chapter\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(938, 84);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3均为可调参数\n    vec4 color1 = vec4(0.71373,0.85882,0.92157,1.0); \n    vec4 color2 = vec4(0.60000,0.67843,1.0,1.0);\n    vec4 color3 = vec4(0.0,0.0,1.0,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.3; \n    \n    //scale为可调参数\n    float scale = 3.0;\n    //colorStep1为可调参数\n    float colorStep1 = 0.33333;\n    //colorStep2为可调参数\n    float colorStep2 = 0.66666;\n\n    float ease[3];\n    ease[0] = -(cos(PI * fract(time/scale)) - 1.0)/2.0 * scale;  \n    ease[1] = fract(time/scale)*scale;\n    ease[2] = (1.0 - pow(1.0 - fract(time/scale),3.0))*scale;\n    \n    float easeChoice = mod(time/scale,4.0);\n    int i = int(easeChoice);\n    float offset  = ease[i] + floor(time/scale)*scale;\n    offset = uv.y - offset;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n    fragColor = mix(color3, color1, dist1);\n    }\n    \n    //红到蓝 step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color1, color2, dist2);\n    }\n    \n    //蓝到绿 step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = mix(color2, color3, dist3);\n    }\n    \n    //fbm color\n    vec2 uv2 = uv;\n\tuv2.x *= 20.0;\n\tuv2.y *= 4.0; \n    uv2.x += time * 0.4;\n    uv2.y -= time;\n\tvec3 col = mix(vec3(0.0,0.0,0.), vec3(1.), fbm(uv2 - vec2(2.0*iTime)));\n\tvec3 color = vec3(0.0);\n  \n    //第一层基础fbm的流动 uv+time\n\tvec2 q = vec2(0.);\n    q.x = fbm(uv2 - .4 * iTime);\n    q.y = fbm(uv2 - vec2(1.0));\n\n    //在第一层fbm的基础上再进行一次fbm，uv+ r + time, time可以改变流速\n\tvec2 g = vec2(0.);\n    g.x = fbm( uv2 - 1.0*q + vec2(1.7,9.2) -  .5 * iTime );\n    g.y = fbm( uv2 - 1.0*q + vec2(8.3,2.8) -  .26 * iTime);\n\n    //得到基础的fbm\n\tfloat f = fbm(uv2+g);\n  \n    color = mix(vec3(0.0,0.0,0.0),\n                vec3(.2,.2,.2),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.7,0.7,0.7),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(1.0,1.0,1.0),\n                clamp(length(g.x),0.0,1.0));\n\n    //提升黑白区的对比度\n    vec4 fbmColor = vec4((f*f*f+.6*f*f+.5*f)*vec3(1.),1.);\n\tfragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),fbmColor.r * 0.5);\n      \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2GW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [224, 371, 397, 397, 777], [850, 850, 876, 876, 1214], [1365, 1365, 1422, 1459, 4590]], "test": "untested"}
{"id": "Dt2GDh", "name": "every(thing,where,time)", "author": "maxwellcoffee", "description": "everything, everywhere, all the time", "tags": ["psychedelic"], "likes": 8, "viewed": 296, "published": 3, "date": "1673239459", "time_retrieved": "2024-07-30T18:17:01.256054", "image_code": "/* @maxwellcoffee - 2023 \n\ninspo from + @kishimisu - 2022)\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          d = 3., \n          e = iTime*0.1;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<2e2 && d>.001;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*cos(2.*e);\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += d = (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.04,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*110. + .99*vec3(0,1.+c*.2,2))+.2)/exp(c*0.0914);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2GDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dtl3WS", "name": "Path Tracing (Disney BSDF)", "author": "XT95", "description": "Tea time!", "tags": ["pathtracing", "pbr", "ggx", "disney", "bsdf"], "likes": 137, "viewed": 4093, "published": 3, "date": "1673224543", "time_retrieved": "2024-07-30T18:17:02.676258", "image_code": "// ----------------------------------------------------------------\n// Path Tracing (Disney BSDF)\n// ----------------------------------------------------------------\n// \n// This is not optimized, I tried to keep it clear.\n// The BSDF has only the diffuse, specular and transmitance parts\n// for now.\n// \n//\n// You can move the camera with the mouse\n// and zoom in/out with 'w' and 's'.\n//\n// - Buffer A : Draw a raw frame\n// - Buffer B : Accumulate frame\n//              You can change the mode to get TAAish output\n// - Image : Basic ACES tonemapping\n// ----------------------------------------------------------------\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = ACES(col*1.2);\n    \n    // vignetting\n    col *= vec3(1.) * smoothstep(1.8,.5, length(uv*2.-1.))*.5+.5;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ----------------------------------------------------------------\n// Defines\n// ----------------------------------------------------------------\n// - Scene can go from 0 to 2\n// - The furnace_test show the energy loss, the image should be\n//   all white in a perfect pathtracer\n//   \n// ----------------------------------------------------------------\n#define CAMERA_SENSITIVTY .01\n#define FOCAL_LENGTH 3.\n\n\n// ---------------------------------------------\n// Hash & Random - From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\n\n// ---------------------------------------------\n// Maths\n// ---------------------------------------------\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n\nmat3 lookat(vec3 ro, vec3 ta)\n{\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(ta-ro);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\n// From Fizzer - https://web.archive.org/web/20170610002747/http://amietia.com/lambertnotangent.html\nvec3 cosineSampleHemisphere(vec3 n)\n{\n    vec2 rnd = frand2();\n\n    float a = PI*2.*rnd.x;\n    float b = 2.0*rnd.y-1.0;\n    \n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(n + dir);\n}\n\n// From Pixar - https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z<0.){\n        float a = 1.0 / (1.0 - n.z);\n        float b = n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, -b, n.x);\n        b2 = vec3(b, n.y * n.y*a - 1.0, -n.y);\n    }\n    else{\n        float a = 1.0 / (1.0 + n.z);\n        float b = -n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n        b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    }\n}\n\nvec3 toWorld(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return v.x*x + v.y*y + v.z*z;\n}\n\nvec3 toLocal(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return vec3(dot(v, x), dot(v, y), dot(v, z));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Color\n// ---------------------------------------------\nvec3 RGBToYCoCg(vec3 rgb)\n{\n\tfloat y  = dot(rgb, vec3(  1, 2,  1 )) * 0.25;\n\tfloat co = dot(rgb, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat cg = dot(rgb, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(y, co, cg);\n}\n\nvec3 YCoCgToRGB(vec3 ycocg)\n{\n\tfloat y = ycocg.x;\n\tfloat co = ycocg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat cg = ycocg.z - ( 0.5 * 256.0 / 255.0 );\n\treturn vec3(y + co-cg, y + cg, y - co-cg);\n}\n\nfloat luma(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Microfacet\n// ---------------------------------------------\nfloat Fresnel(float n1, float n2, float VoH, float f0, float f90)\n{\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-VoH*VoH);\n        if (sinT2 > 1.0)\n            return f90;\n        VoH = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-VoH;\n    float ret = r0+(1.0-r0)*pow(x, 5.);\n    \n    return mix(f0, f90, ret);\n}\nvec3 F_Schlick(vec3 f0, float theta) {\n    return f0 + (1.-f0) * pow(1.0-theta, 5.);\n}\n\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0-theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = pow(roughness, 2.);\n    return a2 / (PI * pow((NoH*NoH)*(a2*a2-1.)+1., k));\n}\n\nfloat SmithG(float NoV, float roughness2)\n{\n    float a = pow(roughness2, 2.);\n    float b = pow(NoV,2.);\n    return (2.*NoV) / (NoV+sqrt(a + b - a * b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness)\n{\n    float a2 = roughness*roughness;\n    float G1 = SmithG(NoV, a2);\n    float G2 = SmithG(NoL, a2);\n    return G1*G2;\n}\n\nvec3 SampleGGXVNDF(vec3 V, float ax, float ay, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(ax * V.x, ay * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(ax * Nh.x, ay * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GGXVNDFPdf(float NoH, float NoV, float roughness)\n{\n \tfloat D = D_GTR(roughness, NoH, 2.);\n    float G1 = SmithG(NoV, roughness*roughness);\n    return (D * G1) / max(0.00001, 4.0f * NoV);\n}\n\n\n// ---------------------------------------------------------------------------------\n// Triplanar & bump mapping! \n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\n// ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}\n\n\n\n// ---------------------------------------------\n// Data IO\n// ---------------------------------------------\nstruct Data {\n    float theta;\n    float phi;\n    float r;\n    \n    vec3 ro;\n    vec3 ta;\n    \n    vec3 oldRo;\n    vec3 oldTa;\n    \n    vec4 oldMouse;\n    \n    float refreshTime;\n};\n\nfloat readData1(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).r;\n}\nvec3 readData3(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value) {\n    if (floor(fragCoord.x) == float(id))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value) {\n    if (floor(fragCoord.x) == float(id))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value) {\n    if (floor(fragCoord.x) == float(id))\n        col = value;\n        \n    return col;\n}\nData initData() {\n\tData data;\n    \n    data.theta = -.5;\n    data.phi = .6;\n    data.r = 3.;\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    data.ta = vec3(0.,0.35,.5);\n    \n    data.oldRo = data.ro;\n    data.oldTa = data.ta;\n    \n    data.oldMouse = vec4(0.);\n    \n    data.refreshTime = 0.;\n    \n    return data;\n}\nData readData(sampler2D tex, vec2 invRes) {\n\tData data;\n    \n    data.theta = readData1(tex, 0);\n    data.phi = readData1(tex, 1);\n    data.r = readData1(tex, 2);\n    \n    data.ro = readData3(tex, 3);\n    data.ta = readData3(tex, 4);\n    \n    data.oldRo = readData3(tex, 5);\n    data.oldTa = readData3(tex, 6);\n    \n    data.oldMouse = readData4(tex, 7);\n    data.refreshTime = readData1(tex, 8);\n    \n    return data;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, Data data) {\n    col = writeData(col, fragCoord.xy, 0, data.theta);\n    col = writeData(col, fragCoord.xy, 1, data.phi);\n    col = writeData(col, fragCoord.xy, 2, data.r);\n    col = writeData(col, fragCoord.xy, 3, data.ro);\n    col = writeData(col, fragCoord.xy, 4, data.ta);\n    col = writeData(col, fragCoord.xy, 5, data.oldRo);\n    col = writeData(col, fragCoord.xy, 6, data.oldTa);\n    col = writeData(col, fragCoord.xy, 7, data.oldMouse);\n    col = writeData(col, fragCoord.xy, 8, data.refreshTime);\n    return col;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Distance field \n// ---------------------------------------------\nfloat box( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat teapot(vec3 p) {\n    p.y -= .02;\n    float scale = 1.2;\n    p *= scale;\n    \n    // body\n    float body;\n    {\n        body = length(p-vec3(0.,.5,0.))-.5+smoothstep(0.1,.8,p.y)*.5;// - smoothstep(0.,.02, p.y)*.01;\n    }\n    \n    //nose\n    float nose;\n    {\n        nose = length(p.xz-vec2(0.0,0.1+smoothstep(0.,.45,p.y)*.45))-.04;\n        nose = max(nose, -p.y+.15);\n    } \n    \n    //grip\n    float grip;\n    {\n        vec2 pos = vec2(-.35,.34);\n        grip = length(p.zy-pos)-.12;\n        grip = smax(grip, -(length(p.zy-pos)-.1), .005);\n        grip = smax(grip, abs(p.x)-.03, .05);\n    } \n    \n    //lid\n    float lid;\n    {\n        vec3 r= vec3(.2,.025,.2);\n        vec3 pp = p - vec3(0.,.51,0.);\n        float k0 = length(pp/r);\n        float k1 = length(pp/(r*r));\n        lid = k0*(k0-1.0)/k1;\n        lid = smin(lid, length(pp-vec3(0.,.05,0.))-.03, 0.01);\n    }\n    \n    float d = smin(body, nose, .1);\n    d = smin(d, grip, .05);\n    d = abs(d)-0.005;\n    d = max(d, p.y-.5);    \n    d = max(d, min(p.z-.3,p.y-.4));\n    d = min(d, lid);\n    \n    \n    return d/scale*.65;\n}\nfloat teapot2(vec3 p) {\n    float s = .4;\n    p -= vec3(.3,-.05,1.5);\n    p.xz = rot(-2.3)*p.xz;\n    return teapot(p*s)/s;\n}\n\nfloat bowl(vec3 p) {\n    p.y -= .42;\n    float d = length(p)-.45;\n    d = abs(d)-.025;\n    d = smax(d, p.y, .05);\n    \n    float grip;\n    {\n        vec2 pos = vec2(-.45,-.18);\n        grip = length(p.zy-pos)-.15;\n        grip = smax(grip, -(length(p.zy-pos)-.1), .05);\n        grip = smax(grip, abs(p.x)-.03, .05);\n        grip = max(grip, -(length(p)-.45));\n    } \n    d = smin(d, grip, .05);\n    d = smax(d, -p.y-.5, .2);\n    return d;\n\n}\n\nfloat tea(vec3 p) {\n    p.y -= .43;\n    float d = length(p)-.4;\n    d = max(d, p.y+.1);\n    d = smax(d, -p.y-.5, .2);\n    return d;\n}\n\n\nfloat boxLight(vec3 p) {\n    return box(p-vec3(-5.,1.,0.), vec3(.5,.5,2.));\n}\n\n\nfloat map(vec3 p) {\n\n    float d = p.y;\n    d = min(d, teapot2(p));\n    d = min(d, min(bowl(p), tea(p)));\n    d = min(d, boxLight(p));\n    \n    return d;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Ray tracing \n// ---------------------------------------------\nfloat trace(vec3 ro, vec3 rd, vec2 nf) {\n    float t = nf.x;\n    float s = sign(map(ro));\n    for(int i=0; i<256; i++) {\n        float d = map(ro+rd*t) * s;\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 eps = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n;\n    n.x = d - map(p - eps.xyy);\n    n.y = d - map(p - eps.yxy);\n    n.z = d - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n", "buffer_a_code": "// ---------------------------------------------\n// Raw Frame\n// ---------------------------------------------\n\n\n// ---------------------------------------------\n// Material\n// ---------------------------------------------\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    \n    float specTrans;\n    float ior;\n    float absorption;\n};\nMaterial newMaterial() {\n    Material mat;\n    mat.albedo = vec3(1.);\n    mat.metallic = 0.;\n    mat.roughness = .0;\n    mat.emissive = vec3(0.);\n    mat.specTrans = 0.;\n    mat.ior = 1.33;\n    mat.absorption = 1.;\n    \n    return mat;\n}\nMaterial getMaterial(vec3 p, inout vec3 n) {\n    \n    Material mat = newMaterial();\n        \n    \n    float d = map(p);\n    if (d == bowl(p)) { // Bowl\n        mat.metallic = 0.0;\n        mat.albedo = vec3(1.);\n        mat.specTrans = 1.;\n        mat.absorption = 0.;\n        mat.roughness = .1;\n        mat.ior = 1.5;\n    } else if (d == teapot2(p)) { // Teapot\n        mat.metallic = 0.0;\n        mat.albedo = vec3(1.);\n        mat.specTrans = 0.;\n        mat.absorption = 0.;\n        mat.roughness = .1;\n        mat.ior = 1.5;\n    } else if (d == tea(p)) { // Tea\n        mat.metallic = 0.0;\n        mat.albedo = vec3(0.,-1.,-2.);\n        mat.specTrans = 1.;\n        mat.absorption = 5.;\n        mat.roughness = .05;\n        mat.ior = 1.33;\n    } else if (d == boxLight(p)) { // Area light\n        mat.emissive = vec3(3.0);\n    } else { // Ground\n        mat.metallic = 1.;\n        mat.specTrans = 0.;\n        mat.albedo = texture(iChannel2,p.zx).rgb;\n        n = bumpMapping(iChannel2, p.zyx,n, 0.01);\n        mat.roughness = luma(mat.albedo);\n    }\n    \n    return mat;\n}\n\n// ---------------------------------------------\n// State\n// ---------------------------------------------\nstruct State {\n    bool isRefracted;\n    bool hasBeenRefracted;\n    float lastIOR;\n};\n\nState initState() {\n    State s;\n    s.hasBeenRefracted = false;\n    s.isRefracted = false;\n    s.lastIOR = 1.;\n    \n    return s;\n}\n\n\n// ---------------------------------------------\n// BSDF\n// ---------------------------------------------\nvec3 evalDisneyDiffuse(Material mat, float NoL, float NoV, float LoH, float roughness) {\n    float FD90 = 0.5 + 2. * roughness * pow(LoH,2.);\n    float a = F_Schlick(1.,FD90, NoL);\n    float b = F_Schlick(1.,FD90, NoV);\n    \n    return mat.albedo * (a * b / PI);\n}\n\nvec3 evalDisneySpecularReflection(Material mat, vec3 F, float NoH, float NoV, float NoL) {\n    float roughness = pow(mat.roughness, 2.);\n    float D = D_GTR(roughness, NoH,2.);\n    float G = GeometryTerm(NoL, NoV, pow(0.5+mat.roughness*.5,2.));\n\n    vec3 spec = D*F*G / (4. * NoL * NoV);\n    \n    return spec;\n}\n\nvec3 evalDisneySpecularRefraction(Material mat, float F, float NoH, float NoV, float NoL, float VoH, float LoH, float eta, out float pdf) {\n    float roughness = pow(mat.roughness, 2.);\n    float D = D_GTR(roughness, NoH, 2.);\n    float G = GeometryTerm(NoL, NoV, pow(0.5+mat.roughness*.5, 2.));\n    float denom = pow(LoH + VoH*eta, 2.);\n\n    float jacobian = abs(LoH) / denom;\n    pdf = SmithG(abs(NoL), roughness*roughness) * max(0.0, VoH) * D * jacobian / NoV;\n    \n    vec3 spec = pow(1.-mat.albedo, vec3(0.5))  * D * (1.-F) * G * abs(VoH) * jacobian * pow(eta, 2.) / abs(NoL * NoV);\n    return spec;\n}\n\nvec4 sampleDisneyBSDF(vec3 v, vec3 n, in Material mat, out vec3 l, inout State state) {\n    state.hasBeenRefracted = state.isRefracted;\n    \n    float roughness = pow(mat.roughness, 2.);\n\n    // sample microfacet normal\n    vec3 t,b;\n    basis(n,t,b);\n    vec3 V = toLocal(t,b,n,v);\n    vec3 h = SampleGGXVNDF(V, roughness,roughness, frand(), frand());\n    if (h.z < 0.0)\n        h = -h;\n    h = toWorld(t,b,n,h);\n\n    // fresnel\n    float VoH = dot(v,h);\n    vec3 f0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n    vec3 F = F_Schlick(f0, VoH);\n    float dielF = Fresnel(state.lastIOR, mat.ior, abs(VoH), 0., 1.);\n    \n    // lobe weight probability\n    float diffW = (1.-mat.metallic) * (1.-mat.specTrans);\n    float reflectW = luma(F);\n    float refractW = (1.-mat.metallic) * (mat.specTrans) * (1.-dielF);\n    float invW = 1./(diffW + reflectW + refractW);\n    diffW *= invW;\n    reflectW *= invW;\n    refractW *= invW;\n    \n    // cdf\n    float cdf[3];\n    cdf[0] = diffW;\n    cdf[1] = cdf[0] + reflectW;\n    //cdf[2] = cdf[1] + refractW;\n    \n    \n    vec4 bsdf = vec4(0.);\n    float rnd = frand();\n    if (rnd < cdf[0]) // diffuse\n    {\n        l = cosineSampleHemisphere(n);\n        h = normalize(l+v);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float LoH = dot(l,h);\n        float pdf = NoL/PI;\n        \n        vec3 diff = evalDisneyDiffuse(mat, NoL, NoV, LoH, roughness) * (1.-F);\n        bsdf.rgb = diff;\n        bsdf.a = diffW * pdf;\n    } \n    else if(rnd < cdf[1]) // reflection\n    {\n        l = reflect(-v,h);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float NoH = min(0.99,dot(n,h));\n        float pdf = GGXVNDFPdf(NoH, NoV, roughness);\n        \n        vec3 spec = evalDisneySpecularReflection(mat, F, NoH, NoV, NoL);\n        bsdf.rgb = spec;\n        bsdf.a = reflectW * pdf;\n    }\n    else // refraction\n    {\n        state.isRefracted = !state.isRefracted;\n        float eta = state.lastIOR/mat.ior;\n        l = refract(-v,h, eta);\n        state.lastIOR = mat.ior;\n        \n        float NoL = dot(n,l);\n        if ( NoL <= 0. ) { return vec4(0.); }\n        float NoV = dot(n,v);\n        float NoH = min(0.99,dot(n,h));\n        float LoH = dot(l,h);\n        \n        float pdf;\n        vec3 spec = evalDisneySpecularRefraction(mat, dielF, NoH, NoV, NoL, VoH, LoH, eta, pdf);\n        \n        bsdf.rgb = spec;\n        bsdf.a = refractW* pdf;\n    }\n    \n    bsdf.rgb *= abs(dot(n,l));\n\n    return bsdf;\n}\n\n\n// ---------------------------------------------\n// Pathtrace\n// ---------------------------------------------\nvec4 pathtrace(vec3 ro, vec3 rd) {\n    \n    State state = initState();\n    float firstDepth = 0.;\n    vec3 acc = vec3(0.);\n    vec3 abso = vec3(1.);\n    \n    for(int i=0; i<8; i++) {\n        // raytrace\n        float t = trace(ro,rd, vec2(0.01, 1000.));\n        vec3 p = ro + rd * t;\n        if (i == 0) firstDepth = t;\n        \n        // sky intersection ?\n        if (t >= 1000.) {\n            //acc += skyColor(rd, sundir) * abso;\n            acc += pow(texture(iChannel3, rd).rgb, vec3(2.2)) * abso;\n            break;\n        }\n        \n        // info at intersection point\n        vec3 n = normal(p, t);\n        if (state.isRefracted) n = -n;\n        Material mat = getMaterial(p,n);\n        \n        // sample BSDF\n        vec3 outDir;\n        vec4 bsdf = sampleDisneyBSDF(-rd,n, mat, outDir, state);\n        \n        // add emissive part of the current material\n        acc += mat.emissive * abso;\n            \n        // bsdf absorption (pdf are in bsdf.a)\n        if ( bsdf.a > 0.)\n            abso *= bsdf.rgb / bsdf.a;\n        \n        // medium absorption\n        if (state.hasBeenRefracted) {\n            abso *= exp(-t * ((vec3(1.)-mat.albedo)*mat.absorption));\n        }\n        \n        // next direction\n        ro = p;\n        rd = outDir;\n        if (state.isRefracted ) {\n            ro += -n*0.01;\n        } else if (state.hasBeenRefracted && !state.isRefracted) {\n            ro += -n*0.01;\n            state.lastIOR = 1.;\n        } else {\n            ro += n*0.01;\n        }\n        \n        // random early exit taking account energy loss\n        #if 1\n        {\n            float q = max(abso.r, max(abso.g, abso.b));\n            if (frand() > q)\n                break;\n\n            abso /= q;\n        }\n        #endif\n        \n    }\n\n    return vec4(acc, firstDepth);\n}\n\n\n// ---------------------------------------------\n// Entrypoint\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    srand(ivec2(fragCoord), iFrame);\n    \n    // read data\n    Data data = readData(iChannel0, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // setup ray\n    vec2 uv = (fragCoord + frand2()-.5) * invRes;\n    vec3 ro = data.ro;\n    vec2 v = uv*2.-1.;\n    v.x *= iResolution.x * invRes.y;\n    \n    // setup camera\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(data.ta-data.ro);\n    vec3 uu = normalize(cross(fw, up));\n    vec3 vv = normalize(cross(uu, fw));\n    vec3 er = normalize(vec3(v,FOCAL_LENGTH));\n    vec3 rd = uu * er.x + vv * er.y + fw * er.z;\n    \n    // depth of field with autofocus\n    #if 1\n    float focusDistance = trace(ro,  fw, vec2(0.01, 100.));\n    vec3 focalPoint = ro + rd * focusDistance;\n    \n    float blurAmount = 0.015;\n    vec3 go = blurAmount*vec3( normalize(frand2()*2.-1.)*sqrt(frand()), 0.0 );\n    ro += go.x*uu + go.y*vv;\n    \n    rd = normalize(focalPoint - ro);\n    #endif\n    \n    \n    // pathtrace\n    vec4 col = pathtrace(ro, rd);\n    \n    fragColor = vec4(min(col.rgb,vec3(10.)), col.a > 1000. ? -1. : col.a);\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------\n// - Camera/data IO + Frames accumulation\n//\n//\n// MODE 0 - Raw frame\n// MODE 1 - Accumulate frames\n// MODE 2 - Temporal reprojection\n// ---------------------------------------------\n#define MODE 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 seed = hash3(vec3(fragCoord.xy, float((iFrame+1) % 10000)));\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = (fragCoord + seed.xy-.5) * invRes;\n    \n    // read input buffer\n    vec2 rawUv = fragCoord*invRes;\n    vec4 rawCol = texture(iChannel1, rawUv);\n    vec4 col = rawCol;\n    \n    // read data\n    bool needRefresh = false;\n    Data data = readData(iChannel0, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // camera\n    if (iMouse.zw == data.oldMouse.zw) {\n        data.theta += (data.oldMouse.x - iMouse.x)  * CAMERA_SENSITIVTY;\n        data.phi += (data.oldMouse.y - iMouse.y)  * CAMERA_SENSITIVTY;\n        if (texelFetch( iChannel2, ivec2(87,0), 0 ).x > 0.) { // w\n            data.r *= 1.-CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(83,0), 0 ).x > 0.) { // s\n            data.r *= 1.+CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(32,0), 0 ).x > 0.) { // space\n            needRefresh = true;\n        }\n        if (iMouse.z > .5)\n            needRefresh = true;\n    }\n    data.phi = clamp(data.phi, 0.01, 3.);\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    \n    \n    // MODE 1 - accumulate frame\n    #if MODE == 1\n    vec4 lastCol = texture(iChannel0, fragCoord*invRes);\n    if (!needRefresh) {\n        float w = 1. / (float(iFrame)-data.refreshTime + 1.);\n        col = lastCol*(1.-w) + col * w;\n    }\n    else {\n        data.refreshTime = float(iFrame);\n    }\n    #endif\n    \n    // MODE 2 - temporal reprojection\n    #if MODE == 2\n    if (col.a > 0.) {\n        // reconstruct world space position\n        vec3 ro = data.ro;\n        vec2 v = uv*2.-1.;\n        v.x *= iResolution.x * invRes.y;\n        vec3 rd = lookat(data.ro, data.ta) * normalize(vec3(v,FOCAL_LENGTH));\n        float t = rawCol.a;\n        vec3 p = ro + rd * t;\n        \n        // reprojection\n        mat3 oldCam = lookat(data.oldRo, data.oldTa);\n        mat3x4 invOldCam = mat3x4( vec4( oldCam[0], -dot(oldCam[0],data.oldRo) ),\n                                   vec4( oldCam[1], -dot(oldCam[1],data.oldRo) ),\n                                   vec4( oldCam[2], -dot(oldCam[2],data.oldRo) ));\n        vec4 wpos = vec4(p,1.0);\n        vec3 cpos = wpos*invOldCam;\n        vec2 npos = FOCAL_LENGTH*cpos.xy/cpos.z;\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0) - (seed.xy-.5)*invRes;\n        vec2 rpos = spos * iResolution.xy;\n        vec4 lastCol = texture(iChannel0, spos);\n\n        float w = .0;\n        vec3 oldRd = lookat(data.oldRo, data.oldTa) * normalize(vec3(v,FOCAL_LENGTH));\n        vec3 oldwp = data.oldRo + oldRd * lastCol.w;\n\n        // depth rejection\n        for(int x=-1; x<=1; x++){\n            for(int y=-1; y<=1; y++){\n                float lastT = texture(iChannel0, spos + vec2(x, y) * invRes).a;\n                w = max(w, smoothstep(t*t*.005,0.,abs(t-lastT)));\n            }\n        }\n        w -= 0.01;\n        \n        // color clamping\n        #if 1\n        const int kernelSize = 2;\n        vec3 minCol = vec3(99999.);\n        vec3 maxCol = vec3(0.);\n        for(int x=-kernelSize; x<=kernelSize; x++){\n            for(int y=-kernelSize; y<=kernelSize; y++){\n                vec4 c = texture(iChannel1, spos + vec2(x, y) * invRes);\n                c.rgb = RGBToYCoCg(c.rgb);\n                minCol = min(minCol, c.rgb);\n                maxCol = max(maxCol, c.rgb);\n            }\n        }\n        lastCol.rgb = RGBToYCoCg(lastCol.rgb);\n        lastCol.rgb = clamp(lastCol.rgb, minCol, maxCol);\n        lastCol.rgb = YCoCgToRGB(lastCol.rgb);\n        #endif\n\n        //w = 0.99;\n        if (rpos.x < 7. && rpos.y < 1.) w = 0.;\n        if (abs(spos.x-.5) > .5) w = 0.;\n        if (abs(spos.y-.5) > .5) w = 0.;\n        \n        if (iFrame > 1)\n            col = mix(col, lastCol, saturate(w));\n    }\n    #endif\n   \n    \n    // write data\n    data.oldRo = data.ro;\n    data.oldTa = data.oldTa;\n    data.oldMouse = iMouse;\n    if (fragCoord.y < 1.)\n    col = writeData(col, fragCoord, data);\n    \n    // output pixel color\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtl3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 621, 646, 646, 832], [834, 834, 891, 891, 1150]], "test": "untested"}
{"id": "dtSGWh", "name": "Rainbow smith cells", "author": "mrange", "description": "CC0: Rainbow smith cells\nContinuation of earlier experiments\n", "tags": ["2d"], "likes": 69, "viewed": 890, "published": 3, "date": "1673207863", "time_retrieved": "2024-07-30T18:17:03.577847", "image_code": "// CC0: Rainbow smith cells\n//  Continuation of earlier experiments\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float rep   = 32.0;\nconst float over  = 4.0;\nconst float nstep = 1.0/(rep*over);\nconst float astep = TAU*nstep;\nconst float pm    = 17.0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float aa) {\n  const float angle = 2.0*PI/rep;\n  float a = aa + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (rep/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat segmentx(vec2 p, float l, float w) {\n  p = abs(p);\n  p.x -= l*0.5-w;\n  float d0 = length(p)-w;\n  float d1 = p.y-w;\n  float d = p.x > 0.0 ? d0 : d1;\n  return d;\n}\n\nvec2 df(vec2 p, float noff, float a, out float n) {\n  const float ll  = 0.5;\n  const float ss = 0.0015;\n  const float bb = ss*4.0;\n  n = modPolar(p, a)/rep+noff;\n  float m = 16.0*sin(TIME*TAU);\n  float anim = sin(TAU*TIME/10.0+pm*noff*TAU);\n  p.x -= 0.75+0.25*anim;\n  float l = ll*mix(0.5, 1.0, smoothstep(-0.9, 0.9, anim));\n  float s = ss;\n  float b = bb;\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x = abs(p1.x);\n  p1.x -= l*0.5-s;\n  float d0 = segmentx(p0, l, s);\n  float d1 = length(p1)-b;\n  return vec2(d0, d1);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec3 effect0(vec2 p, float aa) {\n  const float zz = 2.75;\n  p /= zz;\n  vec2 hn = hextile(p);\n  p *= zz;\n  float n;\n  vec3 col = vec3(0.0);\n  const mat2 rr = ROT(TAU/(rep*over));\n  vec2 pp = p;\n  float a = atan(p.y, p.x);\n  float ll = length(p);\n  for (float i = 0.0; i < over; ++i) {\n    float noff = i*nstep;\n    float aoff = i*astep;\n    vec2 d = df(p, noff, a-aoff, n);\n    d /= aa;\n\n    float g0 = 2.0/max(max(d.x, 0.0), 0.001);\n    float g1 = 8.0/max((d.y*d.y), 0.000001);\n    col += hsv2rgb(vec3(0.5*ll+n-0.1*TIME, 0.85, g0));\n    col += hsv2rgb(vec3(0.5*ll+n-0.1*TIME, 0.5, g1));\n//    col = mix(col, vec3(0.54), smoothstep(1.0, -1.0, d.x));\n//    col = mix(col, vec3(1.0), smoothstep(1.0, -1.0, d.y));\n    p *= rr;\n  }\n  \n  col *= smoothstep(0.5*zz, 0.25*zz, ll);\n  const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.75, 10000.0)); \n  const vec3 gcol1 = HSV2RGB(vec3(0.55, 0.95, 0.025)); \n  col += gcol0*aa*aa+gcol1/dot(p, p);\n  col /= (600.0*aa);\n  return col;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 transform(vec2 p) {\n  vec2 off0 = sin(vec2(1.0, sqrt(0.5))*0.23*TIME);\n  vec2 off1 = sin(vec2(1.0, sqrt(0.5))*0.13*TIME);\n  vec2 sp0 = toSmith(p);\n  vec2 sp1 = toSmith(p+off0);\n  vec2 sp2 = toSmith(p-off1);\n  vec2 pp = fromSmith(sp0+sp1-sp2);\n  pp += 0.1*TIME;\n  return pp;\n}\n\nvec3 effect(vec2 p, vec2 np, vec2 pp) {\n  p = transform(p);\n  np = transform(np);\n  float aa = distance(p, np)*sqrt(2.0); \n  vec3 col = effect0(p, aa);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p + 1.0/RESOLUTION.y;\n  vec3 col = effect(p, np, pp);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[574, 574, 596, 596, 742], [1037, 1123, 1163, 1163, 1543], [1545, 1645, 1664, 1664, 1751], [1753, 1860, 1886, 1886, 2070], [2072, 2072, 2114, 2114, 2239], [2241, 2241, 2292, 2292, 2751], [2753, 2854, 2882, 2981, 3308], [3310, 3310, 3342, 3342, 4270], [4273, 4273, 4296, 4376, 4515], [4517, 4517, 4542, 4621, 4760], [4762, 4762, 4786, 4786, 5042], [5044, 5044, 5083, 5083, 5211], [5213, 5213, 5270, 5270, 5526]], "test": "untested"}
{"id": "ctS3Dh", "name": "Wave equation absorbing boundary", "author": "michael0884", "description": "Mur's boundary conditions\nhttp://www.cavelab.cs.tsukuba.ac.jp/nsfdtd/theory/beginner_04.html", "tags": ["wave"], "likes": 23, "viewed": 457, "published": 3, "date": "1673197942", "time_retrieved": "2024-07-30T18:17:04.556231", "image_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    //render\n    vec4 t = 10.*A(U); \n    //color = amplitude\n    Q.xyz = vec3(1,0,0)*t.x - vec3(0,0,1)*t.x + vec3(0.,0.5,0.)*abs(t.x);\n    vec2 f = vec2(t.x, t.y*2.0);\n    Q.xyz = vec3(0.25*dot(f,f));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n//a way to sample pixels shorthand \n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n", "buffer_a_code": "//the time step\n#define dt 0.4\n\n//boundary thickness\n#define l 1.0\n\n\nfloat laplacian(vec2 pos)\n{\n    return A(pos+vec2(0,1)).x + A(pos-vec2(0,1)).x + A(pos+vec2(1,0)).x + A(pos-vec2(1,0)).x - 4.0*A(pos).x;\n}\n\nvec2 newField(vec2 pos)\n{\n    vec2 field = A(pos).xy;\n    float time = float(iFrame) * dt;\n    float force = 0.1*exp(-0.1*dot(pos-0.5*R,pos-0.5*R))*cos(0.5*time);\n    force += 0.05*exp(-0.1*dot(pos-0.4*R,pos-0.4*R))*cos(0.25*time);\n    force += 0.025*exp(-0.1*dot(pos-0.6*R,pos-0.6*R))*cos(0.125*time);\n    field.y += dt*(laplacian(pos) + force); //velocity += force * time step\n    field.x += dt*field.y; //position += velocity*time step\n    return field;\n}\n\nvec2 newAbsorbed(vec2 pos, vec2 n)\n{\n    float uS = 1.0 * dt / 1.0;\n    vec2 field = A(pos).xy;\n    field.x = A(pos + n).x + (newField(pos + n).x - A(pos).x) * (uS - 1.0) / (uS + 1.0);\n    return field;\n}\n\nvoid mainImage( out vec4 field, in vec2 pos )\n{\n    pos = floor(pos);\n\n    //boundary condition\n    if(pos.x <= l) \n        field.xy = newAbsorbed(pos, vec2(1,0));\n    else if(pos.x >= R.x - 1.0 - l)\n        field.xy = newAbsorbed(pos, vec2(-1,0));\n    else if(pos.y <= l)\n        field.xy = newAbsorbed(pos, vec2(0,1));\n    else if(pos.y >= R.y - 1.0 - l)\n        field.xy = newAbsorbed(pos, vec2(0,-1));\n    else\n        field.xy = newField(pos);\n\n    //initial conditions\n    if (iFrame < 1) {\n        field.xy = vec2(0.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctS3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 54, 244]], "test": "untested"}
{"id": "ctB3Dh", "name": "Compiler bug with % and -", "author": "fenix", "description": "I thought these two macros should produce the same results, but on my system (Mac/Radeon 570X/Chrome or Firefox) they do not. Red = bad, Green = good. It looks like the unary negation operator is being simplified wrongly when % are used, maybe.", "tags": ["glsl", "modulo", "compatibility", "portability"], "likes": 2, "viewed": 223, "published": 3, "date": "1673197288", "time_retrieved": "2024-07-30T18:17:05.560545", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2(-U.x, U.y); // only looking at -a/+b quadrant\n    \n    int x = abs(I.x) % (I.y);\n    int y = (-I.x) % (I.y);     // since I.x is always negative, -I.x should be equal to abs(I.x)\n    \n    O = x == y ? vec4(0, 1, 0, 1) : vec4(1, 0, 0, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctB3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 298]], "test": "untested"}
{"id": "ctj3DR", "name": "3D Tri Rasterizer v1.1", "author": "raymarchingenthusiast", "description": "Fills triangles with textures. Depth corrected. 2^SIZE is how many times faster it gets. Includes backface culling. I figured out that using the normal you can determine wether it faces towards or away without the winding order.", "tags": ["triangles"], "likes": 1, "viewed": 211, "published": 3, "date": "1673189184", "time_retrieved": "2024-07-30T18:17:06.484076", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = (fragCoord/SIZE)/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TriCount 12\n#define PI 3.14159265\n#define SIZE 3.\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nstruct TriDat {\n    Triangle Vp;\n    Triangle Vuv;\n    bool flipNorm;\n    int colMode;\n};\n\nvoid rotX(inout vec3 p, vec2 at) {\n    p.y = at.x*p.y-at.y*p.z;\n    p.z = at.y*p.y+at.x*p.z;\n}\n\nvoid rotY(inout vec3 p, vec2 at) {\n    p.x = at.y*p.z+at.x*p.x;\n    p.z = at.x*p.z-at.y*p.x;\n}\n\nvoid rotZ(inout vec3 p, vec2 at) {\n    p.x = at.x*p.x+at.y*p.y;\n    p.y = at.y*p.x-at.x*p.y;\n}\n\nvec3 crd(vec2 iMouse,vec2 uv) {\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 ra = PI*(vec2(0.,0.)-3.*iMouse);\n    \n    rotY(rd,vec2(cos(ra.x),sin(ra.x)));\n    rotX(rd,vec2(cos(ra.y),sin(ra.y)));\n    \n    //rd.y *= -1.;\n    return rd;\n}\n\nvoid SetTri(inout TriDat t[TriCount], int i,\n  vec3 v1,vec3 v2,vec3 v3,\n  vec2 uv1,vec2 uv2, vec2 uv3,\n  bool fn, int txtr) {\n    t[i] = TriDat(Triangle(v1,v2,v3),Triangle(vec3(uv1,1.),vec3(uv2,1.),vec3(uv3,1.)),fn,txtr);\n}\n\nvoid SetTriData(out TriDat t[TriCount],float iTime) {\n    SetTri(t,0,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(2.,-1.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,1,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(-1.,2.,1.),vec2(1.,0.),vec2(1.,1.),vec2(0.,1.),true,0);\n    SetTri(t,2,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(-1.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),true,0);\n    SetTri(t,3,vec3(-1.,2.,1.),vec3(-1.,2.,4.),vec3(-1.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),true,0);\n    SetTri(t,4,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(2.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,5,vec3(2.,2.,1.),vec3(2.,2.,4.),vec3(2.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),false,0);\n    SetTri(t,6,vec3(-1.,2.,1.),vec3(-1.,2.,4.),vec3(2.,2.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,7,vec3(-1.,2.,4.),vec3(2.,2.,4.),vec3(2.,2.,1.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),false,0);\n    SetTri(t,8,vec3(-1.,-1.,1.),vec3(-1.,-1.,4.),vec3(2.,-1.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),true,0);\n    SetTri(t,9,vec3(-1.,-1.,4.),vec3(2.,-1.,4.),vec3(2.,-1.,1.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),true,0);\n    SetTri(t,10,vec3(-1.,-1.,4.),vec3(-1.,2.,4.),vec3(2.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),true,0);\n    SetTri(t,11,vec3(2.,-1.,4.),vec3(2.,2.,4.),vec3(-1.,2.,4.),vec2(1.,0.),vec2(1.,1.),vec2(0.,1.),false,0);\n}\n\nvoid SplitTriDat(TriDat t[TriCount],out Triangle tp[TriCount],out Triangle tuv[TriCount]) {\n    for(int i = 0; i < TriCount; i++) {\n        tp[i] = t[i].Vp;\n        tuv[i] = t[i].Vuv;\n    }\n}", "buffer_a_code": "void RecalibTris(inout Triangle tso[TriCount], vec3 ro) {\n    for(int i = 0; i < TriCount; i++) {\n        vec3 a = vec3(tso[i].a.xy-.5,tso[i].a.z);\n        vec3 b = vec3(tso[i].b.xy-.5,tso[i].b.z);\n        vec3 c = vec3(tso[i].c.xy-.5,tso[i].c.z);\n        a -= ro;\n        b -= ro;\n        c -= ro;\n        tso[i] = Triangle(a,b,c);\n    }\n}\n\nvec3 CalcNorm(Triangle t) {\n    vec3 U = t.b-t.a;\n    vec3 V = t.c-t.a;\n    \n    vec3 n;\n    \n    n.x = U.y*V.z - U.z*V.y;\n    n.y = U.z*V.x - U.x*V.z;\n    n.z = U.x*V.y - U.y*V.x;\n    \n    return normalize(n);\n}\n\nvec2 CalcUv(vec2 p, Triangle tp, Triangle tuv, Triangle top, out vec3 pos, out float depth) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    //vec3 auv = w1*tuv.a + w2*tuv.b + w3*tuv.c;\n    vec3 puv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    vec4 p0a = vec4(top.a,1.);\n    vec4 p0b = vec4(top.b,1.);\n    vec4 p0c = vec4(top.c,1.);\n    vec4 p1 = w1*p0a/p0a.z + w2*p0b/p0b.z + w3*p0c/p0c.z;\n    vec2 z0a = vec2(tp.a.z,1.);\n    vec2 z0b = vec2(tp.b.z,1.);\n    vec2 z0c = vec2(tp.c.z,1.);\n    vec2 z1 = w1*z0a/z0a.x + w2*z0b/z0b.x + w3*z0c/z0c.x;\n    \n    depth = z1.x / z1.y;\n    pos = p1.xyz / p1.w;\n    return puv.xy / puv.z;\n}\n\nbool isInside(vec2 p, Triangle tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nvec3 projVert(in vec3 v, vec2 ra) {\n    rotY(v,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(v,vec2(cos(-ra.y),sin(-ra.y)));\n    \n    return v;\n}\n\nTriangle Project(Triangle to,vec2 Mouse) {\n    vec2 ra = PI*(vec2(0.,0.)-3.*Mouse);\n    \n    vec3 a = projVert(to.a,ra);\n    \n    vec3 b = projVert(to.b,ra);\n    \n    vec3 c = projVert(to.c,ra);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    c.xy /= c.z;\n    return Triangle(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord0 ) {    \nvec2 fragCoord = fragCoord0 * SIZE;\nvec2 iResolution1 = iResolution.xy;\nvec2 uv = fragCoord / iResolution1;\nvec2 uMouse = iMouse.xy * SIZE;\nuMouse /= SIZE;\nif(uv.x <= 1. && uv.y <= 1.) {\n    uv -= .5;\n    vec2 MOUSE = (uMouse/iResolution1)-.5;\n    if(uMouse == vec2(0.)) MOUSE = vec2(0.);\n    \n    TriDat tris[TriCount];\n    SetTriData(tris,iTime);\n    \n    \n    Triangle tos[TriCount];\n    Triangle uvs[TriCount];\n    \n    SplitTriDat(tris,tos,uvs);\n    \n    vec3 rd = crd(MOUSE,uv);\n    vec3 centrRd = crd(MOUSE,vec2(0.));\n    vec3 ro = vec3(.5,.5,2.5)+crd(MOUSE,vec2(0.))*-8.;\n    //ro = vec3(0.,0.,-2.5);\n    RecalibTris(tos,ro);\n    vec3 ld = vec3(.5,.5,5.*sin(iTime)+5.);\n    \n    fragColor = vec4(0.,0.,.3,10000.);\n    float clipped = 0.;\n    for(int i = 0; i < TriCount; i++) {\n        Triangle ts = Project(tos[i],MOUSE);\n        bool inside = isInside(uv,ts);\n        bool behind = ts.a.z<=0.||ts.b.z<=0.||ts.c.z<=0.;\n        if(inside && !behind) {\n            vec3 p;\n            float d;\n            vec2 textureUv = CalcUv(uv,ts,uvs[i],tos[i],p,d);\n            \n            vec3 col = texture(iChannel0,textureUv).xyz;\n            //col = vec3(0.,1.,0.);\n            \n            vec3 n = CalcNorm(tos[i]);\n            if(tris[i].flipNorm) n *= -1.;\n            \n            bool clip = sign(dot(n,centrRd)) == 1.;\n            //clip = false;\n            if((!clip||tris[i].colMode==1) && d < fragColor.w) {\n                float dif = clamp(dot(n,normalize(ld-p)),0.,1.)*.5+.5;\n                col *= dif;\n                vec3 h = normalize(rd+normalize(ld-p));\n                col += .5* dif * vec3(pow(clamp(dot(h,n),0.,1.),30.));\n                \n                fragColor = vec4(col,d);\n                if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,d);\n            }\n        }\n    }\n    \n    fragColor.xyz = mix(fragColor.xyz,vec3(1.,0.,0.),clipped);\n    fragColor.w = 1.;\n}}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctj3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 153]], "test": "untested"}
{"id": "ml2GDz", "name": "Circle stuff", "author": "pthextract", "description": "Circle of dots", "tags": ["circle"], "likes": 3, "viewed": 176, "published": 3, "date": "1673188600", "time_retrieved": "2024-07-30T18:17:07.345772", "image_code": "void mainImage( out vec4 o, in vec2 i )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = i/iResolution.xy;\n    uv-=.5;\n    uv.y/=iResolution.x/iResolution.y;\n\n\n    vec3 col =1.-vec3(\n    min(\n    abs((0.5+.9*cos(iTime))*22.-88.*length(uv))\n    ,\n    abs((0.5+.1*cos(iTime))*22.-55.*length(uv)))\n    \n    );\n    col.rb+=1.*(1.-abs( .5-  fract( 20.*cos(iTime)+ (36.*atan(uv.x,uv.y)/6.283)    )    ));\n   //col*=1.*(.5-abs( .5-  fract( 10.*cos(iTime)+ (52.*atan(uv.x,uv.y)/6.283)    )    ));\n    \n    \n    // Output to screen\n    o = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2GDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 91, 564]], "test": "untested"}
{"id": "clSGWh", "name": "ChatGPT Rotating field box v.2", "author": "BitsnBobs", "description": "I asked chatGPT to add the actual field shape into an external function based on this shader it wrote just a moment ago.\nhttps://www.shadertoy.com/view/ctSGWh", "tags": ["sdf"], "likes": 0, "viewed": 179, "published": 3, "date": "1673187807", "time_retrieved": "2024-07-30T18:17:08.109730", "image_code": "float sdBox(vec2 p, vec2 s)\n{\n    // Calculate the distance from the point to the box\n    return length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the signed distance field\n    float d = sdBox(p, s);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n/*\nput the actual sdf shape into an external function in the above shader\nCertainly! Here is the modified version of the shader that puts the calculation of the signed distance field (SDF) into a separate function:\n\nCopy code\nfloat sdBox(vec2 p, vec2 s)\n{\n    // Calculate the distance from the point to the box\n    return length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the signed distance field\n    float d = sdBox(p, s);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\nIn this version of the shader, the sdBox function takes in a point p and a box size s, and returns the signed distance from the point to the box. The main image function then uses this function to calculate the signed distance field for each pixel on the screen.\n\nI hope this helps! Let me know if you have any questions.\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 85, 164], [166, 166, 223, 273, 808]], "test": "untested"}
{"id": "ctSGWh", "name": "ChatGPT Rotating field box", "author": "BitsnBobs", "description": "Asked chatGPT to write a rotating field box ( unsigned )", "tags": ["sdf"], "likes": 0, "viewed": 146, "published": 3, "date": "1673187580", "time_retrieved": "2024-07-30T18:17:08.895628", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the distance from the point to the box\n    float d = length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\n\n/*\n\nwrite a shadertoy sdf box that rotates over time\nHere is a modified version of the previous shader that will animate the rotation of the box over time:\n\nCopy code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the distance from the point to the box\n    float d = length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\nThis shader will draw a red box that rotates around the center of the screen. The rotation speed is determined by the value of iTime, which is a built-in variable in Shadertoy that contains the elapsed time in seconds. You can adjust the rotation speed by multiplying iTime by a factor. For example, to rotate the box at half the speed, you could use angle = iTime * 0.25.\n\nI hope this helps! Let me know if you have any questions.\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 708]], "test": "untested"}
{"id": "mlj3Wz", "name": "ChatGPT3 \"Sine wrapping circle\"", "author": "fragcula", "description": "I asked ChatGPT3 to write a fragment shader\n\nPrompt \"write a shadertoy.com fragment shader that draws a sine wave wrapped in a circle\"\n\nOnly modification (you can see in the code) is to swap iGlobalTime for iTime.", "tags": ["spiral", "ai", "chat", "gpt", "chatgpt3"], "likes": 4, "viewed": 187, "published": 3, "date": "1673181220", "time_retrieved": "2024-07-30T18:17:09.764306", "image_code": "// Prompted form ChatGPT3, if you think it ripped you off let me know, it must have gotten the code from somewhere?\n// Inspired to ask ChatGPT3 by https://www.shadertoy.com/view/dljGWz (https://www.shadertoy.com/user/BitsnBobs)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates to [-1, 1]\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    // Compute distance from center\n    float r = length(uv);\n\n    // Compute angle around circle\n    float a = atan(uv.y, uv.x);\n\n    // Compute sine wave\n    float y = sin(a*20.0 + r*10.0 + iTime*5.0); // ChatGPT3 used iGlobalTime here.\n\n    // Compute color from sine wave\n    vec3 col = vec3(y, y*0.5+0.5, y*0.25+0.75);\n\n    // Output color\n    fragColor = vec4(col, 1.0);\n}\n\n/*\nwrite a shadertoy.com fragment shader that draws a sine wave wrapped in a circle\n\nHere is a ShaderToy fragment shader that draws a sine wave wrapped in a circle:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates to [-1, 1]\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    // Compute distance from center\n    float r = length(uv);\n\n    // Compute angle around circle\n    float a = atan(uv.y, uv.x);\n\n    // Compute sine wave\n    float y = sin(a*20.0 + r*10.0 + iGlobalTime*5.0);\n\n    // Compute color from sine wave\n    vec3 col = vec3(y, y*0.5+0.5, y*0.25+0.75);\n\n    // Output color\n    fragColor = vec4(col, 1.0);\n}\n\nThis shader uses the following uniforms:\n\n    iResolution: the dimensions of the output image in pixels\n    iGlobalTime: the current time in seconds\n\nIt expects a vec2 coordinate in screen space (i.e., fragCoord) and outputs a vec4 color value (i.e., fragColor). The mainImage function is the entry point for the fragment shader and is called once for each pixel of the output image.\n\nThe shader first normalizes the screen space coordinates to the range [-1, 1] using the dimensions of the output image. It then computes the distance from the center of the circle (r) and the angle around the circle (a) using the normalized coordinates.\n\nNext, the shader computes the sine wave using the angle and distance, and uses the value of the sine wave to compute a color value. Finally, it outputs the color value as the fragment color. The sine wave is animated over time by using the iGlobalTime uniform in the computation of the sine wave.\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlj3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 286, 326, 754]], "test": "untested"}
{"id": "dtj3Wz", "name": "Lines on a flag", "author": "fragcula", "description": "Adding detail with lines to a flag, I'd like the sun at the centre to have rippling lines.", "tags": ["flag", "kurdish"], "likes": 1, "viewed": 143, "published": 3, "date": "1673180484", "time_retrieved": "2024-07-30T18:17:10.720749", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y ;\n\n    vec3 red    = vec3(0.929, 0.125, 0.141);\n    vec3 green  = vec3(0.153, 0.557, 0.263);\n    vec3 yellow = vec3(0.996, 0.741, 0.067);\n    vec3 white  = vec3(1.0, 1.0, 1.0);\n    vec2 centre = vec2(0.5, 0.5);\n\n    vec3 col = white;\n\n    mat2 scale = mat2(iResolution.x/iResolution.y, 0., 0., 1.);\n\n    float len = distance(uv, vec2(0.));\n\n    if (len < 0.25) {\n        col = yellow;\n        if(mod(len * iResolution.y + 2. * cos(fragCoord.x/3. + iTime * 5.), 4.) < 1.)\n            col *= 0.5;\n    }else{\n        if (uv.y < -1./6.) {\n            col = green;\n            if (mod(fragCoord.y + iTime * 10., 3.) < 1.)\n                col *= 0.5;\n        } else if (uv.y > 1./6.) {\n            col = red;\n            if (mod(fragCoord.y + 2.*cos(fragCoord.x/3. + iTime * 5.), 3.) < 1.)\n\n                col *= 0.5;\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtj3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1059]], "test": "untested"}
{"id": "dljGWz", "name": "chatGPT checker test", "author": "BitsnBobs", "description": "Asked chatGPT to generate a simple checker pattern", "tags": ["checker"], "likes": 1, "viewed": 405, "published": 3, "date": "1673178489", "time_retrieved": "2024-07-30T18:17:11.720077", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y; // correct aspect ratio\n    int x = int( mod( uv.x * 4.0, 2.0 ) );\n    int y = int( mod( uv.y * 4.0, 2.0 ) );\n    if ( ( x + y ) % 2 == 0 )\n    {\n        fragColor = vec4( 1.0, 1.0, 1.0, 1.0 ); // white\n    }\n    else\n    {\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 ); // black\n    }\n}\n\n\n\n/*\nwrite a shadertoy checker shader\nSure! Here is a basic checker shader that alternates between two colors in a checkerboard pattern:\n\nCopy code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y; // correct aspect ratio\n    int x = int( mod( uv.x * 4.0, 2.0 ) );\n    int y = int( mod( uv.y * 4.0, 2.0 ) );\n    if ( ( x + y ) % 2 == 0 )\n    {\n        fragColor = vec4( 1.0, 1.0, 1.0, 1.0 ); // white\n    }\n    else\n    {\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 ); // black\n    }\n}\nThis shader uses the mod function to determine the x and y indices of the current fragment in the checkerboard pattern, and then uses these indices to determine the color of the fragment. The checkerboard has 4x4 squares, so the uv coordinate is multiplied by 4 to ensure that the pattern repeats correctly.\n\nI hope this helps! Let me know if you have any questions or need further assistance.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 434]], "test": "untested"}
{"id": "mtjGWz", "name": "Rainbow wheel", "author": "mrange", "description": "CC0: Rainbow wheel\nI enjoyed this tweet by @junkiyoshi\nhttps://twitter.com/junkiyoshi/status/1611685042199343104?s=20&t=70iv6TwPx0x4qGWJMWqJYg\nTried something similar", "tags": ["2d", "rainbow", "twitter"], "likes": 47, "viewed": 556, "published": 3, "date": "1673177467", "time_retrieved": "2024-07-30T18:17:12.521933", "image_code": "// CC0: Rainbow wheel\n//  I enjoyed this tweet by @junkiyoshi\n//  https://twitter.com/junkiyoshi/status/1611685042199343104?s=20&t=70iv6TwPx0x4qGWJMWqJYg\n//  Tried something similar\n\n// Uncomment for variant suggested by morimea in the comments\n// #define MORIMEA\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float rep   = 32.0;\nconst float over  = 4.0;\nconst float nstep = 1.0/(rep*over);\nconst float astep = TAU*nstep;\nconst float pm    = 17.0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float aa) {\n  const float angle = 2.0*PI/rep;\n  float a = aa + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (rep/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat segmentx(vec2 p, float l, float w) {\n  p = abs(p);\n  p.x -= l*0.5-w;\n  float d0 = length(p)-w;\n  float d1 = p.y-w;\n  float d = p.x > 0.0 ? d0 : d1;\n  return d;\n}\n\nvec2 df(vec2 p, float noff, float a, out float n) {\n  const float ll  = 0.5;\n  const float ss = 0.0015;\n  const float bb = ss*4.0;\n  n = modPolar(p, a)/rep+noff;\n  float m = 16.0*sin(TIME*TAU);\n  float anim = sin(TAU*TIME/10.0+pm*noff*TAU);\n  p.x -= 0.75+0.25*anim;\n  float l = ll*mix(0.5, 1.0, smoothstep(-0.9, 0.9, anim));\n  float s = ss;\n  float b = bb;\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x = abs(p1.x);\n  p1.x -= l*0.5-s;\n  float d0 = segmentx(p0, l, s);\n  float d1 = length(p1)-b;\n  return vec2(d0, d1);\n}\n\nvec3 effect0(vec2 p, float aa) {\n  float n;\n  vec3 col = vec3(0.0);\n  const mat2 rr = ROT(TAU/(rep*over));\n  vec2 pp = p;\n  float a = atan(p.y, p.x);\n  for (float i = 0.0; i < over; ++i) {\n    float noff = i*nstep;\n    float aoff = i*astep;\n#if defined(MORIMEA)\n    vec2 d = df(p, noff, mod(a-aoff,TAU)*PI/25., n);\n#else\n    vec2 d = df(p, noff, mod(a-aoff,TAU), n);\n#endif\n\n    float g0 = 0.005/max(max(d.x, 0.0), 0.001);\n    float g1 = 0.00005/max((d.y*d.y), 0.000001);\n    col += hsv2rgb(vec3(0.5*length(p)+n-0.1*TIME, 0.85, g0));\n    col += hsv2rgb(vec3(0.5*length(p)+n-0.1*TIME, 0.5, g1));\n    p *= rr;\n  }\n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect0(p, aa);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[769, 769, 791, 791, 937], [1232, 1318, 1358, 1358, 1738], [1740, 1840, 1859, 1859, 1946], [1948, 2055, 2081, 2081, 2265], [2267, 2267, 2309, 2309, 2434], [2436, 2436, 2487, 2487, 2946], [2948, 2948, 2980, 2980, 3578], [3580, 3580, 3610, 3610, 3730], [3732, 3732, 3789, 3789, 4007]], "test": "untested"}
{"id": "ml23WR", "name": "Woven Pillars", "author": "kavehth", "description": "copied from this tweet\n\nhttps://twitter.com/kamoshika_vrc/status/1514165646149357568?s=20&t=ZIWaxwtRebHIRU5uK39Kzw", "tags": ["procedural", "lighting", "rotating", "epic", "massivescale"], "likes": 40, "viewed": 521, "published": 3, "date": "1673169219", "time_retrieved": "2024-07-30T18:17:13.447458", "image_code": "//this is not my work just coppied from \n//https://twitter.com/kamoshika_vrc/status/1514165646149357568?s=20&t=ZIWaxwtRebHIRU5uK39Kzw\n\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,Q,o;\n    P.x=iTime*0.0002;\n    float i,d=1.0;\n    for(;i++<2e2 && d>1e-4;\n    P+=normalize(vec3((gl_FragCoord.xy*2.0-iResolution.xy)/iResolution.y,2))*rotate3D(iTime*0.2,vec3(1,2,5))*d)\n    {\n        Q=P;\n        Q.xy=fract(Q.xy)-.5;\n        for(int j;j++<8;Q+=Q)\n          Q.xy=abs(Q.xy*rotate2D(Q.z+iTime*0.15))-.15; \n        d=(length(Q.xy)-0.2)/1e3; \n    }\n    o+=17.10/i;\n    fragColor =vec4(o,1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml23WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 159, 159, 211], [213, 213, 251, 251, 660], [664, 664, 721, 721, 1137]], "test": "untested"}
{"id": "mt23WR", "name": "Slithering Worm 2", "author": "dr2", "description": "Worms on ice", "tags": ["snake", "motion", "reptation"], "likes": 15, "viewed": 212, "published": 3, "date": "1673168910", "time_retrieved": "2024-07-30T18:17:14.492664", "image_code": "// \"Slithering Worm 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, nCyc;\nconst float nSeg = 8.;\nint idObj;\nconst float pi = 3.1415927;\n\n#define NW 3\n\nstruct Arc {\n  vec2 cs, css;\n  float chDist, ang, rad, segRot, tCyc;\n};\nArc arc[NW];\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.45, 0.5);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1. - 1e-4) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid ArcConf ()\n{\n  float arcLen, arcEx, chLen, len, sep;\n  len = 2.;\n  sep = 1.;\n  arcEx = 1.;\n  for (int k = 0; k < NW; k ++) {\n    arcLen = arcEx * length (vec2 (len, sep));\n    chLen = length (vec2 (len * sin (0.5 * arc[k].segRot), sep));\n    arc[k].ang = SecSolve (chLen / arcLen);\n    arc[k].chDist = chLen / tan (arc[k].ang);\n    arc[k].rad = length (vec2 (arc[k].chDist, chLen));\n    arc[k].cs = sin (- arc[k].ang + vec2 (0.5 * pi, 0.));\n    arc[k].css = sin (- arc[k].ang - 0.002 + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  vec2 cs;\n  float dMin, d, tRad, tBmp, s, da, rr, nc;\n  int ig;\n  dMin = dstFar;\n  tRad = 0.5;\n  tBmp = 0.05;\n  pp = p;\n  for (int j = VAR_ZERO; j < NW; j ++) {\n    ig = 256 * (j + 1);\n    p = pp;\n    da = 63. / (2. * arc[j].ang);\n    nCyc = floor (tCur / arc[j].tCyc);\n    cs = sin (arc[j].ang * (1. - 2. * (tCur / arc[j].tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n    p.y -= tRad + tBmp;\n    nc = floor (nCyc / 2.);\n    s = sign (nCyc - 2. * nc - 0.5);\n    p.z -= 6. * float (j - 1);\n    rr = arc[j].rad * arc[j].cs.y;\n    p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n    p.yz = p.zy;\n    p.xy *= vec2 (-1., s);\n    for (float k = float (VAR_ZERO); k < nSeg; k ++) {\n      q = p;\n      q.y *= - sign (mod (k, 2.) - 0.5);\n      q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc[j].chDist);\n      d = dot (vec2 (abs (q.x), q.y), arc[j].css);\n      d = max (length (vec2 (length (q.xy) - arc[j].rad, q.z)) - tRad + tBmp * (1. -\n         smoothstep (0.1, 0.4, 0.5 - abs (0.5 -  mod (da * (atan (q.x, q.y) / (2. * pi)),\n         1.)))), d);\n      if (k == 0. || k == nSeg - 1.) d = max (d, - sign (k - 0.5) * dot (q.xy,\n         cs * vec2 (1., -1.)));\n      DMINQ (ig + 1);\n      if (k == 0. || k == nSeg - 1.) {\n        q.xy = Rot2Cs (q.xy, cs);\n        q.y -= arc[j].rad;\n        d = PrCapsDf (q.yzx, tRad + tBmp, 0.1);\n        DMINQ (ig + 2);\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat GrObjDf (vec2 pg)\n{\n  vec3 p, q, pp;\n  vec2 dkMin, cs;\n  float d, tRad, s, rr, nc, dk;\n  dk = 0.;\n  tRad = 0.5 - 0.15;\n  pp = p;\n  for (int j = VAR_ZERO; j < NW; j ++) {\n    dkMin = vec2 (dstFar, 0.);\n    p = pp;\n    nCyc = floor (tCur / arc[j].tCyc);\n    cs = sin (arc[j].ang * (1. - 2. * (tCur / arc[j].tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n    p.xz = pg;\n    p.y = 0.;\n    nc = floor (nCyc / 2.);\n    s = sign (nCyc - 2. * nc - 0.5);\n    p.z -= 6. * float (j - 1);\n    rr = arc[j].rad * arc[j].cs.y;\n    p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n    p.yz = p.zy;\n    p.xy *= vec2 (-1., s);\n    for (float k = float (VAR_ZERO) - 2. * nSeg; k < nSeg; k ++) {\n      q = p;\n      q.y *= - sign (mod (k, 2.) - 0.5);\n      q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc[j].chDist);\n      d = dot (vec2 (abs (q.x), q.y), arc[j].css);\n      d = max (length (vec2 (length (q.xy) - arc[j].rad, q.z)) - tRad, d);\n      if (k == -2. * nSeg || k == nSeg - 1.) d = max (d, - sign (k - 0.5) *\n         dot (q.xy, cs * vec2 (1., -1.)));\n      if (d < dkMin.x) dkMin = vec2 (d, k);\n      if (k == -2. * nSeg || k == nSeg - 1.) {\n        q.xy = Rot2Cs (q.xy, cs);\n        q.y -= arc[j].rad;\n        d = PrCapsDf (q.yzx, tRad, 0.1);\n        if (d < dkMin.x) dkMin = vec2 (d, k);\n      }\n    }\n    dk = max (dk, (1. + min (dkMin.y / nSeg, 0.) / 2.) * step (dkMin.x, 0.));\n  }\n  return dk;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.9);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hCol4, bCol4, sCol4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, nDotL, sh, s, f, a, r, t;\n  int ig, id;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    bCol4 = vec4 (0., 1., 0., 0.2);\n    hCol4 = vec4 (0.8, 0.5, 0., 0.2);\n    sCol4 = vec4 (1., 1., 1., 0.3);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ig = idObj / 256;\n    id = idObj - 256 * ig;\n    for (int j = 0; j < NW; j ++) {\n      if (j + 1 == ig) {\n        a = arc[j].ang;\n        r = arc[j].rad;\n        t = arc[j].tCyc;\n      }\n    }\n    if (id == 1) {\n      qHit.xy = Rot2Cs (qHit.xy, sin (a * (1. - 2. * (tCur / t - nCyc)) +\n         vec2 (0.5 * pi, 0.)));\n      s = abs (length (qHit.xy) - r);\n      f = Minv2 (Rot2D (0.5 - abs (0.5 - mod (4. * atan (qHit.xz, vec2 (qHit.y, s)) /\n         vec2 (a, pi), 1.)), 0.25 * pi));\n      col4 = mix (bCol4, hCol4, smoothstep (0., 0.03, f + 0.05));\n      if (qHit.z > 0.) col4 = mix (sCol4, col4, smoothstep (0., 0.03, s - 0.03));\n    } else if (id == 2) {\n      if (qHit.x > 0.) {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz,\n           vec2 (0., 0.13), 0.02)));\n      } else {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz -\n           vec2 (0., -0.2), vec2 (0.3, 0.), 0.02)));\n        col4 = mix (vec4 (1., 0., 0., -1.), col4, step (0.1,\n           length (vec2 (abs (qHit.y) - 0.2, qHit.z - 0.1))));\n      }\n      col4 = mix (hCol4, col4, smoothstep (0., 0.03, abs (abs (qHit.x) - 0.25) - 0.15));\n      if (qHit.z > 0. && abs (qHit.x) < 0.5) col4 = mix (sCol4, col4,\n         smoothstep (0., 0.03, abs (qHit.y) - 0.03));\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = mix (vec4 (0.97, 1., 0.97, 0.), vec4 (0.97, 0.97, 1., 0.), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n    s = GrObjDf (ro.xz);\n    col4.b *= 1. - 0.3 * s;\n    vn = VaryNf (0.5 * ro, vec3 (0., 1., 0.), 0.25 * (1. - smoothstep (0.6, 0.9,\n       dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) { \n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (dstObj < dstFar && id == 1) nDotL *= nDotL;\n      sh = (rd.y < 0.) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, vec3 (0.9), pow (1. + rd.y, 16.));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  }\n  if (dstGrnd < min (dstObj, dstFar)) col = mix (col, vec3 (0.2, 0.5, 0.9),\n     0.9 * pow (abs (dot (vn, rd)), 4.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.21 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.02 * pi * tCur;\n    el -= 0.15 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  arc[0].segRot = 0.45 * pi;\n  arc[0].tCyc = 3.22;\n  arc[1].segRot = 0.85 * pi;\n  arc[1].tCyc = 4.3;\n  arc[2].segRot = 0.7 * pi;\n  arc[2].tCyc = 4.01;\n  ArcConf ();\n  ro = vuMat * vec3 (0., 0., -50.);\n  ro.x -= arc[1].rad * arc[1].cs.y * (2. * tCur / arc[1].tCyc - (nSeg + 1.) / 2.) - 1.;\n  zmFac = 4.3 + 1.5 * el;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt23WR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[825, 825, 851, 879, 1275], [1277, 1277, 1294, 1294, 1795], [1797, 1797, 1819, 1819, 3209], [3211, 3211, 3236, 3236, 4598], [4600, 4600, 4633, 4633, 4881], [4883, 4883, 4904, 4904, 5159], [5161, 5161, 5198, 5198, 5427], [5429, 5429, 5463, 5463, 6210], [6212, 6212, 6247, 6247, 8958], [8960, 8960, 9016, 9016, 10369], [10371, 10371, 10418, 10418, 10465], [10467, 10467, 10510, 10510, 10574], [10576, 10576, 10598, 10598, 10625], [10627, 10627, 10663, 10663, 10869], [10871, 10871, 10901, 10901, 11014], [11016, 11016, 11047, 11047, 11111], [11145, 11145, 11169, 11169, 11222], [11224, 11224, 11248, 11248, 11360], [11362, 11362, 11387, 11387, 11533], [11535, 11535, 11560, 11560, 11746], [11748, 11748, 11770, 11770, 11924], [11926, 11926, 11947, 11947, 12102], [12104, 12104, 12133, 12133, 12345], [12347, 12347, 12386, 12386, 12643]], "test": "untested"}
{"id": "clj3Wz", "name": "Infinite Neurons", "author": "nsbalbi", "description": "Heavily adapted from Inigo Quilez (https://iquilezles.org/). Renamed some variables and added comments to improve readability and understanding", "tags": ["raymarching"], "likes": 9, "viewed": 332, "published": 3, "date": "1673143347", "time_retrieved": "2024-07-30T18:17:15.394253", "image_code": "\nconst float D_MAX = 30.0;  // max marching distance\n\n#define PI 3.1416\n#define AA 1  // number of anti-aliasing passes\n\n// SDF Transforms\n\nfloat intersectSDF(float distA, float distB) {\n  return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n  return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n  return max(distA, -distB);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// SDFs\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sceneSDFnoRep(vec3 samplePoint) {    \n  //return sdBox(samplePoint, vec3(0.05, 0.05, 0.5));\n  float smallEdge = 0.01;\n  float s1 = sdBox(samplePoint, vec3(smallEdge, smallEdge, 0.25));\n  float s2 = sdBox(samplePoint, vec3(0.25, smallEdge, smallEdge));\n  float s3 = sdBox(samplePoint, vec3(smallEdge, 0.25, smallEdge));\n  float s123 = unionSDF(s1, unionSDF(s2, s3));\n  float s4 = sdOctahedron(samplePoint, 0.09);\n  // float s4 = sdSphere(samplePoint, 0.2);\n\n  return opSmoothUnion(s123, s4, 0.03);\n}\n\n// Repeat SDF infinitely\n// c is ~size of repeated unit\nfloat opRep( in vec3 p, in vec3 c){\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sceneSDFnoRep( q );\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 samplePoint) {    \n  return opRep(samplePoint, vec3(0.5));\n}\n\n// Calculates surface normal\nvec3 calcNormal( in vec3 pos ) {\n  vec2 e = vec2(1.0,-1.0)*0.5773;\n  const float eps = 0.0005;  // small increment epsilon\n  return normalize( e.xyy*sceneSDF( pos + e.xyy*eps ) + \n          e.yyx*sceneSDF( pos + e.yyx*eps ) + \n          e.yxy*sceneSDF( pos + e.yxy*eps ) + \n          e.xxx*sceneSDF( pos + e.xxx*eps ) );\n}\n\n// Apply fog\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float dist,     // camera to point distance\n               in float distFactor) {\n  float fogAmount = 1.0 - exp( -dist * distFactor );\n  vec3  fogColor  = vec3(0.0, 0.0, 0.0);\n  return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // camera movement\t\n\t// float angle = 0.25 * PI * iTime + 0.75 * PI;\n\t// vec3 eye = vec3( 1.2*cos(angle), 0.4, 1.2*sin(angle) );\n  // vec3 center = vec3( 0.0, 0.0, 0.0 );\n\tvec3 eye = vec3( 1.0 - iTime, 0.25, -0.25 + iTime );\n  vec3 center = vec3( 0.0  - iTime, 0.25, 0.75  + iTime );\n  // camera matrix\n  vec3 ww = normalize( center - eye );  // vect from center to eye\n  vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );  // cross with up\n  vec3 vv = normalize( cross(uu, ww) );\n\n  vec3 tot = vec3(0.0);\n  \n  #if AA>1  // anti-aliasing passes\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;  // offset for anti-aliasing passes\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+offset))/iResolution.y;\n    #else    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    #endif\n\n    // create view ray\n    vec3 ray = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float dTot = 0.0;\n    for( int i=0; i<256; i++ ) {\n      vec3 pos = eye + dTot*ray;\n      float d = sceneSDF(pos);\n      if( d < 0.0001 || dTot > D_MAX ) break;\n      dTot += d;\n    }\n    \n    // shading/lighting\t\n    vec3 color = vec3(0.0);\n    if( dTot < D_MAX ) {\n      vec3 pos = eye + dTot * ray;  // position of point on surface\n      vec3 normal = calcNormal(pos);  // surface normal\n      float diffuse = clamp( dot(normal, vec3(0.5)), 0.0, 1.0 );\n      float ambient = 0.5 + 0.5 * dot(normal, vec3(0.0,1.0,0.0));\n      //color = vec3(0.7, 0.7, 0.7) * ambient + vec3(3.0/255.0, 44.0/255.0, 252.0/255.0) * diffuse;\n      color = vec3(3.0/255.0, 44.0/255.0, 252.0/255.0) * ambient + vec3(0.7, 0.7, 0.7) * diffuse;\n\n      color = applyFog(color, dTot, 0.3);\n    }\n\n    // gamma        \n    color = sqrt( color );\n    tot += color;\n    #if AA>1\n  }\n  tot /= float(AA*AA);  // take mean if multiple anti-aliasing passes\n  #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clj3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 186, 186, 216], [218, 218, 260, 260, 290], [292, 292, 339, 339, 370], [372, 372, 424, 424, 524], [535, 535, 566, 566, 653], [655, 655, 693, 693, 746], [748, 748, 783, 783, 807], [809, 809, 848, 906, 1313], [1315, 1371, 1406, 1406, 1470], [1472, 1485, 1519, 1519, 1565], [1567, 1596, 1628, 1628, 1918], [1920, 1933, 2098, 2098, 2236]], "test": "untested"}
{"id": "Dt2GDR", "name": "Envirocube", "author": "orblivius", "description": "Just a simple example (combination of two different shaders) of how to render into cubemap for environment mapping. It is music activated too!", "tags": ["sound", "audio", "cubemap", "starfield", "environmentmapping"], "likes": 7, "viewed": 271, "published": 3, "date": "1673136295", "time_retrieved": "2024-07-30T18:17:16.441453", "image_code": "// Main shader\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n/////////////////\n\n\n#define PI 3.14159\n#define TYPE_CUBE 1\n#define TYPE_SPHERE 2\n#define OBJECT_COUNT 1\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\n\n\nstruct Object\n{\n\tmat3 rot;\n    vec3 pos;\n    vec3 size;\n    int type;\n};\n\nObject objects[OBJECT_COUNT];\n\n\nfloat dist(vec3 position)\n{\n    float m = 9999.0;\n    vec4 audio = texture(iChannel0, vec2(0.0, 0.0));\n    vec2 uv = vec2(position.x, position.y) * 1.0;\n    vec4 col = texture(iChannel0, uv).rgba;\n    \n    Object o = objects[0];\n    vec3 p = position + o.pos;\n\n    p = p * o.rot;\n    float f = 0.0;\n\n\n    float a = sdBox(p, o.size);\n    float b = sdSphere(p, o.size.x);\n    float au = audio.x;\n\n    f = au * a + (1.0 - au) * b;\n    f -= sdSphere(p, o.size.x) * (0.3 + au * 0.4);\n\n    m = min(f, m);\n    return m;\n}\n\n    \n\nfloat toClipSpace(float f)\n{\n    return f * 2.0 - 1.0;\n}\n\n\nvec3 lookAt(vec3 from, vec3 to, vec3 dir)\n{\n    mat3 m;\n    \n    vec3 fwd = normalize(to - from);\n    vec3 _up = vec3(0.0, 1.0, 0.0);\n    vec3 r = cross(fwd, _up);\n    vec3 u = cross(r, fwd);\n    \n    m[0] = r;\n    m[1] = u;\n    m[2] = fwd;\n    vec3 d = m * dir;    \n    d.z *= -1.0;\n    return d;\n}\n\n\n\nbool trace(vec3 from, vec3 dir, out vec3 hitPosition, out float m)\n{\n    \n    const int steps = 95;\n    float step = 0.01;    \n    vec3 rp = from;\n    m = 99999.0;\n    \n    for (int i = 0; i < steps; ++i)\n    {\n    \trp += dir * max(step, 0.002);\n        float sp = dist(rp);\n        step  = sp;\n        m = min(m, abs(sp));\n        if (abs(sp) <= 0.001)\n        {\n            hitPosition = rp;\n            return true;\n        }\n        \n        if(rp.z > 1.0)\n        {\n            return false;\n        }\n        \n    }\n    return false;\n}\n\n\n\n\nObject getObject(vec3 position, int type)\n{\n    Object c;\n    c.pos = position;\n    c.rot = mat3(1.0);\n    c.type = type;\n    c.size = vec3(0.1, 0.1, 0.1);\n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.x);\n    uv.y += (iResolution.y / iResolution.x) * 0.4;\n    \n    vec2 mouse = iMouse.xy;\n    vec4 audio = texture(iChannel0, vec2(1.0, 0.0));\n    \n    objects[0] = getObject(vec3(0.0), TYPE_CUBE);\n    objects[0].rot = rotx( ((mouse.y  / iResolution.y) - 0.5) * 12.0);\n    objects[0].rot *= roty( ((mouse.x  / iResolution.x) - 0.5) * 12.0);\n    objects[0].size = vec3(0.1, 0.1, 0.1);\n    \n    objects[0].rot *= rotx(iTime * 1.5);\n    objects[0].rot *= roty(sin(iTime * 1.5));\n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0);    \n    vec3 lk = vec3(-toClipSpace(uv.x), -toClipSpace(uv.y), -2.0);\n    vec3 mclip = vec3(0.0);\n    vec3 dir = lookAt(camPos, mclip, normalize(lk));\n    vec3 hit = vec3(0.0);\n    vec4 color = vec4(0.0);\n    \n    float m;\n    bool h = trace(camPos, dir, hit, m);\n    vec4 aColor = vec4(1.0);\n\n\tfloat p =  pow(length(uv - vec2(0.5, 0.5)), 3.0);\n\tif(h)\n    {\n\t    vec2 offset = vec2(0.001, 0.0);\n        vec3 grad = normalize(vec3(dist(hit + offset.xyy) - dist(hit - offset.xyy), \n                                   dist(hit + offset.yxy) - dist(hit - offset.yxy),\n                                   dist(hit + offset.yyx) - dist(hit - offset.yyx)));\n        \n       float d = clamp(dot(grad, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n       float rim = (1.0 - d) * 1.4;        \n       color += texture(iChannel1, -grad);\n    \n    } else\n    {\n        vec2 uv2 = 1.5 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n        vec3 dir = vec3(1.0, uv2.y, uv2.x);\n\n        color = texture(iChannel1, dir);\n    }\n    \n    \n    float d = (1.0 - m * 75.0) * 15.0 * p;\n    color += aColor * pow(clamp(d, 0.0, 1.0), 1.3);\n    \n    fragColor = color;\n    \n}\n", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Shader A (cubemap) \n\n#define PI 3.14159265358979323846\n#define TIMER(sec, min, max) (((mod(iTime, (sec)) * ((max) - (min))) / (sec)) + (min))\n\nmat2 mm2(in float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n     vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n        \n    vec3 color = vec3(0.);\n    \n    vec3 ray = vec3(uv, .75);\n    ray.xy *= mm2(TIMER(15. ,0., -PI*2.));\n    vec3 s = ray/max(abs(ray.x), abs(ray.y))*.4;\n\n    vec3 p = s;\n    for(int i=0; i<5; i++) {\n        vec2 nos1 = vec2(floor(p.xy*30.334) );\n        const vec2 nos2 = vec2(12.9898, 78.233);\n        const float nos3 = 43758.5453;\n\n        vec3 nc = vec3( fract(sin(dot(nos1, nos2))*nos3), fract(sin(dot(nos1, nos2*.5))*nos3), fract(sin(dot(nos1, nos2*.25))*nos3) );\n        float n = fract(sin(dot(nos1, nos2*2.) )*nos3);       \n        float z = fract(cos(n)-sin(n)-iTime*.2);\n     \n        float d = (1.-abs(30.*z-p.z) );\n\n        float sz = 1./s.z;\n        vec3 c = vec3(sin( max(0., d*(sz*nc.r)) ), sin( max(0., d*(sz*nc.g)) ), sin( max(0., d*(sz*nc.b)) ) );\n\n        color += (1.-z)*c;\n        p += s;\n    }    \n    vec3 c = max(vec3(0.), min(vec3(1.), color));\n    \n    fragColor = vec4(c ,1.0);\n    \n    \n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2GDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 51, 51, 75], [77, 77, 110, 110, 175], [177, 177, 208, 208, 246], [248, 248, 284, 284, 368], [370, 370, 415, 415, 455], [457, 457, 498, 498, 569], [571, 571, 602, 602, 698], [806, 806, 826, 826, 953], [954, 954, 974, 974, 1101], [1211, 1211, 1238, 1238, 1725], [1733, 1733, 1761, 1761, 1789], [1792, 1792, 1835, 1835, 2091], [2095, 2095, 2163, 2163, 2636], [2641, 2641, 2684, 2684, 2812], [2816, 2816, 2873, 2873, 4612]], "test": "untested"}
{"id": "mlB3Dz", "name": "morphing spheres 3 ", "author": "jonasfrey", "description": "morphing\n", "tags": ["morphing"], "likes": 4, "viewed": 159, "published": 3, "date": "1673129251", "time_retrieved": "2024-07-30T18:17:17.310131", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset*=2.5;\n\n    float n_its = 50.;\n    float n_tau = 6.2831;\n    float n_dist_prod = 1.;\n    float n_dist_prod2 = 1.;\n    float n_dist_min = 1.;\n    float n_it_nor_dmin = 0.;\n    for(float n_it = 0.; n_it< n_its; n_it+=1.){\n        float n_it_nor = n_it/ n_its;\n        float n_radius = cos(iTime+n_it_nor*n_tau*2.);\n        float n_ang_nor = n_tau * n_it_nor;\n        vec2 o_p = vec2(\n            sin(n_ang_nor)*n_radius,\n            cos(n_ang_nor)*n_radius\n        );\n        float n_dist = length(o_trn_fc_nor_offset - o_p);\n        if(n_dist < n_dist_min){\n            n_it_nor_dmin = n_it_nor;\n        }\n        n_dist_prod *= n_dist;\n        n_dist_prod2 *= pow(n_dist, 1./10.);\n\n        n_dist_min = min(n_dist_min, n_dist);\n    }\n\n    float n_aa = n_ratio_1to_iresx*200.;\n    float n_th = 0.5;\n    float nds = smoothstep(n_th, n_th+n_aa, n_dist_prod);\n    fragColor = vec4(1.-n_dist_prod2);\n    \n    if(o_trn_fc_nor.y > (1./3.)*1.){\n        vec4 o_col = vec4(n_it_nor_dmin, 0.,0.,1.);\n        fragColor = vec4(o_col*(1.-nds));\n    }\n    if(o_trn_fc_nor.y > (1./3.)*2.){\n        fragColor = vec4(1.-n_dist_min);\n    }\n    if(o_trn_fc_nor.y > (1./3.)*3.){\n        fragColor = vec4(1.-n_dist_prod);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 1719]], "test": "untested"}
{"id": "mtlGDn", "name": "Sincos Terrain", "author": "Kris_Katur", "description": "Studies in (pseudorandom) terrains with sine and cosine functions.", "tags": ["raymarching", "terrain", "sine", "cosine"], "likes": 9, "viewed": 185, "published": 3, "date": "1673129220", "time_retrieved": "2024-07-30T18:17:18.081070", "image_code": "// \"Sincos Terrain\"\n// 2023\n// by KΛTUR\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define TAU 6.283185\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n////////  TERRAIN  ///////\n\nfloat map(vec3 p) {\n    \n    // basic shaping of plane\n    p.y -= smoothstep(5.,30.,abs(p.z))*3.;\n    p.y -= smoothstep(5.,30.,abs(p.x))*3.;\n    \n    // actual plane\n    float d = p.y;\n    \n    // sin cos madness\n    d += sin(p.x*.3)*2.9 * sin(p.z*.33+iTime*.3)*1.7 * sin(p.z*.45)*.31 +\n         cos(p.x*.2)*0.7 * cos(p.z*.21)*0.91 * cos(p.x*.71)*.8 +\n         sin(p.z*.51)*0.43 + sin(p.z*.31) * sin(p.x*.21);\n         \n    return d;\n}\n\n// RAYMARCHER\nfloat CastRay(vec3 ro, vec3 rd) {\n\tfloat t=0.;\n    float h=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*t;\n        h = map(p);\n        t += h;\n        if(t>MAX_DIST || abs(h)<SURF_DIST) break;\n    }\n    return t;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = map(p) - \n    vec3(map(p-e.xyy), map(p-e.yxy),map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, 5);\n    ro.xz *= Rot(-m.x*TAU+sin(iTime*.1));\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n\n    vec3 col = vec3(0);\n    vec3 bg_col = mix(col,vec3(.2,.3,.9),uv.y*uv.y*uv.y); //bg color fade\n    \n    float d = CastRay(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        col *= fract(p.x+sin(p.z*2.+iTime*2.)); //texture\n        col *= clamp(.03,1.,smoothstep(-2.,1.,p.y)); //darken \"valleys\"\n        col += max(0.,p.y)*.3; //brighter hilltops\n        col *= n * vec3(1.,.3,.5)*3.; //coloring\n    }\n    \n    col = mix(col, bg_col, 1.0 - exp2(-0.002 * d*d)); //bg color & fog\n    col = pow(col, vec3(.4545));  // gamma correction \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32107, "src": "https://soundcloud.com/french79music/03-between-the-buttons?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[219, 219, 238, 238, 300], [330, 330, 349, 384, 765], [767, 781, 814, 814, 1018], [1020, 1020, 1044, 1044, 1178], [1180, 1180, 1230, 1230, 1415], [1417, 1417, 1474, 1474, 2440]], "test": "untested"}
{"id": "mtBGDz", "name": "morphing spheres2", "author": "jonasfrey", "description": "spheres\ninspired by: https://www.shadertoy.com/view/dlB3DR", "tags": ["morphing"], "likes": 1, "viewed": 172, "published": 3, "date": "1673125675", "time_retrieved": "2024-07-30T18:17:18.907859", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset*=5.;\n\n    float n_its = floor(mod((iTime)*0.25, 9.))+1.;\n    float n_tau = 6.2831;\n    float n_radius = cos(iTime);\n    float n_dist_prod = 1.;\n    float n_dist_min = 1.;\n    for(float n_it = 0.; n_it< n_its; n_it+=1.){\n        float n_it_nor = n_it/ n_its;\n        float n_ang_nor = n_tau * n_it_nor;\n        vec2 o_p = vec2(\n            sin(n_ang_nor)*n_radius,\n            cos(n_ang_nor)*n_radius\n        );\n        float n_dist = length(o_trn_fc_nor_offset - o_p);\n        \n        n_dist_prod *= n_dist;\n        n_dist_min = min(n_dist_min, n_dist);\n    }\n\n    float n_aa = n_ratio_1to_iresx*50.;\n    float n_th = 0.5;\n    float nds = smoothstep(n_th, n_th+n_aa, n_dist_prod);\n    fragColor = vec4(nds);\n    \n    if(o_trn_fc_nor_offset.y > 0.){\n        fragColor = vec4(n_dist_prod);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 1310]], "test": "untested"}
{"id": "dtS3Wz", "name": "Potentially random", "author": "zommuter", "description": "Just some swirling electric charges and the resulting potential field on a logarithmic-ish scale. Now with mouse controls randomizing everything - hold left and move around until you find something you like.", "tags": ["potential", "electric", "charge"], "likes": 3, "viewed": 177, "published": 3, "date": "1673122219", "time_retrieved": "2024-07-30T18:17:19.737640", "image_code": "// CC-BY-NC-SA\n//#define N_CHARGES (1.+(iMouse.x/iResolution.x-0.5))*137.\n#define SEED -3.14159 - (2.3+iMouse.x*iMouse.y) / iResolution.x / iResolution.y\n#define SPEED 0.75\n\nfloat N21(vec2 p, float offset) {  // shamelessly taken from https://www.shadertoy.com/view/lscczl, CC-BY-NC-SA\n\tvec3 a = fract(vec3(p.xyx) * (vec3(213.897, 653.453, 253.098) + offset));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\n\nvec2 N22(vec2 p) {  // forgot the definition in the video, but I guess this one's okay\n    return vec2(N21(p, 32.), N21(p, -314.159));\n}\n\nvec2 N12(float seed) {\n    return N22(vec2(seed));\n}\n\nfloat N11(float seed) {  // yes, yes, I know, horribly inefficient, sue me\n    return N21(vec2(seed, 1./seed), seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N_CHARGES = 5.+N21(vec2(iMouse.x+1., iMouse.y+1.), SEED-1251.23)*137.;\n    vec2 uv_ar = fragCoord/iResolution.y;  // aspect ratio 1:1, but x > 1 possible\n    float aspect = iResolution.x/iResolution.y;\n    \n    float potential = 0.;    \n    for(float n_charge=0.; n_charge < N_CHARGES; n_charge++) {\n        float x_omega_charge = N11(n_charge + SEED + N_CHARGES + 1./137.);\n        float y_omega_charge = N11(n_charge - SEED + N_CHARGES - 1./137.);\n        float t = SPEED * iTime + N11(SEED-1.);\n        vec2 uv_charge = 0.5*vec2(sin(x_omega_charge*t), cos(y_omega_charge*t))+.5;\n        float charge = (N11(n_charge + SEED - N_CHARGES)-.5)*1e2;\n        float r = max(.0005 * abs(charge), length(uv_ar - uv_charge*vec2(aspect, 1.)));\n        potential += charge/r;\n    }\n\n    // TODO tidy up this mess...\n    float l2 = log(1. + abs(potential)/100.)/4.;\n    float l1 = -sign(potential) * l2;\n    float l3 = sign(potential) * l2;\n    float l4 = length(uv_ar-.5)/2.;\n    float r1 = N11(SEED-272154.);\n    float r2 = N11(SEED-1231.);\n    float r3 = N11(SEED+12454.);\n    float r4 = N11(SEED+r3-r1*r2);\n    float r = (r1*l1 + r2*l2 + r3*l3 + r4*l4)/(r1+r2+r3+r4);\n    float g1 = N11(SEED-r1);\n    float g2 = N11(SEED-r2);\n    float g3 = N11(SEED+r3);\n    float g4 = N11(SEED+g3-g1*g2);\n    float g = (g1*l1 + g2*l2 + g3*l3 + g4*l4)/(g1+g2+g3+g4);\n    float b1 = N11(SEED-g1);\n    float b2 = N11(SEED-g3);\n    float b3 = N11(SEED+g2);\n    float b4 = N11(SEED+b3-b1*b2);\n    float b = (b1*l1 + b2*l2 + b3*l3 + b4*l4)/(b1+b2+b3+b4);\n    vec3 col = vec3(r, g, b)*2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3Wz.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[174, 174, 207, 285, 431], [434, 434, 452, 520, 570], [572, 572, 594, 594, 624], [626, 626, 649, 700, 745], [747, 747, 804, 804, 2413]], "test": "untested"}
{"id": "dlBGWz", "name": "Blue Tentacles", "author": "ManuManu", "description": "alteration from this one :\nhttps://www.shadertoy.com/view/lt2GDy", "tags": ["raymarching"], "likes": 15, "viewed": 252, "published": 3, "date": "1673118176", "time_retrieved": "2024-07-30T18:17:20.625267", "image_code": "\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n// Ok, I must confess it : it was totally out of control\n// I made this from testing something from this demo http://glslsandbox.com/e#25403.2 and it's parent here http://glslsandbox.com/e#25400.0\n\n// I didn't expect that, but it's really gorgious ( IMHO )\n\n\n// Note : I can't save with such a value :(\n//#define MAX_STEP 100\n//#define PRECISION .001\n#define MAX_STEP 200\n#define PRECISION .1\n\n\nvec3 pin(vec3 v)\n{\n\tvec3 q = vec3(0.0);\n\t\n\tq.x = sin(v.x)*0.5+0.5;\n\tq.y = sin(v.y+1.0471975511965977461542144610932)*0.5+0.5;\n\tq.z = sin(v.z+4.1887902047863909846168473723972)*0.5+0.5;\n\t\n\treturn normalize(q);\n}\n\nvec3 spin(vec3 v)\n{\n\tfor(int i = 0; i <3; i++)\n\t{\n\t\tv=pin(v.yzx*6.283185307179586476925286766559);\n\t}\n\treturn v.zxy;\n\n}\nfloat map(vec3 p) {\n\tvec3 val = spin(p);\n\tfloat k = val.x + val.y + val.z;\n\treturn (cos(p.x) + cos(p.y*0.75) + sin(p.z)*0.25)+k*1.2;\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv  = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y ;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.zy = rot(dir.zy, iTime * 0.2);\n\tdir.xz = rot(dir.xz, iTime * 0.1); dir = dir.yzx;\n\n\tvec3 pos = vec3(0, 0, iTime * 2.0);\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < MAX_STEP; i++) {\n\t\tfloat temp = map(pos + dir * t) * 0.55;\n\t\tif(temp < PRECISION) break;\n\t\tt += temp;\n\t\tdir.xy=rot(dir.xy,temp*0.05);\n\t\tdir.yz=rot(dir.yz,temp*0.01);\n\t\tdir.zx=rot(dir.zx,temp*0.09);\n\t}\n\tvec3 ip = pos + dir * t;\n    vec3 baseColor = vec3( 0.1,0.2,0.9);\n\tfragColor = vec4(vec3(max(0.01, map(ip + 0.2)) + t * 0.12) * baseColor + 0.35*(dir*spin(ip)), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 482, 482, 674], [676, 676, 695, 695, 795], [796, 796, 815, 815, 930], [932, 932, 959, 959, 1038], [1040, 1040, 1097, 1097, 1772]], "test": "untested"}
{"id": "dtB3DR", "name": "smoothstep init circle shader", "author": "hideodaikoku", "description": "A simple shader demonstrating a circle being drawn while simltaneously being passed through a rotation matrix and a smoothstep function. ", "tags": ["circle", "smoothstep", "rotation", "simpleshapes", "cineshader"], "likes": 2, "viewed": 1661, "published": 3, "date": "1673114711", "time_retrieved": "2024-07-30T18:17:21.382243", "image_code": "#define UV_ORIGIN 0.5\n#define ZOOM 1.0\n#define SPEED 10.0\n\nconst float PI = 3.14;\n\n// rotation function\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.8;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // reset uv to 0.5 to get center and normalize\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // radian based rotation matrix fo zoom\n    uv *= rotationMatrix( SPEED * iTime ) * ZOOM;\n    \n    float d = length(uv);\n    \n    // modulate smoothstep to get trippy effect\n    float c = smoothstep(r+cos(iTime),r-sin(iTime),d);\n    \n    \n    // Output to screen\n    //fragColor = vec4(c+cos(c+iTime)/uv.y, c/sin(uv.y+iTime)-0.5,c-sin(uv.y-iTime)/uv.y, 0.5);\n    fragColor = vec4(c-cos(c+iTime)*uv.x-0.5, c-c/sin(uv.x+iTime)-0.5, c,sin(uv.x));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtB3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 104, 138, 138, 232], [235, 235, 292, 292, 986]], "test": "untested"}
{"id": "mtS3DR", "name": "Randomized H-Curves", "author": "mla", "description": "Place a tile at points with even coordinates. Then join up into H-shaped blocks, with randomized alignment ('a' for fixed alignment) - the tiled boundary is a space-filling curve.", "tags": ["spacefilling", "hcurve"], "likes": 18, "viewed": 315, "published": 3, "date": "1673114036", "time_retrieved": "2024-07-30T18:17:22.134232", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// Randomized H-curves, mla 2023.\n//\n// Inspired by https://www.shadertoy.com/view/mlS3Rm by MartyMcFly\n// but a completely different tiling based method. See references\n// therein for more details.\n//\n// 'a': fixed alignment of H's\n// 'b': 'alternating' alignment\n// 'c': no fill colour\n// 'x': progressive scale\n// 'y': progressive fill\n// 'z': zoom in one level\n//\n//////////////////////////////////////////////////////////////////////\n\nint N = 63;       // Work with NxN array of tiles\nint maxdepth = 1024; // Maximum depth of joining\n\nint bbit(int n) {\n  // Result has a 1-bit at position of rightmost zero in n\n  // ..xxx0111.. -> ..XXX1000.. & ..xxx1000.. -> ..0001000..\n  return ~n & (n+1);\n}\n\nint check(ivec2 p) {\n  int x = p.x, y = p.y;\n  // Is the joiner block at (x,y) horizontal or vertical?\n  // Return 0 for horizontal, 1 for vertical\n  if (key(CHAR_B)) {\n    // Alternate at each level - experimental\n    int bb = bbit(x);\n    assert(bb == bbit(y));\n    int res = 1;\n    while (bb != 0) { res = 1-res; bb >>= 1; } // use popcnt!\n    return res;\n  }\n  if (key(CHAR_A)) return 0;\n  uint h = ihash(uint(x)^ihash(uint(y)^uint(iTime)));\n  return int(h&1u);\n}\n\nint ttype(ivec2 ix) {\n  // Get tile type at index ix, there are tiles at all even coordinates.\n  // (2a,2b), then tiles are joined together by \"joiner blocks\" at\n  // (2a,2b+1),(2a+1,2b+1),(2a+2,2b+1) (or same with x,y flipped).\n  // The central tile of a joiner block has the same number of trailing\n  // 1s in the x and y coordinate (ie. bbit(x) == bbit(y)).\n  // check(x,y) says if the joiner block centred on (x,y) is\n  // horizontal or vertical.\n  int x = ix.x, y = ix.y;\n  if (x < 0 || y < 0) return 0;\n  if (x >= N || y >= N) return 0;\n  int bbx = bbit(x), bby = bbit(y);\n  if (bbx == bby && (bbx == 1 || bbx < maxdepth)) return 1;\n  int blocktype = -1; ivec2 block;\n  if (bby > 1 && bby < maxdepth) {\n    int bbx0 = bbit(x-1), bbx1 = bbit(x+1);\n    if (bbx0 == bby) { blocktype = 0; block = ivec2(x-1,y); }\n    if (bbx1 == bby) { blocktype = 0; block = ivec2(x+1,y); }\n  }\n  if (bbx > 1 && bbx < maxdepth) {\n    int bby0 = bbit(y-1), bby1 = bbit(y+1);\n    if (bbx == bby0) { blocktype = 1; block = ivec2(x,y-1); }\n    if (bbx == bby1) { blocktype = 1; block = ivec2(x,y+1); }\n  }\n  if (blocktype < 0) return 0;\n  return int(check(block) == blocktype);\n}\n  \nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  if (key(CHAR_X)) N = (1<<(int(mod(iTime,8.0)+1.0)))-1;\n  if (key(CHAR_Y)) maxdepth = 1<<int(mod(iTime,8.0));\n  if (key(CHAR_Z)) N = 2*N+1;\n  float lwidth = 0.02;\n  vec2 p = 1.05*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p += 1.0;\n  p *= 0.5*float(N);\n  float px = fwidth(p.x);\n  vec3 col = vec3(0.8);\n  if (min(p.x,p.y) > -0.5 && max(p.x,p.y) < float(N)+0.5) {\n    ivec2 ix = ivec2(floor(p));\n    p = fract(p);\n    int tt = ttype(ix);\n    // Now find adjacent tile type\n    float dx0 = p.x, dx1 = 1.0-p.x;\n    float dy0 = p.y, dy1 = 1.0-p.y;\n    float d = min(min(dx0,dx1),min(dy0,dy1));\n    ivec2 delta;\n    if (d == dx0) delta = ivec2(-1,0);\n    if (d == dx1) delta = ivec2(1,0);\n    if (d == dy0) delta = ivec2(0,-1);\n    if (d == dy1) delta = ivec2(0,1);\n    int tt1 = ttype(ix+delta);\n    if (!key(CHAR_C) && tt != 0) col = vec3(1,1,0.1);\n    p = min(p,1.0-p);\n    if (tt != tt1) {\n      col *= smoothstep(0.0,px,min(p.x,p.y)-lwidth);\n    }\n    col *= smoothstep(0.0,px,length(p)-1.4*lwidth);\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtS3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[614, 614, 631, 751, 774], [776, 776, 796, 796, 1243], [1245, 1245, 1266, 1695, 2406]], "test": "untested"}
{"id": "mtSGzm", "name": "infinite canvas / endless paper", "author": "FabriceNeyret2", "description": "Toy implementation of endlesspaper.app, used by [url]https://twitter.com/vaskange[/url] , with pre-stored stroke shapes.\nup/down key to zoom canvas\nmouse to displace canvas\nSPACE to show LOD = raster cache ", "tags": ["zoom", "lod", "paint", "draw", "canvas"], "likes": 4, "viewed": 252, "published": 3, "date": "1673110504", "time_retrieved": "2024-07-30T18:17:22.892206", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O *= 0.;\n//  O = T(u); return;                                      // debug\n \n    if ( length(iMouse.xy) > 10. ) u += iMouse.xy - R/2.;  // canvas offset : mouse\n    u -= R/2.;\n    u *= exp2( .01* T(vec2(0,0)).a );                         // canvas move : up/down keys\n    u += R/2.; \n    u = clamp(u,vec2(0),R);\n    \n    vec2 U =   u / R, F, A;\n         F = ( u - .5*R ) / R.y;                           // for local vector drawing\n    \n#if 1\n\n    int i = min(4, int( - log2( 1. + .003*T(vec2(0,0)).a ))) - 1, // LOD level where we use raster cache\n        k;                                                 // rather than drawing everything \n    for ( k = -1; k < i; k++ )                             // --- draw vector objects down to i\n        O = blend( O, draw(F,float(k)) ),\n        U = clamp( 2.*fract(U)- pos[min(k+1,3)], 0.,1.),\n        F = ( U - .5 ) *R/R.y;\n    O = blend(O, node(i) );                                // last: draw object + raster cache\n    A = 2.*fract(U)- pos[min(i+1,3)];\n    if ( keyToggle(32) && i < 3 && A == clamp(A,0.,1.) ) O += (1.-O.a)*.2;\n\n#else\n\n    O = node(-1);  // largest object always drawn as vector ( never cached ).\n    \n#endif\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 pos[] = vec2[]( vec2(.5,.3), vec2(.3,.8), vec2(.8,.5), vec2(.3,.1) ); // offsets objects -1 ... 3 \n\n#define R             iResolution.xy\n#define T(U)          texelFetch( iChannel0, ivec2(U), 0 )\n#define keyDown(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hue(v)        vec4( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) , 1 )\n\n#define blend(Cb,Cf) ( Cf + (1.-(Cf).a) * (Cb) )\n\n                   // draw object i in the scene graph,  U ~ local bbox \n#define draw(U,i)     smoothstep( 1.5*fwidth(length(U)), 0., abs( length(U) - .3 -.01*sin(30.*atan(U.y,U.x))  ) -.01 ) * hue( i/4. )\n\n                   // seek for cached image of object i at LOD i , placed around pos[i]\n#define fetch(i)      ( i > 3 ? vec4(0) \\\n                      : texture(iChannel0, .5* ( clamp( 2.*fract(U)- pos[min(i,3)], 0.,1.)  ) + .5*vec2((i)%2,(i)/2) ) )\n\n                   // compose the vector object i at LOD i with the cached objects of LOD i+1\n#define node(i)       blend( draw(F,float(i)), fetch(i+1) )\n\n                   // \"object\" should be the local group of strokes painted at a given region at a given LOD\n", "buffer_a_code": "// === compute the cache of LOD & objects within the scene graph\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    if (u==vec2(.5)) O.a += float(keyDown(40)) - float(keyDown(38)); // top/down arrow keys control zoom.\n    \n    if ( iFrame > 3 ) return;\n    \n    vec2 U = 2.*u/R,                // memory adressing for 4 cache slots. Each slot adressing = fract(U).\n         F = (fract(U)-.5)*R/R.y;   // local coords for local vector drawing\n    int i = int(U) + 2*int(U.y);    // cache slot id. ( deepest = top right, largest = bottom left ) \n    \n    // Each quadrant tile is a cache containing a raster LOD of the lower-scale screen: \n    // Draw local vector object + local background\n    \n    if ( iFrame == 0 && i==3 ) O = node(3); \n    if ( iFrame == 1 && i==2 ) O = node(2);\n    if ( iFrame == 2 && i==1 ) O = node(1);\n    if ( iFrame == 3 && i==0 ) O = node(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1221]], "test": "untested"}
{"id": "ctS3Dz", "name": "Rain (Sound)", "author": "MysteryPancake", "description": "Distorting noise gets a somewhat rain-like sound :) Click to show rain matte", "tags": ["sound", "simulation", "glass", "lod", "rain", "drop", "lightning", "buffer", "window", "drops", "raining", "gpusound", "sfx"], "likes": 12, "viewed": 452, "published": 3, "date": "1673102365", "time_retrieved": "2024-07-30T18:17:23.732958", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Read blur amount from buffer\n    float blur = texture(iChannel1, uv).r;\n    \n    // Use LOD levels to blur texture\n    vec4 tex = textureLod(iChannel0, uv, 7.0 - blur * 6.0);\n    \n    // Add lightning\n    tex += exp(mod(iTime - 1.0, 6.0) * -5.0) * (sin(iTime * 36.0) * 0.2 + 0.2);\n    \n    // Click to show rain matte\n    fragColor = iMouse.z > 0.0 ? vec4(blur) : tex * tex;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "const float TAU = 6.28318530;\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash(float(si)), hash(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float Q) {\n    return sin(TAU * freq * fract(time)) * noise(time * Q);\n}\n\n// Works like Waveshaper in FL Studio\nfloat distort(float x, float time) {\n    // Curved distortion, more bass\n    float a = smoothstep(0.2, 1.0, abs(x));\n    // Straight distortion, more treble\n    float b = clamp((abs(x) - 0.6) * 1.5, 0.0, 1.0);\n    // Unipolar distortion, same for positive and negative sides\n    return sign(x) * mix(a, b, cos(time * 0.5) * 0.5 + 0.5);\n}\n\nvec2 mainSound(int samp, float time) {\n\n    vec2 result = vec2(0.0);\n    \n    // Lightning\n    float amplitude = min(1.0, exp(mod(time - 1.0, 6.0) * -0.5));\n    result.x += coloredNoise(time, 20.0, 500.0) * amplitude;\n    result.y += coloredNoise(time + 1.5, 20.0, 500.0) * amplitude;\n    \n    // Low frequency rumble\n    result.x += coloredNoise(time, 100.0, 1000.0) * 0.3;\n    result.y += coloredNoise(time + 1.5, 100.0, 1000.0) * 0.3;\n    \n    // Mid frequency rumble\n    result.x += coloredNoise(time, 700.0, 2000.0) * 0.05;\n    result.y += coloredNoise(time + 1.5, 700.0, 2000.0) * 0.05;\n    \n    // Distorted noise for rain\n    result.x += distort(coloredNoise(time, 120.0, 2000.0), time) * 0.25;\n    result.y += distort(coloredNoise(time + 1.5, 120.0, 2000.0), time) * 0.25;\n    \n    return result;\n}", "sound_inputs": [], "buffer_a_code": "// From https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nvec2 hash2d(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Initialize with solid black\n    if (iFrame < 1) {\n        fragColor.r = 0.0;\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    float maxVelocity = 2.0 / iResolution.y;\n    vec2 offset = vec2(0.0, maxVelocity - cos(iTime * 0.5) * maxVelocity);\n    \n    // Sample with offset to slide rain down screen\n    float a = texture(iChannel0, uv).r;\n    float b = texture(iChannel0, uv + offset).r;\n    fragColor.r = max(a, b);\n    \n    // Fade towards blur over time\n    fragColor.r = max(0.0, fragColor.r - 0.03);\n    \n    // Draw 16 drops on screen each frame\n    const float drops = 16.0;\n    for (float i = 0.0; i < drops; i++) {\n        float seed = (iTime + i) * 1024.0;\n        vec2 pos = hash2d(seed) * iResolution.xy;\n        float size = 4.0 + hash(seed) * 8.0;\n        fragColor.r += smoothstep(size, 0.0, distance(fragCoord, pos));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctS3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 487]], "test": "untested"}
{"id": "clSGDz", "name": "3D Tri Rasterizer", "author": "raymarchingenthusiast", "description": "Fills triangles with textures. Depth corrected. 2^SIZE is how many times faster it gets.", "tags": ["triangles"], "likes": 0, "viewed": 193, "published": 3, "date": "1673100257", "time_retrieved": "2024-07-30T18:17:24.566729", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = (fragCoord/SIZE)/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TriCount 6\n#define PI 3.14159265\n#define SIZE 2.5\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nstruct TriDat {\n    Triangle Vp;\n    Triangle Vuv;\n    bool flipNorm;\n    int colMode;\n};\n\nvoid rotX(inout vec3 p, vec2 at) {\n    p.y = at.x*p.y-at.y*p.z;\n    p.z = at.y*p.y+at.x*p.z;\n}\n\nvoid rotY(inout vec3 p, vec2 at) {\n    p.x = at.y*p.z+at.x*p.x;\n    p.z = at.x*p.z-at.y*p.x;\n}\n\nvoid rotZ(inout vec3 p, vec2 at) {\n    p.x = at.x*p.x+at.y*p.y;\n    p.y = at.y*p.x-at.x*p.y;\n}\n\nvec3 crd(vec2 iMouse,vec2 uv) {\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 ra = PI*(vec2(0.,0.)-3.*iMouse);\n    rotY(rd,vec2(cos(ra.x),sin(ra.x)));\n    rotX(rd,vec2(cos(ra.y),sin(ra.y)));\n    //rd.y *= -1.;\n    return rd;\n}\n\nvoid SetTri(inout TriDat t[TriCount], int i,\n  vec3 v1,vec3 v2,vec3 v3,\n  vec2 uv1,vec2 uv2, vec2 uv3,\n  bool fn, int txtr) {\n    t[i] = TriDat(Triangle(v1,v2,v3),Triangle(vec3(uv1,1.),vec3(uv2,1.),vec3(uv3,1.)),fn,txtr);\n}\n\nvoid SetTriData(out TriDat t[TriCount],float iTime) {\n    SetTri(t,0,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(2.,-1.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,1,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(-1.,2.,1.),vec2(1.,0.),vec2(1.,1.),vec2(0.,1.),true,0);\n    SetTri(t,2,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(-1.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),true,0);\n    SetTri(t,3,vec3(-1.,2.,1.),vec3(-1.,2.,4.),vec3(-1.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),true,0);\n    SetTri(t,4,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(2.,-1.,4.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,5,vec3(2.,2.,1.),vec3(2.,2.,4.),vec3(2.,-1.,4.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.),false,0);\n}\n\nvoid SplitTriDat(TriDat t[TriCount],out Triangle tp[TriCount],out Triangle tuv[TriCount]) {\n    for(int i = 0; i < TriCount; i++) {\n        tp[i] = t[i].Vp;\n        tuv[i] = t[i].Vuv;\n    }\n}", "buffer_a_code": "void RecalibTris(inout Triangle tso[TriCount], vec3 ro) {\n    for(int i = 0; i < TriCount; i++) {\n        vec3 a = vec3(tso[i].a.xy-.5,tso[i].a.z);\n        vec3 b = vec3(tso[i].b.xy-.5,tso[i].b.z);\n        vec3 c = vec3(tso[i].c.xy-.5,tso[i].c.z);\n        a -= ro;\n        b -= ro;\n        c -= ro;\n        tso[i] = Triangle(a,b,c);\n    }\n}\n\nvec3 CalcNorm(Triangle t) {\n    vec3 U = t.b-t.a;\n    vec3 V = t.c-t.a;\n    \n    vec3 n;\n    \n    n.x = U.y*V.z - U.z*V.y;\n    n.y = U.z*V.x - U.x*V.z;\n    n.z = U.x*V.y - U.y*V.x;\n    \n    return normalize(n);\n}\n\nvec2 CalcUv(vec2 p, Triangle tp, Triangle tuv, Triangle top, out vec3 pos, out float depth) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    //vec3 auv = w1*tuv.a + w2*tuv.b + w3*tuv.c;\n    vec3 puv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    vec4 p0a = vec4(top.a,1.);\n    vec4 p0b = vec4(top.b,1.);\n    vec4 p0c = vec4(top.c,1.);\n    vec4 p1 = w1*p0a/p0a.z + w2*p0b/p0b.z + w3*p0c/p0c.z;\n    vec2 z0a = vec2(tp.a.z,1.);\n    vec2 z0b = vec2(tp.b.z,1.);\n    vec2 z0c = vec2(tp.c.z,1.);\n    vec2 z1 = w1*z0a/z0a.x + w2*z0b/z0b.x + w3*z0c/z0c.x;\n    \n    depth = z1.x / z1.y;\n    pos = p1.xyz / p1.w;\n    return puv.xy / puv.z;\n}\n\nbool isInside(vec2 p, Triangle tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nvec3 projVert(in vec3 v, vec2 ra) {\n    rotY(v,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(v,vec2(cos(-ra.y),sin(-ra.y)));\n    return v;\n}\n\nTriangle Project(Triangle to,vec2 Mouse) {\n    vec2 ra = PI*(vec2(0.,0.)-3.*Mouse);\n    \n    vec3 a = projVert(to.a,ra);\n    \n    vec3 b = projVert(to.b,ra);\n    \n    vec3 c = projVert(to.c,ra);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    c.xy /= c.z;\n    return Triangle(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord0 ) {    \nvec2 fragCoord = fragCoord0 * SIZE;\nvec2 iResolution1 = iResolution.xy;\nvec2 uv = fragCoord / iResolution1;\nvec2 uMouse = iMouse.xy * SIZE;\nuMouse /= SIZE;\nif(uv.x <= 1. && uv.y <= 1.) {\n    uv -= .5;\n    vec2 MOUSE = (uMouse/iResolution1)-.5;\n    if(uMouse == vec2(0.)) MOUSE = vec2(0.);\n    \n    TriDat tris[TriCount];\n    SetTriData(tris,iTime);\n    \n    \n    Triangle tos[TriCount];\n    Triangle uvs[TriCount];\n    \n    SplitTriDat(tris,tos,uvs);\n    \n    vec3 rd = crd(MOUSE,uv);\n    vec3 centrRd = crd(MOUSE,vec2(0.));\n    vec3 ro = vec3(.5,.5,-1.)-crd(MOUSE,vec2(0.))*8.;\n    //ro = vec3(0.,0.,-2.5);\n    RecalibTris(tos,ro);\n    vec3 ld = vec3(.5,.5,5.*sin(iTime)+1.);\n    \n    fragColor = vec4(0.,0.,.3,100.);\n    for(int i = 0; i < TriCount; i++) {\n        Triangle ts = Project(tos[i],MOUSE);\n        if(isInside(uv,ts)&& !(ts.a.z<=0.||ts.b.z<=0.||ts.c.z<=0.)) {\n            vec3 p;\n            float d;\n            vec2 textureUv = CalcUv(uv,ts,uvs[i],tos[i],p,d);\n            \n            vec3 col = texture(iChannel0,textureUv).xyz;\n            \n            vec3 n = CalcNorm(tos[i]);\n            if(tris[i].flipNorm) n *= -1.;\n            //if sign of n dot centrRd != -1. {proceed}\n            \n            float dif = clamp(dot(n,normalize(ld-p)),0.,1.)*.5+.5;\n            col *= dif;\n            vec3 h = normalize(rd+normalize(ld-p));\n            col += .5* dif * vec3(pow(clamp(dot(h,n),0.,1.),30.));\n            \n            if(d<fragColor.w) fragColor = vec4(col,d);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,d);\n        }\n    }\n    //fragColor.xyz = rd;\n    fragColor.w = 1.;\n}}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 148]], "test": "untested"}
{"id": "ctjGzm", "name": "raster", "author": "lennyjpg", "description": "asdffdsdf", "tags": ["grid", "pattern"], "likes": 0, "viewed": 184, "published": 3, "date": "1673067618", "time_retrieved": "2024-07-30T18:17:25.456350", "image_code": "void mainImage( out vec4 O, in vec2 u )\n{\n    vec2 uv = u / iResolution.xy,\n    g = u.xy;\n    \n    float s = 20.,\n    zoom = 2.,\n    k = .5;\n   \n    uv.y = 1. - uv.y;\n    // not ideal\n    if(uv.y > .25){\n      zoom *= k;\n    }\n    if(uv.y > .5){\n      zoom *= k;\n    }\n    if(uv.y > .75){\n      zoom *= k;\n    }\n    \n    g *= zoom;\n    g.x += round(fract(g.y / s) ) * s *0.5;\n    float m = round(fract(g.x / s));\n    O = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 431]], "test": "untested"}
{"id": "mt2Gzw", "name": "Cloudy Horizon", "author": "KatzenTatzenTanz", "description": "Game of Life from Rule 30 based on this video: [video]https://youtu.be/IK7nBOLYzdE[/video]", "tags": ["gameoflife", "rule30", "aestetic"], "likes": 4, "viewed": 103, "published": 3, "date": "1673059359", "time_retrieved": "2024-07-30T18:17:26.328020", "image_code": "#define Scale 1.\n#define Horizon 0.3\n#define HorizonDefinition 0.35\n\n\nfloat TrueScale = max(1.02,Scale);\nvec4 getColor(vec2 uv) {\n    vec3 col = texture(iChannel0, uv).rgb;\n    col.r = max(0.,pow(col.g,0.05)/2. + pow(col.g,3.)/2.);\n    col.g = max(0.,pow(col.g,0.125));\n    col.b = max(0.,col.b - max(0.3,pow(col.b-1.,3.)) + pow(col.b,0.1)/3.);\n    vec3 sky = vec3(0,0.01,0.15)*pow(uv.y*TrueScale,2.);\n    return vec4(col + sky,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (round(fragCoord/TrueScale)+0.5)*TrueScale/iResolution.xy;\n    uv-= vec2(0.5,Horizon);\n    uv/=TrueScale;\n    uv.x+=0.5;\n    if(uv.y >= 2./iResolution.y) {\n        fragColor = getColor(uv);\n        return;\n    }\n    //redefinition for grid\n    uv.y = -uv.y+5./iResolution.y;\n    uv.x += (texture(iChannel1,uv*vec2(0.2+sin(iTime)*0.004,iResolution.y/255.)).r-.5)/iResolution.x*10.;\n    uv.y += (texture(iChannel1,vec2(uv.y/30.,0)).r-0.5)/iResolution.y*4.;\n    fragColor = min(vec4(1.),getColor(uv))-(Horizon-uv.y)/Horizon*HorizonDefinition;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int[] rule = int[] (0,1,1,1,1,0,0,0);\n\nint getRule(vec2 uv) {\n    float y = uv.y;\n    float off = 1./iResolution.x;\n    int x  = int(texture(iChannel0, vec2(uv.x+off,y)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x,    y)).r == 1.)*2;\n        x += int(texture(iChannel0, vec2(uv.x-off,y)).r == 1.)*4;\n    return x;\n}\n\nint getIteration(vec2 uv) {\n    float offx = 1./iResolution.x;\n    float offy = 1./iResolution.y;\n    int x  = int(texture(iChannel0, vec2(uv.x+offx,uv.y-offy)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x,     uv.y-offy)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x-offx,uv.y-offy)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x+offx,uv.y     )).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x-offx,uv.y     )).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x+offx,uv.y+offy)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x,     uv.y+offy)).r == 1.);\n        x += int(texture(iChannel0, vec2(uv.x-offx,uv.y+offy)).r == 1.);\n    bool self =  texture(iChannel0, vec2(uv.x,     uv.y     )).r == 1.;\n    return int((self && (x == 3 || x == 2)) || (!self && x == 3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) {\n        if(int(fragCoord.x) == int(iResolution.x)/2 && int(fragCoord.y) == 0)\n                fragColor = vec4(1.);\n            else\n                 fragColor = vec4(0.);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(int(fragCoord.y) == 0) {\n        fragColor.r = float(rule[getRule(uv)]);\n        return;\n    }\n    if(int(fragCoord.y) == 1) {\n        fragColor.r = texture(iChannel0,vec2(uv.x,0)).r;\n        return;\n    }\n    if( int(fragCoord.y) == int(iResolution.y)-4+int(sin(iTime)*4.) ||\n        int(fragCoord.x) == int(iResolution.x)-4+int(sin(iTime)*4.) || \n        int(fragCoord.x) == 4+int(sin(iTime)*4.)) {\n        fragColor = vec4(0.);\n        return;\n    }\n    int i = getIteration(uv);\n    if(i == 1) {\n        if(texture(iChannel0,uv).r == 1.) {\n            fragColor = texture(iChannel0,uv);\n            fragColor.a -= 0.002;\n            if(fragColor.a <= 0.) {\n                fragColor = vec4(0,1,1,0);\n            }\n        } else {\n            fragColor = vec4(1);\n        }\n    } else {\n        fragColor = texture(iChannel0,uv) * vec4(0,0.95,0.999,0);\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2Gzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 129, 129, 433], [435, 435, 492, 542, 1098]], "test": "untested"}
{"id": "dlB3zW", "name": "Triangle filler 3D v0.2.1", "author": "raymarchingenthusiast", "description": "Fills triangles with textures. Depth corrected.", "tags": ["triangles"], "likes": 1, "viewed": 189, "published": 3, "date": "1673055514", "time_retrieved": "2024-07-30T18:17:27.194702", "image_code": "void RecalibTris(inout Triangle tso[TriCount], vec3 ro) {\n    for(int i = 0; i < TriCount; i++) {\n        vec3 a = vec3(tso[i].a.xy-.5,tso[i].a.z);\n        vec3 b = vec3(tso[i].b.xy-.5,tso[i].b.z);\n        vec3 c = vec3(tso[i].c.xy-.5,tso[i].c.z);\n        a -= ro;\n        b -= ro;\n        c -= ro;\n        tso[i] = Triangle(a,b,c);\n    }\n}\n\nvec3 CalcNorm(Triangle t) {\n    vec3 U = t.b-t.a;\n    vec3 V = t.c-t.a;\n    \n    vec3 n;\n    \n    n.x = U.y*V.z - U.z*V.y;\n    n.y = U.z*V.x - U.x*V.z;\n    n.z = U.x*V.y - U.y*V.x;\n    \n    return normalize(n);\n}\n\nvec2 CalcUv(vec2 p, Triangle tp, Triangle tuv, Triangle top, out vec3 pos) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    //vec3 auv = w1*tuv.a + w2*tuv.b + w3*tuv.c;\n    vec3 puv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    vec4 p0a = vec4(top.a,1.);\n    vec4 p0b = vec4(top.b,1.);\n    vec4 p0c = vec4(top.c,1.);\n    vec4 p1 = w1*p0a/p0a.z + w2*p0b/p0b.z + w3*p0c/p0c.z;\n    \n    pos = p1.xyz / p1.w;\n    return puv.xy / puv.z;\n}\n\nbool isInside(vec2 p, Triangle tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nTriangle Project(Triangle to,vec2 Mouse) {\n    vec2 ra = PI*(vec2(1.,0.)-3.*Mouse);\n    \n    vec3 a = to.a;\n    rotY(a,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(a,vec2(cos(-ra.y),sin(-ra.y)));\n    \n    vec3 b = to.b;\n    rotY(b,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(b,vec2(cos(-ra.y),sin(-ra.y)));\n    \n    vec3 c = to.c;\n    rotY(c,vec2(cos(-ra.x),sin(-ra.x)));\n    rotX(c,vec2(cos(-ra.y),sin(-ra.y)));\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    c.xy /= c.z;\n    return Triangle(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= .5;\n    vec2 MOUSE = (iMouse.xy/iResolution.xy)-.5;\n    if(iMouse.xy == vec2(0.)) MOUSE = vec2(0.);\n    \n    TriDat tris[TriCount];\n    SetTriData(tris,iTime);\n    \n    \n    Triangle tos[TriCount];\n    Triangle uvs[TriCount];\n    \n    SplitTriDat(tris,tos,uvs);\n    \n    vec3 rd = crd((iMouse.xy/iResolution.xy)-.5,uv);\n    vec3 centrRd = crd(MOUSE,vec2(0.));\n    vec3 ro = vec3(.5,.5,0.)-centrRd*8.;\n    //ro = vec3(0.,0.,-2.5);\n    RecalibTris(tos,ro);\n    vec3 ld = vec3(.5,.5,5.*sin(iTime)+1.);\n    \n    fragColor = vec4(0.,0.,.3,100.);\n    for(int i = 0; i < TriCount; i++) {\n        Triangle ts = Project(tos[i],MOUSE);\n        if(isInside(uv,ts)&& !(ts.a.z<=0.||ts.b.z<=0.||ts.c.z<=0.)) {\n            vec3 p;\n            vec2 textureUv = CalcUv(uv,ts,uvs[i],tos[i],p);\n            //p = vec3(0.);\n            \n            vec3 col = texture(iChannel0,textureUv).xyz;\n            \n            vec3 n = CalcNorm(tos[i]);\n            if(tris[i].flipNorm) n *= -1.;\n            float dif = clamp(dot(n,normalize(ld-p))*.5+.5,0.,1.);\n            col *= dif;\n            vec3 h = normalize(rd+normalize(ld-p));\n            col += dif * vec3(pow(clamp(dot(h,n),0.,1.),30.));\n            \n            if(p.z<=fragColor.w) fragColor = vec4(col,p.z);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,1.);\n        }\n    }\n    //fragColor.xyz = rd;\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TriCount 2\n#define PI 3.14159265\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nstruct TriDat {\n    Triangle Vp;\n    Triangle Vuv;\n    bool flipNorm;\n    int colMode;\n};\n\nvoid rotX(inout vec3 p, vec2 at) {\n    p.z = at.y*p.y-at.x*p.z;\n    p.y = at.x*p.y+at.y*p.z;\n}\n\nvoid rotY(inout vec3 p, vec2 at) {\n    p.x = at.y*p.z-at.x*p.x;\n    p.z = at.x*p.z-at.y*p.x;\n}\n\nvoid rotZ(inout vec3 p, vec2 at) {\n    p.y = at.y*p.x-at.x*p.y;\n    p.x = at.x*p.x-at.y*p.y;\n}\n\nvec3 crd(vec2 iMouse,vec2 uv) {\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 ra = PI*(vec2(1.,0.)-3.*iMouse);\n    rotY(rd,vec2(cos(ra.x),sin(ra.x)));\n    rotX(rd,vec2(cos(ra.y),sin(ra.y)));\n    //rd.y *= -1.;\n    return rd;\n}\n\nvoid SetTri(inout TriDat t[TriCount], int i,\n  vec3 v1,vec3 v2,vec3 v3,\n  vec2 uv1,vec2 uv2, vec2 uv3,\n  bool fn, int txtr) {\n    t[i] = TriDat(Triangle(v1,v2,v3),Triangle(vec3(uv1,1.),vec3(uv2,1.),vec3(uv3,1.)),fn,txtr);\n}\n\nvoid SetTriData(out TriDat t[TriCount],float iTime) {\n    SetTri(t,0,vec3(-1.,-1.,1.),vec3(-1.,2.,1.),vec3(2.,-1.,1.),vec2(0.,0.),vec2(0.,1.),vec2(1.,0.),false,0);\n    SetTri(t,1,vec3(2.,-1.,1.),vec3(2.,2.,1.),vec3(-1.,2.,1.),vec2(1.,0.),vec2(1.,1.),vec2(0.,1.),true,0);\n}\n\nvoid SplitTriDat(TriDat t[TriCount],out Triangle tp[TriCount],out Triangle tuv[TriCount]) {\n    for(int i = 0; i < TriCount; i++) {\n        tp[i] = t[i].Vp;\n        tuv[i] = t[i].Vuv;\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlB3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340], [342, 342, 369, 369, 554], [556, 556, 632, 632, 1371], [1373, 1373, 1410, 1410, 1778], [1780, 1780, 1822, 1822, 2267], [2269, 2269, 2326, 2326, 3804]], "test": "untested"}
{"id": "Dlj3zm", "name": "3C : Breakfast on the Boardwalk", "author": "Xenolupus", "description": "A breakfast on the boardwalk", "tags": ["wave", "sine", "beach"], "likes": 4, "viewed": 172, "published": 3, "date": "1673051018", "time_retrieved": "2024-07-30T18:17:28.028473", "image_code": "float PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat waveMaker (in vec2 uv, float timeOffset, vec2 distortOffset, float yOffset)\n{\n    float sineWaveDistort = 1.0-sin(iTime+timeOffset+uv.x*20.0*distortOffset.x)*0.2*distortOffset.y;\n\n    float bigSineWave1 = sin(iTime+timeOffset+uv.x*5.0*distortOffset.x)*0.03*sineWaveDistort*distortOffset.y;\n    float sineWave1 = sin(iTime+timeOffset+uv.x*30.0*distortOffset.x)*0.03*sineWaveDistort*distortOffset.y+0.8;\n\n    float wave = clamp((uv.y-sineWave1+bigSineWave1+yOffset)*1000.0,0.0,1.0);\n        \n    return wave;\n}\n\nfloat combinedWave(float totalTimeOffset, float totalYOffset,in vec2 uv)\n{\n    float wave1 = waveMaker(uv,0.0+totalTimeOffset,vec2(1.0,1.0),0.0+totalYOffset);\n    float wave2 = waveMaker(uv,0.01+totalTimeOffset,vec2(1.01,0.99),0.02+totalYOffset);\n    float wave3 = waveMaker(uv,0.02+totalTimeOffset,vec2(1.03,1.11),0.04+totalYOffset);\n    float wave4 = waveMaker(uv,0.03+totalTimeOffset,vec2(0.99,1.03),0.08+totalYOffset);\n    \n    return wave1*0.25+wave2*0.25+wave3*0.25+wave4*0.25;\n}\n\nvec3 beachCol(in vec2 uv,in vec2 fragCoord)\n{\n    float wave1 = waveMaker(uv,0.0,vec2(1.0,1.0),0.0);\n    float wave2 = waveMaker(uv,0.01,vec2(1.01,0.99),0.02);\n    float wave3 = waveMaker(uv,0.02,vec2(1.03,1.11),0.04);\n    float wave4 = waveMaker(uv,0.03,vec2(0.99,1.03),0.08);\n    \n    float wave = combinedWave(0.0,0.0,uv);\n    \n    vec3 waterCol = vec3(0.0,0.5,1.0);\n    vec3 frothCol = vec3(0.95,0.95,0.95);\n    \n    vec3 waveCol = mix(waterCol,frothCol,1.0-wave+0.25);\n    \n    float wet = clamp(combinedWave(-0.5,0.02,uv)*1000.0,0.0,1.0);\n    \n    float sandMask = 1.0-clamp(wave*1000.0,0.0,1.0);\n    \n    float sandSpecs = clamp((gold_noise(fragCoord,fract(123.12))-0.05)*20.0,0.0,1.0);\n    \n    vec3 sandCol1 = vec3(0.525,0.4,0.2);\n    vec3 sandCol2 = vec3(0.95,0.95,0.7);\n    \n    vec3 sancCol = mix(sandCol1,sandCol2,sandSpecs-wet*0.3);\n    \n    return mix(waveCol,sancCol,sandMask);\n}\n\nfloat boardWalkBoards(in vec2 uv)\n{\n    return clamp((sin(uv.x*50.0+4.8)+0.85)*50.0,0.0,1.0);\n}\n\nfloat boardWalkMask(in vec2 uv)\n{\n        float boardwalk = 1.0-clamp((uv.y-0.55)*1000.0,0.0,1.0);\n    boardwalk *= boardWalkBoards(uv);\n    boardwalk += 1.0-clamp((uv.y-0.45)*1000.0,0.0,1.0);\n    return clamp(boardwalk,0.0,1.0);\n}\n\nfloat findDis(in vec2 pos1, in vec2 pos2)\n{\n    return sqrt(pow(pos2.y-pos1.y,2.0)+pow(pos2.x-pos1.x,2.0));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 boardwalkColor = vec3(0.8,0.7,0.5)*clamp(boardWalkBoards(uv)+0.7,0.0,1.0);\n    \n    boardwalkColor = boardwalkColor*clamp(0.8+(1.0-(boardWalkMask(uv) - boardWalkMask(uv+vec2(0.0,0.01)))),0.0,1.0);\n    \n    vec3 beachColor = beachCol(uv,fragCoord)-boardWalkMask(uv-vec2(0.01,-0.01))*0.2;\n    \n    vec3 result = mix(beachColor,boardwalkColor,boardWalkMask(uv));\n    \n    float aspect = iResolution.x/iResolution.y;\n    vec2 aspectScaledUV = vec2(uv.x*aspect,uv.y);\n    \n    float coconutDis = 1.0-findDis(aspectScaledUV, (vec2(0.5*aspect,0.2)));\n    \n    float coconutMask = clamp((coconutDis-0.9)*1000.0,0.0,1.0);\n    \n    float coconutDisShade = coconutMask * clamp((1.0-findDis(aspectScaledUV, (vec2(0.52*aspect,0.22)))-0.6)*2.25,0.0,1.0);\n    \n\n    \n    float coconutShadowDis = 1.0-findDis(aspectScaledUV, (vec2(0.48*aspect,0.18)));\n    \n    float coconutShadowMask = clamp(1.8-clamp((coconutShadowDis-0.9)*1000.0,0.0,1.0),0.0,1.0);\n    \n    \n    \n    \n    float coconutHoleDis1 = clamp(1.0-findDis(aspectScaledUV, (vec2(0.52*aspect,0.22))),0.0,1.0);\n    float coconutHoleMask1 = clamp(1.5-clamp((coconutHoleDis1-0.9875)*1000.0,0.0,1.0),0.0,1.0);\n    float coconutHoleDis2 = clamp( 1.0-findDis(aspectScaledUV, (vec2(0.52*aspect,0.25))),0.0,1.0);\n    float coconutHoleMask2 = clamp(1.5-clamp((coconutHoleDis2-0.9875)*1000.0,0.0,1.0),0.0,1.0);\n    float coconutHoleDis3 = clamp(1.0-findDis(aspectScaledUV, (vec2(0.50*aspect,0.25))),0.0,1.0);\n    float coconutHoleMask3 = clamp(1.5-clamp((coconutHoleDis3-0.9875)*1000.0,0.0,1.0),0.0,1.0);\n    \n    vec3 coconutColor = vec3(0.5,0.3,0.0)*coconutDisShade*coconutHoleMask1*coconutHoleMask2*coconutHoleMask3;\n    \n    result = mix(result*coconutShadowMask,coconutColor,coconutMask);\n    \n    // Output to screen\n    fragColor = vec4(result,0.0);//vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 109, 109, 169], [171, 171, 254, 254, 685], [687, 687, 761, 761, 1172], [1174, 1174, 1219, 1219, 2069], [2071, 2071, 2106, 2106, 2166], [2168, 2168, 2201, 2201, 2399], [2401, 2401, 2444, 2444, 2515], [2517, 2517, 2574, 2633, 4496]], "test": "untested"}
{"id": "ctj3zm", "name": "Irregular Golden Tiling", "author": "mla", "description": "Another irregular rectangular tiling, this one is based on squares and golden rectangles.", "tags": ["rectangle", "tiling", "golden"], "likes": 25, "viewed": 430, "published": 3, "date": "1673048323", "time_retrieved": "2024-07-30T18:17:28.843294", "image_code": "//////////////////////////////////////////////////////////////\n//\n// Irregular Golden Tiling, mla, 2023\n//\n// A square can be dissected into a smaller square and two\n// golden rectangles (of different sizes). A golden rectangle\n// can be dissected into a square and a (smaller) golden\n// rectangle. Repeat as required.\n//\n// 'x': show tile distance field\n// 'y': iterate to fixed tile size\n// 'z': progressive\n//\n//////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  const float phi = 0.5*(sqrt(5.0)-1.0); // 0.618..\n  float lwidth = 0.001;\n  vec2 p = 1.1*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float px = fwidth(p.x);\n  vec3 col = vec3(1,1,0.5);\n  vec2 a = vec2(-1.0-phi,-1);\n  vec2 b = vec2(1.0+phi,1);\n  int type = 1;\n  float d = rectdist(p,a,b);\n  if (d < 0.0) {\n    uint h = uint(iTime);\n    int N = 11;\n    if (key(CHAR_Z)) { N = int(iTime)%14; h = uint(iTime)/14u; }\n    // Could also iterate eg. until length(a-b) < 0.1\n    // Or don't count thin rectangles\n    // Or randomly terminate loop early.\n    for (int i = 0; \n         key(CHAR_Y) ? length(a-b) > 0.1 : i < N || type == 2; \n         i++, h = ihash(h^uint(type))) {\n      if (type == 0) {\n        bool flip = bool(h&1u);\n        if (flip) { p = p.yx; a = a.yx; b = b.yx; }\n        bool reverse = bool(h&2u);\n        if (reverse) {\n          float x1 = phi*a.x + (1.0-phi)*b.x;\n          if (p.x < x1) { b = vec2(x1,b.y); type = 2; }\n          else { a = vec2(x1,a.y); type = 1; }\n        } else {\n          float x1 = (1.0-phi)*a.x + phi*b.x;\n          if (p.x < x1) { b = vec2(x1,b.y); type = 1; }\n          else { a = vec2(x1,a.y); type = 2; }\n        }\n        if (flip) { p = p.yx; a = a.yx; b = b.yx; }\n      } else { // type == 1 || type == 2 ie. golden or thin rectangle\n        bool flip = b.y-a.y > b.x-a.x;\n        if (flip) { p = p.yx; a = a.yx; b = b.yx; }\n        bool reverse = bool(h&1u);\n        if (reverse) {\n          float x1 = b.x-(b.y-a.y);\n          if (p.x < x1) { b = vec2(x1,b.y); type = 1; }\n          else { a = vec2(x1,a.y); type = 0; }\n        } else {\n          float x1 = a.x+b.y-a.y;\n          if (p.x < x1) { b = vec2(x1,b.y); type = 0; }\n          else { a = vec2(x1,a.y); type = 1; }\n        }\n        if (flip) { p = p.yx; a = a.yx; b = b.yx; }\n      }\n    }\n    col = 0.25+0.75*h2rgb(float(h)/exp2(32.0));\n    d = min(min(p.x-a.x,b.x-p.x),\n            min(p.y-a.y,b.y-p.y));\n    if (key(CHAR_X)) col *= 0.75-0.25*cos(PI*d/px);\n  }\n  col *= smoothstep(0.0,px,d-lwidth);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.4159;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// External distance to rectangle.\nfloat rectdist(vec2 p, vec2 a, vec2 b) {\n  return max(max(a.x-p.x,p.x-b.x),\n             max(a.y-p.y,p.y-b.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctj3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 477, 529, 529, 2609]], "test": "untested"}
{"id": "DtjGzm", "name": "classic webcam mirroring", "author": "jonasfrey", "description": "webcam", "tags": ["webcam"], "likes": 0, "viewed": 285, "published": 3, "date": "1673046385", "time_retrieved": "2024-07-30T18:17:29.910441", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    float n_x = abs(o_trn_fc_nor.x-.5)*-1.+0.5;\n    \n    vec4 o_col_wc = texture(iChannel0, vec2(n_x,o_trn_fc_nor.y));\n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    float n_d = length(o_trn_fc_nor_offset);\n    float n_fuzz, n_min, n_d_smstp_absolute, n_d_smstp_relative;\n    // if we use the ratio of 1. to the resolution\n    // as a factor , we can keep the exact size when using smoothstep\n    fragColor = o_col_wc;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 862]], "test": "untested"}
{"id": "Dlj3Rm", "name": "Genuary2023 jan.6", "author": "z0rg", "description": "https://genuary.art/  Steal like an artist\nReproducing some Etienne Jacob's work", "tags": ["genuary"], "likes": 23, "viewed": 337, "published": 3, "date": "1673043804", "time_retrieved": "2024-07-30T18:17:31.054382", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\nfloat rand()\n{\n  return hash11(_seed++);\n}\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x,max(l.y,l.z));\n}\nfloat _cucube(vec3 p, vec3 s,vec3 t)\n{\n  vec3 l = abs(p)-s;\n  float c = max(l.x,max(l.y,l.z));\n  l = abs(l)-s*t;\n\n  float x = max(max(l.x,c),l.y);\n  float y = max(max(l.z,c),l.y);\n  float z = max(max(l.x,c),l.z);\n  return min(min(x,y),z);\n}\nmat2 r2d(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c,-s,s,c);\n}\n#define sat(a) clamp(a,0.1,1.)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+(r*uv.x+u*uv.y)*.75);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(10000.,-1.);\n\n//acc = _min(acc, vec2(length(p)-1.,0.));\nacc = _min(acc, vec2(-p.y,1.));\nfloat time = iTime*.5;\np.z+=time*.65;\nvec2 rep = vec2(1.);\nvec3 p2 = p-vec3(0.,-.25,0.);\nvec2 id = floor((p2.xz+rep*.5)/rep);\nfloat ida = abs(id.x+10.*id.y);\np2.xz = mod(p2.xz+rep*.5,rep)-rep*.5;\nfloat t = time*2.+ida;\np2.y+=abs(sin(t*2.))*.1;\np2.yz*=r2d(-t);\n\nfloat cube = _cube(p2,vec3(.2));\nacc = _min(acc,vec2(cube,ida));\nfloat cubew = _cucube(p2,vec3(.21),vec3(.1));\nacc = _min(acc,vec2(cubew,-ida));\n  return acc;\n}\n\nvec3 getNorm(float d, vec3 p)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n  vec3 p = ro;\n  for (int i = 0;i<steps&&distance(p,ro)<40.;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+=rd*res.x*.35;\n\n  }\n  return vec3(-1.);\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n  vec3 col = n*.5+.5;\n  float gsz = 5.;\n  if (res.z==1.)\n  {\n    vec2 gridh = sin(p.xz*gsz)-.9;\n    col*= 0.*sat(max(gridh.x,gridh.y)*100.);\n  }\n  if (res.z<0.)\n  {\n    vec2 gridh = sin(p.xy*gsz)-.9;\n    col= vec3(1.)*2.*pow(texture(iChannel0,vec2(res.z*.01+iTime*.005)).x,4.);\n  }\n  if(res.z>1.)\n  col = vec3(0.);\n  return col;\n}\n\nvec3 rdr(vec2 uv,vec2 ouv)\n{\n\n  vec3 col= vec3(0.);\n  float t = iTime*.33;\n  vec3 ro = vec3(4.,-4.,2.);\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n\n  vec3 res = trace(ro,rd, 128);\n  float y =-1.;\n  if (res.y >0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(res.x,p);\n    y = p.y;\n    col = getMat(p,n,rd,res);\n    if(res.z != 0.)\n    {\n      vec3 refl = normalize(reflect(rd,n)\n        +(vec3(rand(),rand(),rand())-.5)*.1);\n      vec3 resrefl = trace(p+n*.01,refl,128);\n      if(resrefl.y>0.)\n      {\n        vec3 prefl = p+n*.01+refl*resrefl.y;\n        vec3 nrefl = getNorm(resrefl.x,prefl);\n        col+= getMat(prefl,nrefl,refl,resrefl);\n      }\n    }\n  }\ncol+=accCol;\ncol = mix(col, texture(iChannel1,ouv).xyz,.6);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\nvec2 ouv = (fragCoord.xy/iResolution.xy);\n\n  _seed = texture(iChannel0,uv).x+iTime;\n\n  vec3 col = rdr(uv,ouv);\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot,ouv);\n        acc += rdr(uv-off.xy*rot,ouv);\n        acc += rdr(uv-off.yy*rot,ouv);\n        acc += rdr(uv-off.yx*rot,ouv);\n        col = acc/5.;\n    }\n  fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 173]], "test": "untested"}
{"id": "dtS3zm", "name": "smoothstep resolution independen", "author": "jonasfrey", "description": "left side, the smoothstep acts relative to the screensize \nright side, the smoothstep acts absolute to the screensize ( stays the same no matter what resolution)", "tags": ["smoothstep"], "likes": 2, "viewed": 208, "published": 3, "date": "1673022035", "time_retrieved": "2024-07-30T18:17:31.947993", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n        \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n\n    float n_d = length(o_trn_fc_nor_offset);\n    float n_fuzz, n_min, n_d_smstp_absolute, n_d_smstp_relative;\n    // if we use the ratio of 1. to the resolution\n    // as a factor , we can keep the exact size when using smoothstep\n    n_fuzz = n_ratio_1to_iresx*100.;\n    n_min = n_ratio_1to_iresx*100.;\n    n_d_smstp_absolute = smoothstep(n_min, n_min+n_fuzz, n_d);\n    \n    // otherwise \n    n_fuzz = 0.5;\n    n_min = 0.1;\n    n_d_smstp_relative = smoothstep(n_min, n_min+n_fuzz, n_d);\n    fragColor = vec4(n_d_smstp_relative);\n    \n    if(o_trn_fc_nor_offset.x>0.){\n        fragColor = vec4(n_d_smstp_absolute);\n\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 1122]], "test": "untested"}
{"id": "mlB3Rw", "name": "HexTorus Dance", "author": "NivBehar", "description": "HexTorus dance\nMake sure music is playing", "tags": ["raymarching", "sound", "torus", "spiral", "hexagons", "buffers"], "likes": 23, "viewed": 581, "published": 3, "date": "1673008471", "time_retrieved": "2024-07-30T18:17:33.159753", "image_code": "/*\n    I wanted to try a new tool I made which produce a smooth sound based on 3 basic bands: bass, middle and treble.\n    You can find it here: https://www.shadertoy.com/view/mtl3Rj\n    So I took an old shader, https://www.shadertoy.com/view/wlG3Wy and pushed these sound parameters where ever I could.\n*/\n\n# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200 // max steps for ray marching\n\nfloat bass;\nfloat mid;\nfloat treb;\nfloat sound;\nfloat bass_cont;\nfloat mid_cont;\nfloat treb_cont;\nfloat sound_cont;\n\nvec4 mouse;\n\nfloat halDist;\nbool init;\nbool stop;\n\nvec3 HalCol() {return vec3(bass,0.4,treb);}\nvec3 FogCol() {return vec3(bass*0.6,treb*0.4,0.21);}\n\nvec3 torus1Pos() {return vec3(0.,0.,0.);}\nvec2 torus1Size() {return vec2(45.3,17.5);} //45.3 17.5\n\nvec2 torusRotSpeed() {return vec2(-sound_cont - time*0.5, sound_cont + time*0.4);}\nfloat inOut = -1.; // -1 inside torus, 1 outside torus\n\nvec2 hexCoordsMul = 1.*vec2(1.9,1.184)*2.*PI;// + 0.*vec2(2.4,1.24)*6. + 0.*vec2(1.5,1.24)*6. + 0.*vec2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nvec3 spherePos() {\n    return vec3(10. * sin(time*0.381), 10. * cos(time*0.452), 40.);\n}\nfloat sphereRad() {return 5.;}\nvec3 spherePosNew(vec3 p, vec3 spherePos)\n{\n    p = p - spherePos;\n    p = RotZ(p, time);\n    p = RotX(p, time);\n    return p;\n}\n\nvec3 camerapos() {return vec3(0., 2.5, 60.);}\nvec3 cameralookat() \n{\n    return spherePos();\n}\nvec3 LightPos()\n{\n    return camerapos() + vec3(10.,4.,0.) + 0.*vec3(70.*cos(0.5*PI + 0.25*PI*sin(bass_cont*0.3)),25.*sin(treb_cont*1.5),70.*sin(0.5*PI + 0.25*PI*sin(mid_cont*0.3)));\n} \n\nvec4 Hive(vec2 UV, bool calc_flowers)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y); // inside each hexagon (without the edges)\n    float edges = 1.-c;\n    float id1 = hc.z;\n    float id2 = hc.w;\n    \n    // masking 3 horizontal bands based on hexagon's ID\n    float num_of_tiles = 6.;\n    float b11;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 0.)\n    {\n        b11 = 0.;\n    }\n    else\n    {\n        b11 = 1.;\n    }\n    \n    float b12;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 1.)\n    {\n        b12 = 0.;\n    }\n    else\n    {\n        b12 = 1.;\n    }\n    \n    \n    float b13;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 2.)\n    {\n        b13 = 0.;\n    }\n    else\n    {\n        b13 = 1.;\n    }\n    \n    float a1 = b12 * b11;\n    float a2 = b11 * b13;\n    float a3 = b12 * b13;\n    b11 = a1;\n    b12 = a2;\n    b13 = a3;\n    \n    float band1 = b11;\n    float band2 = b12;\n    float band3 = b13;\n    \n    // flowers on each hexagon\n    float flowers = 1.;\n    if( calc_flowers)\n    {\n        vec4 ehc = HexCoords((hc.xy+0.1*vec2(0., time))*vec2(2.3,7.) + vec2(100.) + vec2(4.,0.));\n        flowers = fract(ehc.w);\n        flowers += smoothstep(0.,0.6, ehc.y);\n        flowers = clamp(flowers, 0., 1.);\n\n    }\n\n    vec3 A1 = vec3(0.5, 0.5, 0.5);\n    vec3 B1 = vec3(0.75, 0.55, 0.85);\n    vec3 D1 = vec3(0.0, 0.1, 0.2);\n    \n    vec3 A2 = vec3(1., 1., 1.);\n    vec3 B2 = vec3(1., 1., 1.);\n    vec3 D2 = vec3(1., 1., 1.);\n    \n    vec3 C = vec3(-treb_cont*1.5*0. + hc.z*0.15 + hc.w*0.15);\n    vec3 spinning_light_mask = A2 + B2 * cos(2.*PI*(D2 + C));\n\n    col =  \n          // white band\n          + 1.*band1*flowers*(1.-edges)*vec3(1.,1.,0.9) * 4. * treb * treb\n          \n          // blue band\n          + 1.*band2*(flowers)*(1.-edges)*vec3(0.34,0.5,1.) * 4. * mid * mid * mid\n          \n          // orange band\n          + 1.*band3*flowers*(1.-edges)*vec3(1.,0.6,0.2)*1. * bass * bass * bass\n          \n          // spinning band - when music is high\n          + mix(vec3(0.), vec3(0.995,0.749,0.847)*spinning_light_mask *(1.-edges) , min(1.,0. + treb*treb*treb*3.)) * 1.3\n          // spinning band - when music is low\n          + mix(vec3(0.995,0.749,0.847)*spinning_light_mask *(edges), vec3(0.) , min(1.,0. + treb*treb*treb*3.)) * 0.5;\n\n    return vec4(col, edges);\n}\n\nfloat sdTorus1(vec3 p, vec2 r) {\n    float torusDist = length( vec2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    vec2 tUV = GetTorusUV(p, torus1Size());   \n    vec4 h = HexCoords(tUV*hexCoordsMul + hexCoordsAdd + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.2,h.y) + 0.0000*smoothstep(0.1,0.2,h.y);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = inOut*hexTorus;\n    \n    return hiveTorus*0.8;\n}\n\nvec2 GetDist(vec3 p)\n{\n    vec2 distToReturn; \n\n    // torus\n    vec3 torusPosNew = RotY(p - torus1Pos(), time);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size());\n    float torusID = 1.;\n   \n    // an object inside the torus\n    float sphereID = 3.;\n    vec3 spherePosNew = p-spherePos();//spherePosNew(p, spherePos());\n    float sphere_rad = 9.5;\n    float sphereDist = sdSphere(spherePosNew, sphere_rad);\n    float click = mouse.z > 0. ? 1. : 0.;\n    float rotZMouse = (click > 0. ? mouse.x*0.01 : 0.);\n    float rotXMouse = (click > 0. ? mouse.y*0.01 : 0.);\n    vec3 box_pos = RotY(RotX(RotZ(spherePosNew, (1.-click)*treb_cont*1.2 + click*rotZMouse), (1.-click)*bass_cont*1.2 + click*rotXMouse), (1.-click)*mid_cont*1.2);\n    float boxDist = box(box_pos, vec3(0.788*sphere_rad));\n    sphereDist = smoothIntersectSDF(boxDist, sphereDist, .3);\n    vec3 cylPos = box_pos;\n    float max_h = 11.;\n    float cyls_rad = sphereRad()*0.6;\n    float cyl1 = cappedCylinder(cylPos, min(mid*17., max_h), cyls_rad);\n    float cyl2 = cappedCylinder(RotZ(cylPos, PI/2.), min(bass*bass*10., max_h), cyls_rad);\n    float cyl3 = cappedCylinder(RotX(cylPos, PI/2.), min(treb*17., max_h), cyls_rad);\n    float cyls = smoothUnionSDF(cyl1, smoothUnionSDF(cyl2, cyl3, 1.), 1.);\n    sphereDist = smoothUnionSDF(sphereDist, cyls, 6.);\n    \n    /*\n    define Halation around the object\n    idea: keep marching until we get to a point when the previous distance \n          from the object was smaller then the current point.\n          we need the stopping mechanism beacuse if we will not stop,\n          we will get artifacts caused by the torus.\n          its still not accurate but we can get nice results.\n          marching --> --> --> [a point close to the object] --> stop marching\n    */\n    if(init)\n    {\n        // initiate the distance from the object\n        halDist = sphereDist;\n        init = false;\n    }\n    else if(!stop)\n    {\n        \n        if(sphereDist >= halDist)\n        {\n            stop = true;\n        }\n        else\n            // keep updating\n            halDist = sphereDist;\n    }\n\n    float dist = min(torusDist, sphereDist);\n    if(dist == torusDist)\n        distToReturn = vec2(dist, torusID);   \n\n    if(dist == sphereDist)\n        distToReturn = vec2(dist, sphereID);\n        \n    return distToReturn;// * vec2(0.8,1.);\n}\nvec3 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;\n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p);\n        if(dS.x < 0.0001) {break;}\n        dO += dS.x;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).x, \n                        GetDist(p-e.yxy).x, \n                        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 normal, vec3 lightpos, float lightpower, float shadowstrength, int steps)\n{\n    vec3 l = normalize(lightpos - p);\n    //vec3 n = GetNormal(p);\n    float dif = clamp(dot(normal, l*lightpower), 0., 1.);\n    if(steps > 0) // shadows\n    {\n        float d = RayMarch(p + normal*0.2, l, steps).x;\n        if(d < length(lightpos-p))\n            dif *= shadowstrength;\n    }\n    return dif;\n}\n\nfloat GetSpotLight(vec3 p, vec3 normal, vec3 lightpos, vec3 lightDir, float alpha, float light_exp)\n{\n    vec3 l = normalize(lightpos - p);\n    float beta = abs(dot(-l, lightDir));\n    if( beta < cos(alpha))\n        return 0.;\n    float dot_product = beta;\n    dot_product = pow(dot_product, light_exp);\n    float dif = clamp(dot_product, 0., 1.);\n    return dif;\n}\n\nfloat specularReflection(vec3 p, vec3 normal, vec3 rd, vec3 lightPos, float steps, float intensity, float shininessVal)\n{\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, normal), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0 ) {\n        vec3 R = reflect(-L, normal);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nfloat calcOcclusion(vec3 p, vec3 normal) // calcOcclusion by iq\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*normal;\n        float d = GetDist(opos).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 torusCol(vec3 p, vec3 normal, float dif, float spRef, bool calc_flowers)\n{\n    vec3 ret;\n    vec2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n    vec4 hive = Hive(tUV*hexCoordsMul+hexCoordsAdd+torusRotSpeed(), calc_flowers);\n    vec3 hive_col = hive.xyz;\n    ret = vec3(dif);\n    float occ = calcOcclusion(p, normal);\n    ret = dif*hive_col*occ;\n    ret *= ret*1.5;\n    ret += vec3(spRef) * HalCol();\n    //ret *= vec3(occ*occ*occ);\n    return ret;\n}\n\nvec3 sphereCol(vec3 p, float dif, float spRef)\n{\n    vec3 ret;\n    vec3 spherePosNew = spherePosNew(p, spherePos());\n    vec2 sUV = GetSphereUV(spherePosNew, sphereRad());\n    vec3 hive_col = Hive(sUV*vec2(6.,3.3) + 100., true).xyz;\n    ret = hive_col*dif;\n    ret *= ret*1.5;\n    return ret;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance, // camera to point distance\n               float b) // density\n{\n    // only fog out distances above 10.\n    distance = smoothstep(10., 160., distance)*distance;\n    b = 0.05;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = FogCol();\n    return mix( rgb, fogColor, fogAmount );\n    return rgb;\n}\n\nvec3 GetCol(vec3 ro, vec3 rd, vec3 p, vec3 d) \n{\n    vec3 ret;\n    vec3 n = GetNormal(p);\n\tfloat dif = GetLight(p, n, LightPos(), 1., 0.7,  0); //***\n    float spRef = specularReflection(p, n, rd, LightPos(), 100., 0.7, 25.);\n\n    if(d.z == 1.) //torus painting\n    {        \n        ret = torusCol(p, n, dif, spRef, true);\n    }\n\n    // reflection for the object\n    if(d.z == 3.) // sphere col + reflection\n    {\n        rd = normalize(reflect(rd,n)); // reflect does: rd - 2.0 * dot(n, rd) * n\n        ro = p + rd*0.001;\n        d = RayMarch(ro, rd, int(float(MaxSteps) * 0.5));\n        p = ro + rd*d.x;\n        n = GetNormal(p);\n        float reflectDif = GetLight(p, n, LightPos(), 1., 0.7, 0);\n\n        if(d.z == 1.) // torus reflection painting\n        {        \n            ret = torusCol(p, n, reflectDif, 0., false);\n            ret = vec3(ret.z,ret.y,ret.x);\n        }\n        float sphere_rad = 9.5;\n        \n        float a = smoothstep(0.,30.,length(0.7*(p-spherePos())));\n        //a *= a;\n        a = clamp(a, 0., 1.);\n        ret -= HalCol()*0.9*vec3(a);\n    }\n\n    return ret;\n    \n}\nvec3 applyHal(vec3 colToHal)\n{\n    // main halation\n    float a = 1.-halDist*0.1;\n    a *= a * a;\n    a = clamp(a, 0., 1.);\n    //float inside_sphere = smoothstep(5.,0.,halDist);\n    colToHal += HalCol()*vec3(a);\n\n    // sinusoidal halation\n    float b = smoothstep(0.,1.,halDist*0.1);\n    b = smoothstep(-1.,2.,0.5 + 0.5*sin(halDist*2.8));//smoothstep(0.,1.,0.5 + 0.5*sin(a*75.));\n    b = clamp(b,0.,1.);\n    b *= smoothstep( -3.,1., 1.-halDist); // masking outside of the object\n    b *= smoothstep(0., 1., halDist); // masking inside of the object\n    b = clamp(b,0.,1.) *sound*sound*sound ;\n    colToHal += vec3(b);\n    \n    return colToHal;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    init = true;\n    stop = false;\n    halDist = 10000.;\n    \n    bass = GET_BASS;\n    mid = GET_MID;\n    treb = GET_TREB;\n    sound = GET_SOUND;\n    bass_cont = GET_BASS_CONT;\n    mid_cont = GET_MID_CONT;\n    treb_cont = GET_TREB_CONT;\n    sound_cont = GET_SOUND_CONT;\n    \n    mouse = iMouse;\n\n\n    vec3 ret = vec3(0);\n    \n    vec3 lookat = cameralookat();\n    float zoom = 0.5 + 0.15*sin(time*0.4);//0.5 + 0.3*sin(time*0.326);\n    vec3 ro = camerapos();\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n    \n    vec3 d = RayMarch(ro,rd, MaxSteps);\n    vec3 p = ro + rd*d.x;\n    \n    ret = GetCol(ro, rd, p, d);\n    ret = applyFog(ret, d.x,0.05);\n    ret = applyHal(ret); // add halation around the object\n\n    fragColor = vec4(ret,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BufA(x, y) texture(iChannel2, (vec2(x, y) + 0.5) / iResolution.xy)\n#define GET_BASS_PURE BufA(0.,0.).x\n#define GET_BASS BufA(0.,3.).x\n#define GET_BASS_CONT BufA(0.,2.).x\n#define GET_MID_PURE BufA(1.,0.).x\n#define GET_MID BufA(1.,3.).x\n#define GET_MID_CONT BufA(1.,2.).x\n#define GET_TREB_PURE BufA(2.,0.).x\n#define GET_TREB BufA(2.,3.).x\n#define GET_TREB_CONT BufA(2.,2.).x\n#define GET_SOUND_PURE (GET_BASS_PURE + GET_MID_PURE + GET_TREB_PURE)/3.\n#define GET_SOUND (GET_BASS + GET_MID + GET_TREB)/3.\n#define GET_SOUND_CONT (GET_BASS_CONT + GET_MID_CONT + GET_TREB_CONT)/1.5\n\n# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200 // max steps for ray marching\n\nvec3 saturate(vec3 col)\n{\n    float gray = 0.2989 * col.x + 0.5870 * col.y + 0.1140 * col.z;\n    return vec3(gray);\n}\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\n\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\n\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r)\n{\n    float sphereDist = length(p)-r;\n    return sphereDist;\n}\n\n// by IQ\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/(k2.x*k2.x + k2.y*k2.y), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min((ca.x*ca.x + ca.y*ca.y),(cb.x*cb.x + cb.y*cb.y)) );\n}\n\n\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.732050808)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\n// Hexagon Coords by BigWings\n// ID's by Shane\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1., 1.732050808);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    \n    vec4 hC = floor(vec4(UV, UV - vec2(.5, 1))/r.xyxy) + vec4(.5, .5, 1, 1.5);\n    vec2 final_hC = dot(a, a) < dot(b,b) ? hC.xy : hC.zw;\n    //angle, dist from center, id_x, id_y\n    return vec4(x, y, final_hC);\n}\n\n// from https://timcoster.com/2020/02/13/raymarching-shader-pt3-smooth-blending-operators/\nfloat cappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nfloat smoothIntersectSDF(float distA, float distB, float k ) \n{\n    float h = clamp(0.5 - 0.5*(distA-distB)/k, 0., 1.);\n    return mix(distA, distB, h ) + k*h*(1.-h); \n}\nfloat smoothUnionSDF(float distA, float distB, float k ) {\n    float h = clamp(0.5 + 0.5*(distA-distB)/k, 0., 1.);\n    return mix(distA, distB, h) - k*h*(1.-h); \n}\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n    float h = clamp(0.5 - 0.5*(distB+distA)/k, 0., 1.);\n    return mix(distA, -distB, h ) + k*h*(1.-h); \n}", "buffer_a_code": "# define time iTime\n\n// bass bands\n# define BASS_START 0\n# define BASS_END 14\n// middle bands\n# define MID_START 15\n# define MID_END 143\n// treble bands\n# define TREBLE_START 144\n# define TREBLE_END 511\n\n/*------------ Tuning ------------*/\n\n/*---- Smooth Sound values ----*/\n// lower value - less time for the smooth sound stay on top of the pure sound\n#define DECREASE_MIN 0.001\n// lower value - lower decrease time. should be above 1.\n#define DECREASE_MUL 5.\n\n/*---- Smooth Sound Continues values ----*/\n/* play with this to get smaller\\bigger \"acceleration\" for the circles\n   lower value - more deceleration\n   should be below 1 */\n#define DELTA_INCREASE 0.1\n\n/* should be a value between 0 and 1\n   play with this to get smaller\\bigger \"deceleration\" for the circles\n   lower value - less acceleration */\n#define DELTA_MUL 0.9\n\n/* bigger DELTA_COUNT_MAX value will take into account more of the \"acceleration\"\n   lower value will restrain the acceleration\n   in other words - saturate it */\n#define DELTA_COUNT_MAX 8.\n\nfloat getSound(int start, int end)\n{\n    float ret = 0.;\n    for(int i = start; i <= end; i++)\n    {\n        float samp = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n        \n        samp = samp*samp + 0.5*samp;\n        if(samp > 0.8)\n            samp *= 0.8; // just to reduce the magnitude of the low frequencies\n        ret += samp;\n    }\n    \n    ret /= float(end - start + 1);\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float fpsInv = 60./iFrameRate;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 operation = fragCoord - 0.5;\n\n    int start, end;\n    \n    float sound; // pure sound samples average\n    float prev_sound; // previous sound\n    float smooth_sound; // smooth sound\n    float prev_smooth_sound; // previous smooth sound\n    float decrease;\n    float smooth_sound_cont; // smooth sound continues\n    float prev_smooth_sound_cont; // previous smooth sound continues\n    float delta;\n    float delta_count;\n\n    // Initialize values\n    if(iFrame == 0)\n    {\n        sound = 0.;\n        prev_sound = 0.;\n        smooth_sound = 0.;\n        prev_smooth_sound = 0.;\n        decrease = 0.;\n        smooth_sound_cont = 0.;\n        prev_smooth_sound_cont = 0.;\n        delta = 0.;\n        delta_count = 0.;\n    }\n    \n    // fragCoord.x determines to calculate bass\\mid\\treble\n    if(operation.x == 0.) { start = BASS_START; end = BASS_END;}\n    if(operation.x == 1.) { start = MID_START; end = MID_END;}\n    if(operation.x == 2.) { start = TREBLE_START; end = TREBLE_END;}\n    \n    // prev sound\n    sound = getSound(start, end);\n    prev_sound = BufA(operation.x, 0.).x;\n    \n    // sound type 2\n    prev_smooth_sound_cont = BufA(operation.x, 2.).x;\n    prev_smooth_sound = BufA(operation.x, 3.).x;;\n    decrease = BufA(operation.x, 4.).x;\n    if(sound > prev_smooth_sound)\n    {\n        smooth_sound = sound;\n        decrease = DECREASE_MIN;\n    }\n    else\n    {\n        smooth_sound = prev_smooth_sound - decrease;\n        decrease *= 1. + iTimeDelta * DECREASE_MUL;\n    }\n    \n    // smooth_sound_cont - circles motion\n    delta = BufA(operation.x, 5.).x;\n    delta_count = BufA(operation.x, 6.).x;\n    if(sound > prev_sound)\n    {\n        // this statement is to prevent exreme acceleration, when bass\\middle\\treble goes higher very quickly.\n        // in other words - saturate it.\n        // bigger value - accept a bigger acceleration.\n        // to notice the difference, just comment the if statement and reset the shader,\n        // then look at the blue circle which represent the treble\n        if(delta_count < DELTA_COUNT_MAX)\n        {\n            //delta += DELTA_INCREASE;\n            delta += iTimeDelta * DELTA_INCREASE;\n            delta_count += 1.; // for each delta increase\n        }\n    }\n    else\n    {\n        delta_count = 0.; // reset the counting\n        delta *= DELTA_MUL;\n    }\n    smooth_sound_cont = smooth_sound*iTimeDelta + delta + prev_smooth_sound_cont; \n    \n    // to prevent the value to go extremely high, can be useful in some cases when we only care about the fraction value\n    //if(smooth_sound_cont > 50.)\n    //    smooth_sound_cont -= floor(smooth_sound_cont);\n    \n    // fragCoord.y determines to calculate sound\\smoth_sound\\etc..\n    if(operation.y == 0.)\n        fragColor = vec4(sound, 0.,0.,1.0);\n    if(operation.y == 2.)\n        fragColor = vec4(smooth_sound_cont, 0.,0.,1.0);\n    if(operation.y == 3.)\n        fragColor = vec4(smooth_sound, 0.,0.,1.0);\n    if(operation.y == 4.)\n        fragColor = vec4(decrease, 0.,0.,1.0);\n    if(operation.y == 5.)\n        fragColor = vec4(delta, 0.,0.,1.0);\n    if(operation.y == 6.)\n        fragColor = vec4(delta_count, 0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31800, "src": "https://soundcloud.com/giraffage/feels", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[573, 573, 588, 588, 616], [617, 617, 632, 632, 669], [671, 671, 689, 689, 712], [713, 713, 732, 732, 756], [770, 770, 792, 792, 852], [1052, 1052, 1070, 1070, 1140], [1141, 1141, 1160, 1160, 1171], [1172, 1172, 1215, 1215, 1300], [1302, 1302, 1320, 1320, 1347], [1348, 1348, 1370, 1370, 1396], [1397, 1397, 1414, 1414, 1581], [1584, 1584, 1623, 1623, 3927], [3929, 3929, 3961, 3961, 4397], [4399, 4399, 4421, 4421, 6749], [6750, 6750, 6795, 6795, 7016], [7017, 7017, 7041, 7041, 7256], [7257, 7257, 7360, 7360, 7670], [7672, 7672, 7773, 7773, 8037], [8039, 8039, 8160, 8160, 8594], [8595, 8595, 8660, 8660, 8947], [8949, 8949, 9028, 9028, 9409], [9411, 9411, 9459, 9459, 9705], [9707, 9707, 9871, 9911, 10124], [10126, 10126, 10174, 10174, 11227], [11228, 11228, 11258, 11279, 11875], [11876, 11876, 11933, 11933, 12919]], "test": "untested"}
{"id": "DlB3Rm", "name": "golf: half-tweet tiling", "author": "FabriceNeyret2", "description": "variant of  https://shadertoy.com/view/ctjGzD", "tags": ["2d", "tiling", "short", "tweet", "halftweet", "golf"], "likes": 9, "viewed": 283, "published": 3, "date": "1672994839", "time_retrieved": "2024-07-30T18:17:34.067327", "image_code": "// variant of  https://shadertoy.com/view/ctjGzD\n\n\n/**/  void mainImage(out vec4 o,vec2 u) {\n    o*=0.;\n    o[ ( int( u *=.1 ) + int(u.y) ) %3 ]++;\n}\n\n/**/\n\n\n\n\n\n/** // --- Xor's variant:\n\nvoid mainImage(out vec4 o,vec2 u) {\n    o*=0.;\n    o[ int( u *=.1 ) + int(u.y) &3 ]++;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlB3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dljGzW", "name": "aphex twin logo 2", "author": "jonasfrey", "description": "finally i made it! although it is not very accurate, but recognizable for sure :)", "tags": ["logo"], "likes": 5, "viewed": 232, "published": 3, "date": "1672962524", "time_retrieved": "2024-07-30T18:17:35.137467", "image_code": "vec2 f_o_rotd(vec2 o, float n_ang){\n    return vec2(\n        cos(n_ang)*o.x - sin(n_ang)*o.y, \n        sin(n_ang)*o.x + cos(n_ang)*o.y\n    );\n}\n\nfloat f_sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    float k = c.x*q.y - c.y*q.x;\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_iresx_to1 = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    o_trn_fc_nor_offset *= 1.2;\n    o_trn_fc_nor_offset += vec2(0., -0.2);\n    float n_r, n_dist, n_fuzz, n_smst_1, n_smst_2, n_d; \n\n     n_r = 0.05;\n     n_d = f_sdUnevenCapsule(\n        o_trn_fc_nor_offset, \n        vec2(-0.38, 0.0), \n        vec2(-0.0, 0.0), \n        n_r, \n        n_r\n    );\n     n_fuzz = n_ratio_iresx_to1*10.;\n     n_smst_1 = 0.01; \n     n_smst_2 = 0.01+n_fuzz;\n    \n    n_dist += smoothstep(n_smst_2, n_smst_1, n_d);\n    \n    \n    \n    // \n    \n    \n     n_r = 0.05;\n     n_d = f_sdUnevenCapsule(\n        o_trn_fc_nor_offset+vec2(0., 0.05), \n        vec2(-0.0, 0.0), \n        vec2(0.21, -.38), \n        n_r*1.9, \n        n_r*0.6\n    );\n     n_fuzz = 0.01;\n     n_smst_1 = 0.01; \n     n_smst_2 = 0.01+n_fuzz;\n    \n    n_dist += smoothstep(n_smst_2, n_smst_1, n_d);\n    \n    \n    // \n    \n        \n     n_r = 0.023;\n     n_d = f_sdUnevenCapsule(\n        o_trn_fc_nor_offset+vec2(0., 0.05), \n        vec2(-0.1, 0.0), \n        vec2(-0.3, -.33), \n        n_r*2.1, \n        n_r\n    );\n     n_fuzz = 0.01;\n     n_smst_1 = 0.01; \n     n_smst_2 = 0.01+n_fuzz;\n    \n    n_dist += smoothstep(n_smst_2, n_smst_1, n_d);\n    \n    // \n      \n     n_d = length(vec2(-0.16, -0.22)-o_trn_fc_nor_offset);\n     n_fuzz = 0.01;\n     n_smst_1 = 0.055; \n     n_smst_2 = 0.055+n_fuzz;\n    \n    n_dist +=  smoothstep(n_smst_2, n_smst_1, n_d);\n    \n    \n    // \n    \n     n_d = length(vec2(-0.099, -0.152)-o_trn_fc_nor_offset);\n     n_fuzz = 0.01;\n     n_smst_1 = 0.027; \n     n_smst_2 = 0.027+n_fuzz;\n    \n    \n    n_dist *= 1.- smoothstep(n_smst_2, n_smst_1, n_d);\n   \n            \n     n_r = 0.023;\n     n_d = f_sdUnevenCapsule(\n        o_trn_fc_nor_offset+vec2(0., 0.05), \n        vec2(-0.2, 0.01), \n        vec2(-0.4, -.33), \n        n_r*0.8, \n        n_r*0.8\n    );\n     n_fuzz = 0.01;\n     n_smst_1 = 0.01; \n     n_smst_2 = 0.01+n_fuzz;\n     \n    n_dist *= 1.- smoothstep(n_smst_2, n_smst_1, n_d);\n\n\n     n_r = 0.023;\n     n_d = f_sdUnevenCapsule(\n        o_trn_fc_nor_offset,\n          vec2(-0.2, -0.03),\n        vec2(-0.2*abs(1.-o_trn_fc_nor_offset.x*10.), -0.5), \n        //vec2(-0.5, 0.5), \n        n_r*0.8, \n        n_r*0.8\n    );\n     n_fuzz = 0.01;\n     n_smst_1 = 0.01; \n     n_smst_2 = 0.01+n_fuzz;\n     \n    n_dist *= 1.- smoothstep(n_smst_2, n_smst_1, n_d);\n    \n    \n    //n_dist *= 1.-smoothstep(n_smst_2, n_smst_1, n_d);\n    \n     n_d = length(vec2(-0.1, -0.2)-o_trn_fc_nor_offset);\n\n     float n_thick = 0.03;\n     float n_radius = 0.5;\n\n    n_dist += smoothstep(\n        //0.5,\n        2./iResolution.y,\n        0.,\n        //abs(n_d-0.5)*(1.-n_thick)\n        abs(n_d-n_radius)-n_thick*.5\n    );\n    \n\n    \n    fragColor = vec4(n_dist);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 143], [145, 145, 233, 233, 724], [726, 726, 783, 816, 3874]], "test": "untested"}
{"id": "mtjGRW", "name": "circular eq", "author": "jonasfrey", "description": "eq", "tags": ["eq"], "likes": 3, "viewed": 203, "published": 3, "date": "1672958262", "time_retrieved": "2024-07-30T18:17:35.999162", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    \n\n    float n_tau = 6.2831;\n\n    float n_its = 400.;\n    \n    // first value is normal, second is inverted (1.-x)\n    vec2 o_dist_min = vec2(1.);\n    vec2 o_dist_sum = vec2(0.);\n    vec2 o_dist_prod = vec2(1.);\n    float n_it_dmin = 0.;\n    float n_golden_ratio = 1.61803398875;\n    \n\n    float n_freq_hz_min = 40.;\n    float n_freq_hz_max = 20000.;\n    float n_freq_hz_range = n_freq_hz_max-n_freq_hz_min;\n    \n    float n_freq_hz_target = 80.;//a good bass\n    float n_freq_hz_target_nor = n_freq_hz_target/n_freq_hz_range;\n    float n_amp_toggle = texture(iChannel0, vec2(n_freq_hz_target_nor, 0.)).x;//freqdomain\n    \n    float n_wave_rad = n_amp_toggle;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_it_nor = n_it / n_its;\n        float n_amp_timedomain = texture(iChannel0, vec2(n_it_nor, 1.)).x;\n        float n_amp_freqdomain = texture(iChannel0, vec2(n_it_nor, 0.)).x;\n    \n        float n_radius = (1./n_its)*n_it;\n        float n_ang_nor = (1./n_its)*n_it*10.;\n        n_ang_nor += iTime*n_it_nor*0.2;//n_it_nor*(1.-n_radius);//(n_it_nor*n_it_nor)*0.02;\n        //n_ang_nor = n_it * n_golden_ratio;\n        float n_diff_wav_rad = (n_radius-n_wave_rad);\n        if(n_diff_wav_rad > 0.1){\n            n_diff_wav_rad = 1.;\n        }\n        vec2 o_p = vec2(\n            sin(n_ang_nor*n_tau)*n_radius, \n            cos(n_ang_nor*n_tau)*n_radius\n        );\n        float n_dist = length(o_p - o_trn_fc_nor_offset);\n        n_dist *= n_amp_toggle;\n        n_dist *= n_amp_timedomain*5.+ n_amp_freqdomain*10.;\n        n_dist = pow(n_dist, 1./1.4);\n        n_dist +=n_dist*n_diff_wav_rad*0.1;\n        if(n_dist < o_dist_min.x){\n            o_dist_min = vec2(n_dist, 1.-n_dist);\n            n_it_dmin = n_it;\n        }\n    }\n    \n    \n    fragColor = vec4(o_dist_min.x);\n}", "image_inputs": [{"id": 31934, "src": "https://soundcloud.com/narutouzumaki-nu12/naruto-ost-hinata-vs-neji?in=joscie-santos/sets/naruto-soundtrack&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2200]], "test": "untested"}
{"id": "Dtj3zW", "name": "3D Audio Visualizer #2", "author": "kishimisu", "description": "An audio-reactive scene that maps the frequencies of the input music \n   and the audio volume to different cells, colors, size and intensity!", "tags": ["raymarching", "sound", "visualization", "reactive", "music", "live", "neon"], "likes": 60, "viewed": 1749, "published": 3, "date": "1672946684", "time_retrieved": "2024-07-30T18:17:36.830938", "image_code": "/* @kishimisu - 2023\n\n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n   An audio-reactive scene that maps the frequencies of the input music \n   and the audio volume to different cells, colors, size and intensity!\n\n   I've been struggling to complete this scene as I wanted to repeat\n   the space with random variations for each cell. There's a wonderful\n   tutorial by Blackle Mori explaining how to achieve this (https://www.youtube.com/watch?v=I8fmkLK1OKg) ,\n   however I'm using an accumulation technique for the lighting with a\n   fixed number of steps (30) which gets broken with this new technique.\n   \n   I decided to keep a reasonable random variation amount to prevent having \n   raymarching artifacts that are too visible. I couldn't get totally rid of them,\n   however with this kind of audio reactive scene it seems to be more acceptable\n   as there's a lot of rapid movements!\n*/\n\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n#define rot(a) mat2(cos(a + vec4(0,33,11,0)))\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1,.0,.14);\n    float vol = getVol(8.);\n    \n    vec3 ro = vec3(0, 8, 12)*(1. + vol*.3);\n    ro.zx *= rot(iTime*.4);    \n    vec3 f = normalize(-ro), r = normalize(cross(vec3(0,1,0), f));\n    vec3 rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n    \n    float hasSound = 1.; if (iChannelTime[0] <= 0.) hasSound = .4;\n    \n    for (float i = 0., t = 0.; i < 30.; i++) {\n        vec3 p  = ro + t*rd;        \n        \n        vec2 cen = floor(p.xz) + .5;\n        vec3 id = abs(vec3(cen.x, 0, cen.y));\n        float d = length(id);\n        \n        float freq = smoothstep(0., 20., d)*3.*hasSound + hash13(id)*2.;\n        float pitch = getPitch(freq, .7);\n        \n        float v  = vol*smoothstep(2., 0., d);\n        float h  = d*.2*(1.+pitch*1.5) + v*2.;\n        float me = sdBox(p - vec3(cen.x, -50., cen.y), vec3(.3, 50. + h, .3)+pitch) - .05;\n        \n        col += mix(mix(vec3(.8,.2,.4), vec3(0,1,0), min(v*2.,1.)), vec3(.5,.3,1.2), smoothstep(10., 30., d))\n               *(cos(id)+1.5)\n               * (pitch * d*.08 + v)\n               * light(me, 20.) * (1. + vol*2.);\n        \n        t += me;\n    }\n    \n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [{"id": 31826, "src": "https://soundcloud.com/user-696655073-435379126/voidcall", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtj3zW.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1268, 1268, 1297, 1297, 1413], [1414, 1414, 1455, 1455, 1573], [1574, 1574, 1603, 1603, 1720], [1752, 1752, 1783, 1783, 1870], [1871, 1871, 1894, 1894, 1997], [1999, 1999, 2056, 2056, 3288]], "test": "untested"}
{"id": "mlS3zD", "name": "Irregular  Rectangle Tiling II", "author": "mla", "description": "As before, but with some simplifications, and now with UV calculations for each tile. 'x' shows tile distance field.", "tags": ["rectangle", "tiling", "irregular"], "likes": 20, "viewed": 296, "published": 3, "date": "1672939187", "time_retrieved": "2024-07-30T18:17:37.654735", "image_code": "/////////////////////////////////////////////////////////////////\n//\n// Irregular Rectangle Tiling, mla, 2023\n//\n// Inspired by:\n// https://www.shadertoy.com/view/Dt2GRz (@jt)\n// https://www.shadertoy.com/view/Ws3GRs (@Shane)\n// https://www.shadertoy.com/view/7tKGRc (@Gelami)\n//\n// This one works out the actual tile dimensions eg. for texturing \n// or for a proper tile SDF.\n//\n// 'b': don't show tile border\n// 'c': show underlying grid.\n// 'x': show tile SDF\n// 'y': tile offset style\n// 'z': zoom out\n//\n/////////////////////////////////////////////////////////////////\n\n// An SDF for the region to be filled - this must have a boundary\n// (ie. distance == 0) on integer gridlines\nfloat regiondist(vec2 p) {\n  vec2 repeat = vec2(8,5);\n  p += repeat; p = mod(p,2.0*repeat); p -= repeat;\n  p = abs(p);\n  float d0 = max(p.x-5.0,p.y-3.0);\n  float d1 = p.x-2.0;\n  return min(-d0,d1);\n}\n\nfloat offset(vec2 p, bool flip, bool xoffset) {\n  // Find the two grid points that share this offset\n  vec2 delta = xoffset ? vec2(0,1) : vec2(1,0);\n  vec2 q0 = p-delta;\n  vec2 q1 = p+delta;\n  if (flip) { p = p.yx; q0 = q0.yx; q1 = q1.yx; }\n  // NB: grid points _on_ the boundary have offset 0, but only if one or both\n  // of the adjacent points is also on the boundary.\n  if (regiondist(p) > 0.0) return 0.0;\n  if (regiondist(p) == 0.0 && (regiondist(q0) == 0.0 || regiondist(q1) == 0.0)) return 0.0;\n  if (!key(CHAR_Y)) return 0.48*(sin(p.x+0.5*iTime)*sin(p.y+0.382*iTime));\n  float t = rand(ivec2(p)^int(iTime));\n  return 0.95*(t-0.5);\n}\n\n// (Interior) distance to rectangle, corners (x0,y0), (x1,y1)\nfloat rect(vec2 p, float x0, float y0, float x1, float y1) {\n  return min(min(abs(p.x-x0),abs(p.x-x1)),\n             min(abs(p.y-y0),abs(p.y-y1)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float lwidth = 0.01;\n  float scale = 6.0;\n  if (key(CHAR_Z)) scale *= 2.0;\n  vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) p -= m;\n  p *= scale;\n  //p += 0.02*sin(p.x+p.y); // Perturb coordinates (idea by Shane)\n  vec3 col = vec3(0.1);\n  float px = fwidth(p.x);\n  float rdist = regiondist(p);\n  if (rdist > 0.0) {\n    // Just show region border\n    if (!key(CHAR_B)) col *= smoothstep(0.0,px,rdist-lwidth);\n  } else {\n    vec2 ix = round(p);\n    p -= ix; // Rebase at nearest grid point\n    bool flip = mod(ix.x+ix.y,2.0) != 0.0;\n    if (flip) { p = p.yx; ix = ix.yx; } // Fix orientation\n    float x0 = offset(ix,flip,true); // Offset of vertical line\n    float d = p.x-x0;\n    int xdelta = d < 0.0 ? -1 : 1; // x direction of other tile corner\n    float y0 = offset(ix+vec2(xdelta,0),flip,false); // Offset of horizontal line\n    float d1 = p.y-y0;\n    int ydelta = d1 < 0.0 ? -1 : 1; // y direction of other tile corner\n    // Work out tile uv from coordinates of other corner\n    float x1 = float(xdelta)+offset(ix+vec2(xdelta,ydelta),flip,true);\n    float y1 = float(ydelta)+offset(ix+vec2(0,ydelta),flip,false);\n    sort(x0,x1); sort(y0,y1);\n    vec2 uv = (p-vec2(x0,y0))/(vec2(x1,y1)-vec2(x0,y0));\n    if (flip) uv = uv.yx;\n    // Work out tile id from coordinates of left bottom corner\n    if (d < 0.0) ix.x--;\n    if (d1 < 0.0) ix.y--;\n    if (flip) ix = ix.yx; // ix is now the tile id\n    col = 0.25+0.75*h2rgb(rand(ivec2(ix)));\n    col *= length(texture(iChannel0,uv).rgb);\n    if (key(CHAR_C) && flip) col *= 0.5;\n    if (key(CHAR_X)) col *= 0.8-0.2*cos(0.6*PI/px*rect(p,x0,y0,x1,y1));\n    d = min(abs(d),abs(d1));\n    if (!key(CHAR_B)) col *= smoothstep(0.0,px,d-lwidth);\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nconst float PI = 3.14159;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nvoid swap (inout float x, inout float y) {\n  float t = x; x = y; y = t;\n}\n\nvoid sort (inout float x, inout float y) {\n  if (x > y) swap(x,y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlS3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 686, 712, 712, 885], [887, 887, 934, 987, 1528], [1530, 1592, 1652, 1652, 1741], [1743, 1743, 1795, 1795, 3639]], "test": "untested"}
{"id": "mlB3RD", "name": "Conic section lagrange mult.", "author": "NinjaKoala", "description": "A conic section and a curve derived from the lagrange multiplier with respect to the distance to the mouse point.\nBackground is the visualization of the basins of attraction for an iteration which computes the intersection of both curves.", "tags": ["2d", "distancefield", "distance", "curve", "implicit", "lagrange", "conicsection"], "likes": 4, "viewed": 228, "published": 3, "date": "1672933622", "time_retrieved": "2024-07-30T18:17:38.432656", "image_code": "/*\nThis is a variaton of https://www.shadertoy.com/view/DsjXRh\nwhich uses a general conic section in place of the ellipse.\n\nI also added parametrization of the lagrange curve and dot oscillating around the mouse.\n*/\n//#define SHOW_DISTANCE_FIELD\n//#define PARAMETRIC\n\nvec3 bg_col = vec3(1);\nvec3 conic_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 2.;\n\nconst int num_iterations = 16;\nint aa = 2;\n\nconst float pi = 3.1415925;\n\nconst float a_param = 7.;\nconst float b_param = -7.;\nconst float c_param = 0.;\nconst float d_param = 0.;\n\nfloat conic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x*a_param + c_param, 2.*p.y*b_param + d_param);\n\treturn p.x*(p.x*a_param + c_param) + p.y*(p.y*b_param + d_param) + 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n    grad = vec2(2.*(a_param*(p.y-p2.y)-p.y*b_param) - d_param,\n                2.*(b_param*(p2.x-p.x)+p.x*a_param) + c_param);\n    return 2.*(p.x*a_param*(p.y-p2.y)-p.y*b_param*(p.x-p2.x)) + c_param*(p.y-p2.y) - d_param*(p.x-p2.x);\n}\n\nvec2 lagrange_curve_parametric(float t, vec2 p0){\n    return vec2(1./t, -(d_param*t*p0.x - (c_param*t + 2.*a_param)*p0.y - d_param)\n                      /(2.*b_param*t*p0.x + c_param*t + 2.*a_param - 2.*b_param));\n}\n\nvec2 lagrange_curve_parametric_diff(float t, vec2 p0){\n    //-(2*a*x0 + c)*(2*b*y0 + d)/(2*b*t*x0 + c*t + 2*a - 2*b)^2\n    float denom = (t * (b_param*p0.x + c_param/2.) + a_param - b_param);\n    denom *= denom;\n    \n    return vec2(-1./(t*t), -(a_param*p0.x+c_param)*(b_param*p0.y+d_param) / denom);\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat parametric_iteration(float t0, vec2 uv){\n    vec2 p0 = lagrange_curve_parametric(t0, uv);\n    \n    vec2 grad;\n    float conic_val = conic_curve(p0, grad);\n    \n    vec2 diff = lagrange_curve_parametric_diff(t0, uv);\n    \n    return t0 - conic_val / dot(diff,grad);\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tconst mat2 aa_rot = mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum = vec3(0);\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\taa = 1;\n\tmouse = uv;\n\t#endif\n\n\tvec2 p1;\n\tfor(int x = 0;x<aa;x++){\n\t\tfor(int y = 0;y<aa;y++){\n\t\t\tvec2 aa_offset = (vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset *= zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tp1 = uv+aa_offset;\n\n\t\t\tfor(int i = 0;i<num_iterations;i++){\n\t\t\t\tp1 = iteration(p1, mouse);\n\t\t\t}\n\n\t\t\tcol_sum += pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col = pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col *= .75;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 conic_grad;\n\tfloat conic_val = conic_curve(uv, conic_grad);\n\n\tdis = min(dis, abs(conic_val / length(conic_grad)) - line_width);\n\tcolor = mix(conic_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n    \n    float t0 = 1. / mouse.x;\n    \n    vec2 pt = lagrange_curve_parametric(t0+.1*sin(3.*iTime),mouse);\n\n\tdis = min(dis, distance(uv,p1) - dot_size);\n    dis = min(dis, distance(uv,pt) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n\n\t#ifdef SHOW_DISTANCE_FIELD\n    #ifdef PARAMETRIC\n    for(int i=0;i<num_iterations;i++){\n        t0 = parametric_iteration(t0, uv);\n    }\n    p1 = lagrange_curve_parametric(t0,uv);\n    #endif\n\tdis = distance(uv,p1);\n\tfloat sgn = 1.;\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 666, 666, 806], [808, 808, 861, 861, 1095], [1097, 1097, 1146, 1146, 1313], [1315, 1315, 1369, 1433, 1617], [1619, 1619, 1651, 1651, 1878], [1880, 1880, 1926, 1926, 2152], [2154, 2154, 2178, 2178, 2254], [2256, 2256, 2276, 2276, 2396]], "test": "untested"}
{"id": "mlSGzW", "name": "Elliptic curve lagrange mult.", "author": "NinjaKoala", "description": "An elliptic curve and a curve derived from the lagrange multiplier with respect to the distance to the mouse point.\nBackground is the visualization of the basins of attraction for an iteration which computes the intersection of both curves.", "tags": ["2d", "distancefield", "distance", "curve", "implicit", "lagrange", "ellipticcurve"], "likes": 5, "viewed": 245, "published": 3, "date": "1672927308", "time_retrieved": "2024-07-30T18:17:39.310310", "image_code": "/*\nThis is a variaton of https://www.shadertoy.com/view/DsjXRh\nwhich uses an elliptic curve in place of the ellipse.\n\nUpdate: Added parametrization of the lagrange curve and dot oscillating around the mouse.\n*/\n//#define SHOW_DISTANCE_FIELD\n\nvec3 bg_col = vec3(1);\nvec3 elliptic_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 2.;\n\nconst int num_iterations = 16;\nint aa = 2;\n\nconst float pi = 3.1415925;\n\nconst float a_param = -.3;\nconst float b_param = .3;\n\nfloat elliptic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(3.*p.x*p.x + a_param, -2.*p.y);\n\treturn (p.x*p.x + a_param) * p.x + b_param - p.y*p.y;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n\tgrad = vec2(6.*p.x*(p.y-p2.y)+2.*p.y, 3.*p.x*p.x + 2.*p.x - 2.*p2.x + a_param);\n\treturn p.x*(3.*p.x*(p.y - p2.y) + 2.*p.y) - 2.*p.y*p2.x + (p.y-p2.y)*a_param;\n}\n\nvec2 lagrange_curve_parametric(float t, vec2 p0){\n    return vec2(1./t, (a_param*t*t + 3.)*p0.y/(((a_param-2.*p0.x)*t + 2.)*t + 3.));\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = elliptic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tconst mat2 aa_rot = mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum = vec3(0);\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\taa = 1;\n\tmouse = uv;\n\t#endif\n\n\tvec2 p1;\n\tfor(int x = 0;x<aa;x++){\n\t\tfor(int y = 0;y<aa;y++){\n\t\t\tvec2 aa_offset = (vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset *= zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tp1 = uv+aa_offset;\n\n\t\t\tfor(int i = 0;i<num_iterations;i++){\n\t\t\t\tp1 = iteration(p1, mouse);\n\t\t\t}\n\n\t\t\tcol_sum += pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col = pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col *= .75;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 elliptic_grad;\n\tfloat elliptic_val = elliptic_curve(uv, elliptic_grad);\n\n\tdis = min(dis, abs(elliptic_val / length(elliptic_grad)) - line_width);\n\tcolor = mix(elliptic_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n    \n    float t0 = 1. / mouse.x;\n    vec2 pt = lagrange_curve_parametric(t0+.1*sin(3.*iTime),mouse);\n\n\tdis = min(dis, distance(uv,p1) - dot_size);\n    dis = min(dis, distance(uv,pt) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\tdis = distance(uv,p1);\n\tfloat sgn = 1.;\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 594, 594, 696], [698, 698, 751, 751, 913], [915, 915, 964, 964, 1050], [1052, 1052, 1084, 1084, 1314], [1316, 1316, 1340, 1340, 1416], [1418, 1418, 1438, 1438, 1558]], "test": "untested"}
{"id": "7ldfzS", "name": "Asymmetric Spherical Jigsaw Map", "author": "Shane", "description": " Partitioning a sphere into subdivided icosahedral cells then mapping an animated asymmetric jigsaw pattern onto it.", "tags": ["sphere", "map", "hexagon", "icosahedron", "polyhedron", "jigsaw"], "likes": 56, "viewed": 1059, "published": 3, "date": "1672925516", "time_retrieved": "2024-07-30T18:17:40.601856", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Asymmetric Spherical Jigsaw Map\n    -------------------------------\n    \n    Partitioning a sphere into subdivided icosahedral cells then mapping an \n    animated asymmetric jigsaw pattern onto it. \n    \n    I've been meaning to post one of these for ages. This particular version\n    has been sitting in my account for a while. I have a proper 3D version as\n    well, but that needs some work before I can release it.\n    \n    The pattern isn't unique, but there aren't a lot of these around, and I'm \n    pretty confident that no one has bothered to put together a pixelshader \n    version. There are many reasons why, but in essence, working with \n    neighboring cells on a subdivided icosahedron isn't a fun task. :) There \n    was also the matter of figuring out how to produce an assymetric hexagon\n    pattern that was fast enough to construct and render in realtime.\n    \n    Anyway, I just wanted to release one of these in any form. I'll work on \n    some more interesting versions later. And in case anyone was wondering, \n    this provides and interesting means with which to render almost pixel \n    perfect extruded Voronoi looking cells onto the surface of a sphere, \n    amongst other things.\n    \n    In regard to future improvements, there are too many to name. The one I'll \n    mention is that I used actual vertex locations as ID points, which is not \n    accurate at all, so I had to snap each ID point to an integer prior to \n    hashing. This is not ideal. However comming up with an ID system on a \n    subdivided icosahedron would require some forthought... Maybe next time. :)\n    \n    By the way, I tidied this and commented it up in a hurry, but I'll clean \n    it up properly when I get a chance. I'll attempt to get the compile time \n    down on systems that rely on ANGLE also. This example relies a lot on arrays, \n    but from what I understand, ANGLE doesn't deal well with them. This is \n    unfortunate, because I hear that arrays can be useful to coders. :)\n    \n    \n\n\tSimialr examples:\n    \n    // Using a triangle grid to create and raymarch an animated \n    // extruded rounded asymmetric hexagon jigsaw pattern in realtime.\n    Extruded Asymmetric Jigsaw - Shane\n    https://www.shadertoy.com/view/NlKfWt\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n \n\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./4.*2.); \n\n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.5))) - 16.);\n     // Flat plane back wall.\n    float wall = -p.z + 2.5;// - (length(p.xy) - .5)*.125;\n    //float wall = -p.z + 2.5 + dot(sin(p.xy*2. - cos(p.yx*4.)*1.57), vec2(1./2.))*.1;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\n// It's been rewritten based on Spalmer's suggestion.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \n\n/*\n// Spalmer's normal function. It's definitely better, but I'd like\n// to tinker with a bit first before using it. :)\nvec3 getNormal(vec3 q, float h){\n\n    vec3 e = vec3(1, 0, 0), g = e.zzz;\n    for (int i = ZERO + 6; \n            i-- > 0;\n            g += map(q + h * e)*e, e = e.zxy)\n        if (i == 2) e = -e;\n    return normalize(g);\n}\n*/\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the \n    // lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n\n/////////\n// Normalizing and scaling.\nmat3x3 nrmSclMat(mat3x3 m, float rad){\n    \n    return mat3x3(normalize(m[0]), normalize(m[1]), normalize(m[2]))*rad;\n}\n\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector.\nvec3 dir;\nint sID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 q, inout mat3x3 gVertID, const float rad){\n       \n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems. The bottom section is \n    // rotated by PI/5 about the equator.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.);\n    sph = fract((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX)*TAU;\n    //sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    const vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    const vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Skip the top or bottom strip, depending on whether we're in the\n    // northern or southern hemisphere.\n    ivec3 iR = q.y<0.? ivec3(1, 2, 3) : ivec3(0, 1, 3);\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point. Usually, only one\n    // two strips are normally checked, but three are checked here on account \n    // of faux shadow rendering.\n    for(int k = ZERO; k<3; k++){ \n\n        int i = iR[k];\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i&1], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n    \n    // X - coordinates for all three vertices.\n    vec3 ax = mod(vec3(0, -PI/5.*baseFlip, PI/5.*baseFlip) + TAU + sph[id], TAU);\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID = mat3x3(vec3(ax.x, ayT, rad), vec3(ax.y, ayB, rad), vec3(ax.z, ayB, rad));\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if ((id&1)==0) gVertID[0].x = 0.;\n\n    \n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n    \n    \n    return q;\n}\n\n\n/////////\n  \n// Incircle of a 3D triangle: Basically the 3D extension of\n// the 2D version... I was in a hurry, but it seems about right.\n// Let me know if the logic doesn't follow.\n// \nvec3 inCircle(in vec3 v0, in vec3 v1, in vec3 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    return mat3(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n// Sphere line, capped at \"b\".\nfloat sphereLineCapB(vec3 p, vec3 a, vec3 b, float rad){\n \n     \n     p /= rad; // Normalize p.\n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     vec3 perpB = b + cross((a - b), b);\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     \n     return max(abs(ln), endB);\n      \n}\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n// Swap functions.\nvoid swap(inout int a, inout int b){\n    int tmp = a; a = b; b = tmp;\n}\n\nvoid swap(inout float a, inout float b){\n    float tmp = a; a = b; b = tmp;\n}\n\n// Color palette.\nvec3 getColor(float x){\n\n    vec3 col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    if(hash11(x)>.5) col = vec3(x*.75 + .15)*vec3(.95, .95, 1.1);\n    \n    return col;\n}\n\n// Color palette.\nvec3 getColor2(float x){\n\n    vec3 col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    if(hash11(x)>.3) col = vec3(x*.75 + .15)*vec3(.95, .95, 1.1);\n    \n    return col;\n}\n\nfloat getGrey(vec3 x){ return dot(x, vec3(.299, .587, .114)); }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .5, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n        //vec3 h = normalize(ld - rd); \n        //float spec = pow(max(dot(h, sn), 0.), 32.); \n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.   \n        \n         \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0);  \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n        // Global time for the common tab.\n        setTime(iTime);\n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n             // Smoothing factor.\n            float sf = .003; \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            mat3x3 v, vID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vID, rad);\n    \n            v[0] = sphericalToWorld(vID[0]); \n            v[1] = sphericalToWorld(vID[1]);\n            v[2] = sphericalToWorld(vID[2]);\n            \n             \n             \n            // Edge mid points, edge tangents, etc.\n            mat3x3 vE;//, vN;\n            \n            // Edge mid points.\n            vE[0] = mix(v[0], v[1], .5);\n            vE[1] = mix(v[1], v[2], .5);\n            vE[2] = mix(v[2], v[0], .5);\n            vE = nrmSclMat(vE, rad); // Normalize and scale.\n           \n           \n            // Large triangle neighbors.\n            mat3x3 vNgbr;\n                       \n            for(int i = 0; i<3; i++){\n \n                vec3 vEU = vE[i];\n                vec3 v2N = reflect((vEU - v[(i + 2)%3]), (-vEU/rad)); \n                vNgbr[i] = vEU + v2N;//normalize(vEU + v2N)*rad;\n                \n            }\n \n            \n \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            \n            // Subdivided triangle neighbors.\n            //vec3[3] vNgbr2 = vec3[3](vec3(0), vec3(0), vec3(0));\n            \n            float midTri = 0.;\n            int subTriID = 0;\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = ZERO; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    // Upright large triangle, bottom left.\n                    vNgbr[0] = mix(vNgbr[0], v[1], .5); // Left.\n                    vNgbr[1] = mix(vNgbr[1], v[1], .5); // Bottom.\n                    vNgbr[2] = mix(v[2], v[0], .5); // Right.\n                    v[0] = vE[0]; v[2] = vE[1];\n                    subTriID = 0;\n                    midTri = 0.;\n                    \n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    // Upright large triangle, bottom right.\n                    vNgbr[0] = mix(v[0], v[1], .5); // Left.\n                    vNgbr[1] = mix(vNgbr[1], v[2], .5); // Bottom.\n                    vNgbr[2] = mix(vNgbr[2], v[2], .5); // Right.\n                    v[0] = vE[2]; v[1] = vE[1];\n                    subTriID = 1;\n                    midTri = 0.;\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    // Upright large triangle, top.\n                    vNgbr[0] = mix(vNgbr[0], v[0], .5); // Left.\n                    vNgbr[1] = mix(v[1], v[2], .5); // Bottom.\n                    vNgbr[2] = mix(vNgbr[2], v[0], .5); // Right.\n                    v[1] = vE[0]; v[2] = vE[2];\n                    subTriID = 2;\n                    midTri = 0.;\n                }\n                else {\n                \n                    // Neighboring v2 point is the original point.\n                    vNgbr = v;\n                    \n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n           \n                    if(sID%2==1) dir = -dir;\n                    else dir *= vec3(1, -1, 1);\n           \n                    \n                    if(midTri == 1. && sID%2==0){\n                       dir *= vec3(-1, -1, 1);\n                    }\n              \n                    midTri = 1.;\n                    subTriID = 3;\n                    \n                }\n \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = mix(v[0], v[1], .5);\n                vE[1] = mix(v[1], v[2], .5);\n                vE[2] = mix(v[2], v[0], .5);\n                vE = nrmSclMat(vE, rad); // Normalize and scale.\n                \n                vNgbr = nrmSclMat(vNgbr, rad);\n                \n                \n                \n            }\n            #endif\n            /////  \n            \n           \n            \n  \n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = v[0] + v[1] + v[2];\n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            //vec3 ctr = normalize(id)*rad;\n            vec3 ctr = normalize(inCircle(v[0], v[1], v[2]))*rad;;\n  \n \n \n\n \n           \n            vec3 mp = vec3(1e5), mp2 = vec3(1e5);\n            vec3 rc = vec3(1e5);\n            \n            vec3 vOffs; \n            \n            \n            vec3 ctrRnd = ctr + (hash31A(ctr) - .5)*.15/7.*1.;\n            ctrRnd = normalize(ctrRnd)*rad;\n \n            // Lines connecting the offset centers between neighboring edges.\n            vec3 ln = vec3(1e5);\n            for(int i = ZERO; i<3; i++){\n                \n                // Two random indices pointing to random entry and exit points.\n                int ip1 = (i + 1)%3;\n                //int ip2 = (i + 2)%3;\n                \n                vec3 v2N = vNgbr[i];\n                 \n                // Center point in the neighboring cell.\n                vec3 ctrNgbr = normalize(inCircle(v[i], v[ip1], v2N))*rad;\n               \n                // Neighboring cell center with random offset.\n                vec3 ctrNgbrRnd = ctrNgbr + (hash31A(ctrNgbr) - .5)*.15/7.*1.;\n                ctrNgbrRnd = normalize(ctrNgbrRnd)*rad;\n                \n                // Mid point between cells.\n                vec3 midRnd = mix(ctr, ctrNgbr, .5);\n                rc[i] = hash31(midRnd);\n                float mRnd = dir[i]*(rc[i]*2. - 1.);\n                float d = mRnd<0.? -1. : 1.;\n                // Point between the random center and random neighbor points.\n                vec3 vER = normalize(mix(ctrRnd, ctrNgbrRnd, .5))*rad;\n\n\n                // Tangent.\n                vec3 tn = normalize(cross(ctrRnd - vER, vER));\n                \n                // Jigsaw nodule offset.\n                #if SCHEME == 0\n                const float noduleOffset = .02;\n                #elif SCHEME == 1\n                const float noduleOffset = .012;\n                #else\n                const float noduleOffset = .004;\n                #endif\n                \n                // The nodule point and distance field.\n                vER = normalize(vER - d*tn*noduleOffset)*rad;\n                mp[i] = length(lq - vER);\n                \n                \n                // Offset hexagon line partitioning.\n                vec3 lnCntr = ctrNgbrRnd - ctrRnd; // Vector connecting centers.\n                float ed = (dot((lq/rad), cross(ctrRnd, ctrNgbrRnd))/length(lnCntr)); // Center line.\n                ln[i] = ed;\n                \n                \n                // Offset vertex point -- Technically not correct, but it looks the part.\n                vec3 vOffsI = normalize(v[i] + (hash31A(v[i]) - .5)*.15/7./1.5)*rad;\n                vOffs[i] = length(lq - vOffsI);\n            }\n            \n            // Smoothing factor.\n            float smF = .005;\n            // Segmenting the face triangle into three polygon boundaries.\n            //\n            // Each line connnects the offset center to its edge neighbor offset. Therefore,\n            // the polygon boundary we're after will be a combination of two of those lines.\n            // Each triangle consists of three partial polygons, which are gouped into the\n            // following expression.\n            //\n            //ln = max(ln, min(-ln.yzx, ln.zxy));\n            ln = smax(ln, -ln.yzx, smF);\n           \n            \n         \n          \n            //Offset center point distance field.\n            float cp = length(lq - ctrRnd);\n\n            // Give the edges and center points some thickness.\n            #if SCHEME == 0\n            mp -= .05;\n            cp -= .05;\n            #elif SCHEME == 1\n            mp -= .03;\n            cp -= .03;\n            #else\n            mp -= .017;\n            cp -= .018;\n            #endif\n            \n            \n            // Initial background color.\n            texCol = vec3(.05); \n\n\n            /*         \n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) -  .0035;\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            */\n\n            /*\n            // Offset cell boundaries.\n            mat3 mEdge2 = mat3(cross(ctrRnd, v[0]), cross(ctrRnd, v[1]), cross(ctrRnd, v[2]));\n            vec3 ep2 = (normalize(lq)*mEdge2)/\n                        vec3(length(ctrRnd - v[0]), length(ctrRnd - v[1]), length(ctrRnd - v[2]));  \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            ep2 = max(ep2, -ep2.yzx);\n            ep2 = abs(ep2);\n            float line2 = min(min(ep2.x, ep2.y), ep2.z) -  .0035;\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line2))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line2))*.9);\n            */\n            \n          \n      \n            // Disk version... Needs work.\n            //ln = abs(ln + .02) - .02;\n \n            \n            //ln += .005;\n            //mp += .005;\n            \n            // Performing CSG to combine the jigsaw nodules with the polygons\n            // to creat the jigsaw pieces.\n            for(int i = 0; i<3; i++){\n                float mRnd = dir[i]*(rc[i]*2. - 1.);\n                if(mRnd<0.) ln[i] = smin(ln[i], mp[i], smF);\n                else ln[i] = smax(ln[i], -mp[i], smF);\n                \n                int ip1 = (i + 1)%3;\n                mRnd = dir[ip1]*(rc[ip1]*2. - 1.);\n                if(mRnd<0.) ln[i] = smax(ln[i], -mp[ip1], smF);\n                else ln[i] = smin(ln[i], mp[ip1], smF);\n            }\n\n            \n            // Sorting in order of random height. In this way, the faux\n            // shadows will render in the correct order. I was hoping this \n            // would magically sort (pun intended) itself out, but it didn't. :)\n            int index[3] = int[3](0, 1, 2);\n            vec3 rnd3 = vec3(hash31(v[1]), hash31(v[2]), hash31(v[0]));\n            vec3 r3 = rnd3;\n            rnd3 = vec3(getGrey(getColor(rnd3.x)), getGrey(getColor(rnd3.y)), getGrey(getColor(rnd3.z)));\n            if (rnd3[0] > rnd3[1]){ swap(rnd3[0], rnd3[1]); swap(index[0], index[1]); }\n            if (rnd3[0] > rnd3[2]){ swap(rnd3[0], rnd3[2]); swap(index[0], index[2]); }\n            if (rnd3[1] > rnd3[2]){ swap(rnd3[1], rnd3[2]); swap(index[1], index[2]); }\n            \n            \n            // Rendering the jigsaw pieces in order of ascending height.\n            // Laying down shadows, edges, color, etc.\n            for(int j = ZERO; j<3; j++){ \n               \n                int i = index[j];\n                int ip1 = index[(j + 1)%3];\n \n                float rnd = r3[i];\n                vec3 pCol = getColor(rnd);\n               \n                float sL = length(v[i] - v[ip1]);\n                float sh = clamp(.5 - ln[i]/sL*3., 0., 1.);\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*12., ln[i]))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i]));\n                texCol = mix(texCol, pCol, 1. - smoothstep(0., sf, ln[i] + .005));\n                   \n            }\n            \n            /*\n            // Inner lines and shading.\n            for(int j = ZERO; j<3; j++){ \n            \n               int i = index[j];\n               float rnd = r3[i];\n               vec3 pCol = getColor(rnd);\n               texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i] + .02))*.9);\n               texCol = mix(texCol, pCol*.5, (1. - smoothstep(0., sf, ln[i] + .027)));\n     \n            }\n            */\n\n             \n             \n            // Cell vertices.\n            //vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            //float vert = min(min(v3.x, v3.y), v3.z) - .01;\n            \n            // Offset central vertices.\n            float vert = min(min(vOffs[index[0]], vOffs[index[1]]), vOffs[index[2]]) - .01;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.5);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .005));\n    \n            \n        }\n        else { \n        \n            // Back wall.\n\n            // Rotating the pattern.\n            vec2 p = rot2(3.14159/18.)*sp.xy;\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            //scale = 1./2.5; //1./2.\n            vec4 p4 = getTriVerts(p, vID, v);\n            p = p4.xy;\n            vec2 triID = p4.zw; \n            \n            // Vertices and corresponding highlight.\n            vec3 vert;\n            float sL = length(v[0] - v[1]);\n            \n            // Center ID, random offset, etc.\n            vec2 ctrID = triID;\n            vec2 ctr = vec2(0);\n            vec2 ctrRnd = ctr - (hash21A(ctrID) - .5)*.07;\n           \n            // Polygon lines, random values, point distance and height.\n            vec3 ln, rc, rc2, mp, hexHgt;\n            \n             // Nearest vertex, and edge mid-points and offsets on either side.\n            for(int i = ZERO; i<3; i++){\n\n                int ip1 = (i + 1)%3;\n                int ip2 = (i + 2)%3;\n\n                // Nearest offset vertex point.\n                vert[i] = length(p - v[i] + (hash21A(ctrID + vID[i]) - .5)*.07);\n                // Nearest vertex point.\n                //vert[i] = length(p - v[i]);\n                \n                // Random number associated with the triangle vertex, which is \n                // also the center of the hexagon. The extra \".1\" isn't necessary, \n                // but it random number disperses the jigsaw pieces in a way that\n                // feels more appealing.\n                rc[i] = hash21(triID + vID[i] + .1);\n             \n                hexHgt[i] = (triID + vID[i]).y;\n\n                // Mid edge point and ID.\n                vec2 midID = mix(vID[i], vID[ip1], .5);\n                vec2 mid = mix(v[i], v[ip1], .5);\n                \n                // Random number associated with the triangle edge midpoint.\n                rc2[i] = hash21(triID + midID);\n                \n                \n                // Neighbor central ID and position.\n                vec2 ctrNgbrID = ctrID + midID*2.;\n                vec2 ctrNgbr = ctr + mid*2.;\n                // Offset central neighbor ID and position.\n                vec2 ctrNgbrRnd = ctrNgbr - (hash21A(ctrNgbrID) - .5)*.07;\n                vec2 midRnd = mix(ctrRnd, ctrNgbrRnd, .5);\n                \n                // Perpendicular vector and random based direction.\n                vec2 tn = normalize((ctrNgbrRnd - ctrRnd).yx*vec2(1, -1)); \n                float dir = gTri*(rc2[i] - .5<0.? -1. : 1.);\n                \n                // Nodule points.\n                mp[i] = length(p - midRnd - dir*tn*.02);\n                \n                \n                // Partitioning lines to construct the polygons.\n                //ln[i] = distLineS(p, vec2(0), mid);\n                ln[i] = distLineS(p, ctrRnd, ctrNgbrRnd);\n\n\n            } \n            \n            // Vertex and midpoint size.\n            mp -= .0535;\n            vert -= .035;\n            \n            // Smoothing factor and polygon calculation.\n            float smF = .015;\n            // Constructing three polygons for the cell. And if you're thinking\n            // that it's not a lot of code, you'd be correct. :)\n            ln = smax(ln, -ln.zxy, smF);\n            //ln = abs(ln) - .01;\n\n\n            // The two cell objects (top and bottom). Each consist of curved \n            // spiral arms attached to a central shape.\n            vec2 obj = vec2(1e5);  \n            \n            // Smoothing factor and triangle distance.\n            float sf = .005;\n            float tri = sdEqTri(p*vec2(1, gTri), sL/2.);\n            \n            // Intial background color.\n            texCol = vec3(.1);\n            // Triangle grid lines.\n            //texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., abs(tri) - .014)));\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(tri) - .007)));\n            \n            \n            \n            // Sorting in order of random height. In this way, the faux\n            // shadows will render in the correct order. I was hoping this \n            // would magically sort (pun intended) itself out, but it didn't. :)\n            int index[3] = int[3](0, 1, 2);\n            vec3 rnd3 = vec3(hash21(triID + vID[0]), hash21(triID + vID[1]), hash21(triID + vID[2]));\n            rnd3 = vec3(getGrey(getColor2(rnd3.x)), getGrey(getColor2(rnd3.y)), getGrey(getColor2(rnd3.z)));\n            //vec3 r3 = rnd3;\n            if (rnd3[0] > rnd3[1]){ swap(rnd3[0], rnd3[1]); swap(index[0], index[1]); }\n            if (rnd3[0] > rnd3[2]){ swap(rnd3[0], rnd3[2]); swap(index[0], index[2]); }\n            if (rnd3[1] > rnd3[2]){ swap(rnd3[1], rnd3[2]); swap(index[1], index[2]); }\n            \n            // Performing CSG to combine the jigsas nodules with the polygons\n            // to creat the jigsaw pieces.\n            for(int i = 0; i<3; i++){ \n                \n                float rnd2 = gTri*(rc2[i] - .5);//hash2((triID + mid2ID))*2. - 1.;\n                if(rnd2<0.) ln[i] = smin(ln[i], mp[i], smF);\n                else ln[i] = smax(ln[i], -mp[i], smF);\n\n                int ip2 = (i + 2)%3;\n                rnd2 = gTri*(rc2[ip2] - .5);//hash2((triID + mid2ID))*2. - 1.;\n                if(rnd2<0.) ln[i] = smax(ln[i], -mp[ip2], smF);     \n                else ln[i] = smin(ln[i], mp[ip2], smF);        \n            }\n            \n            //ln = abs(ln + .06) - .06;\n            \n            // Lay down the ground tiles first.\n            for(int i = 0; i<3; i++){ \n            \n                // Jigsaw piece placement boundaries.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i])));\n                texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., ln[i] + .016)));\n                texCol = mix(texCol, vec3(.1), (1. - smoothstep(0., sf*2., ln[i] + .035)));\n                \n                //texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., abs(ln[i]) - .024)));\n                //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(ln[i]) - .012)));\n\n            }        \n            \n            \n            // Rendering the polygon shadows, colors, etc, in order of ascending height.\n            for(int j = ZERO; j<3; j++){ \n               \n                int i = index[j];\n  \n                float rnd = rc[i];\n                vec3 pCol = getColor2(rnd);\n            \n                 // Randomly render some of the jigsaw pieces.\n                 if(abs(hexHgt[i] + 8.)<15. && hash11(rc[i] + .01)<.5){\n                     \n                     // Jigsaw pieces.\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*20., ln[i]))*.5);\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i])));\n                     texCol = mix(texCol, pCol, (1. - smoothstep(0., sf, ln[i] + .012)));\n                     //texCol = mix(texCol, pCol, (1. - smoothstep(0., sf, ln[i] + .05)));\n                     \n                     // Inner edges and shading.\n                     //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i] + .055))*.9);\n                     //texCol = mix(texCol, pCol*.5, (1. - smoothstep(0., sf, ln[i] + .075)));\n                     \n                     // Offset vertices.\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., vert[i] - .02))*.5);\n                     texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert[i] - .02));\n                     texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert[i]));\n                     texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert[i] + .02));\n                    \n\n                 }\n\n            }\n            \n        \n        }       \n        \n         \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(1, 2, 4), fBlend);\n  \n    \t\n        \n        // Combining the above terms to procude the final color.//*freS\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*sh*1. + vec3(.2, .4, 1)*fre*sh*.7);\n \n\n\n        // Shading.\n        col *= ao*atten;\n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Subtle colored vignette. It's purpose is to pretend there's some environmental\n    // conditions causing a bluish glow in order to match the Fresnel sphere corona. \n    uv = fragCoord/iResolution.xy;\n    col = mix(col*vec3(.2, .4, 1)*5., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 2\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./2.5;\n \nfloat gTri;\n\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n    \n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// The time variable isn't recognized inside the \"Common\" tab, so this\n// hack gets around it.\nfloat gTime = 0.;\nvoid setTime(float t){ gTime = t; }\n\n// Hastily modified \"uint\" based hash functions. They're a mixture\n// of IQ and Fabrice's versions... I'll tidy these up and add more \n// references soon.\n//\n// IQ's hash function here: https://www.shadertoy.com/view/XlXcW4 \n\n//const uint k = 1664525U; // Numerical Recipes.\nconst uint k = 20170906U; // Today's date -- Use three days ago's date if you want a prime.\n\n// I recognize this particular function from Hugo Elias's now defunct site.\n// In turn, it was based on even older code.\nfloat hash(uint n){ \n\n    // Integer hash copied from Hugo Elias.\n\tn = (n << 13U)^n;\n    n = n * (n*n*15731U + 789221U) + k;//1376312589U;\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash11(float f){ return hash(floatBitsToUint(f)); }\n \n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash3(uvec3 p){\n\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// There are a few ways to use a normal range float with these functions, and\n// this isn't the best one. However, it works, so it'll do.\nfloat hash31(vec3 f){\n    \n    f = floor(f*16384. + .01); \n    return hash3(floatBitsToUint(f)); \n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    f = floor(f*16384. + .01);\n    uvec2 p = floatBitsToUint(f);\n    p = 1103515245U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\nfloat hash21A(vec2 f){    \n\n    uvec2 x = floatBitsToUint(f), q = 1103515245U*(x>>1U^x.yx);\n    float xf = float(1103515245U*(q.x^q.y>>3U))/float(0xffffffffU);\n    return sin(xf*6.2831 + gTime*(xf - .5)*3.)*.5 + .5;\n}\n \n// IQ's uvec3 to vec3 hash.\nvec3 hash33(uvec3 x){\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1./float(0xffffffffU));\n}\n\nvec3 hash31A(vec3 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    f = floor(f*16384. + .01);\n    vec3 x = hash33(floatBitsToUint(f)); \n    return sin(x*6.2831 + gTime*(x - .5)*3.)*.5 + .5;\n\n}\n \n ", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 172, 404]], "test": "untested"}
{"id": "mtSGRW", "name": "Irregular Rectangle Tiling", "author": "mla", "description": "An old favourite. This one uses an SDF to determine the region to be filled. The offset() function says how far the vertical or horizontal line through a grid point is from the point itself. Lots of xy flipping to make sure everything lines up.", "tags": ["rectangle", "tiling", "irregular"], "likes": 17, "viewed": 242, "published": 3, "date": "1672924234", "time_retrieved": "2024-07-30T18:17:41.519402", "image_code": "/////////////////////////////////////////////////////////////////\n//\n// Irregular Rectangle Tiling, mla, 2023\n//\n// Inspired by:\n// https://www.shadertoy.com/view/Dt2GRz (@jt)\n// https://www.shadertoy.com/view/Ws3GRs (@Shane)\n// https://www.shadertoy.com/view/7tKGRc (@Gelami)\n//\n// This one just works out the boundaries and the tile id for\n// colouring - would need extra work to work out the actual\n// tile dimensions eg. for texturing or for a proper tile SDF.\n//\n// 'c' shows underlying grid.\n//\n/////////////////////////////////////////////////////////////////\n\n// An SDF for the region to be filled - this must have a boundary\n// (distance == 0) on integer gridlines\nfloat regiondist(vec2 p) {\n  float d0 = max(abs(p.x)-13.0,abs(p.y)-8.0);\n  float d1 = max(abs(p.x)-5.0,abs(p.y)-3.0);\n  return max(d0,-d1);\n}\n\nfloat offset(vec2 p, bool flip) {\n  if (flip) p = p.yx;\n  // NB: grid points _on_ the boundary have offset 0\n  if (regiondist(p) >= 0.0) return 0.0;\n  float t = rand(ivec2(p)^int(iTime));\n  return 0.95*(t-0.5);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float scale = 10.0;\n  vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  p *= scale;\n  vec3 col = vec3(1,1,0.8);\n  float px = fwidth(p.x);\n  float lwidth = 0.01;\n  float rdist = regiondist(p);\n  if (rdist > 0.0) {\n    col *= smoothstep(0.0,px,rdist-lwidth);\n  } else {\n    vec2 ix = round(p);\n    p -= ix;\n    bool flip = mod(ix.x+ix.y,2.0) != 0.0; // Chequerboard\n    if (flip) {\n      p = p.yx; ix = ix.yx;\n    }\n    float x = offset(ix,flip);\n    float d = p.x-x; // Vertical line\n    int xdelta = d < 0.0 ? -1 : 1;\n    float y = offset(ix+vec2(xdelta,0),flip);\n    float d1 = p.y-y; // Horizontal line to left or right\n    if (d < 0.0) ix.x--;\n    if (d1 < 0.0) ix.y--;\n    if (flip) ix = ix.yx; // Now ix is the tile id\n    col = 0.5+0.5*h2rgb(rand(ivec2(ix)));\n    if (key(CHAR_C) && flip) col *= 0.8;\n    d = min(abs(d),abs(d1));\n    col *= smoothstep(0.0,px,d-lwidth);\n  }\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_C = 67;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 674, 700, 700, 815], [817, 817, 850, 850, 1029], [1031, 1031, 1083, 1083, 2003]], "test": "untested"}
{"id": "ctBGRD", "name": "BlackHole - golf", "author": "FabriceNeyret2", "description": "golfed version of 2021 chars \"BlackHole\" by bloodnok. [url]https://shadertoy.com/view/XdjXDy[/url]\n", "tags": ["procedural", "raymarch", "golf"], "likes": 39, "viewed": 1562, "published": 3, "date": "1672910107", "time_retrieved": "2024-07-30T18:17:42.450911", "image_code": "// golfed version of 2021 chars \"BlackHole\" by bloodnok. https://shadertoy.com/view/XdjXDy\n// more readable version at the end\n\n\n/**/ // --- 492 chars   -2 fab -5 by coyote, -5 by Xor\n\n#define N normalize//\n#define V vec3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float d = .1, w;\n    V  R = iResolution, L,\n       p = 6.3 * V(iMouse) / R,\n       D = p = N( V(cos(p.x), tan(p.y+d), sin(p)) );\n    D.y += .05;\n    D = N( mat3( L = N(cross( D, V(0,1,d) )), \n                 cross(L,D), \n                 D*1.5 ) \n           * V( R.xy-U-U, R.y ) \n         );  \n    p += p - D * texture( iChannel0, D/d+iTime ).r * d;\n    \n    for( O *= 0. ; O.a < .2 && d > .05;\n         D += N( p -= D * .02 ) /2e2 / w\n       )  \n        O +=  vec4(   ( .05 + texture( iChannel1, \n                                       vec2( d = sqrt( w = dot(p,p) ) - .25, \n                                             atan(p.x,p.z) * ( .1 + d*.02 ) + iTime*.2 \n                                           )\n                                      ).r ) \n                    * ( V(80,64,48) / d - d * V(40,36,40) )\n                    * V( w - 1.6*d + p.y*p.y*25e2 < .75 )\n                    + V(3,2.7,2) / w  \n                  , 1 ) / 1e3;    \n}\n\n/**/\n\n\n\n\n/** // --- 504 chars   -6 by coyote, -12 by Xor\n\n#define N normalize//\n#define V vec3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float d = .1, w;\n    V  R = iResolution, L,\n       p = 6.3 * V(iMouse) / R,\n       D = p = N( V(cos(p.x), tan(p.y+d), sin(p)) );\n    U += U - R.xy;\n    D.y += .05;\n    L = N( cross( D, V(0,1,d) ) );\n    D = N( U.x*L + U.y*cross(L,D) - D*1.5*R.y );\n    p += p+ D * texture( iChannel0, D/d+iTime ).r * d;\n    \n    for( O *= 0. ; O.a < .2 && d > .05;\n         D -= N( p += D * .02 ) /2e2 / w\n       )  \n        d = sqrt( w = dot(p,p) ) - .25,     \n        O +=  vec4(   ( V(80,64,48) / d - d * V(40,36,40) )\n                    * V( length(V(d-.55, p.yy*36.)) < 1. )\n                    * ( .05 + texture( iChannel1, \n                                       vec2(d+.25, \n                                             atan(p.x,p.z) * ( .1 + d*.02 ) + iTime*.2 \n                                           )\n                                      ).r ) \n                    + V(3,2.7,2) / w  \n                  , 1 ) / 1e3;    \n}\n\n/**/\n\n\n\n\n/** // --- 523 chars  -1 ch by fab,  -11 ch by xor,  -9 ch by coyote \n\n#define N normalize//\n#define V vec3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    V  R = iResolution,\n       p = 6.3 * V(iMouse) / R,\n       D, L;\n       U += U - R.xy;\n    float l, d = .1, w;\n    D = p = N( V(cos(p.x), tan(p.y+d), sin(p)) );\n    D.y += .05; \n    L = N( cross( D, V(0,1,-d) ) );\n    D = N( U.x*L + U.y*cross(L,D) - D*1.5*R.y );      \n    p += p+ D * texture( iChannel0, D/d+iTime ).r * d; // broken ! :-(\n    \n    for( O *= 0. ; O.a++ < 2e2 && d > .05;\n         D -= N( p += D * .02 ) /2e2 / w\n       )  \n        d = sqrt( w = dot(p,p) ) - .25,     \n        O.rgb +=  (   ( V(80,64,48) - d*d* V(40,36,40) )\n                    * ( .05 + texture( iChannel1, \n                                       vec2( l = length(p), \n                                             atan(p.x,p.z) * ( .095 + l*.02 ) + iTime*.2 \n                                           )\n                                      ).r ) \n                    / d\n                    * step( length(V(l-.8, p.y*50.,0)) , 1. ) \n                    + V(3,2.7,2) / w  \n                  ) / 1e3;     \n}\n\n\n\n\n\n/** // --- 544 chars  -11 ch by coyote,  -11 by xor,  -23 by fab\n\n#define N normalize\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec2  R = iResolution.xy,\n          M = 6.3 * iMouse.xy / R;\n          U+= U - R;\n    float l = M.x, d =  M.y+.1, w;\n\tvec3  p = N( vec3(cos(l), tan(d), sin(l)) ),\n\t      F = vec3(0,.05,0) + p ,\n\t      L = N( cross( F, vec3(0,1,-.1) ) ),\n\t      D = N( U.x*L + U.y*cross(L,F) - F*1.5*R.y );      \n    p += p+ D * texture( iChannel0, D/.1+iTime ).r * .1;\n    \n    for( O *= 0. ; O.a++ < 2e2 && d > .05;\n         D -= N( p += D * .02 ) /2e2 / w\n       )  \n        d = sqrt( w = dot(p,p) ) - .25,     \n        O.rgb +=  (   ( vec3(80,64,48) - d*d* vec3(40,36,40) )\n                    * ( .05 + texture( iChannel1, \n                                       vec2( l = length(p.xz), \n                                             atan(p.x,p.z) * ( .095 + l*.02 ) + iTime*.2 \n                                           )\n                                      ).r ) \n                    / d\n                    * step( length(vec2(l-.8, p.y*50.)) , 1. ) \n                    + vec3(3,2.7,2) / w  \n                  ) / 1e3;     \n}\n\n\n\n\n\n/** // --- 589 chars   -5 by iq , -24 by fab , -12 for dithering \n\n#define N normalize\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,\n          M = 6.3 * iMouse.xy / R;\n    float l =  M.x, d =  M.y,\n          t=0., w, r = .3, f; // r: radius  f: noncaptured\n\tvec3  p = vec3( cos(l) * cos(d),\n                             sin(d),\n                    sin(l) * cos(d) ),\n\t      F = vec3(0,.05,0) + p ,\n\t      L = N( cross( F, vec3(0,1,-.1) ) ),\n\t      D = N( U.x*L + U.y*cross(L,F) - F*1.5 );      \n    p += p+ D * texture( iChannel0, D/.1+iTime ).r * .1;\n    \n    for( O *= 0. ; t++<2e2; // dt    mass\n         D -= N( p += D * f * .02 ) /2e2 / w\n       )\n        w = dot(p,p),\n        f = smoothstep(0.,.01, d = length(p) - r ),     \n        O.rgb += f/1e3 *(    ( vec3(80,64,48) - d*d* vec3(40,36,40) )\n                           * ( .05 + texture( iChannel1, \n                                              vec2( l = length(p.xz), \n                                                    atan(p.x,p.z) * ( .1 + (l - r)*.02 ) + iTime*.2 \n                                                  )\n                                             ).r ) \n                           / d\n                           * step( length(vec2(l-.8, p.y*50.)) , 1. ) // sdTorus\n                           +  vec3(10,9,7) / w * .3  \n                        );     \n}\n\n\n\n\n\n/** // --- 630 chars \n\n#define N normalize\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,\n          M = iMouse.xy / R;\n    float l =  M.x      * 6.28,\n          d = (M.y-.24) * 6.28,\n          t=0., r = .3, f; // r: radius  f: noncaptured\n\tvec3  p = 2.* vec3( cos(l) * sin(d),\n                                 cos(d),\n                        sin(l) * sin(d) ),\n\t      F = N( vec3(0,-.1,0) - p ),\n\t      L = N( cross(vec3(0,1,-.1), F) ),\n\t      D = N( F*1.5 + U.x*L + U.y*cross(F, L) );      \n  //p += D * H( D + iTime ) * .02;\n    p += D * fract(1e4*sin(dot( D +iTime, vec3(R-17.,173)))) * .02;\n    \n    for( O *= 0. ; t++<2e2; // dt    mass\n         D -= N( p += D * f * .02 ) /2e2 / dot(p,p) \n       )\n        U =  vec2( l = length(p.xz), \n                   atan(p.x,p.z) * ( .1 + (l - r)*.02 ) + iTime*.2 \n                 ),\n        f = smoothstep(0.,.01, d = length(p) - r ),     \n        O.rgb += f *(    mix( vec3(1,.8,.6), vec3(.5,.35,.1),  d*d )\n                       * ( texture(iChannel1,U).r+.05 ) \n                       * .08 / d\n                       * step( length(vec2(l-.8, p.y*50.)) , 1. ) // sdTorus\n                      +  vec3(1,.9,.7) / dot(p,p) * .003  \n                    );     \n}\n\n/**/", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 261, 261, 1214]], "test": "untested"}
{"id": "ctjGR1", "name": "Motion Induced Blindness (384ch)", "author": "fenix", "description": "Stare at the green dot, and one or more of the yellow dots will seem to disappear.\n\nReproduction of this tweet:\n\nhttps://twitter.com/gunsnrosesgirl3/status/1610211567966224387\nhttps://whyevolutionistrue.com/2014/09/02/why-do-the-dots-disappear/\n", "tags": ["illusion", "motion", "blindness", "codegolf", "reproduction"], "likes": 16, "viewed": 246, "published": 3, "date": "1672885738", "time_retrieved": "2024-07-30T18:17:43.496117", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Interesting optical illusion! Stare at the green dot, and one or more of the yellow\n//  dots will seem to disappear.\n//\n//  Reproduction of this tweet:\n//\n//      https://twitter.com/gunsnrosesgirl3/status/1610211567966224387\n//  \n//  See also:\n//\n//      https://whyevolutionistrue.com/2014/09/02/why-do-the-dots-disappear/\n//\n//      \"Jack Pettigrew, a neuroscientist at the University of Queensland in Brisbane,\n//      believes that the illusion results from a tussle for supremacy between the left\n//      and right halves of the brain.\"\n//\n// ---------------------------------------------------------------------------------------\n\n// First attempt at golfing by me: (384 chars)\n//*\n#define D(X, Y) smoothstep(.01 + 3./R.y, .01, length(u - vec2(X, Y))) // dot\n#define L(X) smoothstep(27./R.y, 0., max(abs(X.y), abs(X.x) - .25))   // line\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 w, R = iResolution.xy,\n         v = (u = 1.2 * (u - .5 * R) / R.y) * mat2(w = sin(iTime+vec2(1.6,0)), -w.y, w.x),\n         m = fract(v * 8. - .5) - .5;\n         \n    O = vec4(w.x = D(   0, -.3)\n                 + D(-.26,  .15)\n                 + D( .26,  .15),\n             fract(iTime) > .5 ? D(0, 0) + w.x : w.x,\n             abs(v.x) < .45 && abs(v.y) < .45 ? L(m) + L(m.yx) : 0.,\n             1);\n}\n/**/\n\n// Original: (710 chars)\n/*\nmat2 r(float a) { vec2 s = vec2(sin(a), cos(a)); return mat2(s.y, s.x, -s.x, s.y); }\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u = 1.2*(u - .5*R) / R.y;\n    \n    O = vec4(0);\n\n    vec2 v = u * r(iTime);\n    \n    if (v.x < .45 && v.x > -.45 && v.y < .45 && v.y > -.45)\n    {\n        vec2 m = mod(v - .0625, .125) - .0625;\n        O = mix(vec4(0,0,1,1), O, smoothstep(0., 3./R.y, max(abs(m.y), abs(m.x) - .03125)));\n        O = mix(vec4(0,0,1,1), O, smoothstep(0., 3./R.y, max(abs(m.y) - .03125, abs(m.x))));\n    }\n    \n    if (fract(iTime) > .5)\n        O = mix(vec4(0,1,0,1), O, smoothstep(.01, .01 + 3./R.y, length(u)));\n\n    O = mix(vec4(1,1,0,1), O, smoothstep(.01, .01 + 3./R.y, length(u - vec2(0, -.3))));\n    O = mix(vec4(1,1,0,1), O, smoothstep(.01, .01 + 3./R.y, length(r(2.1) * u - vec2(0, -.3))));\n    O = mix(vec4(1,1,0,1), O, smoothstep(.01, .01 + 3./R.y, length(r(4.1) * u - vec2(0, -.3))));\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjGR1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1058, 1058, 1096, 1096, 1508]], "test": "untested"}
{"id": "dlf3zn", "name": "Sand Simulation", "author": "SpinningCube", "description": "Use the mouse to add sand.\n\nI made this shader as an experiment to demonstrate the use of two buffers to simulate sand in some fragment shaders. Particles will often merge together, but I think it works quite well otherwise.", "tags": ["sand", "cellularautomata"], "likes": 21, "viewed": 855, "published": 3, "date": "1672872943", "time_retrieved": "2024-07-30T18:17:44.436602", "image_code": "/*\n * Sand Simulation\n * \n * This shader uses two buffers to perform two passes on the tile world on each frame.\n * Buffer A determines where each particle should move to\n * Buffer B applies the movements determined by Buffer A\n *\n */\n\nvec3 blankCol = vec3(0.0);\nvec3 solidCol = vec3(0.6);\nvec3 sandCol = vec3(1.0, 1.0, 0.9);\nvec3 waterCol = vec3(0.2, 0.5, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 rawSim = texture(iChannel0, uv);\n    \n    float tileType = rawSim.z;\n    \n    vec3 col = blankCol;\n    if (tileType == 0.01) col = solidCol;\n    if (tileType == 0.1) col = sandCol;\n    if (tileType == 0.2) col = waterCol;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n * Sand Simulation - Buffer A\n * \n * Handles particle behavior — determines where the particles should move to\n *\n */\n \nconst bool generateStartingScene = true;\n\nconst float mouseType = 0.1; // Controls what tile is placed by the mouse cursor\n\n/*\n * Tile Types\n * \n * Nothing - 0\n * Solid - 0.01\n * Sand - 0.1\n * Water (broken) - 0.2\n *\n */\n\nvec3 getTile(vec2 fragCoord) {\n    return texture(iChannel0, fragCoord/iResolution.xy).rgb;\n}\n\n// Determines where this should particle move to next.\nvec2 particleVelocity(vec3 tile, vec2 fragCoord) {\n    float tileType = tile.z;\n    vec2 velocity = tile.xy;\n    if (tileType >= 0.1) {\n        \n        if (getTile(fragCoord + vec2(0.0, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            int depth;\n            for (depth = 1; depth <= min(1 - int(velocity.y), movementRange); depth++) {\n                if (!(getTile(fragCoord + vec2(0.0, -depth)).z == 0. && (fragCoord + vec2(0.0, -depth)).y >= 0.)) {\n                    return vec2(0.0, float(-depth) + 1.);\n                }\n            }\n            return vec2(0.0, float(-depth) + 1.);\n        }\n        \n        //if (getTile(fragCoord + vec2(0.0, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n        //    return vec2(0.0, -1.0);\n        //}\n        \n        float side = 2. * round(hash13(uvec3(fragCoord, iFrame))) - 1.;\n        \n        if (getTile(fragCoord + vec2(side, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            return vec2(side, -1.0);\n        }\n        if (getTile(fragCoord + vec2(-side, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            return vec2(-side, -1.0);\n        }\n        \n        // Attempt at water\n        if (tileType >= 0.2) {\n            float side = 2. * round(hash13(uvec3(fragCoord, 2 * (iFrame + 3)))) - 1.;\n            //side = 1.;\n            \n            if (getTile(fragCoord + vec2(side, 0.0)).z == 0. && (fragCoord + vec2(side, 0.0)).x >= 0.) {\n                return vec2(side, 0.0);\n            }\n            if (getTile(fragCoord + vec2(-side, 0.0)).z == 0. && (fragCoord + vec2(-side, 0.0)).x >= 0.) {\n                return vec2(-side, 0.0);\n            }\n        }\n    }\n    return vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 inputColor;\n    \n    if (iFrame < 5 && generateStartingScene) {\n        float noise = perlin(fragCoord/50. * vec2(0.6, 1.0) + iDate.w);\n        if (noise > 0.7) {\n            inputColor = vec3(0.01);\n        } else if (noise > 0.65) {\n            inputColor = vec3(0.1);\n        }\n    } else {\n        inputColor = getTile(fragCoord).rgb;\n    }\n    \n    vec3 tile = inputColor.xyz;\n    \n    vec4 mouse = iMouse;\n    \n    if (mouse.z > 0.5 && distance(fragCoord, mouse.xy) <= 10.) {\n        tile.z = mouseType;\n    }\n    \n    fragColor = vec4(particleVelocity(tile, fragCoord), tile.z, 1.0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * Sand Simulation - Buffer B\n * \n * Handles particle movement — applies the movements determined by Buffer A\n *\n */\n\nvec3 boxScan(vec2 fragCoord) {\n    for (int y = -movementRange; y <= movementRange; y++) {\n        for (int x = -movementRange; x <= movementRange; x++) {\n            vec3 pixel = texture(iChannel0, (fragCoord + vec2(x, y))/iResolution.xy).rgb;\n            if (pixel.z != 0.0) {\n                if (ceil(pixel.xy) == vec2(-x, -y)) {\n                    return pixel;\n                }\n            }\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(boxScan(fragCoord),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int movementRange = 6;\n\n/* Hash functions by Nimitz:\n * https://www.shadertoy.com/view/Xt3cDn\n *\n * I use them to randomize movement of the sand, and to generate perlin noise and create the starting pattern.\n */\n\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 randUnitVector(vec2 pos) {\n    float angle = 2. * 3.1415926536 * hash13(uvec3(pos, 1.0));\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin(vec2 pos) {\n    // Grid cell corner points\n    vec2 p00 = floor(pos);\n    vec2 p01 = p00 + vec2(0, 1);\n    vec2 p11 = p00 + vec2(1, 1);\n    vec2 p10 = p00 + vec2(1, 0);\n    \n    // Random vectors at corner points\n    vec2 r00 = randUnitVector(p00);\n    vec2 r01 = randUnitVector(p01);\n    vec2 r11 = randUnitVector(p11);\n    vec2 r10 = randUnitVector(p10);\n    \n    // Dot product between random vector and distance vector\n    float d00 = dot(r00, pos - p00);\n    float d01 = dot(r01, pos - p01);\n    float d11 = dot(r11, pos - p11);\n    float d10 = dot(r10, pos - p10);\n    \n    \n    // Bicubic interpolation\n    vec2 blend = smoothstep(0., 1., fract(pos));\n    \n    float upper = float(mix(d01, d11, blend.x));\n    float lower = float(mix(d00, d10, blend.x));\n    return 0.8 * mix(lower, upper, blend.y) + 0.5;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlf3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 421, 471, 806]], "test": "untested"}
{"id": "Dtj3z1", "name": "little circle moving", "author": "pomme", "description": "it's my first shader", "tags": ["secondshader"], "likes": 1, "viewed": 149, "published": 3, "date": "1672871507", "time_retrieved": "2024-07-30T18:17:45.286331", "image_code": "// This is my first \"moving\" shader and my second shader\n\n#define sat(a) clamp(a, 0., 1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // thanks to z0rg and FabriceNeyret2\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;;\n\n    vec3 col = vec3(.6, .7, 0.);\n    \n    vec2 circle  = vec2(sin(iTime) * .3, sin(iTime) * .3);\n    \n    float center = distance(circle, uv);\n    \n    float shape = 1. - sat((center - .2) * 100.);\n    \n    vec3 image = col * shape;\n           \n    // Output to screen\n    fragColor = vec4(image,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtj3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 147, 188, 557]], "test": "untested"}
{"id": "Dl2GRh", "name": "Triangle filler 3D v0.1.1", "author": "raymarchingenthusiast", "description": "Fills triangles with textures. Depth corrected.", "tags": ["triangles"], "likes": 0, "viewed": 182, "published": 3, "date": "1672865307", "time_retrieved": "2024-07-30T18:17:46.082202", "image_code": "#define TriCount 2\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvoid RecalibTris(inout Triangle tso[TriCount]) {\n    for(int i = 0; i < TriCount; i++) {\n        vec3 a = vec3(tso[i].a.xy-.5,tso[i].a.z);\n        vec3 b = vec3(tso[i].b.xy-.5,tso[i].b.z);\n        vec3 c = vec3(tso[i].c.xy-.5,tso[i].c.z);\n        tso[i] = Triangle(a,b,c);\n    }\n}\n\nvec3 CalcNorm(Triangle t) {\n    return normalize(cross(t.b-t.a,t.c-t.a));\n}\n\nvec3 CalcUv(vec2 p, Triangle tp, Triangle tuv) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    vec3 perspUv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    float pz = (w1*tp.a.z + w2*tp.b.z + w3*tp.c.z);\n    return perspUv * pz;\n}\n\nbool isInside(vec2 p, Triangle tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nTriangle Project(Triangle to) {\n    return Triangle(to.a/to.a.z,to.b/to.b.z,to.c/to.c.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + (iMouse.xy-iResolution.xy/2.)) / iResolution.xy;\n    if(iMouse.xy == vec2(0.)) uv = fragCoord / iResolution.xy;\n    uv.xy -= .5;\n    \n    Triangle tos[TriCount];\n    Triangle uvs[TriCount];\n    \n    tos[0] = Triangle(vec3(0.,0.,.5),vec3(0.,1.,2.),vec3(1.,0.,2.));\n    uvs[0] = Triangle(vec3(0.,0.,1.),vec3(0.,1.,1.),vec3(1.,0.,1.));\n    tos[1] = Triangle(vec3(1.,.4+.4*cos(iTime*.3),1.+.5*sin(iTime)),vec3(1.),vec3(0.,1.,1.));\n    uvs[1] = Triangle(vec3(1.,0.,1.),vec3(1.),vec3(0.,1.,1.));\n    \n    RecalibTris(tos);\n    \n    fragColor = vec4(0.,0.,.3,1.);\n    for(int i = 0; i < TriCount; i++) {\n        Triangle ts = Project(tos[i]);\n        if(isInside(uv,ts)) {\n            vec3 textureUv = CalcUv(uv,ts,uvs[i]);\n            \n            vec3 col = texture(iChannel0,textureUv.xy).xyz;\n            \n            vec3 n = CalcNorm(tos[i]);\n            col *= clamp(dot(n,vec3(0.,1.,0.))*.5+.5,0.,1.);\n            \n            fragColor = vec4(col,1.);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,1.);\n        }\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2GRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 126, 126, 358], [360, 360, 387, 387, 435], [437, 437, 485, 485, 1048], [1050, 1050, 1087, 1087, 1455], [1457, 1457, 1488, 1488, 1548], [1550, 1550, 1607, 1607, 2718]], "test": "untested"}
{"id": "Dt2GzR", "name": "Van Damme Newspaper Style", "author": "deni_de", "description": "Van Damme News in color & bw printing", "tags": ["animation", "dots"], "likes": 1, "viewed": 239, "published": 3, "date": "1672862104", "time_retrieved": "2024-07-30T18:17:46.854139", "image_code": "#define cs vec2(250,130)\n#define t(a) texture(iChannel0,ceil(((U+a)*cs/r))/cs)\n#define s(a) step(a,U.x/r.x - sin(iTime))\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy; vec2 uv = fract( (U/vec2(r.x, r.y)) * cs);\n    float tr = t(vec2(5.5,0)).x,tg = t(vec2(0,5.5)).y, tb = t(vec2(-5.,-5.)).z;\n    vec3 C = (U.x/r.x - sin(iTime)) < .5 ? vec3(tr,tg,tb) : vec3(1);\n    O.rgb = C * vec3(1. - step(-.1 + .69 * tr, length(uv-vec2(.5)))) + (s(.499) - s(.501));\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2GzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 163, 163, 478]], "test": "untested"}
{"id": "cl23zh", "name": "Nyquist Sampling Theorem", "author": "iq", "description": "Shows Nyquist sampling theorem, which states that a band limited signal (yellow) con be discretized and after than fully reconstructed again if the sampling frequency is at least twice the maximum frequency in the original signal (blue).", "tags": ["1d", "sampling", "nyquist", "dsp"], "likes": 21, "viewed": 934, "published": 3, "date": "1672857435", "time_retrieved": "2024-07-30T18:17:47.610117", "image_code": "//--------------------------------------------------------\n// Shows Nyquist sampling theorem which states that a band \n// limited analog signal can be discretized and then fully\n// reconstructed perfectly again if the sampling frequency\n// is at least twice the maximum frequency in the original\n// signal (ie, the width of its spectrum).\n//\n// In this case the yellow signal is the original, and the\n// blue one is its reconstruction after sampling it merely\n// 0.5% above the Nyquist frequency.\n//\n// Made after https://www.shadertoy.com/view/DtjGRh\n//\n// Our analog signal is made with an AM modulation, with a\n// carrier at 11Hz (kFreqBase), and a modulating signal of\n// 1Hz (kFreqAM), so the bandwidth of the analog signal is\n// 12Hz (kFreqSignal). So, according to Nyquest, we should\n// sample it at least at 2*12Hz = 24Hz (kFreqSample). Here\n// I'm sampling it at 25.2HZ (0.5% more than Nyquist) to\n// make sure all works well.\n//\n#define ANIMATE 1\n//\nconst float kFreqBase   = 11.0;\nconst float kFreqAM     = 1.0;\nconst float kFreqSignal = kFreqBase + kFreqAM;\n#if ANIMATE==0\nconst float kFreqSample = kFreqSignal*2.0*1.005;\nconst int   kNumSincs   = 100; // larger for better reconstruction\n#else\n      float kFreqSample;\nconst int   kNumSincs   = 900; \n#endif\n\n//\n//--------------------------------------------------------\n\n                          \n// utils\nconst float kPi  = 3.1415927;\nconst float kTau = 6.2831853;\nfloat sinc(float x) { return abs(x)>0.0?sin(kPi*x)/(kPi*x):1.0; }\n\n\n// some (band limited) signal\nfloat signal( in float t )\n{\n    //t += fract(iTime/10.0);\n\n    float f = 0.0;\n    f += 1.0*(0.5-0.5*cos(kTau*t))*sin(kTau*kFreqBase*t);\n    t -= 0.5;\n    f += 0.5*(0.5-0.5*cos(kTau*t))*sin(kTau*kFreqBase*t);\n    return f;\n}\n\n// https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem\nfloat reconstruct( in float tc )\n{\n    //int   kNumSincs  = 1 + int(iTime*iTime*60.0);\n\n    float y = 0.0;\n    int   c = int(floor(tc*kFreqSample));\n    for( int n=c-kNumSincs; n<=c+kNumSincs; n++ )\n    {       \n        float t = float(n)/kFreqSample;\n        y += signal( t ) * sinc( kFreqSample*(t-tc) );\n    }\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //kFreqSample = kFreqSignal*0.5*pow(1.1,iTime);\n    \n    #if ANIMATE==1\n    float time = mod(iTime,15.0);\n    kFreqSample = kFreqSignal*mix(0.5,2.0*1.005,smoothstep(0.0,10.0,time));\n    #endif\n    \n    // background\n    float u = fragCoord.x/iResolution.x;\n    vec3 col = vec3(0.15)*(0.75+u*(1.0-u));\n\n\n    vec2  uv = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n    float sc = 1.1;               // scale\n    float am = 0.4;               // amplitude\n    float t  = uv.x*sc;\n\n    // plot signals\n    {\n    float x = signal(t);          // true signal\n    float y = reconstruct(t);     // reconstructed signal\n    float dx = am*dFdx(x)/(sc*px);\n    float dy = am*dFdx(y)/(sc*px);\n    x = abs(am*x-(uv.y-0.5))/sqrt(1.0+dx*dx); // https://iquilezles.org/articles/distance/)\n    y = abs(am*y-(uv.y-0.5))/sqrt(1.0+dy*dy);\n    x = smoothstep( px*2.0/sc, 0.0, x );\n    y = smoothstep( px*2.0/sc, 0.0, y );\n    col = mix( col, vec3(1.0,0.7,0.0), x );\n    col = mix( col, vec3(0.0,0.7,1.0), y );\n    }\n    \n    #if ANIMATE==1\n    {\n    float a = smoothstep(12.0,10.0,time);\n    float x = round(t*kFreqSample)/kFreqSample;\n    float y = signal(x);\n    vec2  p = vec2( t - x,  am*y-(uv.y-0.5) );\n    float f = smoothstep( px*1.5, 0.0, length(p)-0.01 );\n    col = mix( col, vec3(1.0,1.0,1.0), a*f );\n    }\n    #endif\n    \n    // dither to remove banding in the background\n    col += fract(sin(fragCoord.x*vec3(13,17,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl23zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1431, 1431, 1452, 1452, 1496], [1499, 1529, 1557, 1587, 1753], [1755, 1829, 1863, 1915, 2157], [2159, 2159, 2216, 2268, 3722]], "test": "untested"}
{"id": "DtjGzh", "name": "levelex shader", "author": "hneupert", "description": "a test shader for levelex", "tags": ["levelex"], "likes": 0, "viewed": 160, "published": 3, "date": "1672854965", "time_retrieved": "2024-07-30T18:17:48.367093", "image_code": "/*\n * This function will function like an array.\n */\nvec2 getWaveSource(int ws)\n{\n\tvec2 outp;\n\tif (ws == 0)\n\t{\n\t\toutp = vec2(-100,-100);\n\t}\n\telse if (ws == 1)\n\t{\n\t\toutp = vec2(-100,500);\n\t}\n\telse\n\t{\n\t\toutp = vec2(500,-500);\n\t}\n\treturn outp;\n}\n/*\n * Don't need an expensive square root operation.\n * This returns distance squared, not distance.\n */\nfloat distanceSq(vec2 a, vec2 b)\n{\n\tvec2 diff = a - b;\n\treturn dot(diff, diff);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int wsCount = 3;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat wavePower = 0.0;\n\tfor(int i=0; i<wsCount; i++)\n\t{\n\t\tvec2 src = getWaveSource(i);\n\t\tfloat dist = distanceSq(src, uv) / 300.0;\n\t\twavePower += sin((dist + iTime));\n\t\t\n\t}\n\tfragColor = vec4(\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.9\n\t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 81, 81, 242], [243, 348, 382, 382, 429], [430, 430, 487, 487, 852]], "test": "untested"}
{"id": "Dlj3Rh", "name": "portable x%y", "author": "FabriceNeyret2", "description": "trying to get x%y  giving the same result on all platforms.\nThe last one is the one that works everywhere like the ref mod().\nthe before-last is ok for y>0 \n\nIt's incredible how each variant give a different result AND different on Windows vs OpenGL !\n", "tags": ["glsl", "modulo", "compatibility", "portability"], "likes": 7, "viewed": 286, "published": 3, "date": "1672852675", "time_retrieved": "2024-07-30T18:17:49.356448", "image_code": "// #define imod(a,b) int( round ( mod(float(a), float(b) ) ) ) // ref.  but wrong on some values, e.g. mod(33,33)=33\n// #define imod(a,b) (  (a) % (b) )                            // OpenGL: wrong for a|b<0  Windows: wrong on a*b<0\n// #define imod(a, b) (a - (a/b)*b)                            // supposed to be the def but ok only for a&b>0\n// #define imod(a,b) int( uint(a) % uint(b) )                  // OpenGL: look like above  Windows: look like OpenGL (and nothing else)\n// #define imod(a,b) ( ( (a) % (b) ) + ( a < 0 ? b : 0 ) )     // OpenGL: wrong for a|b<0  Windows: ok for b > 0 = the practical case\n// #define imod(a,b) ( ( a + 1024*(b) ) % (b) )                // OpenGL: wrong for a|b<0  Windows: ok for a not too negative\n   #define imod(a,b) ( a >= 0 ? (a) % (b) : -(a)%(b)==0 ? 0 :  b - ( -(a) % (b) ) ) // ok everywhere for b > 0 = the practical case\n// #define imod(a,b) ( b>= 0 ? a >= 0 ? (a) % (b) : ( b - ( -(a) % (b) ) )%(b) \\\n   //                        :  a > 0 ? (a) % -(b) == 0 ? 0 : b + (a) % -(b) : -( -(a) % -(b) ) ) //  ok everywhere for all case\n\n#if 0\nint imod(int a, int b) { // function variant of option 5\n  int r = abs(a)%b;\n  if (a >= 0) return r;\n  if (r == 0) return 0;\n  return b-r;\n}\n#endif\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2( U - iResolution.xy/2. );\n    O = vec4( .5 + .5* float( imod(I.x,I.y) )/float(abs(I.y)) );\n    if (  abs(imod(I.x,I.y)) == abs(I.y) && iFrame%20<10 ) O=vec4(1,0,0,0); // test bounds: red if error\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1237, 1237, 1275, 1275, 1499]], "test": "untested"}
{"id": "DlX3W4", "name": "Lucas–Kanade Optical Flow", "author": "theschwa", "description": "A basic implementation of the Lucas–Kanade method with rejection based on the eigen values.\n\n", "tags": ["opticalflow", "opticalflow", "lucaskanade", "motionestimation"], "likes": 16, "viewed": 1114, "published": 3, "date": "1672850278", "time_retrieved": "2024-07-30T18:17:50.205180", "image_code": "/*\n\nThis is mostly a straightforard implementation of the Lucas-Kanade method\nfor sparse optical flow. I'm also using the eigen values to reject bad features.\n\nI've also added some temporal denoising to the webcam input, and the number of\naccumulated frames can be changed in Buffer A.\n\nThe window size can be set in Buffer B\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mov = textureLod(iChannel0, uv, 0.).xy;\n    \n    float mag = length(mov.xy);\n    float ang = atan(mov.y, mov.x)/(2.*3.14159) + .5;\n    \n    // Remove noisey small values and scale down\n    mag = mag * .5 * smoothstep(0., 1., mag);\n    \n    vec3 col = vec3( ang, 1., mag );\n    col = hsv2rgb(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer solves for dI/dx, dI/dy, dI/dt\n\n# define FRAMES 2.\n# define LOD 0.\n\nfloat lum( vec4 col ) {\n    return dot( col, vec4(.333,.333,.333,.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = pow(2.,LOD)/iResolution.xy;\n    \n    vec4 N = textureLod(iChannel0, uv + vec2( 0., 1.)*texel, LOD);\n    vec4 E = textureLod(iChannel0, uv + vec2( 1., 0.)*texel, LOD);\n    vec4 S = textureLod(iChannel0, uv + vec2( 0.,-1.)*texel, LOD);\n    vec4 W = textureLod(iChannel0, uv + vec2(-1., 0.)*texel, LOD);\n    \n    vec4 currCol = textureLod(iChannel0, uv, LOD);\n    float curr = lum(currCol);\n    float prev = textureLod(iChannel1, uv, LOD).a;\n    \n    // Temporal denoising\n    curr = mix(prev, curr, 1./(1.+ FRAMES ) );\n    \n    float dIdx = lum( (E - W)/2. );\n    float dIdy = lum( (N - S)/2. );\n    float dIdt = curr-prev;\n    \n    fragColor = vec4(dIdx, dIdy, dIdt, curr);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Lucas-Kanade Method\n// Implemented straight from Wikipedia https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method\n\n#define halfSize 5.\n\n// Trace\nfloat tr2( mat2 A ) {\n    return A[0][0] + A[1][1];\n}\n\nfloat det( mat2 A ) {\n    return (A[0][0] * A[1][1]) - (A[1][0] * A[0][1]);\n}\n\n// 3Blue1Brown https://www.youtube.com/watch?v=e50Bj7jn9IQ\nvec2 eigenValues( mat2 A ) {\n    float m = .5*tr2(A);\n    float p = det(A);\n    return vec2( m + sqrt(m*m-p), m - sqrt(m*m-p) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    \n    mat2 structureTensor = mat2(0.,0.,0.,0.);\n    vec2 Atb = vec2(0.,0.);\n    for( float i = -halfSize; i < halfSize; i++) {\n        for( float j = -halfSize; j < halfSize; j++) {\n            vec2 loc = uv + vec2(i,j)*texel;\n            vec2 dis = loc - uv;\n            float weight = exp( - dot(dis,dis)/3. );\n            vec4 deriv = texture(iChannel0, loc);\n            structureTensor += mat2( weight*deriv.x*deriv.x, weight*deriv.x*deriv.y, weight*deriv.x*deriv.y, weight*deriv.y*deriv.y);\n            Atb -= vec2( weight*deriv.x*deriv.z, weight*deriv.y*deriv.z );\n        }\n    }\n    vec2 motion = inverse(structureTensor)*Atb;\n    \n    // Remove bad features\n    vec2 e = eigenValues( structureTensor );\n    if( e.x < 0.001 || e.y < 0.001 ) {\n        motion = vec2(0.,0.);\n    } \n    \n    fragColor = vec4(motion,0.,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// From: https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlX3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 389, 389, 773]], "test": "untested"}
{"id": "DtjGRh", "name": "Kotelnikov's theorem", "author": "foxes", "description": "Let's see how the Kotelnikov (Nyquist—Shannon) theorem works in practice. I specifically chose the closest frequency of the wave to the maximum possible to fulfill the condition. Don't forget to click on the screen", "tags": ["2d", "sound", "wave", "audio", "theorem"], "likes": 6, "viewed": 368, "published": 3, "date": "1672845189", "time_retrieved": "2024-07-30T18:17:51.159627", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Let's see how the Kotelnikov (Nyquist—Shannon) theorem works in practice.\n//\n// I specifically chose the closest frequency of the wave to the maximum\n// possible to fulfill the condition. You can change this in constants.\n//\n// As you can see, there are wave deviations at the frequency boundary,\n// but they are allowed by the theorem.\n//\n// The original theory goes like this:\n// Any function F(t) consisting of frequencies from 0 to f can be continuously\n// transmitted with any accuracy using numbers following each other in less\n// than 1/2f seconds. There is no concept of absolute accuracy here.\n//\n// The standart sampling rate was chosen not because 44100 could record 22000,\n// this is because the problem when trying to restore the frequency\n// of 20000 (the audibility threshold) persisted at 40050\n// the same as in the pair of 22022 and 44100\n// it was called the device problem, but this is the problem of the theory itself\n// Вasically this is a problem for people trying to prove that the signal can be restored\n// absolutely accurately\n//\n// https://ibb.co/pbYRMCF 22000 frequency, 44100 samples\n//\n// The second standard 48000 corresponds to the quality of 2.4 from 20000\n// it is also a mathematical threshold for another basis of various devices\n// that require increasing the frequency not by 1/2f but by close 1/2.5f seconds\n// and is a prime multiplier of other common formats\n//\n// I'm more interested in the distortion of real sound during sampling,\n// so I'm not displaying frequencies, but a wave.\n//\n// You can try to change the FX to generate more complex waves\n// and don't forget to click on the screen\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// for IQ, type 1 and you can remove ZOOM\n// IQ_TEST - very funny\n#define IQ_TEST 0\n\n#if IQ_TEST\n//(kFreqSignal+1.)*2.01\n//#define SAMPLES 24.12\n#define SAMPLES 22.05\n#define FREC 11.0\n#else\n#define ZOOM 2000.\n#define SAMPLES 44100.\n#define FREC 22000.\n#endif\n\n// You can increase the range to get rid of the modulation and thereby get closer to the absolute,\n// but you will not be able to get rid of distortions in this way, they will only get bigger in real sound\n#define RANGE 50.\n#define PI 3.1415\n#define DB 0.25\n\n// Kotelnikov 's basis\nfloat sinc(float x)\n{\n    return abs(x)>0. ? sin(x)/x : 1.;\n}\n\n// test function\nfloat FX(float t)\n{\n#if IQ_TEST\n    float freq = FREC*2.;\n#else\n    float freq = FREC*2./ZOOM;\n#endif\n    \n    float wav = 0.;\n    \n    if (iMouse.z <= 0.0) {\n        wav += (t>0. && t<1.) ? (sin((sqrt(sqrt(t))*2.-0.5)*3.1415)*0.5+0.5)*sin(t*freq*PI) : 0.;\n        t-=0.925;\n        wav += (t>0. && t<1.) ? (sin((sqrt(t)*2.-0.5)*3.1415)*0.5+0.5)*sin(t*freq*PI) : 0.;\n    } else {\n        wav += sin(t*freq*PI);\n    }\n\n    return wav;\n}\n\nfloat restore(float t,float ofs,float samp)\n{\n    float val=0.;\n    for (float i=-RANGE;i<RANGE;i+=1.) {       \n        float dto = (t+ofs)*samp+0.5;\n        float dt = floor(dto)+i;\n        float x = PI*((dto - dt)-0.5);\n        dt = dt/samp;\n        val += FX(dt-ofs)*sinc(x);\n    }\n        \n    return val;\n}\n\nfloat discret(float t,float ofs,float samp)\n{      \n    return FX(floor((t+ofs)*samp+0.5)/samp-ofs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*3.-1.0;\n    float sign = FX(t);\n#if IQ_TEST\n    float s = SAMPLES;\n#else\n    float s = SAMPLES/ZOOM;\n#endif\n    float of = fract(iTime)/s;\n    float disc = discret(t,of,s);\n    float rest = restore(t,of,s);\n\n    rest = clamp((1. - abs(rest*0.25+0.5-uv.y)*5.0/(0.01+abs(dFdx(rest)))),0.,1.);\n    \n    sign = clamp((1. - abs(sign*0.25+0.5-uv.y)*5.0/(0.01+abs(dFdx(sign)))),0.,1.);\n    \n    float dto = (t+of)*s+0.5;\n    float dt = floor(dto);\n    float x = ((dto - dt)-0.5);\n    disc = disc*DB+0.5;\n    disc = abs(disc-uv.y)>0.005 || abs(x)>0.007*s ? 0. : 1.;\n\n    vec3 vawe = vec3(1.,1.,0.5)*sign;\n    vec3 rez = vec3(0.7,0.7,1.0)*rest;\n    vec3 dots = vec3(disc);\n\n    vec3 col= clamp(dots + vawe + rez,vec3(0.),vec3(1.));\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2330, 2353, 2374, 2374, 2414], [2416, 2433, 2452, 2452, 2868], [2870, 2870, 2915, 2915, 3181], [3183, 3183, 3228, 3228, 3285], [3287, 3287, 3344, 3344, 4161]], "test": "untested"}
{"id": "mlB3z1", "name": "Anti-aliased grid 2023", "author": "darkeclipz", "description": "grid", "tags": ["grid"], "likes": 0, "viewed": 358, "published": 3, "date": "1672844425", "time_retrieved": "2024-07-30T18:17:52.091136", "image_code": "mat2 rot(float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Rotate the grid to show aliasing.\n    uv *= rot(0.2*iTime);\n    \n    // Time varying pixel color\n    vec3 col = vec3(1);\n    \n    // Scale the grid so we have more lines.\n    float gridSize = 4.;\n    \n    // Grid lines size independent of the scale of uv.\n    float gridLineSize = fwidth(uv.x) * gridSize;\n    \n    // Domain repetition and offsetting.\n    vec2 repeatedUV = abs(fract(gridSize * uv) - 0.5);\n    \n    // Smoothstep to get the grid lines.\n    vec2 grid = smoothstep(gridLineSize, 0.0, repeatedUV);\n    \n    // Add the grid line colors to the output color.\n    vec3 gridLineColor = vec3(0.8);\n    col = mix(gridLineColor, col, clamp(grid.x + grid.y, 0.0, 1.0));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 95], [97, 97, 154, 204, 1013]], "test": "untested"}
{"id": "mlBGz1", "name": "Genuary2023 jan.4", "author": "z0rg", "description": "https://genuary.art/ Intersections", "tags": ["genuary"], "likes": 4, "viewed": 182, "published": 3, "date": "1672844146", "time_retrieved": "2024-07-30T18:17:52.873046", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cuv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    col += texture(iChannel0, vec2(-1.,-1.)*uv).xyz;\n    col += texture(iChannel0, uv*vec2(1.,2.)).xxx*vec3(1.000,0.102,0.369);\n        col += texture(iChannel0, vec2(.5,-2.)*uv.yx-vec2(.75,0.)).xyz;\n    col *= 200.;\n\n    col = mix(vec3(0.05), vec3(1.), sat(col));\n    vec2 grid = sin(cuv*100.)-.99;\n    col += vec3(1.)*sat(min(grid.x, grid.y)*50.)*.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = vec3(0.0);\n    float t = iTime*1.;\n    vec2 pos = uv - vec2(sin(t*.25), sin(t)*.5)*.25;\n    float shape = length(pos)-0.001;\n    float sharp = iResolution.x;\n    col = mix(col, vec3(1.), 1.-sat(shape*sharp));\n    col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz*1., .99);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBGz1.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 988]], "test": "untested"}
{"id": "mlBGR1", "name": "Genuary2023 jan.3", "author": "z0rg", "description": "https://genuary.art/ Glitch Art", "tags": ["genuary"], "likes": 8, "viewed": 271, "published": 3, "date": "1672844111", "time_retrieved": "2024-07-30T18:17:53.932214", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        //if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    vec2 off = vec2(.005)*sin(uv.y*50.+10000000.+iTime*100.)*1.5;\n    vec3 rgb = texture(iChannel1, uv+off).x*vec3(1.,0.,0.)+\n    texture(iChannel1, uv).y*vec3(0.,1.,0.)+\n    texture(iChannel1, uv-off).z*vec3(0.,0.,1.)+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.2\n#define GLOW_OPACITY 1.76\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = .75;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    vec3 pc = p-vec3(0.,-1.2,-1.5);\n    float t = iTime*.25;\n    pc.xy *= r2d(t);\n    pc.yz *= r2d(t*.7);\n    float shape = _cucube(pc, vec3(.5), vec3(0.1));\n    shape = mix(shape, length(pc)-.5, 55.5);\n    acc = _min(acc, vec2(shape, 2.));\n    acc = _min(acc, vec2(-p.y, 0.));\n    acc = _min(acc, vec2(-p.z, 1.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec4 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 20.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec4(res.x, distance(p, ro), res.y, float(i));\n        p+=rd*res.x*.5;\n    }\n    return vec4(-1.);\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec4 res)\n{\n    vec3 col = n*.5+.5;\n    if (res.z == 1.)\n    {\n    float scales = 5000.*(mod(round(iTime*1.),5.)+1.);\n        col = vec3(1.)*sat(sin(p.x*scales+1000000.+iTime));\n        col = mix(col, vec3(1.,0.,0.)*col, sat(sin((p.y+p.x)*100000.-iTime*10.)));\n        col *= sat(sin(p.x*5.+round(iTime))*sin(p.y*5.+round(iTime*sign(sin(iTime))))*10.);\n    }\n    if (res.z == 0.)\n    {\n        col = pow(texture(iChannel2, p.xz*.5).y, 2.)*.2*vec3(1.)\n        *pow(sat(dot(n, normalize(vec3(-1.)))),.5)*.15;\n    }\n    if (res.z == 2.)\n    {\n        col = sat(sat(dot(rd, n))*vec3(1.,.2,-1.));\n    }\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,-2.,-8.);\n    vec3 ta = vec3(0.5,-0.8,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec4 res = trace(ro, rd, 128);\n    float depth = 100.;\n    \n    if (res.y > 0.)\n    {\n    depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(p, n, rd, res);\n        float spec = .00001;\n        float specpow = pow(texture(iChannel2, p.xz*.5).x,2.)*.5;\n        vec3 refl = normalize(reflect(rd, n)+(vec3(rand(), rand(), rand())-.5)*spec);\n        vec4 resrefl = trace(p+n*0.01, refl, 128);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+n*0.01+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n            col += specpow*getMat(prefl, nrefl, refl, resrefl);\n        }\n        col += vec3(0.2,.2,.9)*(1.-(res.w/128.))*.1;\n    }\n    //col = mix(col, vec3(0.2,.2,.9), 1.-exp(-depth*0.02));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ouv = (fragCoord)/iResolution.xy;\n  \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col = sat(col);\n    col *= 1.5/(col+1.);\n    col = pow(col, vec3(.7));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31811, "src": "https://soundcloud.com/2020visionrecordings/jensen-interceptor-x-assembler?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        //if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBGR1.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1261]], "test": "untested"}
{"id": "dlBGR1", "name": "Genuary2023 jan.2", "author": "z0rg", "description": "https://genuary.art/ Made in 10 minutes", "tags": ["genuary"], "likes": 1, "viewed": 176, "published": 3, "date": "1672844087", "time_retrieved": "2024-07-30T18:17:54.841782", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat _seed;\nfloat hash11(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\nfloat rand()\n{\n    return hash11(_seed++);\n}\nvec3 gradient(float i)\n{\nvec3 grad[4];\n        grad[0] = vec3(0.765,0.376,0.314);\n        grad[1] = vec3(0.349,0.871,0.910);\n        grad[2] = vec3(0.765,0.376,0.314);\n        grad[3] = vec3(0.137,0.122,0.937)*2.;\n    float idx = sat(i)*3.0;\n    int prevIdx = int(idx);\n    int nextIdx = min(prevIdx+1, 3);\n    vec3 prev = grad[prevIdx];\n    vec3 next = grad[nextIdx];\n    float lrp = idx - float(prevIdx);\n    return mix(prev, next, smoothstep(0.,1.,lrp));\n}\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.05);\n    \n    vec2 uv2 = uv;\n    float rep = .1;\n       uv2.y += sin(uv2.x*3.)*.1+.2*sin(uv2.y*5.+uv.x*5.+iTime*.2);\n    float lines = sin(uv2.y*280.)+.9999;\n    \n    float mask = length(uv)-.25;\n    float sharp = iResolution.x*.5;\n    col = mix(col, gradient(length(uv2)*2.), (1.-sat(lines))*(1.-sat(mask*sharp)));\n    col = mix(col, gradient(length(-uv2)*2.).zxy, 1.-sat((abs(mask)-.001)*sharp));\n    col += gradient(length(uv2)*2.)*(1.-sat(lines*.5))*.5*(1.-sat(length(uv)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    float stp = .007;\n    uv = floor((uv/stp))*stp;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec3 col = rdr(uv);\n    col += pow(rand(),.5)*.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBGR1.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[443, 443, 469, 469, 516], [517, 517, 531, 531, 561], [562, 562, 586, 586, 1021], [1022, 1022, 1041, 1041, 1560], [1562, 1562, 1619, 1619, 1865]], "test": "untested"}
{"id": "mtBGR1", "name": "Genuary2023 jan.1", "author": "z0rg", "description": "https://genuary.art/ Perfect loop", "tags": ["loop", "genuary"], "likes": 16, "viewed": 314, "published": 3, "date": "1672844056", "time_retrieved": "2024-07-30T18:17:55.658598", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n#define r2d(a) mat2(cos(a), -sin(a),sin(a), cos(a))\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float globalShape = 10000.;\n    float cnt = 32.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n        uv *= r2d((i/cnt)*.5);\n        float th = 0.0001;\n        float sz = .1+pow(mod(i+iTime*5.,cnt)/cnt,1.5)*.5;\n        float shape = abs(_sqr(uv, vec2(1.,.6)*sz))-th;\n        globalShape = min(globalShape, shape);\n        col += pow(1.-sat(shape*5.),4.)*vec3(0.506,0.710,0.996)*.1;\n    }\n    float sharp = iResolution.x;\n    col = mix(col, vec3(1.), 1.-sat(globalShape*sharp));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    vec3 col = rdr(uv*r2d(-.25));\n    col = mix(col, col.yxz, 1.-sat((abs(uv.x)-.1)*iResolution.x*.01));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBGR1.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 458, 458, 509], [562, 562, 581, 581, 1110], [1112, 1112, 1169, 1169, 1370]], "test": "untested"}
{"id": "DtsGWs", "name": "quadtree point", "author": "lanx06", "description": "quadtree", "tags": ["tree", "quad", "quadtree"], "likes": 6, "viewed": 211, "published": 3, "date": "1672840216", "time_retrieved": "2024-07-30T18:17:56.417569", "image_code": "#define T iTime*0.9\n#define pix 1.8/iResolution.y\n//vec2 dir4[4]=vec2[](vec2(1.0,0.0),vec2(0.0,1.0),vec2(0.0,-1.0),vec2(-1.0,0.0));\nvec2 dir4[4]=vec2[](vec2(1.0,1.0),vec2(1.0,-1.0),vec2(-1.0,-1.0),vec2(-1.0,1.0));\nfloat shape(vec2 uv,vec2 dir){\n    vec2 l = uv-0.5;\n    //vec2 dir=vec2(0);\n    l+=dir;\n    float thin=0.15;\n    float radius=0.5;\n    float a= smoothstep(radius+pix,radius-pix,length(l));\n    //float a= smoothstep(pix,-pix,abs(length(l)-radius)-thin);\n    return a;\n}\nfloat shape4(vec2 uv){\n    float o=0.0;\n    for(int i=0;i<4;i++){\n        //o=max(o,shape(uv,dir4[i]*0.5));\n        if(i%2==0)continue;\n        o+=shape(uv,dir4[i]*0.5);\n    }\n    o=shape(uv,vec2(0.0));\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n=500.0;\n    vec2 st = (fragCoord/iResolution.y);\n    vec2 uv=fract(st);\n    float r=0.1;\n    vec2 p=vec2(cos(T),sin(T*0.333))*0.5+vec2(iResolution.x/iResolution.y*0.5,0.5);\n    vec2 origin=0.5+floor(st);\n    float l;\n    vec3 col ;\n    \n    for(int i=0;i<5;i++){\n        float size=pow(0.5,float(i+1));\n        l=distance(p,origin)-size-r;\n        if(l>0.01)break;\n        origin+=(step(vec2(0.5),uv)-0.5)*size;\n        uv=fract((uv-0.5)*2.0);   \n    }\n    col.rg=vec2(shape4(uv));\n    col.b=smoothstep(pix,-pix,length(st-p)-r);;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 244, 244, 482], [483, 483, 505, 505, 701], [703, 703, 760, 760, 1334]], "test": "untested"}
{"id": "dtfGWj", "name": "Trippy landscape travel", "author": "z0rg", "description": "Some old never puiblished shader I did on Shader Editor on android.", "tags": ["landscape", "trippy", "synthware"], "likes": 10, "viewed": 309, "published": 3, "date": "1672832942", "time_retrieved": "2024-07-30T18:17:57.201473", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\n\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\nmat2 r2d(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c,-s,s,c);\n}\n#define sat(a) clamp(a,0.1,1.)\nfloat _sqr(vec2 uv, vec2 s)\n{\n  vec2 l = abs(uv)-s;\n  return max(l.x,l.y);\n}\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x,max(l.y,l.z));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+(r*uv.x+u*uv.y)*3.5);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(10000.,-1.);\n\nfloat height = sat(-.3+.7*abs(asin(sin(p.x+sin(p.z+iTime*.3)))))*1.5;\nacc = _min(acc, vec2(-p.y-height,1.));\n//acc = _min(acc, vec2(-p.z+550.,1.));\n//acc = _min(acc, vec2(length(p)-1.,0.));\nvec3 p2 =p+vec3(0.,20.,-45.);\np2.xy *= r2d(iTime);\np2.xz *= r2d(iTime*.7);\nacc = _min(acc, vec2(_cube(p2,vec3(5.)),0.));\n\n\nfloat tube = length(p.xy-vec2(0.,-1.5)\n  -vec2(sin(p.z+iTime+sin(p.z*.5)),cos(p.z)))-.02;\nacc = _min(acc, vec2(tube,2.));\n  return acc;\n}\n\nvec3 getNorm(float d, vec3 p)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n  vec3 p = ro;\n  for (int i = 0;i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+=rd*res.x*.5;//*mix(.1,20.,sat(length(p.xz)-55.));\n    if(res.y==2.)\n      accCol += vec3(1.,.2,.2)*(1.-sat(res.x/.2))*.25;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdrSun(vec3 rd)\n{\n  vec3 sun = (vec3(255.,215.,90.)/255.)*\n      pow(sat(5.*(-.8+\n        dot(rd,normalize(vec3(0.,-.5,1.))))),4.)\n        *float(rd.y<0.);\n  //sun = vec3(0.);\n  //sky =vec3(0.);// sat(-.5+dot(rd,normalize(vec3(0.,0.,1.))))*vec3(1.);\nreturn sun;\n}\n\nvec3 rdrSky(vec3 rd)\n{\n  vec3 cols[5];\n  cols[0] = vec3(255.,71.,52.)/255.;\n  cols[1] = vec3(255.,141.,97.)/255.;\n  cols[2] = vec3(217.,142,255.)/255.;\n  cols[3] = vec3(103.,133.,255.)/255.;\n  cols[4] = .7*vec3(93.,83.,220.)/255.;\n  float cur = pow(abs(rd.y)*15.,.5);\n  int icur = int(cur);\n  vec3 sky= mix(cols[min(icur,4)],\n    cols[min(icur+1,4)],\n    smoothstep(0.,1.,fract(cur)));\n\n        return sky*1.3;\n}\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n  if(res.z==0.)\n    return (n*.5+.5)*.5;\n  if(res.z==1.)\n    return vec3(.1)*sat(dot(rd, normalize(p-vec3(-5.))));\n  if(res.z==2.)\n  return vec3(1.,.3,.4);\n  return vec3(.1);\n}\nvec3 rdr(vec2 uv)\n{\n\n  vec3 col= vec3(0.);\n\nuv*=r2d(.2*sin(iTime*.4));\n  float t = iTime*.33;\n  vec3 ro = vec3(0.,-2.,-5.);\n  vec3 ta = vec3(sin(iTime*.2)*3.,-1.+sin(iTime*.2)*2.,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n  float depth = 100.;\n\n  vec3 res = trace(ro,rd, 256);\n  if (res.y >0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(res.x,p);\n    col = getMat(p,n,rd,res);\n  vec3 refl = normalize(reflect(rd,n)\n    +.1*(vec3(rand(),rand(),rand())));\nvec3 resrefl = trace(p+n*0.01,refl,128);\nif(p.y>-0.17)\n{\nif(resrefl.y>0.)\n{\n  vec3 prefl = p+refl*resrefl.y;\n  vec3 nrefl = getNorm(resrefl.x,prefl);\n\n  col += getMat(prefl,nrefl, refl, resrefl);\n}\nelse\n{\n  col+= rdrSky(refl)+rdrSun(refl);\n\n  }\n  }\n  }\ncol+=accCol;\ncol = mix(col, rdrSky(rd),1.-exp(-depth*0.01));\nif(depth>99.)\ncol+= vec3(1.)*pow(texture(iChannel0, rd.xy*1.5).x,5.);\nif (depth>99.)\ncol+= rdrSun(rd);\nfloat mask = 1.-sat(_sqr(\n  (uv-vec2(0.,.35))*r2d(3.14159265*.25),\n  vec2(.35))*400.);\ncol = mix(col, col.yzx,mask);\ncol = pow(col, vec3(.74545));\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n_seed = iTime+texture(iChannel0,uv).x;\n  vec3 col = rdr(uv);\n\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31810, "src": "https://soundcloud.com/airglowsounds/electrifyinglandscape?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfGWj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[411, 411, 437, 437, 482], [484, 484, 498, 498, 526], [527, 527, 546, 546, 613], [645, 645, 674, 674, 721], [722, 722, 751, 751, 806], [807, 807, 838, 838, 968], [970, 970, 997, 997, 1037], [1039, 1039, 1057, 1057, 1540], [1542, 1542, 1573, 1573, 1681], [1695, 1695, 1736, 1736, 2052], [2054, 2054, 2076, 2076, 2322], [2324, 2324, 2346, 2346, 2736], [2737, 2737, 2785, 2785, 2962], [2963, 2963, 2982, 2982, 4038], [4041, 4041, 4098, 4098, 4256]], "test": "untested"}
{"id": "dtBGzh", "name": "OpenAI rotating checkerboard", "author": "pthextract", "description": "OpenAI chatbot made this with very little directions. I am impressed. I just needed to specify header and the use of floats instead of ints. ", "tags": ["openaicheckerboard"], "likes": 0, "viewed": 186, "published": 3, "date": "1672830289", "time_retrieved": "2024-07-30T18:17:58.079126", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Center of the screen\n    vec2 center = vec2(0.5, 0.5);\n\n    // Rotate around center\n    float t = iTime;\n    float c = cos(t);\n    float s = sin(t);\n    vec2 v = vec2(c*(uv.x-center.x) - s*(uv.y-center.y) + center.x, \n                  s*(uv.x-center.x) + c*(uv.y-center.y) + center.y);\n    float f = mod(floor(v.x*10.0) + floor(v.y*10.0), 2.0);\n    vec3 col = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), f);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 625]], "test": "untested"}
{"id": "dtSGRh", "name": "1D Array Ersteller VHS", "author": "ersteller", "description": "Without a texture using only a 1D array in code.\n\nalso with VHS tape pause artifact\n", "tags": ["notexture", "ersteller", "lookuparray"], "likes": 8, "viewed": 250, "published": 3, "date": "1672820471", "time_retrieved": "2024-07-30T18:17:58.903921", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define GRID vec2(15,15)\n#define BITS 1.\n\n// only 1D arrays but at least with constructor ;(\nconst int[] aiErsteller = int[] (\n      0,0,0,0,0,0,0,\n\t  0,0,0,1,0,0,0,\n\t  0,0,1,1,1,0,0,\n\t  0,0,0,1,0,0,0,\n\t  0,0,0,0,0,0,0,\n\t  1,1,1,1,1,1,1,\n\t  1,0,1,1,1,0,1,\n\t  1,0,1,1,1,0,1,\n      0,0,1,1,1,0,0,\n\t  0,0,1,1,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,1,1,0,1,1,0,\n      0,0,0,0,0,0,0\n);\n\nconst vec2 bitmap_size = vec2(7, 15);\n\n\nfloat random(float co){\n    return fract(sin(co)*33333.);\n}\n\nvec3 getRandomGridColor( in vec2 uv , in vec2 grid_size, float bits ){\n    int frac = int(fract(iTime)*4095.);\n    vec2 fetch_pos = vec2( uv * grid_size);\n    int idx = int(fetch_pos.x) + ( int(grid_size.y) - 1 - int(fetch_pos.y)) * int(grid_size.x);\n    float seed = float( frac + idx);\n    return vec3( floor(random(3. * seed)* (bits+1.))  / bits ,\n        floor(random(11. * seed)* (bits+1.)) / bits ,\n        floor(random(13. * seed)* (bits+1.)) / bits );\n}\n\n// input 0 to 1\nvec3 getValueXY( in vec2 uv  )\n{\n\tfloat value = 1.;\n    vec3 col ;\n    // transform to grid pos\n    vec2 fetch_pos = vec2( uv * bitmap_size.y );\n    // check if in array range\n\tif( fetch_pos.x >= 0.  && fetch_pos.y >= 0.\n\t\t&& fetch_pos.x < bitmap_size.x  && fetch_pos.y < bitmap_size.y  )\n\t{\n        // convert x y to index \n\t\tint idx = int(fetch_pos.x) + ( int(bitmap_size.y) - 1 - int(fetch_pos.y)) * int(bitmap_size.x);\n\t\tvalue = float(1 - aiErsteller[idx]); // invert color value of 1 means black\n        \n\t} else value = 1.;  // outer color;\n\treturn vec3(value);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coord (and force square grid aspect ratio)\n    vec2 uv = vec2(fragCoord.x /iResolution.y,fragCoord.y/iResolution.y);\n    // shift to center\n    uv.x = uv.x-0.6;\n    uv.y = uv.y-0.;\n    \n    // emulate VHS-Tape pause artifact\n    float amp = sin((uv.y + iTime*0.5)*5.) - 0.95;\n    if (amp > 0.){\n        uv.x -= amp*.5*sin((- uv.y*10.+ iTime)*5.)*0.5;\n    }\n\n    vec3 col = getValueXY(uv); // get color value from array\n    \n    // random color noise on the artifact\n    if (amp > 0. && col.x == 0.){\n        col = getRandomGridColor(uv, GRID, BITS);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 590, 590, 626], [1679, 1679, 1736, 1796, 2344]], "test": "untested"}
{"id": "ml2GRR", "name": "Genuary2023 Snow Shader Fixed", "author": "oneshade", "description": "I don't know, it's a bit odd looking, but no noise at least!", "tags": ["shader", "snow", "fix"], "likes": 19, "viewed": 345, "published": 3, "date": "1672812813", "time_retrieved": "2024-07-30T18:18:00.065815", "image_code": "mat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 Hash33(in vec3 p) {\n    p = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p += dot(p, p.yxz + 33.33);\n    return fract((p.xxy + p.yxx) * p.zyx);\n}\n\nfloat map(in vec3 p) {\n    p.y += iTime;\n    float w = 4.0;\n    vec3 cell = floor(p / w) * w;\n    p -= cell + 0.5 * w;\n    p.xz *= Rotate2D(iTime * Hash11(cell.y) * 2.0);\n    p -= 2.0 * Hash33(cell) - 1.0;\n    return 0.5 * (length(p) - 0.25);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec3 ro = vec3(10.0 * mouse, 5.0);\n\n    vec3 fd = -normalize(ro);\n    vec3 rt = normalize(vec3(-fd.z, 0.0, fd.x));\n    vec3 up = cross(rt, fd);\n\n    vec3 rd = normalize(uv.x * rt + uv.y * up + fd);\n\n    color = vec3(0.5, 0.5, 1.0) * pow(1.0 - length(fragCoord / iResolution.xy - 0.5), 0.8);\n    if (rd.y < 0.0 && ro.y > -10.0) {\n        color = mix(color, vec3(1.0), pow(-rd.y, 0.4));\n    }\n\n    bool inside = map(ro) < 0.0;\n    float total = 0.0;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        if (inside) {\n            total += 0.03;\n            t += 0.02;\n            if (map(ro + rd * t) >= 0.0) inside = false;\n        }\n\n        else {\n            t += map(ro + rd * t);\n            if (map(ro + rd * t) < 1e-3) inside = true;\n        }\n\n        if (total > 1.0 || t > 60.0 || ro.y + rd.y * t < -10.0) break;\n    }\n\n    color = mix(color, vec3(1.0), total);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2GRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 99], [101, 142, 168, 168, 254], [256, 256, 280, 280, 405], [407, 407, 429, 429, 651], [653, 653, 708, 708, 1790]], "test": "untested"}
{"id": "dt23zz", "name": "glsl mix function", "author": "jonasfrey", "description": "mix", "tags": ["mix"], "likes": 2, "viewed": 520, "published": 3, "date": "1672790159", "time_retrieved": "2024-07-30T18:18:01.106033", "image_code": "float f_n_mixed(float n1, float n2, float n_intensity){\n//https://thebookofshaders.com/glossary/?search=mix\n float n_mixed = n1*(1.-n_intensity)+n2*n_intensity;\n return n_mixed;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = fragCoord/iResolution.xy;\n    \n    vec4[] a_o = vec4[] (\n        // red to black\n        vec4(\n            f_n_mixed(1., 0., o_fc_nor.x),\n            0.,\n            0.,\n            0.\n        ), \n        // green to black\n        vec4(\n            0.,\n            f_n_mixed(1., 0., o_fc_nor.x),\n            0.,\n            0.\n        ), \n        // blue to black \n        vec4(\n            0.,\n            0.,\n            f_n_mixed(1., 0., o_fc_nor.x),\n            0.\n        ), \n        // from red to blue \n        vec4(\n            f_n_mixed(1., 0., o_fc_nor.x),\n            0.,\n            f_n_mixed(0., 1., o_fc_nor.x),\n            0.\n        ), \n        // red to blue different \n        vec4(\n            f_n_mixed(0., 1., 1.-o_fc_nor.x),\n            0.,\n            f_n_mixed(0., 1., o_fc_nor.x),\n            0.\n        ),\n        // from blue to red \n        vec4(\n            f_n_mixed(0., 1., o_fc_nor.x),\n            0.,\n            f_n_mixed(1., 0., o_fc_nor.x),\n            0.\n        ), \n        // from red to black twice\n        vec4(\n            f_n_mixed(1., 0., fract(o_fc_nor.x*2.)),\n            0., \n            0.,\n            0.\n        ), \n        // from red to black twice\n        vec4(\n            f_n_mixed(1., 0., fract(o_fc_nor.x*2.)),\n            0., \n            0.,\n            0.\n        ), \n        // from red to black to red\n        vec4(\n            f_n_mixed(1., 0., 1.-(abs(o_fc_nor.x-0.5)*2.)),\n            0., \n            0.,\n            0.\n        )\n    );\n    float n_index = (o_fc_nor.y/(1./ float(a_o.length())));\n    float n_index_flr = floor(n_index);\n    \n    vec4 o = a_o[int(n_index_flr)];\n    float n_index_nor = (n_index_flr/float(a_o.length()));\n    \n    float n_d_line = fract(n_index);\n    n_d_line = smoothstep(0.05, 0.075, n_d_line);\n    float n_d_line2 = float(n_d_line < 0.01);\n    \n    fragColor = o*n_d_line+n_d_line2;\n    //fragColor = sqrt(fragColor);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt23zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 107, 179]], "test": "untested"}
{"id": "dl2GRz", "name": "StarFinger", "author": "JB_0x0003", "description": "Shape comes from floating point precision errors when running fract(sin(x)) with a very large x. Looks bad when fullscreened.", "tags": ["noise", "stars", "precisionerrors"], "likes": 3, "viewed": 184, "published": 3, "date": "1672788321", "time_retrieved": "2024-07-30T18:18:02.056492", "image_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2\t\tu_resolution;\nuniform float \t\tu_time;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n\tvec2 st = fragCoord.xy/iResolution.xy;\n\n\tvec3 color = texture(iChannel0,st).xyz;\n    color += texture(iChannel1,st).xyz * 0.4;\n    //color = vec3(1.0,1.0,1.0);\n\tfragColor = vec4(color,1.0);\n\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2\t\tu_resolution;\nuniform float \t\tu_time;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n\tvec2 st = fragCoord.xy/iResolution.xy;   \n    vec2 Center1 = vec2(0.1,0.0);\n    vec2 Center2 = vec2(1.0,0.9);\n\tvec2 stRelCenter1 = st - Center1;\n    vec2 stRelCenter2 = st - Center2;\n    \n    \n    st += vec2(0.5,0.4);\n\tst *= 2.4;\n    \n    vec3 color1 = vec3(1.0, 0.0, 1.0);\n    vec3 color2 = vec3(1.0, 0.7, 0.0);\n    vec2 centerColor = vec2(1.5,1.0);\n    \n    //vec2 stColor = st - CenterColor;\n    vec2 stColor = st / sqrt(st.x * st.x + st.y * st.y);\n    centerColor /= sqrt(centerColor.x * centerColor.x + centerColor.y * centerColor.y);\n    centerColor = centerColor;\n    float theta = acos( dot(centerColor, stColor));\n    \n    vec3 hue = mix(color1, color2, theta * 2.345);\n\t\n\tst.x = sqrt( ((stRelCenter1.x * stRelCenter1.x ) + ( stRelCenter1.y * stRelCenter1.y  )) * abs( st.x + st.y - 2.0 ))\n                    - sqrt((( stRelCenter2.x * stRelCenter2.x  ) + ( stRelCenter2.y * stRelCenter2.y  ) ) * abs(st.x + st.y - 2.0) )  ;\n    st.y = st.x;\n    \n\tfloat distFromCenter = sqrt((st.x * st.x) + (st.y * st.y));\n\n\tfloat noise = fract(sin(dot(st.xy,\n\t\t\t\tvec2(8.989, 11.448)\n\t\t\t\t)) * 70000000.0 + \n\t\t\t\tmix(1.3928,100.1093, fract(sin(\n\t\t\t\t\tiTime * 0.003 * pow(distFromCenter,0.4))))  );\n\n    noise = pow(noise,3.9) ;\n    //noise = st.x;\n    vec3 color = vec3(hue * noise);\n\tfragColor = vec4(color,1.0);\n\n}", "buffer_a_inputs": [], "buffer_b_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2\t\tu_resolution;\nuniform float \t\tu_time;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    ivec2 pos = ivec2(fragCoord.xy);\n    \n\tvec3 fresh = texture(iChannel0,st).xyz;\n    vec3 old = texture(iChannel1,st).xyz;\n    \n    vec3 color = old * 0.6 + fresh * 0.5;\n    \n\tfragColor = vec4(color,1.0);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 pos = ivec2(fragCoord.xy);\n    \n    vec3 glow = vec3(0.0);\n    vec3 fetch = vec3(0.0);\n    int kernelRadius = 2;\n    int kernelDiameter = kernelRadius * 2 + 1;\n    \n    for (int i = 0; i < kernelDiameter; ++i){\n    \n        for (int j = 0; j < kernelDiameter; ++j){\n        \n            fetch = texelFetch(iChannel0, ivec2(pos.x -2 + i, pos.y -2 + j),0).xyz;\n            fetch.x = pow(fetch.x, 2.0);\n            fetch.y = pow(fetch.y, 2.0);\n            fetch.z = pow(fetch.z, 2.0);\n            \n            fetch = fetch * (1.0 - float(abs(i - kernelRadius) + abs(j - kernelRadius)) * 0.2 );\n            \n            glow += fetch;\n        }\n    \n    }\n    \n    //glow *= 0.5;\n    \n    \n    vec3 color = glow;\n    \n\tfragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2GRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 156, 156, 352]], "test": "untested"}
{"id": "ctsGD4", "name": "Densor Notation", "author": "Dirk", "description": "\"Densor Notation\" is a pun on \"Tensor Notation\" used in Tensor Calculus. \nThe notation is a work in progress, and I plan to update it as I go (:\nI would love input form my betters on how these variables may be designated.", "tags": ["syntax", "notation", "densor"], "likes": 3, "viewed": 202, "published": 3, "date": "1672772790", "time_retrieved": "2024-07-30T18:18:03.027895", "image_code": "\n\n    //////////////////////////////\n    //                          //\n    //  DIRK'S DENSOR NOTATION  //\n    //                          //\n    //////////////////////////////\n\n\n    #define  loop mainImage\n\n    #define  iR iResolution\n    #define  iM iMouse\n    #define  iT iTime\n    \n    #define  v2 vec2\n    #define  v3 vec3\n    #define  v4 vec4\n    \n    #define  i2 ivec2\n    #define  i3 ivec3\n    #define  i4 ivec4\n    \n    #define  m2 mat2\n    #define  m3 mat3\n    #define  m4 mat4\n\n    #define  A  abs\n    #define  B  break\n    #define  C  clamp\n    #define  D  dot\n    #define  E  floor\n    #define  F  float\n    #define  G  texelFetch(iChannel0,i2(xy),0)\n    #define H(k) texelFetch(iChannel1,i2(k,0),0)\n    #define  I  int\n    #define  J  \n    #define  K  fract\n    #define  L  length\n    #define  M  max\n    #define  N  normalize\n    #define O(c) for( i=0; i<c; i++ )\n    #define  P  pow\n    #define  Q  mix\n    #define  R  return\n    #define  S  step\n    #define  SS smoothstep\n    #define  T  texture( iChannel2, p )\n    #define U(p) (2.0*p-iR.xy)/iR.y\n    #define  V  void\n    #define  W  min\n    #define  X  cross\n    #define  Y  mirror\n    #define  Z  reflect\n\n\nV loop( out v4 pixar, in v2 pixel )\n{\n    v2 uv = (2.0*pixel-iR.xy)/iR.y;\n    v2 uv2 = K( sin( iT+uv*3.0+cos(iT*2.7+uv))+uv*10.0)-0.5;\n    \n    F f = L( uv2 ) - 0.01;\n    f = SS( 0.02, 0.03, f );\n\n    v3 c = v3( 0.0, 0.7, 0.0 )*( 0.5 + 0.5*f );\n\n    pixar = v4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1178, 1178, 1215, 1215, 1448]], "test": "untested"}
{"id": "ct2Gzz", "name": "Glitched lines", "author": "callumacrae", "description": "For genuary day three, made a glitchy thing!", "tags": ["glitch", "genuary", "genuary2023", "genuary3"], "likes": 5, "viewed": 311, "published": 3, "date": "1672770608", "time_retrieved": "2024-07-30T18:18:03.944444", "image_code": "#define LINES 20.0\n#define LINE_WIDTH 4.0\n#define LINE_SMOOTH_WIDTH 1.5\n\n#define GLITCH_COLOR_INVERT_ENABLED true\n#define GLITCH_COLOR_SPLIT_ENABLED true\n#define GLITCH_COLOR_SWAP_ENABLED true\n\n#define GLITCH_POSITION_RECT_SWAP_ENABLED true\n#define GLITCH_POSITION_Y_BAND_SHIFT_ENABLED true\n#define GLITCH_POSITION_FLIP_ENABLED true\n\n#define GLITCH_OTHER_BREAK_REFLECTION_ENABLED true\n#define GLITCH_OTHER_BLANK_ENABLED true\n#define GLITCH_OTHER_LINE_WIDTH_CHANGES_ENABLED true\n\n/** VENDOR START **/\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(int n) { return rand(float(n)) * 1000.0; }\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){ const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }\n\n// https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n/** VENDOR END **/\n\nfloat drawLine(vec2 fragCoord, float i) {\n  float lineWidth = LINE_WIDTH;\n\n  if (GLITCH_OTHER_LINE_WIDTH_CHANGES_ENABLED) {\n    float lineWidthNoise = snoise(vec2(iTime * 2.0 + rand(35), 0.0));\n    if (lineWidthNoise < -0.7) {\n      lineWidth *= 3.0;\n    }\n  }\n\n  float innerWidth = lineWidth / 2.0;\n  float outerWidth = lineWidth / 2.0 + LINE_SMOOTH_WIDTH;\n\n  float lineY = iResolution.y / LINES * (i + 0.5) ;\n  float angleRoot = snoise(vec2(iTime * 0.1 + rand(1), 0.0)) * 0.2;\n  float angleFactor = snoise(vec2(iTime * 0.08 + rand(2), 0.0)) * 0.015;\n  float angle = angleRoot + (LINES / 2.0 - i) * angleFactor;\n\n  float x = fragCoord.x;\n\n  bool shouldReflect = !GLITCH_OTHER_BREAK_REFLECTION_ENABLED ||\n    snoise(vec2(iTime * 1.2 + rand(15), 0.0)) > -0.5;\n  float reflectAt = iResolution.x * 0.33 + snoise(vec2(iTime * 0.1 + rand(3), 0.0)) * 100.0;\n  float reflectedMultFact = 1.5 + snoise(vec2(iTime * 0.12 + rand(4), 0.0)) * 1.0;\n  x = shouldReflect && x < reflectAt\n    ? reflectAt + reflectedMultFact * (reflectAt - x)\n    : x;\n\n  float lineYAtX = lineY - x * tan(angle);\n\n  if (fragCoord.y > lineYAtX - outerWidth && fragCoord.y < lineYAtX + outerWidth) {\n    return smoothstep(outerWidth, innerWidth, abs(fragCoord.y - lineYAtX));\n  }\n  return 0.0;\n}\n\nvoid generateRectangle(out float width, out float height, out vec2 topLeft,\n    int randFrom, float minWidth, float maxWidth, float widthVar,\n    float minHeight, float maxHeight, float heightVar) {\n  float widthNoise = (snoise(vec2(iTime * widthVar + rand(randFrom + 12))) + 1.0) / 2.0;\n  width = iResolution.x * (minWidth + widthNoise * (maxWidth - minWidth));\n  float heightNoise = (snoise(vec2(iTime * heightVar + rand(randFrom + 13))) + 1.0) / 2.0;\n  height = iResolution.x * (minHeight + heightNoise * (maxHeight - minHeight));\n\n  topLeft = iResolution.xy * (vec2(\n    snoise(vec2(iTime * 0.05 + rand(randFrom + 6), 0.0)),\n    snoise(vec2(iTime * 0.1 + rand(randFrom + 7), 0.0))\n  ) * 0.5 + 0.5) - width / 2.0;\n}\n\nbool isInRectangle(float width, float height, vec2 topLeft, vec2 fragCoord) {\n  return fragCoord.x > topLeft.x && fragCoord.x < topLeft.x + width &&\n    fragCoord.y > topLeft.y && fragCoord.y < topLeft.y + height;\n}\n\nvoid swapRectangle(inout vec2 fragCoord, int randFrom, int randFromB) {\n  float width;\n  float height;\n  vec2 topLeftA;\n\n  generateRectangle(width, height, topLeftA, randFrom, 0.2, 0.5, 0.01, 0.2, 0.5, 0.01);\n\n  // Copied from generateRectangle\n  vec2 topLeftB = iResolution.xy * (vec2(\n    snoise(vec2(iTime * 0.05 + rand(randFromB + 10), 0.0)),\n    snoise(vec2(iTime * 0.05 + rand(randFromB + 11), 0.0))\n  ) * 0.5 + 0.5) - height / 2.0;\n\n  if (isInRectangle(width, height, topLeftA, fragCoord)) {\n    fragCoord.x = fragCoord.x - topLeftA.x + topLeftB.x;\n    fragCoord.y = fragCoord.y - topLeftA.y + topLeftB.y;\n  } else if (isInRectangle(width, height, topLeftB, fragCoord)) {\n    fragCoord.x = fragCoord.x - topLeftB.x + topLeftA.x;\n    fragCoord.y = fragCoord.y - topLeftB.y + topLeftA.y;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 colorOut = vec3(0.0);\n\n  if (GLITCH_POSITION_RECT_SWAP_ENABLED) {\n    int randFrom = int(floor(snoise(vec2(iTime * 0.2 + rand(35), 0.0)) * 2.0));\n    int randFromB = int(floor(snoise(vec2(iTime * 0.2 + rand(36), 0.0)) * 2.0));\n    float rectSwapNoise = snoise(vec2(iTime * 2.0 + rand(14), 0.0));\n    if (rectSwapNoise < -0.6) swapRectangle(fragCoord, randFrom, randFromB);\n    if (rectSwapNoise < -0.9) swapRectangle(fragCoord, randFrom + 1000, randFromB + 1000);\n    if (rectSwapNoise < -0.05 && rectSwapNoise > -0.15) swapRectangle(fragCoord, randFrom + 2000, randFromB + 2000);\n    if (rectSwapNoise > 0.6) swapRectangle(fragCoord, randFrom + 10000, randFromB + 10000);\n    if (rectSwapNoise > 0.9) swapRectangle(fragCoord, randFrom + 11000, randFromB + 11000);\n  }\n\n  float bandShiftNoise = snoise(vec2(iTime * 1.3 + rand(23), 0.0));\n  if (GLITCH_POSITION_Y_BAND_SHIFT_ENABLED && bandShiftNoise < -0.3) {\n    float randAmount = rand(floor(snoise(vec2(iTime * 0.2 + rand(37), 0.0)) * 4.0)) * 80.0;\n    float bandHeight = 40.0 + randAmount; // TODO: randomise this per band?\n    fragCoord.x += rand(floor(fragCoord.y / bandHeight)) * 300.0;\n  }\n\n  if (GLITCH_POSITION_FLIP_ENABLED) {\n    float flipNoise = snoise(vec2(iTime * 1.5 + rand(27), 0.0));\n    float flipDirectionNoise = snoise(vec2(iTime * 8.0 + rand(28), 0.0));\n\n    if (flipNoise < -0.85) {\n      if (flipDirectionNoise < 0.0) {\n        fragCoord.x = iResolution.x - fragCoord.x;\n      } else {\n        fragCoord.y = iResolution.y - fragCoord.y;\n      }\n    } else if (flipNoise < 0.5 && flipNoise > 0.2) {\n        int randFrom = 9292 + int(floor(snoise(vec2(iTime * 3.0 + rand(29), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.7, 0.15, 0.3, 0.7, 0.15);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (flipDirectionNoise < 0.0) {\n            fragCoord.x = 2.0 * glitchTopLeft.x + glitchWidth - fragCoord.x;\n          } else {\n            fragCoord.y = 2.0 * glitchTopLeft.y + glitchHeight - fragCoord.y;\n          }\n        }\n    }\n  }\n\n  for (float i = -5.0; i != LINES + 5.0; ++i) {\n    float color = drawLine(fragCoord, i);\n    if (color > 0.0) {\n      colorOut = vec3(color);\n    }\n\n    // TODO: move out of loop for perf somehow?\n    if (GLITCH_COLOR_SPLIT_ENABLED) {\n      bool shouldGlitchColor1 = snoise(vec2(iTime * 3.0 + rand(18), 0.0)) < -0.5;\n      if (shouldGlitchColor1) {\n        int randFrom = 2347 + int(floor(snoise(vec2(iTime * 4.0 + rand(30), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 1.3, 0.2, 0.1, 1.3, 0.2);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (color > 0.0) {\n            colorOut.r = 0.0;\n          }\n\n          // Multiplying the noise, flooring it, and using it to generate a random\n          // number creates a sort of jerking effect\n          vec2 colorSplitDist = vec2(\n              50.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(16), 0.0)) * 100.0))),\n              7.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(17), 0.0)) * 40.0)))\n              );\n          float otherColor = drawLine(fragCoord + colorSplitDist, i);\n          if (otherColor > 0.0) {\n            colorOut.r = otherColor;\n          }\n        }\n      }\n\n      // Yes this is duplicated im sorry lol\n      bool shouldGlitchColor2 = snoise(vec2(iTime * 3.0 + rand(24), 0.0)) < -0.5;\n      if (shouldGlitchColor2) {\n        int randFrom = 8374 + int(floor(snoise(vec2(iTime * 5.0 + rand(31), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 1.3, 0.4, 0.1, 1.3, 0.15);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (color > 0.0) {\n            colorOut.r = 0.0;\n          }\n\n          // Multiplying the noise, flooring it, and using it to generate a random\n          // number creates a sort of jerking effect\n          vec2 colorSplitDist = vec2(\n              60.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(25), 0.0)) * 100.0))),\n              4.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(26), 0.0)) * 40.0)))\n              );\n          float otherColor = drawLine(fragCoord + colorSplitDist, i);\n          if (otherColor > 0.0) {\n            colorOut.r = otherColor;\n          }\n        }\n      }\n    }\n  }\n\n  float blankNoise = snoise(vec2(iTime * 0.7 + rand(19), 0.0));\n  if (GLITCH_OTHER_BLANK_ENABLED) {\n    if (blankNoise < -0.8) {\n      colorOut = vec3(0.0);\n    } else if (blankNoise > 0.3) {\n      float blankNoise2 = snoise(vec2(iTime * 1.6 + rand(20), 0.0));\n      if (blankNoise2 < -0.1) {\n        int randFrom = 2479 + int(floor(snoise(vec2(iTime * 2.0 + rand(32), 0.0)) * 1.5));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 0.7, 0.06, 0.2, 0.6, 0.05);\n\n      if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n        colorOut = vec3(0.0);\n      }\n    }\n    }\n  }\n\n  float invertColorNoise = snoise(vec2(iTime * 0.6 + rand(5), 0.0));\n  if (GLITCH_COLOR_INVERT_ENABLED) {\n    if (invertColorNoise < -0.85) {\n      colorOut = vec3(1.0) - colorOut;\n    } else if (invertColorNoise > 0.4) {\n      float invertColorNoise2 = snoise(vec2(iTime * 3.2 + rand(18), 0.0));\n      if (invertColorNoise2 < -0.3) {\n        int randFrom = 7254 + int(floor(snoise(vec2(iTime * 2.0 + rand(33), 0.0)) * 2.5));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.6, 0.18, 0.2, 0.6, 0.22);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          colorOut = vec3(1.0) - colorOut;\n        }\n      }\n    }\n  }\n\n  float swapColorNoise = snoise(vec2(iTime * 0.6 + rand(21), 0.0));\n  if (GLITCH_COLOR_SWAP_ENABLED && colorOut.r + colorOut.g + colorOut.b > 2.5) {\n    float hue = snoise(vec2(iTime * 0.3 + rand(23), 0.0)) / 2.0 + 0.5;\n    vec3 newColor = hsv2rgb(vec3(hue, 0.75, 0.75));\n\n    if (swapColorNoise < -0.75) {\n      colorOut = newColor;\n    } else if (swapColorNoise > 0.4) {\n      float swapColorNoise2 = snoise(vec2(iTime * 2.6 + rand(22), 0.0));\n      if (swapColorNoise2 < -0.3) {\n        int randFrom = 29482 + int(floor(snoise(vec2(iTime * 0.5 + rand(34), 0.0)) * 5.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.6, 0.2, 0.2, 0.6, 0.2);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          colorOut = newColor;\n        }\n      }\n    }\n  }\n\n  fragColor = vec4(colorOut, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2Gzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 570, 590, 590, 628], [629, 629, 648, 648, 682], [683, 683, 705, 705, 744], [745, 745, 766, 766, 1527], [1529, 1631, 1653, 1653, 1810], [1832, 1832, 1873, 1873, 3091], [3093, 3093, 3291, 3291, 3811], [3813, 3813, 3890, 3890, 4028], [4030, 4030, 4101, 4101, 4828], [4830, 4830, 4885, 4885, 11983]], "test": "untested"}
{"id": "Dlj3Rz", "name": "Iteration slicer", "author": "Xerox1", "description": "Was trying to figure how https://www.shadertoy.com/view/ddS3RR worked (by kishimisu)", "tags": ["2d", "tutorial", "debug", "short"], "likes": 2, "viewed": 183, "published": 3, "date": "1672767769", "time_retrieved": "2024-07-30T18:18:04.946764", "image_code": "//Was trying to figure how https://www.shadertoy.com/view/ddS3RR worked (by kishimisu)\n//Use smoothstep.io if you want to scrub floats with mouse\n\n#define S(a,b) mix(1., a, sin(b)*.5+.5)\n#define s (.34-1.)\n#define n iResolution\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    float[200] x; //slices for d\n    float[200] y1; //slices for a.x\n    float[200] y2; //slices for a.y\n    float[200] y3; //slices for a.z\n    vec3 a,r,t = normalize(vec3((2.*F.xy-n.xy)/n.y*S(2.,s+3.14), 1.)); \n    float d, l=1.;\n    int i = 0;\n    while (i++ < 200 && d<150. && l>0.001) {\n        a = d*t; a.z+=0.21297;\n        d += l = length(mod(a+2.,4.)-2.) - 0.0003008*step(1.,abs(a.x));\n        x[i] = l;\n        y1[i] = a.x;\n        y2[i] = a.y;\n        y3[i] = a.z;\n    }\n    \n    float offset = 10.*abs(sin(iTime*0.61816));\n  \n    O.rgb = vec3(0.5)*(x[3+int(offset)]-x[2+int(offset)]);\n    //Each interation the brightest regions turn black because of the mod function\n    O.rgb = vec3(y1[3+int(offset)]-y1[2+int(offset)],\n                 y2[3+int(offset)]-y2[2+int(offset)],\n                 y3[3+int(offset)]-y3[2+int(offset)])*0.40827;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlj3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dtj3Rz", "name": "Triangle Fractal [240 Chars]", "author": "Xor", "description": "[url=https://twitter.com/XorDev/status/1610001267945783296]Original tweet[/url]", "tags": ["fractal", "triangle", "golf", "sub300"], "likes": 27, "viewed": 421, "published": 3, "date": "1672765800", "time_retrieved": "2024-07-30T18:18:05.706732", "image_code": "/*\n    \"Triangle Fractal\" by @XorDev\n    \n    Tweet: twitter.com/XorDev/status/1610001267945783296\n    Twigl: t.co/a3yLasdMKl\n    \n    \n    <300 chars playlist: shadertoy.com/playlist/fXlGDN\n\n*/\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Clear frag color\n    O *= 0.;\n    //Initialize iterator and time variables\n    float i=0.,f,s=modf(iTime,f);\n    //Initialize resolution for scaling\n    for(vec2 r=iResolution.xy, c;\n    //Loop 8 times\n    i++<8.;\n    //Skew noise texture\n    O+=texture(iChannel0,(ceil(c=(I+I-r)/r.y*mat2(1.155, 0, .577, 1)*exp2(i-s))\n    //Offset cells for triangle pattern\n    +ceil(c.x-c.y)+f+i)/1e3).r*\n    //Compute octave weight\n    max(3.5-abs(i-s-3.5),0.));\n    //Adjust brightness\n    O=O*.1-.1;\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtj3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 195, 232, 255, 729]], "test": "untested"}
{"id": "mtB3zz", "name": "symbol1111", "author": "chenxianming", "description": "symbol1111", "tags": ["raymarching", "sdf", "symbol", "cineshader"], "likes": 5, "viewed": 2055, "published": 3, "date": "1672760276", "time_retrieved": "2024-07-30T18:18:06.467698", "image_code": "#define PI 3.1415926\n#define count 1.\n#define smooth 0\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    p += ( hash12( p * 50. + fract( iTime ) ) ) * -.001;\n   \n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\nfloat myNoise( in vec2 f ){\n  f *= m;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rotation( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n        \n        t += a*myNoise(f*x * rotation( float(i) ));\n\n    }\n    return t;\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 _t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * _t.x) * _t.x;\n\t\tvec3 r2 = d + (c + b * _t.y) * _t.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? _t.y : _t.x;\n        t = dot(r2,r2) < dot(r1,r1) ? _t.y : _t.x; // quicker\n        \n    }\n    \n    vec3 _tan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, _tan));\n    vec3 _normal = cross(_tan, binormal);\n\n\tvec3 t1 = cross(_normal, _tan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(_tan, t1), _tan);\n    pos.xyz = mix(mix(A, B, t), mix(B, C, t), t) - pos; // spline position\n    return vec4(pos.xyz*mm, t);\n}\n\nfloat calcSymbol( vec3 pos, bool isBg ){\n\n    vec3 p = pos;\n    \n    if( isBg ){\n        p.xy *= .5;\n        p.y -= .15;\n        p.z -= .1;\n        \n    }else{\n        p.xz *= rotation( iTime * .5 );\n    }\n\n    p += (fbm4_2(p.yz - iTime * ( isBg ? .1 : .2 ) ).y * ( isBg ? 2.5 : -2.5 ) * fbm4_2(p.xz- iTime * ( isBg ? .5 : 1. ) * .5).x * 2. * cos(p).y * 1.) * .6;\n    \n    vec3 v = vec3( 0. );\n    vec3 pOri = p;\n    \n    v = vec3( 0., 0., -5. );\n    \n    float d = length( pos + v ) - .1;\n    \n    vec3 a = vec3( -1., 0., 0. );\n    vec3 b = vec3( 0., 1.1, 0. );\n    vec3 c = vec3( 1.01, 0., 0. );\n\n    vec4 bz = sdBezierExtrude(p, a, b, c);\n\n    float g = sdBox(bz.xyz, vec3( .1, .1, .1 ) );\n\n    d = min( d, g );\n    \n    a = vec3( -1.4, -0.6, 0. );\n    b = vec3( .1, -1.45, 0. );\n    c = vec3( 1.04, -0.25, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n    \n    p.xy *= rotation( PI * .25 );\n    \n    v = vec3( 0. );\n    v.x -= .71;\n    v.y += .91;\n    \n    p += v;\n    d = min( d, sdBox( p, vec3( .1 ) ) );\n    p = pOri;\n    \n    a = vec3( -1., 0., 0. );\n    b = vec3( 0., -.8, 0. );\n    c = vec3( .5, -0.25, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n    \n    a = vec3( -.3, 0.1, 0. );\n    b = vec3( 0.3, .25, 0. );\n    c = vec3( .55, -0.15, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n\n    v = vec3( 0. );\n    \n    p.xy *= rotation( PI * .25 );\n    \n    v.x -= .28;\n    v.y += .52;\n    \n    p += v;\n    d = min( d, sdBox( p, vec3( .1 ) ) );\n\n    if( isBg ){\n        d = pow( d, .9 );\n    }\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    float d = calcSymbol( pos, false );\n\n    float bg = calcSymbol( pos, true );\n    \n    d = min( d, bg * 1.6 );\n    \n    #if smooth==0\n    \n    vec3 p = pos;\n    \n    p = mod(p+0.4 * vec3(1.),vec3( 1.4, 1.4, .5 ))-0.4*vec3( 1. );\n    \n    float bg2 = calcSymbol( p, true );\n\n    d = min( d, bg2 * 2.1 );\n    \n    #endif\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    float tt = iTime * .2;\n\n    uv = (uv - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 origin = vec3(cos(tt) * -3.2, 0.0, sin(tt) * -3.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -3.2);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 18; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n    \n    vec2 uv2 = ( fragCoord.xy / iResolution.xy - .5 ) * .01;\n    \n    vec3 col = vec3( fbm( vec2( fbm( uv2 - .5 - sin( atan( uv2.x, uv2.y ) + iTime * .1 ), 1. ) ), .1 ) * .00015 );\n    vec3 lig = normalize(vec3( cos( iTime ), .7, .9 ));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n        float p = fbm( vec2( fbm( nor.xy * .15 - iTime * .01, 1. ) ), 1.9 );\n        \n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        col = spe + vec3( p * .3 + .5 ) * amb + vec3(.5) * dif + vec3(.3);\n    }\n\n    \n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n    \n    #if smooth == 1\n    \n    float px = hash12( uv * 50. + fract( iTime ) ) * .2;\n    tot = mix( tot, vec3( .1 ), px );\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtB3zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 122, 122, 188], [190, 190, 213, 213, 298], [300, 300, 322, 322, 439], [442, 442, 467, 467, 501], [503, 503, 523, 523, 693], [695, 695, 716, 716, 826], [828, 828, 855, 855, 935], [938, 938, 974, 974, 1263], [1265, 1271, 1302, 1302, 1389], [1391, 1391, 1447, 1624, 3101], [3103, 3103, 3143, 3143, 4806], [4808, 4808, 4829, 4829, 5173], [5175, 5221, 5252, 5252, 5500], [5502, 5502, 5557, 5607, 7419]], "test": "untested"}
{"id": "dlS3Rz", "name": "Dynamic", "author": "deni_de", "description": "Ra in bow", "tags": ["for"], "likes": 3, "viewed": 220, "published": 3, "date": "1672759597", "time_retrieved": "2024-07-30T18:18:07.215698", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy,u=U/r.xy;float t=iTime;O = vec4(0);\n    for(float i = -4.; i < 5.0;  i++ )\n        for(float i2 = -4.0,a; i2 < 5.0; a = i+i2, O.rgb += (.5 + .5 * cos(t+u.xyx * a+vec3(0,2,4))) \n            * ( 1.0 - smoothstep(\n                                     0.01 * abs(sin(t * 15.5 + a)), \n                                     0.06 + 0.09 * abs(sin(t + a) * 0.5 ),\n                                     length(\n                                               U/vec2(r.x/2.,r.y) - vec2(\n                                                                           1.0 + i * .09 + sin(t * 1.5 + i * .5 + u.y) * .05,\n                                                                            .5 - i2++ * .09 + cos(t * 1.5 + i2 * .5 + u.x) * .05\n                                                                        )\n                                           )\n                                )\n              )\n           )\n           {}  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlS3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 998]], "test": "untested"}
{"id": "mlB3Rz", "name": "大龙猫 - Accidental Voronoi", "author": "totetmatt", "description": "Ivre, il fait un voronoi par accident, ça tourne mal, explication.", "tags": ["voronoi"], "likes": 6, "viewed": 212, "published": 3, "date": "1672742795", "time_retrieved": "2024-07-30T18:18:07.965693", "image_code": "vec3 pal(float t) {return .7+.3*cos(6.28*(vec3(.7,.2,.7)*t+vec3(.0,.3,.7)));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=4.;\n    vec4 d = vec4(100.,0,0,0);\n    float t=iTime;\n    for(float i=0.,im=50.;i++<im;){\n        vec4 p;\n        float t = t*(.1+(i/im));\n        vec2 uv = uv+vec2(sin(i*5.+t),cos(i*7.+t*.33))*2.;\n        p.x = length(pow(uv,vec2(4.)))-.00000001;\n        p.x = pow(p.x,1./(4.-fract(iTime+i*i/im)*3.));\n        p.yzw = pal(i/im);\n        d = p.x < d.x  ? p:d;\n        \n    }\n    //d.x = .05/(abs(d.x)-.001);\n    d.x = smoothstep(fwidth(d.x),0.,abs(d.x+dot(sin(uv*100.),cos(uv.yx*400.))*.2)-.8);\n    vec3 col =d.x*d.yzw;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlB3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 77], [78, 78, 133, 133, 764]], "test": "untested"}
{"id": "mlBGzR", "name": "[Genuary2] Day 2: Made in 10mins", "author": "oneshade", "description": "Prompt: \"Made in 10 minutes.\"\nAs far as I got on making a snow shader in 10 minutes.", "tags": ["day2", "geunary2", "madein10", "notsnow"], "likes": 3, "viewed": 197, "published": 3, "date": "1672733128", "time_retrieved": "2024-07-30T18:18:08.858306", "image_code": "float map(in vec3 p) {\n    p = mod(p + 0.5, 1.0) - 0.5;\n    return length(p) - 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec3 ro = vec3((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y, 5.0);\n\n    vec3 fd = -normalize(ro);\n    vec3 rt = normalize(vec3(-fd.z, 0.0, fd.x));\n    vec3 up = cross(rt, fd);\n\n    vec3 rd = normalize(uv.x * rt + uv.y * up + fd);\n    bool inside = map(ro) < 0.0;\n    float total = 0.0;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        if (inside) {\n            total += 0.05;\n            t += 0.05;\n            if (map(ro + rd * t) >= 0.0) inside = false;\n        }\n\n        else {\n            t += map(ro + rd * t);\n            if (map(ro + rd * t) < 0.0) inside = true;\n        }\n\n        if (total > 1.0) break;\n    }\n\n    color += total;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 86], [88, 88, 143, 143, 938]], "test": "untested"}
{"id": "DtB3zz", "name": "Beachgoers", "author": "Zanzlanz", "description": "Just playing around! Each pixel determines its probable color by comparing its surroundings to a reference bitmap (Buffer A). See options in the common script.", "tags": ["ca", "cellularautomata", "annealing"], "likes": 10, "viewed": 277, "published": 3, "date": "1672726547", "time_retrieved": "2024-07-30T18:18:09.798791", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // This is just to flip and rescale the image.\n    fragColor = vec4(texture(iChannel0, (1.0-fragCoord/iResolution.xy)/ZOOM).xyz, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Color index per pixel\nint f[240] = int[240](\n    0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,1,1,1,1,0,0,0,0,0,0,\n    0,1,2,1,2,1,1,0,0,0,0,0,\n    0,1,1,1,1,1,1,0,0,0,0,0,\n    0,1,1,2,2,1,1,0,0,0,0,0,\n    0,0,1,1,1,1,0,0,0,0,0,0,\n    0,0,0,1,1,0,0,0,0,0,0,0,\n    0,0,0,1,1,0,0,0,1,1,1,0,\n    0,0,1,1,1,0,0,1,2,1,2,1,\n    0,0,1,1,1,0,0,1,1,1,1,1,\n    0,0,1,1,1,0,0,1,1,2,2,1,\n    0,0,1,1,1,1,0,0,1,1,1,1,\n    0,0,0,1,1,1,0,0,0,1,1,0,\n    3,3,3,3,3,3,3,3,3,3,3,3,\n    0,0,0,0,3,3,3,0,0,3,3,3,\n    3,3,3,3,3,3,3,3,3,0,0,0,\n    0,3,0,0,0,3,3,3,0,0,3,3,\n    3,3,3,3,3,3,3,3,3,0,0,0,\n    3,0,0,0,3,0,0,0,0,3,3,3\n);\n\n// Index to color\nvec3 c[4] = vec3[4](\n    vec3(1.0, 1.0, 1.0),\n    vec3(.63, .21, .34),\n    vec3(.17, 0.0, 0.0),\n    vec3(.47, .69, .83)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Stretch the image across the whole buffer. I guess I could make it 1:1 pixel, but this is convenient for wrapping\n    int index = int(fragCoord.x/iResolution.x*INPUT_WIDTH)\n              + int(fragCoord.y/iResolution.y*INPUT_HEIGHT)*int(INPUT_WIDTH);\n    fragColor = vec4(c[f[index]], 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "/*\n * License:\n * Use freely!\n * \n * But I'd appreciate keeping a comment attributing @Zanzlanz or the ShaderToy link:\n * https://www.shadertoy.com/view/DtB3zz\n */\n\n\n// Any ol' noise function\nvec2 noise(vec2 v) {\n    v = fract(v) + fract(v*1e4) + fract(v*1e-4);\n    v += vec2(0.12345, 0.6789);\n    v = fract(v*dot(v, v)*123.456);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Clips the output to the zoom level\n    if(fragCoord.x > iResolution.x/ZOOM || fragCoord.y > iResolution.y/ZOOM) discard;\n    \n    // Adds noise at the start and in the wave pattern to create chaos\n    if(iTime < .5 || abs(fragCoord.y + sin(iTime*.3+fragCoord.x*ZOOM/200.0)*iResolution.y/ZOOM*.4 - iResolution.y/ZOOM/2.0) < WAVE * 6.0) {\n        fragColor = vec4(texture(iChannel0, noise(fragCoord.xy/iResolution.xy).rg).rgb, 1.0);\n        return;\n    }\n    \n    // Calculate the most likely color based on the surroundings\n    int bestScore = 0;\n    vec2 bestScoreColor = vec2(0.0);\n    for(int inputX = 0; inputX < int(INPUT_WIDTH); inputX++) {\n        for(int inputY = 0; inputY < int(INPUT_HEIGHT); inputY++) {\n            int score = 0;\n            for(int kernelX = -KERNEL_SIZE; kernelX <= KERNEL_SIZE; kernelX++) {\n                for(int kernelY = -KERNEL_SIZE; kernelY <= KERNEL_SIZE; kernelY++) {\n                    if(kernelX == 0 && kernelY == 0) continue;\n                    if(\n                        texture(iChannel0, vec2((float(inputX+kernelX)+.5)/INPUT_WIDTH, (float(inputY+kernelY)+.5)/INPUT_HEIGHT))\n                        == texture(iChannel1, (fragCoord + vec2(float(kernelX), float(kernelY))) / iResolution.xy) ) {\n                        // I considered using a normal/gaussian distribution, but the results weren't worth it tbh\n                        score++;\n                    }\n                }\n            }\n            if(score > bestScore) {\n                bestScore = score;\n                bestScoreColor = vec2((float(inputX)+.5)/INPUT_WIDTH, (float(inputY)+.5)/INPUT_HEIGHT);\n            }\n        }\n    }\n    fragColor = texture(iChannel0, bestScoreColor);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// If you create a new picture in Buffer A, be sure to update these\n#define INPUT_WIDTH 12.0\n#define INPUT_HEIGHT 20.0\n\n// Zooms in to help with readability and speed\n#define ZOOM 4.0\n// This determines how many neighbors each pixel checks when annealing\n#define KERNEL_SIZE 4\n\n// You can turn off the wave by setting it to 0\n#define WAVE 1.0", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtB3zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 198]], "test": "untested"}
{"id": "mts3Dl", "name": "Celtic Knotwork Curtains WFC", "author": "fenix", "description": "Knots+Cloth!\n\nCredits:\nknarkowics's Cloth Shading: https://shadertoy.com/view/4tfBzn\nwnu's sparkle commented: https://shadertoy.com/view/Ndlczs\n\n*mouse, up/down: cam*\n*left/right: draw*\n*space: reset WFC buffer*\n*shift-space: reset cloth and attract mode*", "tags": ["dynamics", "physics", "glitter", "quadtree", "cloth", "sheen", "curtain", "velvet"], "likes": 19, "viewed": 357, "published": 3, "date": "1672725230", "time_retrieved": "2024-07-30T18:18:10.911816", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I thought it might be cool to use the Celtic Knotwork WFC design on these curtains. I\n//  guess this is another entry in both my cloth shader series and my WFC series. My\n//  previous cloth shaders:\n//\n//      Tearable 3D Fishnet             https://shadertoy.com/view/NlKBW3\n//      Cloth Draping + Shadows         https://shadertoy.com/view/cdjGRR\n//      Textured Cloth                  https://shadertoy.com/view/Ddj3Wh\n//      Quadtree Tapestry               https://shadertoy.com/view/mlXGzN\n//      Drawable Curtains               https://shadertoy.com/view/clXGRX\n//\n//  And, my previous WFC (Wave Function Collapse) shaders:\n//\n//      Simple Wave Function Collapse   https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC               https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC           https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                   https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC    https://shadertoy.com/view/mdjSDz\n//      Superposition Weave WFC         https://shadertoy.com/view/Ds2XRV\n//      Celtic Knotwork WFC             https://shadertoy.com/view/mtfGWX\n//\n//  Most of the shader (except buffer D and the renderCurtain function) is the same as\n//  Drawable Curtains, so I need to give credit again to two other shaders that I borrowed\n//  code from, for the \"Charlie Sheen\" velvet cloth and glitter respectively:\n//\n//      knarkowics's Cloth Shading      https://shadertoy.com/view/4tfBzn\n//      wnu's sparkle commented         https://shadertoy.com/view/Ndlczs  \n//\n//  The idea of Wave Function Collapse for generating random but ordered tilings comes from:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  DISCLAIMER: as with my previous WFC shaders, this is not a proper implementation of\n//  the original WFC algorithm, but something meant to approximate it.\n//\n//  The sky and moon are borrowed from my own\n//\n//    Arctic Fireflies                  https://shadertoy.com/view/cssSRs\n//\n//  Phew, that was a lot of links! There's not a lot more to say about this shader, that I\n//  didn't say before in the shaders it's built from. The border is hard-coded and the WFC\n//  algorithm runs on the interior of each curtain. Press the space bar to reset the WFC\n//  buffer. Shift-space resets the cloth buffer and restarts attract mode.\n//\n// CHANGELOG:\n// 1/4/23: Reversed order of cloth and scene render - saves time not to compute shadows\n//         for scene pixels covered by cloth anyway\n// ---------------------------------------------------------------------------------------\n\n#define SHADOW_FROM_CLOTH 1\n\nconst float FAR_CLIP = 30.;\n\n#define CLOTH_POS_UNCLAMPED(X) texture(iChannel0, ((X)+.5)/iResolution.xy).xyz\n#define CLOTH_POS_CLAMPED(X) texture(iChannel0, (clamp(X, vec2(0), vec2(CLOTH_SIDE_LEN)+.5)/iResolution.xy)).xyz\n\nvec4 getClothNormalGrad(vec2 uv)\n{\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS_CLAMPED(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS_CLAMPED(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS_CLAMPED(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS_CLAMPED(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    vec3 normal = normalize(cross(deltaX, deltaY) );\n    vec3 clothPos = CLOTH_POS_CLAMPED(uv);\n    float grad = dot(normal, clothPosX0 - clothPos) +\n                 dot(normal, clothPosX1 - clothPos) +\n                 dot(normal, clothPosY0 - clothPos) +\n                 dot(normal, clothPosY1 - clothPos);\n\n    return vec4(normal, grad);\n}\n\n// enable to see visualization of quadtree query counts per pixel\n#define DEBUG_NUM_PROC 0\n\n#if DEBUG_NUM_PROC\n#define DEBUG_NUM_PROC_ONLY(X) X\n#else\n#define DEBUG_NUM_PROC_ONLY(X)\n#endif\n\nDEBUG_NUM_PROC_ONLY(int numProc = 0;)\n\n// originally from archee's curtain and ball: https://www.shadertoy.com/view/MldXWX\n//\n// with optimizations:\n//    * only one texel fetch per loop\n//    * compute d2 only once\n//    * removed square roots (length)\n// \n// also, updated variable names and types, added comments\nvec3 quadtreeRender(vec3 cameraPos, vec3 rayDir, float minSize, bool side)\n{\n    vec3 uvz = vec3(0, 0, FAR_CLIP);\n\n    const float STRETCH_RATIO = 3.;\n    const float voxelK2 = (STRETCH_RATIO / CLOTH_SIDE_LEN_F) * (STRETCH_RATIO / CLOTH_SIDE_LEN_F);\n    float voxelsize2 = (minSize * minSize * voxelK2);\n    \n    vec2 corner = vec2(0); // corner of current quad being considered\n    float size = CLOTH_SIDE_LEN_F / 2.; // size of quad being considered\n    float end = size;\n    if (side)\n    {\n        corner = vec2(size, 0);\n        end = CLOTH_SIDE_LEN_F;\n    }\n    bool levelup = false;\n    \n    for (int i = 0; i < 5000; ++i) // less than 200 iterations for most pixels\n    {\n        DEBUG_NUM_PROC_ONLY(++numProc;)\n\n        vec3 boundingcenter = CLOTH_POS_UNCLAMPED(corner + size * .5);\n        float d2 = length2(cross(boundingcenter - cameraPos, rayDir));\n\n        if (size <= minSize)\n        {\n        \tif (d2 <= voxelsize2 &&\n                floor(corner.x + 1.) != CLOTH_SIDE_LEN_F / 2.) // missing between left and right sides\n        \t{\n                // found small enough quadrant to render it\n                float dept = dot(rayDir, boundingcenter - cameraPos);\n                uvz = dept < uvz.z ? vec3(corner + .5 * size, dept) : uvz;\n\t        }\n          \n            levelup = true; // don't bother to descend, we've already rendered\n        }\n\n        if (d2 > size * size * voxelK2 * .5)\n        {\n            levelup = true; // not near this quadrant, don't descend into here\n        }\n        \n        if (levelup)\n        {\n            levelup = false;\n            \n            if (fract(corner.y / size / 2.) < .25)\n            {\n                corner.y += size; // we're on the top...go to the bottom\n            }\n            else\n            {\n                corner.y -= size; // we're on the bottom...go back to the top\n\n                if (fract(corner.x / size / 2.) < .25)\n                {\n                    corner.x += size; // go from right to left\n                }\n                else\n                {\n                    corner.x -= size; // done with this quad, go up a level\n                    size *= 2.0;\n                    levelup = true;\n                }\n            }\n        }\n        else\n        {\n            if (size > minSize) size /= 2.;\n        }\n        \n        if (corner.x >= end) break;    \n    }\n    \n    return uvz;\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxGetParticlePos(int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(iChannel0, addr, 0).xyz;\n}\n\n#define MAX_STEPS 100\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, true);\n        d += dS;\n        if(d > FAR_CLIP || abs(dS) < SURF_DIST) break;\n    }\n    \n    return min(FAR_CLIP, d);\n}\n\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, 0.75, 1));\n\nbool shadowScene(vec3 p, vec3 lightDir)\n{\n    return rayMarch(p, lightDir) < FAR_CLIP;\n}\n\n#if SHADOW_FROM_CLOTH\nbool shadowCloth(vec3 p, vec3 lightDir)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    \n    cameraPos = p;\n    cameraLookAt = p + lightDir;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = cameraFwd;\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./4., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./4., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n\n    return uvz.z > 0. && uvz.z < FAR_CLIP;\n}\n#endif // SHADOW_FROM_CLOTH\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) * .05) + float(!shadow) * max(0., dot(n, pointLightDir)) * .9;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(1);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.z + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 2.3\n    #define PRIMARY_CONCENTRATION 6.\n    #define SECONDARY_INTENSITY 10.\n    #define SECONDARY_CONCENTRATION 0.9\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 400.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 ligt = vec3(1.);\n    vec3 h = normalize(ligt-camDir);\n    float nl = dot(n,ligt);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*3.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2);\n\n    return col*col;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// From Cloth Shading by knarkowics: https://www.shadertoy.com/view/4tfBzn\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat CharlieD(float roughness, float ndoth)\n{\n    float rcpR  = 1. / roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    return (2. + rcpR) * pow(sin2h, rcpR * .5) / (2. * PI);\n}\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n\nfloat CharlieV(float roughness, float ndotv, float ndotl)\n{\n\tfloat visV = ndotv < .5 ? exp(L(ndotv, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotv, roughness));\n\tfloat visL = ndotl < .5 ? exp(L(ndotl, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotl, roughness));\n\n\treturn 1. / ((1. + visV + visL) * (4. * ndotv * ndotl));\n}\n\nconst vec3 MOON_DIR = normalize(vec3(1, .5, -1));\nconst vec3 MOON_COLOR = vec3(.1, .15, .3);\n\nvec3 velvet(vec4 normalGrad, vec3 rayDir, vec3 hit, vec3 baseColor)\n{\n    if (dot(normalGrad.xyz, rayDir) > 0.) normalGrad.xyz = -normalGrad.xyz;\n\n    vec3 viewDir = -rayDir;\n    vec3 lightDir = MOON_DIR;\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth = saturate(dot(viewDir, halfVec));\n    float ndoth\t= saturate(dot(normalGrad.xyz, halfVec));\n    float ndotv = saturate(dot(normalGrad.xyz, viewDir));\n    float ndotl = saturate(abs(dot(normalGrad.xyz, lightDir)));\n\n    vec3 diffuseColor  = 0.25 * baseColor;\n    vec3 specularColor = sqrt(baseColor);\n    float roughness    = 0.5;\n\n    vec3 diffusePoint = diffuseColor * saturate(dot(normalGrad.xyz, lightDir));\n    vec3 diffuseFill = diffuseColor * saturate(dot(normalGrad.xyz, FILL_LIGHT_DIR));\n\n    vec3 f = FresnelTerm(specularColor, vdoth);\n\n    float d = CharlieD(roughness, ndoth);\n    float v = CharlieV(roughness, ndotv, ndotl);\n\n    vec3 specular = f * (d * v * PI * ndotl);\n\n    vec3 color = diffusePoint + diffuseFill + specular;\n    return color;\n}\n\n// From jarble's Glacial valleys: https://www.shadertoy.com/view/NscGWl\n// (used for moon)\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.2;\n    float freq = 0.5,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        n2 = sin(uv.x*freq)+cos(uv.y*freq);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n2-value) * amplitude);\n        amplitude *= .37;\n        freq *= 2.05;\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nvec3 sky(vec3 rayDir)\n{\n    vec3 stars = vec3(smoothstep(.5, .8, pow(float(hash(uvec4(rayDir * iResolution.y + 4000., 1)).r) / 4.35e9, 50.))) * 4.;\n    float d = distance(rayDir, MOON_DIR);\n    if (d > .03 + + 2./iResolution.y) return stars;\n    vec3 moon = MOON_COLOR * (1. + fbm(rayDir.xxy * 100., 3));\n    return mix(moon, stars, smoothstep(.03, .03 + 2./iResolution.y, d));\n}\n\nvec4 hash4(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return vec4(x) * (1./float(0xffffffffU));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// cell distance functions\nfloat sdIStSt(vec2 p)\n{\n    return min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.5)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.5)));\n\n    return dist;\n}\n\nfloat sdEndCorner(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdEndFoot(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 1), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.5), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6.5, 6), vec2(1.5, 1)));\n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(4, 2), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    \n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat spCell(vec2 p, int type)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)           dist = sdIStSt(p);\n    else if (type == I_ST_CR)      dist = sdIStCr(p);\n    else if (type == I_CR_CR)      dist = sdICrCr(p);\n    else if (type == END_CR)       dist = sdEndCorner(p);\n    else if (type == END_FOOT)     dist = sdEndFoot(p);\n    else if (type == CORNER_ST_ST) dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST) dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR) dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR) dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)   dist = sdTStCrSt(p);\n\n    return smoothstep(0., 80./iResolution.y, dist);\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nfloat renderCelticKnots( vec2 u )\n{\n    u *= vec2(100., 50);\n    vec2 p = fract(u) * 8.;\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel2, ivec2(u), 0));\n    if (valid == uvec4(0)) return 1.;\n    \n    float c = 0.;\n    float n = 0.;\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += spCell(rot90(p,rot), type);\n                ++n;\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / n;\n}\n\nvec4 renderCurtain(vec2 fragCoord)\n{\n    vec4 fragColor = vec4(.1, .0, .9, 0);\n    fragColor = mix(vec4(1,1,1,1), fragColor, renderCelticKnots(fragCoord));\n    return fragColor;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEBUG_NUM_PROC_ONLY(numProc = 0);\n    vec2 u = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxState state = fxGetState(iFrame);\n    \n    cameraPos = -state.orbit * vec3(sin(state.camera.x) * sin(state.camera.y), cos(state.camera.y), cos(state.camera.x) * sin(state.camera.y));\n    cameraLookAt = vec3(0, .3, 0);\n    cameraPos += cameraLookAt;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // render cloth\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./16., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./16., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n    if (uvz.z < FAR_CLIP)\n    {\n        vec4 normalGrad = getClothNormalGrad(uvz.xy);\n        vec3 normal = normalGrad.xyz;\n        vec3 hit = cameraPos + rayDir * uvz.z;\n        float ao = .0 + 1. * smoothstep(-.03, .01, normalGrad.w);\n\n        vec3 lightColor = MOON_COLOR * ao;\n\n#if 0 // enable shadows on cloth\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        //s = s || shadowCloth(offsetPos, MOON_DIR); // self-shadowing adds a lot of cost, not a lot of effect\n#endif\n        if (s) lightColor *= .25;\n#endif\n        if (dot(normal, rayDir) < 0.) lightColor *= .01;\n        \n        vec4 colorGlitter = renderCurtain(uvz.xy / CLOTH_SIDE_LEN_F);\n        //colorGlitter.a = 1.; // gold sparkly curtains\n        vec3 color = velvet(normalGrad, rayDir, hit, colorGlitter.rgb) * lightColor;\n        if (colorGlitter.a > 0.)\n        {\n            color = mix(color, glitter(hit, normal, -rayDir) * ao, colorGlitter.a);\n        }\n        fragColor = vec4(color, 1);\n    }\n    else\n        fragColor.xyz = sky(rayDir);\n\n    // render scene\n    float d = rayMarch(cameraPos, rayDir);\n    if (d < uvz.z)\n    {\n        vec3 hit = cameraPos + rayDir * d;\n        vec3 normal = getSceneNormal(hit, true);\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        bool s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        s = s || shadowCloth(offsetPos, MOON_DIR);\n#endif\n        fragColor.xyz = light(normal, MOON_DIR, s) * MOON_COLOR;\n    }\n\n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n\n    DEBUG_NUM_PROC_ONLY(fragColor = sin(float(numProc) * vec4(1, 11, 13, 0)) * sqrt(vec4(numProc)) / 10.);\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0) * 1e6;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CLOTH_SIDE_LEN = 128;\nconst float CLOTH_SIDE_LEN_F = float(CLOTH_SIDE_LEN);\nconst float PI = 3.141592653589793;\n\nconst uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_FOOT = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\nconst int NUM_TILES = 11;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(uvec4 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(p);\n    return vec4(h)*scale;\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p, bool rod)\n{\n    float d = 1e6;\n    \n    d = min(d, sdBox(p - vec3(-.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,1.,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.8,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.65,.1), vec3(.9,.05,.2))); // sill\n    d = min(d, sdBox(p + vec3(0,3.5,0), vec3(10.,1.,10.))); // floor\n    if (rod)\n    {\n        d = min(d, sdCapsule(p, vec3(-.85, .95, -.02), vec3(.85, .95, -.01)) - .01); // rod\n        d = min(d, sdSphere(p - vec3(-.85, .95, -.02), .03)); // right side ball\n        d = min(d, sdSphere(p - vec3( .85, .95, -.02), .03)); // left side ball\n    }\n    \n    return d;\n}\n\n// // https://iquilezles.org/articles/normalsSDF\nvec3 getSceneNormal(vec3 p, bool rod)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, false ) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, false ) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, false ) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, false ) );\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyDownImpl(sampler, ascii)    ( texelFetch(sampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float draw;\n    float attractCurtain;\n    float attractCamera;\n    float orbit;\n    vec2 camera;\n    vec2 lastMouse;\n};\n\nvoid initState(inout fxState state)\n{\n    state.draw = .75;\n    state.attractCurtain = 15.;\n    state.attractCamera = 1.;\n    state.orbit = 2.;\n    state.camera = vec2(sin(.0004), cos(.0002) * .25 + PI*.5);\n    state.lastMouse = vec2(0);\n}\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, CLOTH_SIDE_LEN * 2), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, CLOTH_SIDE_LEN * 2), 0);\n    \n    fxState state;\n    state.draw = data0.x;\n    state.attractCurtain = data0.y;\n    state.attractCamera = data0.z;\n    state.orbit = data0.w;\n    state.camera = data1.xy;\n    state.lastMouse = data1.zw;\n    if (iFrame == 0) initState(state);\n    return state;\n}\n\n#define fxGetState(iFrame) fxGetStateImpl(iChannel0, iFrame)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2))\n        return vec4(state.draw, state.attractCurtain, state.attractCamera, state.orbit);\n    else\n        return vec4(state.camera, state.lastMouse);\n}\n\nvec4 updateState(fxState state, sampler2D keySampler, ivec2 ifc, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE) && keyDownImpl(keySampler, KEY_SHIFT))\n    {\n        initState(state);\n    }\n    else\n    {\n        if (keyDownImpl(keySampler, KEY_LEFT))\n        {\n            state.draw += .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_RIGHT))\n        {\n            state.draw -= .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_UP))\n        {\n            state.orbit -= .0025;\n            state.attractCamera = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_DOWN))\n        {\n            state.orbit += .0025;\n            state.attractCamera = 0.;\n        }\n        if (state.attractCurtain != 0.)\n        {\n            state.attractCurtain = mod(state.attractCurtain, 30.) + .005;\n            state.draw = smoothstep(5., 15., state.attractCurtain) * smoothstep(30., 20., state.attractCurtain) * .5 + .3;\n        }\n        state.draw = clamp(state.draw, .3, .8);\n\n        if (iMouse.z > 0.)\n        {\n            state.attractCamera = 0.;\n            \n            if (iMouse.w < 0.)\n            {\n                state.camera += 10. * ((iMouse.xy / iResolution.x) - state.lastMouse);\n                state.camera.y = clamp(state.camera.y, PI*.1, PI*.9);\n            }\n\n            state.lastMouse = iMouse.xy / iResolution.x;\n        }\n        \n        if (state.attractCamera > 0.)\n        {\n            state.attractCamera += 1.;\n            state.camera = vec2(sin(state.attractCamera * .0016), cos(state.attractCamera * .0008) * .25 + PI*.5);\n            state.orbit = 1.5 + cos(state.attractCamera * .0012) * .5;\n        }\n    }\n    \n    return fxPutState(state, ifc);\n}\n\nvec3 fxGetParticlePos(sampler2D sampler, int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(sampler, addr, 0).xyz;\n}\n\nvoid horizConstraint(sampler2D sampler, ivec2 nb, int dist, inout vec3 pos)\n{\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    float idealDist = float(dist) * 2.7 / float(CLOTH_SIDE_LEN - 1);\n    float f = .4;\n    if (deltaLen > idealDist) f = .6;\n    pos = mix(nbPos + normalize(delta) * idealDist, pos, f);\n}\n\nvoid vertConstraint(sampler2D sampler, ivec2 nb, int dist, float f, inout vec3 pos)\n{\n    const float Y_STRETCH = 1.47;\n\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    if (deltaLen > Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1))\n    {\n        pos = mix(nbPos + normalize(delta) * Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1), pos, f);\n    }\n}\n\nvec3 initVert(ivec2 v, fxState state)\n{\n    vec2 vert = vec2(v);\n    vert.y = CLOTH_SIDE_LEN_F - (CLOTH_SIDE_LEN_F - vert.y)*.83;\n    vec3 pos = (vec3(((vert - float(CLOTH_SIDE_LEN - 1) * .5))*2./CLOTH_SIDE_LEN_F, -.01) + vec3(0, .05, 0)) * vec3(state.draw, .95, 1);\n    \n    // split down the middle\n    if (v.x < CLOTH_SIDE_LEN / 2) pos.x -= .8 - state.draw;\n    else pos.x += .8 - state.draw;\n    \n    // wavy top to set up the pleats\n    float s = sin(float(v.x) * 3.14 / 4.);\n    //if (abs(s) > 1e-6) s /= sqrt(abs(s));\n    pos.z -= (1. + s) * .03;\n    return pos;\n}\n\n#define CLOTH_POS(X) texture(sampler, clamp((X+.5)/res.xy, vec2(0), vec2(CLOTH_SIDE_LEN))).xyz\n\nvec3 getClothNormal(sampler2D sampler, vec3 res, ivec2 ifc)\n{\n    vec2 uv = vec2(ifc);\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    return normalize(cross(deltaX, deltaY));\n}\n\nvoid clothBufferMainImpl( out vec4 fragColor, vec2 fragCoord, sampler2D vertexSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    \n    fxState state = fxGetStateImpl(vertexSampler, iFrame);\n    \n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2) || ifc == ivec2(1, CLOTH_SIDE_LEN * 2))\n    {\n        fragColor = updateState(state, keySampler, ifc, iFrame, iMouse, iResolution, iTime);\n        return;\n    }\n    \n    if (any(greaterThan(ifc, CLOTH_SIDE_LEN * ivec2(2, 1))))\n    {\n        fragColor = vec4(0); // discard all unneeded pixels\n        return;\n    }\n    \n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE) && keyDownImpl(keySampler, KEY_SHIFT))\n    {\n        // init cloth positions\n        ifc.x = (ifc.x % CLOTH_SIDE_LEN);\n        fxState initState;\n        initState.draw = .8;\n        fragColor.xyz = initVert(ifc, initState);\n        fragColor.w = 1.;\n\n        return;\n    }\n    \n    if (ifc.x >= CLOTH_SIDE_LEN)\n    {\n        // store last position on right side\n        fragColor = texelFetch(vertexSampler, ifc - ivec2(CLOTH_SIDE_LEN, 0), 0);\n        return;\n    }\n    \n    vec3 pos = texelFetch(vertexSampler, ifc, 0).xyz;\n    if (ifc.y >= CLOTH_SIDE_LEN - 6)\n    {\n        pos = initVert(ifc, state); // top six rows are pinned\n    }\n    else\n    {\n        vec3 oldPos = texelFetch(vertexSampler, ifc + ivec2(CLOTH_SIDE_LEN, 0), 0).xyz;\n        \n        pos += (pos - oldPos) * .9; // integration\n        pos += vec3(0, -.1, 0); // gravity\n        \n        // wind\n        vec3 normal = getClothNormal(vertexSampler, iResolution, ifc);\n        pos.z += sin(pos.x*.3 + iTime*.2) * .03 * normal.z;\n\n        // vertical constraints\n        for (int i = 0; i < 5; ++i)\n        {\n            float Y_STRETCH = 1.47;\n            ivec2 nbU = ifc + ivec2(0, i);\n            if (nbU.y <= CLOTH_SIDE_LEN - 1) vertConstraint(vertexSampler, nbU, i, .5, pos);\n            ivec2 nbD = ifc - ivec2(0, i);\n            if (nbD.y >= 0) vertConstraint(vertexSampler, nbD, i, .99, pos);\n        }\n\n        // horizontal constraints\n        int endL = ifc.x < CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 - 1 : CLOTH_SIDE_LEN - 1;\n        int endR = ifc.x >= CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 : 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            ivec2 nbL = ifc + ivec2(i, 0);\n            ivec2 nbR = ifc - ivec2(i, 0);\n            if (nbL.x <= endL) horizConstraint(vertexSampler, nbL, i, pos);\n            if (nbR.x >= endR) horizConstraint(vertexSampler, nbR, i, pos);\n        }\n\n        // collision with scene\n        pos -= min(0., scene(pos, false) - .01) * getSceneNormal(pos, false);\n\n    }\n\n    fragColor = vec4(pos, 1);\n}\n\n#define clothBufferMain(fragColor, fragCoord) clothBufferMainImpl( fragColor, fragCoord, iChannel0, iChannel3, iFrame, iMouse, iResolution, iTime)\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_FOOT =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_FOOT)       return S_END_FOOT;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    /*if (type == T_ST_CR_ST)*/ return S_T_ST_CR_ST;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .1;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return .1;\n    if (type == END_CR)         return .1;\n    if (type == END_FOOT)       return .1;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    /*if (type == T_ST_CR_ST)*/ return .1;\n\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // fxState state = fxGetState(iFrame);\n    ivec2 ifc = ivec2(fragCoord);\n    \n    if (ifc.x == 4 && ifc.y == 2 || ifc.x == 54 && ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(1u << CORNER_ST_ST, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 5 && ifc.y == 3 || ifc.x == 55 && ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(1u << CORNER_CR_CR, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 4 && ifc.y == 45 || ifc.x == 54 && ifc.y == 45)\n    {\n        fragColor = ubtf(uvec4(0, 0, 0, 1u << CORNER_ST_ST));\n        return;\n    }\n    \n    if (ifc.x == 5 && ifc.y == 44 || ifc.x == 55 && ifc.y == 44)\n    {\n        fragColor = ubtf(uvec4(0, 0, 0, 1u << CORNER_CR_CR));\n        return;\n    }\n    \n    if (ifc.x == 45 && ifc.y == 2 || ifc.x == 95 && ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(0, 1u << CORNER_ST_ST, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 44 && ifc.y == 3 || ifc.x == 94 && ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(0, 1u << CORNER_CR_CR, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 45 && ifc.y == 45 || ifc.x == 95 && ifc.y == 45)\n    {\n        fragColor = ubtf(uvec4(0, 0, 1u << CORNER_ST_ST, 0));\n        return;\n    }\n    \n    if (ifc.x == 44 && ifc.y == 44 || ifc.x == 94 && ifc.y == 44)\n    {\n        fragColor = ubtf(uvec4(0, 0, 1u << CORNER_CR_CR, 0));\n        return;\n    }\n    \n    if (ifc.y > 45 || ifc.y < 2 || ifc.x < 4 || ifc.x > 95 || ifc.x > 45 && ifc.x < 54)\n    {\n        fragColor = ubtf(uvec4(1, 0, 0, 0));\n        return;\n    }\n    \n    if (ifc.y == 45 || ifc.y == 2)\n    {\n        fragColor = ubtf(uvec4(0, 2, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 95 || ifc.x == 4 || ifc.x == 45 || ifc.x == 54)\n    {\n        fragColor = ubtf(uvec4(2, 0, 0, 0));\n        return;\n    }\n\n    if (ifc.y == 44 || ifc.y == 3)\n    {\n        fragColor = ubtf(uvec4(0, 8, 0, 0));\n        return;\n    }\n    \n    if (ifc.x == 94 || ifc.x == 5 || ifc.x == 44 || ifc.x == 55)\n    {\n        fragColor = ubtf(uvec4(8, 0, 0, 0));\n        return;\n    }\n\n\n    if (ifc.y >= 43 || ifc.y == 4 || ifc.x == 6 || ifc.x >= 93 || ifc.x == 43 || ifc.x == 56)\n    {\n        fragColor = ubtf(uvec4(1, 0, 0, 0));\n        return;\n    }\n    \n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-5)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Dl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3070, 3070, 3104, 3104, 3788], [6686, 6686, 6806, 6806, 6986], [6988, 6988, 7101, 7101, 7257], [7259, 7259, 7362, 7362, 7495], [7497, 7497, 7528, 7528, 7643], [7691, 7691, 7725, 7725, 7966], [8027, 8027, 8068, 8068, 8115], [8808, 8808, 8861, 8861, 8970], [8972, 8972, 8997, 8997, 9216], [9218, 9290, 9343, 9343, 11507], [11509, 11509, 11534, 11534, 11565], [11567, 11567, 11590, 11590, 11633], [11635, 11710, 11761, 11761, 11858], [11860, 11860, 11906, 11906, 12065], [12067, 12067, 12094, 12094, 12389], [12391, 12391, 12450, 12450, 12729], [12825, 12825, 12894, 12894, 13858], [13860, 13951, 13986, 14035, 14487], [14489, 14489, 14521, 14521, 14571], [14573, 14573, 14596, 14596, 14952], [14954, 14954, 14974, 14974, 15224], [15226, 15278, 15315, 15315, 15395], [15397, 15397, 15458, 15505, 15639], [15641, 15641, 15663, 15663, 15743], [15745, 15772, 15795, 15795, 15848], [15942, 15942, 15965, 15965, 16397], [16399, 16399, 16422, 16422, 16584], [16586, 16586, 16609, 16609, 17269], [17271, 17271, 17298, 17298, 17517], [17519, 17519, 17544, 17544, 17802], [17804, 17804, 17832, 17832, 18082], [18084, 18084, 18112, 18112, 18777], [18779, 18779, 18807, 18807, 19477], [19479, 19479, 19507, 19507, 20424], [20426, 20426, 20451, 20451, 21111], [21113, 21113, 21145, 21145, 21795], [21797, 21797, 21824, 21824, 21971], [21973, 21973, 22008, 22008, 22572], [22574, 22574, 22610, 22610, 22753], [22755, 22839, 22862, 22862, 23022], [23024, 23024, 23081, 23081, 25697]], "test": "untested"}
{"id": "clS3Rz", "name": "高斯模糊0", "author": "ZhuKai_Jul", "description": "高斯模糊0", "tags": ["2d"], "likes": 0, "viewed": 182, "published": 3, "date": "1672717926", "time_retrieved": "2024-07-30T18:18:11.675773", "image_code": "float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 计算uv, iResolution.xy是screen大小\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 模拟像素\n    vec2 pixed = 2.0 / iResolution.xy;\n    // 相邻像素的uv\n    vec2 texcoords[24];\n    texcoords[0] = uv + vec2(-1.0, 0.0) * pixed;\n    texcoords[1] = uv + vec2(0.0, -1.0) * pixed;\n    texcoords[2] = uv + vec2(1.0, 0.0) * pixed;\n    texcoords[3] = uv + vec2(0.0, 1.0) * pixed;\n    texcoords[4] = uv + vec2(-1.0, -1.0) * pixed;\n    texcoords[5] = uv + vec2(-1.0, 1.0) * pixed;\n    texcoords[6] = uv + vec2(1.0, -1.0) * pixed;\n    texcoords[7] = uv + vec2(1.0, 1.0) * pixed;\n    texcoords[8] = uv + vec2(-2.0, 0.0) * pixed;\n    texcoords[9] = uv + vec2(2.0, 0.0) * pixed;\n    texcoords[10] = uv + vec2(0.0, 2.0) * pixed;\n    texcoords[11] = uv + vec2(0.0, -2.0) * pixed;\n    texcoords[12] = uv + vec2(-2.0, -1.0) * pixed;\n    texcoords[13] = uv + vec2(-2.0, 1.0) * pixed;\n    texcoords[14] = uv + vec2(-1.0, -2.0) * pixed;\n    texcoords[15] = uv + vec2(-1.0, 2.0) * pixed;\n    texcoords[16] = uv + vec2(1.0, -2.0) * pixed;\n    texcoords[17] = uv + vec2(1.0, 2.0) * pixed;\n    texcoords[18] = uv + vec2(2.0, -1.0) * pixed;\n    texcoords[19] = uv + vec2(2.0, 1.0) * pixed;\n    texcoords[20] = uv + vec2(-2.0, -2.0) * pixed;\n    texcoords[21] = uv + vec2(-2.0, 2.0) * pixed;\n    texcoords[22] = uv + vec2(2.0, -2.0) * pixed;\n    texcoords[23] = uv + vec2(2.0, 2.0) * pixed;\n    // 相邻像素对应的权重, 卷积核\n    float w[24];\n    w[0] = w[1] = w[2] = w[3] = weight[0];\n    w[4] = w[5] = w[6] = w[7] = weight[1];\n    w[8] = w[9] = w[10] = w[11] = weight[2];\n    w[12] = w[13] = w[14] = w[15] = w[16] = w[17] = w[18] = w[19]= weight[3];\n    w[20] = w[21] = w[22] = w[23] = weight[4];\n    // 权重总和, 用来归一化卷积核\n    float totalWeight = w[0] * 4.0 + w[4] * 4.0 + w[8] * 4.0 + w[12]*8.0 + w[20]*4.0;\n    // 卷积运算\n    vec4 gaussColor = vec4(0.0);\n    for (int i = 0; i < 24; i++) {\n        gaussColor += texture(iChannel0, texcoords[i]) * w[i] / totalWeight;\n    }\n    // 原图\n    vec4 originalColor = texture(iChannel0, uv);\n    // sin + time动态变化\n    float normalTime =0.7;// abs(sin(iTime));\n    // mix输出颜色\n    fragColor = mix(originalColor, gaussColor, normalTime);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clS3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 136, 183, 2369]], "test": "untested"}
{"id": "DlS3RR", "name": "Cheap water effect", "author": "fishy", "description": "Looks pretty good too", "tags": ["water"], "likes": 17, "viewed": 372, "published": 3, "date": "1672701812", "time_retrieved": "2024-07-30T18:18:12.436738", "image_code": "mat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(in vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(in vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(in vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k.\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m =  (iMouse.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, iMouse.z);\n    \n    vec2 rot = vec2(3.14*0.5, 0)-m.xy;\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, 1)), rot.y), rot.x);\n    \n    bool hit;\n    vec3 pli = planeIntersect(ro, rd, 0., hit);\n    \n    vec3 env = texture(iChannel0, mix(reflect(rd, normalize(vec3(0, 1, 0)+0.02*(texture(iChannel1, 0.1*(pli.xyz+iTime)).xyz-0.5))), rd, 1.-float(hit))).rgb;\n\n    fragColor = vec4(env, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlS3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 103, 103, 138], [140, 140, 171, 171, 206], [208, 208, 239, 239, 274], [277, 277, 359, 359, 443], [445, 445, 510, 510, 622], [624, 624, 681, 731, 1273]], "test": "untested"}
{"id": "dtl3Ds", "name": "Electric Mesh [197 chars]", "author": "kishimisu", "description": "My first shader of 2023, happy new year :)", "tags": ["bloom", "glow", "code", "neon", "short", "golf", "golfing"], "likes": 56, "viewed": 1128, "published": 3, "date": "1672696510", "time_retrieved": "2024-07-30T18:18:13.232610", "image_code": "/* \"Electric Mesh\" by @kishimisu (2023) - https://www.shadertoy.com/view/dtl3Ds\n    \n    199 chars => 197 chars by @GregRostami */\n\nvoid mainImage(out vec4 O, vec2 u) {\n    u = abs(u+u-(O.xy=iResolution.xy))/O.y; O *= 0.;\n    \n    for (float i = 0., t = iTime*.5; i < 46.; O += .002/\n        abs(abs(u.x-sin(t+i*.17)*.7)+u.y-sin(t+i*.1)*.6)\n        *(cos(i+++vec4(0,1,2,0))+1.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtl3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 168, 168, 382]], "test": "untested"}
{"id": "mts3Wl", "name": "Triangle filler 2d", "author": "raymarchingenthusiast", "description": "Fills triangles with textures. Depth corrected.", "tags": ["triangles"], "likes": 0, "viewed": 166, "published": 3, "date": "1672688112", "time_retrieved": "2024-07-30T18:18:14.079347", "image_code": "struct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec3 CalcUv(vec2 p, Triangle tpo, Triangle tuv) {\n    Triangle tp = Triangle(tpo.a/tpo.a.z,tpo.b/tpo.b.z,tpo.c/tpo.c.z);\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    vec3 perspUv = w1*tuv.a/tp.a.z + w2*tuv.b/tp.b.z + w3*tuv.c/tp.c.z;\n    float pz = (w1*tp.a.z + w2*tp.b.z + w3*tp.c.z);\n    return perspUv * pz;\n}\n\nbool isInside(vec2 p, Triangle triO) {\n    Triangle tri = Triangle(triO.a/triO.a.z,triO.b/triO.b.z,triO.c/triO.c.z);\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + (iMouse.xy-iResolution.xy/2.)) / iResolution.xy;\n    if(iMouse.xy == vec2(0.)) uv = fragCoord / iResolution.xy;\n    \n    Triangle ts[2];\n    Triangle uvs[2];\n    \n    ts[0] = Triangle(vec3(0.,0.,1.),vec3(0.,1.,1.),vec3(1.,0.,1.));\n    uvs[0] = Triangle(vec3(0.,0.,1.),vec3(0.,1.,1.),vec3(1.,0.,1.));\n    ts[1] = Triangle(.5+.45*vec3(cos(iTime*.5),sin(iTime*2.),1.25),vec3(1.),vec3(0.,1.,1.));\n    uvs[1] = Triangle(vec3(1.,0.,1.),vec3(1.),vec3(0.,1.,1.));\n    \n    fragColor = vec4(0.,0.,.3,1.);\n    for(int i = 0; i < ts.length(); i++) {\n        if(isInside(uv,ts[i])) {\n            vec3 textureUv = CalcUv(uv,ts[i],uvs[i]);\n            \n            vec3 col = texelFetch(iChannel0,ivec2(textureUv.xy*iChannelResolution[0].xy)/2,1).xyz;\n        \n            fragColor = vec4(col,1.);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,1.);\n        }\n    }\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 107, 107, 741], [743, 743, 781, 781, 1227], [1229, 1229, 1286, 1286, 2228]], "test": "untested"}
{"id": "ctlGDs", "name": "monogram/sigil extruded", "author": "remaindeer", "description": "monogram/sigil extruded (as suggested by @jt)\nd\n  a\n    n\nw/ alternative style \"n\" or \"N\", not sure which is better...", "tags": ["3d", "raymarching", "sdf", "sigil", "extrusion", "dan", "monogram"], "likes": 8, "viewed": 194, "published": 3, "date": "1672682526", "time_retrieved": "2024-07-30T18:18:14.924088", "image_code": "const float sixto = 1.0 / 6.0;\n\nfloat sdMonogram(vec2 p, float t, vec4 dann) {\n    float d = 1.0;\n    // d\n    if (bool(dann.x)) {\n        d = sdSegment(p, vec2(0, -1.0 * sixto), vec2(0, +3.0 * sixto), t);\n        d = opUnion(d, opOnion(sdBox(p + vec2(+sixto, 0), vec2(sixto)), t));\n    }\n    // a\n    if (bool(dann.y)) {\n        d = opUnion(d, sdSegment(p, vec2(-1.0 * sixto, 1.0 * sixto), vec2(-1.0 * sixto, 2.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(-1.0 * sixto, 2.0 * sixto), vec2(1.0 * sixto, 2.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(1.0 * sixto, 2.0 * sixto), vec2(1.0 * sixto, 0.0 * sixto), t));\n        d = opUnion(d, opOnion(sdBox(p + vec2(0, +sixto), vec2(sixto)), t));\n    }\n    // n/N\n    if (bool(dann.z) || bool(dann.w)) {\n        d = opUnion(d, sdSegment(p, vec2(0, 0), vec2(0.0, -3.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(0, -sixto), vec2(2.0 * sixto,  (bool(dann.w) ? -1.0 : -3.0) * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(2.0 * sixto, -3.0 * sixto), vec2(2.0 * sixto, -sixto), t));\n    }\n    return d;\n}\n\nfloat sdSigil(vec2 p, float t, vec4 dann) {\n    float d = sdMonogram(p + vec2(sixto, -4.0 * sixto), t, dann);\n    d = opUnion(d, sdMonogram(rotmat2(radians(090.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    d = opUnion(d, sdMonogram(rotmat2(radians(180.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    d = opUnion(d, sdMonogram(rotmat2(radians(270.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    return d;\n}\n\nfloat scene(vec3 p) {\n    float t = 0.125 * sixto;\n    float y = abs(-cos(iTime / 2.0) * 5.0);\n    p.xy = rotmat2(iTime / 3.0) * p.xy;\n    float d = sdSigil(p.xy, t, vec4(y > 1.0, y > 2.0 , y > 3.0, y > 4.0));\n    return opExtrusion(p.z, d, 0.25);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d;\n\n  for (int i = 0; i < MAX_ITER; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n\n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 3);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI/2., PI/2., m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 2, 2);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "// math\n//// constants\n#define PI 3.14159265359\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n//// schwarz triangle\n#define v1 vec2(0, 0)\n#define v2 vec2(0, cos30)\n#define v3 vec2(0.5, cos30)\n\n// ray marching\n#define MAX_ITER 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n//// signed distance functions\n////// ------------------------------------------------\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions/\n    return abs(sdf) - thickness;\n}\n\nfloat opExtrusion(in float p, in float d, in float h) {\n    // modified: https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n////// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// ------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1092, 1092, 1135, 1135, 1511], [1513, 1513, 1534, 1534, 1762], [1764, 1764, 1795, 1795, 2023], [2025, 2025, 2049, 2049, 2241], [2243, 2243, 2290, 2290, 2452], [2454, 2454, 2509, 2509, 3422]], "test": "untested"}
{"id": "Dtl3Wl", "name": "tiling with random orientation", "author": "FabriceNeyret2", "description": "from the unbiased variant of https://shadertoy.com/view/4scGWf ,\ngenerates tiles with varying rotations / symmetries ( 4 possibilities over 8).\n( switch comments to see gradients ).", "tags": ["short", "onetweet"], "likes": 15, "viewed": 444, "published": 3, "date": "1672671590", "time_retrieved": "2024-07-30T18:18:15.846621", "image_code": "// variant of https://shadertoy.com/view/4scGWf\n      \nvoid mainImage( out vec4 O,  vec2 U )\n{  float h= sin(1e5*length (ceil(U/=32.)));\n   O = texture(iChannel0, sign(abs(h)-.5)* fract( h < 0.  ? U : U.yx ));\n// O = vec4( fract( sign(abs(h)-.5)*U[int(h+1.)] )); // grey gradient\n\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtl3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 94, 94, 282]], "test": "untested"}
{"id": "ddSXR1", "name": "Extruded Neon Hearts", "author": "Shane", "description": "Constructing and rendering an extruded packed geometric heart pattern in realtime.", "tags": ["raymarching", "heart", "neon", "extrude", "semiregular", "floret"], "likes": 61, "viewed": 718, "published": 3, "date": "1672667713", "time_retrieved": "2024-07-30T18:18:16.784115", "image_code": "/*\n\n    Extruded Neon Hearts\n    --------------------\n    \n    This is an extruded version of a reasonably popular geometric heart pattern that has\n    been constructed and rendered in realtime. It's a simple variation on a common pentagon \n    floret arrangement, which is technically known for being the dual of a 3,3,3,3,6 snub \n    trihexagonal semi-regular tessellation of the grid... It's a fancy sounding description, \n    but the imagery is pretty basic, if you're not sure and feel like looking it up. :)\n    \n    Extruded square grids are a modern computer image cliche. You'll see them everywhere,\n    especially in stock imagery. Hexagon grids are less common, and triangle grids are \n    less common still, but there are still plenty around. There are a lot of varations as \n    well, like subdivided grids, offset grids to a lesser degree and so forth.\n    \n    After looking around the internet, I noticed that people don't stray much from these \n    base extrusion patterns. Semi-regular grid patterns and their duals are reasonably \n    common in the 2D realm, but you rarely see extruded versions, if at all, so a while \n    back I decided to make some. Obviously, more complicated patterns require more\n    calculation, and that can be exacerbated in a realtime pixelshader environment, but \n    I've seen people on here code harder stuff, so I'm surprised that there are no examples\n    on here at all.\n    \n    There are a number of ways to construct these patterns, and I'm not sure what would\n    be the most efficient, but I've tried my best. The objective for the time being was to \n    get a few extruded semi-regular patterns on the board with the hope that better methods \n    for their construction will be devised later.\n    \n    By the way, there a couple of defines to change the pattern shape and glow color, for\n    anyone interested.\n\n\n    \n    Related examples:\n    \n    // I like this example, since it's a simple 2D semi-regular tiling \n    // visual reference. The floret pattern is contained in it somewhere.\n    Wythoff Uniform Tilings + Duals - Fizzer \n    https://www.shadertoy.com/view/3tyXWw\n    \n    // A Wythoff\\Kaspar-Klug based approach to semi-regular patterns, etc. It's\n    // a nice looking shader. Remaindeer has a really cool extruded boundary \n    // version on here too, if you feel like looking that up. Although, that\n    // shouldn't be confused with the kind of extrusion I'm performing here, which\n    // requires neighboring cell considerations.\n    caspar-klug sdf - remaindeer\n    https://www.shadertoy.com/view/cdsSDS\n    \n    // The following is mildly related believe it or not.\n    Extruded Hexagon Fractal Curve - Shane\n    https://www.shadertoy.com/view/cdjGWy\n    \n*/\n\n\n// Glow color - Red: 0, Blue: 1, Green: 2\n#define COLOR 1\n\n// Extruded shape. Just the two. The floret is a little slow at the moment,\n// but I'll put some effort in later to make it faster.\n//\n// Heart: 0, Floret 1.\n#define SHAPE 0\n\n\n\n#define ZERO min(iFrame, 0)\n\n// Global tile scale.\nconst float scale = 1./2.;\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\nvec3 getCol(sampler2D s2D, vec2 p){\n \n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(s2D, p*scale/16.*s).xyz; \n    return tx*tx;\n\n    //float rnd = hash21(p);\n    //return .5 + .45*cos(6.2831*rnd + vec3(0, 1, 2)*1.5);\n}\n\nfloat ht;\nfloat getHeight(vec2 p){\n\n    vec3 col = getCol(iChannel0, p);\n    if(fract(dot(col, vec3(1))*143.5273)<.2) return -1.;\n    float h = dot(col, vec3(.299, .587, .114));\n    ht = smoothstep(.9, .94, sin(6.2831*h*4. + iTime));\n    return h*.25*(1. + ht) + .025; \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n\n\n\nvec4 gVal; // Global container for 2D distance, etc.\nvec3 glow, lCol; // Global glow and glow color variables.\n\n\n// The extruded image.\nfloat map(vec3 p){\n\n    \n    \n    // Floor.\n    float fl = abs(p.z - .5) - .5;\n\n    \n    float gridScale = scale;\n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p.xy/gridScale);\n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy, .5, 0.);\n    \n \n    \n    const vec2 sDiv12 = s/12.;\n    \n    \n    const float ew = .0; // Edge width.\n    const float ang = atan(sqrt(3.)/5.); // Rotation angle.\n    const float invR = 1./sqrt(7.); // Scaling factor.\n    vec2 q = p4.xy;\n    \n    // Rotate the coordinates in the hexagon grid.\n    q = rot2(ang)*q;\n    float hR = 1.5*invR;\n    float ctrHx = getHex(q, hR, 0.);\n    \n    \n    // Triangle radius.\n    float tR = hR/.8660254;\n    float ctrTri = getTri(rot2(3.14159/6.)*q, tR);\n    ctrTri = min(ctrTri, getTri(rot2(-3.14159/6.)*q, tR));\n    ctrTri = max(ctrTri, ctrHx);\n    \n    // Edge construction lines and shape distance holder.\n    float[6] flLn, flLn2, d6;\n    \n    \n    // Iterate through all six sides of the hexagon cell and create\n    // some edge construction lines.\n    for(int i = 0; i<6; i++){\n       vec2 vi = vID[i]*sDiv12;\n       // Short for the following:\n       //flLn[i] = distLineS(q, vec2(0), vi);\n       flLn[i] = dot(q, vec2(-vi.y, vi.x)*sqrt(3.));\n    }\n    \n    #if SHAPE == 0\n    int j = int(mod(floor(hash21(p4.zw)*36.), 2.));\n    #endif\n    \n \n    vec2[6] cID6;\n    #if SHAPE == 0\n    for(int i = ZERO; i<6; i+=2){\n    #else\n    for(int i = ZERO; i<6; i++){\n    #endif\n    \n        \n        #if SHAPE == 0\n        int ip0 = (i + j)%6;\n        int ip1 = (i + 2 + j)%6;\n        #else\n        int ip0 = i;\n        int ip1 = (i + 1)%6;\n        #endif\n        \n        // The 2D field for this particular shape.\n        d6[i] = (max(ctrTri, max(flLn[ip0], -flLn[ip1])) + ew)*gridScale;\n        // The ID.\n        cID6[i] = p4.zw + eID[i]*invR*2.;\n         \n    }\n    \n    /*\n    // It'd be nice to use polar partitioning to cut down on GPU costs, but,\n    // unfortunately, there are overlap issues. I might try again later.\n    float naB;\n    vec2 qB = rot2(-3.14159/6.)*q;\n    qB = polRot(qB, naB, 6.);\n    int indB = int(mod(8. - naB, 6.));\n    float hi = getHeight(cID6[indB]);\n    */\n    \n    float svHt = -1e5;\n\n    float df = 1e5;\n    #if SHAPE == 0\n    for(int i = ZERO; i<6; i+=2){\n    #else\n    for(int i = ZERO; i<6; i++){\n    #endif        \n \n        // Extruding the 2D field.\n        float hi = getHeight(cID6[i]);//dot(dCol, vec3(.299, .587, .114))*.2;//.2;\n        float di = opExtrusion(d6[i], p.z + hi/2., hi/2.);\n        // Extra face height to reflect light a bit better.\n        di += d6[i]*.125;\n        // Face rippling.\n        //di += (smoothstep(0., .5, sin(d6[i]*124. - 1.57/2.*0.)*.5 + .5) - .5)*.005;\n        \n        // Minimum distance.\n        if(di<df){\n        \n            df = di;\n            gVal = vec4(d6[i], hi, cID6[i]);\n            svHt = ht;\n        }\n    }\n    \n    /////\n        \n    // Some of the neighboring florets (or heart tips) encroach into this cell, so we \n    // need to construct those too. We only need the tips of the objects, which are\n    // hexagonal in shape, so those will do.\n    float na;\n    q = polRot(q, na, 6.);\n    q.x -= tR;\n    q *= rot2(3.14159/6.);\n    float smHx = getHex(q, invR/2. - ew, 0.); // Triangle.\n    smHx *= gridScale;\n    \n    int ind = int(mod(8. - na, 6.));\n    \n    \n    // Add the neighbors.\n    #if SHAPE == 0\n    // Check to see whether the neighbor has been rotated, and if so\n    // offset the index to match.\n    int jn = int(mod(floor(hash21(p4.zw + eID[ind]*2.)*36.), 2.));\n    int ind2 = int(mod(7. - floor((na + float(jn))/2.)*2., 6.));\n    vec2 smHxID = p4.zw + eID[(ind)%6]*2. - eID[(ind2)%6]*invR*2.;\n    #else\n    vec2 smHxID = p4.zw + eID[ind]*(1. - invR)*2.; // See above.\n    #endif\n    \n    float hgt = getHeight(smHxID);\n    float dB = opExtrusion(smHx, p.z + hgt/2., hgt/2.);\n    dB += smHx*.125;\n    //dB += (smoothstep(0., .5, sin(smHx*80. - 1.57/2.*0.)*.5 + .5) - .5)*.003;\n         \n    // Update.\n    if(dB<df){\n        df = dB;\n        gVal = vec4(smHx, hgt, smHxID);\n        svHt = ht;\n    }\n    \n    \n    // Overall object ID.\n    objID = fl<df? 1. : 0.;\n \n    // Glow color beam calculations.\n    lCol = vec3(0);\n    if(df<.25 && objID<.5){\n       vec3 gCol = mix(vec3(1, .1, .3), vec3(1., .3, .1), hash21(gVal.zw + .12));\n       lCol = svHt*gCol*smoothstep(0., .5, -(gVal.x));\n    }\n   \n    \n    \n    // Combining the floor with the extruded object.\n    return  min(fl, df);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319) + rd)*.1, d;\n    \n    glow = vec3(0);\n    \n    for(int i = ZERO; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += d*.7;//d<.5? d*.5 : d*.9; \n        \n        // Accumulate the glow color.\n        glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.7, .1); \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.004, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .005, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n\t// Camera Setup.\n    vec3 ro = vec3(cos(iTime/4.)*.15, sin(iTime/4.)*.15 + iTime/8., -1.5); // Camera position.\n\tvec3 lk = vec3(0, iTime/8. + .6, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = lk + vec3(-.5, 1.5, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // Camera.\n    //mat3 mCam = mat3(rgt, up, fwd);\n    // rd - Ray direction.\n    //vec3 rd = mCam*normalize(vec3(uv, 1./FOV));//\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the object ID.\n    float svObjID = objID;\n    \n    vec4 svVal = gVal;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6); \n        \n        vec3 txP = sp;\n        float sf = 1.5/iResolution.y;\n        float ew = .005;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n             // Light edge.\n            float d = svVal.x; // 2D face distance.\n            float h = svVal.y; // Object height.\n            float dz = txP.z + h; // Heigh cutoff.\n            \n            // Face color.\n            vec3 fCol = getCol(iChannel0, svVal.zw/1.);\n            fCol = vec3(1.35)*(dot(fCol, vec3(.299, .587, .114)) + .25);\n      \n          \n            // Tri-planar texture lookup.\n            vec3 tx = tex3D(iChannel1, sp - vec3(0, 0, -h), sn);\n           \n           \n            // Matches the glow color in the distance function.\n            vec3 hCol = mix(vec3(1, .1, .3), vec3(1., .3, .1), hash21(svVal.zw + .12));\n            // Blending the glow portion from timber to metallic when it's glowing.\n            vec3 tx2 = mix(tx*vec3(.8, 1, 1.2)*(hCol*.5 + 1.25), tx, min(glow.x*2., 1.));\n            \n            // Rendering face colors and borders.\n            vec3 sideCol = vec3(.35);\n            texCol = mix(sideCol, vec3(0), 1. - smoothstep(0., sf, dz - ew));\n            texCol = mix(texCol, sideCol, 1. - smoothstep(0., sf, d + ew));//*vec3(1.4, 1, .5)\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, d + .04));\n            texCol = mix(texCol*(tx*2. + .05), fCol*(tx2*2. + .05), 1. - smoothstep(0., sf, d + .04 + ew*2.));\n            \n             // Ramp up the diffuse value for a more metallic look.\n            //diff = pow(diff, 4.)*2.;\n           \n \n        }\n        else {\n            \n            // The floor.\n            \n            // Background.\n            texCol = vec3(.7);\n            \n             // Tri-planar texture lookup.\n            vec3 tx = tex3D(iChannel1, sp, sn);\n           \n            // Combine for the final surface color.\n            texCol *= tx + .05;//*vec3(1.2, 1, .8);\n            \n            //texCol *= vec3(1.2, 1, .8);\n            \n            // Ground rim.\n            float d = abs(svVal.x) - ew*1.5;\n            if(svVal.y>0.) texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, d)); \n          \n        }\n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel2, ref).xyz; refTx *= refTx;\n        refTx = (texCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        float rf = (svObjID == 1.)? .25 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n        texCol += spRef*refTx*rf*1.; //smoothstep(.03, 1., spRef) \n\n        //texCol = texCol + vec3(4, .5, 1)*texCol*glow*4.;\n       \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n        \n        // Apply the glow color.\n        #if COLOR == 0\n        col = col/2. + col*glow*36.;\n        #elif COLOR == 1\n        col *= vec3(1.1, 1, .9);   \n        col = col/2. + col*glow.zyx/vec3(1.1, 1, .9)*40.;\n        #else\n        col *= vec3(1.2, 1, .8);   \n        col = col/2. + col*glow.yxz/vec3(1.2, 1, .8)*32.;\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // It's sometimes helpful to check things like shadows and AO by themselves.\n        //col = vec3(ao);\n          \n\t\n\t}\n    \n    // Horizon fog. Not visible here, but provided for completeness.\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){ \n    \n    return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    /*\n    // IQ's vec2 to float hash.\n    // An accuracy hack for this particular example. Unfortunately, \n    // \"1. - 1./3.\" is not always the same as \"2./3.\" on a GPU.\n    p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    */\n}\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n// Multiplying them by \"s\" gives the actual vertex postion.\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\n                     \n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-6, -2), vec2(-6, 2), vec2(0, 4), \n                      vec2(6, 2), vec2(6, -2), vec2(0, -4));\n\nconst vec2[6] eID = vec2[6](vec2(-6, 0), vec2(-3, 3), vec2(3, 3), vec2(6, 0), \n                      vec2(3, -3), vec2(-3, -3));\n\n#endif\n/*\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat getHex(in vec2 p, float r, in float sf){\n   \n      #ifdef FLAT_TOP\n      // Flat top.\n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      #else\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n      #endif\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      #ifdef FLAT_TOP\n      // Flat top.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      #else\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n      #endif\n    \n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    // The ID is multiplied by 12 to account for the inflated neighbor IDs above.\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy*12.) : vec4(q.zw, ip.zw*12. + 6.);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\n\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, float aN){\n\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n\n    return p;\n}\n ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3131, 3211, 3257, 3257, 4169], [4171, 4171, 4206, 4257, 4414], [4426, 4426, 4450, 4450, 4687], [4690, 4717, 4774, 4774, 5080], [9774, 9795, 9831, 9950, 10745], [10748, 10839, 10875, 11242, 11514], [11517, 11708, 11760, 11841, 13106], [13109, 13261, 13296, 13296, 13541], [13544, 13544, 13600, 13633, 20258]], "test": "untested"}
{"id": "mlf3Ws", "name": "Sphere order to chaos (progressi", "author": "FabriceNeyret2", "description": "Variant of [url]https://shadertoy.com/view/dtf3Ws[/url] with points progressively displaced", "tags": ["sphere", "glow", "sampling", "fibonacci", "short", "reproduction"], "likes": 28, "viewed": 407, "published": 3, "date": "1672663025", "time_retrieved": "2024-07-30T18:18:17.668750", "image_code": "// progressive variant of https://shadertoy.com/view/dtf3Ws\n// variant of \"Little Fibonacci Sphere\" by Xor. https://shadertoy.com/view/7tVSDh\n\nvoid mainImage( out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy, p,\n         U = ( u+u - R ) / R.y;\n    O*=0.;    \n\n    for(float i=-1.; i<1.; i+=6e-3)\n    {\n        p = cos(i*4e2+iTime+vec2(0,11))*sqrt(1.-i*i);    // Fibonacci distrib + Rotate\n        vec3 h = 2.*fract(1e4*sin(i*vec3(1733,-7117,2913)))-1.; // 3D rand\n        h.xz *= cos(i*4e2+iTime+vec2(0,11));\n        h = mix( h, vec3(p.x,i,p.y), .9+.1*clamp(5.*(2.*sin(iTime/2.)-fract(1e4*sin(i*1e4))+.5),-1.,1.) ); // interpolate between both points\n        O += smoothstep(3./R.y,0.,length(U-h.xy/(h.z+2.))-.01/(h.z+2.)); // perspective + draw point\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlf3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 180, 180, 760]], "test": "untested"}
{"id": "dtf3Ws", "name": "Sphere order to chaos (and back)", "author": "FabriceNeyret2", "description": "vaguely inspired by [url]https://twitter.com/etiennejcb/status/1609340724515901442[/url]\nReusing the base of Xor's Fibonacci sphere sampling [url]https://shadertoy.com/view/7tVSDh[/url]", "tags": ["sphere", "glow", "sampling", "fibonacci", "short", "reproduction"], "likes": 29, "viewed": 444, "published": 3, "date": "1672662462", "time_retrieved": "2024-07-30T18:18:18.424728", "image_code": "// variant of \"Little Fibonacci Sphere\" by Xor. https://shadertoy.com/view/7tVSDh\n\nvoid mainImage( out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy, p,\n         U = ( u+u - R ) / R.y;\n    O*=0.;    \n\n    for(float i=-1.; i<1.; i+=6e-3)\n    {\n        p = cos(i*4e2+iTime+vec2(0,11))*sqrt(1.-i*i);    // Fibonacci distrib + Rotate\n        vec3 h = 2.*fract(1e4*sin(i*vec3(1733,-7117,2913)))-1.; // 3D rand\n        h.xz *= cos(i*4e2+iTime+vec2(0,11));\n        h = mix( h, vec3(p.x,i,p.y), .9+.1*sin(iTime) ); // interpolate between both points\n        O += smoothstep(3./R.y,0.,length(U-h.xy/(h.z+2.))-.01/(h.z+2.)); // perspective + draw point\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtf3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 120, 120, 650]], "test": "untested"}
{"id": "dtf3Dl", "name": "log fall 2", "author": "FabriceNeyret2", "description": ".", "tags": ["short", "log", "fall"], "likes": 14, "viewed": 225, "published": 3, "date": "1672659305", "time_retrieved": "2024-07-30T18:18:19.171731", "image_code": "// variant of https://shadertoy.com/view/mtfGDl\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n         \n    U.y = log2(1.-U.y) - iTime;\n    U *= 10.;\n    if ( mod(U.x+.5,2.) > 1. ) U.y += .5;\n    vec2 F = fract( U +.5 ) -.5, V = F;\n    V.y *= exp2(floor(U.y)/10.+iTime) / 1.4;  // why / 1.4 ? \n    \n    V = smoothstep( 30./R.y, 0., abs(V)-.3 );                 // blocks\n    F = smoothstep( 0.,1., (.5-abs(F)) / min(fwidth(F),.4) ); // lines\n    \n    O = vec4(min(F.x,F.y) *min(V.x,V.y) );                    // blacks + lines\n    O = mix(O, vec4(.6), V.x*smoothstep(0.,.5,-dFdy(U.y)));   // fading to mid color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtf3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 669]], "test": "untested"}
{"id": "mtfGDl", "name": "log fall", "author": "FabriceNeyret2", "description": ".", "tags": ["short", "log", "fall"], "likes": 13, "viewed": 213, "published": 3, "date": "1672655427", "time_retrieved": "2024-07-30T18:18:19.928707", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n         \n    U.y = log2(1.-U.y) - iTime;\n    U *= 10.;\n    \n    vec2 I = floor( U ),\n         F = fract( U +.5 ) -.5;\n         \n    F = smoothstep( 0.,1., abs(F) / min(fwidth(F),.4) ); \n    O = vec4(min(F.x,F.y));                               // lines\n    O.r = mod(I.x+I.y,2.);                                // checker\n    O = mix(O, vec4(.5,1,1,1)*.5, smoothstep(0.,.5,fwidth(U.y)));  // fading to mid color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 515]], "test": "untested"}
{"id": "mlX3Wl", "name": "maze scroll loop", "author": "FabriceNeyret2", "description": "vaguely inspired by https://twitter.com/ruuddotorg/status/1609592373822255107\n\n- why this simple maze generator ( either left or bottom cell wall, at random )  cause a general diagonal path ? \n- why do I need to slightly slowdown the flood front ? ", "tags": ["loop", "scroll", "maze", "short"], "likes": 20, "viewed": 281, "published": 3, "date": "1672654084", "time_retrieved": "2024-07-30T18:18:20.716600", "image_code": "// ========== display =============\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= 360./R.y/4./R;\n    O    = texture(iChannel0, U)*2. -1.;\n    O.r += texture(iChannel1, U).x;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ====== maze generator ===========\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( U - float(iFrame) ) / 4.; \n // O = vec4( fract( U[ fract(1e3*sin(dot(mod(ceil(U),20.),vec2(73,-13))) )>.5 ? 0:1 ] ));\n    O = vec4( fract(-U[ fract(1e3*sin(dot(mod(ceil(U),20.),vec2(73,-17))) )>.5 ? 0:1 ] ));\n}", "buffer_a_inputs": [], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_b_code": "// ======== flooding ================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n   O *= 0.;\n   if (U.y > 1.) O = T(U-1.);                                   // scroll\n   \n   if (iFrame==0) { if ( length(U-vec2(75,40) ) < 5. ) O.r++; } // init \n   \n   else if (    texelFetch(iChannel1,ivec2(U),0).x < .3         // floor\n             && textureLod(iChannel0,U/R,1.).r > 0. \n             && ( iFrame%4 ) < 2 + (iFrame%3<2?1:0)  // slow down the front\n           ) O.r ++;\n    \n\n       \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 75, 75, 183]], "test": "untested"}
{"id": "dtfGDl", "name": "Uniform Distribution on Disk V2", "author": "katayu", "description": "Sampling from Uniform Probability Distribution on Disk with Hashing", "tags": ["disk", "hash", "probability"], "likes": 4, "viewed": 3492, "published": 3, "date": "1672653429", "time_retrieved": "2024-07-30T18:18:21.601235", "image_code": "\n// original source for hash : https://www.shadertoy.com/view/4lXyWN\nconst uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    //I think the value of x is usually comes from 2D/3D coordinates or time in most of applications.\n    //These values are small and continuous.\n    //So, multiply large prime value first.\n    x*=k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\nvec4 disk(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=  vec4(1., 1., 1., 1.0);\n\n    // \n    float lineWidth = 0.005;\n    float lineSpacing = 0.1;\n\n    // uv座標を計算\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // normalize\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float y = mod(uv.y, lineSpacing);\n    if (y <= lineWidth)\n    {\n        // 罫線を描画\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    // 横方向の罫線を描画する位置を計算\n    float x = mod(uv.x, lineSpacing);\n    if (x <= lineWidth)\n    {\n        // 罫線を描画\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }    \n  \n\n\n    float dist = length(uv - vec2(0.0, 0.0));\n\n    // 円の直径\n    float diameter = 0.75;\n\n    uvec3 p = uvec3(fragCoord, iFrame);\n    vec3 h = hash(p);\n    float sampling = h.x + h.y + h.z;\n    sampling = (sampling > 3.*0.5) ? 1.:0.;\n    vec3 color = vec3(1.,1.,1.);\n    color *= sampling;\n\n    if (dist <= diameter)\n    {\n        // サンプリングを描画\n       fragColor = vec4(color, 1.0);\n       \n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 241, 432, 622], [623, 623, 676, 676, 774], [776, 776, 833, 833, 1913]], "test": "untested"}
{"id": "ctfGDl", "name": "ReactionDiffusion2", "author": "DigitalShadow", "description": "Playing around some more with reaction diffusion effects. Should be audio reactive so long as the microphone initializes properly in Buffer A", "tags": ["visualizer", "reactiondiffusion", "microphone"], "likes": 10, "viewed": 528, "published": 3, "date": "1672626863", "time_retrieved": "2024-07-30T18:18:22.419049", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI2 6.28318530718\n#define M1 1597334677U\n#define M2 3812015801U\n\n\n//determines blob shape\nconst float blurSize1 = 4.0;\nconst float blurSize2 = 20.0;\n\n//monochrome fast blur\nfloat monoBlur(sampler2D channel, vec2 uv, vec2 scale, float step){\n    float result = 0.0;\n    int i=0;\n    vec2 d;\n    for(float y=-scale.y; y < scale.y; y+=step){\n    for(float x=-scale.x; x < scale.x; x+=step){\n        d = vec2(x, y);\n        result += texture(channel, uv + (d / iChannelResolution[0].xy)).r*(1.0-smoothstep(0.0, scale.y*2.0,  length(d)));\n\n        i++;\n    }}\n    return result / float(i);\n}\n\n//Fast Hash\n    float hash( uvec2 q ){\n    q *= uvec2(M1, M2); \n    uint n = (q.x ^ q.y) * M1;\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvR = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    //noise and audio data\n    vec3 noise = vec3(1.0,1.0,1.0) * hash(uvec2(fragCoord*iTime));\n    noise.r = clamp(noise.r, 0.0, 1.0);\n    float fft = texture(iChannel1,vec2(length(uvR), 0.25)).r;\n    float wave = texture(iChannel1, vec2(uv.x, 0.75)).r;\n    \n    //lookup uv\n    vec2 uv2 = (uv - 0.5);\n    uv2 *= 0.999 * (1.0+(length(uv2/2.0) /300.0));\n    uv2 *= 1.0 - (.03 * fft) * (0.5 + 0.25 * smoothstep(length(vec2(aspect,1.0)) / 2.0, 0.0, length(uvR)));\n    uv2.x += (.0001 + .002 * fft) * sin(wave + iTime + uv2.y*10.0);\n    uv2.y += (.0001 + .002 * fft) * cos(wave + iTime + uv2.x*10.0);\n    uv2 = uv2 + 0.5;\n    \n    //feedback\n    vec3 prev = texture(iChannel0, uv2).rgb;\n   \n    //dymamic blur\n    float vB = blurSize2 - (blurSize2 * (0.5 + 0.5 * sin(iTime)) - blurSize1 - 2.0); \n    \n    //get two versions of blurred image\n    vec3 blur1 = vec3(monoBlur(iChannel0, uv2, vec2(blurSize1),blurSize1/4.0));\n    vec3 blur2 = vec3(monoBlur(iChannel0, uv2, vec2(vB),(vB)/6.0));\n    \n    //reaction diffusion\n    vec3 col = prev - (blur2 - blur1*0.999);\n\n    //seed with noise\n    //col -= (0.0 + 1.0*fft)/16.0;\n    col += (noise.r-0.5)/8.0;\n    \n    //prevent value runaway\n    col = clamp(col, 0.0, 1.0);\n\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 192]], "test": "untested"}
{"id": "mtl3DB", "name": "monogram/sigil", "author": "remaindeer", "description": "monogram/sigil\nd\n  a\n    n\nw/ alternative style \"n\" or \"N\", not sure which is better...", "tags": ["sdf", "sigil", "dan", "monogram"], "likes": 16, "viewed": 226, "published": 3, "date": "1672623949", "time_retrieved": "2024-07-30T18:18:23.338590", "image_code": "const float sixto = 1.0 / 6.0;\n\nfloat sdMonogram(vec2 p, float t, vec4 dann) {\n    float d = 1.0;\n    // d\n    if (bool(dann.x)) {\n        d = sdSegment(p, vec2(0, -1.0 * sixto), vec2(0, +3.0 * sixto), t);\n        d = opUnion(d, opOnion(sdBox(p + vec2(+sixto, 0), vec2(sixto)), t));\n    }\n    // a\n    if (bool(dann.y)) {\n        d = opUnion(d, sdSegment(p, vec2(-1.0 * sixto, 1.0 * sixto), vec2(-1.0 * sixto, 2.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(-1.0 * sixto, 2.0 * sixto), vec2(1.0 * sixto, 2.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(1.0 * sixto, 2.0 * sixto), vec2(1.0 * sixto, 0.0 * sixto), t));\n        d = opUnion(d, opOnion(sdBox(p + vec2(0, +sixto), vec2(sixto)), t));\n    }\n    // n\n    if (bool(dann.z)) {\n        d = opUnion(d, sdSegment(p, vec2(0, 0), vec2(0.0, -3.0 * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(0, -sixto), vec2(2.0 * sixto,  (bool(dann.w) ? -1.0 : -3.0) * sixto), t));\n        d = opUnion(d, sdSegment(p, vec2(2.0 * sixto, -3.0 * sixto), vec2(2.0 * sixto, -sixto), t));\n    }\n    return d;\n}\n\nfloat sdSigil(vec2 p, float t, vec4 dann) {\n    float d = sdMonogram(p + vec2(sixto, -4.0 * sixto), t, dann);\n    d = opUnion(d, sdMonogram(rotmat2(radians(090.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    d = opUnion(d, sdMonogram(rotmat2(radians(180.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    d = opUnion(d, sdMonogram(rotmat2(radians(270.0)) * p + vec2(sixto, -4.0 * sixto), t, dann));\n    return d;\n}\n\nfloat scene(vec2 p) {\n    float t = 0.125 * sixto;\n    float y = abs(-cos(iTime / 2.0) * 5.0);\n    p = rotmat2(iTime / 3.0) * p;\n    return sdSigil(p, t, vec4(y > 1.0, y > 2.0 , y > 3.0, y > 4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// uv\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 q = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    p *= 3.0;\n    q *= 3.0;\n    \n    // dist\n    float d = scene(p);\n    \n    // color\n    vec3 col = vec3(0);\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n  \n    col = vec3(1.0) - sign(d) * vec3(0.65);\n\tcol *= 1.0 - exp(-24.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(240.0 * d);\n    \n    if (iMouse.z > 0.001) {\n        float d = scene(q);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q) - abs(d)) - 0.0005));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - q) - 0.0015));\n    }\n    \n    float aa = 2.0 / iResolution.y;\n    col = max(col, rnd * smoothstep(aa, 0.0, d));\n    \n    // output\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "mat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n//// signed distance functions\n////// ------------------------------------------------\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions/\n    return abs(sdf) - thickness;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n////// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// ------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtl3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1074, 1074, 1117, 1117, 1493], [1495, 1495, 1516, 1516, 1694], [1696, 1696, 1751, 1758, 2603]], "test": "untested"}
{"id": "DtX3Dl", "name": "Is Inside Triangle?", "author": "raymarchingenthusiast", "description": "Detects if a point is in a triangle.", "tags": ["triangles"], "likes": 1, "viewed": 193, "published": 3, "date": "1672622900", "time_retrieved": "2024-07-30T18:18:24.086590", "image_code": "struct Vert {\n    vec3 col;\n};\n\nstruct Triangle2 {\n    vec2 a;\n    vec2 b;\n    vec2 c;\n};\n\nstruct Triangle3 {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec2 CalcUv(vec2 p, Triangle2 tp, Triangle2 tuv) {\n    float w1p1 = (tp.b.y-tp.c.y)*(p.x-tp.c.x)+(tp.c.x-tp.b.x)*(p.y-tp.c.y);\n    float w1p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w1 = w1p1/w1p2;\n    \n    float w2p1 = (tp.c.y-tp.a.y)*(p.x-tp.c.x)+(tp.a.x-tp.c.x)*(p.y-tp.c.y);\n    float w2p2 = (tp.b.y-tp.c.y)*(tp.a.x-tp.c.x)+(tp.c.x-tp.b.x)*(tp.a.y-tp.c.y);\n    float w2 = w2p1/w2p2;\n    \n    float w3 = 1. - w1 - w2;\n    \n    return w1*tuv.a + w2*tuv.b + w3*tuv.c;\n}\n\nfloat area(Triangle2 tri) {\n    return (tri.a.x*(tri.b.y-tri.c.y) + tri.b.x*(tri.c.y-tri.a.y) + tri.c.x*(tri.a.y-tri.b.y))/2.;\n}\n\n/*bool isInside(vec2 p, Triangle2 tri) {\n    float abc = area(tri);\n    float pab = area(Triangle2(p,tri.a,tri.b));\n    float pac = area(Triangle2(p,tri.a,tri.c));\n    float pbc = area(Triangle2(p,tri.b,tri.c));\n    return abs(abc - (pab + pac + pbc)) < .0001;\n}*/\n\nbool isInside(vec2 p, Triangle2 tri) {\n    float s = (tri.a.x-tri.c.x)*(p.y-tri.c.y)-(tri.a.y-tri.c.y)*(p.x-tri.c.x);\n    float t = (tri.b.x-tri.a.x)*(p.y-tri.a.y)-(tri.b.y-tri.a.y)*(p.x-tri.a.x);\n    \n    if((s<0.) != (t<0.) && s != 0. && t  != 0.) return false;\n    \n    float d = (tri.c.x-tri.b.x) * (p.y - tri.b.y) - (tri.c.y - tri.b.y) * (p.x - tri.b.x);\n    return d == 0. || (d<0.) == (s+t <= 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + (iMouse.xy-iResolution.xy/2.)) / iResolution.xy;\n    if(iMouse.xy == vec2(0.)) uv = fragCoord / iResolution.xy;\n    Triangle2 ts[2];\n    Triangle2 uvs[2];\n    \n    ts[0] = Triangle2(vec2(0.,0.),vec2(0.,1.),vec2(1.,0.));\n    uvs[0] = Triangle2(vec2(0.,0.),vec2(0.,1.),vec2(1.,0.));\n    ts[1] = Triangle2(vec2(1.,0.),vec2(1.,1.),vec2(0.,1.));\n    uvs[1] = Triangle2(vec2(1.,0.),vec2(1.,1.),vec2(0.,1.));\n    \n    fragColor = vec4(0.,0.,.3,1.);\n    for(int i = 0; i < ts.length(); i++) {\n        if(isInside(uv,ts[i])) {\n            vec2 textureUv = CalcUv(uv,ts[i],uvs[i]);\n            \n            vec3 col = texture(iChannel0,textureUv).xyz;\n        \n            fragColor = vec4(col,1.);\n            if(textureUv.x>1.||textureUv.x<0.||textureUv.y>1.||textureUv.y<0.) fragColor = vec4(.15,.15,3.,1.);\n        }\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtX3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 200, 200, 657], [659, 659, 686, 686, 787], [1055, 1055, 1093, 1093, 1461], [1463, 1463, 1520, 1520, 2366]], "test": "untested"}
{"id": "mtfGWX", "name": "Celtic Knotwork WFC", "author": "fenix", "description": "Wave function collapse-like shader of an Celtic knot pattern. The blurry tiles show all the remaining possible matches given the existing neighbors, superimposed.\n\n*mouse camera*\n*key up/down zoom* \n*space to reset sim*\n*shift-space also resume attract*", "tags": ["knot", "celtic", "wfc", "wavefunctioncollapse"], "likes": 29, "viewed": 324, "published": 3, "date": "1672620823", "time_retrieved": "2024-07-30T18:18:25.138777", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in my series trying to do something similar to the \"simple tiled model\" of \n//  Wave Function Collapse:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC      https://shadertoy.com/view/mdjSDz\n//      Superposition Weave WFC           https://shadertoy.com/view/Ds2XRV\n//\n//  For this shader I abandoned the sprite rendering in favor of SDFs, so I could get\n//  higher resolution tiles. I was inspired by Ben Griffin's Knot project and typeface:\n//\n//      https://github.com/MrBenGriffin/Knot\n//      https://fontlibrary.org/en/font/knots\n//\n//  Of course his patterns are cooler than mine are, so far. I'd like to add the dragon\n//  heads and tails, but I'm afraid of the number of tile types exploding. Tune in to\n//  the next shader to find out if I succeed!\n//  \n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 BACKGROUND = vec3(.1, 0, 0);\nconst vec3 LINES = vec3(.4, .4, 0);\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// cell distance functions\nvec3 spEmpty(vec2 p)\n{\n    return BACKGROUND;\n}\n\nfloat sdIStSt(vec2 p)\n{\n    return min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.5)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.5)));\n\n    return dist;\n}\n\nfloat sdEndCorner(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdEndFoot(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 1), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.5), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6.5, 6), vec2(1.5, 1)));\n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(4, 2), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    \n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    return dist;\n}\n\nvec3 spCell(vec2 p, int type, float zoom)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)           dist = sdIStSt(p);\n    else if (type == I_ST_CR)      dist = sdIStCr(p);\n    else if (type == I_CR_CR)      dist = sdICrCr(p);\n    else if (type == END_CR)       dist = sdEndCorner(p);\n    else if (type == END_FOOT)     dist = sdEndFoot(p);\n    else if (type == CORNER_ST_ST) dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST) dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR) dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR) dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)   dist = sdTStCrSt(p);\n    \n    return vec3(mix(LINES, BACKGROUND, smoothstep(0., zoom * 10., dist)));\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nvec4 render( vec2 u, fxState state, float zoom )\n{\n    u = (u - .5 * iResolution.xy) * zoom + state.center * iResolution.y + .5 * iResolution.xy;\n    vec2 p = fract(u) * 8.;\n    \n    if (u.x < 1. ||\n        u.x >= iResolution.x - 1. ||\n        u.y < 1. ||\n        u.y >= iResolution.y - 1.) return vec4(spEmpty(p), 1);\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel0, ivec2(u), 0));\n    if (valid == uvec4(0)) return vec4(spEmpty(p), 1);\n    \n    vec4 c = vec4(0);\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += vec4(spCell(rot90(p,rot), type, zoom), 1);\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / c.a;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    if (state.zoomFade > 0.)\n    {\n        vec4 c = render(u, state, state.zoom);\n        vec4 n = render(u, state, state.nextZoom);\n        O = mix(n, c, state.zoomFade);\n    }\n    else\n        O = render(u, state, state.zoom);\n        \n    O = sqrt(O);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst float PI = 3.141592653589793;\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_FOOT = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\nconst int NUM_TILES = 11;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    vec2 center;\n    float resolution;\n    float zoom;\n    float nextZoom;\n    float zoomFade;\n    float time;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.center = data0.xy;\n    state.resolution = data0.z;\n    state.attract = data0.w != 0.;\n    state.zoom = data1.x;\n    state.time = data1.y;\n    state.nextZoom = data1.z;\n    state.zoomFade = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.center, state.resolution, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.zoom, state.time, state.nextZoom, state.zoomFade);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_FOOT =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_FOOT)       return S_END_FOOT;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    /*if (type == T_ST_CR_ST)*/ return S_T_ST_CR_ST;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .1;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return .1;\n    if (type == END_CR)         return .1;\n    if (type == END_FOOT)       return .1;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    /*if (type == T_ST_CR_ST)*/ return .1;\n\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0 ||\n        state.resolution < 0. ||\n        ifc.x == 0 || // establish boundary so we don't have to check during simulation\n        ifc.x == int(iResolution.x) - 1 ||\n        ifc.y == 0 ||\n        ifc.y == int(iResolution.y) - 1)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.280, .652))) fragColor = ubtf(uvec4(2, 0, 0, 0));\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-5)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    const float START_ZOOM = 1./256.;\n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) && keyDown(KEY_SHIFT) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.center = vec2(0);\n        state.resolution = -iResolution.x * iResolution.y;\n        state.nextZoom = state.zoom = START_ZOOM * 1000. / iResolution.y;\n        state.time = 0.;\n        state.zoomFade = 0.;\n        state.attract = true;\n        \n        fragColor = fxPutState(state, ifc);\n\n        return;\n    }\n\n    state.resolution = abs(state.resolution);\n    state.time += iTimeDelta;\n    if (state.zoomFade > 0.)\n    {\n        state.zoomFade -= iTimeDelta;\n        if (state.zoomFade < 0.)\n        {\n            state.zoomFade = 0.;\n            state.zoom = state.nextZoom;\n        }\n    }\n\n    if (iMouse.z > 0.)\n    {\n        state.attract = false;\n        state.center = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n    }\n\n    if (keyClick(KEY_UP))\n    {\n        state.nextZoom = min(state.nextZoom, state.zoom) * .5;\n        state.zoomFade = 1.;\n        state.attract = false;\n    }\n    if (keyClick(KEY_DOWN))\n    {\n        state.nextZoom = max(state.nextZoom, state.zoom) * 2.;\n        state.nextZoom = min(1., state.nextZoom);\n        state.zoomFade = 1.;\n        state.attract = false;\n    }\n\n    if (state.attract)\n    {\n        state.center = .42*vec2(sin(state.time/iResolution.y - 1.2), cos(state.time/iResolution.y - 1.2));\n        float zoom = pow(.5, floor(3. - mod(state.time / 4., 3.))) * 4. * START_ZOOM * 1000. / iResolution.y;\n        if (zoom != state.zoom && zoom != state.nextZoom)\n        {\n            state.nextZoom = zoom;\n            state.zoomFade = 1.;\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1627, 1679, 1716, 1716, 1796], [1798, 1798, 1859, 1906, 2040], [2042, 2042, 2064, 2064, 2144], [2146, 2173, 2195, 2195, 2220], [2222, 2222, 2245, 2245, 2298], [2392, 2392, 2415, 2415, 2847], [2849, 2849, 2872, 2872, 3034], [3036, 3036, 3059, 3059, 3719], [3721, 3721, 3748, 3748, 3967], [3969, 3969, 3994, 3994, 4252], [4254, 4254, 4282, 4282, 4532], [4534, 4534, 4562, 4562, 5227], [5229, 5229, 5257, 5257, 5927], [5929, 5929, 5957, 5957, 6874], [6876, 6876, 6901, 6901, 7561], [7563, 7563, 7606, 7606, 8283], [8285, 8285, 8312, 8312, 8459], [8461, 8461, 8511, 8511, 9289], [9291, 9291, 9329, 9329, 9620]], "test": "untested"}
{"id": "ctXGWX", "name": "Kurdish Flag Coral", "author": "fragcula", "description": "Draws the rotating Kurdish flag with a coral shaped sun.", "tags": ["flag", "branchless"], "likes": 0, "viewed": 135, "published": 3, "date": "1672615345", "time_retrieved": "2024-07-30T18:18:26.066297", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = -iTime * 0.5;\n    vec2 pxl = fragCoord.xy/iResolution.xy;\n\n    vec3 colour = vec3(0.);\n    mat2 scale = mat2(iResolution.x/iResolution.y, 0., 0., 1.);\n    vec2 q = scale * (pxl - vec2(0.4 * iResolution.y/iResolution.x, 0.));\n    if (pow(q.x - 0.5 , 2.) + pow(q.y - 0.5, 2.) < 0.25) { \n        q -= vec2(0.5, 0.5);\n        q *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n        q += vec2(0.5, 0.5);\n\n        vec3 red    = vec3(0.929, 0.125, 0.141);\n        vec3 green  = vec3(0.153, 0.557, 0.263);\n        vec3 yellow = vec3(0.996, 0.741, 0.067);\n        vec3 white  = vec3(1.0, 1.0, 1.0);\n\n        vec2 centre = vec2(0.5, 0.5);\n\n        vec2 qxl = q - centre;\n\n        float r = 0.2 + 0.05 * cos(atan(qxl.y, qxl.x) * 21.0 + iTime)+ 0.05 * cos(atan(qxl.y, qxl.x) * 10.0 - iTime);\n        float star = smoothstep(r+0.05, r+0.06, length(qxl));\n\n\n        if(pxl.y > (2./3.))\n            colour = (star < 0.001)? yellow : red;\n        else if (pxl.y < (1./3.))\n            colour = (star < 0.001)? yellow : green;\n        else\n            colour = (star < 0.001)? yellow : white;\n    }\n    \n    fragColor = vec4(colour, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1216]], "test": "untested"}
{"id": "mls3D2", "name": "Kurdish Flag Beating", "author": "fragcula", "description": "Draws the Kurdish flag with a beating sun", "tags": ["flag"], "likes": 2, "viewed": 101, "published": 3, "date": "1672615314", "time_retrieved": "2024-07-30T18:18:26.829257", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxl = fragCoord.xy/iResolution.xy;\n    vec3 red    = vec3(0.929, 0.125, 0.141);\n    vec3 green  = vec3(0.153, 0.557, 0.263);\n    vec3 yellow = vec3(0.996, 0.741, 0.067);\n    vec3 white  = vec3(1.0, 1.0, 1.0);\n    \n    vec2 centre = vec2(0.5, 0.5);\n    \n    vec2 qxl = pxl - centre;\n    \n    float r = 0.2 + 0.05 * cos(atan(qxl.y, qxl.x) * 21.0 + iTime)+ 0.05 * cos(atan(qxl.y, qxl.x) * 21.0 - iTime);\n    float star = smoothstep(r + 0.05, r+0.06, length(qxl));\n    \n    vec3 colour;\n    \n    if(pxl.y > 0.666)\n        colour = (star < 0.001)? yellow : red;\n    else if (pxl.y < 0.333)\n        colour = (star < 0.001)? yellow : green;\n    else\n        colour = (star < 0.001)? yellow : white;\n    \n    fragColor = vec4(colour, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mls3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 805]], "test": "untested"}
{"id": "dls3D2", "name": "Animated Kurdish Flag", "author": "fragcula", "description": "Draws an animated Kurdish flag", "tags": ["flag"], "likes": 1, "viewed": 79, "published": 3, "date": "1672615220", "time_retrieved": "2024-07-30T18:18:27.766750", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxl = fragCoord.xy/iResolution.xy;\n    vec3 red    = vec3(0.929, 0.125, 0.141);\n    vec3 green  = vec3(0.153, 0.557, 0.263);\n    vec3 yellow = vec3(0.996, 0.741, 0.067);\n    vec3 white  = vec3(1.0, 1.0, 1.0);\n    \n    vec2 centre = vec2(0.5, 0.5);\n    \n    vec2 qxl = pxl - centre;\n    \n    float r = 0.2 + 0.05 * cos(atan(qxl.y, qxl.x) * 21.0 + iTime * 15.0);\n    float star = smoothstep(r, r+0.001, length(qxl));\n    \n    vec3 colour;\n    \n    // Branchless version of https://www.shadertoy.com/view/mls3D2\n    int h = 1 << int(pxl.y * 3.0);\n    colour = red * float((h & 4)>>2) + white * float((h & 2)>>1) + green * float((h & 1));\n    colour = (1.0 - star)*yellow + star*colour;\n    \n    fragColor = vec4(colour, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dls3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 796]], "test": "untested"}
{"id": "dlsGDf", "name": "Matrix maelstrom", "author": "mrange", "description": "CC0 : Matrix maelstrom\nCode is a bit of a mess, lots of hacking without thought and some lingering alias effects\nStill... want to get something out before bed.", "tags": ["2d", "matrix"], "likes": 47, "viewed": 602, "published": 3, "date": "1672608140", "time_retrieved": "2024-07-30T18:18:28.535694", "image_code": "// CC0 : Matrix maelstrom\n//  Code is a bit of a mess, lots of hacking without thought and some lingering alias effects\n//  Still... want to get something out before bed.\n\n//#define CURSOR\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3  bcol        = vec3(0., 1.0, 0.25)*0.8;\n\nconst float logo_radius = 0.25;\nconst float logo_off    = 0.25;\nconst float logo_width  = 0.10;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\nvoid spiralMod(inout vec2 p, float a) {\n  vec2 op     = p;\n  float b     = a/TAU;\n  float  rr   = length(op);\n  float  aa   = atan(op.y, op.x);\n  rr         -= aa*b;\n  float nn    = mod1(rr, a);\n  float sa    = aa + TAU*nn;\n  float sl    = spiralLength(b, sa);\n  p           = vec2(sl, rr);\n}\n\nfloat dsegmentx(vec2 p, vec2 dim) {\n  p.x = abs(p.x);\n  float o = 0.5*max(dim.x-dim.y, 0.0);\n  if (p.x < o) {\n    return abs(p.y) - dim.y;\n  }\n  return length(p-vec2(o, 0.0))-dim.y;\n}\n\nvec3 digit(vec3 col, vec2 p, vec3 acol, vec3 icol, float aa, float n, float t) {\n  const int[16] digits = int[16](\n    0x7D // 0\n  , 0x50 // 1\n  , 0x4F // 2\n  , 0x57 // 3\n  , 0x72 // 4\n  , 0x37 // 5\n  , 0x3F // 2\n  , 0x51 // 7\n  , 0x7F // 8\n  , 0x77 // 9\n  , 0x7B // A\n  , 0x3E // B\n  , 0x2D // C\n  , 0x5E // D\n  , 0x2F // E\n  , 0x2B // F\n  ); \n  const vec2 dim = vec2(0.75, 0.075);\n  const float eps = 0.1;\n  vec2 ap = abs(p);\n  if (ap.x > (0.5+dim.y+eps)) return col;\n  if (ap.y > (1.0+dim.y+eps)) return col;\n  float m = mod(floor(n), 16.0);\n  int digit = digits[int(m)];\n\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n\n  vec2 p0 = p;\n  p0.y -= 0.5;\n  p0.y = p0.y-0.5;\n  float n0 = round(p0.y);\n  p0.y -= n0;\n  float d0 = dsegmentx(p0, dim);\n\n  vec2 p1 = p;\n  vec2 n1 = sign(p1); \n  p1 = abs(p1);\n  p1 -= 0.5;\n  p1 = p1.yx;\n  float d1 = dsegmentx(p1, dim);\n  \n  vec2 p2 = p;\n  p2.y = abs(p.y);\n  p2.y -= 0.5;\n  p2 = abs(p2);\n  float d2 = dot(normalize(vec2(1.0, -1.0)), p2);\n\n  float d = d0;\n  d = min(d, d1);\n\n  float sx = 0.5*(n1.x+1.0) + (n1.y+1.0);\n  float sy = -n0;\n  float s  = d2 > 0.0 ? (3.0+sx) : sy;\n  // Praying bit shift operations aren't TOO slow\n  vec3 scol = ((digit & (1 << int(s))) == 0) ? icol : acol;  \n\n  col = mix(col, scol, smoothstep(aa, -aa, d)*t);\n  return col;\n}\nvec3 digit(vec3 col, vec2 p, vec3 acol, vec3 icol, float n, float t) {\n  vec2 aa2 = fwidth(p);\n  float aa = max(aa2.x, aa2.y);\n  return digit(col, p, acol, icol, aa, n, t);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash2(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(vec2 p, float aa) {\n  vec2  p1 = p-vec2(logo_off, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = atan_approx(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_off, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = atan_approx(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 clogo(vec2 p, float aa, out float d) {\n  const mat2 rot0 = ROT(PI/4.0);\n  const mat2 rot1 = ROT(5.0*PI/4.0);\n\n//#define SINGLE8\n\n  float sgn = sign(p.y);\n#if !defined(SINGLE8)\n  p *= sgn;\n#endif\n  vec4 s0 = figure_8(p, aa);\n  vec4 s1 = figure_8(p*rot0, aa);\n  vec4 s2 = figure_8(p-vec2(-0.5, 0.0), aa);\n  vec4 s3 = figure_8(p*rot1, aa);\n  \n  // This is very hackish to get it to look reasonable\n  \n  const float off = -PI;\n  s1.z -= off;\n  s3.z -= off;\n  \n  vec4 s = s0;\n#if !defined(SINGLE8)\n  s = merge(s, s1);\n  s = merge(s, s2);\n  s = merge(s, s3);\n#endif\n\n  d = s.w;\n  return vec4(mix(0.025*bcol, bcol, s.x), s.y);\n}\n\nvec3 logoEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  float d;\n  vec4 ccol = clogo(p, aa, d);\n\n  const float period = TAU*10.0;\n  float ss = sin(period*d-TIME*TAU/10.0);\n  const float off = 0.2;\n  float doff = period*aa*cos(off); \n//  col = mix(col, col*0.125, smoothstep(doff, -doff, abs(ss)-off));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvec3 spiralEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  vec2 sp = p;\n  spiralMod(sp, .5);\n\n  vec2 dp = sp;\n  float dz = 0.0125;\n  dp /= dz;\n  aa /= dz;\n  float dny = mod1(dp.y, 3.06);\n  float dhy = hash(dny+1234.5);\n  dp.x = -dp.x;\n  float ltm = (TIME+1234.5)*mix(2.0, 10.0, (dhy))*0.125;\n  dp.x -= ltm;\n  float opx = dp.x;\n  float dnx = mod1(dp.x, 1.5);\n  const float stepfx = 0.125*0.25;\n  float fx  = -2.0*stepfx*ltm+stepfx*dnx;\n  float fnx = floor(fx);\n  float ffx = fract(fx);\n  float dht = hash(fnx);\n  float dhx = hash(dnx);\n  float dh  = fract(dht+dhx+dhy);\n  \n  float l = length(p);\n  float t = smoothstep(0.4, 0.5, l);\n\n  const vec3 hcol = clamp(1.5*sqrt(bcol)+vec3(0.2), 0.0, 1.0);\n  const vec3 acol = bcol;\n  const vec3 icol = acol*0.1;\n  \n  float fo = (smoothstep(0.0, 1.0, ffx));\n  float ff = smoothstep(1.0-2.0*sqrt(stepfx), 1.0, ffx*ffx);\n  col = digit(col, dp, mix(acol, hcol, ff), icol, aa, 100.0*dh, fo*t);\n\n#if defined(CURSOR)\n  float fc = smoothstep(1.0-stepfx, 1.0, ffx);\n  const float rb = 0.2;\n\n  float db = box(dp, vec2(0.5, 1.0))-rb;\n  \n  col = mix(col, mix(col, hcol, 0.33*fc*fc), smoothstep(aa, -aa, db)*t);\n#endif\n\n  return col;\n}\n\nvec3 glowEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  float d = length(p);\n  col += 0.25*bcol*exp(-9.0*max(d-2.0/3.0, 0.0));\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col  = vec3(0.0);\n  col = spiralEffect(col, p, pp, aa);\n  col = glowEffect(col,p, pp, aa);\n  col = logoEffect(col, p*ROT(-0.05*TIME), pp, aa);\n  col *= smoothstep(1.25, 0.5, length(pp));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[556, 642, 679, 679, 786], [788, 874, 913, 913, 1038], [1040, 1040, 1078, 1132, 1189], [1191, 1191, 1230, 1230, 1483], [1485, 1485, 1520, 1520, 1668], [2960, 2960, 3030, 3030, 3134], [3136, 3196, 3218, 3218, 3266], [3268, 3328, 3350, 3350, 3420], [3422, 3508, 3544, 3544, 3638], [3640, 3758, 3785, 3785, 3861], [3863, 3863, 3894, 3894, 3920], [3922, 3922, 3946, 3946, 4045], [4047, 4047, 4077, 4077, 4315], [4317, 4317, 4350, 4350, 4892], [4894, 4894, 4937, 4937, 5520], [5522, 5522, 5576, 5576, 5876], [5878, 5878, 5934, 5934, 7040], [7042, 7042, 7096, 7096, 7185], [7187, 7187, 7217, 7217, 7477], [7479, 7479, 7534, 7534, 7709]], "test": "untested"}
{"id": "mtlGDf", "name": "Genuary1 - perfect lada loop", "author": "flockaroo", "description": "some genuary loop doodling...", "tags": ["loop", "cars", "lada", "genuary"], "likes": 50, "viewed": 774, "published": 3, "date": "1672606176", "time_retrieved": "2024-07-30T18:18:29.558959", "image_code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  lada taigaperfect loop - genuary1\n//\n\n#define LOOPING\n\n#define RandTex iChannel2\n \n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\n//#define ENABLE_MATERIALS \n#ifdef ENABLE_MATERIALS\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n#else\n#define SET_PREV_MAT(x) \n#endif\n\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.243*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n    float ang0 = atan(p.y,p.x);\n\n    float d=1000.,d2,d3;\n    float dmain=length(p.xy)-r-sh;\n    float dplane=-p.z+w*.5;\n    d=-smin_(dplane,-dmain,.005);\n    \n    d2=-smin_(-(dmain+.005),-(dplane-.005),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=-smin_(-(dmain+.02),-(dplane-.045),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=dmain+.04;\n    d=-smin_(-d,d2,.01);\n    \n    dplane=-p0.z+w*.5;\n    d2=-smin_(-(dmain+.04),dplane+.015,.1);\n    float c5=cos(ang0*5.);\n    c5=-c5*.5+.5;\n    c5*=c5;\n    c5*=c5;\n    c5=1.-c5;\n    c5=mix(c5,0.,1.-clamp(((dmain+r+sh)-.045)/.03,0.,1.));\n    d3=-smin_(-(dmain+.115),-(dplane-.01*(.8+.5*c5)),.04);\n    d2=abs(-smin_(-d2,d3,.01))-.0015;\n    d2=max(d2,-p0.z-.01);\n    d=min(d,d2);\n    \n    float mang,ang;\n    float dang;\n\n    // rim holes\n    dang=PI2/12.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    d=max(d,-distCyl(p-vec3(r*.65*cs*(1.+3.*p.z),0.),.085*r,w*1.5));\n    \n    p=p0-vec3(0,0,.07);\n    \n    // screw holes\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    d2=distCyl(p-vec3(r*.3*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.045-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define enable_glass true\n\nvec3 Delta=vec3(-.769,-1.073,-.669);\n\n#define LoopNumFrames 240\n\nfloat distCar(vec3 p)   \n{\n    p+=Delta;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),.023));\n    float d=100000.,d2;\n    vec3 p00=p;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    vec3 psq=p*p;\n\n    #ifdef ENABLE_MATERIALS \n    float d_mat=1001., mat=-1.;\n    #endif\n    SET_PREV_MAT(BG);\n    \n    vec3 frontWheelPos=vec3(1.44*.5,1.25,-.45);\n    vec3 rearWheelPos=vec3(1.42*.5,-1.05,-.5);\n    \n    //d=min(d,distBox(p-vec3(0,0,-.05),vec3(1.65,3.45,.7)*.5));\n    //d=min(d,distBox(p-vec3(0,-.5,.55),vec3(1.65,2.4,.55)*.5));\n    bool front = p0.y>0.; \n    vec3 pwheel = front?frontWheelPos:rearWheelPos;\n    // -- 15 ----- wheel cases (precalc) ------------\n    float dWheelcases=distCylR((p-pwheel+vec3(0,0,-.1-(front?-.018:.0))).zyx,.4,.7,.1);\n    \n    float wcext=.01+(p.z+.5)*.1;\n\n    // -- 0 ---------- main box -------------\n    d=min(d,\n          distBoxR(p-vec3(0,0,.2),\n                   vec3(1.63-(psq.y*psq.y*.1+1.)*psq.y*.01-psq.z*.521-smoothstep(0.25,0.35,p.z)*(p.z-.25)*.0\n                        +wcext*(1.-smoothstep(wcext*.3,wcext,dWheelcases))\n//                        +wcext*exp(-dWheelcases*dWheelcases/wcext/wcext)\n                        ,\n                        3.6- min(psq.z*psq.z*20.*step(0.,p.y),.1) - (psq.z+psq.x)*.1  -step(0.,-p.y)*smoothstep(0.,.2,p.z)*max(p.z-.2,0.)*1.1,\n                        1.3-psq.y*psq.y*psq.y*.015*(.5+.5*step(0.,-p.z))-step(0.,p.z)*(psq.x*.2+psq.y*.035+p.y*.04))*.5,\n                        .03-min(p.y*.03,0.)));\n    float dmainBox=d;\n    \n    // -- 1 ---------- hood/windshield cut -------------\n    float dwin =dot(p-vec3(0,1.5-psq.x*(.3-(p.z-.8)*.4),0.7)*.5,normalize(vec3(0,1.,1)));\n    float dhood=dot(p-vec3(0,1.5-psq.x*(2.-(p.y-.75)*1.),0.74-.1*(p.y-.75)*(p.y-.75))*.5,normalize(vec3(0,.07,1)));\n    //dwin=10000.;\n    d=-smin_(-d,-smin_(dwin,dhood,.03),max(.001,.05-.0*(p.y*.01)));\n    //d=-min(-d,-min(dwin,dhood));\n\n    float dwin2 =dot(p-vec3(0,1.64-psq.x*.3,0.7)*.5,normalize(vec3(0,1.5,1)));\n    float dhood2=dot(p-vec3(0,1.5,0.36)*.5,normalize(vec3(0,.04,1)));\n    d2=-min(-d,-min(dwin2,dhood2));\n    d+=exp(-abs(d2)/.006)*.006;\n    \n    p=p-vec3(0,0,-.01*psq.y);\n\n    // -------- absatz hood ---------------    \n    d2=distBoxR(p-vec3(0.,1.37,.3),vec3(.9,1,.5)*.5,.07);\n    d+=.015*(1.-smoothstep(-.015,.015,d2))*clamp(1.7-p0.y,0.,1.);\n    \n    // -- 2 ---------- side versenkung windows --------------\n    d2=distBoxR(p-vec3(.9-p.z*.2,0,.57),vec3(.1,3.25-p.z*.75,.59)*.5+.02,.15)-.02;\n    d=-smin_(-d,d2,.01);\n\n    SET_PREV_MAT(CARBODY);\n    \n    float dwincut=1000.;\n    // -- 3 ---------- side win rear -----------\n    p=p-vec3(0,-.88,.55);\n    d2=distBoxR(p,vec3(3.,.82-.8*(p.z)*step(0.,-p.y),.37)*.5,.063-p.y*.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n    dwincut=min(dwincut,d2);\n    p=p0;\n\n    // -- 4 ---------- side stripe --------------\n    d2=distBox(p-vec3(0,0,.16-.01*(p.y+.4)*(p.y+.4)),vec3(3.,3.3,.07)*.5);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.01)*.01;\n\n    // -- 5 ---------- door -------------\n    d2=distBoxR(p-vec3(0,.1,.235),vec3(3.,1.03,1.09)*.5,.07-.1*(p.z+.3));\n    d2=-smin_(-(dwin+.03),-d2,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n    SET_PREV_MAT(CARBODY);\n\n    // -- 6 ---------- side win front -----------\n    d2=-smin_(-d2-.05,p.z-.36,.03);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n    dwincut=min(dwincut,d2);\n    \n    // -- 7 ---------- front window -----------\n    p=p0-vec3(0,0,.53);\n    //d2=distBoxR(p,vec3(1.4,5.,.37)*.5,.05);\n    d2=dmainBox+.065-psq.x*.1*p.z;\n    d2=-smin(-d2,dhood-.015,.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.015)*.01;\n    dwincut=min(dwincut,d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // -- 8 ---------- rear window -----------\n    p=p0-vec3(0,-1.7,.5);\n    d2=distBoxR(p,vec3(1.15-p.z*.3,1.,.35)*.48,.07);\n    d+=smoothstep(0.,1.,-(d2-.03+.03*p.z)/.01)*.01;\n    SET_PREV_MAT(CARBODY);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    dwincut=min(dwincut,d2);\n    //d=max(d,-d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // ------- bottom absatz ------------\n    d2=p0.z+.345;\n    d+=.02*min(exp2(-d2/.02),1.);\n\n    // -- 15 ----- wheel cases (apply) ------------\n    d=-smin_(-d,dWheelcases,.005);\n    \n    SET_PREV_MAT(p0.z<-.345?GUMMI:CARBODY);\n\n    // ------------- cut out interior, cutout windows, add windows + window lips\n    float d_inner=d+.06;\n    d=max(d,-d_inner); SET_PREV_MAT(BLACKPLASTIC); \n    d=-smin_(-d,dwincut,.01);\n    SET_PREV_MAT(CARBODY); \n    d=min(d,length(vec2(dwincut,d_inner-.045))-.01);\n    SET_PREV_MAT(GUMMI); \n    d=min(d,length(vec2(dwincut,d_inner-.045)+vec2(1,-1)*.008)-.0025);\n    SET_PREV_MAT(CHROME); \n    if(enable_glass) { d=min(d,d_inner-.045); SET_PREV_MAT(GLASS); }\n    \n    // -- 9 ---------- rear door -----------\n    p=p0-vec3(0,-1.7,.25);\n    d2=distBoxR(p,vec3(1.35-psq.z*.35,.5+p0.z*.5,.97)*.5,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n\n    // -- 11 ---------- rear license plate box -----------\n    p=p0-vec3(0,-1.885,.04);\n    d2=distBoxR(p,vec3(.65+p.z*.3,.2,.2)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(CARBODY);\n    p=p0-vec3(0,-1.775,.14);\n    d2=distBoxR(p,vec3(.68,.05,.04)*.5,.005);\n    d=min(d,d2);\n\n    // -- 10 ---------- rear blinker -----------\n    p=p0-vec3(.68,-1.8,.0);\n    d2=distBoxR(p,vec3(.2-p.z*.2*step(0.,-p.x),.3,.3)*.5,.03);\n    d=min(d,d2);\n    d=max(d,dmainBox-.01);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d-=smoothstep(.007,.01,-d2)*.001;\n    SET_PREV_MAT(p.z<0.06?(p.x>0.0?(p.z>-.05?GLASS:ORANGEGLASS):REDGLASS):REDGLASS);\n    \n    // -- 12 ---------- front blinker -----------\n    p=p0-vec3(.6,1.75,.15);\n    d2=distBoxR(p,vec3(.25,.095,.12)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d=min(d,-smin_(-d2-.025,-p.y+.01,.01));\n    SET_PREV_MAT(p.x<0.03?ORANGEGLASS:GLASS);\n\n    // -- 13 ---------- grill -----------\n    p=p0-vec3(.0,1.78-psq.x*.05,-.05);\n    d2=distBoxR(p,vec3(1.48+.02-p.y*.3,.2,.265-psq.x*.03+.02-p.y*.3)*.5,.06-p.z*.15);\n    d=max(d,-d2);\n    // ----- einbuchtung rund um scheinwerfer -----\n    float d2b=-smin_(-d2,p.x-.48,.02);\n    vec2 pl=(p-vec3(.61,0,0)).xz; float lpl=length(pl);\n    float yo=mix(.02,max(-d2b-.016,0.)*.5,1.-exp2((-lpl+.1)/.0075));\n    d2=-smin_(-d2,-.1+lpl,.005);\n    d2=-smin_(-d2,-abs(p.y-.01)+.035-yo,.005);\n    // ----- cooling slits -----\n    vec3 pi=vec3(0,0,(clamp(floor(p.z/.029),-4.,3.)+.5)*.029);\n    d2=-smin_(-d2,distBox(p-pi,vec3(.96,.2,.02)*.5),.01);\n    // ----- lada logo -------\n    p.y-=.03;\n    d2=min(d2,distBoxR(p,vec3(.04+p.z*.1,.02,.07),.005));\n    d=min(d,d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n\n    // ----- scheinwerfer -----\n    float lsph=length(p-vec3(.61,-.273-.03,0));\n    d=min(d,max(max(lsph-.3,-p0.y+1.65),lpl-.09));\n    SET_PREV_MAT(CHROME);\n\n    // -- 14 ---------- bumpers -----------\n    p=p0; p.y=abs(p.y);\n    p=p-vec3(0,1.87-.03*psq.x,-.25);\n    d2=distBoxR(p,vec3(1.62,.1,.1)*.5,.02);\n    d=min(d,d2);\n    SET_PREV_MAT(CHROME);\n    p-=vec3(.76-p.y*.15,-.065,0);\n    d2=distBoxR(p,vec3(.113,.25,.113)*.5,.02);\n    d2=max(d2,dot(p,vec3(-1,-.4,0))-.03);\n    d=min(d,d2);\n    SET_PREV_MAT(GUMMI);\n    \n    // ------- wheels, axes ------------\n    //d=max(d,-distCylR((p-rearWheelPos+vec3(0,0,-.1)).zyx,.4,.7,.1));\n    // ------- axes ------\n    #if 0\n    p=(p0-pwheel*vec3(0,1,1));\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n\n    p=transformVecByQuat(p,axQuat);\n    p.z-=axOffs;\n#endif\n    d=min(d,distCylR(p.zyx,.12*(1.-.6*smoothstep(0.05,.2,p.x)),1.44,.05));\n    #endif\n    p=(p0-pwheel);\n\n    vec3 wo=vec3(0,0,0);\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    // wheel axis rot + offset\n    p=transformVecByQuat(p+wo,axQuat)-wo;\n    p.z-=axOffs;\n#endif\n    d=min(d,distCyl(p.zyx-vec3(0,0,-.72),.12*(1.-.6*smoothstep(0.05,.2,p.x+.72)),1.55));\n    SET_PREV_MAT(CHASSIS);\n#ifdef USE_SIMDATA\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*-SteerAng*(front?1.:0.));\n    p=transformVecByQuat(p+vec3(.1,0,0),q)-vec3(.1,0,0);\n    // wheel rotations\n    float rot=-WheelRot.x*.7;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n#define PROPER_WHEELS\n#ifndef PROPER_WHEELS\n    d=min(d,distCylR(p.zyx,.35,.2,.05));\n#else\n    // newer viva ...broader tires\n    p.yz*=ROTM(-float(iFrame)/float(LoopNumFrames)*PI2*3.); \n    d=min(d, distWheelDim(p.yzx,185.,75.,16.,12.,.2));\n    // old niva\n    //d=min(d, distWheelDim(p.yzx,175.,80.,16.,12.,.2));\n#endif\n    SET_PREV_MAT(length(p.yz)<.215?CHROME:GUMMI);\n    \n#ifdef ENABLE_MATERIALS \n    return vec2(d,mat);\n#else\n    return d;\n#endif\n}\n\n\n/*float dist(vec3 pos)\n{\n    float fact=pow(100.,fract(-float(iFrame)/float(LoopNumFrames)));\n    pos*=fact;\n    float R=2.,r=.01;\n    float d=100000.;\n    \n    d=min(d,distCar(pos));\n    d=min(d,distCar((pos+Delta*00.)/100.)*100.);\n    d=min(d,distCar((pos+Delta*0000.)/10000.)*10000.);\n    \n    return d/fact;\n}*/\n\n// iq's superb compile optimization - thanks a lot!!\nfloat dist(vec3 pos)\n{\n    float fact=pow(100.,fract(-float(iFrame)/float(LoopNumFrames)));\n    pos*=fact;\n    float R=2.,r=.01;\n    float d=100000.;\n    \n    for( int i=min(0,iFrame); i<3; i++ )\n    {\n        float sca = pow(100.0,float(i));\n        d=min(d,distCar((pos+Delta*00.)/sca)*sca);\n    }\n    \n    return d/fact;\n}\n\n/*vec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}*/\n\n// iq's superb compile optimization - thanks a lot!!\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec3 n = vec3(0.0);\n    for( int i=min(0,iFrame); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dist(p+eps*e);\n    }\n    return n;\n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.003;\n    for(int i=0;i<120;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.6;\n        if (d<eps) return 1.;\n    }\n    return 0.;\n}\n\n#define MOUSE_PHI   (iMouse.x/Res.x*12.)\n#define MOUSE_THETA (iMouse.y/Res.y*12.)\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    float tanFOVh=1./2.5;\n    dir=normalize(vec3(0,0,-1./tanFOVh)+vec3(sc,0));\n    pos=vec3(0,0,6.1);\n    #ifdef LOOPING\n    pos.xy*=ROTM(-1.057-float(iFrame)/float(LoopNumFrames)*PI2);\n    dir.xy*=ROTM(-1.057-float(iFrame)/float(LoopNumFrames)*PI2);\n    #endif\n    float ph = MOUSE_PHI;\n    float th = MOUSE_THETA;\n    if (iMouse.x<1.) { \n        ph=3.6;\n        #ifdef LOOPING\n        ph=4.;\n        #endif\n        th=1.3;\n    }\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\nvec4 ovlCol( vec2 fragCoord )\n{\n    vec4 col=vec4(0);\n    vec2 sc=(fragCoord-iResolution.xy*.5)/iResolution.x;\n    float m2sc=.205;\n    \n    float ph04=fract(MOUSE_PHI/PI*2.*.25)*4.;\n    float backFact =max(clamp(-3.+ph04,0.,1.),clamp(1.-ph04,0.,1.));\n    float sideFact =min(clamp( 0.+ph04,0.,1.),clamp(2.-ph04,0.,1.));\n    float frontFact=min(clamp(-1.+ph04,0.,1.),clamp(3.-ph04,0.,1.));\n    float sideFact2=min(clamp(-2.+ph04,0.,1.),clamp(4.-ph04,0.,1.));\n    sideFact=max(sideFact,sideFact2);\n    float scFact=sideFact2>0.?1.:-1.;\n    col+=sideFact *texture(iChannel0,(ROTM(.023*scFact)*sc*vec2(scFact,1))/Res0*556.+.5+vec2(-.033,.1));\n    col+=frontFact*texture(iChannel1,sc/Res1*556.+.5+vec2(-.252,.1));\n    col+=backFact *texture(iChannel1,sc/Res1*556.+.5+vec2(.26,.1));\n    col.xyz-=exp(-sc.x*sc.x/.001/.001);\n    col.xyz-=exp(-sc.y*sc.y/.001/.001);\n    vec2 sinsc=sin(sc/m2sc*2.*PI);\n    col.yz-=.3*exp(-sinsc.x*sinsc.x/.03/.03);\n    col.yz-=.3*exp(-sinsc.y*sinsc.y/.03/.03);\n    col.xz-=exp(-(sc.x-3.74*.5*m2sc)*(sc.x-3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.x+3.74*.5*m2sc)*(sc.x+3.74*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y-1.64*.5*m2sc)*(sc.y-1.64*.5*m2sc)/.001/.001);\n    col.xz-=exp(-(sc.y+1.64*.5*m2sc)*(sc.y+1.64*.5*m2sc)/.001/.001);\n    return col;\n}\n\nuniform float ovlFade;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ovl=ovlCol( fragCoord );\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    float m=march(pos,dir); //m=1.;\n    vec3 left=normalize(cross(vec3(0,0,1),dir));\n    vec3 up  =normalize(cross(left,dir));\n    vec3 g=getGrad(pos,.0003);\n\n    float lg=length(g);\n    vec3 n=g/(lg+.000001);\n    \n    float ao=1.;\n    float sc=1.7,scmin=.01;\n    float df=dist(pos+n*scmin*.2)/(scmin*.2);\n    for(int i=0;i<30;i++)\n    {\n        float ao2=clamp(dist(pos+n*sc)/(sc/df),0.,1.);\n        ao*=mix(ao2,1.,\n        1.-sqrt(sc)*.2\n        );\n        sc*=.7;\n        if(sc<scmin) break;\n    }\n    ao*=m*.5+.5;\n    \n    fragColor.xyz=(n*.15+.85);\n    \n    vec3 R=reflect(dir,n);\n    vec4 refl=myenv(vec3(0),R,1.);\n    float fres=1.-abs(dot(R,n));\n    fres*=fres*fres;\n    fres=.1+.7*fres;\n    fragColor=mix(fragColor,refl*(ao*.35+.65),fres);\n    \n    fragColor.xyz*=ao;\n    fragColor=mix(clamp(fragColor,0.,1.),ovl,ovlFade);\n    \n    fragColor.w=1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "mtsGDX", "name": "Glacing Blow", "author": "fragcula", "description": "Moving grids of various colours, can be rotated", "tags": ["rainbow"], "likes": 2, "viewed": 123, "published": 3, "date": "1672598617", "time_retrieved": "2024-07-30T18:18:30.523380", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    float g_top = smoothstep(0.6, 1.0, uv.y);\n    float g_bot = smoothstep(0.4, 0.0, uv.y);\n    vec4 h_top = (mod((uv.x + iTime/10.0) * 100.0, 5.0) <= 0.1)? vec4(col,1.0) : vec4(0.0,0.0,0.0,1.0);\n    vec4 h_bot = (mod((uv.x - iTime/10.0) * 100.0, 5.0) <= 0.1)? vec4(col,1.0) : vec4(0.0,0.0,0.0,1.0);\n    vec4 v_top = (mod((uv.y + uv.x/10.0) * 100.0, 5.0) <= 0.1)? vec4(col,1.0) : vec4(0.0,0.0,0.0,1.0);\n    vec4 v_bot = (mod((uv.y + uv.x/10.0)* 100.0, 5.0) <= 0.1)? vec4(col,1.0) : vec4(0.0,0.0,0.0,1.0);\n    fragColor = g_top * (h_top + v_top) + g_bot * (h_bot + v_bot);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 835]], "test": "untested"}
{"id": "Dls3D2", "name": "Twisted Dodecahedron Star Ball", "author": "Shane", "description": "A twisted dodecahedral star ball.", "tags": ["sphere", "star", "ball", "icosahedron", "dodecahedron", "twist", "polyhedron", "pentagon", "weave"], "likes": 81, "viewed": 756, "published": 3, "date": "1672585032", "time_retrieved": "2024-07-30T18:18:31.587535", "image_code": "/*\n\n    Twisted Dodecahedron Star Ball\n    ------------------------------\n    \n    I'm not sure what you'd technically call this, but I've seen it referred\n    to as a twisted starball, so I'll call it that. From a geometric perspective,\n    it's a rendering of wavy twisted lines eminating from the pentagon face \n    centers of a dodecahedron to each of the five edges.\n    \n    I've mentioned before that I'd like to post more of the ornate polyhedral \n    objects that the geometric art crowd are fond of. Unfortunately, the lengthy \n    construction procedures don't lend themselves well to the pixelshader\n    environment -- due to the fact that we have to construct and render them\n    in a fraction of the time that it takes a Blender artist, for instance.\n    \n    My main objective was to get one of these on the board, rather than write\n    it in the most efficient way. Having said that, it seems to run resonably\n    well in windowed mode. The compile time is pretty mediocre, so I'll try to \n    get that down later.\n    \n    The construction procedure was pretty simple: Select the nearest pentagon \n    face, then render curved twisted lines from the centers to the edge midpoints.\n    Normally, that would involve 3D Bezier curves, but realtime pixelshader \n    constraints wouldn't allow for that, so I had to get inventive and take a\n    warped space approach. Thankfully, it worked. :)\n    \n    I've noticed that rendering things in spherical space isn't exactly a task \n    that a lot of coders like to undertake, and I understand that, but it's not \n    as bad as people would think. The line algorithms involve more cross products \n    and so forth, but other than that, they're roughly the same.\n  \n   \n\n\tOther examples:\n    \n    // There aren't a lot of similar examples on here. However TDHooper \n    // was doing this kind of thing before it was cool. :) Unfortunately,\n    // due to the style of rendering involved, I had to take a completely\n    // different approach.\n    Dodecahedron twist  - tdhooper\n    https://www.shadertoy.com/view/MlcGRf\n    \n    // A very stylish, beautifully rendered example. Fast too.\n    Sphere Gears - iq\n    https://www.shadertoy.com/view/tt2XzG\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Twist, or not. A regular star ball has curved lines without\n// the twist, which is neater, but not quite as interesting.\n#define TWIST\n\n// Curving the spiral arms.\n#define CURVE\n \n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    p.yz *= rot2(iTime/6./4. + 0.);\n    p.xz *= rot2(iTime/3./2.);\n    return p;\n    \n}\n\n\n// IQ's 3D box formular with rounding.\nfloat sBoxS(in vec3 p, in vec3 b, in float rf){\n  \n  vec3 d = abs(p) - b + rf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's 2D box formular with rounding.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n \n// Angle between 3D points.\nfloat angle(vec3 v1, vec3 v2){\n\n    return acos(dot(v1, v2)/(length(v1)*length(v2)));\n}\n\n \n//////////\n\n/*\n// Readjusting the points to the surface of the sphere in question. The function here\n// is the same as the one below, but that's not always the case.\nvec3 size(in vec3 p, in float rad){\n\n    //return p;\n    return normalize(p)*rad;\n}\n*/\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI (TAU*.5) // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n/*\n// A cartesian coordinate to spherical coordinate conversion.\nvec3 worldToSpherical(vec3 cartCoord){\n    \n    float r = length(cartCoord);\n    float ax = mod(atan(cartCoord.z, cartCoord.x), TAU); // Longitudinal coordinate.\n    float ay = mod(acos(cartCoord.y/r), PI);// Or atan(sphP.y, length(sphP.xz)); // Latitude. \n    return vec3(ax, ay, r);\n}\n*/\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n \n// Global pentagon center position.\nvec3 pentCntr = vec3(0);\n// Global pentagon latitudinal block ID.\nint pID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getDodecPent(inout vec3 q, inout vec3[5] gVertID, const float rad){\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n\n \n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = mod(atan(q.z, q.x) + vec4(PI/5., PI/5., 0, 0), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(0, 0, .5, .5))/scX*TAU, TAU);\n\n    // Latitudinal strip positions.\n    vec4 pLat = vec4(0, ang, PI - ang, PI);\n    \n    // Pentagon center.\n    //pentCntr = vec3(0);\n    \n    // Distance to pentagon center.\n    float dist = 1e5;\n \n    // Latitudinal strip ID.\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n        \n        // The spherical coordinates of the central vertex point for each pentagon.\n        vec3 sc = vec3(sph[i], pLat[i], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n        // Nearest pentagon distance.\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           // Update.\n           dist = vDist;\n           id = i;\n           pentCntr = sc;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n\n    // The five vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n   \n    vec3 vLat = vec3(cAng, 2.*mAng - cAng, PI - (2.*mAng - cAng));\n    if(id==0 || id ==3){\n        \n        // Top and bottom pentagons.\n        float xOff = PI/5.;\n        if(id==3){ vLat = PI - vLat; xOff = 0.; }\n\n        gVertID[0] = vec3(xOff, vLat.x, rad);\n        gVertID[1] = vec3(2.*PI/5. + xOff, vLat.x, rad);\n        gVertID[2] = vec3(4.*PI/5. + xOff, vLat.x, rad);\n        gVertID[3] = vec3(6.*PI/5. + xOff, vLat.x, rad);\n        gVertID[4] = vec3(8.*PI/5. + xOff, vLat.x, rad); \n    \n    \n    }\n    else{ \n        \n        // Middle latitudinal strip pentagons.\n        if(id==2){ vLat = PI - vLat; }\n        \n        vec3 ax3 = mod(vec3(ax + TAU - PI/5., ax + PI/5., ax), TAU);\n\n        // Clockwise.\n        gVertID[0] = vec3(ax3.x, vLat.y, rad);\n        gVertID[1] = vec3(ax3.x, vLat.x, rad);\n        gVertID[2] = vec3(ax3.y, vLat.x, rad);\n        gVertID[3] = vec3(ax3.y, vLat.y, rad);\n        gVertID[4] = vec3(ax3.z, vLat.z, rad);\n    }\n    \n\n \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id==0 || id==3) pentCntr.x = 0.;\n    \n    // Debug.\n    //cID = int(floor(ax/TAU*5.));\n    \n    /*\n    // Not needed here.\n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    */\n    \n    // Global pentagon latitudinal block ID.\n    pID = id;\n    \n    \n    return q;\n}\n///////////////////\n \n// A signed spherical line running between points \"a\" and \"b\"\n// (capped at \"b\"). I wrote it and appended a wave to it in a hurry,\n// but it seems to work.\nfloat sphereLineDistCapBWave(vec3 p, vec3 a, vec3 b, float ang){ \n     \n     //float ld = length(a - b);\n     //float lp = length(p);\n     \n     p = normalize(p); // Normalize p. // p /= rad; \n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     // Perpendicular vector running through point \"b\".\n     vec3 perpB = normalize(b + cross((a - b), b))*.5;\n     // Capping the line off at point \"b\".\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     #ifdef CURVE\n     // Using the perpendicular vector to add a sinusoidal wave to the line.\n     //ln -= sin(6.2831/ld*.25*.975*(ang))*.06;//(endB)*.95//*.975\n     ln -= sin(6.2831*2.*(endB) + 0.125)*.06;//(endB)*.95//*.975\n     //ln -= sin(6.2831*1.905*(endB))*.06;//(endB)*.95//*.975\n     #endif\n \n     // Return the signed distance. \n     return sign(ln)*max(abs(ln), endB);      \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n     // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 3.))) - 16.);\n     // Adding subtle perturbation to the plane.\n    p.z -= dot(sin(p.xy*1. - cos(p.yx*2.)), vec2(.05));\n    float wall = -p.z + 3.;\n    \n    \n////////////////    \n \n    // Dodecahedron vertices and vertex IDs for the current cell.\n    vec3[5] vP, vPID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the dodecahedron cell.\n    const float rad = .5;\n    vec3 lq = getDodecPent(q, vPID, rad);\n\n\n    // World vertex coordinates.\n    for(int i = 0; i<5; i++){\n        vP[i] = sphericalToWorld(vPID[i]);//vec3(0, rad, 0);\n    }\n\n\n    // Pentagon center cartesian coordinates.\n    vec3 vPCntr = sphericalToWorld(pentCntr);\n\n    \n    // Central curve and trimming curve.\n    float crv = 1e5, crv2 = 1e5;\n\n    \n    //float pDir = ((pID&1)==0)? 1. : -1.;\n    \n    \n    // The pentagon spiral consists of five curved lines connecting the\n    // center to the pentagon edges.\n    for(int i = min(0, iFrame); i<5; i++){ \n    \n        int ip1 = (i + 1)%5;\n\n        // Mid pentagon edge point.\n        vec3 vMid1 = normalize(mix(vP[i], vP[ip1], .5))*rad; \n        // Angle between the current point and the pentagon center.\n        float angR = angle(lq, vPCntr);\n        //float angR = length(lq - vPCntr)/length(vMid1 - vPCntr);         \n\n        // Sphere line between the mide edge point and the pentagon center.\n        // The formula has been modified to give it a sinusoidal wave.\n        float line = sphereLineDistCapBWave(lq, vMid1, vPCntr, angR);\n\n        // 2D box coordinates (The line and the Z direction).\n        vec2 lv = vec2(line, (length(lq) - .5));\n\n       \n        #ifdef TWIST\n        // Twisting (rotating) the box coordinates a quarter turn from the center to\n        // the mid point. How you do this is up to you. The way I've done it is not\n        // pefect, but it's close enough. I'll put more effort into it later.\n        lv = rot2(smoothstep(.25, 1., angR/cAng*1.15)*3.14159/4.)*lv;\n        //lv = rot2(smoothstep(.05, .95, length(lq - vPCntr)/length(vMid1 - vPCntr))*3.14159/4.)*lv;\n        //lv = rot2(smoothstep(.05, 1., angR*1.)*3.14159/4.)*lv;\n        //lv = rot2(clamp(angR*2.65 - .4, .0, 1.)*3.14159/4.)*lv;\n        #endif\n\n        /*\n        // Failed experiment with repeat boxes... I'll try again later. :)\n        float z = normalize(cross(vec3(lv.x, 0, 0), vec3(0, lv.y, 0))).z;\n        z = mod(angR*cAng/6.2831*8. + .25/8., 1./8.) - .5/8.;\n        float bx = sBoxS(vec3(lv, z), vec3(.04), .01);\n        */\n        \n        // Cross sectional 2D box object.\n        float bx = sBoxS(lv, vec2(.04), .0);\n        //float bx = max(abs(lv.x), abs(lv.y)) - .04;\n        //bx += sin(angR*cAng*256. + 3.14159)*.0003; // Ribbing.\n        //bx = max(ln2, abs(z) - .2/8.);\n        \n        // Putting on some trimming.\n        float sdBox = length(abs(lv) - .045) - .0085;//max(abs(lv.x), abs(lv.y));//\n        //sdBox += clamp(sin(angR*cAng*128. + 3.14159)*3., 0., 1.)*.002;\n        sdBox += sin(angR*cAng*256. + 3.14159)*.0005; // Beading.\n \n        crv = min(crv, bx);\n        crv2 = min(crv2, sdBox);\n \n \n            \n    }\n         \n    // Hastily written background line trimming. \n    float sc = .45;      \n    vec3 qq = p - vec3(0, 0, 3. - .02);\n    qq.xy *= rot2(-3.14159/5.);\n    qq.xy += sin(qq.xy*1. - cos(qq.yx*2.))*.05;\n    qq.y = mod(qq.y, sc) - sc/2.;\n    //\n    float bgLn = length(qq.yz) - .03;\n    bgLn += sin(6.2831*qq.x*16.)*.002; // Beading.\n    \n    // Appending the background line trimming.  \n    crv2 = min(crv2, bgLn);\n \n    // Central pentagon spheres.\n    float sph = length(lq - vPCntr*1.115) - .0325;\n     \n\n\n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, crv, crv2);\n    \n    // Shortest distance.\n    return  min(min(sph, wall), min(crv, crv2));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.75; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .1, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    //float svMetal = gMetal;\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // Central spheres.\n            texCol = mix(vec3(1, .3, .1), vec3(1, .1, .2), abs(sn.y)*.5 + .25);\n            texCol = max((sn.xzy)*.35 + .65, .1)*texCol*1.2;\n           \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n\n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n            vec3 tx = tex3D(iChannel1, txP, txN);\n            texCol *= tx*2.; \n    \n           \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n\n            // Intial background color.\n            texCol = mix(vec3(1, .5, .25), vec3(.175), .9);       \n            \n            // Coloring alternate strips.\n            float sc = .45;      \n            vec3 qq = sp;// - vec3(0, 0, 3. - .035);\n            qq.xy *= rot2(-3.14159/5.);\n            qq.xy += sin(qq.xy*1. - cos(qq.yx*2.))*.05;\n            float idy = floor(qq.y/sc + .5);\n            qq.y -= (idy + .5)*sc;//mod(qq.y, sc) - sc/2.;\n            if(mod(idy, 2.)<.5) texCol = mix(vec3(1, .5, .25), vec3(.175), .825);\n\n            // Applying texture.\n            vec3 tx = texture(iChannel1, sp.xy/3. + .5).xyz; tx *= tx;\n            texCol *= (tx + .75)*.9;\n            \n   \n            \n        }\n        else { \n        \n            // Star ball and trim color.\n\n            // Main star ball color.\n            texCol = mix(vec3(1, .3, .1), vec3(1, .1, .2), abs(sn.y)*.5 + .25);\n             \n            // Trimming.\n            if(objID==3){\n                 //All trimming.\n                 texCol = max((sn.xzy)*.35 + .65, .1)*texCol*1.2;\n                 // Star ball trimming.\n                 if(sp.z<2.5){\n                    diff *= sqrt(diff);\n                    texCol = mix(mix(texCol, vec3(1, .5, .25)/2., .8), \n                                 vec3(1)*dot(texCol, vec3(.299, .587, .114)), .2); \n                } \n        \n            }\n            \n            \n            if(sp.z>2.5){ \n            \n                // Back wall tubing metal.\n                vec3 tx = tex3D(iChannel1, sp/3. + .5, sn);\n                texCol = mix(vec3(1, .5, .25)/2., vec3(1)*dot(texCol, vec3(.299, .587, .114)), .65)*.5; \n                texCol *= (tx + .75)*.9;\n            }\n            else {\n                \n                // Star ball texturing.\n                \n                // Texture position and normal.\n                vec3 txP = sp - sphPos;\n                vec3 txN = sn;\n\n                // Rotation to match the scene movement.\n                txP = rotObj(txP);\n                txN = rotObj(txN);\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                //tx = smoothstep(.0, .5, tx);\n                texCol *= tx*2.;// + .1;\n            \n            }\n            \n            \n           \n            \n            \n        }\n        \n         \n        // Specular reflection.\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 8.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel0, rf).xyz; rTx *= rTx;\n        float spF = objID == 2? 2. : 3.;\n        if(objID!=1) texCol += (texCol*.9 + .1)*speR*rTx*spF;\n        \n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .15 + vec3(1, .9, .7)*spec*freS*sh*8. + vec3(.2, .4, 1)*fre*sh*0.);\n \n\n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog.\n    //col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n\n\n    // No temporal blur, for comparison.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2524, 2557, 2579, 2579, 2637], [2640, 2668, 2689, 2689, 2752], [2755, 2835, 2881, 2881, 3793], [3796, 3930, 3953, 3977, 4248], [4251, 4290, 4337, 4337, 4444], [4446, 4485, 4532, 4532, 4629], [4632, 4660, 4690, 4690, 4747], [5007, 5088, 5125, 5125, 5243], [10435, 10591, 10655, 10724, 11450], [15604, 15625, 15661, 15710, 16141], [16144, 16235, 16271, 16614, 16886], [16890, 17081, 17133, 17257, 18577], [18580, 18732, 18768, 18768, 19059], [19062, 19062, 19118, 19118, 26100]], "test": "untested"}
{"id": "ctsGRf", "name": "chalk mouse", "author": "lanx06", "description": "chalk like fog", "tags": ["mouse", "fog", "chalk", "framebuffer"], "likes": 2, "viewed": 273, "published": 3, "date": "1672570775", "time_retrieved": "2024-07-30T18:18:32.364458", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define fb iChannel0\n#define PI 3.1415926538\n#define T iTime*0.5\nfloat sin_lerp(float a,float b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nfloat random(float seed){\n    return fract(sin(seed+1.) * 43758.5453);\n}\nfloat curl_random(float seed,float offset,float freq){\n    return sin_lerp(random(offset+floor(mod(seed,freq))),random(offset+floor(mod(seed+1.,freq))),abs(seed-floor(seed)));\n}\n// Code originally from draw_to_fb().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 color=vec4(0.0);\n\tvec2 uv= fragCoord.xy / iResolution.xy;\n    //vec2 offset;\n    bool mouse_hold = !(iMouse.z < 0.0);\n    vec2 mouse = iMouse.xy;\n    if(!mouse_hold)\n        mouse=iResolution.xy*(vec2(cos(T*5.0)*0.7,sin(T)*0.8)*0.5+0.5);\n    //offset-=vec2(0.5);\n    //offset*=0.01;\n\tcolor = texture(fb,uv+vec2(0.0,0.03))*0.1;\n    float dis=1.0-distance(fragCoord,mouse)/10.0;\n    color+=vec4(clamp(dis*100.,0.0,1.0));\n    #define sample 10\n    vec2 ve[sample];\n    for(int i=0;i< sample;i++){\n        float angle=2.0*PI*float(i)/float(sample);\n        vec2 offset=vec2(cos(angle),sin(angle))*3.;\n        offset/=iResolution.xy;\n        vec4 last = clamp(texture(fb,uv+offset),vec4(0.0),vec4(1.0));\n        color+=(vec4(last.xyz,0))/float(sample);\n        //color+=(vec4(last.x,0,0,0))/float(10);\n        //color+=last/float(sample);\n        \n    }\n    //color=vec4(uv,0.0,0.0);\n\tcolor*=vec4(.9);\n    fragColor = clamp(color,vec4(0),vec4(1));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 137]], "test": "untested"}
{"id": "Dlf3DX", "name": "Truchet Patterns", "author": "lanx06", "description": "Truchet Patterns\nhttps://archive.bridgesmathart.org/2018/bridges2018-39.pdf\nhttps://www.behance.net/gallery/75203387/Criollabat-A\nhttps://www.behance.net/gallery/111788293/Sbastien-Truchet-Typeface", "tags": ["patterns", "truchet"], "likes": 6, "viewed": 222, "published": 3, "date": "1672570766", "time_retrieved": "2024-07-30T18:18:33.203215", "image_code": "#define PI 3.1415926538\nfloat sin_lerp(float a,float b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nfloat random(float seed){\n    return fract(sin(seed+1.) * 43758.5453);\n}\nfloat curl_random(float seed,float offset,float freq){\n    return sin_lerp(random(offset+floor(mod(seed,freq))),random(offset+floor(mod(seed+1.,freq))),abs(seed-floor(seed)));\n}\nvec2 dir4[4]=vec2[](vec2(1.0,0.0),vec2(0.0,1.0),vec2(0.0,-1.0),vec2(-1.0,0.0));\nvec2 dir2_1[4]=vec2[](vec2(1.0,1.0),vec2(1.0,-1.0),vec2(-1.0,-1.0),vec2(-1.0,1.0));\nvec2 dir8[8]=vec2[](vec2(1.0,0.0),vec2(1.0,1.0),vec2(0.0,1.0),vec2(1.0,-1.0),vec2(0.0,-1.0),vec2(-1.0,-1.0),vec2(-1.0,0.0),vec2(-1.0,1.0));\nvec2 dir4_1[4]=vec2[](vec2(1.0,1.0),vec2(-1.0,-1.0),vec2(1.0,-1.0),vec2(-1.0,1.0));\n\nfloat shape(vec2 uv,vec2 dir){\n\n    vec2 l = uv-0.5;\n    l+=dir;\n    float pix =0.02;\n    float thin=0.05;\n    float radius=0.60;\n    float offset=curl_random(iTime,0.,100.0);\n    radius+=(offset-0.5)*radius;\n    //circles https://youtu.be/2R7h76GoIJM?t=1027\n    float a= smoothstep(pix,-pix,abs(length(l)-radius)-thin);\n    radius=1.0-radius;\n    float c= smoothstep(radius+thin+pix,\n                      radius+thin-pix,\n                      length(l));\n    \n    float d= smoothstep(radius-thin+pix,\n                      radius-thin-pix,\n                      length(l));\n    return max(a,c-d);\n}\n\nfloat shape_4(vec2 st,int type){\n    float color=0.0;\n    #define loop2 2\n    if(type<1)\n        for(int i=0;i<2;i++)\n            color=max(color,shape(st,dir4_1[i]/2.0)); \n    else if(type<2)\n        for(int i=2;i<4;i++)\n            color=max(color,shape(st,dir4_1[i]/2.0));\n    else\n        for(int i=0;i<4;i++)\n            color=max(color,shape(st,dir4_1[i]/2.0));\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord/iResolution.y;\n    vec3 color = vec3(0.0);\n    float tem=0.0;\n    float n=50.0;\n    //st=mod(fragCoord,n)/n;\n    st=fract(fragCoord/n);\n    vec2 id=floor(fragCoord/n);\n    float v=curl_random(iTime*0.03,id.x+id.y*n,1000.0);\n    tem=shape_4(st,int(v*3.0));\n    color=mix(vec3(0.058, 0.96, 0.678),vec3(1, 0, 0.38),tem);\n    fragColor = vec4(color,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 64, 64, 131], [132, 132, 157, 157, 204], [205, 205, 259, 259, 382], [772, 772, 802, 802, 1373], [1375, 1375, 1407, 1407, 1762], [1763, 1763, 1820, 1820, 2202]], "test": "untested"}
{"id": "DllGWX", "name": "Happy 2023 New Year!", "author": "shaofun", "description": "Happy 2023 New Year!\n\nEgg: change ichannel3 to nearest", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr", "2023"], "likes": 8, "viewed": 338, "published": 3, "date": "1672555551", "time_retrieved": "2024-07-30T18:18:34.152676", "image_code": "// Fork of \"RayTracing PBR 2023 rot\" by shaofun. https://shadertoy.com/view/mtX3Wj\n// 2023-01-01 06:44:00\n\n// Fork of \"RT SDF Bloom Test\" by shaofun. https://shadertoy.com/view/mllGW4\n// 2022-12-23 11:49:13\n\n// from https://www.shadertoy.com/view/MssczX\n\nvec2 rot(vec2 p, float a) {\n    a=radians(a);\n    return cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec2 saturate(vec2 p) { return clamp(p,0.,1.); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    const float n = 24.;\n    const float a1 = -1.;\n    const float a2 = -5.;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0);\n    vec2 colorShift = vec2(2,1)/iResolution.xy;\n    vec2 uv1 = uv+colorShift;\n    vec2 uv2 = uv;\n    vec2 uv3 = uv-colorShift;\n    vec2 axis1 = rot(vec2(0,1.105/iResolution.y),-15.);\n    vec2 axis2 = rot(vec2(0,0.953/iResolution.y),+65.);\n    for(float delta = 0.; delta< n;delta++){\n        float scale = .0625*.0625*(1.-.9875*delta/n);\n        vec2 d1r = delta*rot(axis1,-a1);\n        vec2 d1g = delta*axis1;\n        vec2 d1b = delta*rot(axis1,+a1);\n        vec4 texR1 = texture(iChannel0, saturate(uv1+d1r));\n        vec4 texR2 = texture(iChannel0, saturate(uv1-d1r));\n        vec4 texG1 = texture(iChannel0, saturate(uv2+d1g));\n        vec4 texG2 = texture(iChannel0, saturate(uv2-d1g));\n        vec4 texB1 = texture(iChannel0, saturate(uv3+d1b));\n        vec4 texB2 = texture(iChannel0, saturate(uv3-d1b));\n        vec3 aberr1 = vec3(dot(vec4(10,4,2,0),texR1+texR2),\n                           dot(vec4(3,10,3,0),texG1+texG2),\n                           dot(vec4(2,4,10,0),texB1+texB2));\n        vec3 col1 = aberr1*max(aberr1.r,max(aberr1.g,aberr1.b));\n        vec2 d2r = delta*rot(axis2,+a2);\n        vec2 d2g = delta*axis2;\n        vec2 d2b = delta*rot(axis2,-a2);\n        vec4 texR3 = texture(iChannel0, saturate(uv1+d2r));\n        vec4 texR4 = texture(iChannel0, saturate(uv1-d2r));\n        vec4 texG3 = texture(iChannel0, saturate(uv2+d2g));\n        vec4 texG4 = texture(iChannel0, saturate(uv2-d2g));\n        vec4 texB3 = texture(iChannel0, saturate(uv3+d2b));\n        vec4 texB4 = texture(iChannel0, saturate(uv3-d2b));\n        vec3 aberr2 = vec3(dot(vec4(10,4,2,0),texR3+texR4),\n                           dot(vec4(3,10,3,0),texG3+texG4),\n                           dot(vec4(2,4,10,0),texB3+texB4));\n        vec3 col2 = aberr2*max(aberr2.r,max(aberr2.g,aberr2.b));\n        vec3 col = pow(scale*max(col1,col2)*3.7,vec3(5.2));\n        color+=col;\n    }\n    fragColor = vec4(mix(texture(iChannel0,uv).rgb,\n                         color,\n                         smoothstep(.01,.2,min(uv.x,uv.y))*smoothstep(-.99,-.8,-max(uv.x,uv.y))),1);\n                         \n    vec4 res = texture(iChannel1,uv);\n    fragColor = max(vec4(0),sqrt(10.5*fragColor)*.001025)+vec4(res.rgb/res.a,1.0);;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(2.5, 8.2, 24.0, 0.0));\n        store(ROTATION, vec4(0.0,PI/15.1,0.0,0.0));\n        \n        store(TARGET,   vec4(2.5, 6.0, 24.0, 0.0));\n        store(TMOUSE,   vec4(0.0,PI/15.1,0.0,0.0));\n        store(PMOUSE,   vec4(0.0,PI/15.1,0.0,0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// 2022.12.30\n// 1. fix blackened colors caused by incorrect light absorption.\n// 2. that also improved the frame rate.\n// 3. correct cumulative brightness in the alpha channel instead of always being one.\n// 4. which reduces noise.\n// 5. ~~discard pixels that are too dark, it brighten the pixel quality.~~\n\n// 2022.12.26\n// 1. enables metal to be used in IOR.\n// 2. small optimization of performance.\n// 3. simplified reflection operations.\n// 4. use plain black background.\n\n// 2022.12.24\n// 1. fixed camera jamming when looking up and down.\n\n// 2022.12.23\n// 1. fix the blackening of rough transparent material, it improved the frame rate.\n// 2. fix the camera misalignment when full screen.\n// 3. fix the inability to propagate reflected light inside an object.\n// 4. optimize the judgment about self-luminous light source.\n// 5. some formatting optimizations and minor efficiency optimizations.\n// 6. gamma correction for skybox.\n\n// 2022.12.21\n// 1. make the rotation of the view smooth.\n// 2. automatically perform noise reduction when stopping movement.\n// 3. hold down space to force a screen refresh.", "buffer_b_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 摄像机参数\nconst float camera_vfov       = 30.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 2.0;                  // 摄像机的对焦距离\nconst float camera_aperture   = 0.000;                // 摄像机的光圈大小\nconst float camera_exposure   = 0.6;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.5;                     // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 200.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.05;                    // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = pow(1.0 / 256.0, gamma);   // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_2   = 0;\nconst int SHAPE_0   = 1;\nconst int SHAPE_3   = 2;\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    vec3  normal;       // 切线空间法线\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// from https://www.shadertoy.com/view/XsfGDn\nvec2 bestUV(vec2 uv) {\n    float textureResolution = iChannelResolution[3].x;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/textureResolution;\n    return uv;\n}\n\n// from https://www.shadertoy.com/view/llcXRl\nvec4 SampleFontTex2(vec2 uv)\n{\n    uv = bestUV(uv);\n    // Do some tricks with the UVs to spell out \"TexFont\" in the middle.\n    vec2 fl = floor(uv + 0.5);\n    if (fl.y == 0.0) {\n         if (fl.x == 0.0) fl = vec2(2.0, 12.0);\n         else return vec4(1000000);\n    } else return vec4(1000000);\n    uv = fl + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel3, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nvec4 SampleFontTex0(vec2 uv)\n{\n    uv = bestUV(uv);\n    // Do some tricks with the UVs to spell out \"TexFont\" in the middle.\n    vec2 fl = floor(uv + 0.5);\n    if (fl.y == 0.0) {\n         if (fl.x == 0.0) fl = vec2(0.0, 12.0);\n         else return vec4(1);\n    } else return vec4(1);\n    uv = fl + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel3, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nvec4 SampleFontTex3(vec2 uv)\n{\n    uv = bestUV(uv);\n    // Do some tricks with the UVs to spell out \"TexFont\" in the middle.\n    vec2 fl = floor(uv + 0.5);\n    if (fl.y == 0.0) {\n         if (fl.x == 0.0) fl = vec2(3.0, 12.0);\n         else return vec4(1000000);\n    } else return vec4(1000000);\n    uv = fl + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel3, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.02;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nfloat DistanceToObject2(vec3 p)\n{\n\t// Load the font texture's distance field.\n    float letterDistField = (SampleFontTex2(p.xy).w - 0.5+1.0/256.0);\n    float box = sd_box(p, vec3(10, 1, 0.1));\n    float dis = opSmoothIntersection(letterDistField, box, 0.1);\n    return dis;\n}\n\nfloat DistanceToObject0(vec3 p)\n{\n\t// Load the font texture's distance field.\n    float letterDistField = (SampleFontTex0(p.xy).w - 0.5+1.0/256.0);\n    float box = sd_box(p, vec3(10, 1, 0.1));\n    float dis = opSmoothIntersection(letterDistField, box, 0.1);\n    return dis;\n}\n\nfloat DistanceToObject3(vec3 p)\n{\n\t// Load the font texture's distance field.\n    float letterDistField = (SampleFontTex3(p.xy).w - 0.5+1.0/256.0);\n    float box = sd_box(p, vec3(10, 1, 0.1));\n    float dis = opSmoothIntersection(letterDistField, box, 0.1);\n    return dis;\n}\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 地图列表\nconst object[] map = object[] (\n    object(SHAPE_2, ZERO,\n        transform(  vec3(-5, 0.0, 0),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_0, ZERO,\n        transform(  vec3(0, 0.0, 0),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(1.0, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_2, ZERO,\n        transform(  vec3(5, 0.0, 0),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.500  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_3, ZERO,\n        transform(  vec3(10, 0.0, 0),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 0.5, 1.8)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    \n    object(SHAPE_2, ZERO,\n        transform(  vec3(-5, 0.0, -100),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_0, ZERO,\n        transform(  vec3(0, 0.0, -100),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(1.0, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_2, ZERO,\n        transform(  vec3(5, 0.0, -100),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.500  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_2, ZERO,\n        transform(  vec3(10, 0.0, -100),\n                    vec3(0, 0, 0),\n                    vec3(10, 10, 10)\n        ),\n        material(   vec3(0.5, 1.0, 0.5)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.500  // 折射率 （沥青）\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    // 会重复的将欧拉角转换成旋转矩阵，实际上只用在第一次计算就行了\n    // 也有可能被编译器优化掉了\n    p *= angle(radians(rotation));\n    \n    switch(obj.shape) {\n        case SHAPE_2:\n            return DistanceToObject2(p/scale.x)*scale.x;\n        case SHAPE_0:\n            return DistanceToObject0(p/scale.x)*scale.x;\n        case SHAPE_3:\n            return DistanceToObject3(p/scale.x)*scale.x;\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o; o.dis = TMAX;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 用世界坐标下的法线计算 TBN 矩阵 from https://doi.org/10.1080/2165347X.2012.689606\nmat3 TBN(vec3 N) {\n    vec3 T, B;\n    \n    if (N.z < -0.99999) {\n        T = vec3(0, -1, 0);\n        B = vec3(-1, 0, 0);\n    } else {\n        float a = 1.0 / (1.0 + N.z);\n        float b = -N.x*N.y*a;\n        \n        T = vec3(1.0 - N.x*N.x*a, b, -N.x);\n        B = vec3(b, 1.0 - N.y*N.y*a, -N.y);\n    }\n    \n    return mat3(T, B, N);\n}\n\n// 使用光线步进 (Ray March) 检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis * 0.1;\n    }\n    return rec;\n}\n\n// 采样立方体贴图\nvec4 mix_cube_lod(samplerCube sharp, samplerCube blur, vec3 dir, float lod) {\n    return mix(textureLod(sharp, dir, lod), textureLod(blur, dir, lod), lod);\n}\n\n// 采样天空\nvec3 sky(ray r, float brightness, float lod) {\n    // float t = 0.5 + 0.5 * r.direction.y;\n    // vec3 bottom = vec3(1.0, 1.0, 1.0);\n    // vec3 top = vec3(0.9, 1.5, 3.0);\n    // return mix(bottom, top, t * brightness);\n    vec4 ibl = textureLod(iChannel2, r.direction, lod); // 天空盒 IBL 照明\n    return pow(ibl.rgb * ibl.a * brightness, vec3(gamma)); // gamma 矫正\n}\n\n// 快速计算五次方\nfloat pow5(float x) {\n    float t = x*x; t *= t;\n    return t*x;\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float cosine, float F0) {\n    return mix(pow5(abs(1.0 - cosine)), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float cosine, float F0, float roughness) {\n    return mix(fresnel_schlick(cosine, F0), F0, roughness);\n}\n\n// 以 n 为法线进行半球采样\nvec3 hemispheric_sampling() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v; \n\n    return vec3(xy, z);\n}\n\n// 用粗糙度采样沿向量 n 半球采样\nvec3 hemispheric_sampling(float roughness) {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    float shiny = pow5(roughness); // 光感越大高光越锐利\n    \n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt((1.0 - r.x) / (1.0 + (shiny - 1.0) * r.x));\n    vec2 xy = sqrt(abs(1.0 - z*z)) * v;\n    \n    return vec3(xy, z);\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    vec3  normal       = rec.obj.mtl.normal;\n    float ior          = rec.obj.mtl.ior;\n    \n    normal = TBN(rec.normal) * normal; // 将切线空间法线转换到世界空间\n    float outer = -sign(dot(normal, r.direction)); // 光正在从外面穿入物体表面\n    \n    // 光线和物体表面参数\n    vec3 I  =  r.direction;\n    vec3 V  = -r.direction;\n    vec3 N  =  normal *= outer; // 如果处于 SDF 物体内部就反过来\n    vec3 C  =  r.color;\n    vec3 L;\n    \n    N = TBN(N) * hemispheric_sampling(roughness); // 用粗糙度半球采样\n    float NoV   = dot(N, V);\n\n    float eta = outer > 0.0 ? ENV_IOR / ior : ior / ENV_IOR; // 计算折射率之比\n    float k = 1.0 - eta * eta * (1.0 - NoV * NoV); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 3.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoV, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.y < F + metallic || k < 0.0) {\n            L = I + 2.0 * NoV * N; // 包含镜面反射、菲涅尔反射、全反射\n            // 下面可以提高帧数，但是会导致透明材质发黑，需要优化\n            C *= float(dot(L, normal) > 0.0); // 如果光穿入或穿出表面就直接吸收掉 \n    } else {\n        if (rand2.x < transmission) {\n            L = eta * I - (sqrt(k)- eta * NoV) * N; // 斯涅尔折射\n        } else {\n            L = TBN(normal) * hemispheric_sampling(); // 漫反射\n        }\n    }\n\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) { // discard;\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 能量守恒\n        r.color *= inv_pdf;\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r, 2.0, 1.0 - 1.0 / (1.0 + 0.1 * float(i)));\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 更新光子的位置\n        r.origin = rec.pos;\n        \n        // 应用 PBR 材质更新光线\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n        r.color        *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        if (visible > intensity || visible < VISIBILITY) break; // 光太暗碰到光源\n    }\n\n    return r;\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color  = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, iTime*iTimeDelta));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    // 色调映射\n    color *= camera_exposure;\n    color  = ACESFitted(color);\n    \n    // 伽马矫正\n    color = pow(color, vec3(1.0 / gamma));\n\n    return vec4(color, brightness(r.color));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Fork of \"RayTracing PBR with Free Camera\" by shaofun. https://shadertoy.com/view/ddSSWy\n// 2022-12-23 10:44:30\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.rgb/color.a, 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 282, 282, 348], [349, 349, 372, 372, 397], [398, 398, 454, 454, 2796]], "test": "untested"}
{"id": "ctlGWX", "name": "HappyNewYear2023", "author": "yasuo", "description": "Happy new year!!!", "tags": ["graphicdesign", "cineshader"], "likes": 28, "viewed": 2155, "published": 3, "date": "1672555045", "time_retrieved": "2024-07-30T18:18:34.903668", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define FS 0.1 // font size\n#define FGS FS/5. // font grid size\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat SimpleVesicaDistanceY(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nfloat dSlopeLines(vec2 p){\n    float lineSize = 200.;\n    float d = tan((mix(p.x,p.y,0.5)+(-iTime*5./lineSize))*lineSize)*lineSize;\n    return d;\n}\n\nfloat dDots(vec2 p, float s, float dist, float speed){\n    p-=iTime*speed;\n    p = mod(p,dist)-(dist*0.5);\n    float d = length(p)-s;\n    return d;\n}\n\nfloat roundBar(vec2 p, vec2 s){\n    float d = B(p,vec2(s));\n    p.x = abs(p.x)-s.x;\n    float d2 = length(p)-s.y;\n    return min(d,d2);\n}\n\nfloat char2(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat char3(vec2 p) {\n    vec2 prevP = p;\n    \n    p.y = abs(p.y);\n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    float d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n\n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);   \n\n    return d;\n}\n\nfloat char0(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    \n    float d2 = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(0.0,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;  \n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat bonsaiLeafBase(vec2 p){\n    vec2 prevP = p;\n    float d = length(p)-0.06;\n    p.x = abs(p.x)-0.06;\n    p.y+=0.02;\n    float d2 = length(p)-0.06;\n    d = min(d,d2);\n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    p.y+=0.05;\n    d2 = length(p)-0.06;\n    d = min(d,d2);\n    p = prevP;\n    p.y+=0.05;\n    d2 = length(p)-0.06;\n    d = min(d,d2);\n    return d;\n}\n\nfloat bonsaiLeaf(vec2 p, float dir){\n    vec2 prevP = p;\n    float d = abs(bonsaiLeafBase(p))-0.002;\n    float dots = dDots(p,0.001,0.02,0.01);\n    dots = max(dots,bonsaiLeafBase(p));\n    d = min(d,dots);\n    \n    p.y+=0.0985;\n    p*=Rot(radians(20.*iTime*dir));\n    \n    p = DF(p,4.0);\n    \n    p -= vec2(0.045);\n    \n    p*=Rot(radians(45.));\n    p.y*=0.4;\n    float d2 = abs(SimpleVesicaDistanceY(p,0.017,0.012))-0.001;\n    \n    p = prevP;\n    d2 = max(bonsaiLeafBase(p),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat branches(vec2 p) {\n    vec2 prevP = p;\n    p.y+=0.095;\n    p*=Rot(radians(20.));\n    float d = B(p,vec2(0.045,0.15));\n    p = prevP;\n    p-=vec2(-0.03,0.06);\n    p*=Rot(radians(30.));\n    float d2 = B(p,vec2(0.13,0.04));\n    d = min(d,d2);\n    p = prevP;\n    p-=vec2(-0.065,0.2);\n    p*=Rot(radians(-60.));\n    d2 = B(p,vec2(0.13,0.03));\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(-0.14,-0.05);\n    p*=Rot(radians(-10.));\n    d2 = B(p,vec2(0.13,0.02));\n    d = min(d,d2);\n\n    p = prevP;\n    p-=vec2(0.2,-0.08);\n    p*=Rot(radians(-15.));\n    d2 = B(p,vec2(0.2,0.02));\n    d = min(d,d2);\n\n    p = prevP;\n    p-=vec2(0.1,0.15);\n    p*=Rot(radians(-20.));\n    d2 = B(p,vec2(0.2,0.02));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat bonsai(vec2 p){\n    p*=1.7;\n    vec2 prevP = p;\n    float d = abs(branches(p))-0.002;\n    float dots = dDots(p,0.0035,0.03,-0.02);\n    dots = max(dots,branches(p));\n    d = min(d,dots);\n    \n    float d2 = bonsaiLeafBase(p-vec2(0.38,0.05));\n    d = max(-d2,d);\n    d2 = bonsaiLeafBase(p-vec2(-0.2,-0.01));\n    d = max(-d2,d);\n    d2 = bonsaiLeafBase(p-vec2(-0.02,0.37));\n    d = max(-d2,d);\n    d2 = bonsaiLeafBase(p-vec2(0.07,0.12));\n    d = max(-d2,d);\n    d2 = bonsaiLeafBase(p-vec2(0.29,0.28));\n    d = max(-d2,d);\n    d2 = bonsaiLeafBase(p-vec2(-0.25,0.2));\n    d = max(-d2,d);  \n    \n    d2 = bonsaiLeaf(p-vec2(0.38,0.05),1.);\n    d = min(d,d2);\n    d2 = bonsaiLeaf(p-vec2(-0.2,-0.01),-1.);\n    d = min(d,d2);\n    d2 = bonsaiLeaf(p-vec2(-0.02,0.37),1.);\n    d = min(d,d2);\n    d2 = bonsaiLeaf(p-vec2(0.07,0.12),-1.);\n    d = min(d,d2);\n    d2 = bonsaiLeaf(p-vec2(0.29,0.28),1.);\n    d = min(d,d2);\n    d2 = bonsaiLeaf(p-vec2(-0.25,0.2),-1.);\n    d = min(d,d2);\n    \n    d = max(-(p.y+0.2),d);\n    \n    d2 = abs(B(p-vec2(0.0,-0.22),vec2(0.17,0.02)))-0.002;\n    d = min(d,d2);\n    d2 = B(p-vec2(0.0,-0.3),vec2(0.2,0.06));\n    float a = radians(-10.);\n    p.x = abs(p.x)-0.18;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    p = prevP;\n    float slope = dSlopeLines(p);\n    slope = max(d2,slope);\n    \n    d = min(d,abs(d2)-0.002);\n    d = min(d,slope);\n    d2 = abs(B(p-vec2(0.0,-0.37),vec2(0.08,0.01)))-0.002;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat infoGraphic1(vec2 p, float dir, float s){\n    p*=Rot(radians(10.*iTime*dir));\n    p*=s;\n    vec2 prevP = p;\n    float size = 0.05;\n    float d = abs(length(p-vec2(0.0,size))-size)-0.001;\n    float d2 = abs(length(p-vec2(0.0,-size))-size)-0.001;\n    d = min(d,d2);\n    d2 = abs(length(p-vec2(-size,0.0))-size)-0.001;\n    d = min(d,d2);\n    d2 = abs(length(p-vec2(size,0.0))-size)-0.001;\n    d = min(d,d2);\n    return d;\n}\n\nfloat infoGraphic2(vec2 p){\n    float d = roundBar(p-vec2(0.0,0.05),vec2(0.1,0.03));\n    float d2 = roundBar(p-vec2(0.06,-0.05),vec2(0.1,0.03));\n    d = min(d,d2);\n    d2 = B(p-vec2(0.03,0.00),vec2(0.04,0.03));\n    d = opSmoothUnion(d,d2,0.02);\n    return abs(d)-0.001;\n}\n\nfloat infoGraphic3(vec2 p){\n    p*=2.;\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p -= vec2(0.042);\n    p*=Rot(radians(45.));\n    p.y*=0.4;\n    float d = abs(SimpleVesicaDistanceY(p,0.025,0.012))-0.001;\n    \n    p = prevP;\n    p*=Rot(radians(23.));\n    p = DF(p,2.);\n    p -= vec2(0.06);\n    float d2 = length(p)-0.007;\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat infoGraphic4(vec2 p){\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p -= vec2(0.02);\n    p*=Rot(radians(45.));\n    p.y*=0.9;\n    float d = abs(SimpleVesicaDistanceY(p,0.02,0.015))-0.001;\n    \n    p = prevP;\n    p*=Rot(radians(-20.));\n    p = DF(p,1.25);\n    p -= vec2(0.05);\n    float d2 = abs(length(p)-0.05)-0.001;\n    p = prevP;\n    d2 = max(-(length(p)-0.08),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat eye(vec2 p){\n    p.x = abs(p.x)-0.03;\n    p.y+=0.03;\n    float d = B(p,vec2(0.001,0.01));\n    float d2 = B(p,vec2(0.008,0.001));\n    return min(d,d2);\n}\n\nfloat bunny(vec2 p){\n    vec2 prevP2 = p;\n    p.y-=iTime*0.1;\n    p*=1.5;\n    p.x = mod(p.x,0.16)-0.08;\n    p.y = mod(p.y,0.26)-0.13;\n    p.y+=0.025;\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.04;\n    p.y-=0.05;\n    p*=Rot(radians(10.));\n    float d = SimpleVesicaDistanceY(p,0.2,0.17);\n    p = prevP;\n    p.y*=1.2;\n    float d2 = length(p-vec2(0.,-0.05))-0.07;\n    d = abs(min(d,d2))-0.001;\n    \n    p = prevP;\n    d2 = eye(p);\n    d = min(d,d2);\n    \n    p = prevP2;\n    d = max(-(length(p)-0.5),d);\n    \n    return d;\n}\n\nfloat year(vec2 p){\n    float d = char2(p-vec2(-0.375,0.0));\n    float d2 = char0(p-vec2(-0.125,0.0));\n    d = min(d,d2);\n    d2 = char2(p-vec2(0.125,0.0));\n    d = min(d,d2);\n    d2 = char3(p-vec2(0.375,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nfloat sun(vec2 p){\n    p*=1.6;\n    vec2 prevP = p;\n    float speed = -0.05;\n    float d = length(p)-0.2;\n    p+=iTime*speed;\n    p = mod(p,0.1)-0.05;\n    float d2 = abs(length(p)-0.05)-0.001;\n    p = prevP;\n    \n    p+=iTime*speed;\n    p-=vec2(0.05);\n    p = mod(p,0.1)-0.05;\n    \n    float d3 = abs(length(p)-0.05)-0.001;\n    d2 = min(d2,d3);\n    \n    d2 = min(abs(d)-0.002,d2);\n    \n    d = max(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.);\n    \n    float d =  bunny(p);\n    col = mix(col,vec3(0.7),S(d,0.0));\n    \n    p.x+=iTime*0.1;\n    p.x+=0.3;\n    p.x = mod(p.x,0.6)-0.3;\n    d = infoGraphic2(p-vec2(0.0,0.25));\n    \n    p = prevP;\n    d = max((length(p)-0.38),d);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = length(p-vec2(-0.2,0.16))-0.125;\n    col = mix(col,vec3(0.),S(d,0.0));\n    d = sun(p-vec2(-0.2,0.16));\n    col = mix(col,vec3(1.),S(d,0.0));\n    d = bonsai(p-vec2(0.02,-0.12));\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = infoGraphic1(p-vec2(0.2,-0.25),1.5,2.2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = infoGraphic1(p-vec2(-0.27,-0.19),-1.,2.5);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = infoGraphic1(p-vec2(-0.15,-0.28),2.,2.);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p*=Rot(radians(-10.*iTime));\n    p = DF(p,4.5);\n    p -= vec2(0.4);\n    p*=Rot(radians(45.));\n    d = infoGraphic3(p-vec2(0.02,-0.12));\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    d = year(p);\n    col *= mix(col,vec3(0.1),S(d,0.0));\n    col = mix(col,vec3(1.),S(abs(d)-0.001,0.0));\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 565, 617, 617, 716], [718, 718, 773, 773, 831], [833, 833, 859, 859, 980], [982, 982, 1036, 1036, 1131], [1133, 1133, 1164, 1164, 1270], [1272, 1272, 1293, 1293, 1856], [1858, 1858, 1879, 1879, 2309], [2311, 2311, 2332, 2332, 2781], [2783, 2783, 2812, 2812, 3140], [3142, 3142, 3178, 3178, 3660], [3662, 3662, 3686, 3686, 4399], [4401, 4401, 4422, 4422, 5867], [5869, 5869, 5916, 5916, 6295], [6297, 6297, 6324, 6324, 6568], [6570, 6570, 6597, 6597, 6933], [6935, 6935, 6962, 6962, 7344], [7346, 7346, 7364, 7364, 7504], [7506, 7506, 7526, 7526, 8026], [8028, 8028, 8047, 8047, 8273], [8275, 8275, 8293, 8293, 8699], [8701, 8701, 8758, 8758, 9993]], "test": "untested"}
{"id": "7djfWW", "name": "Shardstone", "author": "MiguelCepero", "description": "A substance-like approach to 3d texturing", "tags": ["substance"], "likes": 14, "viewed": 266, "published": 3, "date": "1672532744", "time_retrieved": "2024-07-30T18:18:35.662640", "image_code": "\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvec3 random3f( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nvec3 voronoi( in vec3 x, out vec3 center )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n        //float d = abs(r.x) + abs(r.y) + abs(r.z);//dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            center = random3f( p + b );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nvec3 voronoisq( in vec3 x, out vec3 center )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = max(abs(r.x), max(abs(r.y), abs(r.z)));//dot( r, r );\n        //float d = abs(r.x) + abs(r.y) + abs(r.z);//dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            center = random3f( p + b );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat levels(in float x, in float xmin, in float xmax)\n{\n    return clamp((x - xmin)/(xmax - xmin), -1.0, 1.0);\n}\n\nfloat sphere(in vec3 pos, in vec3 center, in float radius)\n{\n    return pow(length(pos - center), 2.0) - radius*radius + 1.0 * pos.z;\n}\n\nfloat rocks(in vec3 pos)\n{\n    vec3 org;\n\n    float mask = levels(\n        simplex3d(5.0 * pos) + \n        0.5 * simplex3d(20.0 * pos) +\n        1.3 * (1.0 - voronoi(10.0 * pos, org).x), -0.01, 0.01);\n    mask = clamp(mask, 0.0, 1.0);\n\n    // warp\n    vec3 noise3 = voronoi(5.0 * pos, org);    \n    //return max(mask, noise3.x) + 50.0 * pos.z;\n    \n    float field = levels(\n        simplex3d(5.0 * pos) + \n        0.5 * simplex3d(20.0 * pos) +\n        1.3 * voronoi(30.0 * pos, org).x, -0.01, 1.2);\n        \n    //field = max(field, 1.5 * noise3.x);\n\n    // output field\n    return (field + 170.0*pos.z);\n}\n\nfloat dirt(in vec3 pos)\n{\n    vec3 org;\n    vec3 noise3 = voronoi(vec3(4.5, 3.3 + 0.5 * simplex3d(0.01*pos), 4.0) * pos + 0.02 * vec3(simplex3d(10.0*pos)), org);\n    //return (noise3.y) + pos.z;\n    float noise1 = simplex3d(100.0 * org);\n    vec3 scale = vec3(4.0 + 0.5*noise1);\n    float field = simplex3d(scale * pos * vec3(1.0, 0.01, 1.0) + vec3(noise1));\n    field = min(field, simplex3d(0.5*scale * pos * vec3(0.01, 1.0, 1.0) - vec3(noise1)));\n    return 0.01 * (field ) + pos.z;\n}\n\nfloat rockfield(in vec3 pos)\n{\n    //return min(dirt(pos), dirt(0.5*pos));\n    return dirt(pos);\n}\n\nfloat sand(in vec3 pos, in vec3 warp)\n{\n    // warp node\n    float noise = simplex3d(0.5*pos);\n    pos += 0.2 * noise * vec3(1.0, 1.0, 0.0) + warp;\n\n    // wave amplitude\n    float amp = clamp(1.0 + simplex3d(2.15*pos), 0.0, 1.0);\n\n    pos.x *= 0.1;\n    pos.y *= 5.0;\n    float field = simplex3d(pos);\n    field = 0.1*pow(1.5 + field, 5.0);\n    return field + amp * 200.0 * pos.z;\n}\n\nvec3 gradientRocks(vec3 pos)\n{\n    float e = 0.001;\n    float m;\n    float dx = rockfield(pos + vec3(e, 0.0, 0.0)) - rockfield(pos - vec3(e, 0.0, 0.0));\n    float dy = rockfield(pos + vec3(0.0, e, 0.0)) - rockfield(pos - vec3(0.0, e, 0.0));\n    float dz = rockfield(pos + vec3(0.0, 0.0, e)) - rockfield(pos - vec3(0.0, 0.0, e));\n    return vec3(dx, dy, dz)/e;\n}\n\nfloat field3d(in vec3 pos)\n{\n    //return sand(2.0*pos);\n    float rockfield = rockfield(pos);\n    return rockfield;\n    //return min(rocks(0.5 * pos), max(rocks(pos), rocks(2.0 * pos)));\n    //return sphere(pos, vec3(0.5, 0.5, 0.0), 0.05);\n    //return sin(20.0*pos.x) + sin(20.0*pos.y) + 100.0*pos.z;\n    //return pos.z;\n    //return simplex3d(10.0*pos) + 80.0 * pos.z;\n    \n    \n}\n\nvec3 gradient(vec3 pos)\n{\n    float e = 0.001;\n    float m;\n    float dx = field3d(pos + vec3(e, 0.0, 0.0)) - field3d(pos - vec3(e, 0.0, 0.0));\n    float dy = field3d(pos + vec3(0.0, e, 0.0)) - field3d(pos - vec3(0.0, e, 0.0));\n    float dz = field3d(pos + vec3(0.0, 0.0, e)) - field3d(pos - vec3(0.0, 0.0, e));\n    return vec3(dx, dy, dz)/e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/vec2(iResolution.x);\n\n    // input world coordinates\n    vec3 pos = vec3(uv.x, uv.y, 0.00*iTime);\n    \n    // scroll\n    pos += vec3(0.04*iTime, 0.04*iTime, 0.0);\n    \n    float field = field3d(pos);\n    vec3 normal = gradient(pos);\n    if (normal.z < 0.0)\n        normal.z = 0.0;\n    normal = normalize(normal);\n    vec3 light = normalize(vec3(sin(-0.01*iMouse.x), -1.0*cos(0.01*iMouse.y), -1.0));//normalize(vec3(sin(iTime), -10.5, cos(iTime)));\n    float l = dot(light, -normal);\n    \n    //vec3 color = 2.0 * field * vec3(1.0, 1.0, 1.0);\n    vec3 color = vec3(1.0, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(color * l, 1.0);\n    //fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n    //fragColor = vec4(20.0*field, 0.0, 0.0, 1.0);\n    //fragColor = vec4(vec3(0.5) + 0.5*normal, 1.0);\n    //fragColor = vec4(l, l, l, 1.0);\n    //fragColor = vec4(0.5 + 0.5*field, 0.0, 0.0, 1.0);\n    //fragColor = vec4(0.0, 0.5 + 0.5*normal.g, 0.0, 1.0);\n    //fragColor = vec4(noise, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 74, 96, 96, 269], [376, 399, 424, 677, 1594], [1864, 1931, 1964, 1964, 2111], [2113, 2113, 2138, 2138, 2323], [2325, 2325, 2369, 2369, 3059], [3061, 3061, 3107, 3107, 3838], [3840, 3840, 3896, 3896, 3953], [3955, 3955, 4015, 4015, 4090], [4092, 4092, 4118, 4118, 4699], [4701, 4701, 4726, 4726, 5187], [5189, 5189, 5219, 5263, 5287], [5289, 5289, 5328, 5345, 5671], [5673, 5673, 5703, 5703, 6034], [6036, 6036, 6064, 6092, 6419], [6421, 6421, 6446, 6446, 6765], [6767, 6767, 6824, 6874, 7892]], "test": "untested"}
{"id": "ctl3D2", "name": "firework explosion", "author": "jonasfrey", "description": "happy new year", "tags": ["firework"], "likes": 6, "viewed": 216, "published": 3, "date": "1672530242", "time_retrieved": "2024-07-30T18:18:36.759706", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    vec4 o_col = texture(iChannel0, o_trn_fc_nor);\n    \n    fragColor = vec4(o_col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 f_o_dist_it_tnor_firework(\n    vec2 o_trn_fc_nor_offset,\n    float n_duration, \n    vec2 o_rocket_direction, \n    float n_explosion_speed, \n    float n_explosion_start_nor,\n    float n_its//iterations\n){\n    float n_tau = 6.2831;\n    float n_mod = n_duration;\n\n    float n_tmod = mod(iTime,n_mod);\n    float n_it_min = 1.;\n    float n_dist_min = 1.;\n    for(float n_it =0.; n_it < n_its; n_it+=1.){\n        float n_rand_flicker = f_n_rand(n_it+fract(iTime)); \n    \n        float n_ang_nor_snapped = (1./n_its)*n_it;\n\n        float n_rand = f_n_rand(n_it*floor(iTime/n_mod));\n        float n_t_explosion = float(n_tmod > (n_mod*n_explosion_start_nor))*(n_tmod-(n_mod*n_explosion_start_nor));\n\n        float n_radius = n_t_explosion*n_explosion_speed;//no explosion\n        vec2 o_rocket_velocity = o_rocket_direction * n_tmod;\n        vec2 o_p= o_rocket_velocity;\n        \n        o_p += vec2(\n            cos((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius, \n            sin((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius\n        );\n\n        \n        vec2 o_gravity = vec2(\n            0., \n            //pow((1.+n_tmod), 2.), \n               pow((n_tmod), 2.)*9.81//i know that this is wrong :shrug:\n        );\n        o_p -= o_gravity;\n\n        float n_size = 0.1;\n\n        float n_dist = length(o_p-o_trn_fc_nor_offset);\n        if(n_tmod > (n_mod*n_explosion_start_nor)){\n            n_dist = n_dist*n_rand_flicker+0.5*0.01;\n            n_size = n_rand*0.1;\n            //n_dist = float(n_dist > n_rand_flicker*0.3);\n        }\n\n        n_dist = smoothstep(n_size, n_size*2., n_dist);\n\n        if(n_dist < n_dist_min){\n            n_dist_min = n_dist;\n            n_it_min = n_it;\n        }\n\n    }\n    //fadeout\n    float n_start_fadeout_nor = 0.8;\n    float n_t_diff = n_tmod - (n_mod*n_start_fadeout_nor);\n    if(n_t_diff > 0.){\n        float n_t_diff_nor = n_t_diff/((1.-n_start_fadeout_nor)*n_mod);\n        n_dist_min += n_t_diff_nor*n_t_diff_nor;\n    }\n\n    return vec3(n_dist_min, n_it_min, iTime/n_mod);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trn_fc_nor);\n    \n    vec2 o_trn_fc_nor_offset = o_trn_fc_nor - vec2(0.5);\n    vec2 o_trn_mo_nor_offset = o_trn_mo_nor - vec2(0.5);\n    o_trn_fc_nor_offset*=80.;\n    vec2 o_diff = vec2(0.)-o_trn_fc_nor_offset;\n    float n_tau = 6.2831;\n    \n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau));\n    \n    vec4 o_col_min = vec4(1.);\n    \n    float n_its = 20.;\n    float n_explosion_start_nor_min = 0.;\n    float n_explosion_start_nor1 = 0.5;\n    vec3 o_dist_it_tnor_firework = f_o_dist_it_tnor_firework(\n        o_trn_fc_nor_offset,\n        4., \n        vec2(2.5, 33.), \n        3., \n        n_explosion_start_nor1, \n        n_its\n    );\n    float n_explosion_start_nor2 = 0.2;\n    vec3 o_dist_it_tnor_firework2 = f_o_dist_it_tnor_firework(\n        o_trn_fc_nor_offset,//vec2 o_trn_fc_nor_offset,\n        5.,//float n_duration, \n        vec2(-4.5, 25.),//vec2 o_rocket_direction, \n        0.3,//float n_explosion_speed, \n        n_explosion_start_nor2,//float n_explosion_start_nor,\n        33.//float n_its//iterations\n    );\n    \n    vec3 o_dist_it_tnor_firework_min = vec3(1.);\n    n_explosion_start_nor_min = n_explosion_start_nor2;\n    o_dist_it_tnor_firework_min = o_dist_it_tnor_firework2;\n    if(o_dist_it_tnor_firework.x < o_dist_it_tnor_firework2.x){\n        o_dist_it_tnor_firework_min = o_dist_it_tnor_firework;\n        n_explosion_start_nor_min = n_explosion_start_nor1;\n    }\n\n    //vec4 o_col = vec4(o_dist_it_tnor_firework_min.x);\n    vec4 o_col = vec4(\n    o_dist_it_tnor_firework2.x*o_dist_it_tnor_firework.x);\n    o_col = 1.-o_col;\n    o_col *= vec4(\n        f_n_rand(o_dist_it_tnor_firework_min.y*3.)*0.2+0.8, \n        f_n_rand(o_dist_it_tnor_firework_min.y)*0.5, \n        f_n_rand(o_dist_it_tnor_firework_min.y*2.)*0.8, \n        1.\n    );\n   // if(fract(o_dist_it_tnor_firework_min.z) > n_explosion_start_nor_min){\n    //    o_col = o_col*0.5;\n    //}\n    \n    o_col += mix(\n        o_col_last, \n        o_col, \n        0.3\n    );\n    //if(o_dist_it_firework.x>.9){o_col = vec4(1.);}\n\n    //o_col+=o_col_last;\n    \n    fragColor = o_col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctl3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 256]], "test": "untested"}
