{"id": "sdSBWh", "name": "大龙猫 - The pulsing mine", "author": "totetmatt", "description": "pulse", "tags": ["pulse", "color", "mine"], "likes": 6, "viewed": 268, "published": 3, "date": "1646088743", "time_retrieved": "2024-07-30T17:00:48.391520", "image_code": "/**\nGaz smol raymarch + yolo\n\n\n*/\n\n#define R(p,a,t) (mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a))\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 pal(float t){ return vec3(.5,.5,.5)+vec3(.5,.5,.5)*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 p,c=vec3(0.);\n    vec3 d = normalize(vec3(fragCoord.xy -.5*iResolution.xy,iResolution.y));\n    for(float i=0.,e,g=0.,t=iTime;i++<50.;){\n        p=g*d;\n        p = R(p,normalize(vec3(.0,1.1,1.)),t*.2);\n        p.z +=+t;\n         \n         p= asin(sin(p));\n         p=R(p,normalize(vec3(.0,1.5+sin(p.x),-cos(p.x*3.)+1.7)),-.5);\n        p.zx -=1.;\n        vec4 pp = vec4(p,1.);\n        float gy = 0.;\n        for(float j=0.;j<8.;j++){\n            \n            gy = mix(-gy,dot(sin(pp.xyz*3.),cos(pp.yzx*5.)),.75)/5.;\n            pp.xyz = abs(pp.zxy)-.5;\n            pp.xy*=rot(-.785*.5);\n            pp.xz = pp.x < pp.z ? pp.zx:pp.xz;\n            pp.xy*=rot(-.785);\n            \n            pp*=1.2;\n        }\n        g+=e=max(.00005+.001*fract(length(p)+iTime*.5),min(length(p)-.15,max(gy/pp.a,-(length(p)-3.))));\n        c+=pal(p.z*.1+(i*i*e))*.02/exp(i*i*e);\n    }\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 115, 115, 162], [163, 163, 181, 181, 252], [253, 253, 308, 308, 1213]]}
{"id": "ssSfWh", "name": "Spiky Gyroid Zoom", "author": "leon", "description": "Inspired by Martijn Steinrucken video about Alien Orb [url]https://www.youtube.com/watch?v=b0AayhCO7s8[/url]", "tags": ["gyroid"], "likes": 12, "viewed": 413, "published": 3, "date": "1646087612", "time_retrieved": "2024-07-30T17:00:49.234267", "image_code": "\n// Spiky Gyroid Zoom by Leon Denise 2022/02/28\n// Variation of Spiky Gyroid https://www.shadertoy.com/view/NsBfW1\n// exploring gyroid shape as an organic pattern\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\n// Rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat map(vec3 p);\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z); }\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos) {\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor, in float scale) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float h = 0.01 + scale*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// geometry\nfloat map(vec3 p) {\n    float scale = 3.;\n    float dist = 100.;\n    float a = 1.0;\n    // fractalish gyroid accumulation\n    for (float i = 0.; i < 3.; ++i) {\n        vec3 s = p*scale/a;\n        s.z += iTime/a+p.x;\n        dist = smin(dist, abs(dot(sin(s),cos(s.yzx))/scale*a)-.01, .15);\n        a /= 3.;\n    }\n    dist = smin(abs(length(p)-1.0)-.4, dist, -.55);\n    return dist;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // coordinates\n    vec2 p = (pixel.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 pos = vec3(0);\n    vec3 ray = normalize(vec3(p, .2));\n    float rng = hash12(gl_FragCoord.xy);\n    \n    // raymarch\n    float shade = 1.;\n    for (shade; shade > 0.; shade -= 1./20.) {\n        float d = map(pos);\n        if (d < .001) break;\n        d *= .9+.1*rng;\n        pos += ray * d;\n    }\n    \n    // color\n    if (shade > 0.) {\n\t    vec3 normal = getNormal(pos);\n\t    vec3 tint = .75+.25*-normal;\n\t    tint += 2.*vec3(0.9,.7,.3)*getAO(pos, normal, 0.15);\n\t    color = vec4(tint*shade, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 434, 454, 454, 499], [520, 577, 599, 599, 716], [718, 783, 826, 826, 925], [927, 989, 1016, 1016, 1143], [1145, 1202, 1258, 1258, 1541], [1543, 1555, 1574, 1574, 1937], [1940, 1940, 1989, 1989, 2616]]}
{"id": "sl33WX", "name": "Fork Fork eye r gchipunov 464", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 175, "published": 3, "date": "1646081506", "time_retrieved": "2024-07-30T17:00:50.012691", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(5000.0*iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(5000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(5000.0*iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(5000.0*iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(5000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(5000.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 895]]}
{"id": "fl33Wf", "name": "Fork Fork gradi gchipunov 234", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 135, "published": 3, "date": "1646081499", "time_retrieved": "2024-07-30T17:00:50.800584", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\nvec3 col5 = smoothstep(col,col4,col3);\n\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 507]]}
{"id": "NlcGDf", "name": "Fork Fork gredt gchipunov 562", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 128, "published": 3, "date": "1646081492", "time_retrieved": "2024-07-30T17:00:51.558557", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col,col2,col4/2.0));//;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 571]]}
{"id": "7lc3WX", "name": "Fork Fork Waves gchipunov 330", "author": "gchipunov", "description": "get audacity for audio program. \n\n\n\nfrom waves, sound, wave, music, colors, beginner, audio, visualizer, easy, sounds\nCreated by ADOB in 2015-04-10\n", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "soundscreatedbyadobin20150410"], "likes": 4, "viewed": 279, "published": 3, "date": "1646081435", "time_retrieved": "2024-07-30T17:00:52.386344", "image_code": "// oringal createor https://www.shadertoy.com/user/ADOB\n// remixer coder: https://www.shadertoy.com/user/gchipunov\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i*7.0 - iTime * 5.6));\n        float Y = uv.y + getWeight(squared(i) * 50.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(2.6 * abs(mod(uvTrue.x + i / 0.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / ((100.0 - abs(uvTrue.x - i)) * Y));\n       // float k = i;\n        if(i== 0.0f)\n       {\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\n                       glowWidth * (1.0 - tan(iTime * 0.19)*55.0));\n       }\n           else   if(i== 1.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.01)/5.0),\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n         else   if(i== 2.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\n                      glowWidth * (0.5 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        else\n        {\n \t\tcolor += vec3(glowWidth/2.0 * (1.0 + tan(iTime * 0.13)),\n                      glowWidth/2.0 * (4.0 - sin(iTime * 0.23)),\n                      glowWidth/2.0 * (1.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        \n\t}\t\n\tcolor = color + cos(color)/44.0;\n    color = color - tan(iTime * 0.13)/555.0;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 23674, "src": "https://soundcloud.com/zubnid/zeldabetamax", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lc3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 143, 143, 167], [169, 169, 200, 200, 259], [261, 261, 287, 287, 385], [387, 387, 444, 444, 2340]]}
{"id": "NdBfW1", "name": "Water Effect with Pixel Offset", "author": "Spi3lot", "description": "Water Refraction Effect with Pixel Offset only", "tags": ["refraction", "distortion", "pixel", "water", "effect", "image", "offset", "spi3lot", "watereffect"], "likes": 12, "viewed": 509, "published": 3, "date": "1646073827", "time_retrieved": "2024-07-30T17:00:53.218120", "image_code": "#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n#define REZ iResolution.xy\n\n// ANGLE... angle where the water comes from, not where it goes!\n#define ANGLE PI * 0.4  \n#define MAX_OFFSET 30.\n#define ZOOM 1.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 normalizedPixel = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * normalizedPixel;\n\n    // Calculating the pixel offset\n    //\n    // Some variables are named noise because I had originally planned to make\n    // a kind of blurry distortion effect but then I tried using a texture\n    // that is not noise, and then (an early version of) this came out!\n    // I discovered this accidentally!\n    vec2 angleTransform = vec2(cos(ANGLE), sin(ANGLE));\n    vec2 movement = iTime * angleTransform * REZ;  // in px per second\n    vec2 noiseUV = mod(movement + fragCoord / ZOOM, iChannelResolution[1].xy);\n    float noise = texelFetch(iChannel1, ivec2(noiseUV), 0).r;\n    vec2 offset = MAX_OFFSET * normalizedPixel * noise;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv + offset);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 263, 313, 1114]]}
{"id": "NsBfW1", "name": "Spiky Gyroid", "author": "leon", "description": "Inspired by Martijn Steinrucken video about Alien Orb [url]https://www.youtube.com/watch?v=b0AayhCO7s8[/url]", "tags": ["gyroid"], "likes": 14, "viewed": 373, "published": 3, "date": "1646073765", "time_retrieved": "2024-07-30T17:00:54.057875", "image_code": "\n// Spiky Gyroid by Leon Denise 2022/02/28\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\n// Rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat map(vec3 p);\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z); }\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos) {\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\n\n// Shane\nfloat sAbs(float x, float c){ return sqrt(x*x + c); }\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor, in float scale) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float h = 0.01 + scale*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// geometry\nfloat map(vec3 p) {\n  vec3 pp = p;\n  float dist = p.y;\n  float scale = 10.;\n  float gyroid = 100.;\n  float a = 1.0;\n  // fractalish gyroid accumulation\n  for (float i = 0.; i < 3.; ++i) {\n    vec3 s = p*scale/a;\n    s.y += iTime+pp.z/a;\n    \n    // hard edges version\n    gyroid = smin(gyroid, abs(dot(sin(s),cos(s.yzx))/scale*a)-.1*a, .2*a);\n    \n    // nice smooth version by Shane\n    //gyroid = smin(gyroid, sAbs(dot(sin(s), cos(s.yzx))/scale*a, .00015) - .1*a, .3*a);\n    \n    a /= 2.;\n  }\n  dist = smin(abs(dist)-.2, gyroid, -.4);\n  return dist;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    // coordinates\n    vec2 p = (pixel.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 pos = vec3(1);\n    vec3 z = normalize(-pos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 2. + x * p.x + y * p.y);\n    float rng = hash12(pixel);\n    // raymarch\n    float shade = 1.;\n    for (shade; shade > 0.; shade -= 1./33.) {\n        float d = map(pos);\n        if (d < .001) break;\n        d *= .9+.1*rng;\n        pos += ray * d;\n    }\n    // color\n    vec3 normal = getNormal(pos);\n    vec3 tint = .6+.2*normal;\n    tint += vec3(1,.5,0)*getAO(pos, -normal, 0.05);\n    color = vec4(tint*shade, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 314, 334, 334, 379], [400, 457, 479, 479, 596], [598, 663, 706, 706, 805], [807, 869, 896, 896, 1023], [1026, 1035, 1064, 1064, 1088], [1090, 1147, 1203, 1203, 1486], [1488, 1500, 1519, 1519, 2053], [2056, 2056, 2105, 2124, 2769]]}
{"id": "fsBfW1", "name": "Canadian flag, Maple Leaf 252chr", "author": "xavierseb", "description": "Canadian Flag , Golfed\nYou Shall Not Improve on This! hehhehe! \n\nAnyone??", "tags": ["canada", "maple"], "likes": 3, "viewed": 224, "published": 3, "date": "1646073657", "time_retrieved": "2024-07-30T17:00:54.858734", "image_code": "// Thank you Truckers!\n// xavierseb Feb 2022\n\n// 252 chars\nvoid mainImage( out vec4 C, vec2 u )\n{\n    u-=C.rg=iResolution.xy/2.;\n    u/=C.g/12.; \n    u.y-=5.; \n    C+=1.-C; \n    C.a=u.x=abs(u.x);      \n    for( int t=0; ++t<5; u = u*mat2(.5,-.86,.84,.5) - vec2(6,3))\n                    C.b=C.g = min(t>3 && (u*=2.4).y>-13.? 1.:C.g, \n                    min(3.-u.y+cos(u.x*2.5),2.5)>abs(u.x) || C.a>10.?0.:1.);\n}\n\n/*\n// with almost all antialias 273 chars\n#define U abs(u.x)\nvoid mainImage( out vec4 C, vec2 u )\n{\n    u-=C.rg=iResolution.xy/2.;\n    u/=C.g/12.; \n    u.y-=5.; \n    C +=1.-C;\n    C.a=u.x=U;      \n    for( int t=0; ++t<5; u = u*mat2(.5,-.86,.84,.5) - vec2(6,3))\n                    C.b=C.g = min(t>3 && (u*=2.4).y>-13.? 1.:C.g, \n                    smoothstep(0.,.1,U-max(C.a-10.+U,min(3.-u.y+cos(U*2.5),2.5))));\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 59, 97, 97, 412]]}
{"id": "NsSBWh", "name": "Shattering Glass", "author": "me_123", "description": "generates a random image every time. uses a simple algorithm, and looks amazing. looks much better  in full screen", "tags": ["2d", "blur", "color", "random", "glass", "multipass"], "likes": 15, "viewed": 532, "published": 3, "date": "1646066866", "time_retrieved": "2024-07-30T17:00:55.753342", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tfragColor /= fragColor.w;\n    fragColor = 0.5/fragColor;\n    fragColor = pow(fragColor, vec4(4.0));\n    if (SHOW_RAW) {\n    \tfragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0).xywz;\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Chance of subdividing\n#define SPLIT_CHANCE 0.01\n\n//Chance of creating random cell\n#define NEW_CELL_CHANCE 0.0000001\n\n//show raw buffer values\n#define SHOW_RAW false\n\nfloat hash(vec2 p) {\n    p *= 0.01;\n    p = sin(p*vec2(138.512415, 535.2451124))*24.51323234234;\n    return fract(sin((p.x*p.y)*23.51245)*234.5512+0.1);\n}", "buffer_a_code": "//resolution and frame tracker\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    ivec2 fc = ivec2(fragCoord);\n    if (fc == ivec2(0, 0))fragColor = vec4(fragColor.zw, iResolution.xy);\n    if (fc == ivec2(1, 0)) {\n        ivec4 r = ivec4(texelFetch(iChannel0, ivec2(0), 0));\n        fragColor += 1.0;\n        if (r.xy != r.zw) fragColor = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 fc = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, fc, 0);\n    ivec4 r = ivec4(texelFetch(iChannel2, ivec2(0), 0));\n    if (r.xy != r.zw) { //resolution changes: \n    \tfragColor = vec4(-1);\n        return;\n    }\n    if (hash(fragCoord+0.0051+iTime) < NEW_CELL_CHANCE && iFrame%2 == 0) {\n        fragColor = vec4(fragCoord, normalize(vec2(hash(fragCoord+0.002), hash(fragCoord+0.003))-0.5)*hash(fragCoord+0.152));\n    } else {\n        if (iFrame == 0) fragColor = vec4(-1);\n    }\n    if (fragColor.w >= 1.0) {\n    \tfragColor.w += 1.0; // add to life time\n        fragColor.x = -hash(vec2(fragColor.z)); //component Z stays to velocity, so random value can be generated\n    } else {\n        for (int x = -1; x <= 1; x += 1) {\n            for (int y = -1; y <= 1; y += 1) {\n                //find pixel to move to\n                vec4 p = texelFetch(iChannel0, fc+ivec2(x, y), 0);\n                if (p.x > 0.0 && p.w < 1.0) {\n                    vec2 np = p.xy+p.zw;\n                    if ((fc == ivec2(round(np))||fc==ivec2(ceil(np)))&&(texelFetch(iChannel0, ivec2(np), 0).w<=5.0)) {\n                        fragColor = vec4(np, p.zw);\n                        return;\n                    } else {\n                        vec2 c = vec2(fragColor.zw);\n                        if (c.y != -1.)c = vec2(c.x, 2);\n                        fragColor = vec4(vec2(-1), c);\n                        if (hash(fragCoord.xy+0.125+iTime) < SPLIT_CHANCE) {\n                            //make perpindicular ray from point left or right\n                            mat2 m = hash(fragCoord.xy+0.1255+iTime) < 0.5 ? mat2(0, 1, -1, 0) : mat2(0, -1, 1, 0);\n                            fragColor = vec4(ivec2(fragCoord.xy), p.zw*m);\n                        } return;\n                    }\n                }\n            }\n        }\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const vec3[5] r = vec3[5](vec3(0.15, 0.2, 0.5), vec3(0.0, 0.3, 0.27), vec3(0.5, 0.05, 0.05), vec3(0, 0, 0), vec3(0.5, 0.1, 0.25));\nvec3 color(in float p) { // color map\n\tint c = int(p*5.);\n    float f = fract(p*5.);\n    return vec3(mix(r[c], r[(c+1)%5], f));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 r = ivec4(texelFetch(iChannel2, ivec2(0), 0));\n    if (r.xy != r.zw) {\n    \tfragColor = vec4(1);\n        return;\n    }\n    vec2 of = fragCoord;\n    \n    float t = texelFetch(iChannel2, ivec2(1, 0), 0).x/60.;\n    \n    //multipass box blur\n    fragCoord += (vec2(hash(fragCoord+iTime), hash(fragCoord+0.1+iTime))-0.5)*float(pow(t*0.2, 2.0));\n    \n    fragColor = texelFetch(iChannel1, ivec2(of), 0);\n    \n    //\n    float l = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).x;\n    float h = abs(l); //decode random ID\n    vec3 c = vec3(1);\n    if (h != 1.0)c = color(h); //map color to ray\n    fragColor += vec4(c, 1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 318]]}
{"id": "ss2fWz", "name": "Racing Thoughts", "author": "scry", "description": "playing with some mobius transformations.\nmaking of:\nhttps://twitter.com/Scrygl/status/1498285695282020354", "tags": ["3d", "mobius", "cohomology"], "likes": 6, "viewed": 246, "published": 3, "date": "1646055221", "time_retrieved": "2024-07-30T17:00:56.586115", "image_code": "////////////////////////////////////////////////////////////////////////////////\n#define time iTime\n#define ptime iTime*pi/5.\n#define pi 3.141592654\n#define def pi/180.\n\n//from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define dtime time*hill(time,10.)\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,w));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \nvec3 slogo(vec2 uv, float ar, float size) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls*(1./size);\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    //float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+time,1.,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.z -= .2;\n    //p *= 0.4;\n    p.xy *= r2d(sin(ptime+p.z*4.)*p.z*0.1);\n    vec3 c = p;\n    \n    p.xz *= r2d(ptime+c.z*pi*1.);\n    float rp = 2.;\n    \n    float pm = length(p);\n    //p.xz *= r2d(sin(o.y)*4.);\n    p = p/dot(p,p);\n    //p -= 0.5;\n    //p += 100.1;\n    //p.z -= 0.;\n    //p.yz *= r2d(sin(ptime)+pm*10.);\n    //p.z += 0.4;\n    p.xz += .1;\n    p.yz *= r2d(ptime+(c.y)*pi);\n    p.xz *= r2d(ptime+(c.x)*pi);\n    p.z -= .1;\n    p = p/dot(p,p);\n    //p.xy += rp/2.;\n    p = (fract(p/rp)-0.5)*rp;\n    //p += sin(abs(c)+time*20.)*.6;\n    float d = length(p)-0.03;\n    //d *= 0.2;\n    d *= 1.25-pm*0.3;\n    //d *= 0.01;\n    //d += 0.01;\n    //d += 0.1;\n    ///d = 2.;\n    //d *= pow(pm+0.01,2.)-0.1;\n    //d += 0.001-pm*0.001;\n    //d -= 0.3-pm*0.9;\n    //d *= pm-.2;\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<350;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.16;\n        ii += 0.016;\n        if (dO > 100. || dS < 0.01) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    vec2 tv = uv;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    //uv = abs(uv)-sin(-ptime+length(uv)*6+2.)*0.1;\n    float dv = 4.;\n    vec2 fv = floor(uv*dv);\n    //uv -= fv/dv;\n    //uv -= 1./dv*0.5;\n    //uv *= r2d(sin(time*fv.y*fv.x)*pi+pi/2.);\n    //uv += fv/dv;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    col = vec3(d.y*0.2);\n    col.r += sin(d.y*4.)/10.;\n    col.b += d.x*0.02;\n    col.g *= d.y*0.3;\n    col -= sin(col*40.+ptime)*0.02;\n    //col = sin(col*1.2);\n    col = sin(col*3.+3.7+d.x*7.);\n    col = cos(col*1.57);\n    col = rgb2hsv(vec3(col.x,col.y,col.z));\n    col.x *= 0.56;\n    col.x += 0.5;\n    col = hsv2rgb(col);\n    col = clamp(col,0.,1.);\n    //col *= 0.5;\n    //col += 0.3;\n    col += slogo(tv,ar,1.)/24.;\n    //col.g += sin(d.y*0.1);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2fWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 312, 334, 334, 665], [670, 729, 751, 751, 920], [923, 959, 986, 986, 1343], [1346, 1346, 1389, 1389, 2265], [2267, 2267, 2286, 2286, 2335], [2337, 2337, 2355, 2355, 3171], [3173, 3173, 3200, 3200, 3445], [3447, 3447, 3502, 3502, 4451]]}
{"id": "fsjfDR", "name": "obj rasterizer", "author": "icantcomeupwithausername", "description": "rasterizing a obj file", "tags": ["rasterizer", "gouraud", "obj"], "likes": 9, "viewed": 451, "published": 3, "date": "1646016369", "time_retrieved": "2024-07-30T17:00:57.370019", "image_code": "/*\n * common, obj verticies and indices\n * buffer a, camera control\n * buffer b, rendering\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define fov 80.0\n#define clearCol vec3(0.509803922, 0.509803922, 0.717647059);\n\n#define pi acos(-1.0)\n\n/*\n * obj file indices and verticies converted to arrays\n */\n\nconst vec3 verticies[48] = vec3[48](\n\tvec3(-0.547476,-0.550000,0.552480),\n\tvec3(-0.247488,-0.550000,0.551115),\n\tvec3(-0.551115,0.550000,-0.247488),\n\tvec3(-0.548841,0.550000,0.252492),\n\tvec3(0.552479,0.550000,0.547476),\n\tvec3(0.251127,0.550000,0.248853),\n\tvec3(0.547476,0.550000,-0.552480),\n\tvec3(-0.251127,-0.550000,-0.248853),\n\tvec3(0.251127,-0.550000,0.248853),\n\tvec3(0.551115,0.550000,0.247488),\n\tvec3(-0.548841,-0.000000,0.252492),\n\tvec3(-0.251127,0.550000,-0.248853),\n\tvec3(0.548840,0.550000,-0.252492),\n\tvec3(-0.551115,-0.000000,-0.247488),\n\tvec3(-0.547476,-0.000000,0.552480),\n\tvec3(0.552479,-0.000000,0.547476),\n\tvec3(0.252492,-0.000000,0.548840),\n\tvec3(0.552479,-0.550000,0.547476),\n\tvec3(-0.247488,-0.000000,0.551115),\n\tvec3(0.252492,-0.550000,0.548840),\n\tvec3(0.547476,-0.000000,-0.552480),\n\tvec3(0.247488,-0.550000,-0.551115),\n\tvec3(0.547476,-0.550000,-0.552480),\n\tvec3(0.247488,-0.000000,-0.551115),\n\tvec3(-0.248853,0.550000,0.251127),\n\tvec3(-0.248853,-0.000000,0.251127),\n\tvec3(0.248852,0.550000,-0.251127),\n\tvec3(0.252492,0.550000,0.548840),\n\tvec3(0.251127,-0.000000,0.248853),\n\tvec3(-0.252492,0.550000,-0.548840),\n\tvec3(-0.252492,-0.000000,-0.548840),\n\tvec3(0.548840,-0.000000,-0.252492),\n\tvec3(-0.552480,0.550000,-0.547476),\n\tvec3(0.248852,-0.000000,-0.251127),\n\tvec3(-0.252492,-0.550000,-0.548840),\n\tvec3(-0.547476,0.550000,0.552480),\n\tvec3(-0.548841,-0.550000,0.252492),\n\tvec3(-0.551115,-0.550000,-0.247488),\n\tvec3(-0.552480,-0.550000,-0.547476),\n\tvec3(-0.552480,-0.000000,-0.547476),\n\tvec3(0.548840,-0.550000,-0.252492),\n\tvec3(0.551115,-0.000000,0.247488),\n\tvec3(0.551115,-0.550000,0.247488),\n\tvec3(-0.248853,-0.550000,0.251127),\n\tvec3(0.248852,-0.550000,-0.251127),\n\tvec3(-0.247488,0.550000,0.551115),\n\tvec3(0.247488,0.550000,-0.551115),\n\tvec3(-0.251127,-0.000000,-0.248853)\n);\n \nconst ivec3 indicies[96] = ivec3[96](\n\tivec3(45,23,41),\n\tivec3(45,22,23),\n\tivec3(1,44,2),\n\tivec3(1,37,44),\n\tivec3(33,12,30),\n\tivec3(3,12,33),\n\tivec3(4,46,25),\n\tivec3(4,36,46),\n\tivec3(6,5,10),\n\tivec3(28,5,6),\n\tivec3(47,13,7),\n\tivec3(47,27,13),\n\tivec3(35,38,39),\n\tivec3(35,8,38),\n\tivec3(20,43,18),\n\tivec3(20,9,43),\n\tivec3(6,10,34),\n\tivec3(34,10,32),\n\tivec3(26,12,11),\n\tivec3(11,12,3),\n\tivec3(29,43,9),\n\tivec3(42,43,29),\n\tivec3(26,4,25),\n\tivec3(11,4,26),\n\tivec3(34,13,27),\n\tivec3(32,13,34),\n\tivec3(38,48,14),\n\tivec3(38,8,48),\n\tivec3(36,19,46),\n\tivec3(15,19,36),\n\tivec3(17,18,16),\n\tivec3(17,20,18),\n\tivec3(39,31,35),\n\tivec3(40,31,39),\n\tivec3(24,7,21),\n\tivec3(24,47,7),\n\tivec3(15,2,19),\n\tivec3(15,1,2),\n\tivec3(16,28,17),\n\tivec3(16,5,28),\n\tivec3(20,46,19),\n\tivec3(20,17,46),\n\tivec3(21,22,24),\n\tivec3(21,23,22),\n\tivec3(47,35,31),\n\tivec3(47,24,35),\n\tivec3(30,40,33),\n\tivec3(30,31,40),\n\tivec3(9,25,29),\n\tivec3(9,26,25),\n\tivec3(8,27,48),\n\tivec3(8,34,27),\n\tivec3(34,22,45),\n\tivec3(24,22,34),\n\tivec3(29,28,6),\n\tivec3(17,28,29),\n\tivec3(26,2,44),\n\tivec3(19,2,26),\n\tivec3(30,48,31),\n\tivec3(30,12,48),\n\tivec3(5,42,10),\n\tivec3(16,42,5),\n\tivec3(32,23,21),\n\tivec3(32,41,23),\n\tivec3(1,11,37),\n\tivec3(11,1,15),\n\tivec3(14,33,40),\n\tivec3(14,3,33),\n\tivec3(34,35,24),\n\tivec3(8,35,34),\n\tivec3(26,20,19),\n\tivec3(9,20,26),\n\tivec3(15,4,11),\n\tivec3(15,36,4),\n\tivec3(37,3,14),\n\tivec3(3,37,11),\n\tivec3(38,40,39),\n\tivec3(38,14,40),\n\tivec3(21,13,32),\n\tivec3(21,7,13),\n\tivec3(10,41,32),\n\tivec3(41,10,42),\n\tivec3(43,16,18),\n\tivec3(42,16,43),\n\tivec3(48,12,44),\n\tivec3(44,12,26),\n\tivec3(29,6,45),\n\tivec3(45,6,34),\n\tivec3(25,46,29),\n\tivec3(47,48,27),\n\tivec3(29,46,17),\n\tivec3(29,41,42),\n\tivec3(31,48,47),\n\tivec3(48,37,14),\n\tivec3(45,41,29),\n\tivec3(44,37,48)\n);", "buffer_a_code": "vec3 getRotation(){\n   vec4 r = texelFetch(iChannel0, ivec2(0,0), 0) * 255.0 - 100.0;     \n   return r.xyz;\n}\n\nvec3 getPRotation(){\n   vec4 r = texelFetch(iChannel0, ivec2(0,1), 0) * 255.0 - 100.0;     \n   return r.xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if(int(fragCoord.x) > 0 || int(fragCoord.y) > 1){\n        discard;\n    }\n\n    if(iFrame > 0){\n        vec3 rot = getRotation();\n        switch(int(fragCoord.y)){\n            case 0:                \n                if(iMouse.z > 0.0){\n                    rot = getPRotation() + vec3((iMouse.xy-abs(iMouse.zw)).yx * 0.8, 0.0);\n                    rot.x = clamp(rot.x, -90.0, 90.0); //prevent camera from flipping\n                }\n\n                fragColor = vec4((rot + 100.0) / 255.0, 1.0);\n            break;\n            \n            case 1:\n                if((iMouse.z > 0.0) == false){\n                    fragColor = vec4((rot + 100.0) / 255.0, 1.0);\n                }else{\n                    fragColor = vec4((getPRotation() + 100.0) / 255.0, 1.0);\n                }\n            break;\n        }\n    }else{\n        switch(int(fragCoord.y)){\n            case 0:\n                fragColor = vec4((vec3(-45.0, -45.0, 0.0) + 100.0) / 255.0, 1.0);\n            break;\n            \n            case 1:\n                fragColor = vec4((vec3(-45.0, -45.0, 0.0) + 100.0) / 255.0, 1.0);\n            break;\n         }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define lightPos vec3(-1.0, 1.7, -1.7)\n#define triColor vec3(0.8)\n\nmat4 perspective(float aspect){\n    float ft = tan(pi*0.5-0.5*radians(fov));\n    float r = 1.0/(0.1-9e20);\n    \n    return mat4(ft/aspect,0.0,0.0,0.0,\n                0.0,ft,0.0,0.0,\n                0.0,0.0,(0.1+9e20)*r,-1.0,\n                0.0,0.0,0.1*9e20*r*2.0,0.0);\n}\n\nmat4 translate(vec3 pos){\n    return mat4(1.0,0.0,0.0,pos.x,\n                0.0,1.0,0.0,-pos.y,\n                0.0,0.0,1.0,pos.z,\n                0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateY(float rotation){\n    rotation = radians(rotation);\n\tfloat ysine = sin(rotation);\n\tfloat ycos = cos(rotation);\n\tfloat yoc = 1.0-ycos;\n\treturn mat4(ycos,0.0,ysine,0.0,\n\t\t\t\t0.0,yoc+ycos,0.0,0.0,\n\t\t\t\t-ysine,0.0,ycos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateX(float rotation){\n    rotation = radians(rotation);\n\tfloat xsine = sin(rotation);\n\tfloat xcos = cos(rotation);\n\tfloat xoc = 1.0-xcos;\n\treturn mat4(xoc+xcos,0.0,0.0,0.0,\n\t\t\t    0.0,xcos,-xsine,0.0,\n\t\t\t\t0.0,xsine,xcos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nfloat edge(vec2 a, vec3 b, vec2 c){\n    return (c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x);\n}\n\nvec3 interpolate(vec3 v1,vec3 v2,vec3 v3,vec3 a,vec3 b,vec3 c,vec2 uv){\n    float h = ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    float weight1 = ((v2.y-v3.y)*(uv.x-v3.x)+(v3.x-v2.x)*(uv.y-v3.y))/h;\n    float weight2 = ((v3.y-v1.y)*(uv.x-v3.x)+(v1.x-v3.x)*(uv.y-v3.y))/h;\n    float weight3 = 1.0-weight1-weight2;\n\n    return a*weight1+b*weight2+c*weight3/(weight1+weight2+weight3);\n}\n\nvec2 getRotation(){\n   vec4 r = texelFetch(iChannel0, ivec2(0,0), 0) * 255.0 - 100.0;     \n   return r.xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.y *= -1.0;\n    \n    vec3 col = clearCol;\n    float pdepth = 9e20;\n    \n    vec2 rot = getRotation();\n    \n    //cheap optimization\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.8 && uv.y > -0.8){\n        for(int i=0; i<indicies.length(); i++){ //very long loop *yikes*\n            mat4 rotation = rotateY(rot.y) * rotateX(rot.x);\n            mat4 perspectiveMatrix = perspective(iResolution.x/iResolution.y);\n            mat4 translation = translate(vec3(0.0,0.0,7.0));\n\n            vec4 v41n = vec4(verticies[indicies[i].x - 1], 1.0);\n            vec4 v42n = vec4(verticies[indicies[i].y - 1], 1.0);\n            vec4 v43n = vec4(verticies[indicies[i].z - 1], 1.0);\n\n            vec4 v41 = v41n * rotation * translation * perspectiveMatrix;\n            vec4 v42 = v42n * rotation * translation * perspectiveMatrix;\n            vec4 v43 = v43n * rotation * translation * perspectiveMatrix;\n\n            vec3 v1 = (v41/v41.w).xyz;\n            vec3 v2 = (v42/v42.w).xyz;\n            vec3 v3 = (v43/v43.w).xyz;\n\n            float tsa = edge(v2.xy,v3,uv);\n            float tsb = edge(v3.xy,v1,uv);\n            float tsc = edge(v1.xy,v2,uv);\n            \n            vec3 rnormal = -normalize(cross(v42.xyz-v41.xyz, v43.xyz-v41.xyz));\n            \n            vec3 snormal = normalize(cross(v42n.xyz-v41n.xyz, v43n.xyz-v41n.xyz));\n            \n            //compute lighting at each vertex\n            vec3 col1 = triColor * max(dot(normalize(lightPos - v41n.xyz), snormal), 0.2) * 1.2; \n            vec3 col2 = triColor * max(dot(normalize(lightPos - v42n.xyz), snormal), 0.2) * 1.2; \n            vec3 col3 = triColor * max(dot(normalize(lightPos - v43n.xyz), snormal), 0.2) * 1.2; \n\n            if(((tsa>=0.0)==(tsb>=0.0))&&((tsb>=0.0)==(tsc>=0.0))&&(dot(rnormal,vec3(0.0,0.0,1.0))>-1e-4)){\n                float area = edge(v1.xy,v2,v3.xy);\n\n                tsa/=area;\n                tsb/=area;\n                tsc/=area;\n\n                float depth = v1.z*tsa+v2.z*tsb+v3.z*tsc;\n                depth = 1.0/depth;\n                \n                if(depth<pdepth){ \n                    col = interpolate(v1,v2,v3,col1,col2,col3,uv);\n                    pdepth = depth;\n                }\n            }\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 150, 150, 214]]}
{"id": "fdjBDR", "name": "Ulam Spiral & Cantor Diagonal", "author": "elenzil", "description": "Showing primes in the Ulam Spiral and the Cantor Diagonalization.", "tags": ["spiral", "primes", "integer", "cantor", "integers", "ulam", "diagonalize"], "likes": 6, "viewed": 176, "published": 3, "date": "1646008253", "time_retrieved": "2024-07-30T17:00:58.194814", "image_code": "// Fork of \"Ulam Spiral\" by elenzil. https://shadertoy.com/view/ssjBRm\n// 2022-02-28 00:22:54\n\nint sqr(int n) {\n    return n * n;\n}\n\n// thanks to @Envy24 for optimized version of this routine.\nbool isPrime(int N) {\n    switch (N)\n    {\n    case 0:\n    case 1:\n        return false;\n    case 2:\n    case 3:\n    case 5:\n    case 7:\n        return true;\n    default:\n        break;\n    }\n\n    if ((N & 1) == 0) { return false; }\n\n    int n = 3;\n    bool r = true;\n    int limit = int(sqrt(float(N)));\n\n    do \n    { \n        r = (N % n) != 0;\n        n += 2;\n    } while (r &&\n        n <= limit);\n\n    return r;\n}\n\nint getNForPixel_Cartesian(in ivec2 IJ, int width) {    \n    return IJ.x + (IJ.y * width);\n}\n\nint getNForPixel_Diagnolize(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int i_j = I + J;\n    return (i_j * 1) * i_j / 2 + J + 1;    \n}\n\nint getNForPixel_Spiral(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J));\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    return n;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    int pixelsPerPixel = iMouse.z > 1.0 ? 1 : 3;\n    ivec2 IJ_centered = ivec2(XY) / pixelsPerPixel - ivec2(iResolution.xy) / 2 / pixelsPerPixel;\n    ivec2 IJ_cornered = ivec2(XY) / pixelsPerPixel;\n    \n    int n;\n\n    if (int(iTime / 10.0) % 2 == 0) {\n        n = getNForPixel_Spiral(IJ_centered);\n    }\n    else {\n        n = getNForPixel_Diagnolize(IJ_cornered);\n    }\n\n    float c = isPrime(n) ? 0.0 : 1.0;\n\n    c = mix(0.15 * c, c, smoothstep(5.0, -5.0, sqrt(float(n)) - 3.0 * float(iFrame)));\n    \n    float f = float(n * pixelsPerPixel) / (iResolution.x * iResolution.y);\n    f = 0.8 + 0.2 * smoothstep(-0.1, 0.1, cos(f * 100.0 - iTime * 4.0));\n    \n    // indication the XY -> N mapping is right:\n    if (int(iTime / 20.0) % 2 == 0) {\n        f = c;\n    }\n    \n    RGBA = vec4(vec2(c), f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 111, 111, 131], [133, 193, 214, 214, 611], [613, 613, 665, 665, 705], [707, 707, 749, 749, 857], [859, 859, 897, 897, 1529], [1531, 1531, 1574, 1574, 2379]]}
{"id": "stdSRf", "name": "spqr: passages", "author": "spqr", "description": "a", "tags": ["a"], "likes": 5, "viewed": 210, "published": 3, "date": "1646001371", "time_retrieved": "2024-07-30T17:00:58.954782", "image_code": "\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return max(max(q.x,q.y),q.z);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat a = 3.141592;\n\n\nfloat tick(float t,float n){\n    float i = floor(t);\n    float r = pow(fract(t),n);\n    return i+r;\n}\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\nvec3 moda ( vec3 p, float rep ) {\n    vec2 rp = vec2(atan(p.z,p.x)/(2.*PI), length(p.xz));\n    rp.x =(fract(rp.x*rep-0.5)-0.5)/rep;\n    rp.x *= 2. *PI;\n    return vec3(cos(rp.x)*rp.y, p.y, sin(rp.x)*rp.y);\n}\n\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<7;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.53;//\n        q*=2.1;\n    }\n    return res;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\n\n\nfloat pi = 3.141592;\nfloat surge (float t) {\n\n   float i = floor(t);\n   float r = fract(t);\n   r = smoothstep(0.,1.,r);\n   r = pow(r, 3.);\n   \n   return i + r;\n   \n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\n\n\n\nfloat pulse ( float x, float t ){\n    x *= .1;\n    \n    float f1 = 11.;\n    t = -t;\n    float u = atan(f1 * sin((sin(x) + t * 2.))/atan(f1)) * .5 + .5;\n \n    return u;\n\n}\n\n\nint matter;\n\n\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd *= 1.7;\n  off.x += sin(dd)*13.;\n  off.x += cos(dd*2.1)*6.1;\n  off.y += sin(dd*0.7)*26.;\n  off.y += cos(dd*1.5)*11.;\n  \n  \n  return off;\n}\nfloat glow = 0.;\nfloat map (vec3 p){\n\n\n    vec3 q = p;\n    vec3 u = p;\n\n // geo\n \n  \n    // ground  \n    \n    float ground = -p.y;\n  \n  \n  \n    // kiosks\n    \n    vec3 pk = p;\n    vec2 domk = vec2(39.);\n    pk.xz = mod(pk.xz, domk) - domk/2.;\n   \n    \n    float kiosks = box(pk+vec3(0,+6,0),vec3(10.34,.1,10.34));\n  \n  \n  \n    // tunnel\n    \n    p += tunnel(p);\n    float passage = cyl(p.xy , 6.);\n    \n    \n    u += tunnel(u);\n    u.xz = mod(u.xz , 120.) - 65.;\n    float passages = cyl(u.xy , 6.);\n    \n    \n    \n    // holes\n    q.y -= 10.;\n    q.x += 10.;\n    q.xz = mod(q.xz, 40.) - 20.;\n    \n    float holes = tor(q.zyx, vec2(10,6.));\n    \n    \n    \n    \n    \n    // final\n    \n    //float final = max(ground,-passage);\n    float final = smin(ground,-passage, -3.);\n    final = smin(final,-passages, -3.);\n    \n    final = smin(final, -holes, -3.);\n    \n    \n    final = min(final, kiosks);\n    \n    if ( final == kiosks) {\n        matter = 1;\n    }\n   \n   \n    return final ;\n   \n  \n\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <6.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv*.8);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\n\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 2.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) {\n\n    float a = hash31(vec3(p.x, p.y,cos(32.) * 77.191));\n    float b = hash31(vec3(p.y, p.x,cos(21.) * 45.432));\n    return fract(a+b);\n    //float a = fract( sin(p.x*5612.431) * 937.442 + sin(p.y*2489.289) * 818.632);\n    //float b = fract(sin(a * 2093.441) * 9433.313);\n    //return b;\n}\nvec2 kifs(vec2 p) {\n    for ( float i=0.; i < 3.;i++) {\n        p *= rot((i + iTime * .3) * pi/2.);\n        p = abs(p) - 60.;\n        p *= 1.2;\n    }\n    return p;\n}\n// ink\nconst float domain_width = 197.;\nconst float domain_height = 41.;\nconst vec3 domain = vec3(domain_width,domain_height,domain_width);\nfloat decal(vec3 p, vec3 domain) {\n\n  \n  vec3 id = floor(p/(domain));\n  float f1 = fract(hash31(id) + iTime/23.1 + hash31(id));\n\n  p = mod(p,domain) - domain/2.;\n  \n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(400.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  \n\n\n vec3 source = vec3(0,0,-10);\n vec3 target = vec3(0,0,0);\n\n float time = iTime;\n float advance = time * 23. ;\n source.z += advance;\n target.z += advance;\n source -= tunnel(source);\n target -= tunnel(target);\n \n vec3 arm = lattice(time * 2.) * 25.;\n arm.y *= .1;\n arm.x *= 4.;\n arm.y -= ( sin(iTime ) * .5 + .5) * 25.;\n arm.y -= 40.;\n\n  \n \n \n source += arm  * smoothstep(0., -30.,source.y);;\n \n\n  \n\n  \n  vec3 cz=normalize(target-source);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  \n  vec3 cy=normalize(cross(cz,cx));\n  \n\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n  // fisheye\n  r.z+=.1*length(uv);\n \n  \n  // march\n  \n  \n  float dd;\n  vec3 p = source;\n  float i;\n  float d;\n  bool hit = false;\n  for(float z=0.; z < 500.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n      //d + .1;\n      break;\n    }\n    if ( dd > 1000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  \n\n    \n  vec3 alt_domain = domain;\n  //alt_domain.x -= .1;\n\n  float decal_val = decal(p,alt_domain);\n  vec3 col;\n  if ( decal_val < 0.) {\n     col = vec3(.8,.4,.2);\n  }\n  \n\n\n\n\n\n  vec3 n = norm(p);\n  vec3 light =normalize(vec3(0,-1,0));\n\n  \n\n \n  float fren = pow(1. + dot(n,r),4.);\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),4.);\n  vec3 fog = vec3(1);\n   \n  col += spec * .65;\n  col += fren * .65;\n\n \n\n \n    \n  if (! hit) {\n      col = mix(vec3(.6), vec3(.4), pow(abs(r.y),.3));\n  }\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 179], [183, 183, 212, 212, 260], [261, 261, 290, 290, 347], [350, 350, 397, 397, 443], [467, 467, 495, 495, 568], [569, 569, 596, 596, 664], [666, 666, 694, 694, 718], [720, 720, 762, 762, 869], [871, 871, 899, 899, 925], [927, 927, 955, 955, 988], [991, 991, 1038, 1038, 1084], [1087, 1087, 1120, 1120, 1294], [1298, 1298, 1355, 1355, 1450], [1451, 1451, 1477, 1477, 1951], [1953, 1953, 1974, 1974, 2174], [2176, 2176, 2215, 2215, 2292], [2294, 2294, 2330, 2330, 2408], [2409, 2409, 2432, 2432, 2510], [2535, 2535, 2558, 2558, 2681], [2685, 2685, 2706, 2706, 2755], [2757, 2757, 2782, 2782, 3251], [3263, 3263, 3296, 3296, 3433], [3451, 3451, 3471, 3471, 3513], [3515, 3515, 3546, 3546, 3648], [3650, 3650, 3671, 3671, 3857], [3875, 3875, 3894, 3894, 4850], [4851, 4851, 4870, 4870, 4989], [4992, 4992, 5011, 5011, 5090], [5093, 5093, 5112, 5112, 5674], [5677, 5677, 5696, 5696, 6095], [6101, 6101, 6129, 6129, 6760], [6761, 6761, 6788, 6788, 7407], [7447, 7447, 7470, 7470, 7585], [7587, 7587, 7609, 7609, 7899], [7900, 7900, 7919, 7919, 8065], [8206, 8206, 8240, 8240, 8482], [8486, 8486, 8543, 8543, 10113]]}
{"id": "ssSfDR", "name": "大龙猫 - Gyroid Terrain", "author": "totetmatt", "description": "Mix of stuff, mainly Art of code + IQ articles. Not really gyroid, but gyroid sdf is base for displacement terrain", "tags": ["terrain", "gyroid"], "likes": 4, "viewed": 334, "published": 3, "date": "1645987236", "time_retrieved": "2024-07-30T17:00:59.711758", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\n\nfloat gyros(vec3 p) {\n  \n    return (dot(sin(p),cos(p.yxz)));\n  }\n  float di(vec3 p){\n    \n      float q=0.;\n      vec4 pp = vec4(p,1.);\n      for(float i=0.;i<8.;i++){\n        q = q+clamp(asin(sin(gyros(pp.xyz)/pp.a)*.9),0.,.5);\n         pp*=1.75;\n         pp.xyz =abs(pp.xyz)-10.9125;\n         pp.xz*=rot(.785);\n\n\n        }\n        return q;\n    }\n float diff=0.;\nvec2 sdf(vec3 p){\n   p.xy*=rot(p.z*.1);\n   p.y = -(abs(p.y)-1.);\n  vec2 h;\n\n  vec3 op = p;\n   p.z +=iTime;\n\n  h.x = p.y+1.+(diff=(di(p)*.3));\n  h.y= 1.;\n  h.x *=.7;\n  return h;\n  } \n  \n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(.1);\n\n  vec3 ro  = vec3(0.,-.9,-5.)+1e-5;\n;\n  vec3 rt  = vec3(0.,-.950,.0)+1e-5;\n  vec3 z   = normalize(rt-ro);\n  vec3 x   = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y   = normalize(cross(z,x));\n  \n  vec3 rp = ro;\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  \n  vec3 light = vec3(0.,1.,-3.)+1e-4;\n  float dd = 0.;\n  for(float i=0.;i<128.;i++){\n      vec2 d = sdf(rp);\n      dd+=d.x;\n      rp+=rd*d.x;\n    if(dd> 50.) break;\n      if(d.x < .0001) {\n           vec3 n = norm(rp,.0005);\n        vec3 n2 = norm(rp,.002);\n           float dif = max(0.,dot(normalize(light-rp),n));\n        float spc = pow(max(0.,dot(normalize(ro-rp),reflect(-normalize(light-rp),n))),4.);\n           col = dif*vec3(.2)+spc*pal(dot(rp,n)*.1);\n            \n           break;\n      }\n   \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [68, 68, 89, 89, 133], [136, 136, 153, 153, 417], [434, 434, 451, 451, 614], [645, 645, 672, 672, 747], [748, 748, 766, 766, 812], [813, 813, 870, 920, 1835]]}
{"id": "sdSBDR", "name": "Snobbish Dream", "author": "IWBTShyGuy", "description": "You can only think of Halloween until you die.", "tags": ["3d", "modeling"], "likes": 8, "viewed": 319, "published": 3, "date": "1645978826", "time_retrieved": "2024-07-30T17:01:00.680169", "image_code": "// Copyright © 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n/*** configure ***/\nstruct Wall {\n    vec3 origin;\n    vec3 normal;\n};\n\nconst float EPS = 1.0e-4;\nconst float FLOOR_INTERVAL = 2.0;\nconst Wall LEFT_WALL = Wall(vec3(-1, 0, 0), vec3(1, 0, 0));\nconst Wall RIGHT_WALL = Wall(vec3(1, 0, 0), vec3(-1, 0, 0));\nconst vec3 SHELF_UNIT = vec3(0.3, 0.3, 0.9);\nconst float SHELF_THICK = 0.05;\nconst vec3 SHELF_UNIT_WITH_THICK = SHELF_UNIT + SHELF_THICK;\n\nconst vec2 NUM_BOOK_RANGE = vec2(12.0, 36.0);\nconst vec2 BOOK_MIN_SIZE = vec2(0.105, 0.148); // A6\nconst vec2 BOOK_MAX_SIZE = vec2(0.210, 0.297); // A4\nconst vec3 BOOK_COLOR_RATIO = vec3(1.0, 0.8, 0.8);\n\n// walk settings\nconst float WALK_BASE_HEIGHT = 1.4;\nconst float WALK_STRIDE = 0.3;\nconst float WALK_PERIOD = 0.75;\nconst float WALK_TIME = WALK_PERIOD * 5.0;\nconst float WALK_AMPT = 0.05;\nconst float WALK_HEIGHT_AMPT = 0.01;\n\n// look around\nconst float LOOKAROUND_TIME = 10.0;\n\n// gaze from far\nconst vec3 GAZE_POSITION = vec3(-5.0, 100.0, 100.0);\nconst float GAZE_TIME = (WALK_TIME + LOOKAROUND_TIME) * 2.0 - WALK_TIME - 0.12 * LOOKAROUND_TIME;\n\nconst float SCENE_PERIOD = (WALK_TIME + LOOKAROUND_TIME) * 2.0 + WALK_TIME + 0.12 * LOOKAROUND_TIME + GAZE_TIME;\n\n/*** 3D toolkit ***/\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nvec2 dCosTheta(in vec2 uv, in float fov) {\n    Camera cam = Camera(\n        vec3(0, 0, 0),\n        vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        fov,\n        iResolution.x / iResolution.y\n    );\n    vec3 e = vec3(1, 1, 0) / iResolution;\n    Ray ray = cameraRay(cam, uv);\n    Ray rayx = cameraRay(cam, uv + e.xz);\n    Ray rayy = cameraRay(cam, uv + e.zy);\n    return vec2(\n        dot(ray.direction, rayx.direction),\n        dot(ray.direction, rayy.direction)\n    );\n}\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/*** integer hash ***/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\n\nvec3 noise32(vec2 x) {\n    uvec3 s = uvec3(ivec2(floor(x)) + 2147483647, 1);\n    vec2 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n        mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n        t.y\n    );\n}\n\nvec2 noise22(vec2 x) {\n    return noise32(x).xy;\n}\n\nvec3 noise33(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(\n            mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n            mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n            t.y\n        ),\n        mix(\n            mix(hash(s + e.xxy), hash(s + e.yxy), t.x),\n            mix(hash(s + e.xyy), hash(s + e.yyy), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n\nfloat noise13(vec3 x) {\n    return noise33(x).x;\n}\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\nvec3 smoothnoise32(vec2 x) {\n    const int k = 2147483647;\n    uvec2 s = uvec2(ivec2(floor(x)) + k);\n    vec2 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            hash(uvec3(s - e.zz, k)),\n            hash(uvec3(s - e.yz, k)),\n            hash(uvec3(s - e.xz, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zy, k)),\n            hash(uvec3(s - e.yy, k)),\n            hash(uvec3(s - e.xy, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zx, k)),\n            hash(uvec3(s - e.yx, k)),\n            hash(uvec3(s - e.xx, k)),\n            t.x\n        ),\n        t.y\n    );\n}\n\nvec3 fbm325(in vec2 uv) {\n    float a = 0.5;\n    vec3 res = vec3(0);\n    for (int i = 0; i < 5; i++) {\n        res += noise32((a *= 2.0) * uv);\n    }\n    return res;\n}\n\nvec3 smoothfbm325(in vec2 uv) {\n    float a = 0.5;\n    vec3 res = vec3(0);\n    for (int i = 0; i < 5; i++) {\n        res += smoothnoise32((a *= 2.0) * uv);\n    }\n    return res;\n}\n\n/*** main ***/\nfloat dCosThetax;\n\nvec2 bookSize(in vec3 p) {\n    vec2 r = noise22(floor(p.yz / SHELF_UNIT_WITH_THICK.yz));\n    return mix(BOOK_MIN_SIZE, BOOK_MAX_SIZE, r);\n}\n\nstruct Hit {\n    vec3 position;\n    vec2 uv;\n    vec3 normal;\n};\n\nconst Hit UNHIT = Hit(vec3(0), vec2(0), vec3(0));\n\nHit hitBox(in Ray ray, vec3 boxSize) {\n    vec3 m = 1.0 / ray.direction, n = m * ray.origin,\n    k = abs(m) * boxSize, t1 = - n - k, t2 = - n + k;\n    float tN = max(max(t1.x, t1.y), t1.z),\n    tF = min(min(t2.x, t2.y), t2.z);\n    vec3 p = ray.origin + tN * ray.direction,\n    uv = (1.0 + p / boxSize) / 2.0,\n    e = sign(p);\n    if(tN > tF || tF < 0.0) return UNHIT;\n    else if (t1.x == tN) return Hit(p, uv.yz, vec3(e.x, 0.0, 0));\n    else if (t1.y == tN) return Hit(p, uv.zx, vec3(0, e.y, 0));\n    else return Hit(p, uv.xy, vec3(0, 0, e.z));\n}\n\nHit hitFloor(in Ray ray) {\n    if (abs(ray.direction.y) < EPS) return UNHIT;\n    float t = -(ray.origin.y + SHELF_THICK) / ray.direction.y;\n    vec3 p = ray.origin + t * ray.direction;\n    if (t > 0.0 && abs(p.x) < FLOOR_INTERVAL * 0.5)\n        return Hit(p, p.zx, vec3(0, 1, 0));\n    else return UNHIT;\n}\n\nHit hitWall(in Ray ray, in Wall wall) {\n    float dotRN = dot(ray.direction, wall.normal);\n    if (abs(dotRN) < EPS) return UNHIT;\n    float distRW = dot(wall.origin - ray.origin, wall.normal),\n    t = distRW / dotRN;\n    if (t < 0.0) return UNHIT;\n    vec3 p = ray.origin + t * ray.direction;\n    return Hit(p, vec2(0), wall.normal);\n}\n\nHit hitUniformBook(in Ray ray, in Hit wall_hit) {\n    vec3 p = wall_hit.position;\n    vec2 bookSize = bookSize(p);\n    vec3 booksCenter = vec3(\n        sign(p.x) * (FLOOR_INTERVAL * 0.5 + SHELF_UNIT.x - bookSize.x / 2.0),\n        floor(p.y / SHELF_UNIT_WITH_THICK.y) * SHELF_UNIT_WITH_THICK.y + bookSize.y / 2.0,\n        floor(p.z / SHELF_UNIT_WITH_THICK.z) * SHELF_UNIT_WITH_THICK.z + SHELF_UNIT.z / 2.0\n    );\n    ray.origin -= booksCenter;\n    Hit hit = hitBox(ray, vec3(bookSize, SHELF_UNIT.z) / 2.0);\n    if (hit != UNHIT) hit.position += booksCenter;\n    return hit;\n}\n\nHit hitShelf(in Ray ray, in Hit wall_hit) {\n    vec3 d = ray.direction, p = wall_hit.position, e = sign(d),\n    u = mod(p, SHELF_UNIT_WITH_THICK),\n    t = vec3(\n        SHELF_UNIT.x / abs(d.x),\n        abs(SHELF_UNIT.y * 0.5 / d.y) - (u.y - SHELF_UNIT.y * 0.5) / d.y,\n        abs(SHELF_UNIT.z * 0.5 / d.z) - (u.z - SHELF_UNIT.z * 0.5) / d.z\n    );\n    if (u.z > SHELF_UNIT.z || u.y > SHELF_UNIT.y)\n        return Hit(p, u.zy / SHELF_UNIT_WITH_THICK.yz, vec3(-e.x, 0, 0));\n    float tMin = min(min(t.x, t.y), t.z);\n    p += tMin * d;\n    u = fract(vec3(abs(p.x) - FLOOR_INTERVAL * 0.5, p.yz) / SHELF_UNIT_WITH_THICK);\n    if (t.x == tMin) return Hit(p, u.zy, vec3(-e.x, 0, 0));\n    else if (t.y == tMin) return Hit(p, u.zx, vec3(0, -e.y, 0));\n    else return Hit(p + t.z * ray.direction, u.xy, vec3(0, 0, -e.z));\n}\n\nHit hitScene(in Ray ray) {\n    Hit hit = hitFloor(ray);\n    if (hit != UNHIT) return hit;\n    hit = hitWall(ray, RIGHT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf) return hBook;\n        else return hShelf;\n    }\n    hit = hitWall(ray, LEFT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf) return hBook;\n        else return hShelf;\n    }\n    return UNHIT;\n}\n\nfloat shadow(in vec3 p, in vec3 lightPos) {\n    Ray ray = Ray(lightPos, normalize(p - lightPos));\n    Hit hit = hitScene(ray);\n    return distance(hit.position, p) < EPS ? 1.0 : 0.0;\n}\n\nfloat cloth(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // distribution by Imageworks\n    float distribution = dotNM * (1.0 + 0.5 / alpha) * pow(1.0 - dotNM * dotNM, 0.5 / alpha);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    float tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\nvec3 colorFloor(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 p = hit.position, dir = p - lightPos;\n    if (abs(p.x) < 0.7) {\n        float k = abs(abs(p.x) - 0.6);\n        k = smoothstep(0.02, 0.01, k);\n        float c = cloth(\n            normalize(vec3(0, 1, 0) + 0.25 * (2.0 * fbm325(p.zx * 10.0) / 5.0 - 1.0)),\n            ray.direction,\n            normalize(dir),\n            0.9,\n            0.5\n        ) / dot(dir, dir);\n        return clamp(c, 0.0, 1.0) * vec3(252.0 / 255.0, k, 0);\n    } else {\n        float c = microfacet(\n            vec3(0, 1, 0),\n            ray.direction,\n            normalize(dir),\n            0.1,\n            0.7\n        ) / dot(dir, dir);\n        return clamp(c, 0.0, 1.0) * texture(iChannel0, fract(p.zx)).xyz;\n    }\n}\n\nvec3 colorUniformBook(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 p = hit.position, dir = p - lightPos, normal = hit.normal, col = vec3(1);\n    vec2 gen = floor(p.yz / SHELF_UNIT_WITH_THICK.yz);\n    float s = sign(hit.position.x), r = noise13(vec3(gen, 12.0 * s)),\n    nBooks = floor(mix(NUM_BOOK_RANGE.x, NUM_BOOK_RANGE.y, r));\n    if (normal.x != 0.0) {\n        r = fract(hit.uv.y * nBooks);\n        float sinAlpha = -dot(ray.direction, normal);\n        float du = distance(p, ray.origin) * sqrt(1.0 - dCosThetax * dCosThetax) / sinAlpha;\n        float a = smoothstep(SHELF_UNIT.z / nBooks, 0.0, 2.0 * du);\n        normal = normalize(normal + vec3(0, 0, a * sin(2.0 * (r - 0.5))));\n        col = noise33(vec3(gen, 16.0 * s)) * BOOK_COLOR_RATIO\n            * (0.6 + 0.4 * texture(iChannel1, hit.uv).xyz);\n    } else {\n        r = fract(hit.uv.x * nBooks);\n        float sinAlpha = -dot(ray.direction, normal);\n        float du = distance(p, ray.origin) * sqrt(1.0 - dCosThetax * dCosThetax) / sinAlpha;\n        float a = smoothstep(SHELF_UNIT.z / nBooks, 0.0, 2.0 * du);\n        if (fract(r + 0.005 * nBooks) < 0.01 * nBooks || hit.uv.y > 0.95)\n            col = 1.0 - a * (1.0 - noise33(vec3(gen, 16.0 * s)) * BOOK_COLOR_RATIO);\n        normal = normalize(normal - vec3(0, 0, a * 0.5 * sin(r - 0.5)));\n    }\n    float t = distance(ray.origin, hit.position),\n    c = 0.5 * microfacet(\n        normal,\n        ray.direction,\n        normalize(dir),\n        0.05,\n        0.7\n    ) / dot(dir, dir) * shadow(p, lightPos);\n    c += 0.5 * microfacet(\n        normal,\n        ray.direction,\n        ray.direction,\n        0.05,\n        0.7\n    ) / (1.0 + t * t);\n    return clamp(c, 0.0, 1.0) * col;\n}\n\nvec3 colorShelf(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 dir = hit.position - lightPos;\n    float t = distance(ray.origin, hit.position),\n    c = 0.5 * microfacet(\n        hit.normal,\n        ray.direction,\n        normalize(dir),\n        0.1,\n        0.7\n    ) / dot(dir, dir) * shadow(hit.position, lightPos);\n    c += 0.5 * microfacet(\n        hit.normal,\n        ray.direction,\n        ray.direction,\n        0.1,\n        0.7\n    ) / (1.0 + t * t);\n    return clamp(c, 0.0, 1.0) * pow(texture(iChannel0, hit.uv).xyz, vec3(2.2));\n}\n\nfloat directLight(in vec3 lightPos, in Ray ray) {\n    vec3 ol = lightPos - ray.origin;\n    float t = dot(ol, ray.direction);\n    if (t < 0.0) return 0.0;\n    vec3 h = ol - t * ray.direction;\n    return 5.0e-4 / dot(h, h);\n}\n\nvec3 sceneColor(in Ray ray, in vec3 lightPos) {\n    Hit hit = hitFloor(ray);\n    if (hit != UNHIT) return colorFloor(ray, hit, lightPos);\n    hit = hitWall(ray, RIGHT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf)\n            return colorUniformBook(ray, hBook, lightPos);\n        else return colorShelf(ray, hShelf, lightPos);\n    }\n    hit = hitWall(ray, LEFT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf)\n            return colorUniformBook(ray, hBook, lightPos);\n        else return colorShelf(ray, hShelf, lightPos);\n    }\n    return vec3(0);\n} \n\nvec3 cameraPos(in float t) {\n    if (mod(t, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        float bt = floor(t / (WALK_TIME + LOOKAROUND_TIME)) * WALK_TIME,\n        dt = mod(t, WALK_TIME + LOOKAROUND_TIME);\n        t = bt + min(dt, WALK_TIME);\n        float it = floor(t / WALK_PERIOD), ft = fract(t / WALK_PERIOD);\n        return vec3(\n            WALK_AMPT * cos(PI * t / WALK_PERIOD),\n            WALK_BASE_HEIGHT + WALK_HEIGHT_AMPT * abs(sin(PI * t / WALK_PERIOD)),\n            -WALK_STRIDE * (it + smoothstep(0.0, 1.0, ft))\n        );\n    } else {\n        return GAZE_POSITION;\n    }\n}\n\nvec3 cameraDir(in float t) {\n    if (mod(t, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        float dt = mod(t, WALK_TIME + LOOKAROUND_TIME);\n        vec3 dir = vec3(0, 0, -1);\n        if (dt > WALK_TIME) {\n            int signum = int(t / (WALK_TIME + LOOKAROUND_TIME)) % 2;\n            dt = (dt - WALK_TIME) / LOOKAROUND_TIME;\n            dt = smoothstep(0.0, 0.125, dt) * 0.125\n                    + smoothstep(0.125, 0.375, dt) * 0.25 \n                    + smoothstep(0.375, 0.625, dt) * 0.25\n                    + smoothstep(0.625, 0.875, dt) * 0.25\n                    + smoothstep(0.875, 1.0, dt) * 0.125;\n            dt += (signum == 1 ? 0.25 : 0.75);\n            vec2 disp = vec2(cos(2.0 * PI * dt), 1.5 * sin(-4.0 * PI * dt));\n            dir += 0.25 * vec3(disp, 0);\n        }\n        return normalize(dir + 0.02 * fbm325(vec2(t * 0.05, 1.0)) / 5.0 - 0.01);\n    } else {\n        return vec3(1, 0, 0);\n    }\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = PI / 3.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    Camera camera = Camera(\n        cameraPos(iTime),\n        cameraDir(iTime),\n        vec3(0, 1, 0),\n        fov,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, uv);\n    dCosThetax = dCosTheta(uv, fov).x;\n\n    vec3 lightPos;\n    if (mod(iTime, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        lightPos = vec3(\n            0.5 * cos(iTime),\n            WALK_BASE_HEIGHT + 0.5 * sin(0.333 * iTime),\n            ray.origin.z - 1.5 + 0.5 * sin(0.5 * iTime)\n        );\n    } else {\n        lightPos = GAZE_POSITION + vec3(\n            3.0,\n            1.5 * sin(iTime),\n            1.5 * cos(iTime * 0.5)\n        );\n    }\n    \n\n    vec3 col = sceneColor(ray, lightPos);\n    if (mod(iTime, SCENE_PERIOD) > SCENE_PERIOD - GAZE_TIME) {\n        col *= 37.5;\n    }\n    col += directLight(lightPos, ray);\n\n    float ft = mod(iTime, SCENE_PERIOD);\n    col *= smoothstep(0.0, 0.5, ft)\n            * smoothstep(0.0, 0.5, abs(ft + GAZE_TIME - SCENE_PERIOD))\n            * smoothstep(SCENE_PERIOD, SCENE_PERIOD - 0.5, ft);\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1);\n}\n\n#define AA 3\nvoid mainImage(out vec4 O, in vec2 U) {\n    mainImage0(O, U);\n    \n    // smart anti-aliasing\n    // reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSBDR.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1515, 1636, 1681, 1681, 2088], [2090, 2090, 2132, 2132, 2557], [2559, 2559, 2651, 2651, 3728], [3730, 3794, 3814, 3814, 4055], [4057, 4057, 4080, 4080, 4209], [4212, 4212, 4234, 4234, 4479], [4481, 4481, 4503, 4503, 4531], [4533, 4533, 4555, 4555, 4997], [4999, 4999, 5022, 5022, 5049], [5212, 5212, 5240, 5240, 5888], [5890, 5890, 5915, 5915, 6057], [6059, 6059, 6090, 6090, 6238], [6274, 6274, 6300, 6300, 6413], [6532, 6532, 6570, 6570, 7079], [7081, 7081, 7107, 7107, 7386], [7388, 7388, 7427, 7427, 7724], [7726, 7726, 7775, 7775, 8300], [8302, 8302, 8345, 8345, 9115], [9117, 9117, 9143, 9143, 9975], [9977, 9977, 10020, 10020, 10161], [10163, 10163, 10250, 10250, 11295], [11297, 11297, 11356, 11356, 12063], [12065, 12065, 12130, 12130, 13770], [13772, 13772, 13831, 13831, 14318], [14320, 14320, 14369, 14369, 14543], [14545, 14545, 14592, 14592, 15597], [15600, 15600, 15628, 15628, 16194], [16196, 16196, 16224, 16224, 17118], [17120, 17120, 17176, 17176, 18336]]}
{"id": "NsBfWz", "name": "torus field lines", "author": "SnoopethDuckDuck", "description": "messing around, mostly unused code.\n\nusing technique from forked shader, distorted grid with log(distance from torus) basically, can use other shapes and do the same thing, quite fun", "tags": ["e"], "likes": 12, "viewed": 311, "published": 3, "date": "1645969387", "time_retrieved": "2024-07-30T17:01:01.430164", "image_code": "#define MAX_STEPS 80\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n\n#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n//https://www.shadertoy.com/view/Wl3fD2\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nvec3 getRo() {\n    float t = 0.0 * iTime, o = 2. * pi / 3.;\n    return 3. * vec3(cos(t - o), cos(t), cos(t + o));\n}\n\nvec3 distort(vec3 p) {\n    float o = 2.* pi / 3.;\n    float t = 0. * length(p) - 0.25 * iTime;\n   // p = abs(p) - 0.5;\n    p.xy *= Rot(t - o);\n    p.yz *= Rot(t);\n    p.zx *= Rot(t + o);\n    return p;//fract(0.8 * p) - 0.5;\n}\n\nfloat GetDist(vec3 p) {\n\n    vec3 ro = getRo();\n    float cd = length(p - ro) - 0.;\n\n    p = distort(p);\n    \n    float r1 = 1.2;\n    float r2 = 0.3;\n    float d0 = length(p.xz) - r1;\n    float d1 = length(vec2(d0, p.y)) - r2;\n    //d1 += 0. + 0.2 * cos(d1 * 2. + iTime);\n    p *= 1.8;\n    //p /= cos(length(p) - iTime);\n   \n    p *= log(d1 - 0.);\n\n    vec3 center = floor(p) + 0.5;\n    vec3 neighbour = center + face(p - center);\n    \n    vec3 pos = p - center;\n    vec3 npos = p - neighbour;\n    \n    float h = hash(hash(neighbour.x, neighbour.y), neighbour.z);\n    \n    float o = 2. * pi / 3.;\n    float t = 2. * pi * h + 0. * iTime;\n    vec3 ax = vec3(cos(t - o), cos(t), cos(t + o));\n    ax = normalize(ax);\n    \n   // npos = erot(npos, ax, 0.5 * pi * h);\n    \n   \n    //npos.xy *= Rot(pi * h);\n    float e = 0.1;\n    float worst = sdBox(npos, vec3(0.75)) - 0.;\n    \n    float sq = 0.25 * sqrt(3.);\n   // worst = length(npos) - 0.5;//sq;\n    worst = sdBox(npos, vec3(0.4)) - 0.3798;\n   // worst = min(min(length(npos.xz), length(npos.zy)), length(npos.yx)) - 0.2;\n    \n    float me = sdBox(pos, vec3(0.2)) - 0.;\n    \n    \n    // lower k => more \"fog\"\n    float k = 0.4;\n    float d = worst;//min(me, worst);\n    d = -min(-d, cd);\n    \n    //return length(p) -0.3 + SURF_DIST;\n    return k * d + 0.14;//500. * SURF_DIST;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = getRo();\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 0.95);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        vec3 dp = distort(p);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       // col = vec3(step(0., dif));\n        \n        // darken with distance from origin\n        float v = exp(-0.3 * pow(dot(p,p), 0.25));\n        \n        // idk what this does\n        v = smoothstep(0., 1., v);\n        v = clamp(1.2 * v * v, 0., 1.);\n      \n        // color + lighten\n        vec3 e = vec3(1);\n        col = v * pal(0.32 + 1. * v, 0.8 * e, 0.5 * e, 0.5 * e, 0.8 * vec3(0,1,2)/3.);    \n        //col = vec3(v);\n        //col -= 0.1;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 154, 154, 197], [199, 199, 218, 218, 280], [282, 282, 311, 311, 392], [490, 490, 520, 520, 596], [598, 598, 636, 636, 701], [703, 703, 722, 722, 805], [807, 807, 821, 821, 922], [924, 924, 946, 946, 1149], [1151, 1151, 1174, 1174, 2477], [2479, 2479, 2522, 2522, 2756], [2758, 2758, 2782, 2782, 2972], [2974, 2974, 3024, 3024, 3215], [3217, 3217, 3274, 3274, 4140]]}
{"id": "NsBfDz", "name": "Parawave RAPID Knob", "author": "Lastminute", "description": "https://parawave-audio.com/index.php?route=product/rapid\nI like making these", "tags": ["knob"], "likes": 18, "viewed": 449, "published": 3, "date": "1645967207", "time_retrieved": "2024-07-30T17:01:02.191129", "image_code": "precision lowp float;\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\n#define PI 3.1415926\n\nvec4 overlay(vec4 a,vec4 b)\n{\n\tfloat f=a.a+b.a*(1.-a.a);\n\treturn vec4((a.rgb*a.a+b.rgb*b.a*(1.-a.a))/f,f);\n}\n\nfloat sdCircle(vec2 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n\tvec2 d=abs(p)-b;\n\treturn length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec4 vertical_gradient(vec2 uv,vec4 c1,vec4 c2)\n{\n\treturn mix(c1,c2,uv.y*1.5+.5);\n}\n\nmat2 rotate2d(float angle)\n{\n\treturn mat2(-cos(angle),sin(angle),-sin(angle),-cos(angle));\n}\n\nfloat random(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t//Colours\n\tvec4 bg_c=vec4(.200,.200,.239,1.);\n\tvec3 bg_bot_c=vec3(.129,.129,.153);\n\tvec3 bg_top_c=vec3(.153,.153,.176);\n\tvec3 light_c=vec3(.337,.639,.878);\n\tvec3 light_glw_c=vec3(.506,.753,.949);\n\tvec4 cap_grad_top_c=vec4(.333,.333,.353,1.);\n\tvec4 cap_grad_bot_c=vec4(.227,.227,.259,1.);\n\tvec3 cap_line_c=vec3(.855,.859,.871);\n\tvec4 black=vec4(0.,0.,0.,1.);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * 1.25;\n\n\tfloat aa=1./((iResolution.x+iResolution.y)/2.) * 1.25;\n\t\n\tfloat range=.75;\n\tfloat val=(iMouse.x/iResolution.x);\n\tfloat angle_val=(1.-range)*PI+val*2.*PI*range;\n\t\n\tfloat a_range=fract((atan(uv.x,uv.y)+PI*range)/(2.*PI));\n\tfloat bg_shape=smoothstep(a_range,a_range,range)*smoothstep(sdCircle(uv,.5)-aa,sdCircle(uv,.5)+aa,0.);\n\tvec4 bg_bot=vec4(bg_bot_c,clamp(bg_shape,0.,1.));\n\t\n\tfloat a_range2=fract((atan(uv.x,uv.y)+PI*range*.98)/(2.*PI))*1.02;\n\tfloat bg_top_shape=smoothstep(a_range2,a_range2,range)*smoothstep(sdCircle(uv,.48)-aa,sdCircle(uv,.48)+aa,0.)*smoothstep(-sdCircle(uv,.4)-aa,-sdCircle(uv,.4)+aa,0.);\n\tvec4 bg_top=vec4(bg_top_c,clamp(bg_top_shape,0.,1.));\n\t\n\tvec4 bg_shadow=vec4(vec3(0.),smoothstep(sdCircle(uv,.45),sdCircle(uv,.5),0.))*bg_shape*.2;\n\tvec4 cap_bot_shadow=vec4(vec3(0.),smoothstep(sdCircle(uv+vec2(0.,.05),.45),sdCircle(uv+vec2(0.,.05),.2),0.));\n\t\n\tfloat bg_light_shape=bg_top_shape*smoothstep(a_range,a_range,range*val);\n\tvec4 bg_light=vec4(light_c,clamp(bg_light_shape,0.,1.));\n\t\n\tfloat bg_light_glw_shape=smoothstep(a_range2,a_range2,range)*smoothstep(sdCircle(uv,.48),sdCircle(uv,.44),0.)*smoothstep(-sdCircle(uv,.4),-sdCircle(uv,.44),0.)*smoothstep(a_range,a_range,range*val);\n\tvec4 bg_light_glw=vec4(light_glw_c,1.)*clamp(bg_light_glw_shape,0.,1.)*(val/2.+.25);\n\t\n\tfloat a=atan(uv.x,uv.y)-angle_val;\n\tfloat cap_shape_bot=smoothstep(sdCircle(uv,.34)-aa,sdCircle(uv,.34)+aa,0.);\n\tvec4 cap_grad=vertical_gradient(uv,cap_grad_bot_c,cap_grad_top_c);\n\tvec4 cap_bot=vec4(cap_grad.rgb,cap_shape_bot);\n\t\n\tfloat cap_shape_bot_glw=smoothstep(-sdCircle(uv,.33)-aa,-sdCircle(uv,.34)+aa,0.)*cap_shape_bot;\n\tvec4 cap_bot_glw=vec4(cap_grad.rgb*1.5,clamp(cap_shape_bot_glw*uv.y,0.,1.));\n\t\n\tvec4 cap_shadow1=mix(vec4(0.,0.,0.,(sin(-angle_val)+1.)/2.*.75),vec4(0.),clamp((clamp(uv*rotate2d(angle_val),0.,1.).x)*1.5,0.,1.))*step((-uv*rotate2d(angle_val)).x,0.)*cap_shape_bot;\n\tvec4 cap_shadow2=mix(vec4(0.,0.,0.,(sin(angle_val)+1.)/2.*.75),vec4(0.),clamp((clamp(-uv*rotate2d(angle_val),0.,1.).x)*1.5,0.,1.))*step((uv*rotate2d(angle_val)).x,0.)*cap_shape_bot;\n\tvec4 cap_shadow3=mix(vec4(0.,0.,0.,1.)*.1,vec4(0.),clamp((clamp(abs(uv*rotate2d(angle_val)),0.,1.).x)*4.,0.,1.))*cap_shape_bot;\n\t\n\tfloat cap_shape_top=smoothstep(sdBox(uv*rotate2d(angle_val),vec2(.12,.5))-aa,sdBox(uv*rotate2d(angle_val),vec2(.12,.5))+aa,0.)*cap_shape_bot;\n\tvec4 cap_top=vec4(cap_grad.rgb,cap_shape_top);\n\t\n\tfloat cap_shape_top_glw=smoothstep(-sdBox(uv*rotate2d(angle_val),vec2(.11,.5))-aa,-sdBox(uv*rotate2d(angle_val),vec2(.12,.5))+aa,0.)*cap_shape_top+smoothstep(-sdCircle(uv,.33)-aa,-sdCircle(uv,.34)+aa,0.)*cap_shape_bot*cap_shape_top;\n\tvec4 cap_top_glw=vec4(cap_grad.rgb*1.5,clamp(cap_shape_top_glw*uv.y,0.,1.));\n\t\n\tfloat line_shape=smoothstep(sdBox(uv*rotate2d(angle_val)-vec2(0.,.25),vec2(.02,.2))-aa,sdBox(uv*rotate2d(angle_val)-vec2(0.,.25),vec2(.02,.2))+aa,0.)*cap_shape_bot;\n\t\n\tvec4 colour=bg_c;\n\tcolour=overlay(bg_bot,colour);\n\tcolour=overlay(bg_top,colour);\n\tcolour=overlay(bg_shadow,colour);\n\tcolour=overlay(cap_bot_shadow,colour);\n\tcolour=overlay(bg_light,colour);\n\tcolour+=bg_light_glw;\n\tcolour=overlay(cap_bot,colour);\n\tcolour=overlay(cap_bot_glw,colour);\n\tcolour=overlay(cap_shadow1,colour);\n\tcolour=overlay(cap_shadow2,colour);\n\tcolour=overlay(cap_shadow3,colour);\n\tcolour=overlay(cap_top,colour);\n\tcolour=overlay(cap_top_glw,colour);\n\tcolour=overlay(vec4(line_shape),colour);\n\t\n\tfragColor=colour;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 124, 124, 203], [205, 205, 237, 237, 260], [262, 262, 296, 296, 364], [366, 366, 415, 415, 449], [451, 451, 479, 479, 543], [545, 545, 568, 568, 637], [639, 639, 694, 705, 4544]]}
{"id": "sdBfRw", "name": "brush tex", "author": "mdb", "description": "brush stroke generator\nused in https://www.shadertoy.com/view/fd2BRm", "tags": ["texture", "paint", "brush"], "likes": 10, "viewed": 374, "published": 3, "date": "1645966833", "time_retrieved": "2024-07-30T17:01:02.950100", "image_code": "//Random////////////////////////////////////////////////////////////////////////////\nfloat noise(vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0 - 2.0*f);\n    \n    vec2 p = floor(x);\n\tfloat a = texture(iChannel0, (p+vec2(0.0, 0.0))/256.0).x;\n\tfloat b = texture(iChannel0, (p+vec2(1.0,0.0))/256.0).x;\n\tfloat c = texture(iChannel0, (p+vec2(0.0,1.0))/256.0).x;\n\tfloat d = texture(iChannel0, (p+vec2(1.0,1.0))/256.0).x;\n\n    \n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nvec2 seed = vec2(0.0);\n\nfloat rand(){\n    return (seed.x = fract(6.0*sin(344.0*seed.x + 0.4)));\n}\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    x += seed;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n//aux///////////////////////////////////////////////////////////////////////////////////\n\nvec3 colorRamp(vec3 col1, vec3 col2, vec3 col3, float t){\n    if (t < 0.5){\n        t*=2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col1, col2, t);\n    }else{\n        t = (t-0.5)*2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col2, col3, t);\n    }\n}\n\n//brush////////////////////////////////////////////////////////////////////////////////\n\n\nvec4 brush(vec2 uv){ //color && alpha\n    uv.y += 0.2*(fbm(vec2(uv.x*2.0, 0.5), 2) - 0.5);\n    //strength\n    float b = 1.0;\n    b *= pow(fbm(uv*vec2(1.0, 3.0), 8), 2.0);\n    b *= smoothstep(0.9, 0.5, 2.0*max(abs(uv.x - 0.5), abs(uv.y - 0.5)));\n    \n    \n    if (b <= 0.15) return vec4(0.0);\n    //color\n    float t = 0.3 + 0.4*fbm(uv*vec2(10.0, 60.0) + 10.0, 3);\n    t += 0.3*fbm(uv*2.0+20.0, 2)-0.15;\n    t += 0.2*noise(seed)-0.1;\n    t = 0.8*t+0.1;\n    \n    t *= b*0.5+0.5; \n    b = smoothstep(0.15, 0.2, b);\n    \n    return vec4(colorRamp(vec3(0.365,0.153,0.337), \n                     vec3(1.000,0.690,0.259),\n                     vec3(0.753,0.165,0.165), t), b);\n}\n\n//main//////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    seed = vec2(floor(iTime));\n    \n    vec4 b = brush(uv);\n    vec3 col = mix(texture(iChannel1, uv).rgb*0.1+0.8, b.rgb, b.w);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 105, 105, 478], [504, 504, 517, 517, 577], [578, 578, 608, 608, 845], [936, 936, 993, 993, 1203], [1295, 1295, 1315, 1332, 1965], [1967, 2048, 2105, 2105, 2312]]}
{"id": "NsSfWz", "name": "fold explanation", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["fold"], "likes": 3, "viewed": 194, "published": 3, "date": "1645961205", "time_retrieved": "2024-07-30T17:01:03.708073", "image_code": "#define TAU atan(1.)*8.\nfloat D(float d){\n  return smoothstep(0.03,0.0,d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p=(gl_FragCoord.xy*2. - iResolution.xy)/iResolution.y;\n  p*=1.5;\n  float a=iTime*TAU/6.;\n  vec2 v=vec2(cos(a),sin(a));\n  fragColor = vec4(0.0);\n  fragColor+=D(length(p-vec2(clamp(p.x,-1.,1.),0)));\n  fragColor+=D(length(p-vec2(0,clamp(p.y,-1.,1.))));\n  fragColor+=D(length(p-clamp(dot(p,v),.0,.5)*v));\n  fragColor+=D(length(p-v*.5)-.05);\n  float g=dot(p,v);\n  p-=(g-abs(g))*v;\n  float len=length(p);\n  if(len<.5)\n  {\n    fragColor.xyz+=vec3(1,0,0)*step(0.,p.x);\n  }else if(len<1.){\n    fragColor.xyz+=vec3(0,0,1)*step(0.,p.y);\n  }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 41, 41, 76], [77, 77, 134, 134, 673]]}
{"id": "fsSBWR", "name": "Player Movement 2D", "author": "Dirk", "description": "Character Movement from keyboard inputs.\n\nWASD to move.\n", "tags": ["game", "keyboard", "character", "input", "movement"], "likes": 2, "viewed": 296, "published": 3, "date": "1645925503", "time_retrieved": "2024-07-30T17:01:04.529876", "image_code": "\n\n    V loop(out v4 O,in v2 U){\n        v2 uv = (2.*U-iR.xy)/iR.y;\n        v3 c = v3(0.);\n        v4 p = pc;\n           p.zw += uv;\n        F  b = S(4./iR.y,0.,L(uv-p.xy)-.1);\n        c = Q(v3(K(p.zw*2.),0.), v3(0.), b);\n        O = v4(c,1.);\n    }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n    V loop(out v4 O,in v2 U){\n        F x,y = 0.0;\n        v2 uv = U.xy/iR.xy;\n        v4 wasd = v4( kf(WASD.x), kf(WASD.y), kf(WASD.z), kf(WASD.w) );\n        if(wasd.y>0.0)x--; if(wasd.x>0.0)y++; if(wasd.w>0.0)x++; if(wasd.z>0.0)y--;\n        v4 p=pc, c=v4(0.0);\n        v2 s=N(v2(x,y))*0.06;\n        if( A(x)>e.x || A(y)>e.x ) p.xy += s;\n        if( p.y >  e.z )  p.y = e.z;\n        if( p.y < -e.z )  p.y = -e.z;\n        if( p.x >  e.z ){ p.x = e.z;  p.z+=s.x;   }\n        if( p.x < -e.z ){ p.x = -e.z; p.z += s.x; }\n        if( p.y < -e.z )  p.y - s.y;\n        if(E(U.x)==0.0 && E(U.y)==1.0) c = p;\n        O = c;\n    }", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n    #define loop mainImage\n\n    #define iR iResolution\n    #define WASD ivec4(87,65,83,68)\n    #define LURD ivec4(37,38,39,40)\n    \n    #define e vec4(0.,0.001,0.9,1.0)\n    \n    #define kf(k) texelFetch( iChannel1, ivec2(k,0), 0 ).x \n    #define pc texelFetch( iChannel0, ivec2( 0, 1 ), 0 )\n    #define wp texelFetch( iChannel0, ivec2( 0, 2 ), 0 )\n    \n    #define v2 vec2\n    #define v3 vec3\n    #define v4 vec4\n\n    #define A abs\n    #define E floor\n    #define F float\n    #define K fract\n    #define L length\n    #define N normalize\n    #define Q mix\n    #define S smoothstep\n    #define V void", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 31, 31, 248]]}
{"id": "7djBzm", "name": "weird sphere", "author": "SnoopethDuckDuck", "description": "it was a sphere now idk what it is", "tags": ["e"], "likes": 5, "viewed": 264, "published": 3, "date": "1645921210", "time_retrieved": "2024-07-30T17:01:05.299817", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n\n#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat mlength(vec2 p) {\n    return max(abs(p.x), abs(p.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(abs(p.x), max(abs(p.y), abs(p.z)));\n}\n\nvec3 distort(vec3 p) {\n    float o = 2.* pi / 3.;\n    float t = 1.5 * length(p) - 0.2 * iTime;\n   // p = abs(p) - 0.5;\n    p.xy *= Rot(t - o);\n    p.yz *= Rot(t);\n    p.zx *= Rot(t + o);\n    return p;//fract(0.8 * p) - 0.5;\n}\n\nfloat thc(float a, float b) {\n    return tanh(a*cos(b))/tanh(a);\n}\n\nfloat GetDist(vec3 p) {\n   vec3 op = p;\n    float cd = length(p);\n   \n   // p = distort(p); \n    float mx = 0.5 + 0.5 * cos(iTime);\n    float m1 = mix(abs(p.y), length(p.xz), mx);\n    float m2 = mix(length(p.xz), p.y, mx);\n   \n    float k = 0.;\n      \n    vec3 t1 = p;\n    t1.xy *= Rot(iTime);\n    \n    float a = atan(t1.x, t1.y);\n    //t1.zy *= Rot(iTime);\n    float d0 = length(t1.xz) - 2.;//  + 0.5 * cos(iTime);\n    \n    vec2 u = vec2(d0, t1.y);\n   // u *= Rot(a + iTime);\n   // u = abs(u) - 0.5;\n    \n    float d1 = 0.5 * length(u) + SURF_DIST;\n    \n    p.xz *= Rot(-0.3 * iTime);\n    p = distort(p);\n    p = fract(8. * p) - 0.5;\n    float e = 0.05;\n    float sd = e * mlength(p) - 0.5 * e * length(p) + SURF_DIST;\n\n    float d = d1;\n    d = sd;//min(sd, d);\n    \n    float m = 1.5 + 0.25 * cos(length(op.xz) * 5. - iTime);\n    d = max(d, abs(abs(m-cd) - 0.3) - 0.12);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t = 0.125 * iTime, o = 2. * pi / 3.;\n    vec3 ro = 3.6 * vec3(cos(t - o), cos(t), cos(t + o));\n   //ro *= (2.5 - 1.1 * cos(0.5 * iTime));\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 0.95);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        //p = distort(p);\n\n        float v = smoothstep(0., 1., exp(-0.5 * length(p)));\n        v *= v;\n      \n        // color + lighten\n        vec3 e = vec3(1);\n        col = v * pal(0.5 * v + 0.36, e, e, e, 0.8 * vec3(0,1,2)/3.);    \n        col += 0.1;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 155, 155, 198], [200, 200, 219, 219, 281], [283, 283, 306, 306, 344], [346, 346, 369, 369, 422], [424, 424, 446, 446, 649], [651, 651, 680, 680, 717], [719, 719, 742, 742, 1608], [1610, 1610, 1653, 1653, 1887], [1889, 1889, 1913, 1913, 2103], [2105, 2105, 2155, 2155, 2346], [2348, 2348, 2405, 2405, 3111]]}
{"id": "7s2fRm", "name": "大龙猫 - Pumpin' box factory", "author": "totetmatt", "description": "The pumping box factory", "tags": ["cube", "box", "factory"], "likes": 13, "viewed": 270, "published": 3, "date": "1645918791", "time_retrieved": "2024-07-30T17:01:06.062777", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.1,.3,.4)));}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(0.)))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat yd =0.;\nfloat xd=0.;\nfloat id = 0.;\nvec2 sdf(vec3 p){\n\n float time = iTime*150./60.*.5;\n p.z +=(floor(time)+pow(fract(time),4.));\n  p.z *=.25;\n    id = floor(p.z);\n     p.xy *=rot(id+sign(mod(id,2.)-.5)*iTime*.2);\n      p.x  +=asin(sin(time*.5+id*.2))*.5;\n    p.y  +=asin(cos(time*.5+id*.2))*.5;\n    \n    p.z =   fract(p.z)-.5;\n    p.z /=.25;\n    vec2 h; \n    h.x = box(p,vec3(1.1));\n    h.y = mod(id,3.)+1.;\n    \n    \n    \n    vec2 t ;\n    vec3 tp = p;\n    tp = abs(tp);\n    tp.y -= 2.+ (yd=sin(iTime+id))*.75;\n    t.x = box(tp,vec3(1.,.125,1.));\n    t.y = 4.;\n    h = t.x < h.x ? t:h;\n    \n    for(float i=0.;i<2.;i++){\n        tp.xz =abs(tp.xz)-.155;\n        tp.xz *=rot(.785+id);\n    }\n    t.x = sdCappedCylinder(tp,-vec3(0.+cos(id)*.1,2.,0),-vec3(0.,tp.y,0.),.2+sin(iTime+p.y)*.1);\n    t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n    \n    tp = p;\n    tp = abs(tp);\n    tp.x -= 2.+(xd=cos(iTime-id))*.75;\n    t.x = box(tp,vec3(.125,1.,1.));\n    t.y = 4.;\n    h = t.x < h.x ? t:h;\n    for(float i=0.;i<2.;i++){\n        tp.yz =abs(tp.yz)-.155;\n        tp.yz *=rot(.785+id);\n    }\n    t.x = sdCappedCylinder(tp,-vec3(2.,0.,0),-vec3(tp.x,0.,0.),.2+sin(iTime+tp.x)*.1);\n    t.y = 3.;\n    h = t.x < h.x ? t:h;\n    return h;\n}\n\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec3 rp,ro=vec3(4.,2.,-5.)+1e-5;\n    ro.xy *= rot(iTime*.2);\n    rp = ro;\n    vec3 rt = vec3(0.)+1e-5;\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.-.8*sqrt(length(uv))));\n    \n    vec3 light = vec3(1.,2.,-3.);\n    vec3 col = vec3(.1);\n    vec3 acc= vec3(0.);\n    float dd=0.;\n    for(float i=0.;i<128.;i++){\n        vec2 d = sdf(rp);\n        if(floor(d.y)==2. || floor(d.y)==3.){\n            float li = floor(d.y)==2. ? yd:xd;\n            acc+=pal(mix(1.15,.3,pow(li*.5+.5,1.5)))*exp(-abs(d.x))/60.*mix(4.,.1,li*.5+.5); \n            d.x = max(.001,abs(d.x));\n     \n        } \n        \n        \n        rp+=rd*d.x;\n        dd+=d.x;\n      \n        if(dd> 50.) break;\n        if(abs(d.x)<.0001){\n            vec3 n = norm(rp,.001);\n            if(d.y == 4.) {\n            vec3 n2 = norm(rp,.01);\n             col = (mod(id,2.)==0.? vec3(0.0, 0.34, 0.72):     vec3(1.0, 0.84, 0.0))*smoothstep(.2,.1,length(n-n2));\n            } else {float dif = max(0.,dot(normalize(light-rp),n));\n            col = vec3(1.)*dif;\n            }\n            break;\n        }\n    \n    }\n    col +=acc;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2fRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 86, 86, 156], [157, 157, 175, 175, 221], [222, 222, 247, 247, 338], [339, 339, 396, 396, 732], [775, 775, 792, 792, 1956], [1984, 1984, 2011, 2011, 2086], [2087, 2087, 2142, 2142, 3446]]}
{"id": "ssjfRm", "name": "Hammer 2D  gchipunov 960", "author": "gchipunov", "description": "Simulates the format of the 2D viewport grid in the Valve Hammer level editor.", "tags": ["2d", "grid", "hammereditor"], "likes": 0, "viewed": 161, "published": 3, "date": "1645917964", "time_retrieved": "2024-07-30T17:01:06.824740", "image_code": "bool onGridline(int distFrom, int spacing);\nbool onSplitline(int distFrom, int spacing, int interval);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Colours , used to return to fragColor depending on criteria.\n\tconst vec4 cBackground = vec4(0.0,0.0,0.0,1.0);\t\t\t// Background colour.\n\tconst vec4 cOrigin = vec4(0.0,0.392,0.392,1.0);\t\t\t// Frag is directly in line with mouse's X or Y.\n\tconst vec4 cLargeSplit = vec4(0.392,0.18,0.004,1.0);\t// Frag is on a large split line.\n\tconst vec4 cMedSplit = vec4(0.449,0.449,0.449,1.0);\t\t// Frag is on a medium split line.\n\tconst vec4 cGridline = vec4(0.293,0.293,0.293,1.0);\t\t// Frag is on a grid line.\n\t\n\t// Grid lines\n\tconst int spacingStd = 16;\t\t\t// Spacing of normal grid lines\n\tconst int intervalLargeSplit = 16;\t// On how many gridlines a large split occurs.\n\tconst int intervalMedSplit = 8;\t\t// On how many gridlines a medium split occurs.\n\tconst float zoom = 1.0;\t\t\t// Zoom level of the grid.\n\t\n\t// Effective spacing\n\t// This is the standard grid spacing, as an integer, once zoom has been applied.\n\t// We do this here and use this value later to avoid float rounding errors.\n\tint effGrid = int(floor((float(spacingStd) * zoom) + 0.5)) ;\n\t\n\t// Convenience integer values for resolution and frag position.\n\tint fragX = int(fragCoord.x - 0.5);\n\tint fragY = int(fragCoord.y - 0.5);\n\tint width = int(iResolution.x);\n\tint height = int(iResolution.y);\n\t\n\t// The offsets to the original mouse position were found by trial and error.\n\tint mouseX = int(iMouse.x);\n\tint mouseY = int(iMouse.y - 1.0);\n\t\n\t// Distance this frag is from the mouse position, in each axis.\n\tint xDistFrom = int(abs(float(mouseX - fragX)));\n\tint yDistFrom = int(abs(float(mouseY - fragY)));\n\t\n\t// ============================================================\n\t\n\t// If on same X or Y as mouse, paint with origin colour.\n\tif ( fragX == mouseX || fragY == mouseY )\n\t{\n\t\tfragColor = cOrigin;\n\t\treturn;\n\t}\n\t\n\t// If on grid line, decide which colour to paint.\n\telse if ( onGridline(xDistFrom, effGrid) || onGridline(yDistFrom, effGrid) \n    ||\n     onGridline(xDistFrom-1, effGrid) || onGridline(yDistFrom-1, effGrid) && mod(float(mouseX),2.0) == 0.0 //(mouseX > 100)\n     ||\n     onGridline(xDistFrom+1, effGrid) || onGridline(yDistFrom+1, effGrid) && (mod(float(mouseX),2.0)== 0.0)//(mouseX > 100)\n    )\n\t{\n\t\t// If on large split line, choose this first.\n\t\tif ( onSplitline(xDistFrom, effGrid, intervalLargeSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalLargeSplit))\n\t\t{\n\t\t\tfragColor = cLargeSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Then check medium split line.\n\t\telse if ( onSplitline(xDistFrom, effGrid, intervalMedSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalMedSplit))\n\t\t{\n\t\t\tfragColor = cMedSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Otherwise, return normal grid line colour.\n\t\telse\n\t\t{\n\t\t\tfragColor = cGridline;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// Fragment is not in line with any grid line - paint as background.\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a grid line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @return True if distFrom lies on a gridline, false otherwise.\nbool onGridline(int distFrom, int spacing)\n{\n\treturn mod(float(distFrom), float(spacing)) == 0.0;\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a split line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @param interval On how many gridlines a split occurs. Eg. 4 would imply a split every 4\n//\t\t  grid spacing amounts.\n// @return True if distFrom lies on the split line, false otherwise.\nbool onSplitline(int distFrom, int spacing, int interval)\n{\n\tint newSpacing = spacing * interval ;\n\t\n\treturn mod(float(distFrom), float(newSpacing)) == 0.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2974, 3293, 3337, 3337, 3392], [3394, 3837, 3896, 3896, 3995]]}
{"id": "7djfRm", "name": "Fork Fork Hamme gchipunov 587", "author": "gchipunov", "description": "Simulates the format of the 2D viewport grid in the Valve Hammer level editor.", "tags": ["2d", "grid", "hammereditor"], "likes": 0, "viewed": 153, "published": 3, "date": "1645917596", "time_retrieved": "2024-07-30T17:01:07.583711", "image_code": "bool onGridline(int distFrom, int spacing);\nbool onSplitline(int distFrom, int spacing, int interval);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Colours , used to return to fragColor depending on criteria.\n\tconst vec4 cBackground = vec4(0.0,0.0,0.0,1.0);\t\t\t// Background colour.\n\tconst vec4 cOrigin = vec4(0.0,0.392,0.392,1.0);\t\t\t// Frag is directly in line with mouse's X or Y.\n\tconst vec4 cLargeSplit = vec4(0.392,0.18,0.004,1.0);\t// Frag is on a large split line.\n\tconst vec4 cMedSplit = vec4(0.449,0.449,0.449,1.0);\t\t// Frag is on a medium split line.\n\tconst vec4 cGridline = vec4(0.293,0.293,0.293,1.0);\t\t// Frag is on a grid line.\n\t\n\t// Grid lines\n\tconst int spacingStd = 16;\t\t\t// Spacing of normal grid lines\n\tconst int intervalLargeSplit = 16;\t// On how many gridlines a large split occurs.\n\tconst int intervalMedSplit = 8;\t\t// On how many gridlines a medium split occurs.\n\tconst float zoom = 1.0;\t\t\t// Zoom level of the grid.\n\t\n\t// Effective spacing\n\t// This is the standard grid spacing, as an integer, once zoom has been applied.\n\t// We do this here and use this value later to avoid float rounding errors.\n\tint effGrid = int(floor((float(spacingStd) * zoom) + 0.5)) ;\n\t\n\t// Convenience integer values for resolution and frag position.\n\tint fragX = int(fragCoord.x - 0.5);\n\tint fragY = int(fragCoord.y - 0.5);\n\tint width = int(iResolution.x);\n\tint height = int(iResolution.y);\n\t\n\t// The offsets to the original mouse position were found by trial and error.\n\tint mouseX = int(iMouse.x);\n\tint mouseY = int(iMouse.y - 1.0);\n\t\n\t// Distance this frag is from the mouse position, in each axis.\n\tint xDistFrom = int(abs(float(mouseX - fragX)));\n\tint yDistFrom = int(abs(float(mouseY - fragY)));\n\t\n\t// ============================================================\n\t\n\t// If on same X or Y as mouse, paint with origin colour.\n\tif ( fragX == mouseX || fragY == mouseY )\n\t{\n\t\tfragColor = cOrigin;\n\t\treturn;\n\t}\n\t\n\t// If on grid line, decide which colour to paint.\n\telse if ( onGridline(xDistFrom, effGrid) || onGridline(yDistFrom, effGrid) \n    ||\n     onGridline(xDistFrom-1, effGrid) || onGridline(yDistFrom-1, effGrid) \n      ||\n     onGridline(xDistFrom+1, effGrid) || onGridline(yDistFrom+1, effGrid) \n    )\n\t{\n\t\t// If on large split line, choose this first.\n\t\tif ( onSplitline(xDistFrom, effGrid, intervalLargeSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalLargeSplit))\n\t\t{\n\t\t\tfragColor = cLargeSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Then check medium split line.\n\t\telse if ( onSplitline(xDistFrom, effGrid, intervalMedSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalMedSplit))\n\t\t{\n\t\t\tfragColor = cMedSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Otherwise, return normal grid line colour.\n\t\telse\n\t\t{\n\t\t\tfragColor = cGridline;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// Fragment is not in line with any grid line - paint as background.\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a grid line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @return True if distFrom lies on a gridline, false otherwise.\nbool onGridline(int distFrom, int spacing)\n{\n\treturn mod(float(distFrom), float(spacing)) == 0.0;\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a split line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @param interval On how many gridlines a split occurs. Eg. 4 would imply a split every 4\n//\t\t  grid spacing amounts.\n// @return True if distFrom lies on the split line, false otherwise.\nbool onSplitline(int distFrom, int spacing, int interval)\n{\n\tint newSpacing = spacing * interval ;\n\t\n\treturn mod(float(distFrom), float(newSpacing)) == 0.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2877, 3196, 3240, 3240, 3295], [3297, 3740, 3799, 3799, 3898]]}
{"id": "ssjBRm", "name": "Ulam Spiral", "author": "elenzil", "description": "Ulam's Spiral.\n\nI started implementing the Sieve of Eratosthenes in a buffer for a LUT of primes,\nbut then I just tried calculating them and it turns out computers have gotten faster since the 1990s.\n[url]https://en.wikipedia.org/wiki/Ulam_spiral[/url]\n\n", "tags": ["spiral", "primes", "integer", "integers", "ulam"], "likes": 7, "viewed": 275, "published": 3, "date": "1645917325", "time_retrieved": "2024-07-30T17:01:08.458372", "image_code": "int sqr(int n) {\n    return n * n;\n}\n\n// thanks to @Envy24 for optimized version of this routine.\nbool isPrime(int N) {\n    switch (N)\n    {\n    case 0:\n    case 1:\n        return false;\n    case 2:\n    case 3:\n    case 5:\n    case 7:\n        return true;\n    default:\n        break;\n    }\n\n    if ((N & 1) == 0) { return false; }\n\n    int n = 3;\n    bool r = true;\n    int limit = int(sqrt(float(N)));\n\n    do \n    { \n        r = (N % n) != 0;\n        n += 2;\n    } while (r &&\n        n <= limit);\n\n    return r;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    int pixelsPerPixel = iMouse.z > 1.0 ? 1 : 3;\n    ivec2 IJ = ivec2(XY) / pixelsPerPixel - ivec2(iResolution.xy) / 2 / pixelsPerPixel;\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J));\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    float c = isPrime(n) ? 0.0 : 1.0;\n\n    c = mix(0.15 * c, c, smoothstep(5.0, -5.0, sqrt(float(n)) - 3.0 * float(iFrame)));\n    \n    \n    RGBA = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 36], [38, 98, 119, 119, 516], [518, 518, 561, 561, 1483]]}
{"id": "7s2BRm", "name": "Fork Hammer 2D  Fatter lines", "author": "gchipunov", "description": "Simulates the format of the 2D viewport grid in the Valve Hammer level editor.", "tags": ["2d", "grid", "hammereditor"], "likes": 0, "viewed": 150, "published": 3, "date": "1645917169", "time_retrieved": "2024-07-30T17:01:09.209364", "image_code": "bool onGridline(int distFrom, int spacing);\nbool onSplitline(int distFrom, int spacing, int interval);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Colours , used to return to fragColor depending on criteria.\n\tconst vec4 cBackground = vec4(0.0,0.0,0.0,1.0);\t\t\t// Background colour.\n\tconst vec4 cOrigin = vec4(0.0,0.392,0.392,1.0);\t\t\t// Frag is directly in line with mouse's X or Y.\n\tconst vec4 cLargeSplit = vec4(0.392,0.18,0.004,1.0);\t// Frag is on a large split line.\n\tconst vec4 cMedSplit = vec4(0.449,0.449,0.449,1.0);\t\t// Frag is on a medium split line.\n\tconst vec4 cGridline = vec4(0.593,0.293,0.293,1.0);\t\t// Frag is on a grid line.\n\t\n\t// Grid lines\n\tconst int spacingStd = 16;\t\t\t// Spacing of normal grid lines\n\tconst int intervalLargeSplit = 16;\t// On how many gridlines a large split occurs.\n\tconst int intervalMedSplit = 8;\t\t// On how many gridlines a medium split occurs.\n\tconst float zoom = 1.0;\t\t\t// Zoom level of the grid.\n\t\n\t// Effective spacing\n\t// This is the standard grid spacing, as an integer, once zoom has been applied.\n\t// We do this here and use this value later to avoid float rounding errors.\n\tint effGrid = int(floor((float(spacingStd) * zoom) + 0.5)) ;\n\t\n\t// Convenience integer values for resolution and frag position.\n\tint fragX = int(fragCoord.x - 0.5);\n\tint fragY = int(fragCoord.y - 0.5);\n\tint width = int(iResolution.x);\n\tint height = int(iResolution.y);\n\t\n\t// The offsets to the original mouse position were found by trial and error.\n\tint mouseX = int(iMouse.x);\n\tint mouseY = int(iMouse.y - 1.0);\n\t\n\t// Distance this frag is from the mouse position, in each axis.\n\tint xDistFrom = int(abs(float(mouseX - fragX)));\n\tint yDistFrom = int(abs(float(mouseY - fragY)));\n\t\n\t// ============================================================\n\t\n\t// If on same X or Y as mouse, paint with origin colour.\n\tif ( fragX == mouseX || fragY == mouseY )\n\t{\n\t\tfragColor = cOrigin;\n\t\treturn;\n\t}\n\t\n\t// If on grid line, decide which colour to paint.\n\telse if ( onGridline(xDistFrom, effGrid) || onGridline(yDistFrom, effGrid) \n    ||\n     onGridline(xDistFrom-1, effGrid) || onGridline(yDistFrom-1, effGrid) \n      ||\n     onGridline(xDistFrom+1, effGrid) || onGridline(yDistFrom+1, effGrid) \n    )\n\t{\n\t\t// If on large split line, choose this first.\n\t\tif ( onSplitline(xDistFrom, effGrid, intervalLargeSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalLargeSplit))\n\t\t{\n\t\t\tfragColor = cLargeSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Then check medium split line.\n\t\telse if ( onSplitline(xDistFrom, effGrid, intervalMedSplit) ||\n\t\t     onSplitline(yDistFrom, effGrid, intervalMedSplit))\n\t\t{\n\t\t\tfragColor = cMedSplit;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Otherwise, return normal grid line colour.\n\t\telse\n\t\t{\n\t\t\tfragColor = cGridline;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// Fragment is not in line with any grid line - paint as background.\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a grid line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @return True if distFrom lies on a gridline, false otherwise.\nbool onGridline(int distFrom, int spacing)\n{\n\treturn mod(float(distFrom), float(spacing)) == 0.0;\n}\n\n// @brief Returns whether the given fragment distance from the mouse axis lies on a split line.\n// @param distFrom Units the fragment is away from the mouse axis value. 0 = on the same axis.\n// @param spacing The units between each consecutive grid line.\n// @param interval On how many gridlines a split occurs. Eg. 4 would imply a split every 4\n//\t\t  grid spacing amounts.\n// @return True if distFrom lies on the split line, false otherwise.\nbool onSplitline(int distFrom, int spacing, int interval)\n{\n\tint newSpacing = spacing * interval ;\n\t\n\treturn mod(float(distFrom), float(newSpacing)) == 0.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2BRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2877, 3196, 3240, 3240, 3295], [3297, 3740, 3799, 3799, 3898]]}
{"id": "7sjBRm", "name": "High quality Gaussian dithering", "author": "Michel_Rouzic", "description": "Helps achieve an image quality equivalent to having a higher bit depth. See description at the top of the shader code.", "tags": ["noise", "random", "hash", "dithering", "prng"], "likes": 6, "viewed": 317, "published": 3, "date": "1645915451", "time_retrieved": "2024-07-30T17:01:09.972324", "image_code": "#define levels 31.           // 255. for 8-bit output, 127. for 7-bit output etc...\n#define square_scale 0.15    // make it bigger to make the squares bigger\n#define noise_frame_div 1    // make it bigger to make the noise only change every noise_frame_div frames\n\n/*\nThis is the Gaussian dithering algorithm I've been using for years, as described here:\nhttps://stackoverflow.com/a/15793794/1675589\n\nBy default a lower bit depth of 5-bit per channel is simulated so that the effect is more evident,\nusing a levels value (see line #1) of 31. The pixels are enlarged to make the effect clearer, and\nyou can pause the shader to see what each pixel looks like at a given time and see that only a\nhandful of different colours are used. You can also increase noise_frame_div to like 1000 to see\nhow it would look if the noise pattern rarely changed. The dithering looks smoother if you lower\nsquare_scale, which makes the pixels smaller.\n\nThe core of the PRNG is a hash function based on github.com/skeeto/hash-prospector. The random\n32-bit integer is then turned into a float in the ]-1 , 1[ range and then a well-known rough\napproximation of the inverse error function is applied to give it a Gaussian distribution.\nWhen colours approach 0 or 1 the intensity of the noise is reduced as to avoid introducing a bias.\nWithout it white wouldn't look as white because the positive noise would be crushed but the\nnegative noise would still darken the image, and black would look like a dark grey noise,\nwhich is undesirable. I tweaked everything to achieve the best lack of banding with the least noise.\n\nBesides the dithering code which is very cool and that I consider essential to making high quality\ngraphics equivalent to having a much superior bit depth, a cool part of this shader that I also\nconsider essential for a different reason is the sinusoidal colour gradient. I use it all the\ntime whenever I need some procedural colours, it's much better than always using a max saturation\ncolour wheel, it produces a natural palette that doesn't seem to ever quite repeat itself. I\nstrongly recommend using such an approach for generating colours.\n\nDithering is done in sRGB therefore it introduces a slight upwards bias, I'm open to suggestions\non how to cancel that out, although at 8-bits that's not really a big deal.\n\nThis shader code is derived from my OpenCL code:\nhttps://github.com/Photosounder/rouziclib/blob/master/rouziclib/graphics/drawqueue/opencl/srgb.cl\n*/\n\nuint rand_xsm32(uint x)\n{\n\tx ^= x >> 16;\n\tx *= 0x21f0aaadu;\n\tx ^= x >> 15;\n\tx *= 0x735a2d97u;\n\tx ^= x >> 15;\n\treturn x;\n}\n\nfloat gaussian_rand_approx(uint pos)\t// max error of the resulting Gaussian distribution: 9.8e-3\n{\n\tfloat r = (float(rand_xsm32(pos)) - 2147483647.5) * 4.6566125e-10;\t\t// r = ]-1 , 1[\n\n\treturn 0.88622693f * sqrt(-log(1. - r*r)) * sign(r);\t\t// gives a e^-x^2 distribution, [-3.54 , 3.54]\n}\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat lsrgb(float l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tfloat x, line, curve;\n\n\t// 13 FR every time + 2 FR once\n\tline = l * 12.92;\t// 1 FR\n\tx = sqrt(l);\t// 4 FR\n\tcurve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\t// 5 FR + 2 FR once, error 0.145 sRGB units\n\n\treturn l <= 0.0031308 ? line : curve;\t// 3 FR\n}\n\nfloat apply_dithering(float pv, float dv)\n{\n\tconst float threshold = 1.2 / levels;\n\tconst float it = 1. / threshold;\n\tconst float rounding_offset = 0.5 / levels;\n\n\t// Reduce the scale of the dithering if pv is close to 0\n\tif (pv < threshold)\t// 1.2 is the threshold so that the crushing happens at 1.2*sqrt(2) = 1.7 sigma\n\t{\n\t\tif (pv <= 0.)\n\t\t\treturn 0.;\n\t\telse\n\t\t\tdv *= pv * it;\n\t}\n\n\t// Same if pv is close to 1\n\tif (pv > 1. - threshold)\n\t{\n\t\tif (pv >= 1.)\n\t\t\treturn 1.;\n\t\telse\n\t\t\tdv *= (1.-pv) * it;\n\t}\n\n\treturn pv += dv + rounding_offset;\n}\n\nvec3 linear_to_srgb(vec3 pl0, uint prng_pos, int use_dithering)\n{\n\tvec3 pl1;\n\tfloat dith;\n\tconst float dith_scale = 0.70710678 / levels;\n\n\tpl0 = clamp(pl0, 0., 1.);\n\n\tpl1.r = lsrgb(pl0.r);\t\t// blue\n\tpl1.g = lsrgb(pl0.g);\t\t// green\n\tpl1.b = lsrgb(pl0.b);\t\t// red\n\n\t// Dithering\n\tdith = gaussian_rand_approx(prng_pos) * dith_scale;\n    if (use_dithering == 0)\n        dith = 0.;\n\n\tpl1.r = apply_dithering(pl1.r, dith);\n\tpl1.g = apply_dithering(pl1.g, dith);\n\tpl1.b = apply_dithering(pl1.b, dith);\n\n\t// Lower bit depth simulation\n\tif (levels < 255.)\n\t\tpl1 = round(pl1 * levels) * (1./levels);\n\n\treturn pl1;\n}\n\nfloat gaussian(float x)\n{\n\treturn exp(-x*x);\n}\n\nfloat point_weight(vec2 dp, float rad, vec2 pf)\n{\n\tfloat d = distance(dp, pf) * rad;\t// distance of the pixel from the centre of the dot, scaled\n\n\treturn gaussian(d);\n}\n\nvec3 value_to_sin_gradient(float v)\n{\n    vec3 g = vec3(v) * vec3(0.36, 0.187, 0.13) + vec3(0.2);\n    g = sin(g) * 0.5 + 0.5;\n    return g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int prng_pos;\n    ivec2 pix_pos;\n    \n    // Pixel to world coordinates\n    float scrscale = 18. / iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5) * scrscale;\n    vec2 uvr = round(uv * (1./square_scale));\n    pix_pos = ivec2(uvr);\n    uvr *= square_scale;\n\n    // Colour gradient\n    vec3 pv = vec3(0.);\n    float source_angle = iTime * 0.1;    // speed of rotation of the Gaussian dot\n    float v = point_weight(vec2(sin(source_angle), cos(source_angle))*10., 0.08, uvr);\n    pv = value_to_sin_gradient(29. + iTime*0.2 + v*4.);\n    \n    // Dithering PRNG position\n    prng_pos = (iFrame/noise_frame_div*int(iResolution.y) + pix_pos.y)*int(iResolution.x) + pix_pos.x;\n\n    // Output to screen\n    pv *= 1. - 0.25*gaussian(uv.y*16.);       // Split\n    fragColor = vec4(linear_to_srgb(pv, uint(prng_pos), uv.y > 0. ? 0 : 1), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2468, 2468, 2493, 2493, 2589], [2881, 2881, 2900, 2900, 2920], [2922, 2922, 3011, 3011, 3301], [3303, 3303, 3346, 3346, 3846], [3848, 3848, 3913, 3913, 4453], [4455, 4455, 4480, 4480, 4501], [4503, 4503, 4552, 4552, 4671], [4673, 4673, 4710, 4710, 4814], [4816, 4816, 4871, 4871, 5718]]}
{"id": "ss2Bzw", "name": "nested boxes", "author": "lwswl", "description": "nested", "tags": ["nested"], "likes": 0, "viewed": 130, "published": 3, "date": "1645911166", "time_retrieved": "2024-07-30T17:01:10.733290", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(1);\n    int i=0; \n    vec4 bb=vec4(0,0,1,1);\n    while(i<100){\n        if(fragCoord.x>iResolution.x*bb.x)\n        if(fragCoord.y>iResolution.y*bb.y)\n        if(fragCoord.x<iResolution.x*(bb.z+bb.x))\n        if(fragCoord.y<iResolution.y*(bb.w+bb.y)){\n            bb.z*=0.5;\n            bb.w*=0.5;\n            if (i%3==0)\n            bb.x+=bb.z;\n            if (i%2==0)\n            bb.y+=bb.w;\n            fragColor*=0.5;\n        }\n        else break;\n        i+=1;\n       \n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Bzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 563]]}
{"id": "ssjBzw", "name": "Twitch shader bars", "author": "mrange", "description": "CC0: Twitch stream hacking\nI have begun twitch streaming a bit of shader hacking with an old friend \nthat wants to learn some shader tricks. \n", "tags": ["2d"], "likes": 13, "viewed": 272, "published": 3, "date": "1645909199", "time_retrieved": "2024-07-30T17:01:11.515199", "image_code": "// CC0: Twitch shader bars\n// I have begun twitch streaming a bit of shader hacking with an old friend \n// that wants to learn some shader tricks. \n// We have been looking to recreate classic rasterbars in shaders as a learning experience\n// Ofc with shaders we are not as limited as we were in the 90s\n// This was my result from the stream\n\n// Nothing complicated but I thought it turned out appealing so sharing.\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int bars = 14;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 rasterbar(vec2 p, float bf, float aa, float z) {\n  p = p.yx;\n  \n  const float hw = 0.2;\n  float d = abs(p.y) - hw;\n  float x = p.y/hw;\n  \n  float df = sqrt(max(1.0-x*x, 0.0));\n  vec3 col = hsv2rgb(vec3(bf, df, smoothstep(0.2, 0.9, z*abs(p.x))*(1.0-0.5*df)));\n  col = mix(vec3(1.0), col, mix(0.0, 1.0, exp(-1.*max((1.0-bf-0.1), 0.0))));\n  \n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nvec3 alphaBlend(vec3 bg, vec4 fg) {\n  return mix(bg, fg.xyz, fg.w);\n}\n\nfloat offset(float tm) {\n  return 1.5*sin(tm)*mix(0.25, 1.0, 0.5+0.5*sin(sqrt(0.5)*tm*0.2));\n}\n\nfloat doffset(float tm) {\n  const float eps = 0.01; \n  return (offset(tm+eps)-offset(tm-eps))/(2.0*eps);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(1.0);\n  \n  for (int i = 0; i < bars; ++i) {\n    vec2 pp = p;\n    float ii = float(i);\n    float bf = ii/float(bars);\n    float itime = TIME + 0.2*ii;\n//    pp *= ROT(0.5*itime);\n    float off = offset(itime); \n    float doff = doffset(itime); \n    float zo = mix(0.5, 1.0, (bf));\n    pp /= zo;\n    pp.x += off; \n    pp *= ROT(0.2*doff);\n    float zi = max(length(pp)-0.2, 0.0); \n    pp /= zi;\n\n    vec4 rcol = rasterbar(pp, bf, aa*zi*zo, zi);\n    col = alphaBlend(col, rcol);\n  }\n  \n  col = mix(vec3(1.0), col, smoothstep(0.5, 3.0, TIME));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[554, 654, 675, 675, 748], [749, 849, 871, 871, 920], [1076, 1076, 1098, 1098, 1244], [1246, 1246, 1299, 1299, 1650], [1652, 1652, 1687, 1687, 1721], [1723, 1723, 1747, 1747, 1817], [1819, 1819, 1844, 1844, 1925], [1927, 1927, 1982, 1982, 2720]]}
{"id": "7djBzw", "name": "Pulsating Blob", "author": "lwswl", "description": "pulsating blob", "tags": ["blob", "pulsating"], "likes": 0, "viewed": 144, "published": 3, "date": "1645907424", "time_retrieved": "2024-07-30T17:01:12.339994", "image_code": "vec3 sphere(in vec3 col,in vec4 s,in vec3 albedo){\n\tcol+=albedo*(s.w/dot(s.xyz,s.xyz));\n\treturn col;\n\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*10.0;\n    vec3 pos=vec3(uv,1.0);\n    vec3 col=vec3(0.1);\n\tfor(int i=0;i<100;i++){\n\t\tfloat f=float(i);\n\t\tcol=sphere(col,vec4(pos+vec3(cos(iTime+0.3+f*1.4),sin(iTime+f*1.3),cos(iTime+f*1.2)),sin(iTime*1.2+f*10.2)),vec3(0,1,0));\n\t}\n    fragColor.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 104], [105, 105, 162, 212, 511]]}
{"id": "fd2BRm", "name": "painted 3D scene", "author": "mdb", "description": "experiment on paint brush as texture", "tags": ["raytracing", "paint", "stylized", "brush", "strokes"], "likes": 27, "viewed": 701, "published": 3, "date": "1645894976", "time_retrieved": "2024-07-30T17:01:13.375226", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = 1.0 - exp(-texture(iChannel0, uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//inspired from: https://www.shadertoy.com/view/XllGRl\n\n#define NUMBER_STROKES 500\n#define MULT 2\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n/* brush                                                                            */\n//////////////////////////////////////////////////////////////////////////////////////\n\n//Random\n\nuint seed = 2647417u;\nuint seed3;\n\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid hash2(){\n    seed3 ^= 2747636419u;\n    seed3 *= 2654435769u;\n    seed3 ^= seed3 >> 16;\n    seed3 *= 2654435769u;\n    seed3 ^= seed3 >> 16;\n    seed3 *= 2654435769u;\n}\n\nfloat random2(){\n    hash2();\n    return float(seed3)/4294967295.0;\n}\n\nfloat noise(vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0 - 2.0*f);\n    \n    vec2 p = floor(x);\n\tfloat a = texture(iChannel0, (p+vec2(0.0, 0.0))/256.0).x;\n\tfloat b = texture(iChannel0, (p+vec2(1.0,0.0))/256.0).x;\n\tfloat c = texture(iChannel0, (p+vec2(0.0,1.0))/256.0).x;\n\tfloat d = texture(iChannel0, (p+vec2(1.0,1.0))/256.0).x;\n\n    \n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nvec2 seed2 = vec2(0.0);\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    x += seed2;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\n#define PI 3.14159265359\n\n\n\nvec2 mn = vec2(0.0, 0.0);\nvec3 random_sphere(){\n    const float a = 4.0*PI/float(NUMBER_STROKES);\n    const float d = sqrt(a);\n    const float M1 = round(PI/d);\n    const float d1 = PI/M1;\n    const float d2 = a/d1;\n\n    float teta = PI*(mn.x + 0.5)/M1;\n    float M2 = round(2.0*PI*sin(teta)/d2);\n\n    float phi = 2.0*PI*mn.y/M2;\n\n    mn.y += 1.0;\n    if (mn.y > M2){\n        mn.x += 1.0;\n        mn.y = 0.0;\n    } \n    \n    teta += random() * 0.2 - 0.1;\n    phi += random() * 0.2 - 0.1;\n    return vec3(sin(teta)*cos(phi), cos(teta), sin(teta)*sin(phi));\n       \n}\n\nvec3 random_sphere2(){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    float s = sqrt(1.0-z*z);\n    return vec3(s*cos(teta), s*sin(teta), z);\n}\n//aux///////////\n\nvec3 colorRamp(vec3 col1, vec3 col2, vec3 col3, float t){\n    if (t < 0.5){\n        t*=2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col1, col2, t);\n    }else{\n        t = (t-0.5)*2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col2, col3, t);\n    }\n}\n\n//brush\n\nvec4 brush(vec2 uv){ //color && alpha\n    uv.y += 0.4*(fbm(vec2(uv.x*2.0, 0.5), 2) - 0.5);\n    //color\n    float t = 0.3 + 0.4*fbm(uv*vec2(10.0, 60.0) + 10.0, 3);\n    t += 0.6*fbm(uv*2.0+20.0, 2)-0.3;\n    t += 0.7*noise(seed2)-0.35;\n    \n    //strength\n    float b = 1.0;\n    b *= pow(fbm(uv*vec2(1.0, 3.0), 8), 2.0);\n    b *= smoothstep(0.9, 0.5, 2.0*max(abs(uv.x - 0.5), abs(uv.y - 0.5)));\n    b = smoothstep(0.17, 0.3, b);\n    \n    return vec4(colorRamp(vec3(0.404,0.133,0.357), \n                     vec3(1.000,0.690,0.259),\n                     vec3(0.753,0.165,0.165), t), b);\n}\n\nint rot_idx = 0;\nvec4 brush2(vec2 uv){ //color && alpha\n    uv.y += 0.4*(fbm(vec2(uv.x*2.0, 0.5), 2) - 0.5);\n    //color\n    float t = 0.3 + 0.4*fbm(uv*vec2(10.0, 60.0) + 10.0, 3);\n    t += 0.6*fbm(uv*2.0+20.0, 2)-0.3;\n    t += 0.7*noise(seed2)-0.35;\n    \n    //strength\n    float b = 1.0;\n    b *= pow(fbm(uv*vec2(1.0, 3.0), 8), 2.0);\n    b *= smoothstep(0.9, 0.5, 2.0*max(abs(uv.x - 0.5), abs(uv.y - 0.5)));\n    b = smoothstep(0.27, 0.3, b);\n    \n    vec3 colors[3] = vec3[3](\n        vec3(0.769,0.769,0.769),\n        vec3(0.188,0.169,0.153),\n        vec3(0.263,0.259,0.259)\n    );\n    rot_idx += 1;\n    rot_idx %= 3;\n    return vec4(colorRamp(vec3(0.204,0.157,0.114), \n                     colors[rot_idx],\n                     vec3(0.239,0.173,0.141), t), b);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n/* rtx                                                                              */\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec4 intersect(vec3 ro, vec3 rd, vec3 p, inout vec3 n){\n    float t = dot(p - ro, n)/dot(rd, n);\n    \n    if (t < 0.0) return vec4(-1.0);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (dot(n, up) > 0.95) up = vec3(0.7071, 0.0, 0.7071);\n    \n    vec3 u = normalize(cross(up, n));\n    vec3 v = cross(u, n);\n    \n    vec3 p2 = ro + rd*t;\n    vec2 uv;\n    \n    uv.x = dot(u, p2 - p);\n    uv.y = dot(v, p2 - p);\n    uv *= vec2(7.0, 10.0); //size\n    if(abs(uv.x) > 1.0 || abs(uv.y) > 1.0) return vec4(-1.0);\n    \n    uv = uv*0.5+0.5;\n    vec4 b = brush(uv);\n    \n    if (b.w < random2()) return vec4(-1.0);\n    \n    n = normalize(n + 0.5*v*(fbm(vec2(20.0, 60.0)*uv, 3) - 0.5));\n    \n    return vec4(t, b.rgb);\n}\n\n\nvec3 scene(vec3 ro, vec3 rd){\n    float t = 1e10;\n    vec3 col = vec3(0.000,0.000,0.000);\n    \n    for(int i = 0; i < NUMBER_STROKES; i++){\n       vec3 pos = random_sphere();\n       vec3 n = normalize(pos + 0.5*vec3(random(), random(), random()) - 0.25);\n       seed2 = vec2(random(), random()) * 256.0;\n       pos *= 0.5;\n       \n       if (dot(-ro, pos) > 0.0) continue;\n       \n       vec4 inter = intersect(ro, rd, pos, n);\n       if (inter.x > 0.0 && inter.x < t){\n           t = inter.x;\n           col = 0.5*vec3(0.059,0.102,0.122);\n           //light1\n           const vec3 l1 = normalize(vec3(1.0, 1.0, 0.0)); \n           const vec3 c1 = 2.0*vec3(1.000,0.812,0.302);\n           float dNL1 = dot(n, l1);\n           col += inter.yzw * c1 * max(0.0, dNL1);\n           if (dNL1 > 0.0)\n               col += c1 * pow(max(0.0, dot(reflect(normalize(pos - ro), n), l1)), 10.0);\n\n\n           //light2\n           const vec3 l2 = normalize(vec3(-1.0, 0.0, 0.2)); \n           const vec3 c2 = vec3(0.004,0.255,0.145);\n           col += inter.yzw * c2 * pow(max(0.0, dot(n, l2)), 4.0);\n               \n           \n       }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed3 = uint(fragCoord.y*iResolution.x + fragCoord.x) + uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    vec3 ro = vec3(sin(iTime*0.5), 0.5, cos(iTime*0.5));\n    \n    vec3 dir0 = normalize(-ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    vec3 col = vec3(0.0);\n    if (length(uv) < 0.6){\n    for(int i = 0; i < MULT; i++)\n        col += scene(ro, rd);\n    col /= float(MULT);\n    }\n    \n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).rgb, 0.3);\n    \n    \n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2BRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 150]]}
{"id": "sdjcD1", "name": " Cross Hatching Exp 1b", "author": "Yusef28", "description": "hatching", "tags": ["3d", "shading", "stripes", "rendering", "cross", "hatching", "style"], "likes": 5, "viewed": 584, "published": 3, "date": "1645894338", "time_retrieved": "2024-07-30T17:01:14.278810", "image_code": "\nfloat getEdge(vec2 fragCoord, float th)\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n   \n\t// simple sobel edge detection\n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).w\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).w;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).w\n    - texture(iChannel0, uv.xy-vec2(0., th)).w;\n    \n\n\t// hack: use g^2 to conceal noise in the video\n    float gr = gxr*gxr + gyr*gyr;\n\n    float g = pow(gr,9.99);\n    return clamp(g*1.,0.,1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.);\n   \n    //col = col1;\n    col = clamp(texture(iChannel0,uv).rgb,0.,1.);\n   // col = vec3(t);\n    col = mix(col, vec3(0.8,0.6,0.1)*1.,vec3(getEdge(fragCoord,0.0025)));\n    col = mix(col, vec3(0.0,0.3,0.8)*1.,vec3(getEdge(fragCoord, 0.0009)));\n    \n   //col = s40;\n   // col *= clamp(texture(iChannel1,uv*2.).rgb,0.,1.).x*1.2;\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 25.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.5); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig*1.2,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TEXTURE_STEP 1./6.\n#define EPS 0.001\n#define FAR 40.\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,-c);\n}\nfloat roundedBox(vec3 sp, vec3 dim, float r){\n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) \n    + length(max(sp, 0.0)) - r;    \n\n\n}\nfloat map(vec3 pos){\n    float d = 1000.;\n    vec3 flpos = floor((pos)/6.);\n    float rf = hash13(flpos);\n    pos = mod(pos,6.)-3.;\n    \n    if(hash13(flpos+100.)<0.5){\n    d = min(d, length(pos)-2.3+rf*0.4);}\n    else{\n    \n    d = min(d, roundedBox(pos, vec3(.5), 1.+rf*0.7));\n    }\n    //pos.xy *= rot(iTime);\n    //d = min(d, roundedBox(pos, vec3(1.), 0.1));\n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float d,t=0.;\n    for(float i = 0.; i < 96.; i++){\n        d = map(ro + rd*t);\n        \n        if(abs(d) < EPS || t > FAR){\n            break;\n        }\n        \n        t += d*0.95;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(EPS, 0.);\n    float dx = map(p - e.xyy) - map(p + e.xyy);\n    float dy = map(p - e.yxy) - map(p + e.yxy);\n    float dz = map(p - e.yyx) - map(p + e.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 getCameraDirection(vec2 uv, vec3 ro, vec3 ta){\n\n    vec3 fwd = normalize(ta-ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = cross(uu,fwd);\n    vec3 up = cross(fwd,ri);\n    return normalize(uv.x*ri + uv.y*up + fwd*1.);\n}\n\nvec2 render(vec2 fragCoord, inout vec3 lightColor)\n{\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col =vec3(0.);\n    vec3 ta = vec3(0.,0.,iTime*0.5);\n    vec3 ro = ta +  vec3(0.,0.,-2.);\n    if(iMouse.z > 0.5){\n        float rotScale = 4.;\n        ro.xz *= rot(8.*(iMouse.x/iResolution.x)-rotScale/2.);\n       // ro.yz *= rot(4.*(iMouse.y/iResolution.y)-rotScale/2.);\n    }\n    else{\n         //ro.xz *= rot(iTime*0.15);\n    }\n    vec3 lp1 = ro + vec3(50.,10.,1.);\n    vec3 lp2 = ro +  vec3(-50.,7.,2.);\n    \n    vec3 rd = getCameraDirection(uv,ro,ta);\n    float cs = cos(iTime*0.25);\n    float si = sin(iTime*0.25); \n    rd.xy*= mat2(cs, si, -si, cs);\n    rd.xz*= mat2(cs, si, -si, cs);\n    float t = trace(ro, rd);\n    float diff1 = 0., diff2 = 0., totalLight;\n    if(t < FAR){\n        vec3 pos = ro + rd*t;\n        vec3 flpos = floor((pos)/6.);\n        vec3 cc = hash33(flpos);\n        vec3 n = getNormal(pos);\n        diff1 = max(0.,dot(n,normalize(lp1-pos)));\n        lightColor = diff1*vec3(0.7,0.3,0.1)*2.;\n        diff2 =  max(0.,dot(n,normalize(lp2-pos)));\n        lightColor = mix(lightColor, vec3(0.2,0.8,0.8), diff2)*2.;\n        lightColor = lightColor*0.8 + 0.2*(hash13(flpos+8410.) < 0.5 ? \n                                       vec3(0.7,0.3,0.1) : \n                                       vec3(0.2,0.8,0.8));\n        lightColor += cc*0.25;\n        totalLight = diff1+diff2;\n        float stripe_Payments = smoothstep(0.23,0.25,abs(fract(pos.y/2./hash13(flpos))-0.5));\n        lightColor -= stripe_Payments*0.125;\n    }\n    else{\n        t = FAR;\n    }\n    \n\n    \n    return vec2(totalLight*0.5,t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(.9);\n    //uv/=3.;\n    \n    vec2 pointInTex1 = uv;\n    vec2 pointInTex2 = uv;\n    vec2 pointInTex3 = uv;\n    \n    //vec3 col1 = texture(iChannel0,pointInTex1).rgb;\n    //vec3 col2 = texture(iChannel0,pointInTex2).rgb;\n    //vec3 col3 = texture(iChannel0,pointInTex3).rgb;\n    //uv.y += iTime*0.01;\n    \n    \n   vec3 s20 = vec3(1.,0.,0.);//singleLines(uv,col,vec2(0.4,0.9),0.43);\n    vec3 s30 = vec3(1.,1.,0.);//singleLines(uv,col,vec2(0.3,1.4),0.36);\n    vec3 s40 = vec3(1.,0.,1.);//singleLines(uv,col,vec2(0.8,1.4),0.1);\n    s20 = singleLines(uv,col,vec2(0.4,0.9),0.43, 1.);\n    s30 = singleLines(uv,col,vec2(0.3,1.4),0.36, 2.);\n    s40 = singleLines(uv,col,vec2(0.8,1.4),0.28, 3.);\n    \n    vec3 d20 = vec3(0.,1.,0.);//singleLines(uv,col,vec2(0.4,0.9),0.43);\n    vec3 d30 = vec3(0.,1.,1.);//singleLines(uv,col,vec2(0.3,1.4),0.36);\n    vec3 d40 = vec3(0.,1.,0.);\n    d20 = doubleLines(uv,col,vec2(4.),0.3, 1.);\n    d30 = doubleLines(uv,col,vec2(4.),0.23, 2.);\n    d40 = doubleLines(uv,col,vec2(4.),0.11, 3.);\n    \n    \n   // vec3 mixCol1 = mix(col1,col2,clamp(uv.x,0.,0.6)/0.6);\n    //vec3 mixCol2 = mix(col2,col3,clamp(uv.x-TEXTURE_STEP,0.,1.)/0.6);\n   // col = mix(mixCol1,mixCol2,uv.x);\n    //mixCol1 = mix(col1,col2,clamp(uv.x,0.,0.6)/0.6);\n    //mixCol2 = mix(mixCol1,col3,clamp(uv.x-TEXTURE_STEP,0.,.6)/0.6);\n    ///col = mix(mixCol1,mixCol2,uv.x);\n    vec3 lightCol;\n    vec2 res = render(fragCoord, lightCol);\n    float d = (1.-clamp(res.x,0.,1.));\n    d = pow(d,1./1.5);\n    float t = res.y;\n    \n    vec3 tmp = mix(s20,s30,pow(clamp(d,0.,0.333)/0.333,1.));\n    \n    tmp = mix(tmp,s40,pow(clamp(d-TEXTURE_STEP*1.,0.,0.333)/0.333,1.));\n    tmp = mix(tmp,d20,clamp(d-TEXTURE_STEP*2.,0.,0.3333)/0.333);\n    tmp = mix(tmp,d30,clamp(d-TEXTURE_STEP*3.,0.,0.333)/0.333);\n    col = mix(tmp,d40,clamp(d-TEXTURE_STEP*4.,0.,.333)/0.33);\n    col = mix(col,s40*1.,float(t>= FAR));\n   /* d = 1.-d;\n    if(d > 0.9 )col = s20;\n    else if(d > 0.5)col = s30;\n    else col = s40;\n    col = tmp;*/\n    //;//col = singles40;//mix(col1,col2,t);\n    //col = col1;\n    //col = texture(iChannel0,uv).rgb;\n   // col = vec3(t);\n    //col = s40;\n    col = mix(col, lightCol, d*0.9);\n    col -= s40*0.05;\n    fragColor = vec4(col,t);\n}", "buffer_a_inputs": [], "common_code": "\nfloat rnd(float a){\n    return fract(sin(a*8194.561)*45279.194);\n}\n\n//from Dave_Hoskins\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat noise1d(float x){\n    float xl = floor(x);\n    float xr = fract(x);\n    return mix(rnd(xl),rnd(xl+1.),xr);\n}\n\nfloat randPath(vec2 uvFloor, float fr){\n    float xFloor = uvFloor.x;\n    float yFloor = uvFloor.y;\n    float path = mix(rnd(yFloor*593.+xFloor),\n                     rnd(yFloor*593.+xFloor + 1.), \n                     fr);\n    return smoothstep(0.,1.,path);\n}\n\n#define shadowCol1 vec3(0.2,0.3,0.4)*2.\n#define shadowCol2 vec3(0.3,0.2,0.1)*2.\n\nvec3 singleLines(vec2 uv, vec3 col, vec2 scale, float theStep, float shade){\n   \n   // vec2 scale = vec2((2.+floor(uv*3.))*20.);\n    vec2 flUV = floor(uv*scale*80.);\n    vec2 frUV = fract(uv*scale*80.);\n    //col -= flUV.y/12.;\n    shade = shade/4.;\n    float lineNoise = noise1d(uv.x*80.+flUV.y*80.);\n    float line = smoothstep(theStep,\n                            theStep+0.1,\n                            0.5-abs(frUV.y-0.5-randPath(flUV,frUV.x)*0.43)\n                            );\n    col = mix(col,vec3(0.1),max(0.,line-lineNoise*0.64));\n    \n   /* line = smoothstep(0.4,\n                      0.5,\n                      0.5-abs(frUV.x-0.5-randPath(flUV.yx,frUV.y)*0.3)\n                      );*/\n    //col += line;\n    return col+shade;\n}\n\nvec3 doubleLines(vec2 uv, vec3 col, vec2 scale, float theStep, float shade){\n\n    //vec2 scale = vec2((2.+floor(uv*3.))*20.);\n    \n    vec2 flUV = floor(uv*scale*60.);\n    vec2 frUV = fract(uv*scale*60.);\n    //col -= flUV.y/12.;\n    float lineNoise = noise1d(uv.x*80.+flUV.y*80.);\n    \n    float line = smoothstep(theStep,\n                            theStep+0.1,\n                            0.5-abs(frUV.y-0.5-randPath(flUV,frUV.x)*0.3)\n                            );\n    col = mix(col,shadowCol1,max(0.,line-lineNoise*0.65));\n    \n    line = smoothstep(theStep,\n                      theStep+0.1,\n                      0.5-abs(frUV.x-0.5-randPath(flUV.yx,frUV.y)*0.3)\n                      );\n    col = mix(col,shadowCol2,max(0.,line-lineNoise*0.65));\n    shade = shade/5.;\n    return col-shade;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 520], [522, 522, 579, 629, 1335]]}
{"id": "fsjBRm", "name": "Variable Power Voronoi", "author": "tungster24", "description": "voronoi with variable power:\n", "tags": ["voronoi"], "likes": 5, "viewed": 165, "published": 3, "date": "1645887144", "time_retrieved": "2024-07-30T17:01:15.111583", "image_code": "#define POW 7.0\n#define T iTime\n#define DOT_SIZE 0.008\nfloat d(in vec2 P1,in vec2 P2) { //distance function with adjustable power\n    return pow(pow(abs(P1.x-P2.x),POW)+pow(abs(P1.y-P2.y),POW),1.0/POW);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    vec2 uv = P/iResolution.xy;\n    vec2 p1 = vec2(sin(T)/6.0+0.7,cos(T)/6.0+0.7);\n    vec2 p2 = vec2(sin(T*2.0)/6.0+0.3,cos(T*2.0)/6.0+0.3);\n    vec2 p3 = iMouse.xy/iResolution.xy;\n    if (ivec2(iMouse.xy) == ivec2(0,0)) p3 = vec2(0.0);\n    \n    vec4\n    R = vec4(1.0,0.0,0.0,1.0),\n    G = vec4(0.0,1.0,0.0,1.0),\n    B = vec4(0.0,0.0,1.0,1.0);\n\n    if(d(uv,p1) < min(d(uv,p2),d(uv,p3))) C = R;\n    if(d(uv,p2) < min(d(uv,p1),d(uv,p1))) C = G;\n    if(d(uv,p3) < min(d(uv,p1),d(uv,p2))) C = B;\n    \n    if (distance(p1,uv) < DOT_SIZE || distance(p2,uv) < DOT_SIZE || distance(p3,uv) < DOT_SIZE\n    \n    ) C+=vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 87, 129, 204], [206, 206, 247, 247, 867]]}
{"id": "fdjfzw", "name": "odos|C-A-T", "author": "ErinZ", "description": "3dversion of my basic shape cat~!", "tags": ["raymarching"], "likes": 7, "viewed": 312, "published": 3, "date": "1645879134", "time_retrieved": "2024-07-30T17:01:15.967296", "image_code": "#define TMIN 0.01\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.1415926\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//========SDFunctions========\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\nfloat sdCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a +t*ab;\n    return length(p-c)-r;\n}\n//https:iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n//===============TRANSFORM=================\nmat2 rotate(float a){\nreturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat smUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n//===============RENDER===================\n//Scene\nfloat f(vec3 p){\n    p.x=abs(p.x);\n    float d;\n    {//face\n    vec3 p0 = vec3(p.x*.8,p.y+.4,p.z);\n    d = sdSphere(p0,vec3(0),1.5); \n    p0 = vec3(p.x*.6,p.y+.6,p.z+.7);\n    float d0 = sdSphere(p0,vec3(0),1.);\n    d = smUni(d,d0,.3);\n    }\n    float angle = sin(iTime*5.)*.1;\n    {//ear\n    vec3 p0 = vec3(p.x-.85,p.y-.3,p.z*1.2+.3);\n    p0.xy *= rotate(-.3);\n    p0.yz *= rotate(-.3);\n    float d0 = sdRoundCone(p0,.8,.2,1.2)/1.2; \n    d = smUni(d,d0,.3);\n    }\n    {//nose\n    float d0 = sdCapsule(p,vec3(0,0,-1.5),vec3(0,-.6,-1.7),.3); \n    d = smUni(d,d0,.05);\n    }\n    {//nose\n    float d0 = sdSphere(p,vec3(.3,-.6,-1.65),.45); \n    d = smUni(d,d0,.05);\n    }\n    {//eye\n    vec3 p0 = vec3(p.x-.6,p.y+.1,p.z+1.45);\n    p0.xy *= rotate(-1.2);\n    p0.yz *= rotate(-0.3);\n    float d0 = sdRoundCone(p0,.06,.08,.2); \n    d = smUni(d,d0,.05);\n    }\n    {//\n    vec3 p0 = vec3(p.x-.9,p.y+.5,p.z+1.3);\n    p0.xy *= rotate(.2+angle*.5);\n    float d0 = sdCapsule(p0,vec3(0,0,0),vec3(.8,0,0),.1);\n    p0.xy *= rotate(-.4+angle*.5);\n    d0 = smUni(d0,sdCapsule(p0,vec3(0,0,0),vec3(.8,0,0),.1),.05);\n    d = smUni(d,d0,.05);\n    }\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nmat3 setCamera(in vec3 camtar, in vec3 campos, in float camro){\n    vec3 z = normalize(camtar-campos);\n    vec3 cp = vec3(sin(camro),cos(camro),0.);\n    vec3 x = normalize(cross(cp,z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(-5., 5.,-5);//light\n\n    //SET Camera\n    vec3 cam_tar = vec3(0,-.5,0);//cam target\n    float angle = pow(sin(iTime+.3),3.)*.5;\n    vec3 cam_pos = vec3(sin(angle),0,-cos(angle))*10.;//cam position\n\n    vec3 rd = vec3(uv,4.); //decide view width\n    if(iMouse.x!=0. || iMouse.y!=0. ){\n        float angle_x = -(iMouse.x /iResolution.x-0.5)  *0.5*PI;\n        float angle_y = (iMouse.y /iResolution.y-0.5)  *0.5*PI;\n        rd.yz *= rotate(angle_y);\n        rd.zx *= rotate(angle_x);}\n    rd = normalize(setCamera(cam_tar,cam_pos,0.)*rd);//viewing frustum\n\n    float t = rayMarch(cam_pos,rd);//raymarching\n    \n    vec3 color = mix(vec3(0,0,1),vec3(0,0,.6),uv.y*.5+.5);//background\n\n    if(t > TMAX) return color; \n    \n    vec3 p = cam_pos + t*rd;\n    vec3 n = calcNormal(p);\n    vec3 l = normalize(lightPos-p);//lightDir\n    vec3 h = normalize(l-rd);//\n\n    vec3 diffusecol = vec3(1.);//diffuse color\n    vec3 specol = vec3(1.);//specular color\n    vec3 cmrfl = .5*vec3(1)*textureLod(iChannel0,reflect(rd,n),1.).rgb;//cubemap reflection\n    \n    float dif = clamp(dot(l,n),0.,1.);//diffuse    \n    float spe = pow(clamp(dot(h,n),0.,1.),50.);//specular\n    float fresnel = pow(clamp(1. - dot(n,-rd),0.,1.),5.);\n\n    color = cmrfl + .1*dif*diffusecol + smoothstep(.6,1.,spe)*specol;//metal\n    color = smoothstep(0.,1.,color);//add contrast\n\n    color += fresnel*.4;\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    #if AA>1\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n    #else\n            uv = getuv(fragCoord);\n    #endif\n            color += render(uv);\n    #if AA>1\n        }\n    }\n    color /= float(AA*AA);\n    #endif\n\n \n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 227, 267, 267, 295], [296, 296, 343, 343, 497], [498, 544, 602, 664, 943], [944, 988, 1009, 1009, 1054], [1055, 1055, 1099, 1099, 1199], [1200, 1251, 1267, 1267, 2392], [2393, 2393, 2433, 2433, 2648], [2649, 2695, 2723, 2723, 2938], [2940, 2940, 3003, 3003, 3176], [3177, 3177, 3198, 3198, 4612], [4613, 4613, 4636, 4636, 4690], [5283, 5283, 5303, 5303, 5692]]}
{"id": "7ssBWj", "name": "spqr: blackle gated vol light", "author": "spqr", "description": "a", "tags": ["a"], "likes": 2, "viewed": 262, "published": 3, "date": "1645872744", "time_retrieved": "2024-07-30T17:01:16.810042", "image_code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat sph (vec3 p, float r) {\n  return length(p) -r;\n}\nfloat cyl (vec2 p,float r) {\n  return length(p) - r;\n}\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nfloat box(vec3 p, float s ) {\n    p = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n\n}\n\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n\nfloat map (vec3 p) {\n//geo\n    float domain = 1.;\n\n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n    if (  rando *.65< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p, vec3(.4));\n      \n        return u;\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p, vec3(.4));\n       \n        return u;\n    }\n   \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad = 0.;\n      break;\n   \n    } \n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=200; //50\n  float voldist = 25.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand ;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += .1/(0.01+(pow(ldistvol,1.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\nvec3 tune ( float t) {\n  vec3 p = vec3(0);\n  \n  float n = 1.;\n  \n  for ( float i=0.; i < 5.; i++) {\n      p.x += sin(t * n)/n;\n      p.y += sin((t + 11.)* n)/n;\n      \n      n *= 1.4;\n   \n     \n  }\n \n  return p;\n  \n}\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  float tt = iTime * 1.;\n  vec3 jump = vec3(1) * tick(iTime*.1)*14.;\n \n  vec3 s = vec3(10.,3.2,7.1)*iTime*.08 + jump;\n  \n  vec3 arm = vec3(17,0,0);\n  arm.xz *= rot(sin(iTime* .19));\n  arm.yz *= rot(sin(iTime*.23));\n  arm.yx *= rot(sin(iTime*.28));\n    \n  vec3 t = s + arm;\n\n\n  vec3 tensor = vec3(6);\n  \n  tensor *= sin(tt);\n  \n  \n  tensor.xz *= rot(tt);\n  tensor.yz *= rot(tt * .83);\n  tensor.xy *= rot(tt * .71);\n  \n  \n  tensor += t;\n  \n  \n  vec3 probe = tensor;\n\n  \n \n  \n  \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 1000.0;\n  float z;\n  bool hit = false;\n  for( z=0.; z<1000.; ++z) {\n  \n    float d=map(p);\n    if(d<0.01) { hit = true; break;}\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  vec3 hue = vec3(.1,.1,.2);\n  \n  vec3 col = hue;\n  //float ao = pow(1. - z/500.,1.);\n  //col *= ao;\n \n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n  float diff = max(0., dot(n,light)*.5 +.5);\n  col *= diff;\n  \n  \n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 2.03E-2) );\n  #define saturate(a) (clamp((a),0.,1.))\n float edge = saturate(length(n1-n2)/0.1);\n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n  vec3 vcol = vollight(probe, s , r, uv, dd);\n  col += vcol*.53;\n\n\n\n  \n  fragColor = vec4(col, 1);\n}\n/*\n   p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n\n*/\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 70, 70, 119], [121, 121, 140, 140, 211], [214, 214, 237, 237, 315], [316, 316, 336, 336, 515], [517, 517, 546, 546, 571], [572, 572, 600, 600, 626], [629, 629, 649, 649, 833], [836, 836, 857, 857, 906], [908, 908, 933, 933, 1402], [1404, 1404, 1427, 1427, 1553], [1594, 1613, 1636, 1636, 1751], [1752, 1752, 1781, 1781, 1838], [1950, 1950, 1973, 1973, 2015], [2017, 2038, 2064, 2064, 2466], [2468, 2527, 2548, 2548, 2748], [2751, 2751, 2771, 2777, 3394], [3396, 3396, 3416, 3416, 3485], [3487, 3487, 3507, 3507, 3549], [3551, 3551, 3573, 3573, 3655], [3660, 3660, 3733, 3733, 3982], [3987, 3987, 4063, 4063, 4322], [4325, 4325, 4395, 4395, 4977], [4979, 4979, 5001, 5001, 5195], [5197, 5197, 5223, 5223, 5348], [5350, 5350, 5369, 5369, 5478], [5480, 5480, 5537, 5537, 7293]]}
{"id": "7dlBRs", "name": "spqr: blackle gated domain 8", "author": "spqr", "description": "a", "tags": ["a"], "likes": 3, "viewed": 225, "published": 3, "date": "1645872734", "time_retrieved": "2024-07-30T17:01:17.724597", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat cyl (vec2 p, float r){\n    return length(p) - r;\n}\nfloat map(vec3 p) {\n\n    //geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.yz *= rot(.42);\n    q.xz *= rot(.4);\n  \n    q.xy *= rot(q.z/50.);\n    q.x += tt * 10.;\n    q.xz = mod( q.xz, 40.) - 20.;\n  \n    float uu = cyl(q.xz,.001);\n    glow += .04/(.1+pow(uu,1.8));\n    \n    float domain = 1.4;\n  ;\n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.04);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    //vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    //(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  // nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(0) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    //arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    //ray marching\n    for ( i = 0.; i < 1500.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>10000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  //col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i/500.,6.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n // if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 2.3E-2) );\n\n\n  float edge = saturate(length(n1-n2)/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n\n/*\n  \n  //float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n // vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlBRs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[313, 313, 331, 331, 404], [514, 514, 537, 537, 579], [581, 602, 628, 628, 1030], [1032, 1091, 1112, 1112, 1312], [1313, 1313, 1339, 1339, 1388], [1392, 1392, 1422, 1422, 1491], [1495, 1495, 1516, 1516, 1705], [1707, 1707, 1728, 1728, 1833], [1887, 1906, 1929, 1929, 2044], [2045, 2045, 2071, 2071, 2142], [2160, 2160, 2187, 2187, 2215], [2216, 2216, 2244, 2244, 2272], [2273, 2273, 2292, 2303, 3594], [3597, 3597, 3623, 3623, 3748], [3750, 3750, 3769, 3769, 3878], [3910, 3910, 3937, 3950, 5450], [5453, 5453, 5510, 5510, 5692]]}
{"id": "fdsBzs", "name": "spqr: blackle gated domain 7", "author": "spqr", "description": "a", "tags": ["a"], "likes": 3, "viewed": 188, "published": 3, "date": "1645872726", "time_retrieved": "2024-07-30T17:01:18.477584", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat map(vec3 p) {\n\n    //geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.xy *= rot(q.z/10.);\n    q.x += tt * 10.;\n    q = mod( q, 16.) - 8.;\n  \n    float uu = sph(q,.00001);\n    glow += .1/(.1+pow(uu,2.));\n    \n    float domain = 1.5;\n  ;\n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.1);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    //vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    //(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  // nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(1) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    //arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    //ray marching\n    for ( i = 0.; i < 800.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>1000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i/500.,1.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n // if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 1.03E-2) );\n\n\n  float edge = saturate(length(n1-n2)/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n\n/*\n  \n  //float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n // vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsBzs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[313, 313, 331, 331, 404], [514, 514, 537, 537, 579], [581, 602, 628, 628, 1030], [1032, 1091, 1112, 1112, 1312], [1313, 1313, 1339, 1339, 1388], [1392, 1392, 1422, 1422, 1491], [1495, 1495, 1516, 1516, 1705], [1707, 1707, 1728, 1728, 1833], [1887, 1906, 1929, 1929, 2044], [2045, 2045, 2071, 2071, 2142], [2160, 2160, 2187, 2187, 2215], [2216, 2216, 2235, 2246, 3480], [3483, 3483, 3509, 3509, 3634], [3636, 3636, 3655, 3655, 3764], [3796, 3796, 3823, 3836, 5333], [5336, 5336, 5393, 5393, 5575]]}
{"id": "fs2BRD", "name": "spqr: artifact highway", "author": "spqr", "description": "a", "tags": ["a"], "likes": 3, "viewed": 213, "published": 3, "date": "1645872691", "time_retrieved": "2024-07-30T17:01:19.511818", "image_code": "\n#define ANTIALIAS\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n \n  float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n} \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  return i + r;\n}\nfloat tock(float t){ \n    float n = atan(20.*sin(t)/atan(20.));\n    n = n*.5 + .5;\n    return n;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n/*\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n*/\nfloat runner (vec3 p) {\n    return box(p, vec3(.5));\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  float u = fract(t);\n  vec3 a = lattice(floor(t));\n  vec3 b = lattice(floor(t+1.));\n  vec3 c = lattice(floor(t+2.));\n  \n  vec3 ab = mix(a,b,u);\n  vec3 bc = mix(b,c,u);\n  \n  return mix(a,b,u);\n\n  \n}\n\nint matter = 0;\nfloat artifact(vec3 p) {\n\n  \n  \n \n\n  vec3 pt=p;\n \n\n  float width = 5.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nfloat lane(vec3 p, vec3 dim, float domain, float prob) {\n\n   \n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    // wierd skylights\n    q.yz *= rot(.42);\n    q.xz *= rot(.4);\n  \n    q.xy *= rot(q.z/50.);\n    q.x += tt * 10.;\n    q.xz = mod( q.xz, 40.) - 20.;\n  \n    //float uu = cyl(q.xz,.001);\n    //glow += .04/(.1+pow(uu,1.8));\n    \n   \n   \n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.04);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n    \n    vec3 jitter = vec3(0);//flit * sin((tt*9.1+rando*12.1));\n  \n    \n    if (  rando * prob < thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        //float u = box(p + jitter, vec3(.4));\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        //return length(p)-1.;\n        //float u = box(p + jitter, vec3(.4));\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nfloat highway(vec3 p){\n\n   \n    float tt = iTime * 0.1;\n   \n    vec3 ap = p  + tt * 45.1 * vec3(0,0,1);\n    vec3 bp = p  + tt * 6.1 * vec3(0,0,1);\n    vec3 cp = p  + tt * 1.1 * vec3(0,0,1);\n    \n    float u = 1.;\n    float a = lane(ap, vec3(.6)*u*1.4,       2.4*u, .4);\n    float b = lane(bp, vec3(.3,.3,8.)*u, 7.1*u, .71);\n    float c = lane(cp, vec3(15,15,5.1)*u,        51.1*u, .8);\n   \n    return min(c,min(a,b));\n    \n \n}\n\n\nfloat map(vec3 p){\n\n     // geo\n     \n    float a = artifact(p);\n   // return a;\n    float b = highway(p);\n    //return b;\n    return max(a,b);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  //vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n  // nav\n\n  float tt = iTime * .03;\n  \n  vec3 s = lattice(tt)*15.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  vec3 t = lattice(tt + 33.)*15.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 100. * arm;\n  t += tock(tt * 3.) * 100. * arm;\n \n\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n \n   \n  float fov =  .8;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*fov);\n \n  r.z -= dot(uv,uv)/10.;\n\n  \n  vec3 p=s;\n  float d = 0.;\n  float dd = 0.;\n  float edge = 0.;\n  float i = 0.;\n  vec3 n1,n2;\n  \n  bool hit = false;\n  \n  \n  // march\n  \n  for(float nn=0.;nn<200.;nn++){ \n    i =nn;\n    d=map(p);\n    \n    if ( d < .001 ) {\n      hit = true;\n      break;\n    }\n      \n     \n    if ( dd > 100.) {\n        break;\n    }\n    p += r * d;\n    dd += d;\n    \n  }\n \n \n\n   \n \n  vec3 col;\n  \n  col = vec3(.8,.4,.2);\n  \n  float ao = pow(1. - i/100.,.5);\n  \n  col *= ao;\n  \n  col *= 1.7;\n  \n\n  \n  \n  n2=norm(p, vec2(0.0, 1.0E-2) );\n  n1=norm(p, vec2(0.0, 2.50E-2) );\n  edge=saturate(length(n1-n2)/0.1);\n  col -= edge*100.;\n \n  \n  if ( ! hit ) { \n      vec3 hue = 1. - vec3(.8,.5,.2);\n      col = mix( vec3(.5), hue, r.x);\n      col = mix(vec3(0), vec3(1.), pow(dot(r,normalize(vec3(1,0,0))*.5+.5),.4));\n \n  }\n  \n\n  \n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2BRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 225, 225, 328], [329, 329, 351, 351, 559], [561, 561, 615, 670, 894], [896, 896, 920, 920, 1117], [1121, 1121, 1150, 1150, 1215], [1216, 1216, 1258, 1258, 1365], [1367, 1367, 1390, 1390, 1498], [1500, 1500, 1524, 1524, 2071], [2073, 2073, 2095, 2095, 2303], [2305, 2305, 2330, 2330, 2363], [2365, 2365, 2387, 2387, 2505], [2510, 2510, 2539, 2539, 2568], [2569, 2569, 2590, 2590, 2637], [2638, 2638, 2657, 2657, 2726], [2729, 2729, 2754, 2754, 2794], [2799, 2799, 2813, 2813, 2853], [2856, 2856, 2892, 2892, 2945], [2969, 2969, 2993, 2993, 3048], [3051, 3051, 3075, 3075, 3161], [3166, 3166, 3192, 3192, 3241], [3243, 3243, 3265, 3265, 3354], [3355, 3355, 3375, 3375, 3453], [3455, 3455, 3494, 3494, 3571], [3574, 3574, 3604, 3604, 3630], [3633, 3633, 3671, 3671, 3959], [3962, 3962, 3985, 3985, 4098], [4099, 4099, 4120, 4120, 4519], [4521, 4521, 4543, 4543, 4748], [4750, 4750, 4777, 4777, 4803], [4805, 4805, 4833, 4833, 4864], [4865, 5087, 5110, 5110, 5141], [5143, 5143, 5171, 5171, 5204], [5208, 5208, 5229, 5229, 5278], [5279, 5279, 5299, 5299, 5348], [5349, 5349, 5369, 5369, 5748], [5749, 5749, 5774, 5774, 6243], [6246, 6246, 6266, 6266, 6450], [6452, 6452, 6475, 6475, 6674], [6692, 6692, 6716, 6716, 7268], [7309, 7328, 7351, 7351, 7466], [7467, 7467, 7523, 7523, 8706], [8708, 8708, 8730, 8730, 9134], [9137, 9137, 9155, 9168, 9282], [9284, 9284, 9331, 9331, 9544], [9548, 9548, 9574, 9574, 9699], [9702, 9702, 9722, 9722, 9841], [9853, 9853, 9910, 9971, 11599]]}
{"id": "7tGXDd", "name": "spqr: artifact alone", "author": "spqr", "description": "a", "tags": ["a"], "likes": 2, "viewed": 182, "published": 3, "date": "1645872668", "time_retrieved": "2024-07-30T17:01:20.277771", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n    //pt.xz=pt.x<pt.z?pt.zx:pt.xz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\nint matter = 0;\nfloat map(vec3 p) {\n\n  // geo\n  \n  vec3 p1 = p;\n  vec3 p2 = p;\n  vec3 p3 = p;\n  vec3 p4 = p;\n  vec3 p5 = p;\n  vec3 p6 = p;\n\n\n\n \n  //float final = R;\n  float final=10000.;\n  \n vec3 pt=p;\n  \n  //vec3 pr = p;\n  //pr = p + vec3(10,-27.565,243.7 * time)/3.3; \n  //pr = rep(pr, vec3(20,50,20));\n  //float run = runner(pr);\n  \n  \n  \n  //float width = mix(5.,15., abs(sin(iTime/100.)));\n  float width = 13.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(pt,vec3(3.6,3.0+0.4+iTime/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  dist=box(pt,vec3(.17));\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\n\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  float tt = iTime;\n  \n  // nav\n  \n  vec3 s = vec3(0,0,-5);\n  s = lattice(tt) * 10.;\n  \n  vec3 t =  vec3(0,0,0);\n  \n   \n  \n  s *= 1.;(sin(tick(tt*.21)) * .5 + .5) +1.;\n  float t1 =tock(tt * 1.21);\n  float t2 =tock(tt * 1.0);\n  float t3 =tock(tt * .81);\n  s.yz *= rot(t1);\n  s.xz *= rot(t2);\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz += dot(uv,uv)/5.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<100.;z++){ \n  \n    i = z;\n    d = map(p);\n\n    if ( d < .001 ) {\n      hit = true;\n      break;\n    } \n    \n    dd += d;\n    p += r * d;\n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(.8, .5, .2);\n  float ao = i/100.;\n  col -= ao ;\n\n\n  n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  n1 = norm(p, vec2(0.0, 1.4E-2) );\n\n\n  edge = saturate(length(n1-n2)/0.1);\n  \n  col -= edge;\n\n  \n  if (! hit){\n      col = vec3(.93, .95, .90);\n      col = vec3(1);\n  }\n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n/*\n//  n2 = norm(p, vec2(0.0, 1E-2+3E-2*.01) );\n//  n1 = norm(p, vec2(0.0, 2E-2) );\n\n*/\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 208, 208, 311], [312, 312, 334, 334, 542], [544, 544, 598, 653, 877], [879, 879, 903, 903, 1105], [1109, 1109, 1138, 1138, 1203], [1204, 1204, 1246, 1246, 1353], [1355, 1355, 1378, 1378, 1486], [1488, 1488, 1512, 1512, 2059], [2061, 2061, 2083, 2083, 2291], [2293, 2293, 2318, 2318, 2351], [2353, 2353, 2375, 2375, 2493], [2497, 2497, 2518, 2518, 2567], [2568, 2568, 2588, 2588, 2637], [2639, 2639, 2660, 2660, 2707], [2708, 2708, 2727, 2727, 2796], [2797, 2797, 2817, 2817, 3196], [3197, 3197, 3222, 3222, 3691], [3693, 3693, 3716, 3716, 3794], [3795, 3795, 3815, 3815, 3999], [4001, 4001, 4024, 4024, 4150], [4153, 4153, 4182, 4182, 4211], [4215, 4215, 4240, 4240, 4280], [4285, 4285, 4299, 4299, 4339], [4342, 4342, 4378, 4378, 4431], [4455, 4455, 4479, 4479, 4534], [4537, 4537, 4561, 4561, 4647], [4656, 4656, 4676, 4676, 4890], [4891, 4891, 4917, 4917, 4966], [4970, 4970, 5009, 5009, 5086], [5089, 5089, 5119, 5119, 5145], [5148, 5148, 5186, 5186, 5509], [5512, 5512, 5535, 5535, 5648], [5649, 5649, 5670, 5670, 6069], [6071, 6071, 6093, 6093, 6298], [6300, 6300, 6327, 6327, 6353], [6355, 6355, 6383, 6383, 6414], [6415, 6415, 6439, 6439, 6630], [6637, 6637, 6706, 6706, 7012], [7029, 7029, 7048, 7058, 7844], [7849, 7849, 7875, 7875, 8000], [8003, 8003, 8023, 8023, 8142], [8148, 8148, 8169, 8169, 8192], [8196, 8196, 8253, 8253, 9524]]}
{"id": "7ssfDX", "name": "odos|reflect&refract", "author": "ErinZ", "description": "tried soft shadows refering to iq https://iquilezles.org/articles/rmshadows/rmshadows.htm\nbut with some problem with the shadow line.....", "tags": ["raymarching"], "likes": 3, "viewed": 277, "published": 3, "date": "1645872233", "time_retrieved": "2024-07-30T17:01:21.189333", "image_code": "#define TMIN 0.01\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.1415926\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//========SDFunctions========\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\nfloat sdCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a +t*ab;\n    return length(p-c)-r;\n}\nfloat sdTorus(vec3 p,vec3 o, float r1,float r2){\n    p -= o;\n    return length( vec2(length(vec2(p.x,p.z))-r1,p.y) ) - r2;\n}\nfloat sdBox(vec3 p, vec3 o, vec3 s){\n    p-=o;\n    return length(max(abs(p)-s,0.)) -.05;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t*ab;\n\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i-.05;\n}\n//===============TRANSFORM=================\nmat2 rotate(float a){\nreturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\n//===============RENDER===================\n//Scene\nfloat f(vec3 p){\n    float ds = sdSphere(p,vec3(0,1,0),1.);//sdf sphere\n    float dc = sdCapsule(p,vec3(1,.5,-1),vec3(3.5,.5,0),.5);//sdf capsule\n    float dt = sdTorus(p,vec3(-2,.5,1),1.,.5);//sdf torus\n    float db = sdBox(p,vec3(1,1,2),vec3(1,2,1));//sdf box\n    float dcy = sdCylinder(p,vec3(1.5,1.7,-1),vec3(4,.5,2),.5);//sdf cylinder\n    float d = min(ds,dc);\n    d = min(d,dt);\n    d = min(d,db);\n    d = min(d,dcy);\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\nfloat softShadow(in vec3 ro, in vec3 rd,float k){\n    float t = .1;\n    float res = 1.;\n    float ld = 1e20;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        //res = min(res, k*d/t);\n        float y = (i==0) ? 0.0 : d*d/(2.0*ld); \n        float l = sqrt(d*d-y*y);\n        res = min(res, k*l/max(0.0,t-y));\n        ld = d;\n        t += d;\n        if(d < PRECISION || t > 30.)\n            break;\n    }\n    return clamp(res,0.,1.);\n}\nfloat calAO( in vec3 p, in vec3 n){\n    float occ = 0.;\n    float sca = 1.;\n    for(int i = 0;i<5;i++){\n        float h = 0.001 + 0.4*float(i)/4.0;\n        float d = f(p + h*n);\n        occ += (h-d)*sca;\n        sca *= 0.6;\n        }\n    return clamp(1.-1.5*occ,0.,1.);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nmat3 setCamera(in vec3 camtar, in vec3 campos, in float camro){\n    vec3 z = normalize(camtar-campos);\n    vec3 cp = vec3(sin(camro),cos(camro),0.);\n    vec3 x = normalize(cross(cp,z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(-5., 5.,-5);//light\n\n    //SET Camera\n    vec3 cam_tar = vec3(1,0,2);//cam target\n    vec3 cam_pos = cam_tar + vec3(10.*cos(iTime*.5), 10., 10.*sin(iTime*.5));//cam position\n\n    vec3 rd = vec3(uv,3.); //decide view width\n    if(iMouse.x!=0. || iMouse.y!=0. ){\n        float angle_x = -(iMouse.x /iResolution.x-0.5)  *0.5*PI;\n        float angle_y = (iMouse.y /iResolution.y-0.5)  *0.5*PI;\n        rd.yz *= rotate(angle_y);\n        rd.zx *= rotate(angle_x);}\n    rd = normalize(setCamera(cam_tar,cam_pos,0.)*rd);//viewing frustum\n\n    float t = rayMarch(cam_pos,rd);//raymarching\n    \n    vec3 color = texture(iChannel0,rd).rgb;//background\n    if(t > TMAX) return color; \n    \n    vec3 p = cam_pos + t*rd;\n    vec3 n = calcNormal(p);\n    vec3 l = normalize(lightPos-p);//lightDir\n    vec3 h = normalize(l-rd);//\n\n    vec3 diffusecol = vec3(1.);//diffuse color\n    vec3 specol = vec3(1.);//specular color\n    vec3 cmrfl = 1.5*vec3(.5)*texture(iChannel0,reflect(rd,n)).rgb;//cubemap reflection\n    vec3 cmrfr = texture(iChannel0,refract(rd,n,.8)).rgb;//cubemap refraction\n    \n\n    float dif = clamp(dot(l,n),0.,1.);//diffuse    \n    float spe = pow(clamp(dot(h,n),0.,1.),50.);//specular\n\n    float shadow = softShadow(p,l,8.);//soft shadow\n    float occ = calAO(p,n);//AO\n    float fresnel = pow(clamp(1. - dot(n,-rd),0.,1.),5.);\n\n    if(floor(mod(iTime*.5,2.))==0.){\n        color = cmrfl + .2*dif*diffusecol + spe*specol;//metal\n        color *= clamp(shadow+.4,0.,1.)*occ;\n        color += fresnel*.4;}\n        else{\n        color = cmrfr + .1*dif*diffusecol + smoothstep(.7,1.,spe)*specol;//glass\n        color *= clamp(shadow+.8,0.,1.)*occ;\n        color += fresnel*.8;}\n    // fog\n    //color *= exp( -0.0001*t*t*t );\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    #if AA>1\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n    #else\n            uv = getuv(fragCoord);\n    #endif\n            color += render(uv);\n    #if AA>1\n        }\n    }\n    color /= float(AA*AA);\n    #endif\n\n \n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 227, 267, 267, 295], [296, 296, 343, 343, 497], [498, 498, 546, 546, 622], [623, 623, 659, 659, 713], [714, 714, 765, 765, 1039], [1040, 1084, 1105, 1105, 1150], [1153, 1204, 1220, 1220, 1643], [1644, 1644, 1684, 1684, 1899], [1900, 1900, 1949, 1949, 2389], [2390, 2390, 2425, 2425, 2661], [2662, 2708, 2736, 2736, 2951], [2953, 2953, 3016, 3016, 3189], [3190, 3190, 3211, 3211, 4985], [4986, 4986, 5009, 5009, 5063], [5656, 5656, 5676, 5676, 6065]]}
{"id": "ssBfzm", "name": "Embroidered rug 3", "author": "jarble", "description": "An elaborately detailed rug pattern.", "tags": ["fractal", "rug"], "likes": 2, "viewed": 211, "published": 3, "date": "1645852766", "time_retrieved": "2024-07-30T17:01:22.023105", "image_code": "//change these constants to get different patterns!\n#define iterations 2\n#define modulo 3\n\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);   \n    for(int k = 0; k < 6*iterations; k++){\n        uv -= (t2.yx)/(scale)+float(k%modulo);\n        t2 = triangle_wave(uv.yx-.5,scale);\n        //uv = min(uv,t2);\n        t3 = -triangle_wave(uv,scale);\n        //t3 /= float(1+k%3);\n        uv.yx = -(t2+t3);\n        col.x = 1.-abs(-uv.y+uv.x+col.x);\n        //col.x = 1.-abs(uv.y+uv.x-col.x);\n        col = col.yzx;\n        uv /= scale*scale;\n        //uv /= scale*(scale)+uv.x-uv.y;\n        //uv *= (t2.y-t2.x+1.);\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 160, 160, 205], [207, 207, 264, 264, 1005]]}
{"id": "7dBfzm", "name": "FlameShader1", "author": "railgunSR", "description": "A basic flames shader", "tags": ["flame", "fire", "flames"], "likes": 1, "viewed": 219, "published": 3, "date": "1645849835", "time_retrieved": "2024-07-30T17:01:22.886795", "image_code": "/*\nMIT License\n\nCopyright (c) 2022 railgunSR\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n/*\nTHIS MAKES USE OF OPENSIMPLEX2, A NOISE ALGORITHM CREATED BY THE FINE FOLKS \nOVER AT https://github.com/KdotJPG/OpenSimplex2\nPLEASE GIVE THEM SOME LOVE.\n\nTHE FLAME FUNCTION IS ONE CREATED BY ME BLENDING A LOG2 INTO A EXPONENTIAL.\n*/\n\n\nvec4 openSimplex2_ImproveXY(vec3 X);\nfloat flameTex(float x, float y);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // vec4 openVec = openSimplex2_ImproveXY(vec3(uv.x,uv.y,iTime));\n    vec4 openVec = openSimplex2_ImproveXY(vec3(uv.x*3.0,uv.y*3.0 - iTime,0.0));\n\n    float nS = 3.0; //noise scale\n\n    //compose textures\n    float flameXScale = 2.0;\n    float flameYScale = 2.0;\n    float flameVal = flameTex(uv.x*flameXScale-1.0/flameXScale,uv.y*flameYScale-1.0/flameYScale);\n\n    float flameComp1 = flameVal * openSimplex2_ImproveXY(vec3(uv.x * nS              ,uv.y * nS - iTime * 1.0,0.0)).x;\n    nS = 3.0;\n    float flameComp2 = flameVal * openSimplex2_ImproveXY(vec3(uv.x * nS              ,uv.y * nS - iTime * 2.0,0.0)).x;\n    nS = 5.0;\n    float flameComp3 = flameVal * openSimplex2_ImproveXY(vec3(uv.x * nS + iTime * 1.0,uv.y * nS - iTime * 3.0,0.0)).x;\n    float flameComp4 = flameVal * openSimplex2_ImproveXY(vec3(uv.x * nS - iTime * 1.0,uv.y * nS - iTime * 3.0,0.0)).x;\n    nS = 3.0;\n    float flameComp5 = flameVal * openSimplex2_ImproveXY(vec3(uv.x * nS              ,uv.y * nS - iTime * 1.5,0.0)).x;\n    float val = \n    flameVal * 3.0 +\n    flameComp1 * 0.2 +\n    flameComp2 * 0.2 +\n    flameComp3 * 0.2 +\n    flameComp4 * 0.2 +\n    flameComp5 * 0.2\n    ;\n    \n    vec3 color = vec3(\n        min(val*2.0,1.0),\n        min(val*0.8,1.0),\n        min(val*0.2,1.0)\n        );\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n//\n//custom flame function\n///\n\nfloat flameTex(float x, float y){\n    //flip y\n    float t = 1.0 - y;\n    //calculate vertical component\n    float verticalFlameValue = pow(log(t+1.0),1.4) - step(0.5,t) * (pow((2.0 * (t - 0.5)),3.0) / pow(log(2.0),1.4));\n    //calculate dist along horizontal from vertical component\n    float dist = abs(x-0.5);\n    //want to fade to nothing at dist >= vertical flame value\n    //use exponent to get there\n    //clamp range with min\n    float v = max(2.0 * (verticalFlameValue - dist),0.0);\n    //apply exponent to get value\n    float rVal = pow(v,1.4);\n    return rVal;\n}\n\n\n\n//////////////// K.jpg's Re-oriented 4-Point BCC Noise (OpenSimplex2) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Inspired by Stefan Gustavson's noise\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2Base(vec3 X) {\n    \n    // First half-lattice, closest edge\n    vec3 v1 = round(X);\n    vec3 d1 = X - v1;\n    vec3 score1 = abs(d1);\n    vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\n    vec3 v2 = v1 + dir1 * sign(d1);\n    vec3 d2 = X - v2;\n    \n    // Second half-lattice, closest edge\n    vec3 X2 = X + 144.5;\n    vec3 v3 = round(X2);\n    vec3 d3 = X2 - v3;\n    vec3 score2 = abs(d3);\n    vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\n    vec3 v4 = v3 + dir2 * sign(d3);\n    vec3 d4 = X2 - v4;\n    \n    // Gradient hashes for the four points, two from each half-lattice\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec4 a = max(0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Use this if you don't want Z to look different from X and Y\nvec4 openSimplex2_Conventional(vec3 X) {\n    \n    // Rotate around the main diagonal. Not a skew transform.\n    vec4 result = openSimplex2Base(dot(X, vec3(2.0/3.0)) - X);\n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Use this if you want to show X and Y in a plane, then use Z for time, vertical, etc.\nvec4 openSimplex2_ImproveXY(vec3 X) {\n    \n    // Rotate so Z points down the main diagonal. Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    vec4 result = openSimplex2Base(orthonormalMap * X);\n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBfzm.jpg", "access": "api", "license": "mit", "functions": [[1382, 1382, 1439, 1499, 2968], [3002, 3002, 3035, 3048, 3575], [3754, 3794, 3816, 3816, 3853], [3855, 3917, 3940, 3988, 4958], [4960, 5005, 5036, 5081, 6468], [6470, 6533, 6573, 6640, 6777], [6779, 6867, 6904, 6981, 7332]]}
{"id": "7sSBzm", "name": "More Torus \"Fog\"", "author": "SnoopethDuckDuck", "description": "i like this technique", "tags": ["e"], "likes": 30, "viewed": 690, "published": 3, "date": "1645841403", "time_retrieved": "2024-07-30T17:01:23.850219", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n\n#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 distort(vec3 p) {\n    float o = 2.* pi / 3.;\n    float t = 3. * length(p) - 0.5 * iTime;\n   // p = abs(p) - 0.5;\n    p.xy *= Rot(t - o);\n    p.yz *= Rot(t);\n    p.zx *= Rot(t + o);\n    return fract(0.8 * p) - 0.5;\n}\n\nfloat GetDist(vec3 p) {\n   \n    p = distort(p); \n    float d = length(p.xz) - 0.5;\n    \n    // lower k => more \"fog\"\n    float k = 0.25;\n    //return length(p) -0.3 + SURF_DIST;\n    return k * length(vec2(d, p.y)) + 1. * SURF_DIST;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t = 0.125 * iTime, o = 2. * pi / 3.;\n    vec3 ro = 3. * vec3(cos(t - o), cos(t), cos(t + o));\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 0.95);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        vec3 dp = distort(p);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       // col = vec3(step(0., dif));\n        \n        // darken with distance from origin\n        float v = exp(-0.31 * length(p));\n        \n        // idk what this does\n        v = smoothstep(0., 1., v);\n        v *= v;\n      \n        // color + lighten\n        vec3 e = vec3(1);\n        col = v * pal(0.77 + 0.15 * length(p), e, e, e, 0.8 * vec3(0,1,2)/3.);    \n        //col -= 0.1;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 155, 155, 198], [200, 200, 219, 219, 281], [283, 283, 305, 305, 503], [505, 505, 528, 528, 738], [740, 740, 783, 783, 1017], [1019, 1019, 1043, 1043, 1233], [1235, 1235, 1285, 1285, 1476], [1478, 1478, 1535, 1535, 2416]]}
{"id": "7dBfRm", "name": "test 32", "author": "lwswl", "description": "test", "tags": ["test"], "likes": 0, "viewed": 152, "published": 3, "date": "1645839320", "time_retrieved": "2024-07-30T17:01:24.911382", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define col fragColor.rgb\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 UV=(fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n    bool b=false;\n    int y=0;\n    for(int i=1;i<200;i++){\n        vec2 offs=vec2(sin(float(i)*iTime*0.02),sin(float(i)*(iTime+0.5)*0.02));\n        b = b^^(dot(UV+offs,UV+offs)<0.01);\n    }\n    col=vec3(b^^true);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7sSfRm", "name": "smol test 2", "author": "lwswl", "description": "test 2", "tags": ["test2"], "likes": 1, "viewed": 136, "published": 3, "date": "1645838169", "time_retrieved": "2024-07-30T17:01:25.850870", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV=(fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n    if(\n        dot(UV,UV)<0.02^^\n        dot(UV+vec2(0.1,0.1),UV+vec2(0.1,0.1))<0.02^^\n        dot(UV+vec2(-0.1,-0.1),UV+vec2(0.1,0.1))<0.02\n    )fragColor.rgb=vec3(0);\n    else fragColor.rgb=vec3(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ssSBRm", "name": "smol test", "author": "lwswl", "description": "not sure. It seems to work though.", "tags": ["circle"], "likes": 1, "viewed": 130, "published": 3, "date": "1645835191", "time_retrieved": "2024-07-30T17:01:26.702593", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 UV=(fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n    if (dot(UV,UV)<0.02){fragColor.r=sin(iTime)*0.5+0.5;fragColor.gb=vec2(0);}\n    else fragColor.rgb=vec3(1);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 251]]}
{"id": "7dBfzw", "name": "BubbleShader1", "author": "railgunSR", "description": "Bubble looking shader", "tags": ["fire", "flames"], "likes": 2, "viewed": 267, "published": 3, "date": "1645832436", "time_retrieved": "2024-07-30T17:01:27.526390", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvO = vec2(uv.x,uv.y - iTime/2.7);\n    vec2 uvSlow = vec2(uv.x,uv.y - iTime/4.2);\n    vec2 uvSlower = vec2(uv.x,uv.y - iTime/6.3);\n    vec2 uvDiag1 = vec2(uv.x - iTime/12.1,uv.y - iTime/6.1);\n    vec2 uvDiag2 = vec2(uv.x + iTime/14.0,uv.y - iTime/6.0);\n    \n    float scaleFactor = 1.0;\n    vec2 uvScaled = vec2(uv.x/scaleFactor,uv.y/scaleFactor);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 texStop =   texture(iChannel1,uv);\n    vec4 texMove =   texture(iChannel1,uvO);\n    vec4 texSlow =   texture(iChannel1,uvSlow);\n    vec4 texSlower = texture(iChannel1,uvSlower);\n    vec4 texDiag1 =  texture(iChannel0,uvDiag1);\n    vec4 texDiag2 =  texture(iChannel0,uvDiag2);\n    \n    float distCenter = sqrt(abs(0.5-uv.x)*abs(0.5-uv.x)+abs(0.5-uv.y)*abs(0.5-uv.y));\n    \n    float verticalFalloff = 0.0;\n    float circleFalloff = 2.0;\n    \n    float colorMagnitude =\n    //vert falloff calc\n    (1.0 - ((verticalFalloff) * uv.y)) *\n    //circle falloff calc\n    (1.0 - (circleFalloff * distCenter)) *\n    (\n    //texStop.x *\n    texMove.x *   0.2 +\n    texSlow.x *   0.2 +\n    texSlower.x * 0.2 +\n    texDiag1.x * 0.05  +\n    texDiag2.x * 0.05\n    )\n    ;\n    \n    vec3 color = vec3(\n    colorMagnitude/4.0\n    ,\n    colorMagnitude/1.2\n    ,\n    colorMagnitude\n    );\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1545]]}
{"id": "sdSfRw", "name": "correct interpolation of random2", "author": "FabriceNeyret2", "description": "in https://shadertoy.com/view/ss2BRh we just renormalized the Gaussian statistic (middle) when interpolating 2 stochastic distributions (naive way, left).   red < 0  green > 1.\nHere, we also restore the initial law, i.e. the Uniform histogram ( right ).", "tags": ["random", "interpolation", "short", "stochastic"], "likes": 12, "viewed": 337, "published": 3, "date": "1645824895", "time_retrieved": "2024-07-30T17:01:28.402048", "image_code": "// continuing https://shadertoy.com/view/ss2BRh\n// which just renormalize statistics when mixing stochastic fields ( textures, noises, etc )\n// Here we also restore the law distribution back, by recovering the histogram \n// ( just uniform here. For general case see https://hal.inria.fr/hal-01824773 )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 R = iResolution;\n    float v,z = iMouse.z > 0. ? 1. : 3.,\n          t = mod(iTime,2.); t = min(t,2.-t);          // saw interpolant  \n    O = U.y > R.y/2. \n          ? texelFetch(iChannel0, ivec2(U/z)%256, 0 )  // top: white noise\n          : texelFetch(iChannel1, ivec2(U/z)%256, 0 ); // bottom: blue noise\n\n    if (    int(U)/2 == int(R)/6                       // red separators\n         || int(U)/2 == int(R)/3              \n         || int(U.y)/2 == int(R.y)/4 )\n      { O = vec4(1,0,0,1); return; }\n      \n    if ( U.x < R.x/3. )                       // --- left: naive interpolation\n        v =  mix( O.x , O.y, t);\n\n    else  if ( U.x < R.x*2./3. ){             // --- middle: interpolation with moments renormalization\n        O = (O-.5) / .289 ;                   // move to 0-mean, 1-variance\n        // go-to 1-variance is only required when mixing 2 different statistics\n        v = mix( O.x , O.y, t);\n        v /=  sqrt(2.*t*t-2.*t+1.);           // renormalize from variance =  (1-t)² + t²\n        v = .5 + .289 * v;                    // back to target (here, initial) statistics\n    }\n    else {                                    // right: restore the uniform distribution\n        v = mix( O.x , O.y, t);\n        float m = min(t,1.-t), T = 2.*t*(1.-t); // apply cumulative distrib as histogram\n        v = v < m ? v*v/T : v < 1.-m ? m*m/T + (v-m)/(1.-m) : 1. - (1.-v)*(1.-v)/T;\n    }\n    if ( iMouse.z > 0. ) v = clamp(v,0.,1.);\n    O = v < 0. ? vec4(1,0,0,0)                // red/green = under/over shoots\n      : v > 1. ? vec4(0,1,0,0)\n      :          vec4( pow(v, 1./2.2) );      // to sRGB\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 341, 341, 1971]]}
{"id": "fsSfRm", "name": "Torus Fog", "author": "SnoopethDuckDuck", "description": "very simple shader, was trying to make something cool using as few raymarching steps as possible (max 8)\n\nsetting MAX_STEPS to 80 gives you non-blurry version", "tags": ["e"], "likes": 9, "viewed": 276, "published": 3, "date": "1645812010", "time_retrieved": "2024-07-30T17:01:29.346523", "image_code": "#define MAX_STEPS 8\n#define MAX_DIST 10.\n#define SURF_DIST 0.03\n\n#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    p = fract(p) - 0.5;\n    \n    float d = length(p.xz) - 0.5;\n    \n    // lower k => more \"fog\"\n    float k = 1.;\n    return k * length(vec2(d, p.y));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t = 0.125 * iTime, o = 2. * pi / 3.;\n    vec3 ro = 3. * vec3(cos(t - o), cos(t), cos(t + o));\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 0.8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(step(0., dif));\n        \n        // darken with distance from origin\n        col *= exp(-0.31 * length(p));\n        \n        // idk what this does\n        col = smoothstep(0., 1., col);\n        col *= col;\n      \n        // color + lighten\n        vec3 e = vec3(1);\n        col *= pal(col.x * 0.5 + 0.44 + 0.1 * length(p), e, e, e, 0.8 * vec3(0,1,2)/3.);    \n        col -= 0.1;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 151, 151, 194], [196, 196, 215, 215, 277], [279, 279, 302, 302, 456], [458, 458, 501, 501, 735], [737, 737, 761, 761, 951], [953, 953, 1003, 1003, 1194], [1196, 1196, 1253, 1253, 2113]]}
{"id": "ltyczV", "name": "EscherThing123", "author": "hyrtsi", "description": "asd", "tags": ["foo"], "likes": 2, "viewed": 238, "published": 3, "date": "1645804168", "time_retrieved": "2024-07-30T17:01:30.244123", "image_code": "//\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI\t\t\t\t\t= 3.14159;\nconst float HALF_PI\t\t\t\t= PI * 0.5;\nconst float DBL_PI\t\t\t\t= PI * 2.0;\n\n//\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat boxSDF( vec3 p, vec3 box)\n{\n  return length(max(abs(p)-box,0.0));\n}\n\n/*\nSphere in origin with radius\nCheck if p is inside it or not\n*/\nfloat sphereSDF(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/*\np sample point\n\nc repetition constant; test it!\nlarger: more space, smaller: all mashes together\n\nTODO:\nIf you replace any row with just p.*,\nthat row will not be generated\n\nExperiment with that...\n*/\nvec3 opRep(in vec3 p, in float c)\n{\n    return vec3(mod(p.x, 2.0 * c) - c,\n                mod(p.y, 2.0 * c) - c,\n                mod(p.z, 2.0 * c) - c);\n}\n\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    //samplePoint = rotateY(iTime / 2.0) * samplePoint;\n        \n    float sideLen = 0.5;\n    float lenMulti = 8.0;\n    vec3 box = vec3(sideLen * lenMulti, sideLen, sideLen);\n    vec3 box2 = vec3(sideLen, sideLen * lenMulti, sideLen);\n    vec3 box3 = vec3(sideLen, sideLen, sideLen * lenMulti);\n\n    //vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n    \n    float c = 4.0;      \n    \n\tfloat bar1 = boxSDF(opRep(samplePoint, c), box);\n    float bar2 = boxSDF(opRep(samplePoint, c), box2);\n    float bar3 = boxSDF(opRep(samplePoint, c), box3);\n    \n    float escher = unionSDF(bar1, unionSDF(bar2, bar3));\n        \n    return escher;\n   \n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n\tfloat depth = start;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n        // If the distance is less than some limit,\n        // the signed function has changed its sign or \"close enough\"\n        // of being inside something\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        \n        // Else not hit anything\n        depth += dist;\n        if (depth >= end)\n        {\n            return end;\n        }     \n    }\n\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0, 2.0, 4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0, 2.0, 2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec3 v = vec3(0.0, 0.0, -11.0 * t);\n    mat3 cam = rotateY(radians(18.0)) * rotateX(radians(18.0));\n\n    vec3 viewDir = rayDirection(45.0 + 8.0 * t, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 1700.0) + v;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = cam * viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye,worldDir,MIN_DIST,MAX_DIST);\n    if (dist > MAX_DIST-EPSILON)\n    {\n        // no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n        \n    // Else color the thing with its color\n\t// The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    //vec3 K_a = vec3(0.2, 0.2, 0.2);\n   \t//vec3 K_d = vec3(0.7, 0.2, 0.2);\n    \n    // Extra:\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 279, 306, 306, 453], [455, 501, 528, 528, 675], [677, 723, 750, 750, 897], [899, 990, 1036, 1036, 1068], [1070, 1154, 1196, 1196, 1228], [1230, 1319, 1366, 1366, 1399], [1401, 1401, 1434, 1434, 1474], [1476, 1542, 1581, 1581, 1614], [1616, 1616, 1661, 1730, 2336], [2338, 2542, 2577, 2577, 2697], [2699, 2699, 2733, 2828, 3484], [3486, 3486, 3577, 3577, 4130], [4132, 4132, 4197, 4197, 4329], [4331, 4331, 4360, 4360, 4670], [4672, 4672, 4812, 4812, 5402], [5404, 5404, 5489, 5489, 6119], [6122, 6449, 6498, 6533, 6664], [6666, 6666, 6723, 6723, 7888]]}
{"id": "ss2fz1", "name": "Simple clouds", "author": "MinimilisticBits", "description": "These are my simple clouds and sky, they're not very optimized, so they're slow", "tags": ["simple", "clouds"], "likes": 3, "viewed": 225, "published": 3, "date": "1645784169", "time_retrieved": "2024-07-30T17:01:31.469846", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec3 c = texture(iChannel0, vec2(p+coords)/iResolution.xy).xyz;\n    c = c*c *1.0;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    for(int i = 0; i < 9; i++){\n        vec2 coords = vec2(float(i%3)-1., float(i/3)-1.)*1.;\n        vec2 fin = (fragCoord+coords)/iResolution.xy;\n        col += texture(iChannel0, fin).xyz;\n    }\n    col /= 9.;\n    \n\n    // Output to screen*/\n    col = pow(col, vec3(1.));\n    col = ACESFilm(col);\n   col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\n\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat p22(float h){\nreturn exp(-h/8500.);\n}\n\nvec3 S(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\nfloat a = 3.14159*3.14159*(n*n-1.0)*(n*n-1.0)/2.0;\nfloat b = p22(h)/N;\nvec3 c = 1.0/(wave*wave*wave*wave);\nfloat d = (1.0-cost*cost);\nreturn a*b*c*d;\n}\n\nvec3 B(vec3 wave, float h){\nfloat n = 1.00029;\nfloat N = 2.504;\n\nfloat a = 8.*pow(3.14159,3.)*(n*n-1.0)*(n*n-1.0)/3.;\nfloat b = p22(h)/N;\nvec3 c = 1./wave;\nreturn a*b*c;\n}\n\nvec3 reyleighapprox(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat d = 1432.1;\nfloat a = (1.0+cost*cost)/(2.0*h*h);\nvec3 b = pow(2.*3.14159/wave,vec3(4.));\nfloat c = pow((n*n-1.0)/(n*n+2.),2.);\nfloat d2 = pow(d/2.,6.);\nreturn a*b*c*d2;\n}\n\nfloat CornetteShanksPhase(float costheta, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+costheta*costheta);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*costheta, 3./2.);\nreturn a*(b/c);\n}\n\nfloat dr(float h){\nreturn exp(h/1200.);\n}\n\nfloat dr2(float h){\nreturn exp(h/8000.);\n}\n\nvec3 boreyleigh(float costheta, vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat a = 1.0+costheta*costheta;\nfloat v = 3.14159*3.14159*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave*0.000000000002))*a;\n}\n\nvec3 boreyleighconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat v = 8.*pow(3.14159, 3.)*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave));\n}\n\nvec3 bommie(float costheta, vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn 0.434*C*((4.*3.14159*3.14159)/(wave*wave))*0.5*Bm;\n}\nvec3 bommieconstant(vec3 wave){\nfloat T = 5.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn Bm;\n}\n\nfloat HenyeyG(float cost, float g){\nreturn (1.0-g*g)/(4.*3.14159*pow(1.0+g*g-2.*cost,3./2.));\n}\n\nfloat ph(float h, float H){\nreturn exp(-(abs(h)/H));\n}\n\nvec3 S(vec3 wave, float h, float H, float cost){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = pow(3.14159,2.)*pow(n*n-1.,2.)/2.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nfloat d = (1.0+cost*cost);\nreturn a*b*c*d;\n}\n//S = B*Y\n\nvec3 B(vec3 wave, float h, float H){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 2.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = ph(h, H)/N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 Bconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 2.504*pow(10., 25.);\nfloat a = 8.*pow(3.14159,3.)*pow(n*n-1.,2.)/3.;\nfloat b = 1./N;\nvec3 c = 1./pow(wave, vec3(4.));\nreturn a*b*c;\n}\n\nvec3 BsR(vec3 wave, float h, float H){\nfloat n = 1.00029;\nvec3 N = vec3(2.504)*pow(10., 25.);\nvec3 a = (8.*pow(3.14159,3.)*pow(n*n-1.,2.))/(3.*N*pow(wave,vec3(4.)));\nfloat b = exp(-(h/H));\nreturn a*b;\n}\n\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat PR(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nfloat Y(float cost){\nfloat a = 3./(16.*3.14159);\nfloat b = 1.0+cost*cost;\nreturn a*b;\n}\n\nvec3 F(vec3 wave,vec3 wave2, vec3 wave3, vec3 wave4, float s, float cost){\nvec3 br = boreyleighconstant(wave);\nvec3 bm = bommieconstant(wave2);\n\nfloat pr = ph(s, 8500.);\nfloat pm = ph(s, 1200.);\n\nvec3 Br = boreyleigh(cost, wave3);\nvec3 Bm = bommie(cost, wave4);\n\nreturn pr*Br*br*200. + pm*Bm*bm;\n}\n//NOT MY CODE///////////\n bool intersect22(vec3 p,  vec3 C, float size, vec3 d, inout vec2 t){\n \n \t\n\tvec3 o_minus_c = p - C.xyz;\n\n    float p2 = dot(d, o_minus_c);\n    float q = dot(o_minus_c, o_minus_c) - (size * size);\n    \n    float discriminant = (p2 * p2) - q;\n    \n\n    float dRoot = sqrt(discriminant);\n    t.x = -p2 - dRoot;\n    t.y = -p2 + dRoot;\n\n    return true;\n \n }\n vec3 Be(vec3 b0,float h, float H){\nreturn b0*exp(-h/H);\n}\nvec3 Brr(vec3 wave){\nfloat n = 1.029;\nfloat N = 10.;\nreturn 8.*pow(3.14159,3.)*(pow(n*n-1.0, 2.)/(3.*N*wave*wave*wave*wave));\n}\nvec3 sky(vec3 p, vec3 d, vec3 lig) {\n  p = vec3(0., 0., 6400.);\n  vec3 wavelengths = vec3(700., 530., 420.);\n  lig.z = clamp(lig.z, 0., 1.);\n\n  vec2 t = vec2(0.);\n  float reyleighH = 4000.;\n  float MieH = 1200.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n  if (intersect22(p, vec3(0., 0., 0.), 6420.0, d, t)) {\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n    vec3 fin = p + d * t.y;\n    vec3 div = vec3(fin - cam) / 20.;\n    float mm = length(cam - fin);\n\n    vec3 accum = vec3(0.);\n    vec3 accum11 = vec3(0.);\n    vec3 accum1111 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 110.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    // vec3 BRrgb = vec3(6.5, 1.73, 2.30);\n    vec3 BRrgb = Brr(wavelengths * 0.00109);\n    vec3 BMrgb = vec3(0.01);\n    ///////////////////////////////////\n\n    for (int i = 0; i < 20; i++) {\n      accum += ph(max(cam.z - 1660., 0.), reyleighH) * length(div);\n      // accum11 += Bwave(wavelengths*0.01, cam.z, MieH)*length(div);;\n      accum1111 += ph(max(cam.z - 1460., 0.), MieH) * length(div);\n      vec3 accum2 = vec3(0.);\n      vec3 accum222 = vec3(0.);\n      float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      if (intersect22(cam, vec3(0., 0., 0.), 6420.0, lig, t)) {\n        vec3 cam2 = cam;\n        vec3 fin2 = cam2 + lig * t.y;\n        vec3 div2 = vec3(fin2 - cam2) / 20.;\n        for (int k = 0; k < 20; k++) {\n          accum2 += max(length(cam2) - 6260., 0.) * length(div2);\n         \n          cam2 += div2;\n        }\n\n        vec3 t1 = BRrgb * accum222 + BMrgb * accum2;\n        vec3 t2 = BRrgb * accum + BMrgb * accum1111;\n\n        accumulateLight +=\n            (exp(-pow(t1 * 0.0054, vec3(1.))) * exp(-t2 * 0.028)) *\n            length(div * 1.) * .0005 * (PRRR * BRrgb * 230. + PMMM * 10.) *\n            mix(vec3(0.9, 0.4, 0.2), vec3(0.9),\n                clamp(dot(lig, vec3(0., 0., 1.)) * 4., 0., 1.));\n\n      }\n\n      if (cam.z < 6360.) {\n        break;\n      }\n      cam += div;\n    }\n    \n  }\n  \n  return max(accumulateLight * 1.4,\n             0.);\n \n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nvec3 remap(vec3 v, vec3 l0, vec3 h0, vec3 ln, vec3 hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nfloat random3d(vec3 p){\nreturn fract(sin(p.x*214. + p.y*241. + p.z*123.)*100. + cos(p.x*42. + p.y*41.2+p.z*32.)*10.);\n}\n\nfloat worley3d(vec3 p){\nvec3 f = floor(p);\n\nfloat ll = 999.;\nfor(int i = 0; i < 27; i++){\nvec3 coords = vec3(float(i%3)-1., mod(float(i/3)-1., 3.), float(i/9)-1.);\nvec3 col = f+coords;\nvec3 curr = vec3(random3d(col), random3d(col+2.), random3d(col+4.))-0.5;\nfloat len = length((col+curr)-p);\nll = min(ll, len);\n}\nreturn ll;\n\n}\n\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise222( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbmss(vec3 p)\n{\n    float scale = 0.1;\n    float threshold = 0.3;\n    float sum = 0.;\n        p += vec3(5., 0., 0.);\n        for(int i = 1; i <= 8; i++)\n        {\n            sum += noise222((p+vec3(iTime, iTime,iTime)*0.5) * scale * pow(2., float(i))) / pow(1.7, float(i));\n        }\n        return max(sum - threshold, 0.);\n}\nfloat fbm(vec3 p, vec3 cam){\n\n\nfloat b = fbmss(p*0.1);\n\n  float Srb = clamp(\n      remap(clamp((cam.z - 200.) / 15., 0., 0.09), 0., 0.09, 0., 1.), 0., 1.);//a *= clamp(abs(length(p)-6500.)*0.00013, 0.0, 1.);\n\nreturn clamp((Srb)*b,0.,1.);\n}\n\n\n\nfloat noise(vec3 p){\nreturn fract(sin(p.x * 23. + p.y * 241.4 + p.z*52.)*100. + cos(p.x * 234. + p.y * 21.4 + p.z*542.)*124.);\n}\n\n\nvec4 clouds2(vec3 p, vec3 d, vec3 lig, inout float dist) {\n  vec3 befo = p;\n \n  float transmission = 1.0;\n  vec3 Ex = vec3(1.0);\n\n \n  vec3 accumulateLight = vec3(0.);\n\n  vec3 ccc = p;\n  vec3 cam = p;\n\n  vec3 accum = vec3(0.);\n  float minus = 0.20;\n  float mult = 1.0;\n\n \n  vec3 sky2 = sky(vec3(0.), lig, lig)*0.1;\n  float pr2 = PR(max(dot(d, lig), 0.));\n  float keepdensity = 0.;\n  bool firsth = false;\n  vec3 firstHit = p;\n  for (int i = 0; i < 150; i++) {\n    float density =\n        max(fbm(cam * mult, cam) - minus - abs(cam.z - 220.) * 0.01, 0.);\n    density = clamp(density, 0., 1.);\n    density = 1.0 - pow(1.0 - density, 4.);\n    if (density > 0.00001) {\n      if (!firsth) {\n        dist = length(cam - ccc);\n        firsth = true;\n        firstHit = cam;\n      }\n      accum += density * 10.6;\n      // accum11 += ph(length(cam)-6500., MieH)*length(div);\n\n      vec3 accum2 = vec3(0.);\n      // float accum3 = 0.;\n      // energy = energy*(1.0-rayleighcoefficients);\n      vec3 cam2 = cam;\n\n      for (int k = 0; k < 13; k++) {\n        float density2 = max(\n            fbm(cam2 * mult, cam2) - minus - abs(cam2.z - 220.) * 0.01, 0.);\n        // density2 = smoothstep(0.,1.,density2);\n        density2 = clamp(density2, 0., 1.);\n        density2 = 1.0 - pow(1.0 - density2, 4.);\n\n        // accum2 += ph(cam2.z, 1300.)*30.;\n        accum2 += density2 * 20.1;\n        // accum3 += ph(length(cam2)-6500., MieH)*length(div2);\n        cam2 += lig * (1. - 0.2 * random3d(cam2));\n      }\n\n      transmission *= 1.0 - density;\n\n    \n      float octave = 0.;\n\n      for (int i = 0; i < 8; i++) {\n   \n        vec3 pm2 = vec3((PM(max(dot(d, lig), 0.), 0.76))) * 140. +\n                   vec3((PM(max(dot(d, lig), 0.), pow(0.5, octave)))) * 13.5 +\n                   vec3((PM(max(dot(d, lig), 0.), -0.5))) * 40.;\n       //  pm2 *= mix(vec3(0.9,0.6,0.2), vec3(0.9), max(dot(lig, vec3(0.,\n       //  0., 1.)), 0.));\n           vec3 colr = vec3(0.9, 0.5, 0.1);\n        accumulateLight +=\n            (1. - exp(-density * 0.6)) * density * transmission *\n            (pm2 + pr2 * 12.*sky2) * pow(0.5, octave) * 3. * sky2 *\n            (exp(-accum2 * 0.05 * pow(.5, octave)) * exp(-accum * 0.1));\n\n        octave += 0.2;\n      }\n\n    } \n\n    cam += d * (3. - 0.5 * random3d(cam));\n    if(transmission < 0.5 || cam.z < 210.){\n        break;\n    }\n  }\n \n  return vec4(accumulateLight * 1.3, transmission);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    int tiles = 4;\n    int samples = 20;\n    //jk = float(iFrame%samples);\n\n    vec2 res = iResolution.xy / float(tiles);\n    int times = (iFrame/samples);\n    vec2 time = vec2(float(times%tiles), float((times/tiles)%(tiles)));\n    vec2 rr = res*time;\n    bool wtf = false;\n    //if(check == 1.){\n   //if(fragCoord.x < (rr.x) || fragCoord.x > (rr.x+res.x))discard;\n   //if(fragCoord.y < (rr.y) || fragCoord.y > (rr.y+res.y))discard;\n    \n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*180.);\n\n    vec3 lig = normalize(vec3(0., 0.6, 0.09));\n  \n    vec3 skys = sky(vec3(0.), d, lig);\n    vec3 final = vec3(0.);\n    \n    float dist = 0.;\n    vec4 mmm = clouds2(vec3(0.,0.,260.),d,lig,dist);\n\n    //vec3 final = skys;\n    final = final*mmm.w + pow(mmm.xyz, vec3(1.3));\n    float f = exp(-dist * .002);\n   // final.xyz = final.xyz * f + skys.xyz * (1.0 - f);\n    \n    // Output to screen\n    fragColor = vec4(final,1.);\n}", "buffer_a_inputs": [], "common_code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c*pi/180.;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2fz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [251, 251, 281, 281, 756], [760, 760, 817, 867, 1320]]}
{"id": "sdjfRW", "name": "Friendly colors", "author": "neueraeumlichkeit", "description": "Friendly colors", "tags": ["test"], "likes": 0, "viewed": 145, "published": 3, "date": "1645782023", "time_retrieved": "2024-07-30T17:01:32.292646", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 1.0 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "sd2fR1", "name": "weird stars", "author": "SnoopethDuckDuck", "description": "kind of draws what isn't there, weird technique", "tags": ["e"], "likes": 1, "viewed": 236, "published": 3, "date": "1645747718", "time_retrieved": "2024-07-30T17:01:33.140380", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n//https://www.shadertoy.com/view/Wl3fD2\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat GetDist(vec3 p) {\n    float t = 0.015 * length(p) + 0.2 * iTime;\n    float o = 2. * pi / 3.;\n   // float sc = 4.;\n    vec3 ax = vec3(cos(t - o), cos(t), cos(t + o));\n   \n    /*\n    p = abs(p) - 3.;\n    p = abs(p) - 1.5;\n    p = abs(p) - 0.75;\n    */\n    p = erot(p, ax, 0.1 * p.y + 0.25 * iTime + 0.* pi);\n    //p *= 0.1;\n    float x = length(p);\n     p = fract(0.8 * p) - 0.5;\n    //p = 0.5 + 0.5 * cos(0.1 * p) - 0.;\n\n    \n    vec3 center = floor(p) + 0.5;\n    vec3 neighbour = center + face(p - center);\n    \n   // vec3 pos = p - center;\n    //vec3 npos = p - neighbour;\n   \n    \n   // float worst = length(npos) - 0.79;\n    float m0 = 0.1;//mix(0.01, 0.1, 0.5 + 0.5 * thc(4., 0.25 * x - 0.5 *  iTime));\n    float worst = length(cross(neighbour, p)) - m0; // -0.1\n   // float me = length(cross(ax, p).yz) - 0.01;\n    float m = mix(0., 6. * exp(-0.5 * x), 0.5 + 0.5 * thc(100., 10. * length(p) + 10. * x - 5. * iTime));\n    float d = exp(-m * length(p)) * worst;//min(me, worst);\n    //d = 0.18 * worst / dot(p, p);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float t = 0.125 * iTime;\n    float o = 2. * pi / 3.;\n    float sc = 4.;\n    vec3 ax = vec3(cos(t - o), cos(t), cos(t + o));\n\n    vec3 ro = 3. * ax;//vec3(0, 3, -3);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 0.8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n       /* vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n        //*/\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(step(0., dif));\n\n       // float fresnel2 = pow(1.+dot(rd, n), 1.); \n        //col += fresnel2;\n        col *= exp(-0.2 * length(p));\n        col = clamp(col, 0., 1.);\n        col = smoothstep(0., 1., col);\n        \n      \n        vec3 e = vec3(1);\n        col *= pal(col.x * 0.4 + 0.55 + 0.1 * length(p), e, e, e, 0.5 * vec3(0,1,2)/3.);\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    col  -= 0.15;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2fR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 147], [149, 149, 178, 178, 259], [357, 357, 387, 387, 463], [465, 465, 503, 503, 568], [570, 570, 589, 589, 672], [674, 674, 697, 697, 1713], [1715, 1715, 1758, 1758, 1992], [1994, 1994, 2018, 2018, 2208], [2210, 2210, 2260, 2260, 2451], [2453, 2453, 2510, 2510, 3876]]}
{"id": "ss2BRh", "name": "correct interpolation of random ", "author": "FabriceNeyret2", "description": "when interpolating stochastic fields (texture, rand...) at least renormalize stats (right) or you'll got loose and fluctuating contrast (left).\nYou may even renormalize histograms as in https://hal.inria.fr/hal-01824773 (cf slides), but more complicated.", "tags": ["random", "interpolation", "short", "stochastic"], "likes": 13, "viewed": 345, "published": 3, "date": "1645712680", "time_retrieved": "2024-07-30T17:01:34.153670", "image_code": "// At least renormalize statistics when mixing stochastic fields ( textures, noises, etc )\n// If you also want to have the law distribution back, you have to recover the histogram: see https://hal.inria.fr/hal-01824773 \n// Uniform case treated here: https://www.shadertoy.com/view/sdSfRw\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 R = iResolution;\n    O = U.y > R.y/2. \n          ? texelFetch(iChannel0, ivec2(U/3.)%256, 0 ) // top: white noise\n          : texelFetch(iChannel1, ivec2(U/3.)%256, 0 );// bottom: blue noise\n    float v,t = mod(iTime,2.); t = min(t,2.-t); // saw interpolant\n\n    if (    int(U)/2 == int(R)/4              // red separators\n         || int(U.y)/2 == int(R.y)/4 )\n      { O = vec4(1,0,0,1); return; }\n      \n    if ( U.x < R.x/2. )                       // --- left: naive interpolation\n        v =  mix( O.x , O.y, t);\n\n    else {                                    // --- right: interpolation with moments renormalization\n        O = (O-.5) / .289 ;                   // move to 0-mean, 1-variance\n        // go-to 1-variance is only required when mixing 2 different statistics\n        v = mix( O.x , O.y, t);\n        v /=  sqrt(2.*t*t-2.*t+1.);           // renormalize from variance =  (1-t)² + t²\n        v = .5 + .289 * v;                    // back to target (here, initial) statistics\n    }\n    O = vec4( pow(v, 1./2.2) );               // to sRGB\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2BRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 327, 327, 1395]]}
{"id": "Nd2fR1", "name": "Fork Gold Agate d4tocchini 920", "author": "d4tocchini", "description": "This was the effect I wanted, smokey and kinda neon", "tags": ["fbm", "smoke", "agate"], "likes": 1, "viewed": 316, "published": 3, "date": "1645705929", "time_retrieved": "2024-07-30T17:01:35.088172", "image_code": "mat2 rot( float a ){ return mat2( sin(a),  cos(a), -cos(a),  sin(a) ); }\n\nfloat noise( in vec2 x ){ return smoothstep(0.,1.,sin(1.5*x.x)*sin(1.5*x.y)); }\n\nfloat fbm( vec2 p ){\n    \n    mat2 m = rot(.4);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pattern (in vec2 p, out vec2 q, out vec2 r, float t){\n   \n    \n\tq.x = fbm( 2.0*p + vec2(0.0,0.0) + 2.*t );\n    q.y = fbm( 1.5*p + vec2(5.2,1.3) + 1.*t );\n\n    r.x = fbm( p + 4.*q + vec2(1.7,9.2) + sin(t) + .9*sin(30.*length(q)));\n    r.y = fbm( p + 8.*q + vec2(8.3,2.8) + cos(t) + .9*sin(20.*length(q)));\n\n    return fbm( p + 7.*r*rot(t) );\n    \n}\n\nvoid mainImage(out vec4 C, in vec2 U){\n    \n    vec2 uv = (U.xy-iMouse.xy)/iResolution.xy * 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 q,r;\n    vec3 col1 = vec3(.9,.7,.5);\n    vec3 col2 = vec3(.3,.5,.4);\n    vec3 c;\n    \n    float f = pattern(uv, q, r, 0.1*iTime);\n    \n    //mix colours\n    c = mix(col1, vec3(0), pow(smoothstep(.0,.9,f), 2.));\n    c += col2 * pow(smoothstep(0., .8, dot(q,r)*.6), 3.) * 1.5;\n    //add contrast\n    c *= pow(dot(q,r) + .3, 3.);\n    //soften the bright parts\n    c *= f*1.5;\n    \n    //c += vec3(1.7,1.2,1.2) * dot(q,r);\n    //c += vec3(.2) * smoothstep(0., .2,pow(length(q),3.));\n    //c += dot(q,r);\n    //c += smoothstep(0.,3.,pow(length(df),0.12));\n    \n\n    C = vec4( c, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2fR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 72], [74, 74, 99, 99, 153], [155, 155, 175, 175, 447], [450, 450, 509, 509, 803], [805, 805, 843, 843, 1534]]}
{"id": "Nd2BR1", "name": "Gaz Fractal Modification #2", "author": "turboplay", "description": "Dedicated to gaz and his best fractals, this one is slightly modified for a different effect.", "tags": ["fractal"], "likes": 2, "viewed": 267, "published": 3, "date": "1645705040", "time_retrieved": "2024-07-30T17:01:35.886039", "image_code": "#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*1.3+vec3(10,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n \tfor(float i=0.,s,e,g=0.,t=iTime;i++<90.;){\n        p=g*d;\n        p.z-=.1;\n        p=R(p,H(t*.03),t*.2);\n        p.x-=.1;\n        p=acos(sin(abs(p)));\n        s=(mod(sqrt(iTime),3.) + 3.)/p.x;\n        for(int j=0;j++<15;)\n           s*=e=max(.5/dot(p,p),1.9),\n           p=abs(p*e-vec3(2,3,2)),\n           p=R(p,normalize(vec3(3,3,1)),1.8);\n        g+=e=abs(p.z)/s+1e-4;\n\t    c+=mix(vec3(1),H(log(s)*.4),.25)*.03/exp(0.8*i*i*e);\n\t}\n\tc*=c*c*c;\n    O=vec4(c,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2BR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 146, 146, 688]]}
{"id": "fs2Bzh", "name": "Simple scanlines", "author": "tuxifan", "description": "Just a super simple scanlines shader. Nothing more to say about that.", "tags": ["simulation", "scanlines", "crt"], "likes": 0, "viewed": 386, "published": 3, "date": "1645699752", "time_retrieved": "2024-07-30T17:01:36.751724", "image_code": "// Public Domain, feel free to use whereever and however you want.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv) - sin(uv.y * iResolution.x) * 0.04;\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2Bzh.jpg", "access": "api", "license": "public-domain", "functions": [[68, 68, 125, 125, 243]]}
{"id": "fd2Bzh", "name": "Cheap chromatic aberration", "author": "tuxifan", "description": "A super simple chromatic aberration shader, based on my \"bad color print\" shader. It's a rather imprecise simulation but it should fit most games and stuff. No blur or anything.", "tags": ["simple", "chromaticaberration", "colors"], "likes": 1, "viewed": 438, "published": 3, "date": "1645699081", "time_retrieved": "2024-07-30T17:01:37.597463", "image_code": "// Public Domain, feel free to use whereever and however you want.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const float intensity = 1.0;\n    float offset = distance(uv, vec2(0.5, 0.5))*(0.01*intensity);\n    fragColor = vec4(texture(iChannel0, uv+vec2(offset, 0.0)).r, texture(iChannel0, uv+vec2(-offset, 0.0)).g, texture(iChannel0, uv).b, 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2Bzh.jpg", "access": "api", "license": "public-domain", "functions": [[68, 68, 125, 125, 409]]}
{"id": "fdjBzh", "name": "Bad color print", "author": "tuxifan", "description": "Makes the colors offset, somewhat like in bad color prints.", "tags": ["colors", "printing"], "likes": 0, "viewed": 182, "published": 3, "date": "1645697854", "time_retrieved": "2024-07-30T17:01:38.349452", "image_code": "// Public Domain, feel free to use whereever and however you want.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const float offset = 0.01;\n    fragColor = vec4(texture(iChannel0, uv+vec2(offset, 0.0)).r, texture(iChannel0, uv+vec2(-offset, 0.0)).g, texture(iChannel0, uv).b, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjBzh.jpg", "access": "api", "license": "public-domain", "functions": [[68, 68, 125, 125, 341]]}
{"id": "ssBfzh", "name": "Embroidered rug 2", "author": "jarble", "description": "An elaborately detailed rug pattern.", "tags": ["fractal", "rug"], "likes": 6, "viewed": 237, "published": 3, "date": "1645685985", "time_retrieved": "2024-07-30T17:01:39.179234", "image_code": "//change these constants to get different patterns!\n#define iterations 4\n#define modulo 3\n\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);   \n    for(int k = 0; k < 6*iterations; k++){\n        uv -= (t2.yx)/(scale)+float(k%modulo);\n        t2 = triangle_wave(uv.yx-.5,scale);\n        t3 = -triangle_wave(uv,scale);\n        t3 /= float(1+k%modulo);\n        uv.yx = -(t2+t3);\n        col.x = 1.-abs(-uv.y+uv.x+col.x);\n        col = col.yzx;\n        uv /= scale*scale;\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 160, 160, 205], [207, 207, 264, 264, 872]]}
{"id": "fdBfz1", "name": "Embroidered rug", "author": "jarble", "description": "An elaborately detailed rug pattern.", "tags": ["fractal", "rug"], "likes": 4, "viewed": 248, "published": 3, "date": "1645673319", "time_retrieved": "2024-07-30T17:01:39.965132", "image_code": "//change these constants to get different patterns!\n#define iterations 3\n#define modulo 3\n\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);   \n    for(int k = 0; k < 6*iterations; k++){\n        uv -= (t2.yx)/(scale)+float(k%modulo);\n        //uv -= t3.yx/(4.);\n\n        t2 = triangle_wave(uv.yx-.5,scale);\n        //uv = min(uv,t2);\n        t3 = -triangle_wave(uv,scale);\n        t3 /= float(1+k%3);\n        uv.yx = -(t2+t3);\n        col.x = 1.-abs(-uv.y+uv.x+col.x);\n        col = col.yzx;\n        uv /= scale*scale*scale;\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 160, 160, 205], [207, 207, 264, 264, 922]]}
{"id": "ssjBzz", "name": "Forky fork fork noise fork noice", "author": "SnoopethDuckDuck", "description": "forked from iq's noise thing - no idea what's going on but looks kinda cool", "tags": ["procedural", "2d", "noise", "perlin"], "likes": 8, "viewed": 249, "published": 3, "date": "1645654470", "time_retrieved": "2024-07-30T17:01:40.915591", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// -----------------------------------------------\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat f = 0.0;\n\t\n\tuv *= 4.0;\n    float a = 3.14159 + 0.5 * thc(4., iTime);\n    float c = cos(a), s = sin(a);\n    mat2 rot = mat2(c, s, -s, c);\n    \n    float m = 0.5;\n    float n = 6.;\n    \n    float am = 10.;\n    float fr = fract(0.8 * iTime / am);\n    float poop = 1.5 + floor(am * fr); // didnt know what to call this\n    \n    // (meant to use fract(0.8 * iTime) instead of fr, but I like how it looks)\n    poop = mix(poop, poop + 1., fr);\n    float test = poop * step(0.5, fract(0.25 + 0.5 * uv.y + 0.05 * cos( iTime + 0.2 * uv.x))) - 1.;\n    for (float i = 0.; i < n; i++) {\n        a = (n - i) / n * 0.006 * iTime;\n        uv += 10. * a * vec2(cos(a), sin(a));\n        //uv *= Rot(a);\n        f += m * noise(uv); //0.5 * abs(f - m * noise( uv ));   \n        uv += (5. + 0.45 * cos(uv.x * 2. + test + 0.2 * iTime)) * cos(f);\n        //m *= 0.5;\n    }\n    //f *= 0.5;\n\tf = 0.5 + 0.5*f;\n    f = smoothstep(0., 1., f);\n    float k = 6.;\n\tf = smoothstep(-k, k, f);\n    //f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n    vec3 e = vec3(1);\n    vec3 col = pal(0.755 + test * f, e, e, e, 0.36 * vec3(0,1,2)/3.);\n    float mx = 0.5 + 0.5 * thc(4.,0.12 * uv.x + iTime);\n    col *= mix(1., test, mx);\n    col = sqrt(col) + 0.05;\n\tfragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjBzz.jpg", "access": "api", "license": "mit", "functions": [[2089, 2089, 2146, 2146, 2261], [2263, 2263, 2289, 2289, 2768], [2822, 2822, 2841, 2841, 2907], [2909, 2909, 2966, 2966, 4291]]}
{"id": "NdjBzz", "name": "Chromatic Aberration - Spi3lot", "author": "Spi3lot", "description": "Chromatic Aberration", "tags": ["chromaticaberration", "chromatic", "aberration", "spi3lot"], "likes": 6, "viewed": 278, "published": 3, "date": "1645654061", "time_retrieved": "2024-07-30T17:01:41.781276", "image_code": "// To reverse direction so that red is further away from the center and blue\n// is closer, just subtract your LEVEL from 2.0\n\n// BLUE_EDGE if false (green will always stay at the original position)\n#define RED_EDGE (false)\n\n// Level Of chromatic Aberration\n#define LEVEL (1.02)\n\n\n// LEAVE AS IS FOR BEST EXPERIENCE\n#define LOA (RED_EDGE ? 2.0 - (LEVEL) : (LEVEL))\n#define LINEAR 0\n\n\nvec2 aberrate(vec2 v, float level) {\n    return (v - 0.5) / level + 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float r, g, b;\n\n#if LINEAR == 1\n    r = texture(iChannel0, uv - (LOA - 1.01)).r;\n    g = texture(iChannel0, uv).g;\n    b = texture(iChannel0, uv + (LOA - 1.01)).b;\n#else\n    r = texture(iChannel0, aberrate(uv, 1.0 / LOA)).r;\n    g = texture(iChannel0, uv).g;\n    b = texture(iChannel0, aberrate(uv, LOA)).b;\n#endif\n    \n    /*\n    float r = texture(iChannel0, aberrate(uv, 1.0 / LOA)).r;\n    float g = texture(iChannel0, aberrate(uv, 1.0)).g;\n    float b = texture(iChannel0, aberrate(uv, LOA)).b;\n    */\n\n    // Output to screen\n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 383, 419, 419, 457], [460, 460, 517, 567, 1186]]}
{"id": "sdjBzz", "name": "reflection changes n3", "author": "jorge2017a2", "description": "reflection changes n3", "tags": ["reflectionchangesn3"], "likes": 7, "viewed": 252, "published": 3, "date": "1645653008", "time_retrieved": "2024-07-30T17:01:42.692840", "image_code": "//cambios por jorge flores p.---->jorge2017a2\n//23-feb-2022\n///referencia y fork\n//https://www.shadertoy.com/view/MtlfRs.....by zackpudil in 2017-12-11\n//---------image------\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n#define PI 3.1415926535\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 GetDist(vec3 p  )\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    res =opU3(res, vec3(planeDist1,57.0,7.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,-1)); \n    res =opU3(res, vec3(planeDist3,2.0,-1.0)); \n    res =opU3(res, vec3(planeDist4,3.0,-1.0)); \n    res =opU3(res, vec3(planeDist5,4.0,-1.0)); \n    res =opU3(res, vec3(planeDist6,5.0,-1.0)); \n          p.y=p.y-5.0;\n   \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,5.0), 6.0 );\n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    res =opU3(res, vec3(sdsp2,201.0,-1)); \n    return vec2(res.x, res.y);\n   \n}\n\n// basic trace, with some LOD\nvec2 RayMarch(vec3 ro, vec3 rd, float m) {\n    float t;\n\tvec2 d = vec2(9999.0,-1.0);\n    \n\tfor(int i = 0; i < 200; i++) {\n\t\td = GetDist(ro + rd*t);\n\t\tif(d.x < (0.001 + 0.0001*t) || t >= m) break;\n        t += d.x*0.67;\n\t}\n\treturn vec2(t,d.y);\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p,vec3 lp,vec3 rd, vec3 ro, vec3 color )\n{   vec3 lightPos=lp;\n    vec3 hit=p;\n    vec3 norm=normal;\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = ambOcclusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 6.) * 0.75;\n    vec3 diffuse =  color * dif*0.8;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\n\n\nvec3 GetColor(vec3 pos, float id_color)\n{  vec3 color; \n   if(id_color<50.0)\n   { color=getColor(int(id_color)); }  \n        \n   if(id_color==57.0)\n   { color =vec3(1.0)*( 0.2 + 0.5*mod(floor(pos.x*0.25) + floor(pos.z*0.25), 2.0));}\n             \n   return color;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig1 = normalize(vec3(10.8, 10.0, -15.6));\n    vec3 lig2 = normalize(vec3(0.0, 60., 25.6));\n    vec2 t;\n    vec3 rcol = vec3(0);\n    \n    \tfor(int i = 0; i < 3; i++) {\n\t\t t = RayMarch(ro, rd, MAX_DIST);\n\t\tif(t.x < MAX_DIST) \n        {\n\t\t\t\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t.x;\n\t\t\tvec3 nor = GetNormal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n              vec3 color= GetColor(pos,t.y);\n            \n            \n                rcol= lightingv3(nor,pos,lig1,rd, ro, color );\n                rcol+= lightingv3(nor,pos,lig2,rd, ro, color );\n                rcol/=2.0;\n            \n            // set up the ray orgin and direction for reflection.\n\t\t\t\n            ro = pos + nor*0.001;\n            if (t.y>50.0)\n\t\t\trd = ref;\n            // sky fog.\n\t\t\t///rcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.00715*t.x));\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0)\n               col = rcol;\n\t\t\telse\n               col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t\t}\n        else if(t.x>MAX_DIST)\n        col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n    \n\t}\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,10.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.0,8.0,-15.0);\n    vec3 rd=normalize(vec3(p,1.0));\n     Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    vec3 col= render(ro, rd);\n \tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "///----------common---\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 376, 376, 397], [398, 398, 430, 430, 514], [515, 515, 561, 561, 648], [651, 676, 710, 710, 806], [807, 807, 841, 841, 932], [933, 933, 967, 967, 1058], [1060, 1060, 1094, 1094, 1189], [1191, 1191, 1215, 1215, 2657], [2659, 2689, 2731, 2731, 2933], [2935, 2935, 2959, 2959, 3122], [3124, 3124, 3168, 3168, 3485], [3487, 3487, 3527, 3527, 3784], [3786, 3807, 3837, 3837, 3970], [3972, 3972, 4004, 4004, 4201], [4203, 4203, 4278, 4278, 5242], [5246, 5246, 5287, 5287, 5511], [5513, 5513, 5545, 5545, 6752], [6755, 6755, 6782, 6782, 6871], [6873, 6873, 6931, 6931, 6979], [6982, 6982, 7005, 7005, 7123], [7125, 7125, 7162, 7162, 7432], [7434, 7434, 7492, 7492, 7823]]}
{"id": "fdjfRz", "name": "Fork AuroraBore nateeee 757", "author": "nateeee", "description": "Northern lights shader.", "tags": ["sky", "stars", "aurora"], "likes": 14, "viewed": 746, "published": 3, "date": "1645636823", "time_retrieved": "2024-07-30T17:01:44.182856", "image_code": "\n#define TAU 6.2831853071\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float o = texture(iChannel1, uv * 0.25 + vec2(0.0, iTime * 0.025)).r;\n    float d = (texture(iChannel0, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r * 2.0 - 1.0);\n    \n    float v = uv.y + d * 0.1;\n    v = 1.0 - abs(v * 2.0 - 1.0);\n    v = pow(v, 2.0 + sin((iTime * 0.2 + d * 0.25) * TAU) * 0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    float x = (1.0 - uv.x * 0.75);\n    float y = 1.0 - abs(uv.y * 2.0 - 1.0);\n    color += vec3(x * 0.5, y, x) * v;\n    \n    vec2 seed = fragCoord.xy;\n    vec2 r;\n    r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n    r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n    float s = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n    color += pow(s, 70.0) * (1.0 - v);\n    \n    fragColor.rgb = color;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 82, 82, 993]]}
{"id": "7dBBzz", "name": "Arrow Flow Thing", "author": "SnoopethDuckDuck", "description": "lots and lots of unused code", "tags": ["e"], "likes": 20, "viewed": 457, "published": 3, "date": "1645625302", "time_retrieved": "2024-07-30T17:01:46.896600", "image_code": "#define pi 3.14159\n\n// sloppy (used in rand)\n#define time() 0.2 * iTime \n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// draws an arrow (d is used to make it go up + down)\nfloat arrow(vec2 uv, float d) {\n    float h = 0.1;//0.1 + 0.4 * thc(4.,2. * d);\n    float d1 = sdEquilateralTriangle(uv-vec2(0.,0.25 - h));\n    float s1 = step(d1, -0.5);\n\n    float d2 = sdBox(uv - vec2(0.,-h), vec2(0.05,0.2));\n    float s2 = step(d2, 0.);\n    \n    return max(s1, s2);\n}\n\nfloat h21 (vec2 a, float zoom) {\n    a = mod(a, zoom);\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat rand(vec2 ipos, vec2 fpos, float sc) {\n    //float val = 20. * length(fpos-0.5) + h21(ipos, sc) - iTime;\n    float val = h21(ipos, sc) + time();\n    \n    float a = 6.28319 * h21(ipos, sc);\n    vec2 dir = vec2(cos(a), sin(a));\n    \n    float f = floor(val);\n    \n    float v1 = h21(0.01 * ipos + dir * f, sc);\n    float v2 = h21(0.01 * ipos + dir * (f + 1.), sc);  \n    \n    return mix(v1, v2, smoothstep(0., 1., fract(val)));\n}\n\nfloat rand2(vec2 ipos, vec2 fpos) {\n    // Generate values for each corner of uv\n    float sc2 = 301.; // can be anything \n    float l  = rand(ipos + vec2(1,0), fpos, sc2);\n    float t  = rand(ipos + vec2(0,1), fpos, sc2);\n    float tl = rand(ipos + vec2(1,1), fpos, sc2);\n    float id = rand(ipos + vec2(0,0), fpos, sc2);\n\n    // Smooth fpos so boundaries meet smoothly\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Box lerp between the corner values\n    return l  * sfpos.x      * (1.-sfpos.y)\n     \t + t  * (1.-sfpos.x) * sfpos.y\n         + tl * sfpos.x      * sfpos.y\n         + id * (1.-sfpos.x) * (1.-sfpos.y);   \n}\n\nvec2 movingTiles(vec2 uv, float sc, float spd){\n    float time = spd * iTime;\n    \n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n    float h = rand2(ipos, fpos);\n       \n    float ft = 0.5 + 0.5 * cos(0. * atan(uv.x, uv.y) + 4. * uv.x - uv.y + 0. * length(uv) + 0.2 * pi * h + 4. * time);//fract(h*0.5 + time);\n    \n    \n   // ft = fract(time);\n   // ft = smoothstep(0., 1., ft);\n\n    \n    uv *= sc;\n    \n    float k = step(0.5, ft);//smoothstep(-0.,0.5, ft - 0.5);\n    uv.x +=      k * sign(fract(uv.y * 0.5) - 0.5) * ft * 2.;\n    uv.y += (1.-k) * sign(fract(uv.x * 0.5) - 0.5) * ft * 2.;\n\t\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float sc = 10.;\n    \n    // Cut uv into smaller uvs\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);   \n    \n    float num = 301.; // can be anything\n    \n    float v = rand2(ipos, fpos);\n    //v *= step(v, 0.55);\n        \n    // Do the tile pattern\n    uv = movingTiles(uv, sc, -0.2);\n    uv *= 2.;\n    \n    ipos = floor(uv) + 0.5;\n    fpos = fract(uv) - 0.5;\n    \n\n    // Generate circle using radius we've obtained\n    float d = length(fpos);\n    float k = 10. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.5 * v);\n    \n    float w = 0.1 * v;\n    fpos *= Rot(2. * pi * v);\n    s = max(step(abs(fpos.x), w), step(abs(fpos.y), w));\n    s = step(mlength(fpos), 0.5 * v);\n    \n    //if (v > 0.5)\n        fpos = abs(fpos) - 0.21;\n    s = arrow(fpos, 0.);\n    vec3 col = vec3(s);\n\n    vec3 e = vec3(1.);\n    col *= 4. * pal(h21(ipos), e, e, e, 0.22 * vec3(0,1,2)/3.);\n    col = clamp(col, 0., 1.);\n    //col += 0.4 * (1.-s) * pal(v, e, e, e, 0.2 * vec3(0,1,2)/3.);\n    col = mix(col, h21(ipos) *  s * vec3(fpos, 2.), 0.5 + 0.5 * thc(7., length(ipos)/sc - 0.5* iTime));\n   // col = vec3(fpos + 0.5, 1.);\n    col += 0.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 93, 93, 159], [161, 161, 203, 203, 414], [416, 416, 453, 453, 533], [535, 589, 620, 620, 876], [878, 878, 910, 910, 1002], [1004, 1004, 1048, 1114, 1437], [1439, 1439, 1474, 1519, 2075], [2077, 2077, 2124, 2124, 2703], [2705, 2705, 2762, 2762, 4007]]}
{"id": "ssSBzz", "name": "Gaz fractals modification", "author": "turboplay", "description": "Dedicated to gaz and his best fractals, this one is slightly modified for a different effect.", "tags": ["fractal"], "likes": 9, "viewed": 396, "published": 3, "date": "1645620594", "time_retrieved": "2024-07-30T17:01:47.920861", "image_code": "#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n \tfor(float i=0.,s,e,g=0.,t=iTime;i++<90.;){\n        p=g*d;\n        p.z-=.2;\n        p=R(p,H(t*.03),t*.2);\n        p.x-=.1;\n        p=acos(sin(abs(p)));\n        s=1.5/p.x;\n        for(int j=0;j++<8;)\n           s*=e=max(.5/dot(p,p),1.9),\n           p=abs(p*e-vec3(2,3,2)),\n           p=R(p,normalize(vec3(3,3,1)),1.8);\n        g+=e=abs(p.z)/s+1e-4;\n\t    c+=mix(vec3(1),H(log(s)*.4),.25)*.03/exp(0.8*i*i*e);\n\t}\n\tc*=c*c*c;\n    O=vec4(c,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 145, 145, 663]]}
{"id": "ssSfRz", "name": "Gaussian-blurred primitives", "author": "Michel_Rouzic", "description": "This is how I've been drawing these primitives in all my programs for a decade.", "tags": ["blur", "line", "circle", "antialiasing", "rectangle", "gaussianblur", "dot", "loopless"], "likes": 33, "viewed": 432, "published": 3, "date": "1645618734", "time_retrieved": "2024-07-30T17:01:48.804498", "image_code": "/*\nUnlike the polygon drawing algorithm in my previous shader the algorithms for drawing these primitives\nwith Gaussian are rather simple. The line, dot and rectangle formulas match exactly what Gaussian\nfiltering would yield, the circle algorithms on the other hand might not be quite accurate, but they\nlook about right. The line, dot and thin circle algorithms represent Gaussian filtering of infinitely\nthin lines and dots, therefore their intensities need to be modified according to the blurring radius.\nThe full circle and rectangle algorithms on the other hand naturally scale themselves.\nThe full circle is probably too bright when blurred a lot, I'd need to look into Gaussian circles more.\n*/\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat gaussian(float x)\n{\n\treturn exp(-x*x);\t// ~6 FR\n}\n\nfloat erf_fast(float x)\n{\n\tfloat y, xa = abs(x);\n\n\t// erf(x) ~= 1 - exp(<polynomial>) for x >= 0, max error 1/4249\n\t// 2 mad, 1 mul, 1 +-, 1 copysign, 1 exp = ~9 FR\n\ty = ((-0.06388*xa - 0.66186)*xa - 1.123613)*xa;\n\ty = 1. - exp(y);\n\ty *= sign(x);\n\n\treturn y;\n}\n\nfloat lsrgb(float l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tfloat x, line, curve;\n\n\t// 13 FR every time + 2 FR once\n\tline = l * 12.92;\t// 1 FR\n\tx = sqrt(l);\t// 4 FR\n\tcurve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\t// 5 FR + 2 FR once, error 0.145 sRGB units\n\n\treturn l <= 0.0031308 ? line : curve;\t// 3 FR\n}\n\nvec2 point_rot(vec2 p, float costh, float sinth)\n{\n    vec2 rp;\n\trp.x = p.x * costh - p.y * sinth;\n\trp.y = p.x * sinth + p.y * costh;\n    return rp;\n}\n\nfloat thin_line_weight(float r1x, float r1y, float r2x, float costh, float sinth, vec2 pf)\n{\n\tfloat v;\n\tvec2 rp;\n\n    rp = point_rot(pf, costh, sinth);\n\tv = (erf_fast(rp.x-r1x) - erf_fast(rp.x-r2x)) * 0.5;\n\tv *= gaussian(rp.y-r1y);\n\n\treturn v;\n}\n\nfloat point_weight(vec2 dp, float rad, vec2 pf)\n{\n\tfloat d = distance(dp, pf) * rad;\t// distance of the pixel from the centre of the dot, scaled\n\n\treturn gaussian(d);\n}\n\nfloat circle_full_weight(vec2 pc, float circrad, float rad, vec2 pf)\n{\n\tfloat dc, dn, df;\n\n\tdc = distance(pf, pc);\t\t// Distance to center\n\tdn = (circrad - dc) * rad;\t// Near edge distance\n\tdf = -(circrad + dc) * rad;\t// Far edge distance\n\n\treturn (erf_fast(dn) - erf_fast(df)) * 0.5;\n}\n\nfloat circle_hollow_weight(vec2 pc, float circrad, float rad, vec2 pf)\n{\n\tfloat dc, dn, df;\n\n\tdc = distance(pf, pc);\t\t// Distance to center\n\tdn = (circrad - dc) * rad;\t// Near edge distance\n\tdf = -(circrad + dc) * rad;\t// Far edge distance\n\n\treturn gaussian(dn) + gaussian(df);\n}\n\nfloat rect_full_weight(vec2 p0, vec2 p1, float rad, vec2 pf)\n{\n\tfloat d;\n\tvec2 d0, d1, gv;\n\n\td0 = (pf - p0) * rad;\n\td1 = (pf - p1) * rad;\n\n\tgv.x = erf_fast(d0.x) - erf_fast(d1.x);\n\tgv.y = erf_fast(d0.y) - erf_fast(d1.y);\n\n\treturn gv.x * gv.y * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Pixel to world coordinates\n    float scrscale = 18. / iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5) * scrscale;\n    \n    // Tetragon rotation\n    float th = iTime * 6.2831853 / 40.;\n    float costh = cos(th);\n    float sinth = sin(-th);\n    \n    // Varying blurriness\n    float rad = sq(1.-abs(cos(iTime * 6.2831853 / 16.))) * 6.;\n    float min_rad = 0.8*scrscale;\n    rad = length(vec2(rad, min_rad));\n\n    // Add all the primitives\n    vec3 pv = vec3(0.);\n    pv += thin_line_weight(-3.5/rad, 0./rad, 5./rad, costh/rad, -sinth/rad, uv) * min_rad/rad;\n    pv += vec3(0., 0.44, 1.) * circle_full_weight(point_rot(vec2(-5., 0.), costh, sinth), 1.5, 1./rad, uv);\n    pv += vec3(0.5, 1., 0.) * circle_hollow_weight(point_rot(vec2(5., 0.), costh, sinth), 1.5, 1./rad, uv) * min_rad/rad;\n    for (float dt=-3.25; dt <= 3.25; dt += 0.5)\n        pv += mix(vec3(1., 1., 0.), vec3(1., 0., 0.), (dt+3.5)/7.) * point_weight(point_rot(vec2(0., dt), costh, sinth), 1./rad, uv) * sq(min_rad/rad);\n    pv += vec3(1., 0., 0.06) * rect_full_weight(vec2(-1.5, 3.5), vec2(1.5, 6.5), 1./rad, point_rot(uv, costh, -sinth));\n    pv += vec3(1., 1., 0.) * \n            (rect_full_weight(vec2(-1.5, -6.5), vec2(1.5, -3.5), 1./rad, point_rot(uv, costh, -sinth)) -\n            rect_full_weight(vec2(-1., -6.), vec2(1., -4.), 1./rad, point_rot(uv, costh, -sinth)));\n\n    // Output to screen\n    fragColor = vec4(lsrgb(pv.r), lsrgb(pv.g), lsrgb(pv.b), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[705, 705, 724, 724, 744], [746, 746, 771, 771, 801], [803, 803, 828, 828, 1063], [1065, 1065, 1154, 1154, 1444], [1446, 1446, 1496, 1496, 1596], [1598, 1598, 1690, 1690, 1843], [1845, 1845, 1894, 1894, 2013], [2015, 2015, 2085, 2085, 2300], [2302, 2302, 2374, 2374, 2581], [2583, 2583, 2645, 2645, 2834], [2836, 2836, 2891, 2929, 4346]]}
{"id": "ssSfzR", "name": "odos|metaballs", "author": "ErinZ", "description": "metaballs colored by normal vector.", "tags": ["raymarching"], "likes": 6, "viewed": 399, "published": 3, "date": "1645611467", "time_retrieved": "2024-07-30T17:01:49.662205", "image_code": "#define TMIN 0.01\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.1415926\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//========SDFunctions========\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\n//===============TRANSFORM=================\nmat2 rotate(float a){\nreturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat smUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//===============RENDER===================\n//Scene\nfloat f(vec3 p){\n    p.zx*=rotate(iTime);\n    p.yz*=rotate(iTime);\n    float k = .7;\n    float d1 = sdSphere(p,vec3(sin(iTime*.5)),1.3);//center sphere\n    float d2 = sdSphere(p,vec3(0,2.*sin(iTime),0.),.5);\n    float d = smUni(d1,d2,k);\n    \n    float d3 = sdSphere(p,vec3(sin(iTime+5.),0,2.*sin(iTime+5.)),.9);\n    d= smUni(d,d3,k);\n     \n    float d4 = sdSphere(p,vec3(-cos(iTime+.3),cos(iTime+.3),cos(iTime+.3)),.8);\n    d= smUni(d,d4,k);\n    \n    float d5 = sdSphere(p,vec3(3.*cos(iTime+.7),0.,.5),.3);\n    d= smUni(d,d5,k);\n    \n\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nmat3 setCamera(in vec3 camtar, in vec3 campos, in float camro){\n    vec3 z = normalize(camtar-campos);\n    vec3 cp = vec3(sin(camro),cos(camro),0.);\n    vec3 x = normalize(cross(cp,z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(-5., 5.,-5);//light\n\n    //SET Camera\n    vec3 cam_tar = vec3(-1,3,2);//cam target\n    vec3 cam_pos = cam_tar +vec3(-3,8,5);//cam position\n\n\n    vec3 rd = vec3(uv,9.); //decide view width\n    rd = normalize(setCamera(cam_tar,cam_pos,0.)*rd);//viewing frustum\n\n    float t = rayMarch(cam_pos,rd);//raymarching\n    \n    vec3 color = vec3(0);//background\n    if(t > TMAX) return color; \n    \n    vec3 p = cam_pos + t*rd;\n    vec3 n = calcNormal(p);\n\n    color = n*.5+.5;\n    // fog\n    color *= exp( -0.0001*t*t*t );\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    #if AA>1\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n    #else\n            uv = getuv(fragCoord);\n    #endif\n            color += render(uv);\n    #if AA>1\n        }\n    }\n    color /= float(AA*AA);\n    #endif\n    \n\n \n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 227, 267, 267, 295], [296, 340, 361, 361, 406], [407, 407, 451, 451, 551], [553, 604, 620, 620, 1155], [1156, 1156, 1196, 1196, 1411], [1413, 1459, 1487, 1487, 1702], [1704, 1704, 1767, 1767, 1940], [1941, 1941, 1962, 1962, 2526], [2527, 2527, 2550, 2550, 2604], [3202, 3202, 3222, 3222, 3611]]}
{"id": "fdBfRz", "name": "Mis Ojos", "author": "oneshade", "description": "!!!", "tags": ["eyes", "animated", "realistic"], "likes": 15, "viewed": 272, "published": 3, "date": "1645593738", "time_retrieved": "2024-07-30T17:01:50.486003", "image_code": "#define TAU 6.2831853072\n\n// http://marcodiiga.github.io/radial-lens-undistortion-filtering\nvec2 barrelDistort(in vec2 p, in vec2 alpha) {\n    return p / (1.0 - alpha * dot(p, p));\n}\n\n// 1D noise\nfloat Hash11(in float p) { // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat snoise11(in float p) {\n    return mix(Hash11(floor(p)), Hash11(ceil(p)), smoothstep(0.0, 1.0, fract(p)));\n}\n\nfloat fbm11(in float p) {\n    p *= 6.0;\n\n    float res = 0.0;\n    float amp = 1.0;\n    float totAmp = 0.0;\n    for (int oct=0; oct < 5; oct++) {\n        res += amp * snoise11(p);\n        totAmp += amp;\n        p *= 2.0;\n        amp *= 0.5;\n    }\n\n    return res / totAmp;\n}\n\n// 2D noise\nfloat Hash21(in vec2 p) { // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise21(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = smoothstep(0.0, 1.0, fract(p));\n\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fbm21(in vec2 p) {\n    float res = 0.0;\n    float amp = 1.0;\n    float totAmp = 0.0;\n    for (int oct=0; oct < 5; oct++) {\n        res += amp * abs(2.0 * snoise21(p) - 1.0);\n        totAmp += amp;\n        p *= 2.0;\n        amp *= 0.5;\n    }\n\n    return res / totAmp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Symmetry (not mirroring though)\n    uv.x = uv.x - 1.4 * sign(uv.x);\n\n    // Distorted UVs to fake a 3D look\n    vec2 bulgeUv = barrelDistort(uv, vec2(0.25));\n    vec2 eyeballUv = bulgeUv - 0.15 * mouse; // Look at mouse\n\n    // Veins\n    float co = cos(1.4), si = sin(1.4);\n    mat2 rot = mat2(co, si, -si, co);\n\n    float veinFade = smoothstep(1.8, 0.0, length(eyeballUv));\n    for (int i=0; i < 4; i++) {\n        color.gb -= 0.7 * smoothstep(0.2, 0.0, fbm21(2.0 * eyeballUv - 10.0)) * veinFade;\n        eyeballUv *= rot;\n    }\n\n    color = max(color, 0.0);\n\n    // Iris\n    vec2 polar = vec2(atan(eyeballUv.y, eyeballUv.x), length(eyeballUv));\n\n    float irisWidth = 0.125 + 0.015 * snoise11(iTime);\n    float irisRadius = 0.375 - irisWidth;\n    float irisDist = abs(length(eyeballUv) - irisRadius) - irisWidth;\n\n    vec3 irisColor = vec3(0.7, 0.4, 0.0) * fbm11(polar.x);\n    irisColor += vec3(0.0, 0.45, 0.0) * fbm11(polar.x - 10.0);\n    color = mix(color, irisColor * 0.9, smoothstep(unit, 0.0, irisDist));\n    //color *= smoothstep(0.0, 0.31, polar.y);\n    if (polar.y < irisRadius + irisWidth) color *= smoothstep(0.1, -0.1, irisDist); // It took me a while to realize this was what I really needed!\n\n    // Pupil\n    color = max(color - smoothstep(unit, 0.0, polar.y - irisRadius + irisWidth), 0.0);\n\n    // Fake specular highlight\n    color += smoothstep(0.2, -0.2, length(uv - vec2(0.3, 0.15)));\n\n    // Eye shape (deformed circle)\n    vec2 eyeUv = vec2(uv.x, 3.5 * uv.y / (2.0 - uv.x * uv.x));\n    //vec2 eyeUv = vec2(uv.x, 6.5 * uv.y / (4.0 - uv.x * uv.x));\n\n    float eyeMask = smoothstep(0.1, -0.1, length(eyeUv) - 1.0); // Outline\n    eyeMask *= smoothstep(2.0, 0.0, length(eyeUv)); // Shading\n\n    float blink = 1.0 - 2.0 * pow(abs(cos(mod(iTime, TAU))), 1000.0);\n    float eyelidCurve = 0.15 * bulgeUv.x * bulgeUv.x * blink;\n    eyeMask *= smoothstep(0.1, 0.0, bulgeUv.y + eyelidCurve - blink); // Eyelid\n\n    color *= eyeMask;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 92, 138, 138, 182], [184, 196, 222, 263, 349], [351, 351, 379, 379, 464], [466, 466, 491, 491, 739], [741, 753, 778, 819, 933], [935, 935, 962, 962, 1266], [1268, 1268, 1292, 1292, 1542], [1544, 1544, 1599, 1599, 3813]]}
{"id": "7slfWX", "name": "first person camera controls", "author": "icantcomeupwithausername", "description": "basic movement and camera rotation, use WASD keys, space, and mouse to navigate", "tags": ["interactive", "camera", "controls"], "likes": 6, "viewed": 315, "published": 3, "date": "1645579092", "time_retrieved": "2024-07-30T17:01:51.356675", "image_code": "//#define debug\n\n/*\n * Buffer A: Camera Controls\n * Buffer B: Rendering\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel0, uv).xyz;\n    \n    #ifdef debug\n        fragColor = texture(iChannel0, uv)+texture(iChannel1, uv)+texture(iChannel2, uv);\n    #else\n        fragColor = texture(iChannel0, uv);\n    #endif\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define initialPos vec3(0.0,1.0,0.0) //starting position\n#define initialRot vec3(0.0)\n#define mouseSensitivity 0.8\n#define plrHeight 0.5 \n#define gravity 2.0 \n#define moveSpeed 1.8 \n\n#define wkey 87.0\n#define akey 65.0\n#define skey 83.0\n#define dkey 68.0\n#define spacekey 32.0\n\n//detects keypresses\nbool keyDown(float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    return texture(iChannel0, uv).x > 0.0;\n}\n\n/*\n * position is stored at pixel 0,0\n * rotation is stored at pixel 0,1\n * rotation before mouse click is stored at pixel 0,2\n */\n\nvec4 getPosition(){\n    vec4 p = texelFetch(iChannel1, ivec2(0,0), 0) * 255.0 - 100.0;    \n    return p.xyzw;\n}\n\nvec3 getRotation(){\n   vec4 r = texelFetch(iChannel1, ivec2(0,1), 0) * 255.0 - 100.0;     \n   return r.xyz;\n}\n\nvec3 getPRotation(){\n   vec4 r = texelFetch(iChannel1, ivec2(0,2), 0) * 255.0 - 100.0;     \n   return r.xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){ \n    //discard unused fragments\n    if(int(fragCoord.x) > 0 || int(fragCoord.y) > 2){\n        discard;\n    }\n\n    if(iFrame > 0){ \n        vec3 rot = getRotation();\n                \n        //handle movement and position\n        switch(int(fragCoord.y)){\n            case 0:\n                vec4 posb = getPosition();\n                vec3 pos = posb.xyz;\n\n                raycastReturn collide = raycast(Ray(vec3(pos.x, pos.y - 0.1, pos.z), normalize(vec3(1.0,-1.0,1.0))));\n\n                //gravity\n                if(collide.dist > plrHeight && posb.w >= 0.0){\n                    pos.y -= gravity * posb.w * iTimeDelta;\n                    posb.w += 0.02; //slowly accelerate fall\n                }else if(posb.w > 0.0){\n                    posb.w = 0.0; //reset w \n                }\n\n                //reset fall\n                if(pos.y < -4.0){\n                    pos = initialPos;\n                }\n\n                if(keyDown(wkey)){ \n                    pos = pos + vec3(0.0,0.0,1.0) * rotate(vec2(0.0,rot.y)) * moveSpeed * iTimeDelta;\n                } \n                \n                if(keyDown(skey)){\n                    pos = pos + vec3(0.0,0.0,-1.0) * rotate(vec2(0.0,rot.y)) * moveSpeed * iTimeDelta;\n                } \n                \n                if(keyDown(akey)){\n                    pos = pos + vec3(-1.0,0.0,0.0) * rotate(vec2(0.0,rot.y)) * moveSpeed * iTimeDelta;\n                } \n                \n                if(keyDown(dkey)){\n                    pos = pos + vec3(1.0,0.0,0.0) * rotate(vec2(0.0,rot.y)) * moveSpeed * iTimeDelta;\n                } \n                \n                if(keyDown(spacekey) && collide.dist <= plrHeight){\n                    posb.w = -1.0; //start a jump if space is pressed\n                }\n\n                if(posb.w < 0.0){\n                    pos.y += 0.04 * -posb.w;\n                    posb.w += gravity * iTimeDelta;\n                }\n\n                fragColor = vec4((pos + 100.0) / 255.0, (posb.w + 100.0) / 255.0);\n            break;\n            \n            case 1:\n                if(iMouse.z > 0.0){\n                    rot = getPRotation() - vec3(((iMouse.xy-abs(iMouse.zw)) * vec2(-1.0,1.0)).yx * mouseSensitivity, 0.0);\n                    rot.x = clamp(rot.x, -100.0, 100.0); //prevent camera from flipping\n                }\n\n                fragColor = vec4((rot + 100.0) / 255.0, 1.0);\n            break;\n            \n            case 2: \n                if((iMouse.z > 0.0) == false){\n                    fragColor = vec4((rot + 100.0) / 255.0, 1.0);\n                }else{\n                    fragColor = vec4((getPRotation() + 100.0) / 255.0, 1.0);\n                }\n            break;\n        } \n    }else{\n        //initialize\n        switch(int(fragCoord.y)){\n            case 0:\n                fragColor = vec4((initialPos + 100.0) / 255.0, 100.0 / 255.0);\n            break;\n            \n            case 1:\n                fragColor = vec4((initialRot + 100.0) / 255.0, 1.0);\n            break;\n            \n            case 2:\n                fragColor = vec4((initialRot + 100.0) / 255.0, 1.0);\n            break;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define sunDirection vec3(0.0, 1.0, 0.0)\n\n//used for fetching camera properties\nvec3 getPosition(){\n    vec4 p = texelFetch(iChannel0, ivec2(0,0), 0) * 255.0 - 100.0;    \n    return p.xyz;\n}\n\nvec2 getRotation(){\n   vec4 r = texelFetch(iChannel0, ivec2(0,1), 0) * 255.0 - 100.0;     \n   return r.xy;\n}\n\nvec3 sky(vec3 raydir){ //very crappy sky\n    vec3 col;\n    if(raydir.y > 0.0){\n        float i = max(1.0-dot(vec3(0.0,1.0,0.0), raydir*30.0),0.0);\n        col = vec3(0.271, 0.345, 0.482)+i+(1.0-raydir.y)*0.48;\n    }else{\n        float i = max(1.0-dot(vec3(0.0,1.0,0.0), -raydir*30.0),0.0);\n        col = vec3(0.416, 0.396, 0.382)+i+raydir.y*0.1;\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 js[4];\n    js[0] = vec2(0.25,0.75);\n    js[1] = vec2(0.75,-0.25);\n    js[2] = vec2(-0.25,-0.75);\n    js[3] = vec2(-0.25,0.75);\n    \n    //get camera position from Buffer A texture\n    vec3 origin = getPosition();\n    \n    vec3 color;\n    for(int i=0; i<js.length(); i++){\n        vec3 dir = normalize(vec3(uv+(js[i]/iResolution.xy),1.0))*rotate(getRotation()); //rotate view rays\n        Ray ray = Ray(origin, dir);\n        raycastReturn rcast = raycast(ray); //cast ray into scene\n\n        if(length(rcast.normal) > 0.0){ //check ray collision\n            color += rcast.color*max(dot(sunDirection, rcast.normal),0.5); //perform basic shading\n        }else{\n            color += sky(ray.direction) + 0.2;\n        }\n    }\n    color/=float(js.length());\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * matrix math\n */\n \nmat3 rotate(vec2 rot){\n    float rotationy = radians(rot.y);\n\tfloat ys = sin(rotationy);\n\tfloat yc = cos(rotationy);\n\tfloat yoc = 1.0-yc;\n\tmat3 y = mat3(yc,0.0,ys,\n\t\t\t\t0.0,yoc+yc,0.0,\n\t\t\t\t-ys,0.0,yc);\n                \n    float rotationx = radians(rot.x);\n\tfloat xs = sin(rotationx);\n\tfloat xc = cos(rotationx);\n\tfloat xoc = 1.0-xc;\n\tmat3 x = mat3(xoc+xc,0.0,0.0,\n\t\t\t    0.0,xc,-xs,\n\t\t\t\t0.0,xs,xc);\n                \n    return x*y; //z rotation isnt needed\n}\n\n/*\n * raycasting\n */\n \nstruct Ray{\n    vec3 origin, direction;\n};\n\nstruct Box{\n    vec3 position, size, color;\n};\n\nstruct raycastReturn{\n    vec3 endp, normal, color;\n    float dist;\n};\n \n//box intersection\nvec4 box(Ray ray,Box box) {\n    mat4 translate = mat4(1.0,0.0,0.0,0.0, //box matrix\n                          0.0,1.0,0.0,0.0,\n                          0.0,0.0,1.0,0.0,\n                          box.position,1.0);\n\n    vec3 q = (inverse(translate)*vec4(ray.origin,1.0)).xyz;\n    vec3 m = 1.0/(inverse(translate)*vec4(ray.direction,0.0)).xyz; \n    vec3 n = m*q;  \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tn = max(max(t1.x,t1.y),t1.z);\n    float tf = min(min(t2.x,t2.y),t2.z);\n    if(tn>tf||tf<0.0) return vec4(-1.0); //ray missed\n    vec3 normal = sign(q)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4(normal,tn);\n}\n\nraycastReturn raycast(Ray ray){\n    float depth = 9e20; \n    raycastReturn hit = raycastReturn(vec3(0.0), vec3(0.0), vec3(0.0), 9e20);\n    \n    for(int o = 0; o < 20; o+=2){ //stairs\n        Box bx = Box(vec3(sin(float(o)*0.3)*2.0,float(o)*0.2+0.101,cos(float(o)*0.3)*2.0), vec3(0.4,0.1,0.4), vec3(0.8));\n        \n        vec4 bdist = box(ray, bx);\n        if(bdist.w > 0.0 && bdist.w < depth){\n            vec3 end = ray.origin+ray.direction*bdist.w;\n            vec3 normal = bdist.xyz;\n            hit = raycastReturn(end, normal, bx.color, bdist.w);\n            depth = bdist.w;\n        }\n    }\n    \n    //platform\n    Box fbx = Box(vec3(0.0,4.0,0.0), vec3(1.0,0.1,1.0), vec3(0.25, 0.75, 0.25));        \n    vec4 bdist = box(ray, fbx);\n    if(bdist.w > 0.0 && bdist.w < depth){\n        vec3 end = ray.origin+ray.direction*bdist.w;\n        vec3 normal = bdist.xyz;\n        hit = raycastReturn(end, normal, fbx.color, bdist.w);\n        depth = bdist.w;\n    }\n    \n    //floor\n    float pd = -ray.origin.y/ray.direction.y;\n    if(pd>.0&&pd<depth){ \n        vec3 end = ray.origin+ray.direction*pd;\n        \n        if(end.x < 3.0 && end.z < 3.0 && end.x > -3.0 && end.z > -3.0){\n            //grid\n            vec2 tcoord = floor(end.xz);\n            float pmask = mod(tcoord.x+mod(tcoord.y, 2.0), 2.0);\n            hit = raycastReturn(end, vec3(0.0,1.0,0.0), vec3(clamp(pmask * 1.0, 0.5, 0.9)), pd);\n        }\n    }\n    \n    return hit;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 131, 131, 391]]}
{"id": "sdsBWs", "name": "More colors, more spirals", "author": "mrange", "description": "CC0: More colors, more spirals\nBeen tinkering withs spirals for a few days so why stop now\n", "tags": ["2d", "spirals"], "likes": 38, "viewed": 581, "published": 3, "date": "1645566734", "time_retrieved": "2024-07-30T17:01:52.211389", "image_code": "// CC0: More colors, more spirals\n// Been tinkering withs spirals for a few days so why stop now\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x)+PI);\n}\n\nvec2 spiralEffect(vec2 p, float a, float n) {\n  vec2 op = p;\n  float b = a/TAU;\n  vec2 pp   = toPolar(op);\n  float  aa = pp.y;\n  pp        -= vec2(pp.y*n*b, (pp.x/b+PI)/n);\n  vec2  nn  = mod2(pp, vec2(a, TAU/n));\n  // Yes, this is a trial and error:ed until it looked good \n  // because I couldn't be bothered to compute the real solution\n  float xf  = tanh_approx(20.0*length(p)/abs(n));\n  return vec2(abs(pp.x)*xf, mod(nn.y, n));\n}\n\n\nvec3 df(vec2 p) {\n  float zo = mix(0.75, 1.5, smoothstep(-0.5, 0.5, -cos(TIME*sqrt(0.1))));\n  \n  p /= zo;\n\n  p += 10.0*cos(0.033*TIME*vec2(1.0, sqrt(0.5)));\n  \n  vec2  hn = hextile(p);\n  float hh = hash(hn);\n  float h0 = fract(1367.0*hh);\n  float h1 = fract(1777.0*hh);\n  float h2 = fract(2083.0*hh);\n  float h3 = fract(2711.0*hh);\n  float h4 = fract(2803.0*hh);\n  \n  float zi = mix(0.125, 0.25, h3);\n\n  float hd = (abs(hex(p.yx, 0.5))-0.025)*zo;\n  \n  p /= zi;\n  \n  float a = 0.5;\n  float sp0 = round(mix(1.0, 23.0, h0));\n  float sp1 = round(mix(1.0, 37.0, h1));\n  vec2 se0 = spiralEffect(p*ROT(-0.123*TIME), a, sp0);\n  vec2 se1 = spiralEffect(p*ROT(.1*TIME), a, sign(h4-0.75)*sp1);\n  \n  vec2 se = vec2(pmin(se0.x, se1.x, 0.025), se0.y+se1.y);\n  \n  float h = se.y*0.05+h2+TIME*0.2;\n  float d = -((se.x)-0.05);\n  d *= zi*zo;\n  return vec3(d, hd, h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q  = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  vec3 d3 = df(p);\n  float d = d3.x;\n  float hd= d3.y;\n  float h = d3.z;\n  float s = smoothstep(aa, -aa, d);\n  vec3 col = vec3(0.0);\n  \n  col = hsv2rgb(vec3(fract(h), 0.95, s));\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, hd));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 428, 450, 450, 596], [598, 698, 719, 719, 792], [793, 893, 915, 915, 964], [966, 1049, 1088, 1088, 1173], [1175, 1261, 1297, 1297, 1391], [1393, 1453, 1481, 1547, 1623], [1625, 1726, 1754, 1853, 2180], [2182, 2276, 2305, 2305, 2485], [2487, 2547, 2568, 2568, 2638], [2640, 2640, 2662, 2662, 2709], [2711, 2711, 2756, 2756, 3144], [3147, 3147, 3164, 3164, 3997], [3999, 3999, 4054, 4054, 4472]]}
{"id": "7dsfDl", "name": "reflection changes n2", "author": "jorge2017a2", "description": "reflection changes n2", "tags": ["reflectionchangesn2"], "likes": 12, "viewed": 253, "published": 3, "date": "1645563523", "time_retrieved": "2024-07-30T17:01:53.311448", "image_code": "//cambios por jorge flores p.---->jorge2017a2\n//21-feb-2022\n///referencia y fork\n//https://www.shadertoy.com/view/MtlfRs.....by zackpudil in 2017-12-11\n\n\n//----\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n#define MIN_DIST 0.001\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  )\n{\n\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n   \n    res =opU2(res, vec2(planeDist1,1.0));\n    float sds1=sdSphere(p-vec3(0.0,5.0,0.0), 5.0 );\n    float d2= sdBox(p-vec3(-10.0,5.0,-5.0), vec3(3.0,10.0,2.0) );\n    float d3= sdBox(p-vec3(10.0,15.0,5.0), vec3(3.0,15.0,5.0) );\n    float d4=sdSphere(p-vec3(0.0,14.0,0.0), 3.0 );\n    float d5= sdBox(p-vec3(-10.0,3.5,10.0), vec3(2.0) );\n\n    res =opU2(res, vec2(sds1,2.0));\n    res =opU2(res, vec2(d2,3.0));\n    res =opU2(res, vec2(d3,4.0));\n    res =opU2(res, vec2(d4,5.0));\n    res =opU2(res, vec2(d5,6.0));\n    return res;\n}\n\n// basic trace, with some LOD\nvec2 RayMarch(vec3 ro, vec3 rd, float m) {\n    float t;\n\tvec2 d = vec2(9999.0,-1.0);\n    \n\tfor(int i = 0; i < 200; i++) {\n\t\td = GetDist(ro + rd*t);\n\t\tif(d.x < (0.001 + 0.0001*t) || t >= m) break;\n        t += d.x*0.67;\n\t}\n\treturn vec2(t,d.y);\n}\n\n// basic normal.\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tGetDist(p + h.xyy).x - GetDist(p - h.xyy).x,\n\t\tGetDist(p + h.yxy).x - GetDist(p - h.yxy).x,\n\t\tGetDist(p + h.yyx).x - GetDist(p - h.yyx).x\n\t);\n\treturn normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 iluminacion(vec3 pos,vec3 rd,vec3 nor, vec3 ref, vec3 lig, float id_color )\n{\n    vec3 rcol =vec3(0.0);    \n    // occlusion and shadows\n    float occ = ambOcclusion(pos, nor);\n\t//float sha = step(5.0, trace(pos + nor*0.001, lig, 5.0));\n    float sha = getSoftShadow(pos, normalize(lig));\n\t\t\t\n    // lighting ambient + diffuse + fresnel + specular\n\trcol += 0.2*occ;\n\trcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*sha;\n\trcol += pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*occ;\n\trcol += 2.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\t\n     \n    if(id_color==1.0)\n    {    rcol *= 0.2 + 0.5*mod(floor(pos.x*0.25) + floor(pos.z*0.25), 2.0);}\n      \n\tif(id_color==2.0)\n    { rcol *= vec3(0.2, 0.7, 0.7);  }\n     \n     if(id_color==3.0)\n    { rcol *= vec3(1.0, 0.32, 0.17); }\n    \n    if(id_color==4.0)\n    { rcol *= vec3(1.0); }\n    \n    if(id_color==5.0)\n    { rcol *= vec3(1.0,0.0,0.0); }\n    \n    if(id_color==6.0)\n    { rcol *= vec3(1.0,1.0,0.0); }\n    \n        \n\treturn rcol;\t\t\n}        \n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig1 = normalize(vec3(10.8, 20.0, -25.6));\n    vec3 lig2 = normalize(vec3(0.0, 10., 25.6));\n    vec2 t;\n    \n    \tfor(int i = 0; i < 3; i++) {\n\t\t t = RayMarch(ro, rd, 50.0);\n\t\tif(t.x < 50.0) \n        {\n\t\t\tvec3 rcol = vec3(0);\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t.x;\n\t\t\tvec3 nor = normal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n            rcol=iluminacion(pos,rd, nor, ref, lig1,t.y);\n            rcol+=iluminacion(pos,rd, nor, ref, lig2,t.y);\n            rcol/=2.0;\n            \n            // set up the ray orgin and direction for reflection.\n\t\t\t\n            ro = pos + nor*0.001;\n            //separacion de colores y reflection\n            if (t.y<5.0)  \n\t\t\trd = ref;\n            \n            // sky fog.\n\t\t\trcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.00715*t.x));\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0)\n               col = rcol;\n\t\t\telse\n                col *= mix(rcol, vec3(1), 1.0 - exp(-0.8*float(i)));\n\t\t}\n\t}\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=25.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,20.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\tvec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\t\n    vec3 ro=vec3(0.0,8.0,-15.0);\n    vec3 rd=normalize(vec3(p,1.0));\n    \n     Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    \n    \n    vec3 col= render(ro, rd);\n        \n    // tone mapping and gamma correction.\n\t//col = 1.0 - exp(-0.5*col);\n\t//col = pow(abs(col), vec3(1.0/2.2));\n\tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsfDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 333, 333, 354], [355, 355, 387, 387, 471], [473, 498, 532, 532, 628], [629, 629, 663, 663, 754], [755, 755, 789, 789, 880], [882, 882, 906, 906, 1518], [1520, 1550, 1592, 1592, 1794], [1796, 1813, 1834, 1834, 2046], [2048, 2048, 2092, 2092, 2409], [2411, 2411, 2451, 2451, 2708], [2710, 2731, 2761, 2761, 2894], [2896, 2896, 2978, 2978, 3886], [3896, 3896, 3928, 3928, 4993], [4996, 4996, 5023, 5023, 5112], [5114, 5114, 5172, 5172, 5220], [5223, 5223, 5246, 5246, 5364], [5366, 5366, 5403, 5403, 5673], [5675, 5675, 5733, 5733, 6200]]}
{"id": "sssfWl", "name": "Collatz Conjecture 2", "author": "elenzil", "description": "different view of https://shadertoy.com/view/NslBWs .\nthat shader effectively assigns the intensity of each pixel as the height of each of these stacks.\nI was curious to see the structure within the stacks.", "tags": ["math"], "likes": 10, "viewed": 269, "published": 3, "date": "1645560838", "time_retrieved": "2024-07-30T17:01:54.423475", "image_code": "// Fork of \"Collatz Conjecture.\" by RJVB09. https://shadertoy.com/view/NslBWs\n// 2022-02-22 19:56:00\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    int n = int(texelFetch(iChannel0, ivec2(XY), 0).r);\n    \n    RGBA = vec4(vec3(float(n) / 300.0), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    int n;\n    \n    const int maxHeight = 300;\n    \n    if (IJ.y % maxHeight == 0) {\n        n = IJ.x + (IJ.y / maxHeight) * int(iResolution.x);\n    }\n    else {    \n        n = int(texelFetch(iChannel0, ivec2(IJ.x, IJ.y - 1), 0).r);\n\n        if (n > 1) {\n            if (n % 2 == 1)\n            {\n                n = n * 3 + 1;\n            }\n            else\n            {\n                n /= 2;\n            }\n        }\n    }\n    \n    if (iMouse.z > 1.0) {\n        n = 0;\n    }\n    \n    RGBA = vec4(float(n));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssfWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 147, 147, 256]]}
{"id": "NdlfDs", "name": "idk grid thing", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 5, "viewed": 227, "published": 3, "date": "1645560523", "time_retrieved": "2024-07-30T17:01:55.356979", "image_code": "#define pi 3.14159\n\nfloat h21 (vec2 a, float zoom) {\n    a = mod(a, zoom);\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat rand(vec2 ipos, float num) {\n    float val = h21(ipos, num) + 0.4 * iTime;\n    \n    float a = 2. * pi * h21(ipos, num);\n    float c = cos(a), s = sin(a);\n    \n    float f = floor(val);\n    vec2 v = vec2(c,s);\n    float v1 = h21(f * v + 0.01 * ipos, num);\n    float v2 = h21((f + 1.) * v + 0.01 * ipos, num);  \n    \n    float m = smoothstep(0., 1., fract(val));\n   \n    return mix(v1, v2, m);\n}\n\nvec2 movingTiles(vec2 uv, float sc, float spd){\n    float time = spd * iTime;\n    \n    float ft = fract(2. * (abs(uv.x) + abs(uv.y)) + time);\n\n    uv *= sc;\n    \n    float k = step(0.5, ft);//smoothstep(-0.,0.5, ft - 0.5);\n    uv.x +=      k * sign(fract(uv.y * 0.5) - 0.5) * ft * 2.;\n    uv.y += (1.-k) * sign(fract(uv.x * 0.5) - 0.5) * ft * 2.;\n\t\n    return fract((2. + 0.03 * h21(uv)) * uv);\n}\n\nfloat grid(vec2 uv, float sc) {\n    // Cut uv into smaller uvs\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);   \n    \n    float num = 301.; // can be anything\n    \n    // Generate values for each corner of uv, used for circle radii\n    float l  = rand(ipos + vec2(1,0), num);\n    float t  = rand(ipos + vec2(0,1), num);\n    float tl = rand(ipos + vec2(1,1), num);\n    float id = rand(ipos + vec2(0,0), num);\n\n    // Smooth the cut uvs so different uvs meet continuously on the edges\n    //uv = uv * uv * (3. - 2. * uv);\n    //fpos = smoothstep(0., 1., fpos);\n    fpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l * fpos.x * (1.-fpos.y)\n     \t    + t * (1.-fpos.x) * fpos.y\n     \t    + tl * fpos.x * fpos.y\n      \t    + id * (1.-fpos.x) * (1.-fpos.y);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float sc = 10.;\n    \n    float t = 0.2 * iTime;\n    \n    float m = 0.5;\n    vec2 uv2 = uv;\n    float v = 0.;\n    for (float i = 0.; i < 5.; i++) {\n        \n        t -= 2. * uv.x; //length(uv);\n       \n        v += m * grid(uv2, sc);\n        float cs = cos(t), sn = sin(t);\n        mat2 rot = mat2(cs, -sn, sn, cs);\n        uv2 *= rot;\n        m *= 0.35;\n    }\n        \n    // Do the tile pattern\n    vec2 fpos = movingTiles(uv, sc, -0.1) - 0.5;\n\n    // Generate circle using radius we've obtained\n    float d = 0.8-mlength(fpos);\n    float k = 10. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.68 * v);\n    vec3 col = vec3(s);\n\n    //col += (1.-s) * (0.35 + .65 * v) * vec3(0.5,0.5,1.);\n    vec3 e = vec3(1.);\n    col += (1.-s) * pal(0.43 + 0.15 * v, e, e, e, 0.45 * vec3(0,1,2)/3.);\n    col = clamp(col, 0., 1.);\n    col += s * vec3(fpos, 1.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 52, 52, 144], [146, 146, 180, 180, 545], [547, 547, 594, 594, 943], [945, 945, 976, 1007, 1817], [1819, 1819, 1876, 1876, 2837]]}
{"id": "fdsfWs", "name": "BC: Music Visualizer", "author": "BackwardsCap", "description": "Just for fun", "tags": ["music", "visualizer"], "likes": 3, "viewed": 252, "published": 3, "date": "1645553164", "time_retrieved": "2024-07-30T17:01:56.218675", "image_code": "//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = abs(2.*fragCoord-iResolution.xy)/iResolution.y * .5;\n    uv = vec2(atan(uv.y,uv.x)/10., length(uv));\n    float n = 100.;\n    uv.x = abs(uv.x)-.01;\n    float id = floor((1.0-uv.x)*n);    \n    float t = pow(texture(iChannel0, vec2(1. - id / n, .25)).x,3.);\n    t *= max(t-abs(uv.y),-1.)*10.;    \n    fragColor.rgb = hsv2rgb(2.*vec3(sin(t*uv.x*10.+iTime),\n                                  cos(t*.1+iTime+uv.y/2.-uv.x*50.),\n                                  (1.0+cos(iTime*.1*+uv.x))/2.*t*uv.x*10.));\n    fragColor.rgb *= max(t,0.) * min(max((length(uv.y)-.01)*10.,0.),1.);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 67, 67, 194], [196, 196, 253, 253, 840]]}
{"id": "stdXR2", "name": "sacred waves", "author": "xnio94", "description": "sacred waves", "tags": ["2d", "waves", "formula", "gold"], "likes": 1, "viewed": 243, "published": 3, "date": "1645547040", "time_retrieved": "2024-07-30T17:01:57.102312", "image_code": "#define to 6.28\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    vec2 p = uv + sin((length(uv-.5))*5.5-t);\n    p = p * (sin(length(uv-.5)*to*2. - t*4.)+1.)/2.;\n    float d = (sin(length(uv-.5)*to*5. - t) + 4.)*4. ;\n    float col;\n    col = length(p)/2.+sin(atan(p.y,p.x)*d)*atan(p.y,p.x)/4.;\n    fragColor = vec4(vec3(col,col/3.,0.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 414]]}
{"id": "ssfBWs", "name": "Fractal Freq Music", "author": "eiffie", "description": "Fractal music created by multiplying a short ring of frequencies at different time scales.", "tags": ["fractalmusic"], "likes": 11, "viewed": 459, "published": 3, "date": "1645541993", "time_retrieved": "2024-07-30T17:01:57.991934", "image_code": "#define rez iResolution.xy\n\nvoid mainImage(out vec4 O, in vec2 U){\n O=vec4(0);\n float t=iTime*5.;\n t=mod(t,384.);\n if(t>128.)t-=128.;\n for(float i=0.;i<99.;i+=1.){\n  vec2 d=vec2(13.,117.)+i;\n  vec2 u=U+fract(sin(vec2(dot(U,d),dot(U,d.yx)))*432.29)*i*vec2(.25,.125);\n  vec2 v=(u-.5*rez)/rez*(t>96.?.1+i*.035:1.-i*.035);\n  float t2=iTime+(v.y+v.x)*2.+i*.05;\n  v-=sound(floor(iTime*15.-i*.1)/3.)*.5;\n  vec4 c=abs(vec4(sin(t2),sin(t2+.5),sin(t2+1.5),0.));\n  v=abs(v);\n  O+=c*smoothstep(15./rez.y,0.,max(v.x*.5,v.y))/(i*i*.01+1.);\n }\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n  vec2 v=vec2(0);\n  for(float i=0.;i<3.;i+=1.)v+=sound(time-i*.247)/(1.+i);\n  return v*.05;\n}", "sound_inputs": [], "common_code": "vec2 sound(float time){\n  float N[8]=float[8](1.,1.125,1.25,4./3.,1.5,5./3.,2./3.,1.5);\n  float t=time*5.,w=1.,h=floor(t/128.);\n  t=mod(t,384.);if(t>128.)t-=128.;\n  bool b=mod(t,2.)>1.;\n  if(t>96.){t=96.-t;w=.25+t*0.0075;h=0.;}\n  int s=int(floor(t)+h*128.);\n  int p=16*4;float n=1.,nb,nh;\n  for(int i=0;i<4;i++){n*=N[(s/p)%8];p/=2;}\n  nb=n;\n  n*=N[(s/2)%8];\n  nh=n; \n  n=nh*(b || s==0?N[s%8]:2.01);\n  if(mod(n+.125,.25)-.125>0.05 && mod(n+1./6.,1./3.)-1./6.>0.05)n=0.;\n  vec2 v=vec2(.5)-fract(vec2(n*200.,nb*50.03)*time);\n  v.y*=step(fract(t),.5)*(b?.5:1.25)*w;v.x*=(1.-fract(t));\n  time-=pow(fract(t*.25),100.);\n  time *=2.6667;\n  v+=(vec2(.5)-fract(vec2(nb*(b?75.03:100.02),nh*200.)*time))*.5;\n  return v;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 66, 66, 530]]}
{"id": "7sXBWl", "name": "Lens Dirt Texture [Day 796]  ", "author": "jeyko", "description": "hmm", "tags": ["lens", "bokeh", "camera", "flare", "dirt", "chromab", "mdtmjvm"], "likes": 13, "viewed": 574, "published": 3, "date": "1645536447", "time_retrieved": "2024-07-30T17:01:59.317390", "image_code": "\n// BuffA is just fiddling with some noise to generate a dirt texture\n// BuffB does bokeh with BuffA as input\n\n// Image draws BuffB and attenuates it by a circle.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uvn = (fragCoord)/iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    \n    float param = iTime;\n    vec2 muv = vec2(sin(param),cos(param + sin(iTime + param)))*0.4;\n    \n    if(iMouse.z > 0.){\n        muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    }\n    \n    float sdCirc = length(uv-muv);\n    \n    // sample the lens dirt texture\n    col = texture(iChannel0,uvn).xyz;\n    col *= smoothstep(0.7,0.,sdCirc);\n\n    \n    // draw fake ball\n    col = mix(col,vec3(8)*mix(vec3(1.),col,0.99),smoothstep(0.1,0.,sdCirc - 0.01));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nmat3 orthBasis( vec3 z ) {\n  z = normalize( z );\n  vec3 up = abs( z.y ) > 0.999 ? vec3( 0.0, 0.0, 1.0 ) : vec3( 0.0, 1.0, 0.0 );\n  vec3 x = normalize( cross( up, z ) );\n  vec3 y = cross( z, x );\n  return mat3( x, y, z );\n}\n\n\nvec3 cyclicNoise( vec3 p ) {\n  vec3 sum = vec3( 0.0 );\n  float amp = 0.52;\n  float warp = 0.6;\n  mat3 rot = orthBasis( vec3( 0.5,-.5,.2 ) );\n\n  for ( int i = 0; i < 4; i ++ ) {\n    p *= rot * 2.0;\n    p += sin( p.zxy * warp );\n    sum += sin( cross( cos( p ), sin( p.yzx ) ) ) * amp;\n    amp *= 0.5;\n    warp *= 1.3;\n  }\n\n  return sum;\n}\n\nmat2 _rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a) );\n}\n\nvec4 cyclicNoise( vec4 p ) {\n  vec4 sum = vec4( 0.0 );\n  float amp = 0.5;\n  float warp = 1.1;\n\n  p.xw *= _rot(1.5);\n  p.wy *= _rot(.9);\n\n  for ( int i = 0; i < 5; i ++ ) {\n\n    p += sin( p.wzxy * warp );\n    sum += sin( dot( cos( p ), sin( p.yzwx ) ) ) * amp;\n    amp *= 0.5;\n    warp *= 1.3;\n    p.xz *= _rot(0.9);\n    p.xy *= _rot(4.9);\n  }\n\n  return sum;\n}\n\n\nvec3 getNoise(vec2 uv){\n    vec3 col = vec3(0);\n    vec3 na = cyclicNoise(vec3(uv + 20.,5.));\n    \n    \n    vec3 n = cyclicNoise(\n        vec3(\n            uv*10. + na.xy*4.,\n            cyclicNoise(vec3(uv,1.)).x*4.\n        )\n    );\n    vec3 nb = cyclicNoise(\n        vec3(\n            uv*2. - n.xy*1.,\n            cyclicNoise(vec3(n.xy,n)).x*-.2  - 10.\n        )\n    );\n    \n    vec3 nc = cyclicNoise(\n        vec3(\n            uv*22. - n.xy*1. + nb.xz*1.,\n            n.y*1. + nb.x - n.x\n        )\n    );\n    \n    vec3 nd = cyclicNoise(\n        vec3(\n            n.xy*2. + nc.xz*0.6,\n            nc.y + 5.\n        )\n    );\n    vec3 ne = cyclicNoise(\n        vec3(\n            nd.xy*2. + uv.xy,\n            nd.x*1. + 441.\n        )\n    );\n    //ne = max(ne,0.8);\n    \n    n *= nb*7.*dot(nc,vec3(0.2 - nd.x,1. - nd.y,0.1))*nd*ne*3.;\n    \n    n = dot(n,vec3(0.23,1,0.5))*vec3(1.);\n    \n    n = max(n,0.);\n    \n    n = n/(1.+n);\n    \n    n = pow(n,vec3(4.1))*55.;\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n\n    \n    col += getNoise(uv);\n\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// dave hoskins hash\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// iq hsv2rgbsmooth\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //uv * 1.5;\n    vec2 uvn = (fragCoord)/iResolution.xy;\n    \n    //uvn += normalize(uv)*dot(uv,uv)*0.06;\n    vec3 col = vec3(0);\n    \n    float iters = 1000.;\n    float ratio = iResolution.x/iResolution.y;\n        \n        \n    if(iFrame > 20) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    } else {\n\n        for(float i = 0.; i < iters; i++){\n\n            vec3 r = hash33(vec3(uv*445. + 1150.,i));\n            r.x = i/iters;\n            //r.y = 1.-i/iters;\n            float eta = 1./(mix(1.15,1.25,r.z));\n\n            vec3 c = hsv2rgbSmooth( vec3(r.z*1.,1,1) );\n\n            vec2 offs = vec2(sin(r.x*3.14*2.),cos(r.x*3.14*2.));\n            offs *= pow(sqrt(r.y),0.9)*(1.+0.1*r.y*dot(uv,uv) - 0.3*dot(offs,normalize(uv)));\n\n            if(ratio > 1.){\n                offs.y *= ratio;\n            } else {\n                offs.x *= ratio; // ?\n            }\n\n            col += texture(iChannel0,uvn - normalize(uv)*0.03*r.z*dot(uv,uv) + offs*0.03).xyz/iters*c*5.;\n        }\n\n        col+= clamp(texture(iChannel0,uvn ).xyz,0.,0.4)*0.1;\n\n        fragColor = vec4(col,1.0);\n    }\n\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXBWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 223, 223, 860]]}
{"id": "NdXfWs", "name": "vector glyph by even-odd", "author": "swiftcoder", "description": "Directly rasterise font glyphs from a list of quadratic bezier segments, by casting horizontal rays and counting the intersections (i.e. the even-odd rule).", "tags": ["bezier", "font", "quadratic", "glyph"], "likes": 6, "viewed": 270, "published": 3, "date": "1645534457", "time_retrieved": "2024-07-30T17:02:00.128222", "image_code": "// directly rasterise font glyphs from a list of quadratic bezier segments\n\n// bezier segments are stored as 2d vecs packed in to pairs of vec3,\n// i.e. segemnt a->b->c is stored as vec3(a.x, a.y, b.x), vec3(b.y, c.x, c.y).\n//\n// segments are preprocessed on the CPU to each be monotonically decreasing\n// along the y-axis.\nconst vec3 letter_e[] = vec3[] (\n    vec3(0.8253138,0.08301527,0.70711297), vec3(0,0.50627613,0),\n    vec3(0.30230126,0.035305344,0.39539748), vec3(0,0.50627613,0),\n    vec3(0.14225942,0.13549618,0.20920502), vec3(0.07061069,0.30230126,0.035305344),\n    vec3(0.9874477,0.2977099,0.94351465), vec3(0.16603054,0.8253138,0.08301527),\n    vec3(0.037656903,0.29007635,0.07531381), vec3(0.20038168,0.14225942,0.13549618),\n    vec3(0.25941423,0.22709924,0.3493724), vec3(0.14122137,0.51046026,0.14122137),\n    vec3(0.6380753,0.15648855,0.583682), vec3(0.14122137,0.51046026,0.14122137),\n    vec3(0.73117155,0.19847329,0.69246864), vec3(0.17175573,0.6380753,0.15648855),\n    vec3(0.79393303,0.26049617,0.76987445), vec3(0.22519083,0.73117155,0.19847329),\n    vec3(0.16317992,0.45419848,0.16945606), vec3(0.3129771,0.25941423,0.22709924),\n    vec3(0.832636,0.33587787,0.8179916), vec3(0.29580152,0.79393303,0.26049617),\n    vec3(0,0.48854962,0), vec3(0.379771,0.037656903,0.29007635),\n    vec3(0.832636,0.33587787,0.91004187), vec3(0.3167939,0.9874477,0.2977099),\n    vec3(1,0.5763359,1), vec3(0.5152672,1,0.45419848),\n    vec3(1,0.45419848,0.58158994), vec3(0.45419848,0.16317992,0.45419848),\n    vec3(0,0.53435117,0), vec3(0.5114504,0,0.48854962),\n    vec3(0.038702928,0.7194657,0), vec3(0.6335878,0,0.53435117),\n    vec3(0.9717573,0.71374047,1), vec3(0.639313,1,0.5763359),\n    vec3(0.8043933,0.70229006,0.832636), vec3(0.65267175,0.83682007,0.59160304),\n    vec3(0.16736402,0.59160304,0.50209206), vec3(0.59160304,0.83682007,0.59160304),\n    vec3(0.2039749,0.69751906,0.17573221), vec3(0.648855,0.16736402,0.59160304),\n    vec3(0.27719665,0.78244275,0.23221758), vec3(0.7461832,0.2039749,0.69751906),\n    vec3(0.73117155,0.78625953,0.77615064), vec3(0.7519084,0.8043933,0.70229006),\n    vec3(0.8838912,0.851145,0.94351465), vec3(0.78816795,0.9717573,0.71374047),\n    vec3(0.14644352,0.86736643,0.077405855), vec3(0.8053435,0.038702928,0.7194657),\n    vec3(0.38179916,0.83874047,0.32217574), vec3(0.8187023,0.27719665,0.78244275),\n    vec3(0.6286611,0.8396947,0.68619245), vec3(0.8206107,0.73117155,0.78625953),\n    vec3(0.51046026,0.85877866,0.44142258), vec3(0.85877866,0.38179916,0.83874047),\n    vec3(0.51046026,0.85877866,0.5711297), vec3(0.85877866,0.6286611,0.8396947),\n    vec3(0.73117155,0.95706105,0.8242678), vec3(0.91412216,0.8838912,0.851145),\n    vec3(0.30857742,0.9646947,0.21548118), vec3(0.9293893,0.14644352,0.86736643),\n    vec3(0.51046026,1,0.6380753), vec3(1,0.73117155,0.95706105),\n    vec3(0.51046026,1,0.40167364), vec3(1,0.30857742,0.9646947)\n);\n\n// evaluate only the x coordinate of the bezier specified by the control points\nfloat eval_bezier_x(float t, vec2 p1, vec2 p2, vec2 p3) {\n    float s = 1.0 - t;\n    return s * s * p1.x + 2.0 * s * t * p2.x + t * t * p3.x;\n}\n\n// returns the x coordinate of the intersection beteen a horizontal line at y=b, and the\n// bezier specified by the control points, or a very negative value if no intersection.\nfloat bezier_intersect_horizontal_line(float b, vec2 p1, vec2 p2, vec2 p3) {\n    // bezier is entirely above or below the line, no intersection\n    if (min(p1.y, p3.y) > b || max(p1.y, p3.y) < b) {\n        return -1000.0;\n    }\n    \n    // find the intersection by solving for t in the standard bezier equation\n    // https://www.wolframalpha.com/input?i=b+%3D+%281-t%29%5E2*p1%2B+2*t*%281-t%29*p2+%2B+t%5E2*p3+solve+t\n    \n    // we need to precalculate the denominator to avoid a divide by zero\n    float a = p1.y - 2.0*p2.y + p3.y;\n\n    // bezier is a straight line, so we can calculate the intersection directly\n    if (abs(a) < 0.0002) {\n        float t = (b - p1.y) / (p3.y - p1.y);\n        return p1.x + t * (p3.x - p1.x);\n    }\n\n    // now solve for t\n    float t = (p1.y - p2.y - sqrt(b*a + p2.y*p2.y - p1.y*p3.y)) / a;\n    \n    // finally feed t back into the bezier equation to find our x\n    return eval_bezier_x(t, p1, p2, p3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = uv * 1.2 - 0.1;\n    \n    float intersections = 0.0;\n    for (int i = 0; i < 66; i+=2)\n    {\n        vec3 dataA = letter_e[i + 0];\n        vec3 dataB = letter_e[i + 1];\n        \n        // unpack the bezier control points\n        vec2 p1 = dataA.xy;\n        vec2 p2 = vec2(dataA.z, dataB.x);\n        vec2 p3 = dataB.yz;\n\n        // cast a line rightward from our point, if it intersects bump the counter \n        if (bezier_intersect_horizontal_line(uv.y, p1, p2, p3) >= uv.x) {\n            intersections += 1.0;\n        }\n    }\n\n    // point is inside the glyph everywhere the intersection count is odd\n    float inside = mod(intersections, 2.0);\n    \n    fragColor = vec4(vec3(inside), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2890, 2970, 3027, 3027, 3113], [3115, 3292, 3368, 3435, 4234], [4236, 4236, 4293, 4293, 5078]]}
{"id": "NdfBDs", "name": "gyroid lamp", "author": "drschizzo", "description": "simple experiment based on a video from https://www.youtube.com/c/TheArtofCodeIsCool/videos", "tags": ["raymarching", "shadow", "volumetric"], "likes": 20, "viewed": 533, "published": 3, "date": "1645533034", "time_retrieved": "2024-07-30T17:02:01.086660", "image_code": "#define T iTime\n\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat gyro(vec3 p){\n    float size=10.*(.8+.6*sin(T/2.47+1.6));\n    p.xz*=mat2(cos(T),sin(T),-sin(T),cos(T));\n     p.yz*=mat2(cos(T),sin(T),-sin(T),cos(T));\n    p*=size;\n    //return abs(.5*dot(sin(p+T),cos(p.yzx-T/2.))/size)-.03;\n    return abs(.5*dot(sin(p),cos(p.yzx))/size)-.02;\n}\n\nbool isgyro=true;\n\nfloat map(vec3 p){\n\n    float d=p.y+1.1;//+length(p.xz)/5.;\n    float c2=abs(length(p)-1.)-.05;\n    c2=opSmoothIntersection(c2,gyro(p),.02);\n    \n    d=abs(length(p)-6.)-.1;\n    if(d<c2-.5)\n        isgyro=false;\n   //d=length(p)-5.;\n    return min(d,c2);\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(0,.001);\n    float a=map(p);\n    return(normalize(a-vec3(map(p-e.yxx),\n                          map(p-e.xyx),\n                          map(p-e.xxy))));\n}\n\n\n\n\nmat3 cam(vec3 ro, vec3 lp) {\n\tvec3 cd = normalize(lp - ro); \n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); \n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 normalmap(vec2 p){\n    float v=texture(iChannel1,p).r;\n    float vx=v-texture(iChannel1,p-vec2(0.001,0)).r;\n    float vy=v-texture(iChannel1,p-vec2(0.,0.001)).r;\n    return normalize(vec3(vx,0.,vy));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 ro=vec3(0.,1.,3.);\n    \n    //ro.xz*=mat2(cos(T),sin(T),-sin(T),cos(T));\n    vec3 rd=normalize(cam(ro,vec3(0.,0.,0.))*normalize(vec3(uv,-1)));\n    float dt=0.;\n    for(float i=0.;i<200.;i++){\n        float d=map(ro+dt*rd);\n        dt+=d;\n        if(d<.001 || d > 200.)\n            break;\n    }\n    float dust=0.;\n    vec3 pos=ro;\n    \n    //there must be a better solution...\n    for(float i=0.;i<20.;i++){\n          float s=gyro(normalize(pos));\n          \n           s*=50.*smoothstep(.8,1.,length(pos));\n           s=clamp(0.,1.,s);\n            dust+=s*(1./max(1.,(length(pos))));\n            dust+=pow(smoothstep(.4,.001,length(pos))*10.,3.);\n        pos+=rd;\n    }\n    if(dt<200.){\n    vec3 lpos=vec3(0,0,0);\n    \n        vec3 p=ro+dt*rd;\n        if(!isgyro){\n                    vec3 n=normal(p);\n            float s=gyro(normalize(-p));\n            float w=.04*length(p/3.);\n            s=smoothstep(-w,w*2.,s)*.3;\n            float diff=dot(n,normalize(lpos-p));\n            vec3 r=vec3(1.);//texture(iChannel0,normalize(reflect(rd,n))).xyz;\n            //fragColor=vec4(r*s/(dt),1.);\n            fragColor=vec4((vec3(.4,.8,.9)*diff*s),1.);\n        }\n        else{\n        \n        vec3 n=normal(p);\n        float diff=dot(n,normalize(lpos-p));\n        vec3 colext=vec3(.2,.3,.9)*texture(iChannel0,normalize(reflect((rd),n))).xyz*.2;\n        \n        vec3 colint=vec3(.95,.2,.1)*clamp((diff),.0,1.);\n        if(diff<0.){\n                    //dust=0.;\n\n            }\n            dust=dust*smoothstep(-.4,.4,diff);\n           fragColor=vec4(mix(colext,colint,smoothstep(-.2,.2,diff)),1.);\n        }\n    }\n      else      fragColor = vec4(vec3(0.),1.0);\n    \n   // fragColor*=4.;\n    fragColor=pow((fragColor+vec4(dust*.05)*vec4(.9,.7,.7,1.)),vec4(.45));\n\n //   fragColor=vec4(dust/10.);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 77, 77, 176], [179, 179, 198, 198, 463], [484, 484, 502, 502, 740], [742, 742, 762, 762, 934], [939, 939, 967, 967, 1117], [1119, 1119, 1142, 1142, 1330], [1332, 1332, 1389, 1389, 3310]]}
{"id": "NdfBDl", "name": "Hypnosis - Basic Spiral Fade", "author": "jackakers13", "description": "Created by Jack Akers on February 22, 2022.\nMade available under the CC0 license - https://creativecommons.org/publicdomain/zero/1.0/", "tags": ["basic", "spiral", "fade", "hypnosis"], "likes": 6, "viewed": 277, "published": 3, "date": "1645524718", "time_retrieved": "2024-07-30T17:02:02.151812", "image_code": "// Created by Jack Akers on February 22, 2022.\n// Made available under the CC0 license - https://creativecommons.org/publicdomain/zero/1.0/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    // Spiral\n    vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    float dist = distance(center, fragCoord);\n    float angle = atan(fragCoord.y - iResolution.y/2.0, fragCoord.x - iResolution.x/2.0);\n    float col = cos(0.25 * dist + angle + 4.0 * iTime);\n    \n    // Fade\n    float distToEdge = distance(center, vec2(iResolution.x/2.0, iResolution.y));\n    float percentDistToEdge = clamp(dist / distToEdge, 0.0, 1.0);\n    col = mix(0.0, col, 1.0 - percentDistToEdge);\n    \n    // Return\n    fragColor = vec4(vec3(col), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfBDl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[0, 140, 195, 214, 746]]}
{"id": "7dsfDX", "name": "Alien biology", "author": "jarble", "description": "Some vaguely biological-looking fractal structures.", "tags": ["fractal", "cell"], "likes": 11, "viewed": 314, "published": 3, "date": "1645506961", "time_retrieved": "2024-07-30T17:02:02.993561", "image_code": "//change these constants to get different patterns!\n#define iterations 3\n#define modulo 3\n\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);   \n    for(int k = 0; k < 6*iterations; k++){\n    uv -= (t2.yx)/(scale)+float(k%modulo);\n    //uv -= t3.yx/(8.);\n    t2 = triangle_wave(uv.yx-.5,scale);\n    t3 = -triangle_wave(uv,scale);\n    //t3 /= float(1+k%3);\n    uv.yx = -(t2+t3)/scale;\n    col.x = 1.-abs(-uv.y+uv.x+col.x);\n    col = col.yzx;\n    uv /= scale*scale;\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 160, 160, 205], [207, 207, 264, 264, 860]]}
{"id": "7dlfzf", "name": "Electro-giant", "author": "El_Sargo", "description": "Animated e-giant from clash royal! Sorry about the slow compile time, if you know how to reduce it please let me know.\n\nInspired by https://www.youtube.com/watch?v=ol_od46644k", "tags": ["3d", "raymarching", "character"], "likes": 13, "viewed": 271, "published": 3, "date": "1645505286", "time_retrieved": "2024-07-30T17:02:04.128527", "image_code": "#define WALKSPEED 4.\n#define color\n#define sdTest sdGiant\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 a = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.yx );\n\treturn (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n}\n\nvec3 opElongate(in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return q;\n}\n\n\nvec3 opCheapBend( in vec3 p, float k)\n{\n\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, float t, float r )\n{\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)-t;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opSymX( in vec3 p)\n{\n    p.x = abs(p.x);\n    return p;\n}\nvec3 opSymZ( in vec3 p)\n{\n    p.z = abs(p.z);\n    return p;\n}\n\nvec3 opSymXY(vec3 p){\n    p.xy = abs(p.xy);\n    return p;\n}\n\nfloat sdXCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-0.5;\n}\n\nfloat sdBBox(vec3 p, vec3 b){\n    float d = sdBox(p.xz, b.xz);\n    vec2 w = vec2( d, abs(p.y) - b.y );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdRoundBox( in vec3 p, in float h )\n{\n    float d = sdRoundedBox(p.xy, vec2(0.35,0.08), vec4(0.05,0.15,0.05,0.1));\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdTriPrisim( in vec3 p, in float h )\n{\n    float d = sdEquilateralTriangle(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat pow4(float v){\n    return v*v*v*v;\n   }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sdBeardSpine(vec3 p, float s){\n    p*=s;\n    return min(opSmoothSubtraction(sdSphere(p-vec3(0,-8.90,1.6), 10.),\n                                sdTriPrisim(p-vec3(0,sin(p.z)*0.9,1.), 1.),\n                                0.4)/s,\n                                1.);\n}\n\nfloat sdBeltBuckle(vec3 p){\n    return sdHexPrism(p-vec3(0, -1.5, -1.), vec2(.35,.1));\n}\n\nfloat sdBelt(vec3 p){\n    return min(\n                sdTorus(opElongate(p-vec3(0, -1.5, 0), vec3(1., 0.2, 0.1)), 0.1, .6),\n                sdBeltBuckle(p)\n                );\n}\n\nvec3 repeat4y(vec3 p){\n    const float l = 2.;\n    const float c = 0.3;\n    float q = p.y-c*clamp(round(p.y/c),-l,l);\n    return vec3(p.x, q, p.z);\n}\n\nfloat sdBeard(vec3 p){\n    vec3 q = opSymX(p)-vec3(.6,-1.4,-.4);\n    vec3 w = opSymX(p)-vec3(1.5,-1.2,-.4);\n    vec3 z = opSymX(p)-vec3(1.15,-0.5,-.0);\n    return min(min(\n                    sdBeardSpine(q*rotz(-0.1*3.14)*roty(.1*3.14)*rotx(.3*3.14),2.3),\n                    sdBeardSpine(w*rotz(-0.2*3.14)*roty(.3*3.14)*rotx(.2*3.14),2.)),\n                    sdBeardSpine(z*roty(0.3*3.14)*rotz(-0.25*3.14)*rotx(.2 * 3.14),4.) \n                );\n}\n\nfloat sdMouthCavity(vec3 p){\n\n    return sdRoundBox(p-vec3(0,-0.4,-0.4), .5);\n}\n\nfloat sdCoil(vec3 p){\n    return sdTorus(opElongate(repeat4y(p-vec3(1.7,-0.7,0)), vec3(0.1,0.,.8)), 0.2, 0.5);\n}\n\nfloat sdPlate(vec3 p){\n    p-=vec3(0,0.1,-0.085);\n    p*=roty(0.5*3.141);\n    vec3 symP = opSymZ(p);\n    return  min(\n                smin(\n                    max(\n                        -sdHexPrism((p-vec3(0.,-0.2,.20)),vec2(1.2, 2.7))+0.2,\n                        max(\n                            max(\n                                -sdHexPrism(opElongate(p*rotx(0.5*3.141)+vec3(0.3,0,0.1), vec3(0.,0.4,0)), vec2(0.4,2.7))+0.2,\n                                sdHexPrism(p,vec2(1.2, 2.7))-0.1),\n                            sdHexPrism(p*rotx(0.5*3.141),vec2(1.5, 1.8))-0.1\n                            )\n                        ),\n                    min(sdCapsule(symP, vec3(0.5,0,0.5), vec3(0.9,1.4,.9)*1.5, 0.12),\n                        sdSphere(symP-vec3(0.9,1.4,.9)*1.4, 0.54)\n                        ),\n                    0.02),\n                    min(\n                        max(-sdBox(p-vec3(1.7,-0.7,0), vec3(.9,0.7,1.9)),\n                            sdBBox(p-vec3(1.7,-0.7,0), vec3(.3,1,1.1))),\n                        sdCoil(p))\n                    );\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBand(vec3 p){\n    return sdTorus(opElongate((p-vec3(0,0.16,0))*rotx(0.1), vec3(0.1,0.047,0.1)), 0.05, 0.62);\n}\n\nfloat sdTeeth(vec3 p){\n return sdTorus(p-vec3(0,-0.4,-0.25+sin(p.x*40.)*0.01), .11,.3);\n}\n\nfloat sdLens(vec3 p){\n    return sdCappedCylinder(p, 0.29, 0.35);\n}\n\nfloat sdRim(vec3 p){\n    p = opSymX(p);\n    p-=vec3(0.43,0.05,-0.4);\n    p*=rotx(1.44);\n    return min(\n                max(-sdCappedCylinder(p, 0.2, 10.),sdCappedCylinder(p, 0.29, 0.35)-0.03),\n                sdLens(p)\n               );\n}\n\nfloat sdGoggles(vec3 p){\n    return min(sdBand(p),\n               sdRim(p));\n}\n\nfloat sdNose(vec3 p){\n       p -= vec3(0,-.2,-.7);\n       return opSmoothSubtraction(sdSphere(opSymX(p)-vec3(0.3,-0.3,-0.1), 0.33),\n                                   sdRoundCone(p, 0.2, 0.07, 0.2),\n                                   0.1);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\nfloat gloveRing(vec3 p, float h, float r){\n    float d = sdHexagram(p.xy, r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.1;\n}\nfloat sdGlove(vec3 p){\n    p -= vec3(.15, -2.2, -2.2);\n    p *= 3.;\n    return smin(\n                smin(\n                    smin(\n                        smin(\n                            sdTorus(repeat4y(opElongate(p, vec3(0.1,0,0.1))), 0.28, 0.4),\n                            sdBox(p-vec3(0.2,0.1,1.0),vec3(0.1, .3, 0.6))-0.5,\n                            0.5),\n                        sdCapsule(p, vec3(-0.9,.5,0.), vec3(-0.8,-.5,0.), 0.5),\n                        0.01),\n                    sdCapsule(p, vec3(-0.5,.8,1.), vec3(-0.9,.5,0.), 0.5),0.6),\n                 gloveRing(p-vec3(0,0,2.6), .2, 1.),\n                 0.2) / 3.;\n                \n}\n\nfloat sdShoulder(vec3 p){\n    p = opSymX(p)-vec3(2.,0.6,0);\n    return sdEllipsoid(p,vec3(0.9, 0.8, 0.7));\n}\n\nfloat sdArm(vec3 p){\n    float x = p.x;\n    p = opSymX(p)-vec3(2.,0.6,0);\n    p*= roty(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotz(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotx(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25);\n    return min(min(\n                smin(\n                    sdEllipsoid(p-vec3(0,-0.8,-0.1),vec3(0.5, 0.8, 0.6)),\n                    sdEllipsoid((p-vec3(0.1,-2.,-1.1))*rotx(0.2*3.14), vec3(0.5,0.4,.6)),\n                    0.3),\n                 sdGlove(p)\n               ),2.1);\n               //Quick hack to prevent the ray from overshooting when evaluating the other side\n               //Since the left arm is just a mirror of the right if x>0 then the ray will get the\n               //distance for the right arm and could over shoot the left one.\n               //Clamping the distance to a max of 2 will prevent this overshooting\n}\n\nfloat sdHead(vec3 p){\n    p-=vec3(0,1.8,-0.5);\n    vec3 q = vec3(p.x, p.y+cos(p.x*4.)*0.07-0.05+p.y*p.y*0.1, p.z-0.03);\n    float bound = sdSphere(q, 1.);\n    if (bound < 1.) {\n    return smin(\n                smin(\n                    min(sdTeeth(q),\n                        opSmoothSubtraction(\n                                            sdMouthCavity(q),\n                                            min(\n                                                smin(\n                                                        smin(sdSphere(p, 0.57),sdBox(p, vec3(0.3)),0.2),\n                                                        min(sdBox((p-vec3(0,-0.1,0))*rotx(0.88), vec3(0.25,0.1, 0.8)),\n                                                            sdBox((p-vec3(0,0,-0.2))*rotx(0.3), vec3(0.5,0.0, 0.52))\n                                                            ),\n                                                        0.04\n                                                    ),\n                                                sdGoggles(p)\n                                                ),\n                                             0.02\n                                            )\n                        ),\n                        sdNose(p), \n                        0.0\n                        ),\n                   sdBeard(p),\n                   0.005\n                 );\n                } else \n                    return bound;\n}\n\nfloat sdLegs(vec3 p, float leftOrRight){\n    p *= rotx(cos(iTime*WALKSPEED)*0.2*leftOrRight+0.5);\n    return min(\n                smin(\n                    sdCapsule(p, vec3(0), vec3(0., -1., 0), 0.5),\n                    sdBox((p-vec3(0., -1.4, .8)*rotx(.25*3.14))+vec3(0,sin((p.z-1.5)*2.)*0.1,0), vec3(0.3, -0.2, 0.5))-0.2,\n                    0.1),\n                .5);\n    }\n\nfloat sdPants(vec3 p){\n    vec3 q = opSymX(p)-vec3(.8, -2., 0);\n    vec3 knee = vec3(0.1, -0.7, 0);\n    q *= rotx(sin(iTime*WALKSPEED)*-0.5*p.x/abs(p.x)-0.5);\n   return  smin(\n               smin(sdSphere(p-vec3(0,-2.,0), 0.5),\n                    sdCapsule(\n                                q, \n                                vec3(0), \n                                knee,\n                                0.6), \n                    0.2),\n                sdLegs(q-knee, p.x/abs(p.x)),\n                0.1);\n}\n\nfloat sdGiant(vec3 p){\n    p.y += abs(cos(iTime*WALKSPEED))*0.1;\n    //Adding this bounding volume resulted in 5x fps and 0.25x compile time on my computer\n    float bound = sdBox(p, vec3(4,4.5,3.5));\n    if (bound < 1.){\n        vec3 h = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        p*=roty(sin(iTime*WALKSPEED)*-0.051);\n        vec3 q = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n\n        return min(\n                    min(\n                        smin(\n                            min(\n                                smin(\n                                     smin(\n                                         sdBox(q-vec3(0,0.5,0)  ,vec3(1.,.2,0.3))-0.25,\n                                         sdBox(q-vec3(0,-0.35,0),vec3(1.,0.7,0.15))-0.25,\n                                         0.75\n                                         ),\n                                      sdPants(p),\n                                      0.1\n                                     ),\n                                min(\n                                    sdArm(q),\n                                    sdPlate(q)\n                                    )\n                                ),\n                             sdShoulder(q),\n                             0.1\n                            ),\n                        sdHead(h)),\n                        sdBelt(p)\n                        );\n    } else\n        return bound;\n                \n                \n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y - h;\n}\n\nfloat sdGround(vec3 p){\n    return sdPlane(p, -4.5);\n}\n\nfloat sdScene(vec3 p){\n    return min(sdGiant(p), sdGround(p));\n}\n\nfloat pow2(float v){\n    return v*v;\n}\n\n// IQ's normal function.\nvec3 calcNormal(vec3 p){ \n    \n    vec3 e = vec3(.001, 0, 0);\n    \n    vec3 n = vec3(0.0);\n    for( int i = min(iFrame, 0); i<4; i++ )\n    {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*sdScene(p + .001*e);\n    }\n    \n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdGiant(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return 1.-pow4(1.-res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 im = iMouse / iResolution.xyxy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, .4));\n    //rd *= rotx(0.0);\n    vec3 ro = vec3(0,1,-10);\n    vec3 LD = vec3(-0.4,1,-.3);\n    mat3 xr = rotx(.5);\n    mat3 yr = roty((-im.x)*3.14*-2.);\n    ro*=xr*yr;\n    rd*=xr*yr;\n    vec3 rp = ro;\n    \n    //March\n    float dist;\n    for (int i=0;i<60;i++){\n        dist = sdScene(rp);\n        if (10. < dist ^^ dist < 0.01)\n            break;\n        else\n            rp += rd*dist;\n    }\n    vec3 normal = calcNormal(rp);\n    //Colors\n    vec3 background = texture(iChannel0, rd).zyx;\n    vec3 refBackground = texture(iChannel0, reflect(rd, normal)).zyx;\n    vec3 col;\n    float ref = 0.05;\n   \n    //Coloring\n    #ifndef color\n    if (sdScene(rp) < 0.1){\n        col = vec3(0.9);\n        float shadow = softshadow(rp, LD, 1., 5., 1.);\n         col = col *shadow * dot(LD, normal)\n               + col * vec3(0.7, 0.8, 0.9) * 0.1;\n    } else {\n        float groundDist = plaIntersect(ro, rd, vec4(1,0,0,0));\n        vec2 gp = (rd*groundDist).xz;\n        vec2 grid = mod(gp, vec2(gridSize));\n        if (rd.y < 0.){\n            if ((grid.x < gridSize/2.) || (grid.y < gridSize/.2))\n                col = vec3(0.2);\n            else\n                col = vec3(0.4);\n        } else\n            col = background;\n    }\n            \n        col = background;\n    #else\n    if (sdGiant(rp) < 0.01){\n        rp.y += abs(cos(iTime*WALKSPEED))*0.1;\n        col = vec3(250,219,172)/256.;\n        //Giant rotations\n        vec3 p = rp*roty(sin(iTime*WALKSPEED)*-0.051);\n        vec3 h = rp*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        vec3 q = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        //Belt coloring\n        float belt = sdBelt(p);\n        float head = sdHead(h);\n        float plate = sdPlate(q);\n        float pants = sdPants(p);\n        //Arm transform\n        float x = q.x;\n        vec3 z = opSymX(q)-vec3(2.,0.6,0);\n        z *= roty(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotz(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotx(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25);\n        float gloves = sdGlove(z);\n        if (belt <0.05){\n            col = mix(col, vec3(138, 51, 36) / 256., clamp(1./belt,0.,1.));\n            float beltBuckle = sdBeltBuckle(p);\n            if (beltBuckle < 0.01)\n                ref = 0.9;\n                col = mix(col, vec3(255,215,0) / 256., clamp(1./beltBuckle,0.,1.));\n        }\n        else if (head < 0.01){\n            //Head transforms\n            h-=vec3(0,1.8,-0.5);\n            float beard = sdBeard(h);\n            float nose = sdNose(h);\n            float teeth = sdTeeth(h);\n            float goggles = sdGoggles(h);\n            if (beard < 0.04)\n                col = mix(col, vec3(240, 74, 0) / 256., clamp(0.04/clamp(beard,10e-10,1.),0.,1.));\n            else if (nose <0.02)\n                col = mix(col, vec3(255,219,172)/350., clamp(0.02/clamp(nose,10e-10,1.),0.,1.));\n            else if (teeth < 0.01)\n                col = mix(col, vec3(1.), clamp(0.01/clamp(teeth,10e-10,1.),0.,1.));\n            else if (goggles < 0.1){\n                \n                float band = sdBand(h);\n                float rims = sdRim(h);\n                if (rims < 0.015){\n                        //Rim color    215\n                        ref = 0.7;\n                        col = mix(col, vec3(255,215,0) / 256., clamp(0.015/rims,0.,1.));\n                        //Rim space distortions\n                        h = opSymX(h);\n                        h-=vec3(0.43,0.05,-0.4);\n                        h*=rotx(1.44);\n                        float lens = sdLens(h);\n                        if (lens < 0.02)\n                            col = mix(col, vec3(135,206,250) / 256., clamp(0.02/clamp(lens,10e-10,1.),0.,1.));\n                }\n                else if (band < 0.1)\n                    col = mix(col, vec3(0.1), clamp(0.1/band, 0.,1.));\n            }\n        }\n        else if (plate < 0.14){\n            p-=vec3(0,0.1,-0.085);\n            p*=roty(0.5*3.141);\n            if (sdCoil(p) < 0.1){\n                ref = 0.7;\n                col = vec3(255,215,0) / 256.;\n            } else {\n                ref = 0.5;\n                col = mix(col, vec3(0.4), clamp(1./plate, 0., 1.));\n            }\n        }\n        else if (pants < 0.1){\n            vec3 l = opSymX(p)-vec3(.8, -2., 0);\n            vec3 knee = vec3(0.1, -0.7, 0);\n            l *= rotx(sin(iTime*WALKSPEED)*-0.5*p.x/abs(p.x)-0.5);\n            float legs = sdLegs(l-knee, p.x/abs(p.x));\n            if (legs > 0.1)\n                col = mix(col, vec3(0.1, 0.1, 0.9), clamp(1./pants, 0., 1.));\n        }\n        else if (gloves < 0.1){\n            col = mix(col, vec3(138, 51, 36)/256., clamp(1./gloves, 0., 1.));\n        }\n    float shadow = clamp(0.5+softshadow(rp, LD, 1., 5., 1.), 0., 1.)*0.5;\n     col = col *shadow*2. * (0.25*dot(LD, normal)+0.75)\n           + col * vec3(0.7, 0.8, 0.9) * 0.1;\n       col = mix(col, refBackground, ref * clamp(shadow*2.,0.,1.));\n    } else if (rd.y < 0.){\n        float shadow = softshadow(rp, LD, 1., 5., 1.);\n        float g = texture(iChannel2, rp.xz*0.05+ vec2(0, -0.05*iTime*WALKSPEED)).x;\n        col = clamp(shadow, 0.2, 0.3) * vec3(g);\n    } else {\n        \n        col = background;\n    }\n    #endif\n    \n    //Lighting\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28281, "src": "https://soundcloud.com/direalshaggy/boombastic?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 78, 78, 205], [206, 206, 226, 226, 353], [354, 354, 374, 374, 501], [503, 503, 544, 544, 605], [607, 607, 639, 639, 667], [670, 670, 723, 723, 782], [784, 784, 837, 837, 1006], [1008, 1008, 1048, 1048, 1100], [1103, 1103, 1142, 1142, 1273], [1274, 1274, 1305, 1305, 1392], [1394, 1394, 1437, 1437, 1498], [1499, 1499, 1535, 1535, 1808], [1810, 1810, 1853, 1853, 1952], [1954, 1954, 1979, 1979, 2015], [2016, 2016, 2041, 2041, 2077], [2079, 2079, 2100, 2100, 2138], [2140, 2140, 2186, 2186, 2245], [2247, 2247, 2299, 2299, 2406], [2408, 2408, 2445, 2445, 2528], [2530, 2530, 2582, 2582, 2703], [2705, 2705, 2760, 2760, 2917], [2919, 2919, 2961, 2961, 3172], [3175, 3175, 3212, 3212, 3296], [3298, 3298, 3327, 3327, 3457], [3459, 3459, 3502, 3502, 3674], [3676, 3676, 3720, 3720, 3858], [3860, 3860, 3880, 3880, 3905], [3907, 3907, 3965, 3965, 4065], [4071, 4071, 4107, 4107, 4343], [4345, 4345, 4372, 4372, 4433], [4435, 4435, 4456, 4456, 4611], [4613, 4613, 4635, 4635, 4762], [4764, 4764, 4786, 4786, 5214], [5216, 5216, 5244, 5244, 5295], [5297, 5297, 5318, 5318, 5409], [5411, 5411, 5433, 5433, 6482], [6484, 6484, 6542, 6604, 6883], [6885, 6885, 6906, 6906, 7003], [7005, 7005, 7027, 7027, 7094], [7096, 7096, 7117, 7117, 7163], [7165, 7165, 7185, 7185, 7404], [7406, 7406, 7430, 7430, 7484], [7486, 7486, 7507, 7507, 7727], [7729, 7729, 7772, 7772, 8013], [8014, 8014, 8056, 8056, 8190], [8191, 8191, 8213, 8213, 8847], [8849, 8849, 8874, 8874, 8957], [8959, 8959, 8979, 8979, 9819], [9821, 9821, 9842, 9842, 11264], [11266, 11266, 11306, 11306, 11644], [11646, 11646, 11668, 11668, 12155], [12157, 12157, 12179, 12179, 13599], [13601, 13601, 13658, 13658, 13707], [13709, 13709, 13740, 13740, 13762], [13764, 13764, 13787, 13787, 13818], [13820, 13820, 13842, 13842, 13885], [13887, 13887, 13907, 13907, 13925], [13927, 13952, 13976, 13976, 14239], [14242, 14242, 14319, 14319, 14548]]}
{"id": "NdlfWf", "name": "Column Thingy 2", "author": "SnoopethDuckDuck", "description": "click to move\n\ntrying a few techniques - they dont gel that well together but its ok", "tags": ["e"], "likes": 22, "viewed": 336, "published": 3, "date": "1645497482", "time_retrieved": "2024-07-30T17:02:04.996207", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n   \n    float sd = sdBox(p, vec3(4.)) - 2.;\n    \n    vec2 uv = p.xz;\n    //float sc = 3.;\n   // uv = floor(sc * uv)/sc + 0.5;\n\n    uv *= Rot(0.1 * p.y);\n   // uv.x = abs(uv.x) - 1.5;\n   \n    float tim = 0.1 * p.y + iTime;\n   \n    float ext = 4.2 + 0.1 * thc(4., tim) * thc(4., 4. * p.y);\n    vec2 id = vec2(step(uv.x,0.), step(uv.y,0.));\n    uv = sabs(uv) - ext;\n   // uv *= Rot(pi/4.);\n   // uv.x = sabs(uv.x) - sqrt(ext) * sqrt(3./2.);\n   \n    float time = 0. * p.y + iTime + cos(tim);\n    vec2 v = vec2(cos(time), sin(time));\n    float d = sdSegment(uv, -2. * v, 2. * v) - 1.;\n    d *= 0.6;\n    return d;//-smin(d, -sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -20);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n           \n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n        \n        \n        vec2 uv = p.xz;\n        uv *= Rot(0.1 * p.y);\n        vec2 id = vec2(step(uv.x,0.), step(uv.y,0.)) - 0.5;\n        float ido = pi * id.x * id.y;\n        float hid = pi * h21(id) ;\n        \n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 e = vec3(1);\n        \n        float in1 = dif * 0.3 + 0.25 + 0.1 * thc(4., hid + 0.05 * p.y + iTime);\n        \n        // removed this, was causing artifacts (was thc(10.,) instead of cos)\n        //in1 += thc(6., ido -0.05 * p.y + 0.1 * iTime + floor(5. * (iTime + 2. * ido + 0.5 * pi * cos(ido + 4. * p.y))) / 5.);\n        \n        vec3 bcol = pal(in1, e, e, e, 0.28 * vec3(0,1,2)/3.);\n       // col = 0.02 * clamp(col, 0., 1.);\n       \n        col = bcol;\n        col *= 0.75 - 0.25 * n.y;\n        \n        // fresnel\n        col += pow(1.+dot(rdIn, nExit), 5.);\n        col += pow(1.+dot(rd, n), 4.);  //5.  //maybe better without this too?   \n        col *= col * vec3(1. + dot(rd, n));\n        \n        col = clamp(col, 0., 1.);\n        col *= 1.- 0.1 * exp(-2. * cos(hid * ido + 5. * length(p.xz) + iTime));\n        \n\n        float k = 0.01;\n        float v = 1. + .5 * step(thc(10., 4. * p.y), 0.5) + 0.5 * thc(80., floor(5. * (hid + 0.1 * p.y + id.x * id.y * iTime))/5. ) + dot(rd,n);\n        float val = smoothstep(-k, k, v);\n       // col += bcol * clamp(mix(0.5, 1. + dot(rd,n), 10000.), 0., 1.);//exp(-2. * p.y));\n        col += bcol * clamp(val, 0., 1.);\n        //col += mix(0., fresnel, 0.5);\n    }\n    \n    col = pow(col, vec3(.4545)) + vec3(0.24, 0.05, 0.09);\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [151, 151, 180, 180, 261], [264, 264, 287, 287, 913], [915, 915, 958, 958, 1192], [1194, 1194, 1218, 1218, 1408], [1410, 1410, 1460, 1460, 1651], [1653, 1653, 1710, 1710, 4025]]}
{"id": "NdsfDf", "name": "Fractal knots 6", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 4, "viewed": 228, "published": 3, "date": "1645496903", "time_retrieved": "2024-07-30T17:02:05.961625", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n\n    vec2 t2 = vec2(0.);\n        float p1 = 1.;\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 12; k++){\n\n            //uv -= (t2.yx+.5)/scale;\n            uv -= (t2.yx)/scale;\n            //uv -= (t2.yx)*(1.+uv.x-uv.y);\n\n            //uv -= (t2.yx)/(1.-uv.y-uv.x);\n            \n            //uv -= float(k%3)*float(k%2); //this makes it even more colorful\n            \n            \n            //vec2 t4 = t2/4.;\n            vec2 t4 = vec2(0.);\n            \n            t3 = p1*triangle_wave(-p1*uv,scale)-t4;\n            vec2 temp = t2;\n            t2 = p1*triangle_wave(-p1*uv.yx-.5,scale)-t4;\n            \n            //p1 *= -1.; //this makes another interesting pattern\n            \n            \n            \n            uv.yx = t3-t2;\n            //t2 /= (temp-.25);\n\n        col.x = 1.-abs(uv.x+uv.y+col.x);\n        col = col.yzx;\n        \n        uv /= scale*scale;\n      }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1423]]}
{"id": "7ssSzl", "name": "Fork Rolling wa firebreath 440", "author": "firebreathz", "description": "Raymarching rolling clouds and waves", "tags": ["waves", "raymarch"], "likes": 8, "viewed": 289, "published": 3, "date": "1645484277", "time_retrieved": "2024-07-30T17:02:06.759492", "image_code": "#define MAX_STEPS 120\n#define MAX_DIST 120.\n#define SURF_DIST .01\n\nfloat GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.5)*2.7+cos(point.z*2.5+sin(iTime)*5.)*.1+sin(point.x*5.+point.z*10.)*0.03;\n    float planeDist = point.y + texture*.5;\n    \n    float planeDist2 = -point.y + 3. + texture*.5;;\n    \n    return min(planeDist,planeDist2);\n}\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int i = 0;\n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  float d = RayMarch(point+normal*.1, direction).x;\n  if ( d < length(lightPos-point)) dif *= .5;\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1.5, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1, 1.5, 1);\n    \n    if (d.x < 120.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/50.;\n        col = vec3(\n            light-dist,\n            light-dist/1.5+(d.y*0.004),\n            light-dist/2.+(d.y*0.005)\n        );\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 98, 98, 364], [366, 366, 394, 394, 623], [625, 625, 674, 674, 1103], [1105, 1105, 1161, 1161, 1390], [1392, 1392, 1449, 1478, 2148]]}
{"id": "NslBDX", "name": "Sound Experiment #6", "author": "oneshade", "description": ".", "tags": ["buzz", "frequencies", "soundexperiment"], "likes": 8, "viewed": 224, "published": 3, "date": "1645481888", "time_retrieved": "2024-07-30T17:02:07.809684", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n\n    // Aspect correct, centered UVs and 2 pixel AA width for soft edges\n    uv = fragCoord / iResolution.y - vec2(0.0, 0.5);\n    float unit = 2.0 / iResolution.y;\n\n    // Graph sound wave (MUCH slower than actual speed)\n    float x = mod(0.02 * (uv.x + 2.0 * iTime), 11.0);\n    float graphDist = abs(uv.y - 0.25 * makeNoise(x));\n    float slope = 0.01 * (makeNoise(x + 0.0001) - makeNoise(x - 0.0001)) / 0.0002;\n    graphDist /= sqrt(slope * slope + 1.0);\n    graphDist += 0.0025;\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, graphDist));\n\n    fragColor = vec4(color, 1.0);\n\n    // Uncenter\n    uv += vec2(0.0, 0.5);\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat makeNoise(in float time) {\n    float sound = 0.0;\n\n    float t = 4.8 * time;\n\n    // Slightly modified tune from experiment 5\n    float s = floor(t);\n    float n = mod(s, 6.0) + mod(s, 2.0) + 2.0;\n    n += mod(s, mix(2.0, 4.0, step(1.0, mod(time, 5.0))));\n    n += floor(10.0 * snoise(0.25 * s));\n    n = floor(0.4 * n) + 1.0;\n\n    // Smooth transition to avoid clicks\n    // Slightly longer to emphasize note changes\n    t = fract(t);\n    float env = smoothstep(0.0, 0.2, min(t, 1.0 - t));\n\n    // Random frequencies that sound good together\n    // The gaussian weight filters out high frequencies\n    // I don't know exactly where the buzz comes from but I kind of like it\n    for (float i=0.0; i < 50.0; i++) {\n        float freq = floor(660.0 * floor(Hash11(i) * n) / n * 0.8);\n        sound += sin(TAU * fract(freq * time)) * env * exp(-0.00008 * freq * freq) / 25.0;\n    }\n\n    return sound * 8.0;\n}", "sound_code": "vec2 mainSound(in int samp, in float time) {\n    return vec2(makeNoise(float(samp % (11 * int(iSampleRate))) / iSampleRate));\n    //return vec2(makeNoise(float(samp) / iSampleRate));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1935]]}
{"id": "NslBW2", "name": "lONG BLUE SLOW LIGHTS", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 4, "viewed": 240, "published": 3, "date": "1645480900", "time_retrieved": "2024-07-30T17:02:09.062335", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.5;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(131.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1001);\n    p *= p + 33.33;\n    return fract(4.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 5.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.2,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/200.);\n\tfloat rest = mod(time,30.0);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*10. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 20.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*840.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.007)*0.1,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 1.001 + mval.y;\n\tfloat dofamount=0.00001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<2;\n\tbool lightsilver = section>1 && section<12;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = !(section>0);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,1.);\n     // motion slowing down during the last section\n\tfloat t2=section!=16?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*1.1 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 20. : 22.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<2; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,2,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+9.9)*25.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.9+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][2];\n                \n\t\t\t\tfloat d2=1000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.000,0.000,0.251)*0.4, vec3(1.000,1.000,1.000) * 1., max(r.x+r.z*.3-r.y*.3,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.1,0.1,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.9,1);\n                    col += alpha * smoothstep(0.5,0.1,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.2+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*1.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .001;\n\t\t\t\t\tcol += alpha * smoothstep(0.009,0.001,fract(time*.005+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.001+floor(r.z*sqsize)*0.02))) * 1. * (rnd33(floor(r*sqsize)+floor(time)*.0037)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.9*.5)*.9)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 9. * vec3(0.345,0.000,0.690);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*1.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*0.000033);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.1)?.4:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.1;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .5;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*34.,j*5)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.9/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1402]]}
{"id": "ssfBDf", "name": "Water Caustic Pattern #2", "author": "jaybird", "description": "A more expensive version of https://www.shadertoy.com/view/3d3yRj", "tags": ["noise", "water", "simplex", "simplexnoise", "caustic", "watercaustic"], "likes": 36, "viewed": 2023, "published": 3, "date": "1645476163", "time_retrieved": "2024-07-30T17:02:10.024762", "image_code": "// Based on: https://www.shadertoy.com/view/3d3yRj\n// See also: KdotJPG's https://www.shadertoy.com/view/wlc3zr\n\nfloat water_caustics(vec3 pos) {\n    vec4 n = snoise( pos );\n\n    pos -= 0.07*n.xyz;\n    pos *= 1.62;\n    n = snoise( pos );\n\n    pos -= 0.07*n.xyz;\n    n = snoise( pos );\n\n    pos -= 0.07*n.xyz;\n    n = snoise( pos );\n    return n.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n    // camera matrix\n    vec3 ww = normalize(-vec3(0., 1., 0.8));\n    vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n    vec3 vv = normalize(cross(uu,ww));\n\n\tvec3 rd = p.x*uu + p.y*vv + 1.5*ww;\t// view ray\n    vec3 pos = -ww + rd*(ww.y/rd.y);\t// raytrace plane\n    pos.y = iTime*0.75;\t\t\t\t\t// animate noise slice\n    pos *= 3.;\t\t\t\t\t\t\t// tiling frequency\n\n    float w = mix(water_caustics(pos), water_caustics(pos + 1.), 0.5);\n\n    // noise [-1..+1] -> color\n    float intensity = exp(w*4. - 1.);\n\tfragColor = vec4(vec3(intensity), 1.);\n}", "image_inputs": [], "common_code": "// 3D simplex noise adapted from https://www.shadertoy.com/view/Ws23RD\n// * Removed gradient normalization\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, vec3(C.y)));\n    vec3 x0 = v   - i + dot(i, vec3(C.x));\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.x;\n    vec3 x2 = x0 - i2 + C.y;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Compute noise and gradient at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m2 * m;\n    vec4 m4 = m2 * m2;\n    vec3 grad =\n      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +\n      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +\n      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +\n      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * vec4(grad, dot(m4, px));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 145, 145, 349], [351, 351, 408, 408, 1010]]}
{"id": "7dXfDf", "name": "Spiral surprise", "author": "mrange", "description": "Spiral Surprise\nMore spiral experimenting gave a surprisingly appealing result\n", "tags": ["2d", "spirals"], "likes": 13, "viewed": 288, "published": 3, "date": "1645475456", "time_retrieved": "2024-07-30T17:02:11.906730", "image_code": "// CC0: Spiral Surprise\n// More spiral experimenting gave a surprisingly appealing result\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x)+PI);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 spiralEffect(vec2 p, float a, float n) {\n  vec2 op = p;\n  float b = a/TAU;\n  vec2 pp   = toPolar(op);\n  float  aa = pp.y;\n  pp        -= vec2(pp.y*n*b, (pp.x/b-PI)/n);\n  vec2  nn  = mod2(pp, vec2(a, TAU/n));\n  return vec2(pp.x, mod(nn.y, n));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(1.0);\n  \n  float a = 0.5;\n  vec2 se0 = spiralEffect(p*ROT(-0.523*TIME), a, 4.0);\n  vec2 se1 = spiralEffect(p.yx*ROT(0.1*TIME), a, 6.0);\n  vec2 se = vec2(max(se0.x, se1.x), se0.y+se1.y);\n  float h = hash(se.y+123.4)+0.5*length(p)+0.25*p.y;\n  col = hsv2rgb(vec3(fract(h), 0.95, abs(se.x)/a));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 352, 352, 498], [500, 600, 621, 621, 694], [695, 795, 817, 817, 866], [868, 868, 890, 890, 937], [939, 1025, 1061, 1061, 1155], [1157, 1157, 1202, 1202, 1406], [1408, 1468, 1490, 1490, 1538], [1540, 1540, 1595, 1595, 2058]]}
{"id": "fdffDf", "name": "Twisty Tunnel", "author": "codebender", "description": "A different version of my twisty twirl (https://www.shadertoy.com/view/fd2yDG)", "tags": ["tunnel"], "likes": 3, "viewed": 246, "published": 3, "date": "1645465196", "time_retrieved": "2024-07-30T17:02:12.812309", "image_code": "#define noiseTwistingIntensity 2.\n#define noiseTwistingDistanceFactor 60.\n#define noiseTwistingSpeedFactor .4\n\n#define twistingSpeedFactor .3\n\n#define movementSpeedFactor 3.\n\n#define numSegments 5\n\n\n\n\n\n\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** RANDOM **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** PERLIN NOISE **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nconst float M_PI = 3.1415;\nconst float M_PI_DOUBLE = 6.2831;\n\n\nvec2 applyRotation(vec2 base, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(base.x*c-base.y*s, base.x*s+base.y*c);\n}\n\n\nvec2 bringVectorCloserTo(vec2 base, vec2 target, float value) {\n    return target + vec2((base - target).x*value, (base - target).y*value);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = fragCoord.xy/iResolution.y;\n    uv = bringVectorCloserTo(uv, iResolution.xy/iResolution.y/2., .01/pow(distance(uv, iResolution.xy/iResolution.y/2.), 2.));\n    uv = iResolution.xy/iResolution.y/2. + applyRotation(uv.xy - iResolution.xy/iResolution.y/2., distance(uv.xy, iResolution.xy/iResolution.y/2.)*2.+cnoise(vec3(distance(uv.xy, iResolution.xy/iResolution.y/2.)*noiseTwistingDistanceFactor+iTime*movementSpeedFactor, 0., iTime*noiseTwistingSpeedFactor))*noiseTwistingIntensity+iTime*twistingSpeedFactor);\n    \n    float opacity = 0.;\n    \n    float vignette;\n    for (int i = 0; i < numSegments; i += 1) {\n        if (atan(uv.y - 1./2., uv.x - iResolution.x/iResolution.y/2.)/M_PI*180. > float(i*(360/numSegments)-180) && atan(uv.y - 1./2., uv.x - iResolution.x/iResolution.y/2.)/M_PI*180. < float((i+1)*(360/numSegments)-180)) {\n            vignette = (fragCoord.x/iResolution.x)*(fragCoord.y/iResolution.y)*(1.-fragCoord.x/iResolution.x)*(1.-fragCoord.y/iResolution.y)*15.;\n            opacity = float(i)/float(numSegments-1)*vignette+random(fragCoord.xy/2.)*.2;\n        }\n    }\n    \n    vec4 color;\n    color = vec4(opacity*( 1./pow(.5/distance(fragCoord.xy/iResolution.y, iResolution.xy/iResolution.y/2.), 1.2)  ) );\n   \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdffDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[635, 635, 659, 659, 766], [1208, 1208, 1229, 1229, 1266], [1267, 1267, 1294, 1294, 1342], [1343, 1343, 1362, 1362, 1398], [1399, 1399, 1420, 1420, 3692], [3758, 3758, 3802, 3802, 3911], [3914, 3914, 3977, 3977, 4055], [4058, 4058, 4113, 4113, 5386]]}
{"id": "NdXBWf", "name": "Column thingy", "author": "SnoopethDuckDuck", "description": "click to move\n\nplaying around with the usual, refraction, p.y stretching 2d stuff, colors + fresnel stuff\n\n(looks cool when you look directly upwards)", "tags": ["e"], "likes": 13, "viewed": 321, "published": 3, "date": "1645464077", "time_retrieved": "2024-07-30T17:02:13.841558", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    //float sd = sdBox(p, vec3(4.)) - 2.;\n    \n    vec2 uv = p.xz;\n    \n    // buggy + laggy:\n    // float sc = 3.;\n    // uv = floor(sc * uv)/sc + 0.5;\n\n    uv *= Rot(0.1 * p.y);\n    //uv.x = sabs(uv.x) - 1.5;\n   \n    float ext = 4.2 + 1.2 * cos(0.1 * p.y + iTime);\n    uv = abs(uv) - ext;\n    uv *= Rot(pi/4.);\n    uv.x = abs(uv.x) - sqrt(ext) * sqrt(3./2.);\n   \n    uv *= Rot(p.y * 2.4 + iTime);\n   \n    float t = iTime;\n    float r = 0.5;\n    r *= 0.5 + 0.5 * cos(0.5 * t + 1.2 * p.y);       \n    vec2 p0 = r * vec2(cos(t), sin(t));\n    vec2 p1 = r * vec2(cos(t + pi), sin(t + pi));\n    float d = sdSegment(uv * 1.35, p0, p1) - .8 - .5 * length(uv);\n    \n    // looks cool too:\n     //d = sdSegment(uv * (1. + 0.1 * cos(3. * 3. * length(uv))), p0, p1) -0.055 - .5 * length(uv);  \n\n    //d *= 0.8;\n    return d;//-smin(d, -sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -20);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n           \n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 e = vec3(1);\n        vec3 bcol = pal(dif * 0.35 + 0.2 + 0.2 * cos(0.1 * p.y + iTime), e, e, e, 0.5 * vec3(0,1,2)/3.);\n       // col = 0.02 * clamp(col, 0., 1.);\n       \n        col = bcol;\n        col *= 0.75 - 0.25 * n.y;\n        \n        // fresnel (interior + exterior)\n        col += pow(1.+dot(rdIn, nExit), 5.);    \n        col += pow(1.+dot(rd, n), 5.);\n        col *= col * (1. + dot(rd, n));\n\n        // cartoony outline effect (0.5 determines thickness, looks cool with smoothstep)\n        col += bcol * step(0., 0.5 + dot(rd, n));\n    }\n    \n    col = pow(col, vec3(.4545)) + 0.05;\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [151, 151, 180, 180, 261], [263, 263, 286, 328, 1119], [1121, 1121, 1164, 1164, 1398], [1400, 1400, 1424, 1424, 1614], [1616, 1616, 1666, 1666, 1857], [1859, 1859, 1916, 1916, 3321]]}
{"id": "fsfBWX", "name": "Fork Taichi2D", "author": "xavierseb", "description": "A Chinese Taichi model.\n\nUsing backbuffer", "tags": ["2d", "taichi"], "likes": 3, "viewed": 201, "published": 3, "date": "1645450982", "time_retrieved": "2024-07-30T17:02:14.673333", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0,  fragCoord.xy / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ying yang feedback from Taichi2D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)*1.2 /iResolution.yy;\n   \n    float t = clamp(4.*sin(iTime/2.),-3.1416,3.1416) +1.5708; \n    vec2 tpos = .25*vec2(sin(t),cos(t)); \n    \n    float h = 0.;\n    float x = distance(uv, tpos), y = distance(uv, -tpos);\n    if(y<.25 ) h=-1. +smoothstep(.24,.25,y); // +antialiasing\n    if(x<.25 ) h= 1. -smoothstep(.24,.25,x); //    \n    if(x<.10 ) h=-1. +smoothstep(.09,.10,x); //\n    if(y<.10 ) h= 1. -smoothstep(.09,.10,y); // \n\n    if(length(uv)<.5) h = clamp(h+ texture(iChannel0,fragCoord/iResolution.xy).x, -1., 1. );\n    fragColor = vec4(h,h,h+1.,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]]}
{"id": "7dsfDj", "name": "Mutant Zebra Valley", "author": "mla", "description": "Tidied up version of Fabrice's shader. Mouse sets parameters.\n\nA little slow, a loopless version would be a nice exercise for someone.", "tags": ["zebra", "reproduction"], "likes": 21, "viewed": 440, "published": 3, "date": "1645450142", "time_retrieved": "2024-07-30T17:02:15.537024", "image_code": "// Variant of Fabrice's https://www.shadertoy.com/view/sslBDj\n// Tidied up so I could understand what was going on.\n// Also colours, variable wave heights, better AA (takes into\n// account slope of graph) and added some more movement.\nvoid mainImage( out vec4 O, vec2 p ){\n  float scale = 3.0;\n  float H = 2.0; // Wave height\n  float K = 6.0; // Band density\n  if (iMouse.z > 0.0) {\n    H = 6.0*iMouse.x/iResolution.x;\n    K = 10.0*iMouse.y/iResolution.y;\n  }\n  p = scale*(2.0*p-iResolution.xy)/iResolution.y;\n  //p *= 2.0; // Uncomment to see what is going on\n  O = vec4(0);\n  int N = int(1.2*K*(H+scale));\n  float px = fwidth(p.y);\n  float A = 1.0;\n  float t = 0.618*iTime+p.x;\n  float z = A*sin(t); // Vertical displacement\n  for( int i = -N; i <= N; i++) {\n    int ix = i;\n    ix -= int(0.5*K*iTime);\n    float offset = float(ix)/K;\n    float a = p.x + sin(offset + iTime);\n    float d = H*cos(a) - offset - p.y - 0.5*iTime + z;\n    // Insert favourite approximate to sqrt here.\n    float k = sqrt(1.0+sqr(H*sin(a)-A*cos(t)));\n    //float k = 1.0+0.5*abs(H*sin(a)-A*cos(t)); // Not a bad one\n    if (abs(d) > 3.0*k/K) continue;\n    vec4 col = vec4(ix&1); // ix can be negative!\n    col *= vec4(0.5+0.5*h2rgb(fhash(ix)),1);\n    col *= 0.6 - 0.4*sin(a); // Shading\n    O = mix(O,col,smoothstep(-px*k,px*k,d));\n  }\n  O = pow(O,vec4(0.4545));\n}", "image_inputs": [], "common_code": "vec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat fhash(int n) {\n  return float(ihash(uint(n)))/pow(2.0,32.0);\n}\n\nfloat sqr(float x) { return x*x; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 235, 272, 272, 1344]]}
{"id": "7slBD2", "name": "Gamut clipping - modified Oklab", "author": "bjornornorn", "description": "Comparing gamut clipping allowing hue distortions, top, and gamut clipping without hue distortions on the bottom. With some hue distortions the result can be made smoother.", "tags": ["gamut"], "likes": 4, "viewed": 341, "published": 3, "date": "1645446594", "time_retrieved": "2024-07-30T17:02:16.353840", "image_code": "vec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat softness_scale = 0.2;\n\nvec3 toLms(float I, float hue, float sat)\n{\n    float a = cos(hue);\n    float b = sin(hue);\n    \n    float l_ = + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = - 0.0894841775f * a - 1.2914855480f * b;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    vec2 MC = findCenterAndPurity(lms);   \n    lms -= MC.x;    \n    lms *= sat;    \n    lms += I;\n    \n    return lms;\n}\n\nvec2 approximateShapeA(float L, float hue, float sat)\n{\n    vec3 lms = toLms(L, hue, sat);\n        \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.70021527e+00 + -8.21491826e-02*a +  1.73329721e-01*b +  1.73952306e-01*a2 +  4.95620904e-03*b2 + 1.94643985e-02*a3 +  2.39021796e-02*b3,\n        3.07593575e-01 + 1.70513225e-02*a +   7.21549478e-03*b +  1.99728079e-02*a2 + -1.25118676e-03*b2 + -7.99372300e-04*a3 + 1.21489709e-03*b3\n    );\n}\n\nvec2 approximateShapeB(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat); \n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n\n    // softness_scale 0.2\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n        2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n    );\n}\n\n\nvec3 compute(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat);\n\n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    \n    return rgbResult;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return grey + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float I = 2.0*fragCoord.y / iResolution.y;\n    I = I - floor(I);\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n\n    float C_max;\n    \n    for (int i=0; i<200; i++)\n    {\n        vec3 rgbTest = compute(I, h, 0.5*float(i)/200.0);\n        float diff = length(rgbTest - clamp(rgbTest, 0., 1.));\n    \n        if(diff == 0.)\n        {\n            C_max = 0.5*float(i)/200.0;\n        }\n    }\n    \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 0.5)\n    {\n        vec2 ST = approximateShapeA(I, h, 1.0);\n   \n        float C_smooth = (1.0/((ST.x/I) + (ST.y/(1.0-I))));\n        rgb = compute(I, h, min(C,C_smooth));\n        rgb = softClipColorOutsideGamutOnly(rgb);\n        \n    }\n    else\n    {\n        rgb = compute(I, h, min(C,C_max));\n    }\n    \n    rgb = clamp(rgb,0.0,1.0);\n    \n    fragColor.rgb = Srgb3(vec3(rgb));\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 175, 754], [757, 757, 777, 777, 1038], [1069, 1069, 1112, 1112, 1495], [1497, 1497, 1552, 1552, 2397], [2399, 2399, 2454, 2454, 3293], [3296, 3296, 3341, 3341, 3737], [3739, 3739, 3774, 3774, 3914], [3916, 3916, 3964, 4049, 4482], [4484, 4484, 4541, 4541, 5450]]}
{"id": "7dsBW2", "name": "Drive the Mapper", "author": "dr2", "description": "Just drive - will not go off-road", "tags": ["game", "interactive", "trail", "car", "building", "steer"], "likes": 29, "viewed": 627, "published": 3, "date": "1645442383", "time_retrieved": "2024-07-30T17:02:17.371120", "image_code": "// \"Drive the Mapper\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Driving\" series; others are listed in \"Truck Driving 2\" (ftt3Ds)\n*/\n\n#define OE min(VJ,0)\n#define HV(DA)if(XH<Gk){Gk=XH; Pz=DA; Vb=RF;}\n#define JG(RF)Up=Wa; Wa=Up/2; if(Wa*2!=Up)XH+=Ez(RF)\n#define JG(RF)Up=Wa; Wa=Up/2; if(Wa*2!=Up)XH+=Ez(RF)\n#define VN iChannel0\n#define Zj iChannelResolution[0].xy\nconst float Xd=3.1415927;const int CB=32;const int AQ=7;const int IH=1,Fl=2,Dj=3,Yc=4,UG=5,Wr=6,EU=7,NO=8,Ks=9,GW=10,ZN=11;vec4 Wn,Jg;vec3 CW,Vb,FK,ZJ,LZ;vec2 GS[6],KR[6],DZ[6],YK,Go;float Lr,Id,Hv,Bl,SI,OA,PQ,Ha,Nk;int VJ,Pz;bool Nx,Pi,Iq;float Az(vec3 TH,vec3 UK){vec3 XH;XH=abs(TH)-UK;return min(max(XH.x,max(XH.y,XH.z)),0.)+length(max(XH,0.));}float YO(vec2 TH,vec2 UK){vec2 XH;XH=abs(TH)-UK;return min(max(XH.x,XH.y),0.)+length(max(XH,0.));}float KN(vec3 TH,vec3 UK,float BT){return length(max(abs(TH)-UK,0.))-BT;}float Hr(vec3 TH,vec3 UK,float BT){TH=max(abs(TH)-UK,0.);return sqrt(length(TH*TH))-BT;}float Jc(vec2 TH,vec2 UK,float BT){return length(max(abs(TH)-UK,0.))-BT;}float FG(vec3 TH,float Ai,float RB){return max(length(TH.xy)-Ai,abs(TH.z)-RB);}float My(vec3 TH,float Ai,float BT,float RB){return length(max(vec2(length(TH.xy)-Ai,abs(TH.z)-RB),0.))-BT;}float Ck(vec3 TH,float Ai,float RB){return length(vec3(TH.xy,sign(TH.z)*(max(0.,abs(TH.z)-RB))))-Ai;}float DV(vec3 TH,vec2 VW,float Ai,float RB){float XH;XH=max(dot(vec2(length(TH.xy)-Ai,TH.z),VW),abs(TH.z)-RB);RB/=VW.x*VW.x;Ai/=VW.x;XH=min(XH,min(length(vec3(TH.xy,TH.z+Ai*VW.y-RB))-Ai+RB*VW.y,length(vec3(TH.xy,TH.z+Ai*VW.y+RB))-Ai-RB*VW.y));return XH;}float Oj(vec3 TH,float Kw,float Ai){return length(vec2(length(TH.xy)-Ai,TH.z))-Kw;}float ED(vec2 TH){return min(TH.x,TH.y);}float CS(vec2 TH){return max(TH.x,TH.y);}float QX(float HM,float Jx,float Ai){float RB;RB=clamp(0.5+0.5*(Jx-HM)/Ai,0.,1.);return mix(Jx-RB*Ai,HM,RB);}float Pm(float HM,float Jx,float Ai){return-QX(-HM,-Jx,Ai);}mat3 ZA(float Xq,float ID){vec2 RW,Rg,Wv;RW=vec2(Xq,ID);Rg=cos(RW);Wv=sin(RW);return mat3(Rg.y,0.,-Wv.y,0.,1.,0.,Wv.y,0.,Rg.y)*mat3(1.,0.,0.,0.,Rg.x,-Wv.x,0.,Wv.x,Rg.x);}vec2 Ro(vec2 RF,float BL){vec2 VW;VW=sin(BL+vec2(0.5*Xd,0.));return vec2(dot(RF,vec2(VW.x,-VW.y)),dot(RF.yx,VW));}vec2 PD(vec2 RF,vec2 VW){return vec2(dot(RF,vec2(VW.x,-VW.y)),dot(RF.yx,VW));}vec3 BP(vec3 Pv){return Pv.z*mix(vec3(1.),clamp(abs(fract(Pv.xxx+vec3(1.,2./3.,1./3.))*6.-3.)-1.,0.,1.),Pv.y);}float Ez(vec2 RF){return(1.-smoothstep(0.13,0.17,abs(RF.x)))*(1.-smoothstep(0.5,0.57,abs(RF.y)));}float EY(vec2 RF,int QT){float XH;int Up,Wa;const vec2 Xh=vec2(0.5,0.5),Sa=vec2(-0.5,0.5),Vw=vec2(1.,0.);if(QT==-1)Up=8;else if(QT<2)Up=(QT==0)?119:36;else if(QT<4)Up=(QT==2)?93:109;else if(QT<6)Up=(QT==4)?46:107;else if(QT<8)Up=(QT==6)?122:37;else    Up=(QT==8)?127:47;RF=(RF-0.5)*vec2(1.8,2.3);XH=0.;Wa=Up;JG(RF.yx-Vw); JG(RF.xy-Xh); JG(RF.xy-Sa); JG(RF.yx);JG(RF.xy+Sa); JG(RF.xy+Xh); JG(RF.yx+Vw);return XH;}float GJ(vec2 RF,vec2 Bu,float Ng,float Li){float Sn,Md,UK,Gb;RF=vec2(-RF.x,RF.y)/Bu;UK=0.;if(min(RF.x,RF.y)>=0.&&max(RF.x,RF.y)<1.){RF.x*=Ng;Sn=Ng;Md=Ng-1.-floor(RF.x);RF.x=fract(RF.x);Li=max(Li,0.);Gb=Li/pow(10.,Ng-Md-1.);if(Md>=Ng-Sn)UK=EY(RF,int(mod(floor(Gb),10.)));}return UK;}const float Df=43758.54;vec2 Tm(float TH){return fract(sin(mod(TH+vec2(0.,1.),2.*Xd))*Df);}vec2 UX(vec2 TH){vec2 EQ=vec2(37.,39.);return fract(sin(mod(dot(TH,EQ)+vec2(0.,EQ.x),2.*Xd))*Df);}vec3 WI(vec2 TH){vec2 EQ=vec2(37.,39);return fract(sin(mod(dot(TH,EQ)+vec3(0.,EQ.xy),2.*Xd))*Df);}float Xu(float TH){vec2 EH;float LM,Qh;LM=floor(TH);Qh=fract(TH);Qh=Qh*Qh*(3.-2.*Qh);EH=Tm(LM);return mix(EH.x,EH.y,Qh);}float Zf(vec2 TH){vec2 EH,LM,Qh;LM=floor(TH);Qh=fract(TH);Qh=Qh*Qh*(3.-2.*Qh);EH=mix(UX(LM),UX(LM+vec2(0.,1.)),Qh.y);return mix(EH.x,EH.y,Qh.x);}float Cx(float TH){float AM,BL;AM=0.;BL=1.;for(int SE=0;SE<5;SE++){AM+=BL*Xu(TH);BL*=0.5;TH*=2.;}return AM*(1./1.9375);}float Ei(vec2 TH){float AM,BL;AM=0.;BL=1.;for(int SE=0;SE<5;SE++){AM+=BL*Zf(TH);BL*=0.5;TH*=2.;}return AM*(1./1.9375);}float FT(vec3 TH,vec3 OR){vec3 UK;float BL;UK=vec3(0.);BL=1.;for(int SE=0;SE<5;SE++){UK+=BL*vec3(Zf(TH.yz),Zf(TH.zx),Zf(TH.xy));BL*=0.5;TH*=2.;}return dot(UK,abs(OR));}vec3 MT(vec3 TH,vec3 OR,float AM){vec4 Gb;vec3 RB;vec2 VF=vec2(0.1,0.);for(int SE=OE;SE<4;SE++){Gb[SE]=FT(TH+((SE<2)?((SE==0)?VF.xyy:VF.yxy):((SE==2)?VF.yyx:VF.yyy)),OR);}RB=Gb.xyz-Gb.w;return normalize(OR+AM*(RB-OR*dot(OR,RB)));}const float Xy=128.;vec4 Bh(int By){float Ow;Ow=float(By);return texture(VN,(vec2(mod(Ow,Xy),floor(Ow/Xy))+0.5)/Zj);}float FX(vec3 TH){vec3 RF,Tq;float Gk,XH,EH,Zs,TU;TH-=Wn.xyz;TH.xz=Ro(TH.xz,Wn.w);Gk=Lr;if(!Nx)XH=KN(TH,vec3(ZJ.x,ZJ.y+1.2,ZJ.z),0.5);if(Nx||XH<0.1){RF=TH;TU=My(vec3(abs(RF.x)-FK.x,RF.y,FK.z*(fract(RF.z/FK.z+0.5)-0.5)).yzx,Hv+0.02,0.05,0.35);RF.y-=1.1;Zs=Hr(RF,ZJ-1.,1.);XH=min(abs(Zs)-0.05,max(Zs,TU-0.05));XH=Pm(XH,-max(abs(abs(RF.z)-FK.z-Hv-0.2)-0.01,0.02-abs(Zs)),0.02);XH=Pm(XH,-min(min(Jc(vec2(RF.y-0.3,abs(RF.z)-1.05),vec2(0.3,0.75),0.2),Jc(vec2(abs(RF.x)-0.6,RF.y-0.3),vec2(0.3,0.25),0.2)),max(Jc(vec2(RF.x,RF.z-0.8),vec2(0.8,0.5),0.2),-RF.y)),0.02);XH=max(XH,-max(TU,max(abs(RF.z)-FK.z-(Hv+0.1),FK.x-0.7-abs(RF.x))));HV(IH);RF=TH;RF.yz-=vec2(ZJ.y+1.33+0.05,-1.);XH=My(RF.xzy,0.15,0.05,0.22);RF.y-=max(0.5*SI,0.)-0.05;XH=min(XH,My(RF.xzy,0.6,0.15,0.03));HV(Ks);RF=TH;RF.xz=abs(RF.xz)-FK.xz-vec2(-0.2,-0.5*FK.z);RF.z=abs(RF.z)-0.5*FK.z;XH=FG(RF.yzx,0.1,0.2);HV(Fl);for(int Up=OE;Up<6;Up++){RF=TH;RF.xz=PD(RF.xz-GS[Up]*FK.xz,KR[Up]);EH=Hv-length(RF.yz);RF.yz=PD(RF.yz,DZ[Up]);Tq=abs(RF);XH=min(max(length(max(vec2(0.1-EH,Tq.x-0.1),0.))-0.1,EH-0.2),max(0.2-EH,Tq.x-0.12));XH=max(XH,-max(abs(fract(4.*RF.x/0.24)-0.5)-0.2,EH-0.05));XH=min(XH,FG(vec3(Tq.x-0.1,((Tq.y<Tq.z)?RF.yz:RF.zy)),0.06,Hv-0.15));RF.x*=sign(TH.x);HV(Dj);}RF=TH;XH=KN(RF-vec3(-0.4,0.5,ZJ.z-0.4),vec3(0.1,0.5,0.03),0.05);RF.yz=Ro(RF.yz-vec2(0.72,-0.2),-0.1*Xd);RF-=vec3(-0.4,0.9,1.8);XH=min(XH,My(RF,0.03,0.03,0.35));RF.z-=-0.35;RF.xy=Ro(RF.xy,-8.*Bl+Xd/6.);RF.xy=Ro(RF.xy,2.*Xd*floor(3.*atan(RF.y,-RF.x)/(2.*Xd)+0.5)/3.);XH=min(XH,Oj(RF,0.025,0.35));RF.x+=0.17;XH=min(XH,FG(RF.yzx,0.02,0.17));HV(Yc);RF=TH;RF.yz-=vec2(0.5,0.8);XH=KN(RF,vec3(0.98,0.2,0.35)-0.05,0.05);RF.yz=Ro(RF.yz-vec2(0.5,-0.45),0.1*Xd);RF.x=abs(RF.x)-0.49;XH=min(XH,KN(RF,vec3(0.48,0.35,0.1)-0.05,0.05));HV(UG);RF=TH;RF.yz-=vec2(0.6,-1.);XH=KN(RF,vec3(0.98,0.2,0.35)-0.05,0.05);RF.yz=Ro(RF.yz-vec2(0.5,-0.45),0.1*Xd);RF.x=abs(RF.x)-0.49;XH=min(XH,KN(RF,vec3(0.48,0.35,0.1)-0.05,0.05));HV(UG);RF=TH;RF-=vec3(0.1,-0.1,1.5);RF.yz=Ro(RF.yz,Xd*(0.02+0.06*sign(SI)));RF.y-=0.5;XH=Ck(RF.xzy,0.04,0.5);HV(Wr);RF=TH;RF.yz-=vec2(1.1,2.4);XH=Ck(RF.xzy,0.06,0.05);HV(EU);RF=TH;XH=Ck((vec3(abs(RF.xz),RF.y).xzy-vec3(0.7,0.4,ZJ.z+0.02)).yzx,0.05,0.3);HV(NO);}else Gk=min(Gk,XH);return Gk;}\nfloat Jt(vec3 Mh,vec3 BT){vec3 TH;float CO,XH;CO=0.;for(int SE=OE;SE<160;SE++){TH=Mh+CO*BT;XH=FX(TH);CO+=XH;if(XH<0.001||CO>Lr||TH.y<0.)break;}if(TH.y<0.)CO=Lr;return CO;}vec3 HI(vec3 TH){vec4 Gb;vec2 VF;VF=vec2(0.001,-0.001);for(int SE=OE;SE<4;SE++){Gb[SE]=FX(TH+((SE<2)?((SE==0)?VF.xxx:VF.xyy):((SE==2)?VF.yxy:VF.yyx)));}Gb.x=-Gb.x;return normalize(2.*Gb.yzw-dot(Gb,vec4(1.)));}float OV(vec3 TH){vec3 RF;float XH;TH-=Wn.xyz;TH.xz=Ro(TH.xz,Wn.w);RF=TH;RF.y-=1.1;return max(Hr(RF,ZJ-1.,1.),-0.5-RF.y);}float Sr(vec3 Mh,vec3 BT){vec3 TH;float CO,XH;CO=0.;for(int SE=OE;SE<60;SE++){TH=Mh+CO*BT;XH=OV(TH);CO+=XH;if(XH<0.001||CO>Lr||TH.y<0.)break;}if(TH.y<0.)CO=Lr;return CO;}vec3 QG(vec3 TH){vec4 Gb;vec2 VF;VF=vec2(0.001,-0.001);for(int SE=OE;SE<4;SE++){Gb[SE]=OV(TH+((SE<2)?((SE==0)?VF.xxx:VF.xyy):((SE==2)?VF.yxy:VF.yyx)));}Gb.x=-Gb.x;return normalize(2.*Gb.yzw-dot(Gb,vec4(1.)));}float Le(vec3 Mh,vec3 BT){float Dn,XH,RB;int SV;SV=Pz;Dn=1.;XH=0.02;Nx=true;for(int SE=OE;SE<30;SE++){RB=FX(Mh+XH*BT);Dn=min(Dn,smoothstep(0.,0.1*XH,RB));XH+=RB;if(Dn<0.05||XH>Lr)break;}Nx=false;Pz=SV;return 0.5+0.5*Dn;}void BC(){LZ=4.*floor(vec3(0.08*PQ,4.,0.08*PQ)*(0.4+0.6*WI(YK+Go)))-0.5;Nk=10.+2.*LZ.y;}float DR(vec3 TH){vec3 RF,Yx,Tq;float Gk,XH,Zs;Gk=Lr;RF=TH;RF.xz-=PQ*(YK+0.5);RF.y-=LZ.y;Zs=Az(RF,LZ);if(Pi){XH=Zs;}else{Yx=mod(RF+2.,4.)-2.;Yx.y-=0.2;Tq=abs(RF)-LZ+1.;XH=Pm(abs(Zs)-0.1,-min(max(YO(Yx.xy,vec2(1.3,1.)),CS(Tq.xy)),max(YO(Yx.zy,vec2(1.3,1.)),CS(Tq.zy))),0.05);XH=min(XH,max(abs(Yx.y-1.1)-0.05,Zs));}HV(GW);if(!Pi){RF.y-=-LZ.y;RF=vec3(abs(RF.xz)-LZ.xz-4.,RF.y-0.1*Nk);XH=Nk*DV(RF/Nk,sin(0.06*Xd+vec2(0.5*Xd,0.)),0.03,0.06);HV(ZN);}return Gk;}float Hn(vec3 Mh,vec3 BT){vec3 TH,DE;vec2 Av;float CO,XH,Zb;Zb=0.01;if(BT.x==0.)BT.x=0.0001;if(BT.z==0.)BT.z=0.0001;DE.xz=1./BT.xz;Av=vec2(-999.);CO=Zb;for(int SE=OE;SE<120;SE++){TH=Mh+CO*BT;TH.xz-=0.5*PQ;YK=floor(TH.xz/PQ);if(YK!=Av){Av=YK;BC();}XH=DR(TH);CO+=min(XH,Zb+max(0.,ED((PQ*(YK+step(0.,BT.xz))-TH.xz)*DE.xz)));if(XH<Zb||CO>Lr||TH.y<0.)break;}if(XH>=Zb||TH.y<0.)CO=Lr;return CO;}vec3 FC(vec3 TH){vec4 Gb;vec2 VF=vec2(0.001,-0.001);TH.xz-=0.5*PQ;for(int SE=OE;SE<4;SE++){Gb[SE]=DR(TH+((SE<2)?((SE==0)?VF.xxx:VF.xyy):((SE==2)?VF.yxy:VF.yyx)));}Gb.x=-Gb.x;return normalize(2.*Gb.yzw-dot(Gb,vec4(1.)));}float IY(vec3 Mh,vec3 BT){vec3 TH;vec2 Av;float Dn,XH,RB;int SV;SV=Pz;Dn=1.;Av=vec2(-999.);XH=0.01;for(int SE=OE;SE<30;SE++){TH=Mh+XH*BT;TH.xz-=0.5*PQ;YK=floor(TH.xz/PQ);if(YK!=Av){Av=YK;BC();}RB=DR(TH);Dn=min(Dn,smoothstep(0.,0.1*XH,RB));XH+=max(RB,0.01);if(RB<0.001||XH>Lr)break;}Pz=SV;return 0.5+0.5*Dn;}float Lz(vec2 TH){vec4 AU;vec2 Vo[2],WZ[2],Bd,RF;float We,UK,Cg;We=1.;for(float XL=-1.+float(OE);XL<=1.;XL++){Vo[0]=Wn.xz;WZ[0]=Vo[0]+Ro(vec2(0.,XL*FK.z),-Wn.w);for(int SE=OE;SE<CB;SE++){Vo[1]=Vo[0];WZ[1]=WZ[0];AU=Bh(AQ+SE);if(AU.z>=0.){Vo[0]=AU.xy;WZ[0]=Vo[0]+Ro(vec2(0.,XL*FK.z),-AU.z);UK=1.;if(XL==0.){Bd=WZ[0]-WZ[1];Cg=length(Bd);if(Cg>0.){RF=PD(TH-0.5*(WZ[0]+WZ[1]),Bd.yx/Cg);RF.x=abs(RF.x)-FK.x;UK=min(UK,Jc(RF,vec2(0.1,0.5*Cg),0.05));}}else{for(float Up=-1.;Up<=1.;Up+=2.){Bd=WZ[0]-WZ[1];Cg=length(Bd);if(Cg>0.){RF=PD(TH-0.5*(WZ[0]+WZ[1])+Ro(vec2(Up*FK.x,0.),-AU.z),Bd.yx/Cg);UK=min(UK,Jc(RF,vec2(0.1,0.5*Cg),0.05));}}}We=min(We,1.-0.3*sqrt(1.-min(1.,(float(SE)+20.*(Id-AU.w))/float(CB)))*(1.-smoothstep(0.,0.05,UK)));We=min(We,1.-0.3*sqrt(1.-float(SE)/float(CB))*(1.-smoothstep(0.,0.05,UK)));}else break;}}return We;}vec3 Mu(vec2 TH){vec2 VF;VF=vec2(0.01,0.);TH*=0.5;return vec3(normalize(vec3(Ei(TH)-vec2(Ei(TH+VF.xy),Ei(TH+VF.yx)),8.*VF.x)).xzy);}float Vs(vec2 TH,float TU){return Jc(mod(TH+0.5*PQ,PQ)-0.5*PQ,vec2(0.5*PQ)-2.*Ha-TU,Ha);}float Of(vec2 TH){float XH;XH=Lr;for(int Up=0;Up<6;Up++)XH=min(XH,length(Wn.xz-Ro((vec2(2.*mod(float(Up),2.),float(Up/2))-1.)*FK.xz,-Wn.w)-TH));return 0.7+0.3*smoothstep(0.2,0.3,XH);}vec3 KJ(vec2 TH,float Nc,float Dn){vec3 JX,Pe,TL;vec2 Qp,RF;float AM,We;Pe=0.4*mix(vec3(0.8,1.,0.5),vec3(0.7,0.9,0.5),0.2+0.6*smoothstep(0.3,0.7,Ei(0.5*TH)));Qp=vec2(0.);if(Vs(TH,0.4)>0.){AM=smoothstep(0.,0.1,abs(Vs(TH,0.2))-0.2);JX=mix(vec3(0.4,0.4,0.1),vec3(0.3),AM);TL=vec3(0.,1.,0.);Qp=vec2(4.,0.2+0.5*AM);}else{RF=TH-0.5*PQ;YK=floor(RF/PQ);BC();RF-=PQ*(YK+0.5);if(Jc(RF,LZ.xz+2.,0.5)<0.){JX=vec3(0.25);TL=vec3(0.,1.,0.);Qp=vec2(4.,1.);}else{JX=Pe;TL=Mu(TH);}}JX*=Of(TH);We=Lz(TH);Qp*=1.+2.*step(We,0.99);Qp.y*=1.-smoothstep(0.5,0.8,Nc/Lr);if(Qp.y>0.)TL=MT(Qp.x*vec3(TH.x,0.,TH.y),TL,Qp.y);JX*=(0.2+0.8*Dn*max(dot(TL,CW),0.))*(0.5+0.5*We);return JX;}vec3 LQ(vec3 Mh,vec3 BT){vec3 JX,GB,Kf;vec2 RF;float AM,La,ML,ZR;if(BT.y>-0.02&&BT.y<0.03*Cx(16.*atan(BT.z,-BT.x))){JX=vec3(0.3,0.4,0.5);}else{RF=0.01*(Mh.xz+2.*Id+((100.-Mh.y)/BT.y)*BT.xz);ML=Ei(RF);AM=smoothstep(0.2,0.8,ML);La=smoothstep(0.2,0.8,Ei(RF+0.01*CW.xz))-AM;GB=(0.7+0.5*ML)*(vec3(0.7)-0.7*vec3(0.3,0.3,0.2)*sign(La)*smoothstep(0.,0.05,abs(La)));ZR=max(dot(BT,CW),0.);Kf=vec3(0.3,0.4,0.8)+step(0.1,ZR)*vec3(1.,1.,0.9)*min(0.3*pow(ZR,64.)+0.5*pow(ZR,2048.),1.);JX=mix(Kf,GB,0.1+0.9*AM*smoothstep(0.01,0.1,BT.y));}return JX;}vec4 UC(out float IL){vec4 LI,Nt;float EH;Nt=vec4(0.95,0.9,0.9,0.2);LI=Nt;if(Pz==IH){if(!Iq){if(abs(Vb.z)<FK.z+Hv+0.2)LI.rgb*=0.7+0.3*smoothstep(0.,0.02,abs(length(vec2(Vb.y+1.1,FK.z*(fract(Vb.z/FK.z+0.5)-0.5)))-Hv-0.14)-0.02);LI.rgb*=0.7+0.3*smoothstep(0.,0.02,Jc(vec2(Vb.y-0.3,abs(Vb.z)-1.05),vec2(0.3,0.75),0.2)-0.04);LI.rgb*=0.7+0.3*smoothstep(0.,0.02,Jc(vec2(abs(Vb.x)-0.6,Vb.y-0.3),vec2(0.3,0.25),0.2)-0.04);if(Vb.y>0.)LI.rgb*=0.7+0.3*smoothstep(0.,0.02,Jc(vec2(Vb.x,Vb.z-0.8),vec2(0.8,0.5),0.2)-0.04);}else{LI*=0.5;}}else if(Pz==Ks){LI.rgb*=0.1+0.9*smoothstep(0.,0.02,length(vec2(Vb.y,dot(Vb.zx,sin(2.*Xd*floor(12.*atan(Vb.z,-Vb.x)/(2.*Xd)+0.5)/12.+vec2(0.5*Xd,0.)))))-0.12);}else if(Pz==Fl){LI=vec4(0.3,0.3,0.4,0.1);}else if(Pz==Dj){EH=Hv-length(Vb.yz);if(EH<0.17){LI=vec4(0.3,0.3,0.3,0.);if(EH<0.07)LI*=1.-0.5*abs(step(0.,cos(32.*Xd*Vb.x))-step(0.5,mod(32.*atan(Vb.z,-Vb.y)/(2.*Xd)+0.5,1.)));}else if(EH<0.2||Vb.x<0.){LI*=0.5;}}else if(Pz==Yc){LI=vec4(0.9,0.9,0.7,0.2);}else if(Pz==Wr){LI=vec4(0.9,0.9,0.7,0.2);}else if(Pz==UG){LI=vec4(0.9,0.7,0.4,0.05)*(0.95+0.05*cos(64.*Vb.x));}else if(Pz==EU){LI=(OA>0.)?vec4(0.,0.8,0.,-1.):vec4(0.8,0.,0.,-1.);}else if(Pz==NO){if(abs(Bl)>0.03*Xd&&Bl*Vb.x<0.&&abs(Vb.x)>0.95&&mod(2.*Id,1.)>0.5)LI=vec4(0.7,0.7,0.,-1.);else LI=(Vb.z>0.)?vec4(1.,1.,0.95,-1.):vec4(0.9,0.,0.,-1.);LI.rgb*=0.8+0.2*smoothstep(0.,0.02,abs(abs(Vb.x)-0.95));}IL=0.;if(LI==Nt)IL=0.3;return LI;}vec3 Ae(vec3 JX,vec3 BT){return mix(JX,vec3(0.3,0.4,0.5),pow(1.+BT.y,16.));}\nvec4 Ko(inout vec3 TL){vec4 LI;vec2 EH,Qp;float RB,UK,NK;RB=mod(dot(YK+Go,vec2(17.11,21.11)),1.);Qp=vec2(0.);if(Pz==GW){LI=vec4(BP(vec3(RB,0.4,0.8)),0.1);if(Az(Vb,LZ)<0.){LI*=0.3;if(TL.y<-0.95)LI=mix(vec4(1.,1.,0.5,-1.),LI,step(0.5,length(mod(Vb.xz+2.,4.)-2.)));}else{UK=0.;EH=vec2(dot(Vb.xz,normalize(vec2(-TL.z,TL.x)))-1.3,Vb.y+LZ.y-0.8);if(CS(abs(TL.xz))>0.99&&YO(EH,vec2(3.,1.))<0.1){NK=dot(mod(YK+31.+floor(0.4*Go),100.),vec2(100.,1.));UK=GJ(EH,vec2(2.4,0.6),4.,NK);if(UK>0.)LI=vec4(1.,1.,0.8,-1.);}if(UK==0.)Qp=vec2(16.,0.5);}}else if(Pz==ZN){LI=vec4(BP(vec3(mod(0.25+0.2*RB,1.),0.6,0.9)),0.);Qp=vec2(32.,1.);}if(Qp.y>0.)TL=MT(Qp.x*Vb,TL,Qp.y);return LI;}vec3 Iu(vec3 Mh,vec3 BT){vec4 LI;vec3 NS,Fp,JX,QP,TL,WM,RF;float Qy,ON,Sj,Nc,TY,IL,Dn;int Rk;NS=Mh;Fp=BT;Nx=false;Pi=false;ZJ=vec3(FK.x+0.05,1.2,FK.z+1.);for(int Up=OE;Up<6;Up++){GS[Up]=vec2(2.*mod(float(Up),2.),float(Up/2))-1.;KR[Up]=sin(-Bl*GS[Up].y+vec2(0.5*Xd,0.));DZ[Up]=sin(-((GS[Up].y!=1.)?((GS[Up].x<0.)?Jg.x:Jg.y):((GS[Up].x<0.)?Jg.z:Jg.w))+vec2(0.5*Xd,0.));}Qy=Hn(Mh,BT);Rk=Pz;WM=Vb;ON=Jt(Mh,BT);if(Qy<min(ON,Lr)){Pz=Rk;Vb=WM;ON=Qy;}if(ON<Lr){Mh+=ON*BT;TL=(Pz==Rk)?FC(Mh):HI(Mh);if(Pz==IH)Iq=(Hr(Vb,ZJ-1.,1.)<0.03);IL=0.;LI=(Pz==Rk)?Ko(TL):UC(IL);if(LI.a>=0.){TY=max(dot(TL,CW),0.);if(Pz!=Rk){Dn=Le(Mh+0.01*TL,CW);}else{Dn=1.;TY*=TY;}JX=LI.rgb*(0.2+0.8*Dn*TY)+LI.a*step(0.95,Dn)*pow(max(dot(CW,reflect(BT,TL)),0.),32.);if(Pz==Rk)JX=mix(JX,0.9*Ae(KJ(Mh.xz,Nc,Dn),BT),smoothstep(0.85,0.95,ON/Lr));if(IL>0.)BT=reflect(BT,TL);}else if(LI.a==-1.){JX=LI.rgb*(0.5-0.5*dot(BT,TL));}}if(ON>=Lr||IL>0.){if(BT.y<0.){Nc=-Mh.y/BT.y;Mh+=Nc*BT;Dn=(Nc<Lr)?min(Le(Mh+0.01*vec3(0.,1.,0.),CW),IY(Mh+0.01*vec3(0.,1.,0.),CW)):1.;QP=Ae(KJ(Mh.xz,Nc,Dn),BT);}else{QP=LQ(Mh,BT);}JX=(IL>0.)?mix(JX,0.9*QP,IL):QP;}Sj=Sr(NS,Fp);if(Sj<min(ON,Lr)){Mh=NS+Sj*Fp;TL=QG(Mh);JX*=vec3(0.9,1.,0.9);BT=reflect(Fp,TL);JX=mix(JX,LQ(Mh,BT),0.2+0.8*pow(1.-abs(dot(TL,BT)),5.));}Pi=true;Qy=Hn(NS,Fp);if(Qy<min(ON,Lr)){Mh=NS+Qy*Fp;TL=FC(Mh);BT=reflect(Fp,TL);JX=mix(0.8*JX,LQ(Mh,BT),0.6);}return clamp(JX,0.,1.);}void mainImage(out vec4 RS,in vec2 TD){mat3 YS;vec4 XP;vec3 BT,Mh,JX,Pv,AD;vec2 SR,Eq,CF,Im;float Xq,ID,Dw,PY,Uc,UK,Ut;\nVJ=iFrame;SR=iResolution.xy;Eq=2.*TD.xy/SR-1.;Eq.x*=SR.x/SR.y;Id=iTime;\nDw=SR.x/SR.y;XP=Bh(1);FK=XP.xyz;Hv=FK.y;SI=XP.w;XP=Bh(2);PQ=XP.x;Ha=XP.y;OA=XP.z;Uc=XP.w;XP=Bh(3);ID=XP.x;Xq=XP.y;Im=XP.zw;XP=Bh(4);Bl=XP.y;Go=mod(vec2(floor(XP.w),floor(XP.w/100.)),100.);XP=Bh(5);Wn=XP;XP=Bh(6);Jg=XP;Xq=clamp(Xq-0.1*Xd,-0.49*Xd,0.02*Xd);YS=ZA(Xq,ID);Mh=Wn.xyz+YS*vec3(0.,1.,-12.);Mh.y+=2.;Wn.y+=Hv;PY=3.5+2.*Xq;Lr=400.;CW=normalize(vec3(1.,2.,-1.));CW.xz=Ro(CW.xz,-ID);const float QC=1.;JX=vec3(0.);Ut=2.*mod(dot(mod(floor(0.5*(Eq+1.)*SR),2.),vec2(1.)),2.)-1.;for(float a=float(OE);a<QC;a++){BT=YS*normalize(vec3(Eq+step(1.5,QC)*Ro(vec2(0.5/SR.y,0.),Ut*(0.667*a+0.5)*Xd),PY));JX+=(1./QC)*Iu(Mh,BT);}AD=vec3(0.41,-0.32,0.135);CF=0.5*Eq-AD.xy*vec2(Dw,1.);UK=(length(CF)-AD.z)*SR.y;JX=mix(vec3(0.,1.,1.),JX,smoothstep(0.,1.,abs(UK)-1.));if(UK<0.){JX=mix(vec3(0.,1.,1.),JX,step(1.,ED(abs(CF))*SR.y));Pv=(OA>0.)?vec3(0.,1.,0.):vec3(0.8,0.,0.);JX=mix(Pv,JX,smoothstep(2.5,3.5,abs(length(CF-Im)*SR.y-10.)));CF=Ro(CF,atan(Im.y,-Im.x));if(CF.x<0.&&(length(Im)-length(CF))*SR.y>10.)JX=mix(Pv,JX,smoothstep(1.5,2.5,abs(CF.y)*SR.y));}JX=mix(JX,vec3(0.,1.,1.),GJ(0.5*Eq-vec2(0.44*Dw,-0.15),vec2(0.06*Dw,0.03),4.,mod(floor(Uc/(2.*Hv)),1e4)));RS=vec4(JX,1.);}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define VN iChannel0\n#define Zj iChannelResolution[0].xy\nconst float Xd=3.1415927;const float Xy=128.;const int CB=32;const int AQ=7;vec4 Wn;vec3 FK;float PQ,Ha;int VJ;float Jc(vec2 TH,vec2 UK,float BT){return length(max(abs(TH)-UK,0.))-BT;}float NB(float Zw,float Yt,float ww,float xx){return(1.-smoothstep(Yt-ww,Yt+ww,xx))*smoothstep(Zw-ww,Zw+ww,xx);}vec2 Ro(vec2 RF,float BL){vec2 VW;VW=sin(BL+vec2(0.5*Xd,0.));return vec2(dot(RF,vec2(VW.x,-VW.y)),dot(RF.yx,VW));}vec4 Bh(int By){float Ow;Ow=float(By);return texture(VN,(vec2(mod(Ow,Xy),floor(Ow/Xy))+0.5)/Zj);}void Yg(int By,vec4 Li,inout vec4 HE,vec2 Jp){vec2 XH;float Ow;Ow=float(By);XH=abs(Jp-vec2(mod(Ow,Xy),floor(Ow/Xy))-0.5);if(max(XH.x,XH.y)<0.5)HE=Li;}bool Ql(){vec2 TH;bool MP;MP=true;for(int Up=0;Up<6;Up++){if(Up<=1||Up>=4){TH=Wn.xz-Ro((vec2(2.*mod(float(Up),2.),float(Up/2))-1.)*FK.xz,-Wn.w);MP=(Jc(mod(TH+0.5*PQ,PQ)-0.5*PQ,vec2(0.5*PQ)-2.*Ha,Ha)>0.);if(!MP)break;}}return MP;}void mainImage(out vec4 RS,in vec2 TD){vec4 HZ,JK,XP,XY,Jg,MC;vec3 AD;vec2 GF,SR,Im,SA,CF,ww,SZ;float JO,Id,Fh,Ul,Hv,Bl,SI,Lv,Uc,OA,Gs,Em,ID,Xq,Dw,UK;int PU,Co;bool Kb;GF=floor(TD);PU=int(GF.x+Xy*GF.y);if(PU>=AQ+CB)discard;\nVJ=iFrame;SR=iResolution.xy;Id=iTime;JO=iDate.w;HZ=iMouse;HZ.xy=HZ.xy/SR-0.5;\nKb=(VJ<=1);Dw=SR.x/SR.y;if(Kb){PQ=80.;Lv=mod(floor(1000.*JO),10000.);Wn=vec4(0.5*PQ+3.,0.,0.,0.);Bl=0.;Hv=0.5;FK=vec3(1.4,Hv,1.5);Jg=vec4(0.);ID=-0.3*Xd;Xq=-0.1*Xd;Em=0.;Im=vec2(0.);JK=HZ;Co=0;Fh=1.;Ha=5.;OA=0.;Uc=0.;}else{XP=Bh(0);JK.xyz=XP.xyz;Co=int(XP.w);XP=Bh(1);FK=XP.xyz;XP=Bh(2);PQ=XP.x;Ha=XP.y;OA=XP.z;Uc=XP.w;XP=Bh(3);ID=XP.x;Xq=XP.y;Im=XP.zw;XP=Bh(4);Em=XP.x;Bl=XP.y;Fh=XP.z;Lv=XP.w;XP=Bh(5);Wn=XP;XP=Bh(6);Jg=XP;}if(PU<AQ){AD=vec3(0.41,-0.32,0.135);if(HZ.z>0.){if(Co==0&&JK.z>0.){ID=-2.*Xd*HZ.x;Xq=-Xd*HZ.y;}else{CF=HZ.xy*vec2(Dw,1.)-AD.xy*vec2(Dw,1.);if(Co==1){Fh=-Id;Im=CF;UK=length(Im);if(UK>0.)Im=min(UK,AD.z)*Im/UK;}else if(JK.z<=0.&&length(CF)<AD.z)Co=1;}}else{Co=0;Im*=vec2(1.-1e-2,1.-2e-3);}Hv=FK.y;++Em;if(Fh>0.){Gs=mod(0.004*Em,4.);Bl=0.04*Xd*NB(0.3,0.7,0.1,mod(Gs,1.))*sign(mod(Gs,2.)-1.)*sign(Gs-2.);SI=0.7*(0.12-0.06*abs(Bl/(0.15*Xd)));ww=vec2(-Bl/(0.15*Xd),SI/0.5);ww=pow(abs(ww),1./vec2(1.5))*sign(ww);Im=ww*AD.z;}else{ww=Im/AD.z;ww=pow(abs(ww),vec2(1.5))*sign(ww);Bl=-0.15*Xd*ww.x;SI=0.2*ww.y*smoothstep(0.01,0.02,abs(ww.y));if(Id+Fh>20.)Fh=1.;}XY=Wn;SA=Wn.xz;MC=vec4(1.);if(abs(Bl)>1e-4){Ul=Wn.w-Bl*SI/Xd;SZ.x=FK.z/asin(Bl);UK=FK.z/SZ.x;SZ.y=SZ.x*sqrt(1.-UK*UK);Wn.xz+=2.*SZ.x*(sin(Wn.w-vec2(0.5*Xd,0.))-sin(Ul-vec2(0.5*Xd,0.)));Wn.w=mod(Ul,2.*Xd);MC+=FK.x*vec4(-1.,1.,-1.,1.)/SZ.xxyy;}else{Wn.xz+=SI*sin(Wn.w+vec2(0.,0.5*Xd));}OA=Ql()?1.:0.;if(OA>0.){Jg+=MC*SI/Hv;if(SI>0.)Uc+=length(Wn.xz-SA);}else{Wn=XY;SI=0.;Uc=0.;}}if(!Kb){if(mod(float(VJ),12.)==0.){if(PU==AQ)XP=vec4(Bh(5).xzw,Id);else if(PU<AQ+CB)XP=Bh(PU-1);}else if(PU>=AQ&&PU<AQ+CB)XP=Bh(PU);}else{XP=vec4(0.,0.,-1.,0.);}if  (PU==0)XP=vec4(HZ.xyz,float(Co));else if(PU==1)XP=vec4(FK,SI);else if(PU==2)XP=vec4(PQ,Ha,OA,Uc);else if(PU==3)XP=vec4(ID,Xq,Im);else if(PU==4)XP=vec4(Em,Bl,Fh,Lv);else if(PU==5)XP=Wn;else if(PU==6)XP=Jg;Yg(PU,XP,RS,TD);}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsBW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[678, 678, 704, 704, 786], [786, 786, 812, 812, 884], [884, 884, 919, 919, 957], [957, 957, 992, 992, 1045], [1045, 1045, 1080, 1080, 1118], [1118, 1118, 1154, 1154, 1197], [1197, 1197, 1242, 1242, 1305], [1305, 1305, 1341, 1341, 1406], [1406, 1406, 1450, 1450, 1660], [1660, 1660, 1696, 1696, 1743], [1743, 1743, 1761, 1761, 1784], [1784, 1784, 1802, 1802, 1825], [1825, 1825, 1862, 1862, 1934], [1934, 1934, 1971, 1971, 1994], [1994, 1994, 2021, 2021, 2164], [2164, 2164, 2190, 2190, 2278], [2278, 2278, 2303, 2303, 2356], [2356, 2356, 2373, 2373, 2467], [2467, 2467, 2485, 2485, 2565], [2565, 2565, 2590, 2590, 2977], [2977, 2977, 3021, 3021, 3260], [3284, 3284, 3302, 3302, 3351], [3351, 3351, 3368, 3368, 3449], [3449, 3449, 3466, 3466, 3547], [3547, 3547, 3566, 3566, 3668], [3668, 3668, 3686, 3686, 3813], [3813, 3813, 3832, 3832, 3933], [3933, 3933, 3951, 3951, 4052], [4052, 4052, 4078, 4078, 4220], [4220, 4220, 4254, 4254, 4450], [4470, 4470, 4486, 4486, 4567], [4567, 4567, 4585, 4585, 6785], [6786, 6786, 6812, 6812, 6957], [6957, 6957, 6974, 6974, 7166], [7166, 7166, 7184, 7184, 7288], [7288, 7288, 7314, 7314, 7458], [7458, 7458, 7475, 7475, 7667], [7667, 7667, 7693, 7693, 7887], [7887, 7887, 7897, 7897, 7975], [7975, 7975, 7993, 7993, 8430], [8430, 8430, 8456, 8456, 8819], [8819, 8819, 8836, 8836, 9039], [9039, 9039, 9065, 9065, 9346], [10171, 10171, 10188, 10188, 10303], [10303, 10303, 10330, 10330, 10392], [10392, 10392, 10410, 10410, 10575], [10575, 10575, 10610, 10610, 11229], [11229, 11229, 11254, 11254, 11763], [11763, 11763, 11785, 11785, 13177], [13177, 13177, 13202, 13202, 13253], [13254, 13254, 13277, 13277, 13915], [13915, 13915, 13940, 13940, 15294], [15294, 15294, 15333, 15333, 16648]]}
{"id": "sslBDj", "name": "Zebra Valley 2b", "author": "FabriceNeyret2", "description": "pseudo-shaded variant of https://shadertoy.com/view/sdlfRj\n\nref: https://twitter.com/JuhaniHalkomaki/status/1493836353410371586", "tags": ["2tweets", "short", "reproduction"], "likes": 53, "viewed": 808, "published": 3, "date": "1645435018", "time_retrieved": "2024-07-30T17:02:18.131088", "image_code": "// pseudo-shaded variant of https://shadertoy.com/view/sdlfRj\n// + animated zoom\n\n// Xor golfed down 12 chars. See more readable version below\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= 7./R;\n    O-=O;\n    for(float i=-60.,a,z = 3.+sin(iTime/2.); i++ < 9.;\n        O += ( mod(i,2.)* ( .7 - .3*sin(a) ) - O ) \n            * smoothstep(0.,15./R.y, 4./z*cos(a) -i/6. - U.y ))\n        a = z*.5* ( U.x - sin( i/6. + iTime ) );\n}\n\n\n\n\n\n/**  // 232 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= 7./R;\n    O-=O;\n    for(float i=0.,a,z = 1.5+.5*sin(iTime/2.); i++ < 70.; )\n        a = z* ( U.x + sin( i/6. + iTime ) ),\n        O = mix(O, vec4(int(i)%2)* ( .7 - .3*sin(a) ), \n                smoothstep(0.,15./R.y, 10.-i/6. + 2./z*cos(a) - U.y ) );\n}\n\n/**/\n\n\n\n\n/* // --- optimized version  ( +16 )\n\n    for(float i=-18.,v; i++ < 11.; ) \n        v = 2.*cos(U.x + sin(i/6.-ceil(U.y) + iTime ) ) -i/6. - fract(U.y),\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 182, 182, 458]]}
{"id": "7ssBzs", "name": "litle demo", "author": "olegbug", "description": "made in < 10 min and low skil", "tags": ["demo"], "likes": 3, "viewed": 171, "published": 3, "date": "1645432436", "time_retrieved": "2024-07-30T17:02:18.926960", "image_code": "#define PI 3.14159\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 px = vec2(sin(iTime/5.),cos(iTime/10.))/2.+0.5;\n    vec2 uv = fragCoord/iResolution.xy-px;\n\n    vec2 pos = vec2((atan(uv.x,uv.y)+PI)/(PI),0.5/length(uv));\n\n    vec4 tex0 = texture(iChannel0, pos+vec2(0.,iTime));\n    // Output to screen\n    fragColor = tex0*length(uv);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 126, 406]]}
{"id": "fssBW2", "name": "Fractal knots 5", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 2, "viewed": 237, "published": 3, "date": "1645419176", "time_retrieved": "2024-07-30T17:02:19.764720", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n\n    vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 12; k++){\n\n            uv -= (t2.yx);\n            //uv -= (t2.yx)/(1.+(t2.x-t2.y)/4.);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx+.5,scale);\n            t3 = triangle_wave(uv,scale);\n            //t2 = triangle_wave(uv.yx+.5,scale)/(1.+t2);\n            //t3 = triangle_wave(uv,scale)/(1.+t3);\n            \n            uv.yx = t3-t2;\n\n        col.x = 1.-abs(uv.x+uv.y+col.x);\n        col = col.yzx;\n        \n        //col.x = abs(uv.x+uv.y-col.x*2.);\n        //col = abs(1.-col.yzx);\n        \n        uv /= scale*scale;\n        //uv /= 1.+temp.yx;\n      }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1177]]}
{"id": "NdsfDj", "name": "sphere bouncing", "author": "xnio94", "description": "i was just trying to see how much time i need to create a basic raymarcher from scratch (it was 25min)", "tags": ["ray", "marching"], "likes": 1, "viewed": 174, "published": 3, "date": "1645413365", "time_retrieved": "2024-07-30T17:02:20.516709", "image_code": "float bounce(float dh,float a)\n{\n    if (dh==0.) return 0.;\n    float g=10.;\n    float v0 = sqrt(dh*4.*g);\n    float t = mod(iTime + a*v0/g+ 0.*v0/g,v0/g); \n    return -g*t*t+v0*t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    vec3 rd = vec3(uv,1.);\n    rd = normalize(rd);\n    vec3 o =vec3(sin(5.+5.*sin(iTime*5.))*.1,0.,iTime*4.);\n    vec3 n=vec3(0.);\n    float d = 0.;\n    float e = 0.;\n    float shadow = 1.;\n\n    for(int i =0;i<99;i++)\n    {\n        vec3 p = o+d*rd;\n        vec3 qq = p;\n        p.xz = mod(p.xz,2.)-1.;\n        float s = p.z-qq.z;\n        \n        float a =length(p+vec3(0.,-bounce(.3,s/5.),0.))-.5;\n        float b = p.y+.5;\n        if(a < b)\n        {\n            e = a;\n            n =.5*(mod(iTime*5.+s,2.)+1.)*normalize(p);\n        }\n        else \n        {\n            e = b;\n            n = vec3(0.,1.,0.);\n            \n        }\n        d +=e;\n    }\n    float col;\n    vec3 sun = vec3(cos(iTime*7.),1.,sin(iTime*5.));\n    sun=normalize(sun);\n    \n    \n    if(n==vec3(0.,1.,0.))\n    {\n        vec3 p = o+d*rd;\n        float d2=0.;\n        float ee = 1.;\n        for(int i =0;i<36;i++)\n        {\n            vec3 q = p+d2*sun;\n            vec3 qq = q;\n\n            q.xz = mod(q.xz,2.)-1.;\n        float s = q.z-qq.z;\n            ee = length(q+vec3(0.,-bounce(.3,s/5.),0.))-.5;\n            d2+=ee;\n        }\n        if (ee<1e-2)\n        {\n            shadow = 0.;\n        }\n    }\n    \n\n    \n    if(e<1e-4) \n    {\n        col = shadow * max(0., dot(n,sun))/d;\n    }\n    else col = 0.;\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 182], [183, 183, 240, 290, 1683]]}
{"id": "NdsBWj", "name": "line spiral E", "author": "SnoopethDuckDuck", "description": "quite laggy, doesnt start at the right place", "tags": ["e"], "likes": 12, "viewed": 300, "published": 3, "date": "1645407351", "time_retrieved": "2024-07-30T17:02:21.338512", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float px = 128.;\n    // uv = floor(px * uv) / px;\n       \n    /*\n    float r = length(uv);\n    float a = atan(uv.x, uv.y) - 4. * r;\n    //r = log(r);\n    uv = r * vec2(cos(a), sin(a));\n    */\n    \n    float h = h21(uv);\n    \n    // change me\n    float a1 = 10.; // any number is good here\n    float a2 = a1 + 1.;\n    float sc = 0.5; // higher -> more square (use 0.001 instead of 0)\n    \n    float th = .01;//mix(0.03, 0.005, 1.-m); //0.0025;\n    \n    float t = .2 * iTime;\n    float n = 100.;\n    \n    float d = 10.;\n    float s = 0.;\n    \n    float myi = 0.;\n    \n    for(float i = 0.; i < n; i++) {\n        float o = 1. * pi * i / n;\n        \n        float r = 0.42 * (0.5 + 0.5 * thc(50., 2. * t + 1. * o));\n        \n        vec2 p = r * vec2(thc(sc, t + a1 * o), ths(sc, t + a1 * o));\n        vec2 q = -r * vec2(thc(sc, t + a2 * o), ths(sc, t + a2 * o));\n        float d2 = sdSegment(uv, p, q);\n        if (d2 < d) {\n            d = d2;\n            myi = i;\n        }\n    }\n    \n    float k = 1./iResolution.y;\n    s = smoothstep(-k, k, -d + th);\n    \n    vec3 col = vec3(s);\n    \n    vec3 e = vec3(1.);\n    col *= pal(myi / n, e, e, e, 0.4 * vec3(0,1,2)/3.);\n    col = sqrt(col + 0.02);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [174, 174, 231, 231, 1532]]}
{"id": "7sfBW2", "name": "blueball on/of", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 1, "viewed": 230, "published": 3, "date": "1645399167", "time_retrieved": "2024-07-30T17:02:22.329862", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-10.; i<=0.75; ++i) {\n\t\tfor(float j=-2.; j<=0.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.01,02.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 044.1031);\n    p *= p + 33.33;\n    return fract(0.4*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * 33.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.3) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<1;\n\tbool lightsilver = section>2 && section<12;\n\tbool lightgreen = section>5;\n\tbool lightpink = section>7 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 15;\n\tint sphmax = 15;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=100.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.1:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1416]]}
{"id": "ssXfW2", "name": "Fractal knots 4", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 9, "viewed": 288, "published": 3, "date": "1645396581", "time_retrieved": "2024-07-30T17:02:23.116758", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a = abs(a);\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        //uv -= (t2.yx)/scale;\n        uv -= (t2.yx);\n        //uv -= (t2.yx)*(.25+(t2.x+t2.y));\n        \n        t2 = triangle_wave(uv.yx-.5,scale);\n        //t2 = triangle_wave(uv.yx-.5,scale)/(1.+t2);\n\n        //t2 = triangle_wave(uv.yx-.5,scale)*(1.-t2/3.);\n\n        \n        uv.yx = (triangle_wave(uv,scale)-t2)/scale;\n        col.x = abs(uv.y+uv.x-col.x);\n        col = abs(col.yzx);\n        //col.x = abs(uv.y+uv.x-col.x*2.);\n        //col = abs(col.yzx-1.);\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 138, 183], [185, 185, 242, 242, 994]]}
{"id": "fslBDS", "name": "linesegmentestsiethsieptsetset", "author": "SnoopethDuckDuck", "description": "idk what this is", "tags": ["e"], "likes": 7, "viewed": 232, "published": 3, "date": "1645395791", "time_retrieved": "2024-07-30T17:02:24.048267", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.5 + 0.5 * thc(6., 0.5 * iTime);\n    \n    // change me\n    float a1 = 1. + 4. * m;\n    float a2 = 1.;// * uv.x;\n    float sc = 0.01;// + 3.99 * m; // sc = 0.01 is basically cos \n    \n    float th = mix(0.03, 0.005, 1.-m); //0.0025;\n    \n    float t = .5 * iTime;\n    t += 4. * m * length(uv);\n    float n = 50.;\n    \n    float d = 10.;\n    float s = 0.;\n    \n    float myi = 0.;\n    \n    for(float i = 0.; i < n; i++) {\n        float o = 1. * pi * i / n;\n        \n        float r = 0.45;// * (0.5 + 0.5 * thc(10., t + 0. * o));\n        \n        float c = cos(t + o), b = sin(t + o);\n        vec2 p = r * vec2(thc(sc, t + a1 * o), ths(sc, t + a2 * o));\n        vec2 q = r * vec2(thc(sc, t + a1 * b * o), ths(sc, t + a2 * c * o));\n        float d2 = sdSegment(uv, p, q);\n        if (d > d2) {\n            d = d2;\n            s = max(s, step(d, th));\n            myi = i;\n        }\n    }\n    \n    //s = step(d, 0.025);\n    \n    vec3 col = vec3(s);\n    \n    vec3 e = vec3(1.);\n    col *= pal(1.-myi / n, e, e, e, 0.45 * vec3(0,1,2)/3.);\n    col = sqrt(col + 0.02);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [174, 174, 231, 231, 1411]]}
{"id": "ssXBW2", "name": "torus-esfera", "author": "jorge2017a2", "description": "torus-esfera", "tags": ["torusesfera"], "likes": 10, "viewed": 233, "published": 3, "date": "1645394141", "time_retrieved": "2024-07-30T17:02:25.269004", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//referencia FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 RotarEsferas(vec3 p)\n{\n  vec3 p0=p;  \n float nesf=14.0;\n float ang=360.0/nesf;\n vec2 dfin=vec2(9999.9 ,-1.0);\n \n p0= rotate_y(p0-vec3(0.0,0.0,0.0), radians(-iTime*50.0));\n \n for (float i=0.0; i<nesf;i++)\n    {   \n        vec3 p3= rotate_y(p0, radians(ang*i));\n        float d3= sdSphere(p3-vec3(15.0,0.0,0.0), 1.0 );\n        dfin=opU2( dfin, vec2( d3,float(i)+1.0));\n        \n    }\n    return dfin;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.y=p.y-5.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n   \n    res =opU2(res, vec2(planeDist1,57.0));\n    vec2 re1= RotarEsferas(p );\n    res =opU2(res, re1);\n   \n    p=p0;\n    \n    float d1=sdTorus( p, vec2(15.0,2.0) );\n    float d2=sdTorus( p, vec2(15.0,1.8) );\n    float d3=sdBox( p-vec3(0.0,1.0,-10.5), vec3(17.0,1.5,7.0) );\n    d1= differenceSDF(d1, d2);\n    d1= differenceSDF(d1, d3);\n    \n    res =opU2(res, vec2(d1,60.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    \n    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n\n    }\n    return object;\n\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = occlusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   \n    return colOut;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{\n            colobj=getColor(int( id_color)); \n            return colobj;\n        }\n    \n    if (id_color==57)\n        {return pattern( p.xz );}\n    if (id_color==58)\n        {return pattern( p.xy );}\n    if (id_color==59)\n        {return pattern( p.zy );}\n        \n     if (id_color==60)\n   {   vec3 mat = vec3(0.8, 0.2, 0.2);\t\n\t\tfloat f = smoothstep(0.3, 0.3001, mod(atan(p.x, p.z), 0.65));\n        mat = mix(mat, vec3(0.7, 0.7, 0.8), 1.0 - f);\n        return mat;\n   }\n   \n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    \n\t    \n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-28.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    if (i>-1 ) return Arrcolores[i];  }\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 486, 522, 522, 543], [544, 544, 576, 576, 660], [661, 661, 695, 695, 757], [758, 758, 805, 805, 832], [833, 833, 876, 876, 903], [904, 904, 952, 952, 980], [981, 1019, 1055, 1055, 1100], [1101, 1126, 1160, 1160, 1256], [1257, 1257, 1291, 1291, 1382], [1383, 1383, 1417, 1417, 1508], [1510, 1510, 1537, 1537, 1915], [1917, 1917, 1942, 1942, 2445], [2447, 2447, 2471, 2471, 2633], [2635, 2635, 2683, 2683, 3022], [3025, 3025, 3069, 3069, 3395], [3397, 3397, 3434, 3434, 3695], [3697, 3697, 3782, 3782, 4744], [4746, 4746, 4839, 4839, 4969], [4971, 4971, 5003, 5003, 5200], [5202, 5250, 5278, 5278, 5466], [5469, 5469, 5537, 5537, 6058], [6061, 6061, 6088, 6088, 6177], [6179, 6179, 6237, 6237, 6285], [6288, 6288, 6311, 6311, 6429], [6431, 6431, 6462, 6462, 7083], [7086, 7086, 7143, 7143, 7589]]}
{"id": "7dfBDj", "name": "Sound Experiment #5", "author": "oneshade", "description": ".", "tags": ["sound", "experiment", "frequencies"], "likes": 9, "viewed": 204, "published": 3, "date": "1645391503", "time_retrieved": "2024-07-30T17:02:26.101777", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n\n    // Aspect correct, centered UVs and 2 pixel AA width for soft edges\n    uv = fragCoord / iResolution.y - vec2(0.0, 0.5);\n    float unit = 2.0 / iResolution.y;\n\n    // Graph sound wave (MUCH slower than actual speed)\n    float x = mod(0.02 * (uv.x + 2.0 * iTime), 11.0);\n    float graphDist = abs(uv.y - 0.5 * makeNoise(x));\n    float slope = 0.02 * (makeNoise(x + 0.0001) - makeNoise(x - 0.0001)) / 0.0002;\n    graphDist /= sqrt(slope * slope + 1.0);\n    graphDist += 0.0025;\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, graphDist));\n\n    fragColor = vec4(color, 1.0);\n\n    // Uncenter\n    uv += vec2(0.0, 0.5);\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat makeNoise(in float time) {\n    float sound = 0.0;\n\n    float t = 5.0 * time;\n    //float n = max(2.0, 6.0 * abs(mod(0.05 * floor(t) * floor(t), 2.0) - 1.0));\n    //float n = max(2.0, 6.0 * abs(mod(0.2 * pow(floor(t), 1.5), 2.0) - 1.0));\n    //float n = floor(6.0 * snoise(0.25 * floor(t))) + 2.0;\n\n    // Randomly hacked together\n    float s = floor(t);\n    float n = mod(s, 6.0) + mod(s, 2.0) + 2.0;\n    n += mod(s, mix(2.0, 4.0, step(1.0, mod(time, 5.0))));\n    n += floor(6.0 * snoise(0.25 * s));\n    n = floor(0.5 * n) + 1.0;\n\n    // Smooth transition to avoid clicks\n    t = fract(t);\n    float env = smoothstep(0.0, 0.08, min(t, 1.0 - t));\n\n    // Random frequencies that sound good together\n    // The gaussian weight filters out high frequencies\n    for (float i=0.0; i < 50.0; i++) {\n        float freq = floor(550.0 * floor(Hash11(i) * n) / n);\n        sound += sin(TAU * fract(freq * time)) * env * exp(-0.00001 * freq * freq) / 25.0;\n    }\n\n    return sound;\n}", "sound_code": "vec2 mainSound(in int samp, in float time) {\n    return vec2(makeNoise(float(samp % (11 * int(iSampleRate))) / iSampleRate));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1934]]}
{"id": "NsffD2", "name": "Spiral mapping in 3D", "author": "mrange", "description": "License CC0: Spiral mapping in 3D\nThis weekend has been messing with spiral mapping.\nThis is more of tech shader as I wanted to see if spiral mapping works in raymarcher\n", "tags": ["3d", "raymarching", "spiral"], "likes": 13, "viewed": 328, "published": 3, "date": "1645386265", "time_retrieved": "2024-07-30T17:02:27.096118", "image_code": "// License CC0: Spiral mapping in 3D\n// This weekend has been messing with spiral mapping.\n// This is more of tech shader as I wanted to see if \n// the spiral mapping would work ok a raymarcher or \n// if the discontinuity between the spiral arms would \n// cause too much artifacts\n// By applying a bit of backtracking it looks usable for my\n// purposes\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\nvoid spiralMod(inout vec2 p, float a) {\n  vec2 op     = p;\n  float b     = a/TAU;\n  float  rr   = length(op);\n  float  aa   = atan(op.y, op.x);\n  rr         -= aa*b;\n  float nn    = mod1(rr, a);\n  float sa    = aa + TAU*nn;\n  float sl    = spiralLength(b, sa);\n  p           = vec2(sl, rr);\n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p;\n  float d0 = sphere4(p0, 0.6);\n  d0 = abs(d0) - 0.025;  \n\n  vec3 p1 = p;\n  float d1 = p1.y;\n  \n  vec3 p2 = p;\n  const float a = 0.5;\n  spiralMod(p2.xz, a);\n  p2.x += 0.1*TIME;\n  float nsp_ = mod1(p2.x, a);\n  vec3 p3 = p2;\n  float h2 = hash(nsp_);\n  float t2 = TIME+h2;\n  float dt = mix(0.25, 0.66, h2);\n  mod1(t2, 2.0*dt);\n  float sr = mix(0.125, 0.25, fract(1336.0*h2));\n  p2.y -= sr*a+0.2*(dt*dt-t2*t2);\n  float d2 = sphere(p2, sr*a);\n  \n  float bd = a*sr*1.5;\n  p3.y -= bd;\n  float d3 = sphere4(p3, bd);\n  \n  float d = d1;\n  d0 = pmax(d0, -(d3 ), 0.1*a);\n  d = pmin(d, d0, 0.1);\n  d = min(d, d2);\n//  d = min(d, d3);\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  float sf = 1.0;\n  float pd = 0.0;\n  float pt = t;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE) {\n      // Because of distance field is discontinous when crossing the spiral arms\n      // Let's back track when we hit the surface and step a bit shorter\n      if (sf >= 0.25) {\n        t = pt;\n        d = pd;\n        sf *= 0.5;\n      } else {\n        break;\n      }\n    }\n    pt =  t;\n    pd =  d;\n    t  += sf*d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0,1.2,1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n\n  float sr    = 0.6;\n  float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);\n\n  vec3 gcol   = sd*sd*1.5*vec3(2.0, 1.0, 0.75)*1.0;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return vec3(0.0);\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ifade = exp(-0.5*max(t-2.0, 0.0));\n  float h     = fract(-1.0*length(pos)+0.1);\n  float s     = 0.25;\n  float v     = tanh_approx(0.4/(1.0+40.0*sd));\n  vec3 color  = hsv2rgb(vec3(h, s, v));\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.05, 10.0);\n\n  float dm  = 8.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;  \n  float spe = pow(max(dot(refl, ld), 0.), 30.);\n  float l   = mix(0.2, 1.0, dif*sha);\n  \n  vec3 col = l*color*ifade + 2.0*spe*sha*sqrt(ifade);\n  return gcol+col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float a   = TIME*TAU/20.0-PI*0.5;\n  float h   = smoothstep(0.5, 1.0, 0.5-0.5*cos(a));\n  vec3 cam  = vec3(1.5, .66+2.0*h, 0.0);\n  cam.xz    *= ROT(a);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.25*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsffD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[712, 812, 833, 833, 906], [907, 1007, 1029, 1029, 1078], [1080, 1140, 1168, 1188, 1264], [1266, 1319, 1341, 1341, 1510], [1512, 1572, 1594, 1594, 1642], [1644, 1727, 1766, 1766, 1855], [1857, 1857, 1896, 1896, 1925], [1927, 2021, 2079, 2079, 2560], [2562, 2562, 2593, 2593, 2619], [2621, 2621, 2653, 2653, 2700], [2702, 2788, 2827, 2827, 2952], [2954, 2954, 2992, 3046, 3103], [3105, 3105, 3144, 3144, 3397], [3399, 3399, 3417, 3417, 4067], [4069, 4069, 4117, 4117, 4719], [4721, 4721, 4744, 4744, 4952], [4954, 4954, 5022, 5022, 5301], [5303, 5303, 5334, 5334, 6373], [6375, 6375, 6406, 6406, 6848], [6850, 6850, 6905, 6905, 7083]]}
{"id": "fsffDj", "name": "Fork Fork mirro firebreath 433", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 4, "viewed": 246, "published": 3, "date": "1645377468", "time_retrieved": "2024-07-30T17:02:28.550230", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.5;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(131.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 5.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/8.);\n\tfloat rest = mod(time,8.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*10. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 20.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*840.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.007)*0.1,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 1.001 + mval.y;\n\tfloat dofamount=0.00001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<4;\n\tbool lightsilver = section>1 && section<12;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = !(section>10);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,1.);\n     // motion slowing down during the last section\n\tfloat t2=section!=16?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*1.1 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 5. : 5.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.6)*17.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.3+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 4.-k*rrad;\n\t\t\t\trad2 = 4.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=1000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.3,0.8,1)*0.4, vec3(1,0.7,0.5) * 1., max(r.x+r.z*.3-r.y*.3,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.1,0.1,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.9,1);\n                    col += alpha * smoothstep(0.5,0.1,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.2+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*1.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.009,0.001,fract(time*.005+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.001+floor(r.z*sqsize)*0.02))) * 1. * (rnd33(floor(r*sqsize)+floor(time)*.0037)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*1.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*0.000033);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.1)?.4:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*7.,j*5)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsffDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1402]]}
{"id": "NdlBzS", "name": "heart core (fail)", "author": "hnh", "description": "Fork of [url]https://www.shadertoy.com/view/NsffWN[/url]\nDeserves 15 hearts ;-)", "tags": ["love", "foolishness"], "likes": 2, "viewed": 218, "published": 3, "date": "1645372093", "time_retrieved": "2024-07-30T17:02:29.358070", "image_code": "\n/*\nUnfortunately, this shader does not work on many systems as intended \nsince it is very sensitive on precision (see comments).\nPlease use the test flag below to see which numbers (int(iTime)) look \ngood on your system. Compare with array va.\n*/\n//#define test\n\n#define PI 3.14159265\n\n\nvec4 flip(vec2 p, float pi) {\n    vec3 a = vec3(0.0998); int ni = 58;  // parameters\n    vec3 q= vec3(p, .06);  // scale\n    vec3 t;\n    for(int i=0; i<ni; i++) {\n        a = sin(a);  // works by accident\n        a = vec3(1.-a.y-a.x,a.y,a.x)*pi;\n\n        vec3 c = cos(a), s = sin(a);\n        mat3 N= mat3(1, 0, 0,\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);\n    \n        for(int j=0; j<3; j++) {\n            t[j] = dot(q, N[j]);\n            if(t[j] < 0.) {q -= 2.*t[j]*N[j]*vec3(1,1,0);}\n        }\n    }\n\t// q.xy: cartesian coords, t.xyz: triangle normal coords (t.x = q.x)\n    return vec4(q.xy, t.yz);\n}\n\n\n#ifdef test\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    U = (U - .5*iResolution.xy)/iResolution.y;        \n    float pi = PI*(1. + floor(iTime)*1e-7);\n    O = flip(U,pi);\n    O = vec4(dot(O,vec4(0,50,-30,0)));\n}\n\n#else\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    int[] va = int[](92,-22,-33,-60,-66,16,24,33,45,48,49,55,56,63,75);  // 15 patterns\n    int na = 15;\n    float a = 5., b = 6.;\n    float t = iTime - .9;\n    float f = sin(-t/b*PI);\n    t += f*f*2.5;\n    \n    U = (U - .5*iResolution.xy)/iResolution.y;\n\n    float l = length(U);\n    f = (log(l) - t + a)/b;    \n    int n = int(1.-f);  // pattern index\n    f = fract(f);\n    float l2 = exp(f*b - a);\n    f = smoothstep(.5,.4,abs(.5-f));  // for gentle transitions\n    f = min(f,l/l2);\n    U *= l2/l;\n    \n    float v = float(va[n%na]);\n    float pi = PI*(1. + v*1e-7);  // slight bend\n    \n    O = flip(U,pi);  // -> flipped coords\n    O = f*vec4(dot(O,vec4(0,50,-30,0)));  // weighted sum\n    \n}\n\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 317, 317, 926]]}
{"id": "fdXfWj", "name": "Fork mirror lights v4", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 3, "viewed": 238, "published": 3, "date": "1645371424", "time_retrieved": "2024-07-30T17:02:30.334460", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.5;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(131.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 5.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/8.);\n\tfloat rest = mod(time,8.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*10. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 20.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*840.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.007)*0.1,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 1.001 + mval.y;\n\tfloat dofamount=0.00001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<4;\n\tbool lightsilver = section>1 && section<12;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = !(section>10);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,1.);\n     // motion slowing down during the last section\n\tfloat t2=section!=16?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*1.1 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 5. : 5.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.6)*17.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.3+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 4.-k*rrad;\n\t\t\t\trad2 = 4.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=1000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.3,0.8,1)*0.4, vec3(1,0.7,0.5) * 1., max(r.x+r.z*.3-r.y*.3,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.1,0.1,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.9,1);\n                    col += alpha * smoothstep(0.5,0.1,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.2+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*1.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.009,0.001,fract(time*.005+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.001+floor(r.z*sqsize)*0.02))) * 1. * (rnd33(floor(r*sqsize)+floor(time)*.0037)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*1.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*0.000033);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.4)?.04:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*7.,j*5)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1402]]}
{"id": "NsffWj", "name": "Inflate/Deflate 3d SDF", "author": "erratac", "description": "Simple inflate offsetting based on a similar method to the elongation operation mentioned in article: https://iquilezles.org/articles/distfunctions/distfunctions.htm", "tags": ["raymarching", "distancefield", "sdf", "distance", "inflate"], "likes": 3, "viewed": 304, "published": 3, "date": "1645370911", "time_retrieved": "2024-07-30T17:02:33.268615", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(vec2(c, -s), vec2(s, c));\n}\n\n// This operation is based on the technique of elongation \n// https://iquilezles.org/articles/distfunctions\n\n// This does not create a true distance field, but does not distort the field too much.\n// If the shape is centered on the origin the distortion works well.\n// If the shape is concave however, this will not work well.\n// Note that just like the elongation method it produces zero length gradient in the center region\n// This can break boolean operations like intersection and subtraction.\nvec3 inflate(vec3 p, float r) {\n    float pl = length(p);\n    vec3 n = p / pl;\n    return p - n * clamp(pl, -r, r);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map( in vec3 p ) {\n    mat2 rot = Rot(iTime);\n    const float scale = 0.6;\n\n    float d = 1e10;\n    \n    \n    {\n        vec3 p2 = p + vec3(-1.0, 0, 0);      \n        p2.xz = p2.xz * rot;\n        \n        p2 /= scale;\n\n        float factor = (sin(iTime) + 0.6) * 0.3;\n\n        p2 = inflate(p2, factor);\n\n        d = min(sdOctahedron(p2, 0.5) * scale, d);\n    }\n    {\n        vec3 p2 = p + vec3(1.0, 0, 0);      \n        p2.xz = p2.xz * rot;\n        \n        p2 /= scale;\n\n        float factor = (sin(iTime) + 0.6) * 0.3;\n\n        p2 = inflate(p2, factor);\n        \n        \n        float d1 = sdSphere(p + vec3(1.0, 0, 0), 0.47);\n        float d2 = sdOctahedron(p2, 0.5) * scale;\n\n        d = min(max(d1,-d2), d);\n    }\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n\tvec3 ro = vec3( 0.0, 0.2, -2.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsffWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 64, 64, 138], [249, 638, 669, 669, 755], [757, 757, 795, 795, 1075], [1076, 1076, 1109, 1109, 1137], [1139, 1139, 1163, 1163, 1880], [1882, 1928, 1960, 1960, 2199]]}
{"id": "fdffz2", "name": "Synthwave city", "author": "nyri0", "description": "More synthwave stuff \\o/\nI've cut a lot of corners to get this one running smoothly. Feel free to play with FSAA if your GPU is a beast (4 or +) or you like pixels (1).", "tags": ["city", "car", "synthwave"], "likes": 17, "viewed": 770, "published": 3, "date": "1645360992", "time_retrieved": "2024-07-30T17:02:34.428513", "image_code": "const int FSAA = 2;\nconst float EPS = 0.01;\nconst float FOVH = 70.0;\nconst float D = 0.1;\nconst float L = 200.0;\nconst int MAX_ITER = 100;\nconst float ROAD_RADIUS = 4.;\nconst float SPEED = 2.;\n\nconst vec3 CYAN = vec3(0.4,.95,1);\nconst vec3 PINK = vec3(1,.2,.9);\nconst vec3 BLACK = vec3(0,0,0);\n\n// From https://www.shadertoy.com/view/Msf3WH\nvec2 hashv( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hashv(i+0.0)), dot(b,hashv(i+o)), dot(c,hashv(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// Minimum of distance wit hcolor.\nvec4 min_sdf(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\n// From https://www.shadertoy.com/view/WttXWX\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//vec4 hash_vec4(uint x)\n//{\n//    uint hash_ = hash(x);\n//    return vec4(\n//        hash_ & 0xffU,\n//        (hash_ >> 8) & 0xffU,\n//        (hash_ >> 16) & 0xffU,\n//        (hash_ >> 24) & 0xffU\n//    ) / float(0xffU);\n//}\n\nvec4 sdf_building( vec3 p, vec3 col, vec3 b, bool get_color)\n{\n  vec3 q = abs(p) - b;\n  float sdf_ = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  if(get_color) {\n      vec3 bdv = smoothstep(vec3(-.6), vec3(-.4), q);\n      float bd = max(bdv.x*bdv.y, max(bdv.x*bdv.z, bdv.y*bdv.z));\n      col = mix(col, CYAN, bd);\n  }\n  return vec4(col,sdf_);\n}\nfloat sdf_box( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Color in xyz and sdf in w.\nvec4 sdf(in vec3 pos, bool get_color) {\n    vec4 sdf_ = vec4(0,0,0,1000);\n\n    const float R_0_X = 32.;\n    const float R_0_Z = 32.;\n    const float R_0_D = 100.;\n    const int GM = 2;\n    const int GN = 2;\n    const float w = R_0_X/float(GN);\n    const float we = .325*w;\n    vec3 col;\n    if(get_color) {\n        uint col_hash = hash(uint(.6*abs(pos.x)) + (uint(1.5*abs(pos.y))<<12) + (uint(.6*abs(pos.z))<<16) + (pos.x > 0. ? 13u : 0u));\n        int col_idx = int(col_hash % 16u);\n        col = col_idx == 0 ? CYAN : (col_idx == 1 ? PINK : BLACK);\n    } else {\n        col = BLACK;\n    }\n    const float heights[4] = float[](42., 34., 34., 32.);\n    for(int i = 0; i < GM; i++) {\n        for(int j = 0; j < GN; j++) {\n            int idx = GN * i + j;\n            float height = heights[idx];\n            vec3 c = vec3(-R_0_X/2.+w*(0.5+float(j)), 0.0, -R_0_Z/2.+w*(0.5+float(i)));\n            vec3 pos0 = pos - c;\n            pos0.x += sign(pos.x) * 15.;\n            pos0.x = pos0.x-R_0_X*(clamp(round(pos0.x/R_0_X),pos.x > 0. ? 1. : -8.,pos.x > 0. ? 8. : -1.));\n            pos0.z += R_0_D;\n            pos0.z = pos0.z-R_0_Z*clamp(round(pos0.z/R_0_Z),-16.,0.);\n            sdf_ = min_sdf(sdf_, \n                sdf_building(pos0, col, vec3(we, height, we), get_color)\n            );\n        }\n    }\n    \n    //sdf_ = min_sdf(sdf_, vec4(1,1,1,length(pos-vec3(0,1,-5))-1.));\n    {\n        vec3 pos1 = pos;\n        pos1.x -= ROAD_RADIUS;\n        pos1.x = mod(pos1.x+ROAD_RADIUS, 2.*ROAD_RADIUS)-ROAD_RADIUS;\n        sdf_ = min_sdf(sdf_, vec4(CYAN, sdf_box(pos1, vec3(0.05,0.05,400.))));\n    }\n    {\n        vec3 pos2 = pos;\n        pos2.x = abs(pos2.x);\n        pos2.z -= SPEED * iTime;\n        pos2.z = mod(pos2.z+ROAD_RADIUS, 2.*ROAD_RADIUS)-ROAD_RADIUS;\n        sdf_ = min_sdf(sdf_, vec4(CYAN, sdf_box(pos2 - vec3(ROAD_RADIUS+200.,0,0), vec3(200.,.05,.05))));\n    }\n    \n    return sdf_;\n}\n\nfloat non_zero(float x) {\n    return x + (x >= 0. ? 0.0001 : -0.0001);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec3 cameraPos, in vec3 lookDir, in vec2 screenDim, in vec2 uv,\n                inout vec3 col, in bool mirror) {\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookPerH = normalize(cross(lookDir, up));\n    vec3 lookPerV = normalize(cross(-lookDir, lookPerH));\n    vec3 screenCenter = cameraPos + lookDir;\n    vec3 screenPos = screenCenter + 0.5 * screenDim.x * uv.x * lookPerH\n                     + 0.5 * screenDim.y * uv.y * lookPerV;\n    \n    vec3 rayDir = normalize(screenPos - cameraPos);\n    \n    // Simple way of doing the reflections, inaccurate if lookDir is not parallel to the ground.\n    float diffuse;\n    if(mirror) {\n        // Noise in function of where the ray intersects the reflective surface.\n        float s = -cameraPos.y / non_zero(rayDir.y);\n        vec3 surf_inter = cameraPos + s * rayDir;\n        if(s < 0.) return;\n        vec2 surf_uv = (surf_inter.xz - vec2(0, SPEED*iTime));\n        float noise_ = noise(5.*surf_uv);\n        diffuse = abs(surf_uv.x) < ROAD_RADIUS ? 0.1 : 0.2;\n    \n        float noise_coef = abs(surf_uv.x) < ROAD_RADIUS ? 0.05 : 0.2;\n        //cameraPos.y = -cameraPos.y;\n        cameraPos = surf_inter;\n        rayDir.y = -rayDir.y+noise_coef*noise_;\n    }\n    \n    float t = 0.0;\n    vec4 dist;\n    vec3 pos;\n    int iter = 0;\n    do {\n        pos = cameraPos + t * rayDir;\n        dist = sdf(pos, false);\n        t += dist.w;\n        iter++;\n    } while(t < L && iter < MAX_ITER && dist.w > EPS);\n    \n    if(pos.y < 0.) return;\n    \n    if(dist.w <= EPS && (!mirror || pos.z > -200.)) {\n        dist = sdf(pos, true);\n        float v = 1.0 - t / L;\n        col = dist.xyz;\n    } else {\n        float s = (40.-cameraPos.z) / rayDir.z;\n        vec2 sky_uv = (cameraPos + s*rayDir).xy;\n        float stars_noise = noise(sky_uv);\n        float white_intensity = smoothstep(0.6, 1.0, stars_noise);\n        col = mix(col, vec3(1,1,1), white_intensity);\n    }\n    \n    if(mirror) {\n        col = mix(col, vec3(.5,0,.7), diffuse);\n    }\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float screenWidth = 2.0 * D * atan(0.5 * FOVH);\n\n    vec3 cameraPos = vec3(0, 2.5, 0);\n    vec3 lookDir = vec3(0, 0., -D);\n    vec2 screenDim = vec2(screenWidth, screenWidth / aspectRatio);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    //vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    // TODO: anti aliasing\n    vec3 col = BLACK;\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col, true);\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col, false);\n    \n    // Very useful visual debugging\n    //float sdf_2d = sdf(12.*vec3(uvf.x, 0., uvf.y-4.));\n    //if(sdf_2d < 0.) col = vec3(cos(60.*sdf_2d), 0, 0);\n    //else col = vec3(0, 0, cos(60.*sdf_2d));\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdffz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 341, 363, 363, 478], [479, 479, 505, 505, 987], [989, 1024, 1054, 1054, 1086], [1088, 1134, 1153, 1153, 1267], [1496, 1496, 1558, 1558, 1850], [1851, 1851, 1883, 1883, 1970], [3897, 3897, 3922, 3922, 3969], [3971, 3995, 4127, 4127, 5989], [5991, 5991, 6031, 6031, 6898], [6900, 6900, 6957, 6957, 7214]]}
{"id": "sslfWS", "name": "Mapping 2d SDF as 3d outlines", "author": "erratac", "description": "Method of mapping one 2d SDF onto another 2d SDF to create new 3d SDF as combination of them. As a fun effect the distance mapping can be rotated around the first SDF like in this shader.", "tags": ["distancefield", "sdf", "distance"], "likes": 7, "viewed": 310, "published": 3, "date": "1645350703", "time_retrieved": "2024-07-30T17:02:35.406897", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(vec2(c, -s), vec2(s, c));\n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat map( in vec3 p )\n{\n    p.y += 0.9;\n    \n    const float scale = 1.5;\n    p /= scale;\n    \n    float d2 = sdHeart(p.xy);\n    vec2 p2d = vec2(d2, p.z) * Rot(iTime);\n    \n    // This may produce a true SDF, but it depends on the \n    // shapes involved\n    float d = sdRoundedX(p2d, 0.1, 0.05);\n    \n    return d * scale;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 2.0*cos(an), 0.2, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 64, 64, 138], [140, 140, 168, 168, 388], [389, 389, 444, 444, 507], [509, 509, 533, 533, 835], [837, 883, 915, 915, 1154]]}
{"id": "NslfWB", "name": "odos|first ray-marching", "author": "ErinZ", "description": "my first ray-marching shader! :D", "tags": ["raymarching"], "likes": 3, "viewed": 288, "published": 3, "date": "1645339898", "time_retrieved": "2024-07-30T17:02:36.602700", "image_code": "#define TMIN 0.1\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\nfloat sdCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a +t*ab;\n    return length(p-c)-r;\n}\nfloat sdTorus(vec3 p,vec3 o, float r1,float r2){\n    p -= o;\n    return length( vec2(length(vec2(p.x,p.z))-r1,p.y) ) - r2;\n}\nfloat sdBox(vec3 p, vec3 o, vec3 s){\n    p-=o;\n    return length(max(abs(p)-s,0.));\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t*ab;\n\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\nfloat f(vec3 p){\n    float ds = sdSphere(p,vec3(0,1,3),1.);//sdf sphere\n    float dc = sdCapsule(p,vec3(1,.5,2),vec3(3.5,.5,3),.5);//sdf capsule\n    float dt = sdTorus(p,vec3(-2,.5,4),1.,.5);//sdf torus\n    float db = sdBox(p,vec3(1,1,5),vec3(1,2,1));//sdf box\n    float dcy = sdCylinder(p,vec3(1.5,1.7,2),vec3(4,.5,5),.5);//sdf cylinder\n    float dp = p.y;//sdf plane y=0\n    float d = min(ds,dc);\n    d = min(d,dt);\n    d = min(d,dp);\n    d = min(d,db);\n    d = min(d,dcy);\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(5.*cos(iTime), 5., 5.*sin(iTime)+3.);//light\n    vec3 ro = vec3(0,2,-4);//camera\n    vec3 rd = normalize(vec3(uv,2));\n\n    vec3 color = vec3(0);//background\n    vec3 amb = vec3(.1);//ambient color\n    vec3 diffusecol = vec3(1.,1.,1.);//diffuse color\n\n    float t = rayMarch(ro,rd);//raymarching\n    \n    vec3 p = ro+t*rd;\n    vec3 n = calcNormal(p);\n    vec3 l = normalize(lightPos-p);//lightDir\n    vec3 dif = clamp(dot(l,n),0.,1.)*diffusecol;//lambert\n\n    float shadow = rayMarch(p,l);\n    if(shadow<length(lightPos-p)) dif*=.1;\n\n    color = amb + dif;\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    color /= float(AA*AA);\n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 215, 215, 243], [244, 244, 291, 291, 445], [446, 446, 494, 494, 570], [571, 571, 607, 607, 656], [657, 657, 708, 708, 978], [979, 979, 995, 995, 1470], [1471, 1471, 1511, 1511, 1726], [1727, 1773, 1801, 1801, 2016], [2018, 2018, 2039, 2039, 2645], [2646, 2646, 2669, 2669, 2723], [2724, 2724, 2781, 2781, 3216], [3220, 3220, 3240, 3240, 3629]]}
{"id": "NdlfDS", "name": "Fractal explosions", "author": "jarble", "description": "This fractal explodes and implodes.", "tags": ["fractal", "knot"], "likes": 4, "viewed": 256, "published": 3, "date": "1645327846", "time_retrieved": "2024-07-30T17:02:37.616988", "image_code": "\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    //uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n\n            uv -= (t2.yx)/(scale);\n\n            t2 = triangle_wave(uv.yx,scale);\n\n            t3 = triangle_wave(uv-iTime/10.,scale);\n            \n            uv.yx = (t2+t3)/scale;\n\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n        uv *= scale;\n\n        }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 79], [81, 81, 138, 138, 740]]}
{"id": "NssBDS", "name": "Fractal knots 3", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 4, "viewed": 284, "published": 3, "date": "1645326180", "time_retrieved": "2024-07-30T17:02:38.722034", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    //float offset1 = iTime/1000.;\n    vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 18; k++){\n        //float scale = scale + col.x/8.;\n        //float scale = scale-col.x/16.;\n            //float scale = scale + col.x/16.;\n\n            //uv /= -scale-col.x;\n            \n            //uv -= offset + (t2.yx)/(1.+(col.x+col.y+col.z)/3.);\n            uv -= offset + (t2.yx)/(scale);\n            //uv += ceil(t2.x*t2.y+2.)/4.; //mosaic pattern\n\n\n            //uv += iTime/1000.-(t2.yx)/(scale);\n\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx+.5+float(i),scale);\n            \n            t3 = -triangle_wave(uv,scale);\n            \n            uv.yx = -(t2+t3);\n            //offset += offset1;\n            //offset += iTime/400.+ col.x/(scale-col.x);\n        col.x = 1.-abs(-uv.y+uv.x+col.x);\n        col = col.yzx;\n        \n        \n        uv /= scale*scale*scale;\n        //uv /= (t2.y-t2.x+1.);\n      }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1612]]}
{"id": "sdXfWB", "name": "cos(t) > 1.0", "author": "mla", "description": "Hilariously, Intel GPU can return cos(t) > 1.0 - a red flash after a second or so. Also show range of error with blue region.", "tags": ["cosine", "limit"], "likes": 4, "viewed": 272, "published": 3, "date": "1645302043", "time_retrieved": "2024-07-30T17:02:39.755271", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool s = cos(0.01*iTime) > 1.0;\n    bool t = cos(0.1*fragCoord.x/iResolution.x) > 1.0;\n    fragColor = vec4(s,0,t,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 181]]}
{"id": "Nl3SWs", "name": "Remnant Lost", "author": "Dave_Hoskins", "description": "Buzzing a Remnant crash site on Solar Zen 4.\n", "tags": ["3d", "raymarching", "raymarch", "remnant", "lost"], "likes": 54, "viewed": 1434, "published": 3, "date": "1645300347", "time_retrieved": "2024-07-30T17:02:40.750611", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n// https://www.shadertoy.com/view/Nl3SWs\n\n#define USE_TEX_NOISE_DERIVATIVE\n// Uses a texture to store derivative noise data.\n// Needs only one texture look-up.\n// We can't set buffer sizes, so the speed up is good, but not great.\n// because there's still an enormous amount of texture cache thrashing during the ray march.\n// It really needs a 256x256 buffer.\n\n// @Shadertoy - Please enable selectable buffer sizes! (That would be 💓)\n\n\n#define THRESHOLD .4\n#define FAR 12000.0\n#define SCALE 2.8\n#define MINRAD2 .25\nconst float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\nconst float absScalem1 = abs(SCALE - 1.0);\nconst float AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nconst vec3 surfaceColour1 = vec3(.8, .0, 0.);\nconst vec3 surfaceColour2 = vec3(.6, .6, 0.6);\nconst vec3 surfaceColour3 = vec3(.7, .7, 0.00);\nconst vec4 scale =vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2;\n\nconst vec3 sunLight  = normalize( vec3(  1.1, 0.8,  -0.8 ) );\nconst vec3 sunColour = vec3(1.0, .8, .6);\nconst vec3 cloudColour = vec3(.52, .35, .3);\n\nvec3 cameraPos;\nfloat gTime = 0.0;\n\n//#define MOUSE_SCRUB\n\n//-------------------------------------------------------------------------------------------------------\n\n#ifdef USE_TEX_NOISE_DERIVATIVE\n\n// Uses one texture LUT...\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n//    vec2 u = f*f*(3.0-2.0*f);\n//    vec2 du = 6.0*f*(1.0-f);\n\n\n    ivec2 p = ivec2(floor(x));\n\tvec4 n = texelFetch(iChannel0, p & TWRAP, 0);\n\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n#else\n\n// iq's original code from 'elevated'...\n// Thanks Inigo!\nvec3 noiseD(in vec2 x )\n{\n    vec2 f = fract(x);\n    \n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.0);\n//    vec2 u = f*f*(3.0-2.0*f);\n//    vec2 du = 6.0*f*(1.0-f);\n\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch(iChannel0, p&TWRAP, 0 ).x;\n\tfloat b = texelFetch(iChannel0, (p+ivec2(1,0))&TWRAP, 0 ).x;\n\tfloat c = texelFetch(iChannel0, (p+ivec2(0,1))&TWRAP, 0 ).x;\n   \tfloat d = texelFetch(iChannel0, (p+ivec2(1,1))&TWRAP, 0 ).x;\n\n\treturn vec3(a + (b-a) * u.x+(c-a) *u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n#endif\n\n//-------------------------------------------------------------------------------------------------------\n// Basic 3D noise using texture channel...\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//-------------------------------------------------------------------------------------------------------\n\n#define ANG2 1.33\n#define ANG3 1.4\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.;\n\n#define REM_SCALE 0.0035\n#define RIM_POSITION  vec3(-1500.,-220.,-1500)\n\n//-------------------------------------------------------------------------------------------------------\nfloat terrain( in vec2 p, float z)\n{\n   \n    float disObj = length(p+RIM_POSITION.xz)*.00044;\n\tfloat sc = clamp(disObj, 0.0,1.0);\n    \n    float a = 0.0;\n    \n    p+= vec2(200,222);\n    \n\tp = p*0.0004;\n    \n    vec2  d = vec2(0.0);\n    float b = 800.0 * sc;\n\n\n    \n    // Decrease iteration detail with distance with forced version...\n    int iter;\n    if (z >= 0.)\n        iter = 16-int(log2(z*.2+.05));\n    else\n        iter = -int(z);\n    \n    iter = clamp(iter, 1, 16);\n    \n\tfor (int i = 0; i < iter; i++)\n\t{\n       vec3 n = noiseD(p);\n        \n        d += n.yz;\n        a += b*n.x/(1.+dot(d,d));\n\t\tb *= 0.483;\n        p = rotMat*p;\n        p -= n.yz*.3;\n\t} \n    \n\n\n\treturn a;\n}\n\nmat3 rot3D; // ...Set in main\n//-------------------------------------------------------------------------------------------------------\n// Do the Mandelbox....\nfloat mapRemnant(vec3 pos) \n{\n\n    pos = pos + RIM_POSITION;\n    pos = rot3D * pos;\n    vec4 p = vec4(pos*REM_SCALE,1);\n\tvec4 p0 = p;\n    \n    // Shape always needs 8 iterations...\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale + p0;\n\t}\n\tfloat l = ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters) / REM_SCALE;\n\n    return l;\n}\n\nvec3 remnantColour(vec3 pos) \n{\n    pos = pos + RIM_POSITION;\n    pos = rot3D * pos;\n    vec4 p = vec4(pos*REM_SCALE,1);\n\tvec4 p0 = p;\n    \n\tfloat trap = 1.0;\n    \n    // Just 6 iterations for colour selection...\n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale + p0;\n\t\ttrap = min(trap, r2);\n\t}\n\t// |c.x|: log final distance (fractional iteration count)\n\t// |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.00015*length(p)-1., sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos * REM_SCALE) - gTime*31.5, 16.0);\n    vec3 surf = mix( surfaceColour1, vec3(.1, 2., 5.), smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t));\n\treturn mix(mix(surf, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\n//-------------------------------------------------------------------------------------------------------\n// A big background sky drop... without sun or clouds for fogging.\nvec3 getSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),4.);\n\tvec3  sky = mix(vec3(.0, .06, .2), cloudColour, v);\n\tsky = sky + sunColour * pow(sunAmount, 4.0) * .2;\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.0, r = 0.0;\n    \n    p*= .00008;\n    p += 3.5;\n    for (int i = 0; i < 6; i++)\n    {\n        r+= noise2D(p).x*a;\n        a*=.51;\n        p = rotMat *p;\n    }\n\treturn max(r-1., 0.0);\n}\n\n//-------------------------------------------------------------------------------------------------------\n//..used by...\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (8000. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*200.);    \n    t = (max((r-t)*40., .3))+.8;\n    vec3 col = cloudColour *t;\n    float f = pow(max(dot(sunLight, dir), 0.0), 8.0)*5.;\n    col= mix(col, sunColour*vec3(2., .9, .4), clamp(f, 0.0, 1.0));\n    // returns colour and alpha...\n    return vec4(col, r*.3);\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 addSun(in vec3 rd)\n{\n    float sunAmount = max( dot( rd, sunLight), 0.0 );\n    return sunColour * pow(sunAmount, 300.0)*2.;\n}\n\n//-------------------------------------------------------------------------------------------------------\n// Merge ground into the sky background for correct fog colouring...\nvec3 applyFog( in vec3  col, in vec3 sky, in float dis,in vec3 pos, in vec3 dir)\n{\n\n    vec3 v = exp2(-dis*0.00006*vec3(1.,1.4,4)); \n    return mix(sky, col, v);\n\n}\n\n\n//-------------------------------------------------------------------------------------------------------\n// Map the whole scene with two objects...\nfloat map(vec3 p, float z)\n{\n    return  min(p.y-terrain(p.xz, z), mapRemnant(p));\n}\n\n//-------------------------------------------------------------------------------------------------------\n\n// March the whole scene...\nfloat rayMarch(in vec3 rO, in vec3 rD, in float t)\n{\n\tfloat d = 0.;\n    float adj = .4;// Estimate error adjust starts very small\n\n    for(int j = min(0, iFrame); j < 300 && t < FAR; j++)\n\t{\n        d = map(rO + t*rD, t);\n        if (d < THRESHOLD) break;\n        t += d * adj;\n        // Instead of adding an arbitrary value to the estimation to speed up marching,\n        // scale the value instead.\n        adj += .004; // ... Works like magic here!\n\t}\n \n\treturn t;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 cameraPath( float t )\n{\n    vec2 p = vec2(2500.0 * sin(2.63*t), 2500.0 * cos(1.715*t) );\n    p += 600.;\n\treturn vec3(p.x,   terrain(p, -4.)+200.0+sin(gTime*3.+2.0)*100.0, p.y);\n} \n\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getNormal(vec3 p, float dis)\n{\n    dis = dis*1.5/iResolution.y;\n\tvec2 e = vec2(0,clamp(dis, .1, 144.));\n\treturn normalize(map(p, -15.0)-vec3(map(p - e.yxx, -15.), map(p - e.xyx, -15.), map(p - e.xxy, -15.)));\n}\n\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, in float dis)\n{\n\tfloat res = 1.0;\n    float t = 1.0;\n\tfloat h;\n\t\n    // Thankfully only a few steps are needed...\n    for (int i = min(0, iFrame); i < 35; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p, dis);\n\t\tres = min(.6*h / t*t, res);\n\t\tt += h+6.0;\n\t}\n    return clamp(res, .2, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec4 getDiffuse(vec3 pos, vec3 dir,  vec3 nor, float dis)\n{\n    vec4 dif = vec4(0);\n    if ((pos.y-terrain(pos.xz, dis)) < THRESHOLD)\n    {\n        // Simple Terrain colouring...\n        float n = cos(pos.z*.001+pos.x*.004+.8+pos.y*.001)*.4+.4;\n        float dark = smoothstep(8000.0,3000.0,length(pos.xz+RIM_POSITION.xz));\n        \n    \n        dif.xyz = vec3(mix(vec3(1.,.6,.4), vec3(.6, .6, .6), n));\n\n        \n        float s = max(0.,nor.y*nor.y);\n\n        dif.xyz = mix(dif.xyz, vec3(s*.4, s*.1,0.), clamp(nor.x+nor.z+.4, 0.0, 1.));\n        dif.w += .4;\n        dif *= dark;\n        \n\n        \n     }else\n     {\n         // Remnant colour...\n         dif.xyz = remnantColour(pos)*2.; //... Wasted processing faffing around!\n         dif.w = 1.5;\n     }\n    return dif;\n}\n\n//-------------------------------------------------------------------------------------------------------\n// Calculate lighting from the sun...\nvec3  doLighting(in vec4 dif, in vec3 pos, in vec3 nor, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,nor);\n\tvec3 mat = dif.xyz * sunColour*(max(h, 0.0));\n    vec3 ref = reflect(eyeDir, nor);\n    mat += sunColour * pow(max(dot(ref, sunLight), 0.0), 80.0) * dif.w;\n\n    mat *= shadow(pos+nor*2., sunLight, dis);\n    // Some fake sky lighting...\n    mat += vec3(.7,.6,.5) * max(0.0, -nor.y) *.05;\n     \n    return min(mat, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nvec3 cw, cu, cv;\nvec3 getCamera(vec2 uv)\n{\n    vec3 cameraTar;\n\tcameraPos = cameraPath(gTime + 0.0);\n\tcameraTar = cameraPath(gTime + .25);\n    cameraTar.y = cameraPos.y +sin(gTime*8.+2.5)*200.;\n    \n    // Camera lean on corners...\n    // not working\n    //vec3 far\t \t= cameraPath(gTime + .2);\n    //vec2 v1 = normalize(far.xz-cameraTar.xz);\n    //vec2 v2 = normalize(cameraTar.xz-cameraPos.xz);\n    //float roll = clamp(atan(cross2(v1,v2), dot(v1,v2))*.6, -.8, .8);\n\n    // Boat-roll it instead...\n\tfloat roll = .4*sin(gTime*10.);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n    cw = normalize(cameraTar-cameraPos);\n\tcu = normalize(cross(cw,cp));\n\tcv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + (length(uv*0.3)+.6)*cw);;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat m = 0.0;\n    #ifdef MOUSE_SCRUB\n    m = (iMouse.x/iResolution.x)*50.0;\n    #endif\n\tgTime = (iTime*.5+m+234.)*.1;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    rot3D = rotY(0.785398) * rotX(0.885398);\n\n    if (abs(xy.y -.5) > .37)\n\t{\n\t\t// Top and bottom cine-crop. Don't discard; - it won't always be black.\n\t\tfragColor = vec4(0.0);\n\t\treturn;\n\t}\n\n    vec3 dir = getCamera(uv);\n\n\tvec3 col;\n\tfloat dist;\n\n    float st = hash12(uvec2(fragCoord*iTime))*80.;\n\tdist = rayMarch(cameraPos, dir, st);\n    \n    vec3 sky = getSky(dir);\n    \n\tif (dist >= FAR)\n    {\n\t\t// Completely missed the scene...\n\t\tcol = sky;\n        \n        col = min(vec3(1.0), col+addSun(dir));\n        vec4 cc = getClouds(cameraPos, dir);\n       \n        col = mix(col, cc.xyz, cc.w);\n\t}\n\telse\n\t{\n        // Render the objects...\n        vec3 pos = cameraPos + dist * dir;\n        vec3 nor = getNormal(pos, dist);\n        vec4 dif = getDiffuse(pos, dir, nor, dist);\n        col = doLighting(dif, pos, nor, dir, dist);\n        col = applyFog(col, sky, dist, pos, dir);\n\t}\n\n\n    // Post screen effects...\n    // Sun flare stuff...\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t// glare2 is the cyan ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t// glare3 is a yellow ring...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.1;\n\t\tcol += bri * vec3(.2, 1.0, 1.) * pow(glare2, 2.0)*4.;\n\t\tcol += bri *vec3(0.5, .5,0.0) * pow(glare3, 2.0)*5.;\n\t}\n   \n    // Got fed up of bloody smoothstepping everything 🙄\n    // Use exponential curve instead (see in Common)\n    col =  clamp(col, 0.0, 1.0);\n    col *= fader(0.0, 4.0, iTime); \n    \n    // Fade out to 4 mins for video rendering.\n    //col *= fader(240.0, 230.0, iTime);\n    \n    // Contrast...\n    col = col*.4 + (col*col*(3.0-2.0*col))*.6;\n    // Gamma...\n    col = sqrt(col);\n    \n    xy.y = xy.y*1.37 -.185; // ...for letterbox crop\n\tcol *= 0.4 + .6*pow( 40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .5);  // ...Vignette.\n\tfragColor=vec4(col, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------------------", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28272, "src": "https://soundcloud.com/sergenarcissovmusic/space-ambient?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n// Create derivative noise texture\n\n// @Shadertoy - PLease enable selectable buffer sizes.\n\n\n// Normal random data with a sneaky curve...\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+10) & TWRAP);  // ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, 1. );\n}\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n// Draw it ony once to relavent area...\n\n// It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n// Pre-calc all the sums...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}", "buffer_a_inputs": [], "common_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n#define TSIZE 256.\n#define TWRAP 255\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xfffffffeU))\n\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 noise2D( in vec2 n )\n{\n\n    vec2 p = floor(n);\n    n = fract(n);\n    n = n*n*(3.0-2.0*n);\n    \n    vec2 res = mix(mix( hash22(p), hash22(p+vec2(1.0 ,0.0)),n.x),\n                    mix( hash22(p + vec2(0.0,1.0)), hash22(p + vec2(1.0,1.0)),n.x),n.y);\n    return res;\n}\n\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nmat3 rotX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n\nmat3 rotY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n// Exponential falloff.. \nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n/*\n float cross2(vec2 A, vec2 B)\n {\n\treturn A.x*B.y-A.y*B.x;\n }\n*/\n", "sound_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n//----------------------------------------------------------------------------------------\nvec2 mainSound( in int samp, float time )\n{\n    // Engine noise...\n    vec2 noi = (noise2D(vec2(time*220.0))-.5)*.5 * noise2D(vec2(time*.3)+.1);\n    noi += (noise2D(vec2(time*600.0))-.5)*.4 * noise2D(vec2(time*.2)+.1);\n    noi += (noise2D(vec2(time*88.0))-.5)*.9 *  noise2D(vec2(time*2.)+.2);\n    noi *= fader(.0, 3.0,time) * fader(180.0, 170.0,time);\n    return noi;\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3SWs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2390, 2539, 2565, 2565, 2770], [3064, 3170, 3206, 3206, 3854], [3868, 4016, 4045, 4045, 4488], [4490, 4490, 4521, 4521, 5331], [5334, 5507, 5532, 5532, 5757], [5759, 5865, 5896, 5896, 6093], [6095, 6216, 6252, 6252, 6699], [6701, 6807, 6832, 6832, 6937], [6939, 7114, 7196, 7196, 7278], [7281, 7430, 7458, 7458, 7514], [7623, 7651, 7703, 7703, 8121], [8123, 8229, 8257, 8257, 8412], [8416, 8522, 8557, 8557, 8737], [8739, 8820, 8873, 8873, 9150], [9152, 9258, 9317, 9317, 10034], [10036, 10180, 10267, 10267, 10618], [10744, 10744, 10769, 10769, 11474], [11476, 11582, 11639, 11639, 14073]]}
{"id": "7sfBDS", "name": "Disgusting Pattern", "author": "SnoopethDuckDuck", "description": "I hate these patterns so much", "tags": ["e"], "likes": 5, "viewed": 231, "published": 3, "date": "1645297197", "time_retrieved": "2024-07-30T17:02:41.623277", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat dlength(vec2 uv) {\n    return abs(uv.x) + abs(uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // change me\n    float a1 = 0.;\n    float a2 = 0.;\n    int n = 3;\n    float l = -24.; // 0. looks less disgusting\n\n    float m = 0.3 + 0.15 * thc(5., 0.6 * iTime); \n       \n    uv *= Rot(0. * iTime + a1 * atan(uv.x, uv.y));\n    for (int i = 0; i < n; i++) {\n        //uv *= Rot(a1 * atan(uv.x, uv.y));\n        uv = abs(uv) - m;\n        m *= 0.5;\n    }\n     \n    uv *= Rot(l * length(uv) + a2 * atan(uv.x, uv.y) + iTime);\n    vec2 s = 2. * step(uv, vec2(0)) - 1.;\n    vec2 id = 0.5 + 0.25 * s;\n          \n    vec3 e = vec3(1);\n    // most of this is unnecessary\n    vec3 col = pal(id.x * id.y + 0.1 + 0.0675 * (s.x + 5.) * (s.y -5.), 1.2 * e, e, e,\n                   0.5 * vec3(0,1,2)/3.);\n    //col = sqrt(col);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 80, 80, 146], [148, 148, 214, 214, 257], [259, 259, 283, 283, 323], [325, 325, 349, 349, 385], [387, 387, 444, 444, 1265]]}
{"id": "NsffWB", "name": "Fractal nice colors 2", "author": "SnoopethDuckDuck", "description": "first time golfing a shader\n\noriginal: \nhttps://www.shadertoy.com/view/ssXfWS", "tags": ["e"], "likes": 5, "viewed": 221, "published": 3, "date": "1645289121", "time_retrieved": "2024-07-30T17:02:42.495943", "image_code": "void mainImage( out vec4 g, in vec2 h )\n{\n    vec2 u = (h - 0.5 * iResolution.xy) / iResolution.y, \n    i = vec2(1);\n\n    float t = .3 * length(u) + iTime, \n    f = floor(t),\n    a = t-f;\n    f = 2.9325 * (f + pow(a*a*(3.-2.*a), 3.)); \n    \n    t = .2;\n\n    for(int j = 0; j < 5; j++) {   \n        vec2 s = step(u, vec2(0)) - .5;\n        \n        a = f * s.x * s.y;\n        u *= mat2(cos(a), -sin(a), sin(a), cos(a));\n     \n        i = .5 * i + s + .5;\n      \n        u = abs(u) - t;\n        t *= .5;// + .25 * tanh(4. * cos(12. * u.x - iTime));\n    }\n    \n    g = vec4(sqrt( 1. + cos(6.284 * (.13 * vec3(0,1,2) - min(-i.x, i.y))) ), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsffWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 640]]}
{"id": "fdSyWW", "name": "walking robot", "author": "mdb", "description": "inspired by this video:\nhttps://www.youtube.com/watch?v=imbIsNAvUpM&ab_channel=Polyfjord", "tags": ["raytracing", "glass", "animation", "inversekinematicscinematic"], "likes": 19, "viewed": 433, "published": 3, "date": "1645285272", "time_retrieved": "2024-07-30T17:02:43.415485", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float vign = pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = col*col*(3.0 - 2.0*col);\n    \n    col += 0.01*step(0.3, texture(iChannel1, uv*2.0).r * (1.0 - vign));\n    \n    col = 1.0 - exp(-0.5*col);\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    col *= 0.3 + 0.7*vign;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265359\n#define AA 1\nconst float leg_segment = 0.25; // length of the leg / 3\n\n\n\n//globals\nstruct leg {vec3 p1, p2, p3, p4;};\nleg legs[4];\nmat3x3 rotX;\nmat3x3 rotZ;\nvec3 center;\nfloat inside = 1.0;\n\n//random////////////////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nfloat smoothNoise(float time){\n    seed = (uint(time)+45456u) * 23456u;\n    float a = random();\n    seed = (uint(time)+45457u) * 23456u;\n    float b = random();\n    float t = fract(time);\n    return mix(a, b, t*t*(3.0 - 2.0*t));\n    \n}\n\nfloat timeFbm(float time, int depth){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < depth; i++){\n        float n = smoothNoise(time);\n        a += b*n;\n        t += b;\n        b *= 0.6;\n        time *= 2.0; \n    }\n    return a/t;\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdBox( vec3 p, float size){\n  return max(max(abs(p.x), abs(p.y)), abs(p.z)) - size;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat dot2(vec3 v) {return dot(v, v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  //return length(p - b)  - 0.05;\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n\n//animation///////////////////////////////////////////////////////////////////////////\nvec2 walking_cycle(float t){\n    return (t < 0.5) ? vec2(-1.0 + 4.0*t, sin(2.0*PI*t)) : vec2(3.0 - 4.0*t, 0.0);\n} \n\n\nvoid inverse_kinematic(in vec3 p1, out vec3 p2, out vec3 p3, inout vec3 p4){\n    float d = distance(p1, p4);\n    vec3 u = (p4 - p1)/d;\n    \n    if (d > leg_segment * 3.0){\n        p2 = p1 + u * leg_segment;\n        p3 = p1 + 2.0 * u * leg_segment;\n        p4 = p1 + 3.0 * u * leg_segment;\n        return;\n    }\n    \n    float a = (d - leg_segment) * 0.5;\n    float h = sqrt(leg_segment*leg_segment - a*a);\n    \n    vec3 b1 = cross(u, vec3(0.0, 1.0, 0.0));\n    vec3 up = normalize(cross(u, b1));\n    \n    p2 = p1 + u*a + h* up * sign(up.y);\n    p3 = p2 + u*leg_segment;\n    \n    return; \n}\n\nvoid compute_leg_pos(float t){\n    center =  vec3(timeFbm(t, 3)*0.2 - 0.1, \n                   timeFbm(t + 10.0, 4)*0.2 - 0.1 + 0.05*sin(4.0*PI*t), \n                   timeFbm(t + 20.0, 3)*0.2 - 0.1);\n    \n    float angleX = 0.3*(timeFbm(t*4.0 + 30.0, 2)*2.0 - 1.0);\n    float angleZ = 0.3*(timeFbm(t*4.0 + 30.0, 2)*2.0 - 1.0);\n    \n    rotX = mat3x3(1.0, 0.0, 0.0,\n                  0.0, cos(angleX), -sin(angleX),\n                  0.0, sin(angleX), cos(angleX));\n    \n    rotZ = mat3x3( cos(angleZ), -sin(angleZ),   0.0,\n                   sin(angleZ),  cos(angleZ),   0.0,\n                       0.0    ,      0.0    ,   1.0   );\n    \n    for(int i=0; i < 4; i++){\n        float i_f = float(i);\n        float angle = 0.5*PI*i_f;\n        vec3 direction = vec3(cos(angle), 0.0, sin(angle));\n        \n        legs[i].p1 = (center + rotZ * rotX * direction * 0.2);\n        legs[i].p4 = vec3(0.2, 0.1, 0.1)*walking_cycle(fract(t + 0.5*i_f)).xyx \n                    + vec3(0.0, -0.4, 0.0) + 0.53 * direction;\n        \n        inverse_kinematic(legs[i].p1, legs[i].p2, legs[i].p3, legs[i].p4);\n    }\n    \n    rotX = inverse(rotX);\n    rotZ = inverse(rotZ);\n    \n    return;\n}\n\n//render//////////////////////////////////////////////////////////////////////////////\n\nfloat map(vec3 p, out int matID){\n    float d = 1e5;\n    float d2;\n    matID = 0;\n     for(int i=0; i < 4; i++){\n         d = min(d, sdRoundCone(p, legs[i].p1, legs[i].p2, 0.1, 0.06));\n        d = min(d, sdRoundCone(p, legs[i].p2, legs[i].p3, 0.06, 0.03));\n        d = min(d, sdRoundCone(p, legs[i].p3, legs[i].p4, 0.03, 0.001));\n     \n    }\n     \n    vec3 p2 = rotZ * rotX * p;\n    d = min(d,  sdBox(p2 - center, 0.17));\n    \n    if (d > p.y + 0.4){ //plane\n        d = p.y + 0.4;\n        matID = 2;\n    }\n    \n    d *= inside;\n    \n    d2 = 1e5;\n    for(int i=0; i < 4; i++){\n        d2 = min(d2, length(p - legs[i].p1) - 0.13);\n    }\n    \n    if (d > d2){ \n        d = d2;\n        matID = 1;\n    }\n    \n    return d;\n}\n\nfloat map(vec3 p){\n    int i_;\n    return map(p, i_);\n}\n\n\n\n#define OFFSET 0.0005 \nvec3 normal(vec3 p){\n    return normalize(vec3(map(p+vec3(OFFSET,0,0))-map(p-vec3(OFFSET,0,0)),\n                          map(p+vec3(0,OFFSET,0))-map(p-vec3(0,OFFSET,0)),\n                          map(p+vec3(0,0,OFFSET))-map(p-vec3(0,0,OFFSET)))); \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd){\n    float res = 1.0;\n    float tmax = 12.0;  \n    float t = OFFSET*4.0;\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = map( ro + rd*t);\n        res = min(res, 16.0*h/t);\n        t += h;\n        if( h<OFFSET ) return 0.0;\n        if( t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat distance_scene(vec3 ro, vec3 rd, out int matID){\n    float t = 0.02;\n    float dt;\n    \n    for(int i=0; i < 100; i++){\n        dt = map(ro + t*rd, matID);\n        t += dt;\n        \n        if(abs(dt) < OFFSET)\n            return t;\n        \n        if(t > 10.0)\n            return -1.0;\n        \n    }\n    return -1.0;\n}\n\nfloat fresnel(vec3 rd, vec3 n){\n    float n2 = 1.0, n1 = 1.330;\n    float R0 = pow((n2 - n1)/(n2 + n1), 2.0);\n    float teta = -dot(n, rd);\n    float R = R0 + (1.0 - R0)*pow(1.0 - teta, 5.0);\n    return R;\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    float t;\n    vec3 n, col, mask, p;\n    int matID;\n    \n    const vec3 sun_dir = normalize(vec3(-0.8, 1.0, 0.5));\n    \n    inside = 1.0;\n    mask = vec3(1.0);\n    col = vec3(0.0);\n    \n    vec3 bgCol = vec3(0.0);\n    \n    for(int i = 0; i < 6; i++){\n        t = distance_scene(ro, rd, matID);\n        if(t < 0.0) return col + mask * bgCol;\n        p = ro + t*rd;\n        n = normal(p); \n        ro = p;\n        \n        if (matID == 0){ //glass\n            float f = fresnel(rd, n);\n                vec3 rd2 = reflect(rd, n);\n                float s = softshadow(p, sun_dir);\n                \n                \n                if(dot(n, sun_dir) > 0.0){\n                    vec3 sky = mix(vec3(0.5, 0.4, 0.4), vec3(vec3(2.0)), 0.5*n.y + 0.5);\n                    col += s*f*mask*(sky + 70.0*pow(max(dot(rd2, sun_dir), 0.0), 30.0));\n                }\n                mask *= 1.0 - f;\n                rd = refract(rd, n, 1.0/1.33);\n                inside *= -1.0;\n                mask *= vec3(1.0, 0.85, 0.85);\n            \n            \n        }\n        \n        if(matID == 1){ //cube\n            mask *= vec3(1.0, 0.1, 0.1);\n            col += mask *( vec3(0.1, 0.1, 0.2) * (map(p + n*0.02) / 0.02) * (min(1.0, 1.0 + dot(sun_dir, n)))\n                      + 1.0*vec3(1.30,1.00,0.70) * dot(sun_dir, n) * softshadow(p, sun_dir)\n                        );\n            \n            return col;\n        }\n        \n        if(matID == 2){ //plane\n            vec3 tex = texture(iChannel1, p.xz*0.2 + 0.8*vec2(0.2, 0.1)*iTime).rgb;\n            mask *= tex*tex;\n            mask *= exp(-dot(p.xz + vec2(-0.5, 0.5), p.xz + vec2(-0.5, 0.5)));\n            col += mask *( vec3(0.1, 0.1, 0.2) * (min(1.0, 1.0 + dot(sun_dir, n)))\n                      + 1.0*vec3(1.30,1.00,0.70) * dot(sun_dir, n) * softshadow(p, sun_dir)\n                        );\n            return col;\n        }\n\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    compute_leg_pos(iTime);\n    initRandomGenerator(fragCoord);\n    \n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(sin(0.2), 0.5, cos(0.2));\n    \n    vec3 dir0 = normalize(-ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd;\n    \n    vec3 col = vec3(0.0);\n    for(int x = 0; x < AA; x++){\n    for(int y = 0; y < AA; y++){\n        rd = normalize(dir0 + right*(uv.x + float(x)/float(AA)/iResolution.x) \n                            + up*(uv.y + float(y)/float(AA)/iResolution.x));\n        col += march(ro, rd);\n    }\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 471]]}
{"id": "NsfBWB", "name": "odos | function grapher", "author": "ErinZ", "description": "still have some problem witn AA :((((", "tags": ["2d"], "likes": 6, "viewed": 330, "published": 3, "date": "1645283197", "time_retrieved": "2024-07-30T17:02:44.252248", "image_code": "#define S(v,r)    smoothstep( r, r+ 5./iResolution.y, v )\n#define S1(v,r)   1.-S(v,r)\n#define PI        3.1415926\n#define AA        5.\n#define wid       0.1\n\nfloat func(in float x) {\n    float T = 4. + 2. * sin(iTime);\n    return sin(2. * PI / T * x);\n    //return sin(x);\n}\nvec2 getuv(vec2 fragcoord){\n    return (2.*fragcoord-iResolution.xy)/iResolution.y*4.;\n}\nfloat AAfunc(vec2 coord){\n    float c = 0.;\n    for(float m =0.;m<AA;m++){\n        for(float n=0.;n<AA;n++){\n            vec2 o = getuv(coord + (vec2(m,n)-.5*AA) / AA*2.);\n            c += smoothstep(func(o.x)-wid,func(o.x)+wid,o.y);//\n        }\n    }\n    c = abs(c/(AA*AA)-0.5)*2.;//remap to 0-1:more closed to 0 more closed to the funcline\n    return smoothstep(300./iResolution.y,0.,c);\n}\n\nvec3 grid(vec2 uv){\n    vec2 pos = floor(uv*2.);\n    vec3 c = vec3(0.1)+mod(pos.x+pos.y,2.0)*0.1;\n    c = mix(c,vec3(.3,.8,1),S1(abs(uv.x),0.01));\n    c = mix(c,vec3(1,0,.3),S1(abs(uv.y),0.01));\n    return c;\n}\nfloat logo(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = getuv(fragCoord);\n    vec3 col = grid(uv);\n    col = mix(col, vec3(1), AAfunc(fragCoord));\n    //col += smoothstep(func(uv.x),func(uv.x)+0.1,uv.y);\n\n    col +=logo(uv*.25);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 182, 182, 274], [275, 275, 302, 302, 363], [364, 364, 389, 389, 755], [757, 757, 776, 776, 967], [990, 990, 1047, 1047, 1292], [1296, 1296, 1316, 1316, 1705]]}
{"id": "fsffD4", "name": "Particle Exper #1 [commented]", "author": "Yusef28", "description": "The collisions don't take into account the angle of collision but it still works out ok.", "tags": ["particles", "truchet", "physics", "commented", "buffer", "collisions"], "likes": 7, "viewed": 326, "published": 3, "date": "1645282917", "time_retrieved": "2024-07-30T17:02:45.180765", "image_code": "/*\n\nBUFFER A <= For information on the particle simulation & animation\nIMAGE <= For information on the coloring and lighting\n\nIMAGE\n******************************************************\n\nMAIN FEATURES:\n\n1. A Hemispherical Normal function to calculate a 3d normal for \nevery point on a 2d disk. This is explained in depth.\n\n2. Skipping particles that are outside a certain distance from a given pixel \nsince it wont factor into the color of that pixel\n\n3. Lot's and lot's of comments!\n\n*/\n\n//noise function used for the truchet texture.\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n//circle function for drawing parts of the disk\nfloat circle(vec2 p, float r, float sf)\n{    \n    return smoothstep(r+EPS*sf, r-EPS*sf, length(p));\n}\n\n//a sin function to create a ripple effect on the disks\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*50./r))*(smoothstep(r+EPS, r-EPS,c));\n}\n\n/* Next, I create a 3d spherical normal out of a point on a disk\nusing trigonometry\nimagine you are standing in a field but you are covered by this\ndome. A complete half sphere dome. You are on this field inside \nand at any position in there, you are under a part of the \"roof\"\nof the dome. The height to the roof where you are standing, is the \nz axis. Your position is x and y.\nWe know the dome will have a middle (where x and y = vec2(0,0)) the \norigin of the dome on the field. So we can find the length to the position\non the field where you are standing with length(xy).\nOk, so then we have a length, but we never actually found Z did we?\nBut we do have the length and so we can use trigonometry if we\nlet length be A and let Z be B.\nSo we have A but we don't have B or C.\nWell if the dome is a \"unit sphere\" then we DO have C because it\nwill be the hypotenuse of length = 1.\nThen B = sqrt(1.-A^2)\nSo we can return the normal as \nvec3(x from field ,y from field ,B from triangle)\n*/\nvec3 hemiNormal(vec2 center, vec2 point){\n//we scale base to be 1 based on the radius scaled to only the \n//part of the circle we want to add highlights to. instead of the full\n//radius, we want 0.6 of it.\n    float base = length(point)/(RADIUS*0.6);\n    float height = sqrt(1.-base*base);\n    return vec3(point, height);\n}\n\n//This function puts a lot of things together\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     int ball_id,\n                     vec2 fragCoord, \n                     vec2 pos, \n                     float r){\n                     \n    //I get the animation data for the given disk       \n    vec4 anim_data = load0(vec2(float(ball_id)+0.5,1.5));\n    //animation is the animation run time from 0 to 1\n    float animation = anim_data.x;\n    //This light is for the rim lighting of the disks\n    vec2 light = vec2(1.,0.);\n    //I move it around the screen\n    light*=rot(iTime);\n    \n    //metal texture for the disks\n    vec3 tx1 = vec3(texture(iChannel2,(pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    float scale = 0.6/r;\n    vec3 tx2 = vec3(texture(iChannel3, \n    ((pos)*scale*rot(iTime))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n\n    //the light direction for rim lighting\n    vec2 lightDir = normalize(light - max(pos,EPS));\n    \n    //a light for 3d lighting of the greenish dome\n    vec3 light3 = normalize(vec3(-light*7., 1.));\n    //light direction\n    vec3 ld = normalize(light3-vec3(pos, 0.));\n    //get the hemispherical normal\n    vec3 n = hemiNormal(vec2(0.),pos);\n    //our ray direction looking into the screen\n    vec3 rd = vec3(0.,0.,-1.);\n    //diffuse\n    float diff = max(0., dot(ld,n));\n    //specular\n    float spec = pow(max(0., dot(reflect(-ld, n), -rd)),4.);\n    \n    //shadow circle\n    col = mix(col, vec3(0.0), circle(pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, silver+dot(pos,-lightDir), circle(pos, r, 1.));\n    //gold outer circle\n    col = mix(col, silver-tx1.x+0.2, circle(pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(pos, r*0.67, 5.));\n\n    //rotating posision so that every disk's greenish rexture and color\n    //are rotated randomly about it's center\n    pos *= rot(iTime+float(ball_id));\n    //the greenish yellowish color\n    vec3 truCol = mix(vec3(0.45,0.32,0.1)+tx2*0.6,vec3(0.1,0.5,0.4),0.5-pos.y*8.);\n    //a circle with the radius of the dome\n    float inner_C = circle(pos,r*0.6, 1.);\n    //get a blurred circle shape for the lighting on hit\n    float flash = smoothstep(r*0.6+0.02, r*0.6, length(pos));\n    //add the color for the inner dome\n    col = mix(col, truCol+4.*pow(length(pos)-r*0.7, 1.), inner_C); \n   //add the flash with a \n    //glowy color based on the animation scaled from 0 to 0.5\n    col += (0.5-abs(animation-0.5))*flash*vec3(0.59,0.3,0.9)*4.;\n    //add the diffuse and specular lighting to the color\n     col += inner_C*(clamp(diff,0.,1.)*vec3(0.45,0.32,0.1)*5. + clamp(spec,0.,1.)*vec3(0.1,0.5,0.4)*1000.);\n    return col;\n    \n}\n\n\n//a modified truchet pattern function so that\n//I can make dashed lines if cut = 1. instead of solid \nfloat truchet(vec2 st,float edge, float cut){\n    float d;\n    \n    st*=16.;\n    vec2 stFL = floor(st);\n    vec2 stFR = fract(st)-0.5;\n    float id = floor(noise(stFL)*4.)*0.25;\n    \n    float spacing = 0.5;\n    float width = 0.45;\n    stFR *= rot(id*PI);\n    \n    vec2 pos = stFR-spacing;\n    \n    d = abs(length(pos)-spacing) + \n            smoothstep(0.4,0.5,\n            abs(fract(16.*(atan(pos.y,pos.x)+PI)/PI)-0.5))*cut;\n    //only cut if cut == 1\n    pos = stFR+spacing;\n    d = min(d,abs(length(pos)-spacing) + \n            smoothstep(0.4,0.5,\n            abs(fract(16.*(atan(pos.y,pos.x)+PI)/PI)-0.5))*cut\n            );\n    \n    return smoothstep(edge,edge-0.07,d+0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = UVn1;//this is a function in common tab\n    //vignett here so I can use it to shade the truchets\n    vec2 st = fragCoord/iResolution.xy;\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); \n    \n    //set a soft gradient fro the background\n    vec3 backColor = mix(vec3(0.1,0.0,0.0)*1.5, vec3(0.2,0.15,0.1)*1.5, vig);\n    vec3 col = backColor;\n    //make thin stripes/lines that look raised maybe\n    col += smoothstep(0.2,0.08,abs(fract(uv.x*42.)-0.5))*0.09;\n    //use a truchet pattern to overwrite the lines\n    col = mix(col, backColor*0.95, truchet(fragCoord.xy/iResolution.y,0.35,0.));\n    //add a dotted truchet \n    col = mix(col, vec3(0.2,0.1,0.1)*0.1, truchet(fragCoord.xy/iResolution.y,0.22,1.)*0.8);\n    \n    //add in a second truchet overtop of the dotted one but thinner\n    //two options\n    //col = mix(col, mix(gold,vec3(0.59,0.3,0.9),vig),truchet(fragCoord.xy/iResolution.y, 0.19,1.));\n    col = mix(col, backColor*0.99,truchet(fragCoord.xy/iResolution.y, 0.19,1.));\n    //gamma or something \n    col = pow(col*0.3, vec3(0.5));\n     \n    //loop through all particles and if one is further than a radius*1.2\n    //away we can just skip the f*cker right! \n    for(int i = 0; i < BALL_NUM; i++){\n        if(length(uv-load0(vec2(float(i)+0.5,0.5)).xy) > RADIUS*1.2)continue;\n        col = drawFancyCircle(col, uv, i, fragCoord, uv-load0(vec2(float(i)+0.5,0.5)).xy, RADIUS*0.98);\n    }\n    //more gamma or something\n    col = pow(col, vec3(0.9));\n    fragColor = vec4(col*vig*1.2,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nIMAGE <= For information on the coloring and lighting\n\nBUFFER A <= For information on the particle simulation & animation\n\n\nBUFFER A\n******************************************************\n\nMAIN FEATURES:\n\n\n*/\n\n//a struct for holding ball data during collisio tests\nstruct Ball{\n    int id;\n    float r;\n    vec2 pos;\n    vec2 vel;\n    \n};\n\n\n\n//global collision flag\nfloat collided = 0.;\n\nvec4 wallCollision(inout vec2 pos,inout vec2 vel){\n    //just test if we hit a wall but use ASP since the x axis\n    //is stretched compared to y. (maybe not for all screens I don't know)\n    //if the particle collides with any wall we set teh collision flag to = 1.\n    vec2 tmp = pos + vel;    \n    if(tmp.y + RADIUS > 1.){pos.y = 1.-RADIUS*1.01;vel.y=-vel.y;\n    collided = 1.;}\n    else if(tmp.y-RADIUS < -1.){pos.y = -1.+RADIUS*1.01;vel.y=-vel.y;\n    collided = 1.;}\n    if(tmp.x + RADIUS > ASP){pos.x = ASP-RADIUS*1.01;vel.x=-vel.x;\n    collided = 1.;}\n    else if(tmp.x-RADIUS < -ASP){pos.x = -ASP+RADIUS*1.01;vel.x=-vel.x;\n    collided = 1.;}\n    return vec4(pos,vel);\n    \n}\n//we check if the ball is overlapping any other particle\nvec4 ballOverlap(inout vec2 pos, inout vec2 vel, vec2 fragCoord){\n    int thisID = int(floor(fragCoord.x));\n    \n    for(int i = 0; i < BALL_NUM; i++){\n        \n        if(i == thisID){continue;}//skip when we get the same particle\n        Ball b;\n        \n        //load second particle and create an object to hold it\n        vec4 stuff = load0(vec2(float(i)+0.5,0.5));\n        b.pos = stuff.xy;\n        b.vel = stuff.zw;\n        \n        //check overlapp\n        float dist = length(pos-b.pos);\n        float diff = dist-RADIUS*2.;\n        //if overlap\n        if(diff < 0.){\n            //basically omve things away from each other in the\n            //direction opposite the normal by the amount of overlap\n            float halfDiff = 0.999*(diff);\n            vec2 normal = normalize(pos-b.pos);\n            pos -= normal*halfDiff;\n            //set collided flag\n            collided = 1.;\n\n        }\n    }\n    return vec4(0.);\n}\n\n//check particle collision, \n//This is mostly the same as above, I probably could combine them.\nvec4 ballCollision(inout vec2 pos, inout vec2 vel, vec2 fragCoord){\n    int thisID = int(floor(fragCoord.x));\n    \n    for(int i = 0; i < BALL_NUM; i++){\n        \n        if(i == thisID){continue;}//skip same ball\n        Ball b;\n        vec4 stuff = load0(vec2(float(i)+0.5,0.5));\n        \n        b.r = RADIUS;\n        b.pos = stuff.xy;\n        b.vel = stuff.zw;\n        \n        float dist = length(pos-b.pos);\n        float diff = dist-RADIUS*2.;\n        \n        if(diff < 0.){\n            //if overlap just exchange velocities\n            vel = b.vel;\n            collided = 1.;\n        }\n    }\n    return vec4(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV01;\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    //what we do on the very first frame\n    if(iFrame < 1){\n        //if the pixels coordinate is in the region for storing\n        //particle position and velocity informaiton\n        if(fragCoord.x < float(BALL_NUM) && fragCoord.y == 0.5){\n\n            //set it's data to a calculated point on the screen\n            //and a small random velocity between -0.005 and .005 for xy\n            fragColor = vec4(\n            mod(fragCoord.x,floor(2.*ASP/(RADIUS*2.)))*RADIUS*2.-1.*ASP+0.1,\n            1.-RADIUS-floor(fragCoord.x/floor(2.*ASP/(RADIUS*2.)))*RADIUS*2.,\n            rnd(fragCoord.x+901.)*0.01-0.005,\n            rnd(fragCoord.x)*0.01)-0.005;\n        }\n        //if the pixels coordinate is in the region for storing\n        //particle animation information, set it to 0\n        else if(fragCoord.x < float(BALL_NUM) && fragCoord.y == 1.5){\n            fragColor.x = 0.;\n        }\n        \n   }\n   //if we are beyond the first frame, \n   else{\n       //as long as we are withing the region of the particles, \n       //regardless of which part, get the posision and velocity\n       //(even if it doesn't exist, doesn't really matter\n        if(fragCoord.x < float(BALL_NUM) && fragCoord.y < 3.5){\n            vec2 pos = load0(vec2(fragCoord.x,0.5)).xy;\n            vec2 old_vel = load0(vec2(fragCoord.x,0.5)).zw;\n            //save access to the old velocity since the new one will\n            //change\n            vec2 vel = old_vel;\n            \n            //we send the velocity through collisions with particles\n            //and with walls, as well as checking for overlaps\n            ballCollision(pos,vel,fragCoord);;\n            ballOverlap(pos,vel,fragCoord);\n            wallCollision(pos,vel);\n            //after all that we have a final velocity whcih we \n            //add to position\n            pos += vel;\n            \n            //now, if our pixels position is on the pos and vel of the\n            //particle, we can now update\n            if(fragCoord.y == .5){\n                fragColor = vec4(pos,vel);\n            }\n            //otherwise, if the pixel is over the animaton segment\n            //for a given particle, we do the animation stuff\n            else if(fragCoord.y == 1.5){\n                //get collision data to know if are already reacting\n                //to a collision or not\n                vec2 col_data = load0(vec2(fragCoord.x,1.5)).xy;\n                //get animaiton data to know where we are in an animation\n                //if we are in one at all.\n                vec2 anim_data = load0(vec2(fragCoord.x,1.5)).zw;\n                \n                //if collided but it was a while ago, reset\n                if(col_data.y == 1. && (iTime-anim_data.x) > DURATION){\n                \n                    fragColor = vec4(0.,0.,0.,atan(vel.x,vel.y));\n                    //store current angle so in image both old and new\n                    //are the same\n                    \n                }\n                //new collision, set flag to 1 and set start time\n                else if(collided == 1. && col_data.y == 0.){\n                    \n                    fragColor.x = col_data.x;\n                    fragColor.y = 1.;//collision now = 1 (true)\n                    fragColor.z = iTime;//the time of the collision \n                    //this was used for rotating arrows in Image\n                    //it's unused right now.\n                    fragColor.w = atan(old_vel.x,old_vel.y);\n                    //store old angle so in main we can animnate betwen\n                    //old and new current angle.\n                    \n                }    \n                //if already collided, update animation\n                else if(col_data.y == 1.){\n                    //just update how far we are in the animation\n                    //from 0 to 1.\n                    fragColor.x = (iTime-anim_data.x) / DURATION;\n                    //everything else is just refreshing\n                    fragColor.y = col_data.y;//refresh collision flag\n                    fragColor.z = anim_data.x; //refresh ( I think always 0)\n                    fragColor.w = anim_data.y; //refresh angle\n                \n                }\n                //if nothing happened just refresch all\n                else if(collided == 0. && col_data.y == 0.){\n                    fragColor.x = col_data.x;\n                    fragColor.y = col_data.y;\n                    fragColor.z = anim_data.x;\n                    fragColor.w = anim_data.y;\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RADIUS 0.14\n#define PI 6.2831 \n#define silver vec3(255., 204., 206.)/255.\n#define gold vec3(215., 154., 15.)/205.\n#define EPS 0.001\n#define BALL_NUM 50\n#define UV01 fragCoord/iResolution.xy\n#define UVn1 (fragCoord*2.-iResolution.xy)/iResolution.y\n#define ASP  iResolution.x/iResolution.y\n#define DURATION .6\n#define load0(f) texture(iChannel0,f/iResolution.xy)\n#define load1(f) texture(iChannel1,f/iResolution.xy)\n#define load2(f) texture(iChannel2,f/iResolution.xy)\n#define load3(f) texture(iChannel3,f/iResolution.xy)\n\n#define GAME_STATE_ADDRESS vec2(0.5,0.)\n\n#define PARTICLE_NUM 10.\n\nfloat rnd(float a){\n    return fract(sin(a*235.512)*5421.74);\n}\n\nfloat rnd2(vec2 a){\n    return fract(sin(dot(a,vec2(11.75,74.94)))*5421.74);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsffD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 537, 558, 558, 620], [622, 670, 711, 711, 771], [773, 829, 857, 857, 943], [945, 1934, 1975, 2139, 2257], [2259, 2305, 2501, 2580, 5197], [5200, 5302, 5347, 5347, 5983], [5985, 5985, 6042, 6092, 7674]]}
{"id": "fsffDS", "name": "Spiral \"domain mapping\"", "author": "mrange", "description": "CC0: Spiral \"domain mapping\"\nWas tinkering with getting a spiral domain mapping to work.\nWhile there are distortions I think it it turned out well enough to be useful to me", "tags": ["2d", "domain", "spiral"], "likes": 21, "viewed": 634, "published": 3, "date": "1645278432", "time_retrieved": "2024-07-30T17:02:45.989603", "image_code": "// CC0: Spiral \"domain mapping\"\n// Was tinkering with getting a spiral domain mapping to work.\n// While there are distortions I think it it turned out well enough to be useful to me\n\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\nvoid spiralMod(inout vec2 p, float a) {\n  vec2 op     = p;\n  float b     = a/TAU;\n  float  rr   = length(op);\n  float  aa   = atan(op.y, op.x);\n  rr         -= aa*b;\n  float nn    = mod1(rr, a);\n  float sa    = aa + TAU*nn;\n  float sl    = spiralLength(b, sa);\n  p           = vec2(sl, rr);\n}\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat eye(vec2 p, float h) {\n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*(TIME+h)/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1.y -= 0.28;\n  float d1 = circle(p1, 0.622);\n  d1 = max(d1,d0);\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3.y -= 0.28;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-length(p1));\n\n  vec2 p4 = p;\n  p4.y -= 0.28;\n  float d4 = circle(p4, 0.285);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  d0 = abs(d0)-mix(0.0125, -0.0025, t0);\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  \n  float aa = 2.0/RESOLUTION.y;\n  vec3 col = vec3(1.0);\n\n  float a = 0.25;\n  \n  vec2 sp = p;\n  spiralMod(sp, a);\n  sp.x += -TIME*0.2;\n  vec2 msp = sp;\n  float nsp = mod1(msp.x, a);\n  \n  float z = a*0.4;\n  \n  float dd = length(msp)-z;\n  \n  float h = hash(nsp+123.4);\n  \n  float de = eye(msp/z,h)*z;\n  de -= 0.25*aa;\n  \n  col = mix(vec3(1.0-abs(2.0*sp.y/a)), vec3(0.0), smoothstep(aa, -aa, de));\n  col *= smoothstep(0.0, 0.4, length(p));\n  \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsffDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 391, 430, 430, 555], [557, 557, 595, 649, 706], [708, 708, 747, 747, 1000], [1003, 1103, 1124, 1124, 1197], [1198, 1298, 1320, 1320, 1369], [1371, 1431, 1453, 1453, 1501], [1503, 1503, 1525, 1525, 1569], [1571, 1571, 1602, 1602, 1628], [1630, 1681, 1721, 1721, 1870], [1872, 1912, 1951, 1951, 2040], [2042, 2042, 2081, 2081, 2110], [2112, 2112, 2140, 2140, 2998], [3000, 3000, 3055, 3055, 3650]]}
{"id": "fdffDS", "name": "Fast Gaussian-blurred polygon", "author": "Michel_Rouzic", "description": "A real breakthrough in polygon rendering, this directly calculates the Gaussian-blurred pixels of polygons (both concave and convex) in one single pass. This works by approximating the Gaussian-weighted area of the polygon around the pixel.", "tags": ["triangle", "blur", "antialiasing", "gaussianblur", "polygon", "loopless"], "likes": 24, "viewed": 516, "published": 3, "date": "1645277100", "time_retrieved": "2024-07-30T17:02:46.781485", "image_code": "/*\nI, Michel Rouzic, have been researching this problem for years and at last I have just (in February 2022) solved it.\nThis directly calculates, in one pass, a visually fully accurate approximation of a Gaussian-blurred polygon,\nin this case a polygon with 4 (easy to modify) sides which can be concave or convex.\nThis works by calculating the Gaussian-weighted area of the polygon around the coordinate of the pixel being rendered.\nEach side of the polygon forms a subtriangle with the pixel, and each subtriangle is split into two right triangles.\nTheir weights are calculated mainly according to the approximation of an integral, and depending on the angle at the\npixel some other operations have to be done. Then all the weights are added together and multiplied by the colour.\n\nThe Gaussian blurring gets no smaller than 0.8 pixels wide because that's what I consider the best Gaussian blurring\nfor a sharp antialiasing. I made this so that I could render perfectly antialiased polygons (even on the CPU)\nefficiently without any multisampling. I think this method is a pretty big deal due to how efficient and practically\nperfect it is.\n\nBonuses include a fast approximation of the error function (erf) which you can reuse whenever you need erf() and \na way to convert linear pixel values to sRGB without using pow() (although I'm not sure this is more efficient).\n*/\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat erf_fast(float x)\n{\n\tfloat y, xa = abs(x);\n\n\t// erf(x) ~= 1 - exp(<polynomial>) for x >= 0, max error 1/4249\n\t// 2 mad, 1 mul, 1 +-, 1 copysign, 1 exp = ~9 FR\n\ty = ((-0.06388*xa - 0.66186)*xa - 1.123613)*xa;\n\ty = 1. - exp(y);\n\ty *= sign(x);\n\n\treturn y;\n}\n\nfloat erf_right_triangle_acute_integral(float x, float y)\n{\n\tfloat x2 = x*x, y2 = y*y;\n\tfloat v = (((((-1.6663128e-05*y2 + 5.104393e-06)*x2 +\n\t\t\t0.0005496131*y2 - 5.30433e-05)*x2 +\n\t\t\t(0.0001584783*y2 - 0.00741157237)*y2 - 0.0018265954)*x2 +\n\t\t\t(-0.003881739*y2 + 0.0523013844)*y2 + 0.04582956)*x2 +\n\t\t\t((-0.00368418*y2 + 0.03692744)*y2 - 0.1996548)*y2 - 0.50360028)*x2 +\n\t\t\t((-0.0012717*y2 - 0.0101518)*y2 + 0.0109084)*y2 - 1.836892;\n\treturn exp(v) * x2 * y;\t// 25 FR\n}\n\nfloat calc_right_triangle_pixel_weight(vec2 rp)\n{\n\tvec2 rpa;\n\tbool use_obtuse;\n\tfloat slope, acute, obtuse;\n\n\trpa = abs(rp);\n\n\t// Pick method\n\tuse_obtuse = rpa.y > rpa.x;\n\tif (use_obtuse)\t\t\t// if we use the obtuse method\n\t{\n\t\t// Swap axes\n\t\tfloat t = rp.x;\n\t\trp.x = rp.y;\n\t\trp.y = t;\n\t}\n\n\t// Prepare the arguments (slope and clamped x)\n\tslope = abs(rp.x) < 1e-5 ? 0. : rp.y / rp.x;\n\tslope = clamp(slope, -1., 1.);\n\trp.x = clamp(rp.x, -3., 3.);\n\n\tacute = erf_right_triangle_acute_integral(rp.x, slope);\n\tobtuse = 0.25 * erf_fast(rp.y) * erf_fast(rp.x) - acute;\n\tacute = abs(acute) * sign(slope);\n\tobtuse = abs(obtuse) * sign(slope);\n\n\treturn use_obtuse ? obtuse : acute;\n}\n\nfloat calc_subtriangle_pixel_weight(vec2 p0, vec2 p1)\n{\n\tvec2 rot, r0, r1, np;\n\tfloat weight;\n\n\t// Rotate points\n\trot = normalize(p1 - p0);\n\tr0.x = rot.x*p0.y - rot.y*p0.x;\n\tr0.y = rot.x*p0.x + rot.y*p0.y;\n\tr1.x = r0.x;\n\tr1.y = rot.x*p1.x + rot.y*p1.y;\n\n\t// Calc weights\n\tweight = calc_right_triangle_pixel_weight(r1);\n\tweight -= calc_right_triangle_pixel_weight(r0);\n\n\treturn weight;\n}\n\nvec3 draw_tetragon(vec2 p[4], vec3 col, float rad, vec3 pv, vec2 pf)\n{\n\tfloat weight;\n    \n\t// Transform polygon coordinates\n\tp[0] = (p[0] - pf) * rad;\n\tp[1] = (p[1] - pf) * rad;\n\tp[2] = (p[2] - pf) * rad;\n\tp[3] = (p[3] - pf) * rad;\n\n\t// Calculate weight for each subtriangle\n\tweight = calc_subtriangle_pixel_weight(p[0], p[1]);\n\tweight += calc_subtriangle_pixel_weight(p[1], p[2]);\n\tweight += calc_subtriangle_pixel_weight(p[2], p[3]);\n\tweight += calc_subtriangle_pixel_weight(p[3], p[0]);\n\n\t// Apply weight to colour\n\tpv += weight * col;\n\n\treturn pv;\n}\n\nfloat lsrgb(float l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tfloat x, line, curve;\n\n\t// 13 FR every time + 2 FR once\n\tline = l * 12.92;\t// 1 FR\n\tx = sqrt(l);\t// 4 FR\n\tcurve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\t// 5 FR + 2 FR once, error 0.145 sRGB units\n\n\treturn l <= 0.0031308 ? line : curve;\t// 3 FR\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rp, p[4] = vec2[] ( vec2(0., 3.), vec2(1.8, -2.), vec2(0., 0.), vec2(-1.8, -2.) );\n    \n    // Pixel to world coordinates\n    float scrscale = 18. / iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5) * scrscale;\n    \n    // Tetragon rotation\n    float th = iTime * 6.2831853 / 40.;\n    float costh = cos(th);\n    float sinth = sin(-th);\n    \n    for (int i=0; i < 4; i++)\n    {\n        rp.x = p[i].x * costh - p[i].y * sinth;\n        rp.y = p[i].x * sinth + p[i].y * costh;\n        p[i] = rp;\n    }\n    \n    // Varying blurriness\n    float rad = sq(1.-abs(cos(iTime * 6.2831853 / 16.))) * 6.;\n    float min_rad = 0.8*scrscale;\n    rad = length(vec2(rad, min_rad));\n\n    // Time varying pixel color\n    vec3 pv = vec3(0.);\n    pv = draw_tetragon(p, vec3(1.), 1./rad, pv, uv);\n\n    // Output to screen\n    fragColor = vec4(lsrgb(pv.r), lsrgb(pv.g), lsrgb(pv.b), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdffDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1375, 1375, 1394, 1394, 1414], [1416, 1416, 1441, 1441, 1676], [1678, 1678, 1737, 1737, 2148], [2150, 2150, 2199, 2199, 2821], [2823, 2823, 2878, 2878, 3209], [3211, 3211, 3281, 3281, 3765], [3767, 3767, 3856, 3856, 4146]]}
{"id": "NdfBDS", "name": "Infinite Flower", "author": "BryceStansfield", "description": "An infinite spiraling flower.\n\nThis runs into problems when petals are >3 stripes in length, but since it works fine in 1080p I don't think it's worth fixing.", "tags": ["flower"], "likes": 2, "viewed": 156, "published": 3, "date": "1645272050", "time_retrieved": "2024-07-30T17:02:47.601294", "image_code": "#define PI     3.14159265\n// This code all desperately needs to be cleaned, but this is just a quick sketch\n\nfloat magnitude(in vec2 v){\n    return sqrt(pow(v.x, 2.) + pow(v.y, 2.));\n}\n\nfloat ring_offset(in float time){\n    return time;\n}\n\nfloat ring_num_float(in vec2 v, in float ringSize, in float time){\n    return (magnitude(v) + ring_offset(time)*ringSize)/ringSize;\n}\n\nint ring_num(in vec2 v, in float ringSize, in float time){\n    return int(floor(ring_num_float(v, ringSize, time)));\n}\n\nbool should_print_circle_line(in vec2 v, in float ringSize, in float time, in float lineSize){\n    float ringNum = mod(ring_num_float(v, ringSize, time), 1.0);\n    return ringNum < (lineSize/2.0) || ringNum > (1.0 - lineSize/2.0);\n}\n\nvec4 background_colour(in vec2 v, in float ringSize, in float lineSize, in float time){\n    // Params\n    vec4 colours[6] = vec4[6](\n        vec4(255.0, 128.0, 0.0, 255.0)/255.0,    // Orange\n        vec4(0.0, 0.0, 204.0, 255.0)/255.0,      // Dark Blue\n        vec4(0.0, 204.0, 0.0, 255.0)/255.0,      // Green\n        vec4(102.0, 0.0, 204.0, 255.0)/255.0,    // Purple\n        vec4(255.0, 51.0, 255.0, 255.0)/255.0,   // Pink\n        vec4(102.0, 178.0, 255.0, 255.0)/255.0); // Light Blue\n    int coloursLength = 6;\n    \n    return should_print_circle_line(v, ringSize, time, lineSize) ?\n           vec4(0.0, 0.0, 0.0, 1.0) : colours[ring_num(v, ringSize, time) % coloursLength];\n}\n\nvec4 colour_fallthrough(in vec4 colourOne, in vec4 colourTwo){\n    // Calculates how colourTwo should show through colourOne\n    // Assumes colourTwo.w == 1.0\n    return vec4(colourOne.w * colourOne.xyz + (1.0-colourOne.w) * colourTwo.xyz, 1.0);\n}\n\nfloat angle_distance(in float a1, in float a2){\n    // I desperately need to make this function nicer\n    a1 = mod(a1 + PI, 2.0*PI) - PI;\n    a2 = mod(a2 + PI, 2.0*PI) - PI;\n    return min(min(abs(a2-a1), a2 + 2.0*PI - a1), a1 + 2.0*PI - a2);\n}\n\nbool is_stem(in int numPetals, in float stemRefAngle, in float stemRefAngleTip, in float pointAngle, in float ringNumber, in float tolerance){\n    bool isStem = false;\n    float piDiv = (2.0*PI)/float(numPetals);\n    bool tipEnabled = mod(ringNumber, 1.0) <= 0.5;\n    \n    for(int i = 0; i < numPetals; i++){\n        float refAngle = stemRefAngle + float(i) * piDiv;\n        float refAngleTip = stemRefAngleTip + float(i) * piDiv;\n        isStem = isStem || angle_distance(refAngle, pointAngle) < tolerance;\n        isStem = isStem || (tipEnabled && angle_distance(refAngleTip, pointAngle) < tolerance);\n    }\n    return isStem;\n}\n\nbool is_in_ball(in int numPetals, in vec2 coords, in int ringNumberInt, in float time, in float ringSize, in float stemRefAngleTip, in float angleToMatch){\n    bool isInBall = false;\n    \n    float piDiv = (2.0*PI)/float(numPetals);\n    \n    float ballMidRing = float(ringNumberInt)+0.5 - ring_offset(time);\n    float ballRadius = tan(angleToMatch)*ballMidRing*ringSize;\n    \n    for(int i = 0; i < numPetals; i++){\n        float refAngleTip = stemRefAngleTip + float(i) * piDiv;\n        vec2 ballCentre = vec2(cos(refAngleTip)*ballMidRing*ringSize, sin(refAngleTip)*ballMidRing*ringSize);\n        isInBall = isInBall || magnitude(coords-ballCentre) <= ballRadius;\n    }\n    \n    return isInBall;\n}\nvec4 petals(in vec2 coords, in float ringSize, in float time){\n    // Params\n    int numPetals = 3;\n\n    // Setting up the petal mask\n    float ringNumber = ring_num_float(coords, ringSize, time);\n    int ringNumberInt = int(floor(ringNumber));\n    \n    vec4 petalMask = vec4(1.0, 1.0, 1.0, 1.0);\n    petalMask = petalMask * float(ringNumber >= 1.0);\n    \n    // Is this part of a petal stem?\n    float pointAngle = atan(coords.y, coords.x);\n    float stemRefAngle = PI/3.0 - (float(ringNumberInt)-1.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt) - ring_offset(time)));\n    float stemRefAngleTip = PI/3.0 - (float(ringNumberInt)-2.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt-1) - ring_offset(time)));\n    float stemRefAngleOverhangTip = PI/3.0 - (float(ringNumberInt)-3.0) * 0.2 + iTime * (0.1 + 0.03 * (float(ringNumberInt-2) - ring_offset(time)));\n    \n    bool tipEnabled = mod(ringNumber, 1.0) <= 0.5;\n    float twoPiOnThree = (2.0 * PI)/3.0;\n    \n    bool isStem = is_stem(numPetals, stemRefAngle, stemRefAngleTip, pointAngle, ringNumber, 0.05);\n    petalMask = isStem ? petalMask : vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // What about the petal stems line?\n     \n    bool isStemLine = is_stem(numPetals, stemRefAngle, stemRefAngleTip, pointAngle, ringNumber, 0.06);\n    petalMask = !isStem && isStemLine ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    // Finally, what about the ball_ends of the petals    \n    bool isInBall = is_in_ball(numPetals, coords, ringNumberInt, time, ringSize, stemRefAngleTip, 0.05);\n    petalMask = isInBall ? vec4(1.0, 1.0, 1.0, 1.0) : petalMask;\n    \n    bool isInBallLine = is_in_ball(numPetals, coords, ringNumberInt, time, ringSize, stemRefAngleTip, 0.06);\n    petalMask = isInBallLine && !isInBall && !isStem ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    // And what is the ball is too large for 1 stripe, but can fit in two?\n    bool isInBall2 = is_in_ball(numPetals, coords, ringNumberInt-1, time, ringSize, stemRefAngleOverhangTip, 0.05);\n    petalMask = isInBall2 ? vec4(1.0, 1.0, 1.0, 1.0) : petalMask;\n    \n    bool isInBallLine2 = is_in_ball(numPetals, coords, ringNumberInt-1, time, ringSize, stemRefAngleOverhangTip, 0.06);\n    petalMask = isInBallLine2 && !isInBall && !isInBall2 && !isStem ? vec4(0.0, 0.0, 0.0, 1.0) : petalMask;\n    \n    return petalMask;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Params\n    float ringSize = 50.0;\n    float lineSize = 0.05;\n    \n    \n    vec2 centre = iResolution.xy/2.0;\n    \n    \n    // Adjusted coordinates\n    vec2 centreAdjustedCoords = fragCoord - centre;\n    float time = iTime * 0.1 + 1.0;\n    \n\n    // Output to screen\n    fragColor = colour_fallthrough(petals(centreAdjustedCoords, ringSize, time),\n    background_colour(centreAdjustedCoords, ringSize, lineSize, time));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 136, 136, 184], [186, 186, 219, 219, 238], [240, 240, 306, 306, 373], [375, 375, 433, 433, 493], [495, 495, 589, 589, 727], [729, 729, 816, 830, 1412], [1414, 1414, 1476, 1572, 1661], [1663, 1663, 1710, 1764, 1907], [1909, 1909, 2051, 2051, 2539], [2541, 2541, 2696, 2696, 3239], [5570, 5570, 5625, 5639, 6052]]}
{"id": "ssffRf", "name": "Colored Infinite Spheres", "author": "codebender", "description": "I'm new to raymarching so please tell me in the comments if there is anything that I did wrong or could have done better", "tags": ["raymarching", "fractals"], "likes": 5, "viewed": 318, "published": 3, "date": "1645271527", "time_retrieved": "2024-07-30T17:02:48.351288", "image_code": "vec3 rotateVector(vec3 p, float q, float q2) {\n    p = vec3(p.x*cos(q) - p.y*sin(q), p.x*sin(q) + p.y*cos(q), p.z);\n    p = vec3(p.x*cos(q2)+p.z*sin(q2), p.y, -p.x*sin(q2)+p.z*cos(q2));\n    return p;\n}\n\nfloat sdSphere(vec3 p, float s, vec3 pos)\n{\n    p -= pos;\n    return length(p)-s;\n}\n\nfloat map(vec3 p) {\n    float d = sdSphere(mod(p, 1.), .15, vec3(0.5, 0.5+sin(floor(p.z/1.)+floor(p.x/1.)+iTime*10.)*.05, 0.5));\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n\t\tmap(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n\t\tmap(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n\t\t));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec3 point_light_pos = vec3(1., 1., 1.);\n\n    vec3 cam_pos = vec3(iTime*2., iTime, iTime*5.);\n    vec3 ray_dir = normalize(vec3(fragCoord.x/iResolution.y-iResolution.x/iResolution.y/2., fragCoord.y/iResolution.y-1./2., 1.));\n    ray_dir = rotateVector(ray_dir, sin(iTime)*.5, sin(iTime*.35)*.5);\n    \n    float closest_distance = 10000.;\n    bool hit = false;\n    vec3 hit_pos = cam_pos;\n    float t = 0.;\n    for (int i = 0; i < 60; i += 1) {\n        t = map(hit_pos);\n        hit_pos += ray_dir*t;\n        if (t < .001) {\n            hit = true;\n            break;\n        }\n        closest_distance = min(t, closest_distance);\n    }\n    \n    float light_power = (dot(calcNormal(hit_pos), normalize(point_light_pos-hit_pos))+1.)/2.;\n    \n    float depth = distance(hit_pos, cam_pos);\n    \n    float vignette = (1.-abs(fragCoord.x-iResolution.x/2.)/iResolution.x)*(1.-abs(fragCoord.y-iResolution.y/2.)/iResolution.y);\n    \n    if (hit) {\n        fragColor = smoothstep(1., vignette/40., depth/10.)*vignette*vec4(random(floor(hit_pos/1.)), random(floor(hit_pos/1.)+vec3(1., 1., 1.)), random(floor(hit_pos/1.)+vec3(5., 5., 5.)), 1.);\n    } else {\n        fragColor = vignette/40.*vec4(1.);\n    }\n    \n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** RANDOM **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (vec3 st) {\n    return fract(sin(dot(st.xyz,\n                         vec3(12.9898,78.233, 15.234)))*\n        43758.5453123);\n}\n\n\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** PERLIN NOISE **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssffRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 201], [203, 203, 246, 246, 286], [288, 288, 307, 307, 432], [434, 434, 459, 459, 677], [679, 679, 734, 734, 1945]]}
{"id": "7ssfzs", "name": "perception: hidden numbers", "author": "FabriceNeyret2", "description": "Which number do you read ? \nthis is related to your contrast sensitivity function.\nClick for motion or scrolling fast or eye squinting++ change things. \nref: https://www.dailymail.co.uk/femail/article-10526875/What-number-Optical-illusion-goes-viral.html", "tags": ["illusion", "perception", "reproduction"], "likes": 9, "viewed": 282, "published": 3, "date": "1645265806", "time_retrieved": "2024-07-30T17:02:49.162120", "image_code": "// utils from https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n\n\nvoid mainImage(out vec4 O,  vec2 U )\n{\n\tvec2  R = iResolution.xy, p = 2.*U-R;\n    float t = iMouse.z > 0. ? iTime : 0.,                       // click for motion\n          a = 100.* ( atan(p.y,p.x) +0.*length(p)/R.y + t ),    // rays pattern\n          v = mix( .5+.5*cos(a)* smoothstep(6.14,0.,fwidth(a)), // display rays\n                   pInt( p/360.-vec2(1,-.5), 3452839. ).x,      // display digits\n                   .05 );\n    O = vec4( pow( v, 1./2.2 ) );                               // to sRGB\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 78, 78, 309], [310, 310, 338, 338, 458], [461, 461, 499, 499, 967]]}
{"id": "7ssBRs", "name": "Abominable Plasma", "author": "oneshade", "description": "I've forgotten what I was actually trying to do. Click with the mouse if the texture loads late and nothing appears.", "tags": ["plasma", "zoom", "convolution", "trippy", "spin"], "likes": 6, "viewed": 190, "published": 3, "date": "1645251146", "time_retrieved": "2024-07-30T17:02:49.978936", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // 4x scale\n    uv = (uv - 0.5) * 0.25 + 0.5;\n\n    //float y = uv.y - fract(iTime);\n    //uv.y += 1.0 * exp(-200.0 * y * y) * y;\n\n    fragColor = texture(iChannel0, uv);\n\n    // Weird colors\n    fragColor.rgb = cos(10.0 * fragColor.rgb);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    if (iFrame == 0 || iMouse.z > 0.0) {\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    }\n\n    else {\n        float rot = 0.02;// * cos(0.05 * iTime);\n        float co = cos(rot), si = sin(rot);\n        mat2 spin = mat2(co, si, -si, co);\n\n        // Move, spin, zoom\n        fragCoord -= vec2(cos(iTime), sin(iTime));\n        fragCoord = spin * (fragCoord - 0.5 * iResolution.xy) * 0.99 + 0.5 * iResolution.xy;\n\n        // Emboss convolution matrix\n        float emb = 0.3;//0.24;\n        mat3 kernel = mat3(emb,  0.0,  0.0,\n                           0.0,  1.0,  0.0,\n                           0.0,  0.0, -emb);\n\n        // Convolve\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                vec4 color = texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy);\n                float convWeight = kernel[j + 1][i + 1];\n                fragColor += color * convWeight;\n            }\n        }\n\n        // Normalize\n        //fragColor.rgb /= max(abs(fragColor.r), max(abs(fragColor.g), abs(fragColor.b)));\n        //fragColor.rgb = normalize(fragColor.rgb);\n        fragColor.rgb = exp2(normalize(log2(abs(fragColor.rgb) + 0.00001)));\n        fragColor.rgb /= max(abs(fragColor.r), max(abs(fragColor.g), abs(fragColor.b)));\n        //fragColor.rgb *= 0.993;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 342]]}
{"id": "sdlfRl", "name": "Fractal nice colors", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 12, "viewed": 238, "published": 3, "date": "1645236638", "time_retrieved": "2024-07-30T17:02:51.050072", "image_code": "mat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n      \n    float m = 0.16;\n    float th = 0.8 * iTime;\n    float n = 4.; // other values look cool too\n    vec2 id = vec2(1.);\n    for(float i = 0.; i < n; i++) {      \n        uv *= Rot(2. * pi * h21(id) + length(ouv) + 0.2 * iTime);\n       \n        id *= 0.5;\n        id += vec2(step(uv.x, 0.), step(uv.y, 0.));\n        \n        th += 0.5 * pi / n * cos(th); // can remove cos(th)\n        \n        vec2 p = 0.5 * vec2(thc(8., th), ths(8., th)) - 0.5;\n        uv = abs(uv - 0.5 * m * abs(p) + 0. * m) - m;\n        m *= 0.5;\n    }\n       \n    // maybe dont include 0.1*length(ouv)\n    float h = h21(id + floor(h21(id) + 0.1 * length(ouv) + 0.2 * iTime));\n    h = smoothstep(0., 1., h);\n    \n    float d = length(uv);\n    float k = 2.4;//mix(0.1, 2., 0.5 + 0.5 * thc(3., 2. * pi * h + iTime)); //1./iResolution.y;\n    float s = smoothstep(-k, k, -d + 2.* m); //2m not needed\n     \n    vec3 e = vec3(1.);\n    vec3 col = s * pal(0.4 * ouv.y + h, e, e, e, 0.45 * vec3(0,1,2)/3.);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 144, 144, 1259]]}
{"id": "7ssBzX", "name": "Hell 2", "author": "iq", "description": "A remix of [url]https://www.shadertoy.com/view/MdfGRX[/url]", "tags": ["3d", "raymarching", "cloud", "volumetric"], "likes": 87, "viewed": 3502, "published": 3, "date": "1645230915", "time_retrieved": "2024-07-30T17:02:55.801369", "image_code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// Just a remix of https://www.shadertoy.com/view/MdfGRX\n\n//------------------------------------------------------------------\n// noise\n//------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat noise1( in float x )\n{\n    float p = floor(x);\n    float w = fract(x);\n    float u = w*w*(3.0-2.0*w);\n    return mix(hash(p+0.0),hash(p+1.0),u);\n}\n\nfloat noise( in vec3 x )\n{\n#if 0\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*(3.0-2.0*w);\n    float n = 1.0*p.x + 317.0*p.y + 157.0*p.z;\n    return mix( mix( mix(hash(n+  0.0),hash(n+  1.0),u.x),\n                     mix(hash(n+317.0),hash(n+318.0),u.x),u.y),\n                mix( mix(hash(n+157.0),hash(n+158.0),u.x),\n                     mix(hash(n+474.0),hash(n+475.0),u.x),u.y),u.z);   \n#else\n    return textureLod(iChannel0,x/32.0,0.0).x;\n#endif    \n}\n\n//------------------------------------------------------------------\n\nvec4 map( vec3 p, float time )\n{\n    // density\n\tfloat den = 0.2 - p.y;\n\n    // invert space\t(https://en.wikipedia.org/wiki/Inversive_geometry)\n\tp = p/dot(p,p);\n    \n    // scale and reverse\n    p = -7.0*p;\n\n    // twist space\t\n\tfloat co = cos(0.8*den);\n\tfloat si = sin(0.8*den);\n\tp.xz = mat2(co,-si,si,co)*p.xz;\n\n    // cloud\t\n\tfloat f;\n    float t = time + 9.0;\n\tvec3 q = p                           - vec3(0.0,t*0.2,0.0);\n    f  = 0.500000*noise( q ); q = q*2.21 - vec3(0.0,t*0.4,0.0);\n    f += 0.250000*noise( q ); q = q*2.15 - vec3(0.0,t*0.8,0.0);\n    f += 0.125000*noise( q ); q = q*2.13 - vec3(0.0,t*1.6,0.0);\n    f += 0.062500*noise( q ); q = q*2.05 - vec3(0.0,t*3.2,0.0);\n    f += 0.031250*noise( q );\n\n\tden = den + 4.0*f + 0.015;\n\t\n    vec3 col = mix( vec3(0.8), vec3(0.5), den ) + 0.02*sin(p);\n\t\n\treturn vec4( col, den );\n}\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel, float time )\n{\n    // lightining\n    float li = 1.0;\n    li *= smoothstep(0.6,0.65,noise1( time*11.2 + 6.1 ));\n    li *= smoothstep(0.4,0.45,noise1( time*1.1 + 6.1 ));\n\n    // raymarch\n    vec4 sum = vec4( 0.0 );\n    \n    const float stepFactor = 0.5;\n\n\t// with dithering\n    float t = 0.05 *fract(sin(iTime+pixel.x*11.0+17.0*pixel.y)*1.317);    \n\tfor( int i=0; i<256; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos, time );\n\n        if( col.w>0.0 )\n        {\n            float len = length(pos);\n            float at = smoothstep(2.0,0.0,len);\n            col.xyz *= mix( 2.5*vec3(0.3,0.4,0.5), 0.9*vec3(0.4,0.45,0.55), clamp( (pos.y-0.1)/2.0, 0.0, 1.0 ) );\n            col.xyz *= 1.0 + 0.15*at + 1.5*li*at;\n\n            //if( li>0.001 )\n            {\n            vec3 dir = pos/len;\n            float nn = max(0.0,col.w - map( pos-dir*0.05, time ).w);\n            col.xyz += 2.0*li*(0.5+1.5*at)*nn*vec3(0.8,0.8,0.8)*(1.0-col.w);\n            }\n\n            // fog\n            col.xyz *= 1.15*exp2(-t*0.1);\n\n            // compose\t\t\n            col.a *= stepFactor;\n            col.rgb *= col.a;\n            sum = sum + col*(1.0 - sum.a);\t\n            if( sum.a > 0.99 ) break;\n        }\n\n\t\tt += 0.1*stepFactor;\n\t}\n\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    // camera\n    vec3 ro = 4.0*normalize(vec3(1.0, 1.5, 0.0));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n\tfloat cr = 0.4*cos(0.4*iTime);\n\t\n    // shake\t\t\n\tro += 0.01*(-1.0+2.0*noise1(3.1*time));\n\tta += 0.01*(-1.0+2.0*noise1(3.3*time));\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n    // raymarch\t\n    \n\tvec3 col = raymarch( ro, rd, fragCoord, time );\n\n    // color grade\n    col = col*col*(3.0-2.0*col);\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n    col *= 1.2;\n    \n    // vignette\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= 0.1 + 0.9*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBzX.jpg", "access": "api", "license": "proprietary-license", "functions": [[700, 847, 870, 870, 921], [923, 923, 951, 951, 1075], [1077, 1077, 1103, 1103, 1552], [1624, 1624, 1656, 1671, 2458], [2460, 2460, 2528, 2546, 3775], [3777, 3777, 3834, 3834, 4708]]}
{"id": "fdsBRl", "name": "one line portraits", "author": "FabriceNeyret2", "description": "inspired by\nreference: https://www.reddit.com/r/pics/comments/soujbu/been_experimenting_more_with_one_line_portraits/\n\n( the line turns are just outside the frame :-D )", "tags": ["2tweets", "short", "reproduction"], "likes": 17, "viewed": 330, "published": 3, "date": "1645213972", "time_retrieved": "2024-07-30T17:02:56.719913", "image_code": "\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 9.* ( u+u - R ) / R.y;\n         U += vec2(U.y,-U);                    // scaling and tilt\n         \n    float x = fract(U.x -=  sin(.6*U.y) )-.5,  // woobly bands\n          y = .3*sin(12.*U.y)                  // high freq \n            * (1.-texture(iChannel0, u/R).r);  // modulation\n \n    O = vec4( abs(x-y) / fwidth(U.x - y) );    // antialiasing draw\n // O += texture(iChannel0, u/R);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 472]]}
{"id": "sdXBzs", "name": "Fractal breathing", "author": "tdhooper", "description": "I was playing with @macbooktall's IFS and this pair of lungs appeared.\n\nRendered animation here https://twitter.com/tdhooper/status/1494669344021913601", "tags": ["sss", "ifs"], "likes": 29, "viewed": 1011, "published": 3, "date": "1645204130", "time_retrieved": "2024-07-30T17:02:58.028415", "image_code": "vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define ANIMATE\n#define SSS\n#define DOF\n\nfloat guiRotPhaseX = .591;\nfloat guiRotPhaseY = .366;\nfloat guiRotPhaseZ = .5005000000000001;\nfloat guiAnimPhaseX = -.42;\nfloat guiAnimPhaseY = .33;\nfloat guiAnimPhaseZ = .0;\nfloat guiOffsetX = .66;\nfloat guiOffsetY = .37;\nfloat guiOffsetZ = .18;\nfloat spaceAnimFreq = .06;\nfloat startScale = 1.5;\nvec3 animAmp = vec3(-.02,.02,-.06) * 3.;\n \n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat time;\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n    bool sss;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    vec3 skin = pow(vec3(0.890,0.769,0.710), vec3(2.2));\n    float flush = smoothstep(-1.75, -.0, model.albedo.x);\n    skin += mix(vec3(-.6,.0,.15) * .5, vec3(.4,-.03,-.05), flush);\n    skin *= vec3(1.1,.8,.7);\n    skin = clamp(skin, vec3(0,0,0), vec3(1,1,1));\n    bool sss = false;\n    #ifdef SSS\n    sss = true;\n    #endif\n    return Material(skin, .15, .3, sss);\n}\n\n\n// IFS from Connor Bell (macbooktall)\nModel map(vec3 p) {\n\n    p.y += .12;\n    pR(p.yz, .75);\n\n    float s = .3;\n    p /= s;\n\n    vec3 pp = p;\n\n    float scale = startScale;\n\n    const int iterations = 20;\n\n    float l = 0.;\n    float len = length(p) * spaceAnimFreq*2.;\n\n    float phase = time * PI * 2. + len * -5.0;\n\n    vec3 rotPhase = vec3(guiRotPhaseX, guiRotPhaseY, guiRotPhaseZ) * PI * 2.;\n    vec3 animPhase = vec3(guiAnimPhaseX, guiAnimPhaseY, guiAnimPhaseZ) * PI * 2.;\n    vec3 offset = vec3(guiOffsetX, guiOffsetY, guiOffsetZ);\n\n    vec3 anim = len + rotPhase + sin(phase + animPhase) * animAmp;\n \n    float orbitTrap = 1e20;\n    for (int i=0; i<iterations; i++) {\n        p.xz = abs(p.zx);\n        p = p * scale - offset;\n        pR(p.xz, anim.x);\n        pR(p.yz, anim.y);\n        pR(p.xy, anim.z);\n        orbitTrap = min(orbitTrap, length(p)-scale);\n    }\n\n    float d = length(p) * pow(scale, -float(iterations));\n\n    p = pp;\n    d = smax(d, -(length(p * vec3(1,1,.75)) - .4), .1);\n\n    d *= s;\n\n\n    return Model(d, p, vec3(orbitTrap), 1);\n\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).d - map(p-h.xyy).d,\n                           map(p+h.yxy).d - map(p-h.yxy).d,\n                           map(p+h.yyx).d - map(p-h.yyx).d ) );\n}\n\n\nvec3 sunPos = normalize(vec3(-.5,.5,-.25)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 4.5;\n\n\nvec3 env(vec3 dir, bool includeSun) {\n    vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dir.y));\n    return col * .6;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 400; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n\n        if (model.d < .0002) break;\n\n        if (rayLength > maxDist) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// Walk on spheres subsurface scattering\n// inspired by blackle https://www.shadertoy.com/view/wsfBDB\nHit walkOnSpheres(vec3 origin, vec3 normal, float startdepth, inout vec2 seed) {\n    Model model;\n    \n    vec2 lastSeed = seed;\n    seed = hash22(seed);\n    normal = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n    \n    model = map(origin - normal * startdepth);\n    origin -= normal * abs(model.d);\n    \n    for (int v = 0; v < 250; v++) {\n        model = map(origin);\n\n        if (abs(model.d) < .00002) break;\n        \n        vec2 lastSeed = seed;\n        seed = hash22(seed);\n        vec3 dir = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n        \n        origin += dir * abs(model.d);\n    }\n    return Hit(model, origin);\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor/10. * diffuse;\n        }\n    }\n    return col;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// noby https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 nor, vec3 rayDir, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(-rayDir + l);\n    float dnl = clamp(dot(nor,l), 0.0, 1.0);\n    float dnv = clamp(dot(nor,rayDir), 0.0, 1.0);\n    float dnh = clamp(dot(nor,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 sphereLight(vec3 lightPos, float radius, vec3 pos, vec3 rayDir, vec3 nor) {\n    vec3 L = (lightPos - pos);\n    vec3 ref = reflect(rayDir, nor);\n    vec3 centerToRay = dot(L, ref) * ref - L;\n    vec3 closestPoint = L + centerToRay * clamp(radius / length(centerToRay), 0., 1.);\n    return closestPoint;\n}\n\nvec3 sampleDirectSpec(Hit hit, vec3 rayDir, vec3 nor, float rough, inout vec2 seed) {\n    vec3 lpos = sphereLight(sunPos, 5., hit.pos, rayDir, nor);\n    \n    vec3 lightDir = normalize(lpos - hit.pos);\n    vec3 h = normalize(rayDir + lightDir);\n    float specular = pow(clamp(dot(h, nor), 0., 1.), 64.0);\n\n    vec3 col = vec3(0);\n\n    float fresnel = pow(max(0., 1. + dot(nor, rayDir)), 5.);\n    specular = ggx(nor, rayDir, lightDir, rough, fresnel);\n\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightDir, nor)));\n    if (specular > 0.) {\n        Hit sh = march(shadowOrigin, lightDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += sunColor * specular * .1;\n        }\n    }\n    return col;\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    \n    p *= .85;\n\n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(0,0,.4) * focalLength * 1.;\n    vec3 camTar = vec3(0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    //vec3 origin = eye;\n    //vec3 rayDir = normalize(vec3(p.x * fov, p.y * fov, -1.) * mat3(vView));\n\n\n    #ifdef DOF\n    float fpd = .36 * focalLength;\n    vec3 fp = origin + rayDir * fpd;\n    origin = origin + camMat * vec3(rndunit2(seed), 0.) * .02;\n    rayDir = normalize(fp - origin);\n    #endif\n\n    Hit hit;\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = skyColor;\n    bool doSpecular = true;\n\n    const int MAX_BOUNCE = 3;\n    \n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        hit = march(origin, rayDir, 10., .5);\n   \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0 && ! doSpecular)\n                col += env(rayDir, doSpecular) * throughput;\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        seed = hash22(seed);\n        doSpecular = hash12(seed) < material.specular;\n        \n        bool doSSS = material.sss && bounce < 1 && ! doSpecular;\n        if (doSSS) {\n            seed = hash22(seed);\n            doSSS = hash12(seed) < .8;\n        }\n        \n        if ( ! doSpecular) {\n            // update the colorMultiplier\n            throughput *= material.albedo;\n        }\n\n        if (doSSS) {\n            origin = hit.pos;\n            \n            seed = hash22(seed);\n            hit = walkOnSpheres(origin, nor, .05, seed);\n            nor = calcNormal(hit.pos);\n\n            float extinctionDist = distance(origin, hit.pos) * 10.;\n            vec3 extinctionCol = material.albedo;\n            extinctionCol = mix(mix(extinctionCol, vec3(0,0,1), .5), vec3(1,0,0), clamp(extinctionDist - 1., 0., 1.));\n            vec3 extinction = (1. - extinctionCol);\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            extinction = clamp(extinction, vec3(0), vec3(1));\n            throughput *= extinction;\n        }\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular)\n        {\n            seed = hash22(seed);\n            col += sampleDirect(hit, nor, throughput, seed);\n            rayDir = diffuseRayDir;\n        }\n        else\n        {\n            if (bounce == 0) { // fix fireflies from diffuse-bounce specular\n                seed = hash22(seed);\n                col += sampleDirectSpec(hit, rayDir, nor, material.roughness, seed) * throughput;\n            }\n            \n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = 0.5;\n\n    #ifdef ANIMATE\n        time = fract(iTime / 4.);\n        \n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        \n        vec4 col = vec4(0.);\n        const int c = 4;\n        for (int i = 0; i < c; i++) {\n            col += draw(fragCoord, iFrame * c + i);\n        }\n        col /= float(c);\n        \n        col = mix(col, lastCol, .2);\n    #else\n        vec4 col = draw(fragCoord, iFrame);\n        if (iFrame > 0 && iMouse.z <= 0.) {\n            vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            col += lastCol;\n        }\n    #endif\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 210], [212, 212, 267, 267, 453]]}
{"id": "Nlc3Df", "name": "Fork Fork Fork  gchipunov 019", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 174, "published": 3, "date": "1645202445", "time_retrieved": "2024-07-30T17:02:58.939977", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(4.0/uv.y,2.0,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/2.5 +col/ 5.0 +mix(col3,col2,cos(iTime));//;\ncol5 = col5 + col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 795]]}
{"id": "sdfBRs", "name": "jpg sandwich", "author": "lennyjpg", "description": "for martin", "tags": ["dsfgsdfgsdfgsdfg"], "likes": 3, "viewed": 248, "published": 3, "date": "1645197926", "time_retrieved": "2024-07-30T17:02:59.744825", "image_code": "\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float n = snoise(uv * 2.2 + iTime * 0.5);    \n    vec3 img1 = texture(iChannel0, uv).rgb;\n    vec3 img2 = texture(iChannel1, uv).rgb;\n    vec3 mixed = uv.x > 0.5 ? vec3(n) : mix(img1, img2, n);\n    fragColor = vec4(mixed,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 62], [64, 64, 85, 85, 905], [909, 909, 966, 966, 1239]]}
{"id": "7dlfRf", "name": "Jacobi Theta Functions", "author": "oneshade", "description": "Complex plot of the Jacobi theta functions.\n[url=https://mathworld.wolfram.com/JacobiThetaFunctions.html]https://mathworld.wolfram.com/JacobiThetaFunctions.html[/url]\nDrag with the mouse to change the nome (q).", "tags": ["complex", "jacobi", "theta", "thetafunction"], "likes": 16, "viewed": 239, "published": 3, "date": "1645171570", "time_retrieved": "2024-07-30T17:03:00.698276", "image_code": "/*\nOddly enough, I found out about the Jacobi theta functions\nwhen I was trying to find the \"exact\" value of the infinite\ndecimal 0.1010010001000010000010000001...\n\nBy expanding the decimal into an infinite sum of powers of ten\n(specifically, triangular number powers because of the constant\nincrease in the gaps between ones) and manipulating it a bit, it\ncan be expressed in terms of the second Jacobi theta function:\n10^(1/8) * ϑ2(0, 1/10^(1/2)) / 2 - 1\n*/\n\n#define k 24.0\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// Jacobi theta function 1, 2, 3, and 4\nvec2 theta1(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    float s = 1.0;\n    for (float n=0.0; n <= k; n++) {\n        w += s * cmul(cpow(q, sqr(n + 0.5)), csin((2.0 * n + 1.0) * z));\n        s = -s;\n    }\n\n    return 2.0 * w;\n}\n\nvec2 theta2(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    for (float n=0.0; n <= k; n++) {\n        w += cmul(cpow(q, sqr(n + 0.5)), ccos((2.0 * n + 1.0) * z));\n    }\n\n    return 2.0 * w;\n}\n\nvec2 theta3(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    for (float n=1.0; n <= k; n++) {\n        w += cmul(cpow(q, n * n), ccos(2.0 * n * z));\n    }\n\n    return 2.0 * w + 1.0;\n}\n\nvec2 theta4(in vec2 z, in vec2 q) {\n    vec2 w = vec2(0.0);\n    float s = 1.0;\n    for (float n=1.0; n <= k; n++) {\n        w += s * cmul(cpow(q, n * n), ccos(2.0 * n * z));\n        s = -s;\n    }\n\n    return 2.0 * w + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    vec2 mouse = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.62, 0.74);\n\n    vec2 q = mouse;\n    vec2 w = vec2(0.0);\n\n    // ϑ1(z, q) in lower left quadrant\n    if (uv.x < 0.0 && uv.y < 0.0) {\n        vec2 z = 2.0 * uv + 1.0;\n        z.x *= aspect;\n        w = theta1(z, q);\n    }\n\n    // ϑ2(z, q) in lower right quadrant\n    if (uv.x > 0.0 && uv.y < 0.0) {\n        vec2 z = 2.0 * uv + vec2(-1.0, 1.0);\n        z.x *= aspect;\n        w = theta2(z, q);\n    }\n\n    // ϑ3(z, q) in upper right quadrant\n    if (uv.x > 0.0 && uv.y > 0.0) {\n        vec2 z = 2.0 * uv - 1.0;\n        z.x *= aspect;\n        w = theta3(z, q);\n    }\n\n    // ϑ4(z, q) in upper left quadrant\n    if (uv.x < 0.0 && uv.y > 0.0) {\n        vec2 z = 2.0 * uv + vec2(1.0, -1.0);\n        z.x *= aspect;\n        w = theta4(z, q);\n    }\n\n    // Domain coloring\n    color = hue2rgb(carg(w) / tau + 0.5);\n\n    // Dividers\n    if (abs(fragCoord.x - 0.5 * iResolution.x) < 2.0) color = vec3(0.0);\n    if (abs(fragCoord.y - 0.5 * iResolution.y) < 2.0) color = vec3(0.0);\n\n    // Label quadrants\n    uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n\n    // θ1\n    drawChar(color, vec3(0.0), uv, -corner + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, -corner + vec2(0.15, 0.1), vec2(0.1), 49);\n\n    // θ2\n    drawChar(color, vec3(0.0), uv, vec2(0.0, -corner.y) + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(0.0, -corner.y) + vec2(0.15, 0.1), vec2(0.1), 50);\n\n    // θ3\n    drawChar(color, vec3(0.0), uv, vec2(0.1), vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(0.15, 0.1), vec2(0.1), 51);\n\n    // θ4\n    drawChar(color, vec3(0.0), uv, vec2(-corner.x, 0.0) + 0.1, vec2(0.1), 133);\n    drawChar(color, vec3(0.0), uv, vec2(-corner.x, 0.0) + vec2(0.15, 0.1), vec2(0.1), 52);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sqr(in float x) { return x * x; }\n\n// Constants\n#define pi 3.1415926536\n#define rho 1.5707963268\n#define tau 6.2831853072\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// ------------------------ Complex math (minified) ------------------------\n\n// Miscellaneous\nfloat carg(in vec2 z) { return atan(z.y, z.x); }\n\n// Elementary operations (+, -, *, /)\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\n\n// Powers\nvec2 cpow(in vec2 z, in float w) {\n    float a = carg(z) * w;\n    return vec2(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\n// Hyperbolic functions\nvec2 csinh(in vec2 z) { return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y)); }\nvec2 ccosh(in vec2 z) { return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y)); }\n\n// Trigonometric functions\nvec2 csin(in vec2 z) { return csinh(z.yx).yx; }\nvec2 ccos(in vec2 z) { return ccosh(vec2(z.y, -z.x)); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 556, 660, 660, 995], [997, 1037, 1072, 1072, 1270], [1272, 1272, 1307, 1307, 1466], [1468, 1468, 1503, 1503, 1653], [1655, 1655, 1690, 1690, 1879], [1881, 1881, 1936, 1936, 4004]]}
{"id": "7dlBRf", "name": "Ordinary Glass, with Comments", "author": "elenzil", "description": "first take at transparency.\n\nmouse to orbit.  Lower Left = auto-orbit.  Upper Left = cross-eyed stereo + auto-orbit.", "tags": ["reflection", "transparency", "glass", "recursion", "queue"], "likes": 17, "viewed": 412, "published": 3, "date": "1645169160", "time_retrieved": "2024-07-30T17:03:01.935967", "image_code": "// Fork of \"Ordinary Glass, with Comments\" by elenzil. https://shadertoy.com/view/7dlBRf\n// 2022-02-23 00:29:54\n\n/*\n\n    Ordinary Glass, with Comments\n    -----------------------------\n    \n    I've been wanting for a long time to try an approach to glass.\n    The main tricky/interesting part is how to handle the growing number of rays.\n    In raytracing simple materials, each pixel results in one ray\n    that travels into the scene and hits something, and maybe gets reflected,\n    but it's still one ray at a time.\n    But when a ray hits a glassy surface, it splits into two:\n    one child ray gets transmitted through the material and one gets reflected.\n    Then each of those split into two, and so on.\n    \n    In a normal CPU environment you would handle this ray-branching with recursion\n    but GPUs have no recusion. So I thought I'd try keeping a queue of rays,\n    and have a loop that runs forever, pulling rays from the queue and either\n    finishing the ray by contributing color to the pixel or forking into one or more\n    child-rays. Along the way each ray has to remember what share of contribution\n    it has for the scene.\n    \n    It looks like this:\n    \n    1. Find the initial ray leaving the pixel and entering the scene.\n       This ray has full contribution of 1.  Add it to the queue.\n\n    2. While the ray queue is not empty:\n       * pull a ray out of the queue.\n       * march it until it hits a surface or reaches the marching limit.\n         * if it reaches the marching limit, color it Sky.\n         * if it reaches a surface:\n           * use some fraction of the ray's \"contribution\" for diffuse shading.\n             this involves another marching step for shadows.\n           * use the remaining fraction to create child rays for reflection and transmission,\n             and add them to the queue.\n             \n    This was my first time marching through the dark (in) side of the SDF,\n    so it's likely there are some thing I'm missing there.\n    There are still some artifacts I haven't figured out.\n        * speckles in the plain featureless portions of surfaces\n        * something's weird with floor reflections plus transmission\n        * high attenuation coefficient yields weird results\n        * black edges on iOS.\n          - this makes me this something's uninitialized.\n    \n    I've heard that arrays and globals have poor performance in GLSL,\n    but it seems to do allright. The array size is being used is just 6 or so.\n               \n    There may be other approaches to this,\n    I haven't checked how folks like Dr2 and byt3_m3chanic are doing it.\n    .. Now I have. A lot of folks are using a stack,\n    but some of the best ones just treat each interface-crossing\n    as either entirely transmissive or entirely reflective, based on total internal reflection.\n\n\n    I've tried to add Shane-style comments, but it's still fairly messy.\n*/\n\n\n// Fork of \"elenzil marcher base\" by elenzil. https://shadertoy.com/view/fdffDn\n// 2022-02-12 15:40:33\n\n// todo\n// [x] optimize queue!\n// [x] actual attenuation while in material\n// [x] total internal reflection\n// [ ] fresnel ?\n// [ ] better environment\n// [ ] vignette\n// [ ] consider a conveyor-belt style presentation ?\n// [ ] AA\n// [ ] per-object materials\n// [ ] shadows that know about transparency\n// [ ] diffusion\n\n\n// the maximum number of simultaneous rays in the backlog.\n// the number of rays per pixel can be more than this.\nconst uint  gMaximumRaysInQueue = 10u;\n\n// a ray must have at least this much contribution left to be enqueued.\nconst float gMinimumRayContribution = 0.005f;\n\n// #define HEATMAP\n\n\nstruct ray_t {\n    // origin\n    vec3  ro;\n    \n    // direction\n    vec3  rd;\n    \n    // what amount of the pixel this ray is contributing. [0, 1]\n    float contribution;\n    \n    // whether this ray is on the inside of the SDF.\n    bool  internal;\n};\n\n\n////////////////////////////////////////////////////////////////////////////\n// This section of code implements a ring-buffer queue for holding rays.\n// Using a queue of rays instead of a stack\n// because earlier child-rays are more important than later.\n// ie, if we used a stack, the less-contributing rays would get processed\n// earlier than the more-contributing rays, eating up our budgets.\n// This is a pretty standard implementation of a ring-buffer, not special to GLSL.\n// The only difference from an implementation in say C++ is no error-checking!\n\n// my kingdom for templates in GLSL..\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u;\nQTYPE gQ[gQNumSlots];\nuint gQHead = 0u;\nuint gQTail = 0u;\n\n// the number of items in the queue\nuint QCount() {\n\tif (gQHead >= gQTail) {\n\t\treturn gQHead - gQTail;\n\t}\n\telse {\n\t\treturn gQNumSlots - (gQTail - gQHead);\n\t}\n}\n\n// the remaining capacity of the queue\nuint QSpaceLeft() {\n\treturn gQCapacity - QCount();\n}\n\nbool QIsFull() {\n\treturn QSpaceLeft() == 0u;\n}\n\nbool QIsEmpty() {\n\treturn QCount() == 0u;\n}\n\n// add an item to the head of the queue.\n// only call this if the queue is not empty !\nvoid QEnqueue(QTYPE item) {\n\tgQHead = (gQHead + 1u) % gQNumSlots;\n\tgQ[gQHead] = item;\n}\n\n// pull an item off the tail of the queue.\n// only call this if the queue is not empty !\nQTYPE QDequeue() {\n\tgQTail = (gQTail + 1u) % gQNumSlots;\n\treturn gQ[gQTail];\n}\n\n// conditionally add a ray to the queue\nbool addRay(in ray_t ray) {\n    if (QIsFull()) {\n        return false;\n    }\n    if (ray.contribution < gMinimumRayContribution) {\n        return false;\n    }\n    QEnqueue(ray);\n    return true;\n}\n\n// do not call this if the queue is empty !\nray_t popRay() {\n    return QDequeue();\n}\n\n// this section has a bunch of globals which are configured once per pixel per frame,\n// and then re-used multiple times.\n// for example, rotation matrices used in the core map() function.\n// I haven't noticed other people doing this, perhaps there's a reason..\nfloat gViewTheta = 0.0;\nvec3  gSceneCenter = gVy * 1.4;\nfloat gRounding = 0.075;\nvec3  gLightDirection = normalize(vec3(1.0, -2.0, 1.0));\nfloat gUnderStepFactor = 1.0;\nvec2  gRes;\nbool  gDoStereo = false;\n\nfloat gSSZoom;\nvec2  gM;\nmat2  gSceneRot1;\nmat2  gSceneRot2;\nmat2  gSceneRot3;\nmat2  gSceneRot4;\nfloat gBoxTwist = 0.0;\nvec3  gOuterBox;\nvec3  gInnerBox;\nvec3  gCornerBox;\nfloat gCornerBoxRounding;\nfloat gMouseTargetRad;\nvec3  gBallPos;\nfloat gBallRad;\nfloat gBallSep;\n\n// the maximum number of steps to raymarch.\nint   gMaxMarchStepsExternal = 250;\nint   gMaxMarchStepsInternal = 200;\n\n// pre-calculate values which are used in the core map() sdf function.\nvoid configMap() {\n    gSceneRot1 = rot2( -gViewTheta * 0.5);\n    gSceneRot2 = rot2(sin(gViewTheta * 4.0) * 0.1);\n    gSceneRot3 = rot2(cos(gViewTheta * 4.0) * 0.1);\n    gSceneRot4 = rot2(gT);\n    \n    gOuterBox = vec3(1.0);\n    gInnerBox = vec3(mix(0.0, 0.98, smoothstep(-0.9, 0.9, -cos(gT * 0.621))));\n    \n    float CBf = smoothstep(2.0, 3.0, gT);\n    gCornerBox         = CBf * vec3(0.6);\n    gCornerBoxRounding = CBf * gRounding;    \n    \n    gBallRad = 0.3;\n    gBallSep = 0.1;\n\n    // these odd numbers like 0.91, 0.31 all over the place\n    // are just to keep the various cyclic aspects from lining up\n    // so that the exact state of the scene keeps varying over time.\n    gBallPos = gSceneCenter;\n    gBallPos.x  += -cos(gT * 0.91 ) * 1.5;\n    gBallPos.z  +=  sin(gT * 0.91 ) * 1.5;\n    gBallPos.y  +=  sin(gT * 0.31) * (1.3 - gBallRad - gBallSep);\n    \n    // some twist for the box.\n    // twisting ruins the accuracy of the distance field,\n    // so while twisting we under-step during marching.\n    float twistT = gT / 4.123;\n    float btc = smoothstep(0.7, 1.0, -cos(twistT));\n    gBoxTwist = btc * 0.7 * sign(sin(twistT / 2.0));\n    gUnderStepFactor = mix(1.0, 0.82, btc);\n}\n\n// more configuration.\nvoid configGlobals0() {\n    gMouseTargetRad = 50.0;\n}\n\nvoid configGlobals1() {\n    gSSZoom = 0.8;\n\n    gT = iTime * PI / 10.0;\n    gSSEps  = 3.0/MINRES/gSSZoom;\n    gSSLw   = 2.0/MINRES/gSSZoom;\n\n    vec2 M = iMouse.xy;\n    if (gDoStereo || length(M) < gMouseTargetRad) {\n        M = (vec2(cos(gT * 0.751) * 0.8, cos(gT * 0.631)) * 0.4 + 0.4) * gRes.xy;\n    };\n    gM = M / gRes.xy;\n    gViewTheta = gM.x * PI * 2.0 + sin(gT * 0.71) * 0.1;\n}\n\n// a variable to track the number of calls to map().\n// this can be displayed as a 'heat map'.\nfloat gMapCalls = 0.0;\n\n// the core signed-distance-function routine.\nfloat map(vec3 p) {\n    float d = 1e9;\n    \n    gMapCalls += 1.0;\n    \n    // mod() the incoming point by a fairly large value,\n    // just to get some extra geometry in the background.\n    float repD = 50.0;\n    p.xz = mod(p.xz + repD/2.0, repD) - repD/2.0;\n    \n    // move to the center of our scene\n    vec3 pp = p - gSceneCenter;\n    \n    // apply some view-dependent wobble\n    pp.xz *= gSceneRot1;\n    pp.yz *= gSceneRot2;\n    pp.xy *= gSceneRot3;\n    \n    mat2 twist = rot2(pp.z * gBoxTwist);\n    pp.xy *= twist;\n    \n    // the main cube\n    d  = opU(d, sdBox   (pp, gOuterBox - gRounding) - gRounding);\n    \n    // minus a sube inside of it which grows and shrinks.\n    d  = opS(d, sdBox   (pp, gInnerBox - gRounding) - gRounding);\n   \n    // use abs() to now operate on each corner at once\n    vec3 ppp = abs(pp) - gV1 * 1.0;\n    // subtract a cube from each/the corner\n    d = opS(d, sdBox(ppp, gCornerBox) - gCornerBoxRounding);\n    \n    // move to the ball\n    ppp = p - gBallPos;\n    \n    // subtract a 'force field' from around where the ball will be\n    d = opS(d, sdSphere(ppp, gBallRad + gBallSep));\n    \n    // work in a sub-distance metric.\n    // this isn't really needed for what's here now,\n    // but it was useful for a more complex ball thing for a while.\n    float dd = 1e9;\n    // a regular sphere\n    dd = opU(dd, sdSphere(ppp, gBallRad));\n    // minus a growing/shrinking sphere inside of it.\n    dd = opS(dd, sdSphere(ppp, gBallRad * mix(0.0, 0.95, smoothstep(-0.4, 0.4, sin(gT * 2.31)))));\n    // union our sub-distance field with the main one.\n    d = opU(d, dd);\n    \n    // add a ground plane.\n    // I'm having some strange artifacts with the ground plane and reflectivity.\n    d = opU(d, sdPlnY(p));\n  \n    return d;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gWSEps);\n    }\n    return normalize(n);\n}\n\n// return a ray from the camera through our pixel and into the scene.\n// uv should be 0 in the center of the viewport, not 0.5.\nray_t getCamRay(vec2 uv, bool isLeftEye) {\n\n    ray_t ray;\n    \n    float stereoSep = -0.1 * (isLeftEye ? -1.0 : 1.0);\n    \n    // this seed ray is the whole contribution of the pixel!\n    // .. or at least it is until I add anti-aliasing.\n    ray.contribution = 1.0;\n\n    float zoomFac = 0.7;\n    \n    // where the whole camera is looking to.\n    // ping-pongs between the flying ball and the main cube.\n    float viewPingPong = smoothstep(0.8, 1.0, -cos(gT * 0.113));\n    vec3  lookDst = mix(gSceneCenter, gBallPos, viewPingPong);\n    \n    // where the camera is looking from.\n    // also ping-pongs.\n    vec3  lookSrc = vec3(cos(gViewTheta), (1.4 - gM.y * 1.3) * 4.0/3.0, sin(gViewTheta)) * 3.0;\n    lookSrc = mix(lookSrc, gBallPos * vec3(2.2, 1.3, 2.2), viewPingPong);\n    \n    // some rough logic to keep the camera a safe distance away from the ball and cube\n    float lsl  = length(lookSrc);\n    float lsl2 = max(lsl, 4.0);\n    lookSrc = lookSrc / lsl * lsl2;\n    \n    // construct an orthobasis for the camera. altho I don't turn it into an actual matrix.\n    vec3  camFw   = normalize(lookDst - lookSrc);\n    vec3  camRt   = normalize(cross(camFw, gVy));\n    vec3  camUp   = cross(camRt, camFw);\n    \n    lookSrc += camRt * stereoSep;\n    camFw   = normalize(lookDst - lookSrc);\n    camRt   = normalize(cross(camFw, gVy));\n    camUp   = cross(camRt, camFw);\n    \n\n    \n    // determine a 'look to' point for this specific pixel.\n    // gV0 is vec3(0).\n    vec3  p       = gV0;\n    p            += lookSrc;\n    p            += camFw;\n    p            += camRt * uv.x * zoomFac;\n    p            += camUp * uv.y * zoomFac;\n    \n    // copy it to the ray.\n    ray.ro        = lookSrc;\n    ray.rd        = normalize(p - ray.ro);\n    \n    // if the camera is initially inside an object, things are going to look weird,\n    // but at least this gives them a shot at correctness.\n    ray.internal  = map(p) < 0.0;\n    \n    return ray;\n}\n\n// ordinary raymarching.\n// return distance along ray to nearest intersection.\n// also returns the minimum distance from the ray to a surface. ie, often 0.\nfloat marchExternal(vec3 ro, vec3 rd, out float minD) {\n    float t = 0.0;\n    minD = 1e9;\n    \n    vec3 p;\n    for (int n = 0; n < gMaxMarchStepsExternal && (dot(p, p) < 1e4); ++n) {\n        p = ro + rd * t;\n        float d = map(p);\n        minD = min(minD, d);\n        if (d < gWSEps) {\n            minD = 0.0;\n            return t;\n        }\n        \n        t += d * gUnderStepFactor;\n    }\n    \n    return 1e9;\n}\n\n// raymarching in the negative side of the SDF.\nfloat marchInternal(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    \n    for (int n = 0; n < gMaxMarchStepsInternal && t < 1e2; ++n) {\n        vec3  p = ro + rd * t;\n        float d = map(p);\n        if (d > -gWSEps) {\n            return t;\n        }\n\n        t -= d * gUnderStepFactor;\n    }\n    \n    return 1e9;\n}\n\n// a function for some 'sky'. takes direction only, no positon.\n// could be replaced with a cubemap.\nvec3 sky(vec3 dir) {\n    float theta = atan(dir.z, dir.x);\n    vec3 rgb = abs(dir);\n    float absst = abs(sin(theta * 10.0 ));\n    rgb = mix(rgb, vec3(1.0), 0.2 * smoothstep(0.05, 0.0, absst - 0.2));\n    rgb *= mix(1.0, smoothstep(-0.1, 0.1, dir.y), 0.7);\n    rgb = mix(rgb, vec3(rgb.x + rgb.y + rgb.z) / 3.0, absst);\n    return rgb;\n}\n\n// takes a ray off the queue, marches it, potentially adds children to the queue.\n// repeats indefinitely until either the queue is empty or we pass a limit.\n// in a recursive implementation this would be \"processRay()\", and would call itself.\nvec3 processRays() {\n\n    // rgb is the output pixel color. start with black.\n    vec3 rgb = gV0;\n    \n    // track how many rays we've processed.\n    // stop when either that number is too large,\n    // or when the queue is empty.\n    uint processingIter;\n    for (processingIter = 0u;\n        processingIter < gQCapacity * 3u && !QIsEmpty();\n        ++processingIter) {\n        \n        // take the oldest ray out of the queue.\n        // on the first call to this method, there is only one ray in the queue,\n        // so the queue is empty after this call.\n        ray_t ray = popRay();\n        \n        // march either external or internal, depending on the ray.\n        float distanceAlongRayToSurface;\n        if (ray.internal) {\n            distanceAlongRayToSurface = marchInternal(ray.ro, ray.rd);\n        }\n        else {\n            float _unused;\n            distanceAlongRayToSurface = marchExternal(ray.ro, ray.rd, _unused);\n        }\n        \n        // if the returned distance is \"near\", call it a surface.\n        // if it's \"far\", call it the sky.\n        if (distanceAlongRayToSurface < 1e4) {\n        \n            // the position of the intersection\n            vec3  p    = ray.ro + distanceAlongRayToSurface * ray.rd;\n            vec3  grad = getNormal(p);\n            vec3  n    = grad;\n            \n            // If the ray is internal,\n            // we need to adjust the normal to point inwards.\n            // We also attenuate the ray's contribution according\n            // to how much material the ray passed through.\n            if (ray.internal) {\n                // surface normal is from the gradient, so flip it.\n                n = -n;\n                \n                // attenuation\n                ray.contribution *= exp(-1.0 * distanceAlongRayToSurface);\n            }\n            \n            // poor-man's materials: there's floor, sky, and everything else.\n            bool isFloor = p.y < 0.001;\n            \n            // diffuse component\n            float diffAmt = isFloor ? 0.9 : 0.05;\n            // dot the surface normal with our light direction\n            float diff = max(0.0, dot(n, -gLightDirection));\n            \n            // shadows\n            // only do these if there's a point.\n            if (diff * diffAmt * ray.contribution > 0.01) {\n                // for shadows we march towards the light\n                // and take advantage of the ease with which raymarching\n                // tells you approximately how close you came to any surface,\n                // and use that for a little soft shadowing.\n                // Soft shadowing tends to being out the artifacts in raymarching,\n                // so we understep significantly.\n                // Don't forget to offset the initial point from the surface by a bit,\n                // and not to use 'n' for that, because for internal rays it points inward.\n                float minD;\n                const float penumbra = 0.1;\n                float saveUnderStep = gUnderStepFactor;\n                int   saveMaxSteps  = gMaxMarchStepsExternal;\n                gMaxMarchStepsExternal = 200;\n                gUnderStepFactor *= 0.3;\n                marchExternal(p + grad * (penumbra + 0.01), -gLightDirection, minD);\n                diff *= smoothstep(0.0, penumbra, minD);\n                gUnderStepFactor = saveUnderStep;\n                gMaxMarchStepsExternal = saveMaxSteps;\n            }\n            \n            // almost done with diffuse shading.\n            // calculate albedo, the inherent color of the surface.\n            // it's white for glass, and patterned for the floor.\n            // note this is still modulated by the 'diffAmt' factor.\n            vec3 albedo = gV1 * 0.5;\n            if (isFloor) {\n                float x = abs(cos(p.z)) - 0.5 * -cos(p.x * 1.5);\n                x = sqrt(x);\n                albedo = gV1 * 0.4 * smoothstep(0.49, 0.51, x) + 0.05;\n                albedo = (albedo) / (1.0 + length(p) * 0.5);\n                albedo.r *= 0.5;\n            }\n            \n            // ambient light.\n            // it's good to add in some of this\n            // so that albedo texture that's in shadow isn't lost.\n            diff = max(0.04, diff);\n            \n            // add the diffuse lighting to the pixel.\n            rgb += diff * ray.contribution * diffAmt * albedo;\n            \n            // add rays for reflection and transmission\n\n            // \"eta\" is the greek letter η.\n            // it's the ratio of the two indices of refraction of the mediums.\n            // eg, air to glass.\n            // we animate the index of refraction a little,\n\n            const float ior_air     = 1.0003;\n            const float ior_water   = 1.333;\n            const float ior_quartz  = 1.46;\n            const float ior_diamond = 2.42;\n\n            float eta = ior_air / ior_diamond;\n\n            // if we're transitioning from inside to outside,\n            // eta should be inverted.\n            if (ray.internal) {\n                eta = 1.0 / eta;\n            }\n\n            // The next chunk of code determines the contributions\n            // of the reflected and refracted rays.\n\n            // this is the portion of the ray contribution left for\n            // reflection and refraction, after whatever diffuse used up.\n            float reflectAndRefractAmt = 1.0 - diffAmt;\n\n            // this is what portion of the reflect/refract portion is reflect vs. refract.\n            // 0 = all reflection, no transmission\n            // 1 = all transmission, no reflection\n            float reflectVsRefract = smoothstep(-1.0, -0.5, cos(gT * 0.221));\n\n            reflectVsRefract = min(0.95, reflectVsRefract);\n\n\n            // glsl conveniently provides these helpers:\n            vec3  reflectDir = reflect(ray.rd, n);\n            vec3  refractDir = refract(ray.rd, n, eta);\n\n            // refract() returns 0 if there's total internal reflection.\n            // it's critical to handle this case because it's common.\n            bool totalInternal = dot(refractDir, refractDir) == 0.0;\n\n            // no transmission if total internal reflection.\n            // no transmission for the floor\n            if (isFloor || totalInternal) {\n                reflectVsRefract = 0.0;\n            }\n\n            // The portion of the contribution for reflection and transmission\n            float reflectAmt = reflectAndRefractAmt * (1.0 - reflectVsRefract);\n            float refractAmt = reflectAndRefractAmt * reflectVsRefract;\n            float reflectContribution = ray.contribution * reflectAmt;\n            float refractContribution = ray.contribution * refractAmt;\n\n            // the origin of the ray for reflection should be offset from the surface a bit.\n            // the origin for transmission should be inset into the surface a bit.\n            vec3  reflectSrc = p + n * gWSEps * 2.0;\n            vec3  refractSrc = p - n * gWSEps * 2.0;\n\n\n            // enqueue the reflected ray. it copies the parent ray's internal-ness\n            if (!addRay(ray_t(reflectSrc, reflectDir, reflectContribution,  ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * reflectContribution;\n            }\n\n            // enqueue the transmitted ray. it inverts the parent ray's internal-ness\n            if (!addRay(ray_t(refractSrc, refractDir, refractContribution, !ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * refractContribution;\n            }\n            \n        }\n        else {\n            // this ray did not hit a surface. it's the sky!\n            // ray contribution is still super important here,\n            // as that's handling all the attenuation due to transmission, reflection.\n            rgb += sky(ray.rd) * ray.contribution;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid addCircle(inout vec3 rgb, in vec2 p, float rad) {\n    float lp = length(p);\n    rgb = mix(rgb, gV0, 0.1 * smoothstep(2.0, 0.0,     lp - rad));\n    rgb = mix(rgb, gV1, 0.2 * smoothstep(2.0, 0.0, abs(lp - rad)));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    configGlobals0();\n    \n    vec2 xy = XY;\n    \n    gDoStereo = length(vec2(iMouse.x, RES.y - iMouse.y)) < gMouseTargetRad;    \n    gRes = gDoStereo ? vec2(RES.x / 2.0, RES.y) : RES.xy;    \n    bool isLeftEye = XY.x < gRes.x;    \n    if (gDoStereo && !isLeftEye) {\n        xy.x -= gRes.x;        \n    }\n    \n    // set up some things we'll re-use\n    configGlobals1();\n    \n    // configure the geometry of the scene.\n    // this is called once per pixel here,\n    // but map() is called hundreds of times.\n    configMap();\n    \n    // screen-space coordinates with 0,0 at the center\n    vec2 uv = (xy - gRes.xy / 2.0) / MINRES * 2.0 / gSSZoom;\n    \n    // kick things off with a single ray for this pixel\n    addRay(getCamRay(uv, isLeftEye));\n\n    // march the ray and all its children\n    vec3 rgb = processRays();\n    \n    // gamma\n    rgb = pow(rgb, vec3(1./2.2));\n    \n    // \"UI\"\n    addCircle(rgb, XY, gMouseTargetRad);\n    addCircle(rgb, vec2(XY.x, iResolution.y - XY.y), gMouseTargetRad);\n\n    #ifdef HEATMAP\n    float pixelExpense = clamp(gMapCalls/1000.0, 0.0, 1.0);\n    rgb   *= 0.2;\n    rgb.r += pixelExpense;\n    #endif\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "#define RES    iResolution\n#define MINRES min(RES.x, RES.y)\n#define ZERO   (min(iFrame, 0))\n\nconst float PI = 3.14159265359;\n\n// WS = world space SS = screen space\nfloat gWSEps = 0.001;  // WS epsilon for surfaces\nfloat gSSEps;          // SS epsilon for smoothstep\nfloat gSSLw;           // SS line width\nfloat gT;\n\nconst vec3 gV0 = vec3(0.0);\nconst vec3 gV1 = vec3(1.0);\nconst vec3 gVx = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gMagenta = vec3(1.0, 0.0, 1.0);\nconst vec3 gGreen   = vec3(0.0, 1.0, 0.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat opU(float A, float B) {\n    return min(A, B);\n}\nfloat opS(float A, float B) {\n    return -min(-A, B);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCylX(vec3 p, float r) {\n    return length(p.yz) - r;\n}\n\nfloat sdCylY(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCylZ(vec3 p, float r) {\n    return length(p.xy) - r;\n}\nfloat sdPlnY(vec3 p) {\n    return p.y;\n}\nfloat sdSlabX(vec3 p, float r) {\n    return abs(p.x) - r;\n}\nfloat sdSlabY(vec3 p, float r) {\n    return abs(p.y) - r;\n}\nfloat sdSlabZ(vec3 p, float r) {\n    return abs(p.z) - r;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4648, 4684, 4699, 4699, 4807], [4809, 4848, 4867, 4867, 4900], [4902, 4902, 4918, 4918, 4948], [4950, 4950, 4967, 4967, 4993], [4995, 5082, 5109, 5109, 5169], [5171, 5260, 5278, 5278, 5338], [5340, 5380, 5407, 5407, 5576], [5578, 5622, 5638, 5638, 5663], [6520, 6591, 6609, 6609, 7783], [7785, 7808, 7831, 7831, 7861], [7863, 7863, 7886, 7886, 8249], [8370, 8416, 8435, 8435, 10172], [10175, 10333, 10356, 10356, 10553], [10555, 10683, 10725, 10725, 12621], [12623, 12779, 12834, 12834, 13197], [13199, 13247, 13286, 13286, 13558], [13560, 13661, 13681, 13681, 13996], [13998, 14242, 14262, 14319, 22232], [22234, 22234, 22288, 22288, 22451], [22453, 22453, 22496, 22496, 23666]]}
{"id": "7slfRX", "name": "Turbo and TurboPlus Colormaps", "author": "starea", "description": "Used in DepthLab: Real-Time 3D Interaction With Depth Maps for Mobile Augmented Reality https://augmentedperception.github.io/depthlab/", "tags": ["color"], "likes": 1, "viewed": 161, "published": 3, "date": "1645160781", "time_retrieved": "2024-07-30T17:03:02.881439", "image_code": "// Turbo and TuborPlus colormaps\n// Applied in DepthLab: Real-Time 3D Interaction With Depth Maps for Mobile Augmented Reality https://augmentedperception.github.io/depthlab/\n// Also explained in https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\n\n#define BLACK_BANDS\n\nfloat saturate(float x) {\n  return clamp( x, 0.0, 1.0 );\n}\n\n\nvec3 TurboPlus(in float x) {\n  const float d = 1. / 32.;\n  const vec3[] kColors = vec3[](\n    vec3(0.4796, 0.0158, 0.0106), vec3(0.6754, 0.0898, 0.0045), vec3(0.8240, 0.1918, 0.0197), vec3(0.9262, 0.3247, 0.0584), vec3(0.9859, 0.5048, 0.1337), vec3(0.9916, 0.6841, 0.2071), vec3(0.9267, 0.8203, 0.2257), vec3(0.7952, 0.9303, 0.2039), vec3(0.6332, 0.9919, 0.2394), vec3(0.4123, 0.9927, 0.3983), vec3(0.1849, 0.9448, 0.6071), vec3(0.0929, 0.8588, 0.7724), vec3(0.1653, 0.7262, 0.9316), vec3(0.2625, 0.5697, 0.9977), vec3(0.337, 0.443, 0.925), vec3(0.365, 0.306, 0.859),\n    vec3(0.4310, 0.1800, 0.827),  vec3(0.576, 0.118, 0.859), vec3(0.737, 0.200, 0.886), vec3(0.8947, 0.2510, 0.9137), vec3(1.0000, 0.3804, 0.8431), vec3(1.0000, 0.4902, 0.7451), vec3(1.0000, 0.5961, 0.6471), vec3(1.0000, 0.6902, 0.6039), vec3(1.0000, 0.7333, 0.6157), vec3(1.0000, 0.7804, 0.6431), vec3(1.0000, 0.8275, 0.6824), vec3(1.0000, 0.8706, 0.7255), vec3(1.0000, 0.9098, 0.7765), vec3(1.0000, 0.9451, 0.8235), vec3(1.0000, 0.9725, 0.8588), vec3(1.0000, 0.9922, 0.8863),\n    vec3(1., 1., 1.)\n  );\n  \n  vec3 col = vec3(0.0);\n  for (float i = 0.; i < 32.; i += 1.) {\n    col += (step(d*i, x) - step(d *(i+1.), x)) * mix(kColors[int(i)], kColors[int(i+1.)], saturate((x-d*i)/d));\n  }\n  \n  // Adds the last white colors after 99%.\n  col += step(.99, x) * mix(kColors[31], kColors[32], saturate((x-.99)/.01));\n  \n  return col;\n}\n\n\nvec3 GetPolynomialColor6(in float x, in vec4 kRedVec4, in vec4 kGreenVec4, in vec4 kBlueVec4,\n                       in vec2 kRedVec2, in vec2 kGreenVec2, in vec2 kBlueVec2) {\n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4) + dot(v2, kRedVec2),\n\tdot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n\tdot(v4, kBlueVec4) + dot(v2, kBlueVec2)\n  );\n}\n\n\nvec3 GetPolynomialColor8(in float x, in vec4 kRedVec4, in vec4 kGreenVec4, in vec4 kBlueVec4,\n                       in vec4 kRedVec2, in vec4 kGreenVec2, in vec4 kBlueVec2) {\n  x = saturate(x);\n  vec4 v = vec4( 1.0, x, x * x, x * x * x);\n  vec4 v2 = vec4( v.zw, v.zw * v.z) * v.z;\n  return vec3(\n    dot(v, kRedVec4) + dot(v2, kRedVec2),\n\tdot(v, kGreenVec4) + dot(v2, kGreenVec2),\n\tdot(v, kBlueVec4) + dot(v2, kBlueVec2)\n  );\n}\n\n\nvec3 GetPolynomialColor12(in float x, \n   in vec4 kRedVec, in vec4 kGreenVec, in vec4 kBlueVec,\n   in vec4 kRedVec2, in vec4 kGreenVec2, in vec4 kBlueVec2,\n   in vec4 kRedVec3, in vec4 kGreenVec3, in vec4 kBlueVec3) {\n    x = saturate(x);\n    vec4 v = vec4( 1.0, x, x * x, x * x * x);\n    vec4 v2 = vec4( v.zw, v.zw * v.z) * v.z; // 4, 5, 6, 7\n    vec4 v3 = vec4( v.zw, v2.zw) * v2.z; // 2+6, 3+6, \n    return vec3(\n    dot(v, kRedVec) + dot(v2, kRedVec2) + dot(v3, kRedVec3),\n\tdot(v, kGreenVec) + dot(v2, kGreenVec2) + dot(v3, kGreenVec3),\n\tdot(v, kBlueVec) + dot(v2, kBlueVec2) + dot(v3, kBlueVec3)\n  );\n}\n\nvec3 Turbo(in float x) {\n  x = 1.0 - x;\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n  return GetPolynomialColor6(x, kRedVec4, kGreenVec4, kBlueVec4, kRedVec2, kGreenVec2, kBlueVec2);\n}\n\nvec3 GetPolynomialColor(in float x, in vec4 kRedVec4, in vec4 kGreenVec4, in vec4 kBlueVec4,\n                       in vec2 kRedVec2, in vec2 kGreenVec2, in vec2 kBlueVec2) {\n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4) + dot(v2, kRedVec2),\n\tdot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n\tdot(v4, kBlueVec4) + dot(v2, kBlueVec2)\n  );\n}\n\nvec3 Inferno(in float x) {\n  const vec4 kRedVec4 = vec4(-0.027780558, 1.228188385, 0.278906882, 3.892783760);\n  const vec4 kGreenVec4 = vec4(0.014065206, 0.015360518, 1.605395918, -4.821108251);\n  const vec4 kBlueVec4 = vec4(-0.019628385, 3.122510347, -5.893222355, 2.798380308);\n  const vec2 kRedVec2 = vec2(-8.490712758, 4.069046086);\n  const vec2 kGreenVec2 = vec2(8.389314011, -4.193858954);\n  const vec2 kBlueVec2 = vec2(-3.608884658, 4.324996022);\n  return GetPolynomialColor(x, kRedVec4, kGreenVec4, kBlueVec4, kRedVec2, kGreenVec2, kBlueVec2);\n}\n\nvec3 Magma(in float x) {\n  const vec4 kRedVec4 = vec4(-0.023226960, +1.087154378, -0.109964741, +6.3336657630);\n  const vec4 kGreenVec4 = vec4(+0.010680993, +0.176613780, +1.638227448, -6.743522237);\n  const vec4 kBlueVec4 = vec4(-0.008260782, +2.244286052, +3.005587601, -24.279769818);\n  const vec2 kRedVec2 = vec2(-11.640596589, +5.337625354);\n  const vec2 kGreenVec2 = vec2(+11.426396979, -5.523236379);\n  const vec2 kBlueVec2 = vec2(+32.484310068, -12.6882);\n  return GetPolynomialColor(x, kRedVec4, kGreenVec4, kBlueVec4, kRedVec2, kGreenVec2, kBlueVec2);\n}\n\nvec3 Plasma(in float x) {\n  const vec4 kRedVec4 = vec4(+0.063861086, +1.992659096, -1.023901152, -0.490832805);\n  const vec4 kGreenVec4 = vec4(+0.049718590, -0.791144343, +2.892305078, +0.811726816);\n  const vec4 kBlueVec4 = vec4(+0.513275779, +1.580255060, -5.164414457, +4.559573646);\n  const vec2 kRedVec2 = vec2(+1.308442123, -0.914547012);\n  const vec2 kGreenVec2 = vec2(-4.686502417, +2.717794514);\n  const vec2 kBlueVec2 = vec2(-1.916810682, +0.570638854);\n  return GetPolynomialColor(x, kRedVec4, kGreenVec4, kBlueVec4, kRedVec2, kGreenVec2, kBlueVec2);\n}\n\nvec3 TurboPlus2(in float x) {\n  float d = 1. / 32.;\n  const vec3[] kColors = vec3[](\n    vec3(0.4796, 0.0158, 0.0106), vec3(0.6754, 0.0898, 0.0045), vec3(0.8240, 0.1918, 0.0197), vec3(0.9262, 0.3247, 0.0584), vec3(0.9859, 0.5048, 0.1337), vec3(0.9916, 0.6841, 0.2071), vec3(0.9267, 0.8203, 0.2257), vec3(0.7952, 0.9303, 0.2039), vec3(0.6332, 0.9919, 0.2394), vec3(0.4123, 0.9927, 0.3983), vec3(0.1849, 0.9448, 0.6071), vec3(0.0929, 0.8588, 0.7724), vec3(0.1653, 0.7262, 0.9316), vec3(0.2625, 0.5697, 0.9977), vec3(0.2758, 0.4110, 0.8794), vec3(0.2483, 0.2414, 0.6129),\n    vec3(0.3804, 0.0000, 0.4239), vec3(0.5500, 0.0000, 0.6876), vec3(0.8500, 0.1500, 0.8576), vec3(0.8947, 0.2510, 0.9137), vec3(1.0000, 0.3804, 0.8431), vec3(1.0000, 0.4902, 0.7451), vec3(1.0000, 0.5961, 0.6471), vec3(1.0000, 0.6902, 0.6039), vec3(1.0000, 0.7333, 0.6157), vec3(1.0000, 0.7804, 0.6431), vec3(1.0000, 0.8275, 0.6824), vec3(1.0000, 0.8706, 0.7255), vec3(1.0000, 0.9098, 0.7765), vec3(1.0000, 0.9451, 0.8235), vec3(1.0000, 0.9725, 0.8588), vec3(1.0000, 0.9922, 0.8863),\n    vec3(1., 1., 1.)\n  );\n  \n  vec3 col = vec3(0.0);\n  for (float i = 0.; i < 32.; i += 1.) {\n    col += (step(d*i, x) - step(d *(i+1.), x)) * mix(kColors[int(i)], kColors[int(i+1.)], saturate((x-d*i)/d));\n  }\n  \n  // Adds the last white colors behind.\n  col += step(.99, x) * mix(kColors[31], kColors[32], saturate((x-.99)/.01));\n  \n  //col += step(x, d) * mix(kColors[0], kColors[1], saturate(x/d));\n  //col += (step(d, x) - step(d*2., x)) * mix(vec3(0.9859, 0.50479, 0.13367), vec3(0.64920, 0.99416, 0.28237), saturate((x-d)/d));\n  //col += (step(d*2., x) - step(d *3., x)) * mix(vec3(0.64920, 0.99416, 0.28237), vec3(0.15844, 0.73551, 0.92305), saturate((x-d*2.)/d));\n  //col += (step(d*3., x) - step(d *4., x)) * mix(vec3(0.15844, 0.73551, 0.92305), vec3(0.525490196, 0.0, 0.874509804), saturate((x-d*3.)/d));\n  //col += (step(d*4., x) - step(d *5., x)) * mix(vec3(0.525490196, 0.0, 0.874509804), vec3(0.890196078, 0.337254902, 0.88627451), saturate((x-d*4.)/d));\n  \n  // vec3(0.9859, 0.50479, 0.13367);\n  //col += step(.5, x) * mix(vec3(0.18995, 0.07176, 0.23217), vec3(1.0, 0.9922, 0.8904),  saturate((x-0.5)/0.5));\n  //col = texture(iChannel0, vec2(x, 0.5)).rgb;\n  \n  return col;\n}\n\n\nvec3 TurboPlusLog(in highp float x) {\n  const vec4 kRedVec = vec4(0.59113794, 3.16900829, 52.89642789, -643.59893141);\n  const vec4 kGreenVec = vec4(0.11791950, -2.96354342, 90.53068222, -358.27990197);\n  const vec4 kBlueVec = vec4(-0.00310419, 1.30977871, -19.83579702, 191.92611722);\n  const vec4 kRedVec2 = vec4(2251.02981189, -3517.73633738, 2580.28822942, -725.69853887);\n  const vec4 kGreenVec2 = vec4(370.78250135, 281.25373429, -680.93444324, 300.67763485);\n  const vec4 kBlueVec2 = vec4(-622.24890432, 921.22427328, -649.78988729, 178.38954304);\n   \n  vec3 col = GetPolynomialColor8(x, kRedVec, kGreenVec, kBlueVec, kRedVec2, kGreenVec2, kBlueVec2);\n  return pow(col, vec3(1.2));\n}\n\n\nvec3 TurboPlusLinear(in highp float x) {\n  const vec4 kRedVec = vec4(0.46173515, 9.22083635, -34.26051625, -115.58080461);\n  const vec4 kGreenVec = vec4(0.08302509, -2.32628488, 85.82655757, -369.21926583);\n  const vec4 kBlueVec = vec4(-0.02271163, 3.26319467, -62.70877922, 527.02855858);\n  const vec4 kRedVec2 = vec4(703.89772879, -1212.74587245, 896.82155017, -246.83765279);\n  const vec4 kGreenVec2 = vec4(545.79945344, -215.64444787, -141.71031824, 98.22738339);\n  const vec4 kBlueVec2 = vec4(-1812.15734679, 3002.41093024, -2395.64049052, 739.06448700);\n  return GetPolynomialColor8(x, kRedVec, kGreenVec, kBlueVec, kRedVec2, kGreenVec2, kBlueVec2);\n}\n\nvec3 TurboPlusLog2(in highp float x) {\n  const vec4 kRedVec = vec4(0.55546817, 10.32569510, -228.41083958, 3784.80747541);\nconst vec4 kGreenVec = vec4(0.02637814, 5.75343742, -148.70319297, 2946.64996453);\nconst vec4 kBlueVec = vec4(0.15058610, -21.55034214, 665.88981142, -7957.16657920);\nconst vec4 kRedVec2 = vec4(-33792.67660851, 168174.89549296, -508003.01406935, 974982.11565746);\nconst vec4 kGreenVec2 = vec4(-26187.86131447, 131067.00088319, -407238.26557028, 809987.61796453);\nconst vec4 kBlueVec2 = vec4(48137.30586023, -162178.00445973, 313108.65007430, -325416.83050805);\nconst vec4 kRedVec3 = vec4(116917.59278686, 92868.25390777, -106396.74770902, 30273.58714786);\nconst vec4 kGreenVec3 = vec4(116917.59278686, 92868.25390777, -106396.74770902, 30273.58714786);\nconst vec4 kBlueVec3 = vec4(116917.59278686, 92868.25390777, -106396.74770902, 30273.58714786);\n  return GetPolynomialColor12(x, kRedVec, kGreenVec, kBlueVec, kRedVec2, kGreenVec2, kBlueVec2,\n  kRedVec3, kGreenVec3, kBlueVec3);\n}\n\n\n\n\nfloat tri( float x ) { return 1.0 - abs( fract( x * 0.5 ) - 0.5 ) * 2.0; }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothbump( vec3 a, vec3 r, vec3 x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nfloat greyScale(in vec3 col) \n{\n   // return dot(col, vec3(0.3, 0.59, 0.11));\n   return dot(col, vec3(0.2126, 0.7152, 0.0722)); //sRGB\n}\n#ifdef SHADERTOY_STANDALONE\nvoid main()\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n#endif\n{\n\tfragColor.a = 1.0;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float bandWidth = 1.0 / 8.0;\n\n\tif ( uv.y > 1.0 - bandWidth ) fragColor.xyz = Turbo( uv.x );\n\telse if ( uv.y > 1.0 - bandWidth * 2.0 ) fragColor.xyz = vec3(greyScale(Turbo( uv.x )));\n\telse if ( uv.y > 1.0 - bandWidth * 3.0 ) fragColor.xyz = TurboPlus( uv.x );\n\telse if ( uv.y > 1.0 - bandWidth * 4.0 ) fragColor.xyz = vec3(greyScale(TurboPlus( uv.x )));\n\telse if ( uv.y > 1.0 - bandWidth * 5.0 ) fragColor.xyz = Magma( uv.x );\n\telse if ( uv.y > 1.0 - bandWidth * 6.0 ) fragColor.xyz = vec3(greyScale(Magma( uv.x )));\n\telse if ( uv.y > 1.0 - bandWidth * 7.0 ) fragColor.xyz = Inferno( uv.x );\n\telse if ( uv.y > 1.0 - bandWidth * 8.0 ) fragColor.xyz = vec3(greyScale(Inferno( uv.x )));\n    \n\t#ifdef BLACK_BANDS\n\tfloat r = 32.0 / iResolution.y;\n\tfragColor.xyz *= step( r, tri( uv.y / 0.125 ) );\n\t#endif\n\n\t#ifdef PLOT_CURVES\n\tfloat y = fract( uv.y / 0.25 );\n\tfloat r = 6.0 / iResolution.y;\n\tfragColor.xyz += smoothbump( vec3( 0.0 ), vec3( r ), vec3( y ) - fragColor.xyz );\n\t#endif\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 318, 318, 351], [1755, 1755, 1930, 1930, 2170], [2173, 2173, 2348, 2348, 2601], [2604, 2604, 2821, 2821, 3211], [3213, 3213, 3237, 3237, 3773], [3775, 3775, 3949, 3949, 4189], [4191, 4191, 4217, 4217, 4744], [4746, 4746, 4770, 4770, 5309], [5311, 5311, 5336, 5336, 5874], [10483, 10483, 10505, 10505, 10557], [10558, 10558, 10595, 10595, 10635], [10636, 10636, 10679, 10679, 10746], [10747, 10747, 10778, 10824, 10883]]}
{"id": "NdsBRf", "name": "[4k] 2022 shiny glow v3", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 4, "viewed": 328, "published": 3, "date": "1645141224", "time_retrieved": "2024-07-30T17:03:04.026377", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.5;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(131.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/8.);\n\tfloat rest = mod(time,8.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+1.;\n\tfloat focusdist=camdist - 7. + mval.y;\n\tfloat dofamount=.15;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<4;\n\tbool lightsilver = section>2 && section<12;\n\tbool lightgreen = section>1;\n\tbool lightpink = section>7 && section<8;\n\tbool centerlight = section>11;\n\tbool strips = !(section>1);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.6 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.6)*17.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.2+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 4.-k*rrad;\n\t\t\t\trad2 = 4.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>10.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.001;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.005)?.008:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.005)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1402]]}
{"id": "NdsyDS", "name": "Kaleidoscope Truchet", "author": "Pelegefen", "description": "A Truchet kaleidoscope like effect done by sampling a video trough a Truchet shaped UV.", "tags": ["truchet"], "likes": 3, "viewed": 226, "published": 3, "date": "1645138668", "time_retrieved": "2024-07-30T17:03:04.893060", "image_code": "#define PI 3.1465\n#define TAU 6.283185307179586\n\n\nconst float _Scale = 5.;\nconst float _Smoothness = 0.21;\n\n\n\nfloat hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand01(vec2 p)\n{\n      return ceil(hash21(p) * 2. - 1.);\n}\n\nvec2 rot(vec2 p, float rad)\n{\n    float s = sin(rad);\n    float c = cos(rad);\n    return p*mat2(c,s,-s,c);\n\n}\n\n\n\nvec2 Tuv(vec2 uv)\n{\n\n\n\n        vec2 guv = fract(uv);\n                vec2 guv1 = fract(uv);\n\n        vec2 id = floor(uv);\n\n  \n   // if(mod(id.x  , 2.) == 0.)\n   // vec2 rguv =  rot(guv +vec2(1.0)  ,fract(iTime *.1)* TAU );\n    if(rand01(id) == 0.)\n        guv.x = 1. - guv.x;\n        \n        \n     float f = _Smoothness;\n    float line1 = smoothstep(0.711 - f,0.7111 + f,guv.x + guv.y);\n        \n    float line2 = smoothstep(1.31 + f,1.3 - f,guv.x + guv.y);\n    \n    float corner1 = smoothstep(0.31 + f,0.3 - f ,guv.x + guv.y);\n\n    float corner2 = smoothstep(1.711 - f ,1.7111 + f,guv.x + guv.y);\n\n    float tr = ((line1 * line2) + (corner1 + corner2));\n    \n    return vec2(tr, tr * length(guv -.5));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n     uv += iTime *.05;\n\n        uv *= vec2(_Scale);\n        \n        vec2 tuv = Tuv(uv);\n        \n        vec2 ttuv = Tuv(tuv * 5.3);\n        \n       \n       vec3 col =  vec3(tuv,0.);\n       col = texture(iChannel0,tuv).xyz;\n       // col =  vec3(abs(tr * (guv.x - guv.y)*.5) );\n\n      //  vec3 col2 =fract(abs(rot( ouv,iTime / TAU).xyy  ) )+.5;\n       // col = mix(col2.yxx,col2,tr);\n          //col = vec3(guv,0.);\n         // float g = smoothstep(.011,.01,guv1.x) + smoothstep(.011,.01,guv1.y);\n      // col = vec3( max( g,col.r ),col.g - g,col.b - g) ; \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 131, 131, 202], [204, 204, 226, 226, 268], [270, 270, 299, 299, 379], [383, 383, 402, 402, 1089], [1092, 1092, 1149, 1199, 1897]]}
{"id": "sdfyz4", "name": "Heaven & Hell", "author": "gurkanizmirligil", "description": "It turned out kind of artsy.", "tags": ["raymarching"], "likes": 12, "viewed": 405, "published": 3, "date": "1645138488", "time_retrieved": "2024-07-30T17:03:05.640063", "image_code": "#define SURFACE_DIST .01\n#define MAX_DIST 50.0\n#define MAX_STEPS 100\n\n//most of this shader is derived from Inigo Quilez's SDFs\n\nfloat displacement(vec3 p)\n{\n    float stAnim = step(.7, sin(iTime * .5));\n     return sin(1.*p.x)*sin(1.*p.y)*sin(.3*p.z + iTime * 2.0 - iTime * 1.5 * stAnim);\n}\n\nfloat sdPyramid( vec3 p, float s)\n{\n  float stAnim = step(.7, sin(iTime * .5));\n  float angle = (100. - 75. * stAnim)*(sin(iTime * .1 + 3.14) + iTime * .1) + 7.;\n  float xx = p.x * cos(angle) - p.z * sin(angle);\n  float zz = p.x*sin(angle) + p.z*cos(angle);\n  p.xz = vec2(xx, zz);\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h + displacement(p) * .2;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n      float stAnim = step(.7, sin(iTime * .5));\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  float bf =  min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.5 * stAnim))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.5))+min(max(q.x,max(q.y,p.z)),0.0));\n  return bf;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    float stAnim = step(.7, sin(iTime * .5));\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return min(sdBoxFrame(q, vec3(1.5), .2), sdPyramid(q + vec3(0,.3,0), .4));\n}\n\n\n\n\nfloat GetDist( vec3 p)\n{\n  float stAnim = step(.7, sin(iTime * .5));\n  float ground = sdPlane(p, vec3(0.0,1.0,0.0), -4.2+ stAnim * 4545.45);\n  float bf = opRep(p, vec3(4.75 + stAnim * 5.));\n  float gr = opSmoothUnion(bf, ground, .5 );\n  float d = gr;\n  return d;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float d0 = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro+d0*rd;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(dS < SURFACE_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 ld){\n   vec3 lightDir = ld;\n   vec3 l = normalize(lightDir);\n   vec3 n = GetNormal(p);\n   float dif = clamp(dot(n, l), 0., 1.0);\n   vec3 l2 = vec3(-l.x, l.yz);\n   float dif2 = clamp(dot(n, l2), 0., 1.0);\n   dif = mix(dif, dif2, .5);\n   float lightDistance = 5.0;\n   //shadow\n   //float d = raymarch(p+n*SURFACE_DIST*2.0, l);\n   //if(d<lightDistance) dif *= .5;\n   return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stAnim = step(.7, sin(iTime * .5));\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 bg = vec3(mix(.9, 0., uv.y), mix(0.2, 0.0, uv.y), 0.0);\n    if(stAnim > .5) bg = vec3(1.,.99,.95);\n    vec3 ro = vec3(0, 5., -5) - vec3(0, 0,iTime - iTime * .75 * stAnim) * ((-stAnim * 1.6) + 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = raymarch(ro, rd);    \n    vec3 p = ro + rd * d;\n    float anim = clamp(abs(sin(sin(iTime))) / (10. * sin(iTime * 3.) * sin(iTime* 3.)), .5, 4.);\n    float dif = GetLight(p, vec3(10. * sin(iTime * .1) - 5., 5., 5.));\n    float dif2 = GetLight(p, vec3(-15.,1. + stAnim * 10.,-5.));\n    dif = mix(dif * anim, dif2, stAnim);\n    float m = clamp(d / MAX_DIST ,0.,1.);\n    vec3 mat = vec3(100., 0, 0.) / 255.;\n    if(stAnim > .5) mat = vec3(1.5,1.5,1.5);\n    vec3 s = vec3(dif) * mat;\n    vec3 col = mix(s, bg,  m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 157, 157, 291], [293, 293, 328, 328, 852], [854, 854, 896, 922, 970], [971, 971, 1016, 1016, 1378], [1380, 1380, 1433, 1433, 1533], [1537, 1537, 1573, 1573, 1735], [1740, 1740, 1764, 1764, 2004], [2007, 2007, 2040, 2040, 2254], [2256, 2256, 2279, 2279, 2466], [2468, 2468, 2500, 2500, 2873], [2876, 2876, 2933, 2933, 3852]]}
{"id": "ssXBRX", "name": "snowflake sweep", "author": "peabrainiac", "description": "Animation of Mandelbrot's spacefilling \"snowflake sweep\" curve filling the koch snowflake. I used to draw this one for for hours on paper back in high school, now I got a shader doing it for me...", "tags": ["fractal", "animation", "spacefillingcurve", "kochsnowflake"], "likes": 13, "viewed": 353, "published": 3, "date": "1645134143", "time_retrieved": "2024-07-30T17:03:06.434938", "image_code": "const float PI = 2.0*acos(0.0);\nconst float SQRT3 = sqrt(3.0);\nconst mat2 ROT1 = mat2(cos(PI/1.5),sin(PI/1.5),-sin(PI/1.5),cos(PI/1.5));\nconst mat2 ROT2 = mat2(cos(PI/6.0),sin(PI/6.0),-sin(PI/6.0),cos(PI/6.0));\n\nfloat fractal(vec2 x, float param);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/length(iResolution);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float a = mod((iTime/3.0),1.0);\n    mat2 rot = pow(SQRT3,-a)*mat2(cos(a*PI/6.0),-sin(a*PI/6.0),sin(a*PI/6.0),cos(a*PI/6.0));\n    \n    float temp = fractal((0.7+0.2*sin(iTime/2.0))*rot*uv+vec2(0,0.5/SQRT3),(a-0.25*a*a)/0.75);\n    temp = mod((iTime/3.0),2.0)<1.0?temp:1.0-temp;\n\n    fragColor = vec4(temp<0.0?col:vec3(0.15+0.2*temp),1.0);\n}\n\nfloat fractal(vec2 x, float param){\n    if (x.y<-0.0||x.y/(0.25*SQRT3)+abs(x.x)*4.0/3.0>2.0){\n        return -1.0;\n    }\n    float t = 1.0;\n    for (int i=0;i<6;i++){\n        if (x.y/(0.25*SQRT3)+abs(x.x)*4.0<2.0){\n            if (x.y>1.0/SQRT3){\n                x = x*3.0-vec2(0.0,SQRT3);\n            }else if(x.x+x.y/SQRT3<-1.0/6.0){\n                x = x*3.0+vec2(1.0,0.0);\n            }else if(-x.x+x.y/SQRT3<-1.0/6.0){\n                x = ROT1*ROT1*(x*3.0-vec2(1.0,0.0))+vec2(-0.25,0.25*SQRT3);\n                t = 1.0-t;\n            }else if(x.x<1.0/6.0&&x.x+min(x.y,1.0/SQRT3-x.y)*SQRT3>1.0/6.0){\n                x = mat2(1.5,0.5*SQRT3,-0.5*SQRT3,1.5)*(x-vec2(0.0,0.5/SQRT3))+vec2(0.0,0.5/SQRT3);\n                t = 1.0-t;\n            }else{\n                if (x.x<1.0/6.0){\n                    if (x.y>0.5/SQRT3){\n                        x = ROT1*ROT1*(x-vec2(0.0,0.5/SQRT3))+vec2(0.0,0.5/SQRT3);\n                    }else{\n                        x = ROT1*(x-vec2(0.0,0.5/SQRT3))+vec2(0.0,0.5/SQRT3);\n                        t = 1.0-t;\n                    }\n                }\n                x = mat2(0.0,SQRT3,-SQRT3,0.0)*(x-vec2(0.0,0.5/SQRT3))+vec2(0.0,0.5/SQRT3);\n                t = 1.0-t;\n            }\n        }else{\n            if (x.x<0.0){\n                x = ROT1*ROT2*(x+vec2(0.5,0.0))*SQRT3+vec2(0.0,0.5*SQRT3);\n            }else{\n                x = ROT2*ROT2*ROT1*ROT2*(x-vec2(0.5,0.0))*SQRT3+vec2(0.0,0.5*SQRT3);\n            }\n            if (x.y/(0.25*SQRT3)+abs(x.x)*4.0>2.0){\n                if (x.x<0.0){\n                    x = ROT1*ROT2*(x+vec2(0.5,0.0))*SQRT3+vec2(0.0,0.5*SQRT3);\n                }else{\n                    x = ROT2*ROT2*ROT1*ROT2*(x-vec2(0.5,0.0))*SQRT3+vec2(0.0,0.5*SQRT3);\n                }\n            }\n        }\n    }\n    x = (param*mat2(1.0,0.0,0.0,1.0)+(1.0-param)*mat2(0.5,-0.5*SQRT3,0.5/SQRT3,1.5))*(x-vec2(0.5,0.0))+vec2(0.5,0.0);\n    return ((x.y>1.0/SQRT3||x.x+x.y*SQRT3<1.0/6.0||x.y/(0.25*SQRT3)+abs(x.x)*4.0>2.0)?t:1.0-t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 303, 303, 773], [775, 775, 810, 810, 2765]]}
{"id": "NssBRX", "name": "Dithering should happen in sRGB", "author": "iq", "description": "Dithering should happen in sRGB. Disable the #define in line 12 to see the effects of doing dithering _before_ the linear to sRGB conversion instead of after.", "tags": ["2d", "rgb", "dithering", "srgb"], "likes": 39, "viewed": 1850, "published": 3, "date": "1645134134", "time_retrieved": "2024-07-30T17:03:07.285663", "image_code": "// The displays expects colors in sRGB space, so we'll be converting colors\n// from linear space to sRGB. But also, the display has a limted number of\n// bits (usually 8, but we'll do 3 for today's test - change line 12 to emulate\n// other bit counts). So we'll want to dither the results to prevent banding\n// before sending the colors ot the display. So now the question arises - should\n// we convert to sRGB before or after dithering. The answer is _before_, since\n// dithering aids quantization, and that happens in sRGB, or in the display if\n// you want. Comment the #define in line 13 to see the consequences of doing the\n// sRGB conversion _after_ dithering - darkest colors are wrong, and the noise\n// no longer feels uniform.\n\n#define BITS 4\n#define SHOW_CORRECT\n//#define PERCEPTUAL_UNIFORM\n\n//------------------------------------------------------------------\n// rand()\n//------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // hash by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n//------------------------------------------------------------------\n// color display functions\n//------------------------------------------------------------------\n\nfloat lrgb2srgb( float color )\n{\n\treturn (color<0.0031308) ? color*12.92:1.055*pow(color,(1.0/2.4))-0.055;\n}\n\nfloat dither( float color )\n{\n    float n = frand()+frand()-1.0;  // triangular noise\n    return color + n*exp2(-float(BITS));\n}\n\nfloat quantize( float color )\n{\n    const float levels = exp2(float(BITS));\n    return floor(color*levels)/(levels-1.0);\n}        \n\n//------------------------------------------------------------------\n// main\n//------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Init randoms\n    srand( ivec2(fragCoord), iFrame );\n\n    // Coordinates\n    float x = 1.0*fragCoord.x/iResolution.x;\n    float y = 3.0*fragCoord.y/iResolution.y;\n\n    // Create an energy linear color ramp. Note that darks will feel\n    // compressed to your eye. Enable #define PERCEPTUAL_UNIFORM in \n    // line 14 to make it more perceptually uniform, if you want.\n    float col = x;\n    #ifdef PERCEPTUAL_UNIFORM\n    col = pow( col, 2.2 );\n    #endif\n\n\n    // CORRECT: convert to sRGB BEFORE dithering\n    #ifdef SHOW_CORRECT\n        col = lrgb2srgb( col ); \n\n        if( y>1.0 && y<2.0 )\n        col = dither( col );\n\n    // INCORRECT: converting to sRGB AFTER dithering\n    #else\n        if( y>1.0 && y<2.0 )\n        col = dither(col);\n        \n        col = lrgb2srgb( col ); \n    #endif\n\n    // simulate 2^BITS color level display screen\n    if( y>1.0 )\n    col = quantize(col); \n\n    // separation lines\n    //col *= smoothstep( 0.0, 0.01, 1.0-2.0*abs(fract(y)-0.5) );\n\n    fragColor = vec4( col, col, col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[966, 966, 984, 984, 1041], [1042, 1042, 1061, 1061, 1093], [1094, 1094, 1129, 1129, 1376], [1544, 1544, 1576, 1576, 1652], [1654, 1654, 1683, 1683, 1782], [1784, 1784, 1815, 1815, 1906], [2063, 2063, 2118, 2138, 3149]]}
{"id": "7sXBzX", "name": "Little Refracty Torus Thing", "author": "SnoopethDuckDuck", "description": "has a few grainy artifacts", "tags": ["e"], "likes": 6, "viewed": 259, "published": 3, "date": "1645133434", "time_retrieved": "2024-07-30T17:03:08.026682", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 1.3;\n    float r2 = 0.3;\n    float d1 = length(p.xz) - r1;\n    \n    float a = atan(p.x, p.z);\n    \n    vec2 u = vec2(d1, p.y);    \n    u.xy *= Rot(1.5 * a - 0.5 * atan(u.x, u.y) + iTime);\n    u.x = sabs(u.x) - 0.5;\n    u = sabs(u) - 0.2;\n\n    float d2 = length(u) - r2;\n    \n    return 0.5 * d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\t\n    float dO=0.; \n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, -5);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1. + exp(-0.6 * d); // very specific trick\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        vec3 pIn = p - 30. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.); //rdIn\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 2.);\n        col = vec3(fresnel);\n        fresnel = pow(1.+dot(rd, n), 5.);\n        col += vec3(fresnel);\n        \n        float dif = dot(p, normalize(vec3(1,2,3)))*.5+.5;\n        col *= mix(dif, 1., 0.8 + 0.22 * thc(40., d * 20.));\n        \n        float v = 1.-exp(-1. * pow(dIn, 4.));\n        //col = vec3(v);\n        col = smin(col, vec3(v));\n        vec3 e = vec3(dIn);\n        col *= pal(0.02 * dIn, e, e, e, vec3(0,1,2)/3.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n//crude\nvec3 smin(vec3 a, vec3 b) {\n    return vec3(smin(a.x,b.x), smin(a.y,b.y), smin(a.z,b.z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [151, 151, 174, 174, 487], [489, 489, 532, 532, 766], [768, 768, 792, 792, 982], [984, 984, 1034, 1034, 1225], [1227, 1227, 1284, 1284, 2569]]}
{"id": "7syGR1", "name": "Combat Banding with Dither", "author": "Xaymar", "description": "Simple example of the power of proper dithering techniques for removing banding.\n", "tags": ["color", "rgb", "linear", "dithering", "srgb", "bayer", "absolute", "lrgb"], "likes": 2, "viewed": 350, "published": 3, "date": "1645120647", "time_retrieved": "2024-07-30T17:03:08.910319", "image_code": "// ----------------------------------------\n// Options\n// ----------------------------------------\n\n// How many bits per channel (BpC) should be emulated?\n// Range: [1 .. Inf] Default: 4\n#define BITS_PER_CHANNEL 4\n\n// How much space should be reserved for fully dark and bright pixels?\n// Range: [0 .. .5] Default: (1. / (exp2(float(BITS_PER_CHANNEL)) + 2.)) // About 1 step on each side.\n#define RESERVED_AREA (1. / (exp2(float(BITS_PER_CHANNEL)) + 2.))\n\n// ----------------------------------------\n// References\n// ----------------------------------------\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\n// https://loopit.dk/banding_in_games.pdf\n// https://cdn.cloudflare.steamstatic.com/apps/valve/2008/GDC2008_PostProcessingInTheOrangeBox.pdf\n\n// ----------------------------------------\n// Code\n// ----------------------------------------\n\nfloat range = (exp2(float(BITS_PER_CHANNEL)) - 1.);\nfloat4 generateBars(float2 uv) {\n    float4 result;\n    float gradient = lerp(0., 1., (uv.x - RESERVED_AREA) / (1. - (RESERVED_AREA * 2.)));\n    // Incorrect: smoothstep(RESERVED_AREA, 1. - RESERVED_AREA, uv.x);\n\n    float gy2 = uv.y * 1.;\n    float gy = fract(gy2);\n\n    result = float4(gradient, gradient, gradient, 1.);\n    if (gy >= .75) {\n        result.rg = float2(0., 0.);\n    } else if (gy >= .50) {\n        result.rb = float2(0., 0.);\n    } else if (gy >= .25) {\n        result.gb = float2(0., 0.);\n    }\n    \n    return result;\n}\n\n#define DITHER_BANDS 7\n\nfloat band0(uint2 fragCoord) {\n    // No dithering.\n    return 0.5;\n}\n\nfloat band1(uint2 fragCoord) {\n    // No dithering, bias to zero.\n    return 1.;\n}\n\nfloat band2(uint2 fragCoord) {\n    // Bayer\n    // Levels should be above 3u for ideal quality. 5u seems to be a good spot.\n    return Bayer(fragCoord, 5u, true, uint(iFrame));\n}\n\nfloat band3(uint2 fragCoord) {\n    // Interleaved Gradient Noise\n    return InterleavedGradientNoise(fragCoord, true, uint(iFrame));\n}\n\nfloat band4(uint2 fragCoord) {\n    // Shaped Thresholding (iChannel2)\n    return textureLod(iChannel2, float2(fragCoord * 1u) / iChannelResolution[2].xy, 0.).r;\n}\n\nfloat band5(uint2 fragCoord) {\n    // Shaped Thresholding (iChannel2)\n    return textureLod(iChannel2, float2(fragCoord * 3u) / iChannelResolution[2].xy, 0.).r;\n}\n\nfloat band6(uint2 fragCoord) {\n    // Shaped Thresholding (iChannel3)\n    return textureLod(iChannel3, float2(fragCoord * 1u) / iChannelResolution[3].xy, 0.).r;\n}\n\nfloat band7(uint2 fragCoord) {\n    // Shaped Thresholding (iChannel3)\n    return textureLod(iChannel3, float2(fragCoord * 3u) / iChannelResolution[3].xy, 0.).r;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // As far as I can tell, ShaderToy writes directly to the canvas, which is sRGB.\n    // Correct me if I'm wrong, but please provide sources/references.\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = 1. - uv.y; // Flip V.\n    \n    // Generate a gradient from left to right.\n    float2 guv = float2(uv.x, uv.y * (float(DITHER_BANDS) + 1.));\n    fragColor = generateBars(float2(guv.x, fract(guv.y)));\n    \n    // Call the threshold function.\n    float threshold = 0.;\n    #if DITHER_BANDS >= 7\n    if (guv.y >= 7.) {\n        threshold = band7(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 6\n    if (guv.y >= 6.) {\n        threshold = band6(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 5\n    if (guv.y >= 5.) {\n        threshold = band5(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 4\n    if (guv.y >= 4.) {\n        threshold = band4(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 3\n    if (guv.y >= 3.) {\n        threshold = band3(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 2\n    if (guv.y >= 2.) {\n        threshold = band2(uint2(fragCoord));\n    } else\n    #endif\n    #if DITHER_BANDS >= 1\n    if (guv.y >= 1.) {\n        threshold = band1(uint2(fragCoord));\n    } else\n    #endif\n    if (guv.y >= 0.) {\n        threshold = band0(uint2(fragCoord));\n    }\n    \n    // Perform Dithering (should happen in sRGB space).\n    fragColor = DitherQuantize(fragColor, range, threshold);\n    \n    // Image writes to an lRGB buffer, which is presented as sRGB. Must fix this by inverting the generated color.\n    fragColor = sRGBA_to_lRGBA(fragColor);\n    \n    // Debug threshold\n    //if (fragCoord.y <= iMouse.y) {\n    //    fragColor.rgb = float3(threshold, threshold, threshold);\n    //}\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ----------------------------------------\n// HLSL to GLSL translations\n// ----------------------------------------\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n#define uint2 uvec2\n#define uint3 uvec3\n#define uint4 uvec4\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n#define fmod mod\n#define imod(a, b) (a % b)\n#define lerp mix\n#define frac fract\n\n// ----------------------------------------\n// Threshold Functions\n// ----------------------------------------\nfloat Bayer(uint2 xy, uint levels, bool temporal, uint iFrame) {\n    if (temporal) {\n        xy.x += iFrame % levels;\n        xy.y += (iFrame / levels) % levels;\n    }\n    \n    float val = 0.;\n    float div = 0.;\n    float mul = 1.;\n\n    //[loop]\n    for(uint level = levels; level >= 1u; level--)\n    {\n        mul *= 4.;\n\n        float2 bayer = fmod(floor(float2(xy.xy) * exp2(1. - float(level))), 2.);\n        float x2 = bayer.x * 2.;\n\n        val += lerp(x2, 3. - x2, bayer.y) / 3. * mul;\n        div += mul;\n    }\n\n    return val / div;\n}\n\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat InterleavedGradientNoise(uint2 xy, bool temporal, uint iFrame) {\n    if (temporal) {\n        xy.x += uint(float(imod(iFrame, 64u)) * 5.588238f);\n        xy.y += uint(float(imod(iFrame, 64u)) * 5.588238f);\n    }\n\n    return fmod(52.9829189f * fmod(0.06711056f * float(xy.x) + 0.00583715f * float(xy.y), 1.f), 1.f);\n}\n\n// ----------------------------------------\n// Dither Functions\n// ----------------------------------------\nfloat4 Dither(float4 color, float threshold) {\n    // color: [0..Infinity) Decimal value in the expected output range.\n    // threshold: The output of a thresholding function, like Bayer or IGN.\n\n    /* Naive variant.\n    float4 fcolor = frac(color);\n    color = floor(color);\n    color.r += fcolor.r > threshold ? 1. : 0.;\n    color.g += fcolor.g > threshold ? 1. : 0.;\n    color.b += fcolor.b > threshold ? 1. : 0.;\n    color.a += fcolor.a > threshold ? 1. : 0.;\n    return color; //*/\n    \n    /* Incorrect Variant (>= instead of >)\n    return floor(color) + step(threshold, frac(color)); //*/\n    \n    //* Faked Variant (> emulated with a tiny offset)\n    return floor(color) + step(threshold + 0.0001, frac(color)); //*/\n}\nfloat3 Dither(float3 color, float threshold) {\n    // color: [0..Infinity) Decimal value in the expected output range.\n    // threshold: The output of a thresholding function, like Bayer or IGN.\n\n    /* Naive variant.\n    float3 fcolor = frac(color);\n    color = floor(color);\n    color.r += fcolor.r > threshold ? 1. : 0.;\n    color.g += fcolor.g > threshold ? 1. : 0.;\n    color.b += fcolor.b > threshold ? 1. : 0.;\n    return color; //*/\n    \n    /* Incorrect Variant (>= instead of >)\n    return floor(color) + step(threshold, frac(color)); //*/\n    \n    //* Faked Variant (> emulated with a tiny offset)\n    return floor(color) + step(threshold + 0.0001, frac(color)); //*/\n}\nfloat2 Dither(float2 color, float threshold) {\n    // color: [0..Infinity) Decimal value in the expected output range.\n    // threshold: The output of a thresholding function, like Bayer or IGN.\n\n    /* Naive variant.\n    float2 fcolor = frac(color);\n    color = floor(color);\n    color.r += fcolor.r > threshold ? 1. : 0.;\n    color.g += fcolor.g > threshold ? 1. : 0.;\n    return color; //*/\n    \n    /* Incorrect Variant (>= instead of >)\n    return floor(color) + step(threshold, frac(color)); //*/\n    \n    //* Faked Variant (> emulated with a tiny offset)\n    return floor(color) + step(threshold + 0.0001, frac(color)); //*/\n}\nfloat Dither(float color, float threshold) {\n    // color: [0..Infinity) Decimal value in the expected output range.\n    // threshold: The output of a thresholding function, like Bayer or IGN.\n\n    /* Naive variant.\n    float4 fcolor = frac(color);\n    color = floor(color);\n    color += fcolor > threshold ? 1. : 0.;\n    return color; //*/\n    \n    /* Incorrect Variant (>= instead of >)\n    return floor(color) + step(threshold, frac(color)); //*/\n    \n    //* Faked Variant (> emulated with a tiny offset)\n    return floor(color) + step(threshold + 0.0001, frac(color)); //*/\n}\nfloat4 DitherQuantize(float4 color, float range, float threshold) {\n    return Dither(color * range, threshold) / range;\n}\nfloat3 DitherQuantize(float3 color, float range, float threshold) {\n    return Dither(color * range, threshold) / range;\n}\nfloat2 DitherQuantize(float2 color, float range, float threshold) {\n    return Dither(color * range, threshold) / range;\n}\nfloat DitherQuantize(float color, float range, float threshold) {\n    return Dither(color * range, threshold) / range;\n}\n\n// ----------------------------------------\n// Quantize Functions\n// ----------------------------------------\nfloat Quantize(float v, float range) {\n    return round(v * range) / range;\n}\nvec2 Quantize(vec2 v, float range) {\n    return round(v * range) / range;\n}\nvec3 Quantize(vec3 v, float range) {\n    return round(v * range) / range;\n}\nvec4 Quantize(vec4 v, float range) {\n    return round(v * range) / range;\n}\n\n// ----------------------------------------\n// Unaccelerated lRGB<->sRGB conversion\n// ----------------------------------------\n// May be potentially wrong as I relied on the StackOverflow source for this:\n// - https://stackoverflow.com/questions/61430174/sRGB-linear-rgb-conversion-precision\n\nfloat _sRGB_to_lRGB(float ch) {\n\tif (ch <= 0.04045) {\n\t\treturn (ch / 12.92);\n\t}\n\treturn pow((ch + 0.055) / 1.055, 2.4);\n\t//return (ch <= 0.04045) ? (ch / 12.92) : pow((ch + 0.055) / 1.055, 2.4);\n}\n\nfloat _lRGB_to_sRGB(float ch) {\n\t// Inverse of above.\n    if (ch <= 0.0031308) {\n        return ch * 12.92;\n    }\n    return (1.055 * pow(ch, (1.0 / 2.4)) - 0.055);\n\t//return (ch >= 0.0031308) ? (ch * 12.92) : (1.055 * pow(ch, 1.0 / 2.4) - 0.055);\n}\n\nfloat3 sRGB_to_lRGB(float3 sRGB) {\n\treturn float3(\n\t\t_sRGB_to_lRGB(sRGB.r),\n\t\t_sRGB_to_lRGB(sRGB.g),\n\t\t_sRGB_to_lRGB(sRGB.b)\n\t);\n}\n\nfloat4 sRGBA_to_lRGBA(float4 sRGB) {\n\treturn float4(\n\t\t_sRGB_to_lRGB(sRGB.r),\n\t\t_sRGB_to_lRGB(sRGB.g),\n\t\t_sRGB_to_lRGB(sRGB.b),\n\t\t_sRGB_to_lRGB(sRGB.a)\n\t);\n}\n\nfloat3 lRGB_to_sRGB(float3 lRGB) {\n\treturn float3(\n\t\t_lRGB_to_sRGB(lRGB.r),\n\t\t_lRGB_to_sRGB(lRGB.g),\n\t\t_lRGB_to_sRGB(lRGB.b)\n\t);\n}\n\nfloat4 lRGBA_to_sRGBA(float4 lRGB) {\n\treturn float4(\n\t\t_lRGB_to_sRGB(lRGB.r),\n\t\t_lRGB_to_sRGB(lRGB.g),\n\t\t_lRGB_to_sRGB(lRGB.b),\n\t\t_lRGB_to_sRGB(lRGB.a)\n\t);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[961, 961, 993, 993, 1500], [1526, 1526, 1556, 1577, 1595], [1597, 1597, 1627, 1662, 1679], [1681, 1681, 1711, 1804, 1859], [1861, 1861, 1891, 1925, 1995], [1997, 1997, 2027, 2066, 2159], [2161, 2161, 2191, 2230, 2323], [2325, 2325, 2355, 2394, 2487], [2489, 2489, 2519, 2558, 2651]]}
{"id": "7ssfz2", "name": "heart by dot2shader", "author": "IWBTShyGuy", "description": "This shader is generated by my new app: dot2shader [url]https://iwbtshyguy.gitlab.io/dot2shader/[/url]", "tags": ["bitmap"], "likes": 2, "viewed": 202, "published": 3, "date": "1645102904", "time_retrieved": "2024-07-30T17:03:09.726138", "image_code": "// \n// This shader is generated by my new web app: dot2shader\n//\n// https://iwbtshyguy.gitlab.io/dot2shader/\n//\n// This web app generates a shader for Shadertoy from a pixel art by only uploading an image file.\n//\n\nconst vec3 PALETTE[] = vec3[](\n    vec3(0, 0, 0) / 255.0,\n    vec3(252, 0, 0) / 255.0,\n    vec3(252, 127, 127) / 255.0\n);\n\nconst int WIDTH = 13, HEIGHT = 11, CHUNKS_IN_U32 = 16;\nconst int BUFFER[] = int[](\n    4096, 1342177616, 1431306261, 357912577, 1364546896, 1498764629, 1437160789, 1427476821,\n    22025473\n);\n\nvec3 getColor(in ivec2 u) {\n    int idx = u.y * WIDTH + u.x;\n    u = ivec2(idx % CHUNKS_IN_U32, idx / CHUNKS_IN_U32);\n    int bitShift = 32 / CHUNKS_IN_U32;\n    return PALETTE[BUFFER[u.y] >> u.x * 32 / CHUNKS_IN_U32 & (1 << bitShift) - 1];\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy;\n    ivec2 u = ivec2(floor((U - 0.5 * r) / r.y * float(HEIGHT) + vec2(WIDTH, HEIGHT) / 2.0));\n    O.xyz = u == abs(u) && u.x < WIDTH && u.y < HEIGHT ? getColor(u) : vec3(0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 531, 558, 558, 772], [774, 774, 813, 813, 1019]]}
{"id": "sdlfRj", "name": "Zebra Valley", "author": "FabriceNeyret2", "description": "ref: https://twitter.com/JuhaniHalkomaki/status/1493836353410371586", "tags": ["2tweets", "short", "reproduction"], "likes": 58, "viewed": 805, "published": 3, "date": "1645092601", "time_retrieved": "2024-07-30T17:03:10.468154", "image_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= 7./R;\n    O-=O;\n    for(float i=0.,v; i++ < 70.; )\n        v = 9.-i/6.+2.*cos(U.x + sin(i/6. + iTime ) ) - U.y,\n        O = mix(O, vec4(int(i)%2), smoothstep(0.,15./R.y, v) );\n}\n\n\n\n\n\n\n/** // --- optimized version  ( 203 chars = +16 )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U *= 7./R;\n    O-=O;\n    for(float i=-18.,v; i++ < 11.; ) \n        v = 2.*cos(U.x + sin(i/6.-ceil(U.y) + iTime ) ) -i/6. - fract(U.y),\n        O = mix(O, vec4(int(i)%2), smoothstep(0.,15./R.y, v) );\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 255]]}
{"id": "7dXBRB", "name": "The nether", "author": "El_Sargo", "description": "An attempt to model the warrped fungus from minecraft", "tags": ["3d", "raymarching"], "likes": 9, "viewed": 330, "published": 3, "date": "1645089334", "time_retrieved": "2024-07-30T17:03:11.214159", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdTorus( vec3 p, float t, float r)\n{\n  vec2 q = vec2(length(p.xz)- t,p.y);\n  return length(q)- r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nvec3 bendPoint(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat displacement(vec3 p){\n    return \n    texture(iChannel1,p*0.2).x*0.1+\n    texture(iChannel1,p*0.4).x*0.05+\n    texture(iChannel1,p*0.8).x*0.025+\n    texture(iChannel1,p*1.6).x*0.0125;\n}\n\nfloat sdLand(vec3 p){\n    p-=vec3(3,-0.1,1.5);\n    return smin(\n                smin(\n                    sdBox((p-vec3(2,-1.8,7))*roty(-1.), vec3(2,1,2)),\n                    sdBox((p-vec3(2.5,-3.8,4)), vec3(3,1.9,3)),\n                    2.\n                    ),\n                smin(\n                    sdBox((p-vec3(-2,-1.8,1))*roty(-1.), vec3(2,1,2)),\n                    sdBox((p-vec3(4,-1.50,4)), vec3(1)),\n                    2.\n                    ),\n                    2.\n                )\n            + displacement(p*vec3(.2, .1, .2))*6.;\n}\n\nfloat sdShroomLights(vec3 q){\n   return min(\n              min(\n                  sdSphere(q-vec3(1.,1.5,5.4), 0.35), \n                  sdSphere(q-vec3(2.,1.5,5.6), 0.4)\n                  ),\n              min(\n                  sdSphere(q-vec3(1.2,1.6,6.5), 0.45), \n                   sdSphere(q-vec3(2.7,1.4,6.6), 0.34)\n                  )\n              );\n}\n\n\n#define SHROOMBEND bendPoint(p, sin(iTime*0.6)*0.05+0.1)\n\nfloat sdShroomHead(vec3 q){\n    return sdCutHollowSphere((q-vec3(1.5,0.95,6.5))*rotz(3.3)*rotx(.25), 1.8, -0.24*smoothstep(-1.,01.,sin(10.*q.x-q.z))-0.1, 0.12 )+displacement(q);\n}\n\nfloat sdShroomStem(vec3 q){\n    return sdVerticalCapsule(q-vec3(2.,-2.,6.5), 4., .32);\n}\n\nfloat sdShroom(vec3 p){\n    vec3 q = SHROOMBEND;\n        return smin(\n                       min(\n                            sdShroomHead(q),\n                            sdShroomStem(q)\n                           ),\n                       sdShroomLights(q),\n                       0.06\n                   );\n}\n\nfloat sdScene(vec3 p){\n    return smin(\n                sdShroom(p),\n                sdLand(p),\n                .2\n                );\n}\n\n\nvec3 calcShroomLightDir( in vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    vec3 q = SHROOMBEND;\n    return normalize( k.xyy*sdShroomLights(q + k.xyy*h) + \n                      k.yyx*sdShroomLights(q + k.yyx*h) + \n                      k.yxy*sdShroomLights(q + k.yxy*h) + \n                      k.xxx*sdShroomLights(q + k.xxx*h) );\n}\n\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene(p + k.xyy*h) + \n                      k.yyx*sdScene(p + k.yyx*h) + \n                      k.yxy*sdScene(p + k.yxy*h) + \n                      k.xxx*sdScene(p + k.xxx*h) );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdScene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera setup...\n    //https://www.shadertoy.com/view/4tGfz3\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, .4));\n    //rd *= rotx(0.0);\n    vec3 rp = vec3(0.0, 0, 0);\n\n\n    \n    //---------------------------------------\n    //\n    //March!\n    //\n    //\n    for(int i = 0; i < 60; i++) {\n        rp += rd*sdScene(rp)*0.9;\n    }\n    //if (sdScene(rp) < .1)\n    vec3 p = rp;\n    vec3 q = SHROOMBEND;\n    float SLDist = sdShroomLights(q);\n    vec3 normal = calcNormal(rp);\n    vec3 lightDir;\n    if (SLDist <= 0.1)\n        lightDir = -normal;\n    else\n        lightDir = calcShroomLightDir(rp);\n    vec3 ShroomLightCol = vec3(2.99,0.99,0.42);\n    vec3 AmbientLightCol = vec3(0.9);\n    vec3 col = vec3(1.,0.4,0.);\n    float reflecive = 1.;\n    if (SLDist <= 0.1) {\n        col = ShroomLightCol*(texture(iChannel2, q.xy*4.).xxx-vec3(0, 5.5, 0));\n        reflecive = -2.2;\n    } else if(sdShroomHead(q) <= 0.2) {\n        col = vec3(0.2, 0.8, 1.2)+texture(iChannel0, q.xy).yxx*0.75;\n        reflecive = 0.8;\n    } else if(sdShroomStem(q) <= 0.4){\n        col = vec3(7.7)*texture(iChannel2, q.xy).xxx;\n        reflecive = 1.;\n    } else if(sdLand(p) < 0.5){\n        col = vec3(1.8, 0.3, 0.1)*texture(iChannel2, 2.2*p.xz + p.y*p.y).xyz;\n        reflecive = 0.4;\n    } else {\n        col = texture(iChannel3, rd).xyz+vec3(0.9,0.4,0.9);\n        reflecive = 1.;\n        normal = vec3(0);\n    }\n    vec3 DirlightDir = normalize(vec3(1.2, -1, 1));\n    float DirLightStrength = shadow(rp, -DirlightDir, 2.1, 2.);\n    fragColor = vec4(clamp(vec3(0),vec3(1),ShroomLightCol*smoothstep(-0.,1.,dot(lightDir,-normal)*0.5/SLDist)+\n                     col*AmbientLightCol*0.4*reflecive*smoothstep(-1.,1.,dot(normal,-DirlightDir))*(DirLightStrength*0.5+0.5)), 1);\n}\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [446, 446, 487, 487, 548], [550, 550, 582, 582, 610], [613, 613, 675, 737, 943], [945, 945, 987, 987, 1050], [1052, 1052, 1105, 1105, 1164], [1167, 1167, 1200, 1200, 1330], [1332, 1332, 1363, 1363, 1450], [1452, 1452, 1479, 1479, 1643], [1645, 1645, 1666, 1666, 2200], [2202, 2202, 2231, 2231, 2562], [2623, 2623, 2650, 2650, 2802], [2804, 2804, 2831, 2831, 2892], [2894, 2894, 2917, 2917, 3204], [3206, 3206, 3228, 3228, 3341], [3344, 3344, 3402, 3402, 3759], [3761, 3761, 3811, 3811, 4113], [4115, 4115, 4179, 4179, 4342], [4344, 4344, 4401, 4467, 6244]]}
{"id": "fsfBz2", "name": "mandelbrot zoom in", "author": "loryruta", "description": "z = z^2 + c", "tags": ["mandelbrotsetfractal"], "likes": 0, "viewed": 185, "published": 3, "date": "1645088707", "time_retrieved": "2024-07-30T17:03:11.958170", "image_code": "#define MAX_ITER 255\n\n\n#define MAX_OUTWARD_ZOOM 0.7\n#define MAX_INWARD_ZOOM 10000.0\n#define THRESHOLD 1.0\n\nvec3 map_color(float it)\n{\n    return vec3(1.0 - sin(it * 3.14));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 trasl = vec2(-0.7449, 0.1);\n\n    // point on screen between [-1, 1]\n    vec2 frag_p = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\n    vec2 mb_c = vec2(0) + trasl; // mandelbrot center point\n    vec2 mb_p = frag_p + trasl; // mandelbrot point under analysis \n    \n    float s = (abs(mod(iTime * 0.01, 1.0)) * (MAX_INWARD_ZOOM - MAX_OUTWARD_ZOOM)) + MAX_OUTWARD_ZOOM; // scaling factor\n    vec2 zoomed_p = (mb_p - mb_c) * (1.0 / s) + mb_c; // the zoomed point\n\n    vec2 p0 = zoomed_p;\n    vec2 p = vec2(0);\n    \n    float it = 0.0;\n    while ((p.x * p.x + p.y * p.y) <= 2.0 * 2.0 && it < float(MAX_ITER))\n    {\n        float tmp = p.x * p.x - p.y * p.y + p0.x;\n        p.y = 2.0 * p.x * p.y + p0.y;\n        p.x = tmp;\n        it += 1.0;\n    }\n    \n    \n    fragColor = vec4(map_color(it / float(MAX_ITER)), 1.0);\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 133, 133, 174], [176, 176, 233, 233, 1062]]}
{"id": "NdlfRj", "name": "round subtlety ", "author": "FabriceNeyret2", "description": "on some machines, round applied to coordinates is rounded up or down depending on parity.\nIf above you don't see a grid of dots on left and blinking on right, says it !\n\ni.e. round seems implemented like roundEven, at least on nVidia/OpenGL", "tags": ["glsl", "bug", "compatibility"], "likes": 5, "viewed": 266, "published": 3, "date": "1645082533", "time_retrieved": "2024-07-30T17:03:12.805904", "image_code": "//#define round roundEven\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4( U.x/iResolution.x < .5 \n                  ? round(U) == U+.5\n                  : round( floor(iTime) +.5 ) == ceil(iTime) \n            );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 65, 65, 220]]}
{"id": "sdXfzj", "name": "half castle", "author": "jorge2017a2", "description": "half castle", "tags": ["halfcastle"], "likes": 10, "viewed": 248, "published": 3, "date": "1645066073", "time_retrieved": "2024-07-30T17:03:13.903969", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nvec2 cuarto00(vec3 p)\n{   vec3 p0=p;\n    vec2 res= vec2(9999.0, -1.0); \n    float d1a= sdRoundBox( p-vec3(0.0,0.5,0.0), vec3(10.5,7.0,10.0), 0.5 );\n    float d1aa= sdRoundBox( p-vec3(0.0,0.5,0.0), vec3(8.5,7.5,8.0), 0.5 );\n    float d1b=sdVesica(p.xy, 4.0, 1.5);\n    float d1c= sdBox(p-vec3(0.0,-2.0,0.0), vec3(2.4,3.0,11.0) );\n    d1a=differenceSDF(d1a,d1aa);\n    float d1bc= unionSDF(d1b, d1c);\n    float ddif= differenceSDF(d1a, d1bc);\n    \n    float d3a= sdRoundBox( p-vec3(0.0,0.5,0.0), vec3(10.5,7.0,10.5), 0.5 );\n    float d3aa= sdRoundBox( p-vec3(0.0,0.5,0.0), vec3(8.5,7.5,8.5), 0.5 );\n    float d3b=sdVesica(p.xy, 4.5, 1.5);\n    float d3c= sdBox(p-vec3(0.0,-2.0,0.0), vec3(3.5,3.0,11.5) );\n    float d3bc= unionSDF(d3b, d3c);\n    d3a=differenceSDF(d3a, d3aa);\n    float ddif3= differenceSDF(d3a, d3bc);\n    \n    p.x=abs(p.x)-8.0;\n    p.z=abs(p.z)-8.0;\n    float d4a= sdCylinderXY( p-vec3(0.0,5.0,0.0), vec2(0.25,5.0) );\n    \n    p=p0;\n    p.x=abs(p.x)-15.0;\n    p.z=abs(p.z)-9.0;\n    float d1=sdCylinderXZ( p, vec2(4.0,10.5) );\n    float d2=sdCylinderXZ( p-vec3(0.0,10.5,0.0), vec2(5.0,1.0) );\n    float d2a=sdCylinderXZ( p-vec3(0.0,10.5,0.0), vec2(4.0,1.5) );\n    d2= differenceSDF(d2, d2a);\n    //res =opU2(res, vec2(ddif,64.0));\n    res =opU2(res, vec2(ddif,100.0));\n    //res =opU2(res, vec2(ddif3,64.0));\n    res =opU2(res, vec2(ddif3,101.0));\n    \n    res =opU2(res, vec2(d1,64.0));\n    res =opU2(res, vec2(d2,64.0));\n    res =opU2(res, vec2(d4a,2.0));\n    return res;\n}   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n     p.y=p.y-6.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+5.5;  //piso inf\n    res =opU2(res, vec2(planeDist1,100.0));\n    p.z= opRep1D(p.z, 35.0 );\n    vec2 re1= cuarto00(p);\n    res =opU2(res, re1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = occlusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n    if (i==101 )\n    { vec3 col=tex3D(iChannel1, p/32., nor); return col*2.0; }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.95,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n    \n    if (id_color==57)\n        {return pattern( p.xz );}\n    if (id_color==58)\n        {return pattern( p.xy );}\n    if (id_color==59)\n        {return pattern( p.zy );}\n    \n   if (id_color==60)\n   {   vec3 mat = vec3(0.8, 0.2, 0.2);\t\n\t\tfloat f = smoothstep(0.3, 0.3001, mod(atan(p.x, p.z), 0.65));\n        mat = mix(mat, vec3(0.7, 0.7, 0.8), 1.0 - f);\n        return mat;\n   }\n   \n   if (id_color==61)\n   {   vec3 mat = vec3(0.3, 0.6, 1.0);\n       float f = smoothstep(0.5, 1., mod(length(p.xz), 2.3));\n       mat = mix(mat, vec3(1.0, 1.0, 1.0), 1.0 - f);\n       return mat;\n   }\n   \n   if (id_color==63)\n   {   vec3 col1= vec3(1)*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0);\n       vec3 col2= vec3(0.5)*mod(floor(p.x*0.5) + floor(p.z*0.05), 2.0);\n       return col1-col2;\n   }\n   \n   if (id_color==62)\n   { return vec3(1)*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0); }\n   \n   if (id_color==64)\n        {return pattern( p.xy*2.0 );}\n   \n   if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        return coltex;\n\t}\n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,22.0,-25.0+t);\n   if (sin((t+1.0)*0.125)<0.0)\n   ro.y-=13.0*abs(sin(t*0.125));\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(30.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random(vec2 uv) \n{ return fract(sin(dot(uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 535, 535, 556], [557, 557, 589, 589, 673], [674, 674, 720, 720, 807], [808, 808, 847, 847, 942], [943, 943, 982, 982, 1077], [1078, 1078, 1117, 1117, 1212], [1214, 1258, 1305, 1305, 1332], [1333, 1333, 1376, 1376, 1403], [1404, 1404, 1452, 1452, 1480], [1481, 1519, 1555, 1555, 1600], [1601, 1641, 1675, 1675, 1771], [1772, 1772, 1806, 1806, 1897], [1898, 1898, 1932, 1932, 2023], [2025, 2025, 2067, 2067, 2224], [2226, 2226, 2249, 2249, 3712], [3717, 3717, 3742, 3742, 3991], [3993, 3993, 4017, 4017, 4179], [4181, 4181, 4229, 4229, 4556], [4558, 4558, 4602, 4602, 4928], [4930, 4930, 4967, 4967, 5228], [5230, 5230, 5315, 5315, 6278], [6280, 6280, 6329, 6329, 6487], [6489, 6489, 6582, 6582, 6712], [6714, 6714, 6746, 6746, 6943], [6945, 6993, 7021, 7021, 7209], [7211, 7211, 7279, 7279, 8476], [8478, 8478, 8505, 8505, 8594], [8596, 8596, 8654, 8654, 8702], [8705, 8705, 8728, 8728, 8846], [8848, 8848, 8879, 8879, 9500], [9503, 9503, 9560, 9560, 10099]]}
{"id": "fdfBzj", "name": "Random Blobs E", "author": "SnoopethDuckDuck", "description": "Quite simple but fun :)", "tags": ["e"], "likes": 13, "viewed": 338, "published": 3, "date": "1645037531", "time_retrieved": "2024-07-30T17:03:14.822512", "image_code": "float blob(vec2 uv, float o) {\n    float d = 10.;\n    for (float i = 0.; i < 12.; i++) {\n        float e = 0.01 * i;\n        float hx = h21(vec2(e + o, 1.-e));\n        float hy = h21(vec2(e + 1., e - o));\n        vec2 p = 0.45 * (0.5 - vec2(hx, hy));\n        d = smin(d, (1.5 - 0.5 * hx) * length(uv - p));\n    }\n    return d;\n}\n\n// todo:\n// stretch hx/hy so u get stretched blobs not in a square\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float time = 0.4 * iTime;\n    \n    float sc = 8.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = sc * uv - ipos;\n\n    float h = h21(ipos);\n    float o = 0.01 * floor(time + h);\n    float d = blob(fpos, o + h);\n    \n    float k = 6. / iResolution.y;\n    float s = smoothstep(-k, k, abs(-d + 0.05) - 0.05);\n    s *= smoothstep(-k, k, smin(-abs(fpos.x), -abs(fpos.y)) + 0.45);\n    vec3 e = vec3(1.);\n    vec3 col = s * pal(0.12 * fpos.y - 0.2 + floor(3. * h) / 3. + floor(time + h)/3., \n                       e, e, e, 0.45 * vec3(0,1,2)/3.);\n    col += 0.08;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 328], [398, 398, 455, 455, 1132]]}
{"id": "7dlfzS", "name": "大龙猫 - 20220216", "author": "totetmatt", "description": "Gaz smol raymarch + meger sponge fracal from previous week shader (lost ref T_T))\n", "tags": ["fractal"], "likes": 7, "viewed": 288, "published": 3, "date": "1645026691", "time_retrieved": "2024-07-30T17:03:15.737067", "image_code": "/**\nGaz smol raymarch + meger sponge fracal from previous week shader (lost ref T_T))\n\n\n*/\n\n#define R(p,a,t) (mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a))\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n// distance to a menger sponge of n = 1\nfloat crossDist( in vec3 p ) {\n  \n    vec3 absp = abs(p);\n  \n    //return length(p.yx+sin(p.z)*.05)-2.7;\n    // get the distance to the closest axis\n    float maxyz = max(absp.y, absp.z);\n    float maxxz = max(absp.x, absp.z);\n    float maxxy = max(absp.x, absp.y);\n    float cr = 1.0 - (step(maxyz, absp.x)*maxyz+step(maxxz, absp.y)*maxxz+step(maxxy, absp.z)*maxxy);\n    // cube\n    float cu = max(maxxy, absp.y) - 3.0;\n    // remove the cross from the cube\n    return max(cr, cu);\n}\n\n// menger sponge fractal\nfloat fractal( in vec3 p ) {\n    vec3 pp = p;\n    float scale = 1.0;\n    float dist = 0.0;\n    for (int i = 0 ; i < 6 ; i++) {\n    \n        dist = max(dist, crossDist(p)*scale);\n        \n        p = fract((p-1.0)*0.5) * 6.0 - 3.0;\n        scale /= 3.;\n        //p.yz*=rot(.785);\n        \n    }\n\n    return dist;\n}\nvec3 pal(float t){ return vec3(.4,.5,.6)+vec3(.2,.3,.5)*cos(6.28*(vec3(.2,.2,.3)*t+vec3(.2,.5,.8)));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 p,c=vec3(0.);\n    vec3 d = normalize(vec3(fragCoord.xy -.5*iResolution.xy,iResolution.y));\n    for(float i=0.,s,e,g=0.,t=iTime;i++<50.;){\n        p=g*d;\n        p = R(p,normalize(vec3(.1+cos(iTime*.5+p.z*.2)*.5,sin(iTime*.5+p.z*.2)*.5,.5)),.5+t*.2);\n\n        p.z +=iTime;\n        p=asin(cos(p))-vec3(2,4,1);\n        p = mod(p,4.)-2.;\n        s=1.;\n        \n        g+=e=max(.0001,abs(fractal(p))+.0009);\n        c+=2.*sqrt(pal(p.z/6.28))*.02/exp(i*i*e);\n    }\n    c*=c;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 172, 172, 219], [220, 260, 290, 290, 744], [746, 771, 799, 799, 1084], [1085, 1085, 1103, 1103, 1186], [1187, 1187, 1242, 1242, 1752]]}
{"id": "ssfBzS", "name": "Sound Experiment #4", "author": "oneshade", "description": "Peaceful music?", "tags": ["sound", "experiment", "peaceful"], "likes": 7, "viewed": 216, "published": 3, "date": "1644997094", "time_retrieved": "2024-07-30T17:03:18.484720", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\nfloat amp(in float freq, in float time) {\n    return (sin(time) * exp(-freq) + 0.01 * sin(5.0 * (freq + time)) + 0.1) * 14.3;\n}\n\n// Stop puzzling, the name is meaningless\nfloat bar(in float time, in float foo) {\n    float sound = 0.0;\n    for (float freq=1.0; freq < 6.0; freq++) {\n        sound += amp(freq, time * 10.0) * sin(TAU * fract(foo * freq * time));\n    }\n\n    return sound;\n}\n\n#define safepow(x, n) sign(x) * pow(abs(x), n)\nfloat makeNoise(in float time) {\n    float sound = 0.0;\n    sound += bar(time, 50.0);\n    sound += bar(time, 100.0);\n    sound += bar(time, 200.0);\n    sound += cos(0.5 * time) * bar(time, 300.0);\n    sound += safepow(sin(0.25 * time), 3.0) * bar(time, 400.0 + 100.0 * step(6.0, mod(time, 10.0)));\n    return sound / 200.0;\n}", "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1411]]}
{"id": "sdsfRM", "name": "Visualizer 2.0", "author": "Zi7ar21", "description": "poggers (still some improvements I wanna make)", "tags": ["music", "visualizer", "visualize"], "likes": 10, "viewed": 452, "published": 3, "date": "1644989375", "time_retrieved": "2024-07-30T17:03:19.465100", "image_code": "// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\nvec3 color_palette(float t)\n{\n    return 0.5 * (vec3(\n    cos( two_pi * (t - 0.0000000000000000) ),\n    cos( two_pi * (t - 0.3333333333333333) ),\n    cos( two_pi * (t - 0.6666666666666666) )\n    ) + 1.0);\n}\n\nvec3 visualizer(vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n\n    float wave_amplitude = 0.5 * (texture(iChannel0, vec2(fragCoord.x / iResolution.x, 1.)).x - 0.5);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x) ;\n\n    float freq_amplitude0 = texture( iChannel0, vec2(fract(2.0 * ( (2.0 * theta + 0.25 * two_pi * iTime) / two_pi ) ), 0.0) ).x;\n    float freq_amplitude1 = texture( iChannel0, vec2(fract(2.0 * ( (2.0 * theta - 0.25 * two_pi * iTime) / two_pi ) ), 0.0) ).x;\n\n    //freq_amplitude0 = pow(freq_amplitude0, 2.0);\n    //freq_amplitude1 = pow(freq_amplitude1, 2.0);\n    freq_amplitude0 *= freq_amplitude0;// * freq_amplitude0;\n    freq_amplitude1 *= freq_amplitude1;// * freq_amplitude1;\n\n    if(wave_amplitude + 0.4 < uv.y)\n    {\n        col = color_palette( fract( (fragCoord.x / iResolution.x) + iTime ) );\n    }\n    if(wave_amplitude - 0.4 > uv.y)\n    {\n        col = color_palette( fract( (fragCoord.x / iResolution.x) - iTime ) );\n    }\n\n    if(r > 0.25 && r < 0.3 * freq_amplitude0 + 0.3)\n    {\n        col = color_palette( fract( 2.0 * ( (theta - 0.25 * two_pi * iTime) / two_pi) ) );\n    }\n    if(r < 0.20 && r > 0.1 * freq_amplitude1 + 0.15)\n    {\n        col = color_palette( fract( 2.0 * ( (theta + 0.25 * two_pi * iTime) / two_pi) ) );\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    fragColor.rgb = (\n    visualizer( fragCoord + vec2(-0.500, -0.250) ) +\n    visualizer( fragCoord + vec2(-0.250,  0.500) ) +\n    visualizer( fragCoord + vec2( 0.250,  0.500) ) +\n    visualizer( fragCoord + vec2( 0.500, -0.500) )\n    ) / 4.0;\n}", "image_inputs": [{"id": 28231, "src": "https://soundcloud.com/cautioncrisis/sweden-caution-crisis-remix?si=5333346d31dd4fc7908c4c4c57f626e2&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 274, 274, 451], [453, 453, 486, 486, 1842], [1844, 1844, 1901, 1901, 2191]]}
{"id": "NsXfRS", "name": "sciggegelgelgelgleg", "author": "SnoopethDuckDuck", "description": "very similar to thing is forked from + comes with extra lag :))\n\n", "tags": ["raymarching", "template", "artofcode"], "likes": 17, "viewed": 366, "published": 3, "date": "1644977779", "time_retrieved": "2024-07-30T17:03:20.241024", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n//nabbed from blacklemori\nvec3 erot(vec3 p, vec3 ax, float rot) {\n  return mix(dot(ax, p)*ax, p, cos(rot)) + cross(ax,p)*sin(rot);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 distort(vec3 p) {\n    float time = 0.5 * length(p) + 1. * iTime;\n    \n    vec3 q = p;\n    float m = 5.;// - 0.2 * length(p);\n    float tp = 2.*pi/3.;\n    for (float i = 0.; i < 7.; i++) {\n        //th += -0.1 * iTime;\n        //q.xy *= Rot(th);\n        //q.zy *= Rot(th);\n        q = sabs(q) - m; //sabs cool too\n        m *= 0.39 + 0.05 * i;\n        \n        time += 1.5 * length(q) + .4 * iTime;\n        q = erot(q, normalize(cos(time + vec3(0,tp,-tp))), 0.1);\n    }\n    \n    // artifacts might appear if p,q are colinear? idk\n    return cross(p, q);\n}\n\nfloat GetDist(vec3 p) {\n   \n    vec3 ro = vec3(0, 3., -3.5);\n    ro.xz *= Rot(0.2 * iTime);\n    float sd = length(p - ro) - 2.2;\n    \n    //p = mix(sabs(p) - 0., sabs(p) - 1., 0.5 + 0.5 * thc(4., iTime));\n    //p.xz *= Rot(0.04 * p.y + 0.* iTime);\n    float sc = 20.;\n    p = distort(p);\n    //p.xz *= Rot(4. * p.y + iTime);\n   // p = sabs(p) - 0.25;\n    float d = length(p) - 0.4; // was 0.8\n    //d = length(p.xz) - 1.;\n    //float tp = 2.*pi/3.;\n    //d = dot(p, cos(0.3 * iTime + vec3(0,tp,-tp)));\n    d *= 0.2; //smaller than I'd ike it to be\n    d = -smin(-d, sd); \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = z * GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3.5); //0,3,-18. looks cool but BUGGY\n    ro.xz *= Rot(0.2 * iTime);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.5;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //vec3 r = reflect(rd, n);\n        /*\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        vec3 pIn = p - 30. * SURF_DIST * n;\n        float dIn = RayMarch(pIn, rdIn, -1.);\n\n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = GetNormal(pExit);\n        */\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       // col = vec3(dif);\n        \n        float fresnel = pow(1.+dot(rd, n), 1.);\n       // col = 1. * vec3(fresnel);\n        \n        //col = mix(vec3(dif), 0.5 + 0.5 * n, exp(-0.2 * length(p)));\n        //p = distort(p);\n        col = vec3(fresnel);\n        //col *= 1. + 0.6 * thc(3., 4. * n.y - 0. * iTime);\n        //col = clamp(col, 0., 1.);\n        col *= 1.-exp(-3.5 - 0.5 * p.y);\n        //col *= cross(p, col);\n        vec3 e = vec3(1.);\n        float tp = 2. * pi / 3.;\n        vec3 c = thc(8., 0.5 * iTime + vec3(0,tp,-tp));\n        c = normalize(c);\n        \n        col *= pal(dot(n,c)*0.28 + -0.05 + 0.1* h21(p.xz), e, e, e, 0.42 * vec3(0,1,2)/3.);\n      \n       \n       // col = clamp(col, 0., 1.);\n        col *= 3. * exp(-0.5 * length(p));\n        //col *= 0.5 + 0.5 * n;\n        //dif = 1.-smoothstep(0., 1., dif);\n        //col = max(col, 0. * dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 93, 132, 132, 199], [201, 201, 220, 220, 282], [284, 284, 313, 313, 394], [396, 396, 418, 418, 955], [957, 957, 980, 980, 1549], [1551, 1551, 1594, 1594, 1809], [1811, 1811, 1835, 1835, 2025], [2027, 2027, 2077, 2077, 2268], [2270, 2270, 2327, 2327, 4112]]}
{"id": "fdlfD4", "name": "Inwards and Onwards", "author": "nyri0", "description": "This is an animated version of an album cover of Half Moon Run's EP \"Inwards and Onwards\".\nI kinda hacked the math, it's actually full 2d but looks 3d.\nTurn FSAA up for more anti-aliasing, down for better perf.", "tags": ["retro", "cover", "album"], "likes": 5, "viewed": 301, "published": 3, "date": "1644972319", "time_retrieved": "2024-07-30T17:03:21.166550", "image_code": "const int FSAA = 4;\nconst float GRID_DIM = 1.0;\nconst float R = 0.8;\n\nfloat jTime;\n\n\nfloat sq(float x) {\n    return x*x;\n}\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat length_sq(vec2 x) {\n    return dot(x, x);\n}\n\nfloat segment_df(vec2 uv, vec2 p0, vec2 p1) {\n  float l2 = length_sq(p1 - p0);\n  float t = clamp(dot(uv - p0, p1 - p0) / l2, 0.0, 1.0);\n  vec2 projection = p0 + t * (p1 - p0);\n  return distance(uv, projection);\n}\n\nfloat semi_circle_sdf(vec2 uv, vec2 c, float r) {\n    return max((length(uv - c) - r), -(uv.y-c.y));\n}\n\nfloat frame_sdf(vec2 uv, vec2 pf) {\n    // Factor by which to multiply the distance at max depth for cheap 3d look.\n    const float fm = 5.0;\n    \n    const vec2 A = vec2(-R, 0.0);\n    const vec2 B = vec2(R, 0.0);\n\n    // Two segments towards pf\n    float sdf = min(segment_df(uv, A, pf), segment_df(uv, B, pf)) * mix(1., fm, smoothstep(0., pf.y, uv.y));\n    \n    // Semi-circles\n    const int n_steps = 15;\n    for(int i = 0; i < n_steps; i++) {\n        float t = 1. - exp(-0.3*float(i));\n        float fmi = mix(1., fm, t);\n        // sdf = min(sdf, segment_df(uv, mix(A, pf, t), mix(B, pf, t)) * fmi);\n        sdf = min(sdf, abs(semi_circle_sdf(uv, mix(vec2(0,0), pf, t), R*(1.-t))) * fmi);\n    }\n    \n    return sdf;\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    \n    // Pixel coordinates fixed with correct aspect ratio\n    vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec2 pf = vec2(0.55 * cos(0.7*iTime), 0.4);\n    vec2 pfl = pf + vec2(0, -0.1);\n    \n    vec3 col;\n    \n    float my_noise = simplexNoise(vec3(500.0*uvf, iTime));\n    \n    // Black noisy background\n    vec3 bg_col = mix(vec3(0,0,0), vec3(0.9, 0.3, 1), smoothstep(0.2, 1.0, my_noise));\n    col = bg_col;\n    \n    // Very visible noise in lower part of the circle\n    if(uvf.y < 0.0) col = mix(vec3(0,0,0), vec3(0.9, 0.3, 1.), 0.1+0.9*smoothstep(0., 1., my_noise));\n    \n    // Bright lines with glow\n    const float fm = 1.7;\n\n    const vec2 po0 = vec2(-0.6*R, 0.);\n    const vec2 po1 = vec2(-0.1*R, 0.);\n    vec2 po0a = pfl + 0.5 * (po0-pf);\n    vec2 po1a = pfl + 0.2 * (po1-pf);\n    vec2 po0b = pfl + 3. * (po0-pf);\n    vec2 po1b = pfl + 3. * (po1-pf);\n    vec3 outer_col_orange = uvf.y > 0. ? vec3(1, 0.35, 0.) : vec3(1, .1, 0);\n    vec3 inner_col_orange = vec3(.95, 1, .8);\n    float df_orange = min(segment_df(uvf, po0b, po0a), segment_df(uvf, po1b, po1a)) * mix(1.0, fm, smoothstep(-R, pf.y, uvf.y));\n    col = mix(outer_col_orange, col, smoothstep(0.1, 0.2, df_orange+0.1*my_noise));\n    col = mix(col, inner_col_orange, step(smoothstep(0., 0.35, df_orange), my_noise));\n    \n    const vec2 pp0 = vec2(0.4*R, 0.);\n    const vec2 pp1 = vec2(0.75*R, 0.);\n    vec2 pp0b = pfl + 3. * (pp0-pf);\n    vec2 pp1b = pfl + 3. * (pp1-pf);\n    vec3 outer_col_blue = uvf.y > 0. ? vec3(0.5, .8, .9) : vec3(0.3, 0.3, 1);\n    vec3 inner_col_blue = vec3(0.95, 1, 1);\n    float df_purple = min(segment_df(uvf, pp0b, pfl), segment_df(uvf, pp1b, pfl)) * mix(1.0, fm, smoothstep(-R, pf.y, uvf.y));\n    col = mix(outer_col_blue, col, smoothstep(0.1, 0.2, df_purple+0.1*my_noise));\n    col = mix(col, inner_col_blue, step(smoothstep(0., 0.35, df_purple), my_noise));\n    \n    // Mask\n    if(length(uvf) > R) col = bg_col;\n    \n    // Frame\n    col = mix(vec3(1,1,1), col, smoothstep(0., 0.007, frame_sdf(uvf, pf)));\n    \n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 104, 104, 122], [254, 254, 276, 276, 428], [429, 429, 457, 457, 1117], [1119, 1119, 1144, 1144, 1168], [1170, 1170, 1215, 1215, 1382], [1384, 1384, 1433, 1433, 1486], [1488, 1488, 1523, 1603, 2210], [2212, 2212, 2252, 2252, 4518], [4520, 4520, 4577, 4577, 4834]]}
{"id": "NsXfzH", "name": "Oh Hi!", "author": "ChrisK", "description": "Oops! all circles", "tags": ["2d", "cute", "circles"], "likes": 17, "viewed": 295, "published": 3, "date": "1644971374", "time_retrieved": "2024-07-30T17:03:22.015281", "image_code": "#define PI                 3.14159\n\n#define BREATHE_SPEED      1.0\n#define SACCADE_FREQUENCY  1.2\n#define SACCADE_SPEED      7.0\n#define BLINK_PERIOD       5.0\n#define BLINK_SPEED        3.0\n\n#define SCALE_FACTOR       1.0\n#define STROKE_WEIGHT      0.01\n#define EYE_SPACE          0.5\n\n\nfloat distancetocoverage( float d ) {\n    return clamp(d/SCALE_FACTOR*iResolution.y+0.5, 0.0, 1.0);\n}\n\n\nfloat circle( vec2 uv, vec2 p, float r ) {\n    float d = r - distance(uv,p);\n    return distancetocoverage(d);\n}\n\n\nfloat circlestroke( vec2 uv, vec2 p, float r, float t ) {\n    float d = r - distance(uv,p);\n    d = t - abs(d);\n    return distancetocoverage(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t// camera-space position (-1 => 1)\n    uv.y *= iResolution.y/iResolution.x;\n    \n    //breathing\n    float breathe = sin(iTime*BREATHE_SPEED);\n    \n    //saccades\n    float sn = floor(iTime*SACCADE_FREQUENCY);\n    vec2 saccade = (1.0-abs(cos(sn*67.0))) * vec2(cos(sn*PI*1.618),sin(sn*PI*1.618));\n    sn++;\n    vec2 nextsaccade = (1.0-abs(cos(sn*67.0))) * vec2(cos(sn*PI*1.618),sin(sn*PI*1.618));\n    float st = max( (fract(iTime*SACCADE_FREQUENCY)-1.0)*SACCADE_SPEED+1.0, 0.0);\n    saccade = mix( saccade, nextsaccade, st*st*(3.0-(2.0*st)) );\n    saccade.x *= sign(uv.x);   //flip one eye so that it moves in the same direction after mirroring\n    \n    //blinking\n    float bt = max( mod(iTime,BLINK_PERIOD)-BLINK_PERIOD+1.0, 0.0 );\n    float b = max( (fract(bt)-1.0)*BLINK_SPEED+1.0, 0.0 ) ;\n    float blink = 9.5212*b*(b-0.8)*(b-1.0); // animating with a cubic function for a nice little 'bounce' at the end\n    \n    uv.y += 0.05-0.005*breathe;\n    uv *= SCALE_FACTOR;\n    uv.x = -abs(uv.x) + EYE_SPACE;                                       // mirror\n    float r = (0.15+blink*0.02)*PI;\n    vec2 ruv = vec2( uv.x*cos(r)-uv.y*sin(r), uv.x*sin(r)+uv.y*cos(r) ); // rotated space for outer eye\n    vec2 buv = vec2( ruv.x, ruv.y/(1.0-blink) );                         // squashed space for blinking eyes\n    \n    float aperture = circle( buv, vec2(0.0), 0.25-STROKE_WEIGHT );       // eyelid coverage\n    \n    float eyelids = 0.0;\n    eyelids += circle( buv,vec2(-0.04,0.0),0.3 ) * distancetocoverage(ruv.y);                       // upper lashes\n    eyelids += circle( buv,vec2(-0.04,0.0),0.25 ) * distancetocoverage(-max(ruv.x,ruv.y));          // lower lashes\n    eyelids += circle( buv, vec2(0.25,0.0), 0.04 );                                                 // lacrimal caruncle\n    eyelids += circlestroke( ruv,vec2(0.0),0.325,STROKE_WEIGHT) * circle(ruv,vec2(0.0,0.4),0.375 ); // eye socket upper arch\n    eyelids *= 1.0-aperture;\n\n    float eyeball = 0.0;\n    vec2 ip = vec2(0.03-blink*0.01, -blink*0.05) + saccade*0.01;\n    eyeball += circlestroke( uv, ip, 0.18, STROKE_WEIGHT );                         // limbal ring\n    eyeball += circle( uv, ip, 0.18 ) * (1.0-circle( uv, ip-vec2(0.0,0.5), 0.5 ));  // shadow on upper iris\n    eyeball += circle( uv, ip, 0.13+blink*0.02 );                                   // pupil\n    float glint = circle( uv, ip, 0.025+blink*0.005 );                              // highlight\n    eyeball *= 1.0-glint;\n    float iriscoverage = circle( uv, ip, 0.18+STROKE_WEIGHT ) * (1.0-glint);\n    eyeball *= aperture;\n    \n    float eyebrows = circle(uv,vec2(0.125,-0.05-blink*0.005),0.6) * (1.0-circle(uv,vec2(0.0),0.4)) * circle(uv,vec2(-0.3+blink*0.01,1.2),1.0);\n    \n    float nose = 0.0;\n    float nh = -0.2+blink*0.002;\n    nose += circlestroke( uv, vec2(EYE_SPACE,nh), 0.125, STROKE_WEIGHT ) * circle(uv,vec2(EYE_SPACE,nh+0.4),0.4); //nose\n    nose += circle( uv, vec2(EYE_SPACE-0.05,nh+0.02), STROKE_WEIGHT*2.0+0.001*breathe );                          //nostril\n    \n    float mouth = 0.0;\n    float mh = -0.2;\n    mouth += circlestroke( uv, vec2(EYE_SPACE,mh+0.05), 0.25, STROKE_WEIGHT ) * distancetocoverage(mh-uv.y);                             //smile curve\n    mouth += circle( uv, vec2(EYE_SPACE-0.245,mh), STROKE_WEIGHT*(2.0+blink*0.1) );                                                      //mouth corners\n    //mouth += circlestroke( uv, vec2(EYE_SPACE,-0.9+blink*0.002), 0.625, STROKE_WEIGHT*1.0 ) * circle( uv, vec2(EYE_SPACE,-0.15), 0.25 ); //upper lip\n    //aperture += circle( uv, vec2(EYE_SPACE,-0.9+blink*0.002), 0.625 ) * circle( uv, vec2(EYE_SPACE,-0.15), 0.25 );\n    \n    float face = 0.0;\n    face += eyelids;\n    face += eyeball;\n    face += eyebrows;\n    face += nose;\n    face += mouth;\n    face = clamp( face, 0.0, 1.0 );\n    \n    vec3 col = vec3(1.0,0.6,0.4);\n    col -= vec3(0.0,0.35,0.3) * clamp(1.0-distance(uv*vec2(1.0,2.5),vec2(EYE_SPACE,-0.3)),0.0,1.0);  //blush\n    col = mix(col, mix(vec3(1.0), vec3(0.1,0.7,1.0), iriscoverage), aperture);  //eye colours\n    //col *= circle( uv*vec2(1.0,1.5+blink*0.02), vec2(EYE_SPACE,0.15), 1.0 );\n    col *= 1.0-face;\n    col = pow( col, vec3(0.45) );\t\t\t\t//gamma adjustment\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 325, 325, 389], [392, 392, 434, 434, 504], [507, 507, 564, 564, 654], [657, 657, 714, 714, 4989]]}
{"id": "fs2SRm", "name": "Material - Wrinkled", "author": "loryruta", "description": "Wrinkled material", "tags": ["material"], "likes": 6, "viewed": 229, "published": 3, "date": "1644967409", "time_retrieved": "2024-07-30T17:03:22.881963", "image_code": "#define NOISE fbm\n\n#define OBJ_DIFF vec3(1.0, 0.0, 0.0)\n\n#define LIGHT_DIFF vec3(1.0)\n#define LIGHT_AMB  vec3(0.1)\n#define LIGHT_DIR  normalize(vec3(-1.0, -1.0, -1.0))\n\n#define EPSILON 0.001\n#define PI 3.1415926538\n#define NUM_NOISE_OCTAVES 8\n\n#define REFRACTIVE_INDEX_OUTSIDE 1.0\n#define REFRACTIVE_INDEX_INSIDE 1.1\n#define OBJECT_REFLECTIVITY 0.1\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x)\n{\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 surf_norm(vec2 pos)\n{\n    float h = NOISE(pos);\n\n    vec3 d1 = normalize(vec3(EPSILON, 0, NOISE(pos + vec2(EPSILON, 0)) - h));\n    vec3 d2 = normalize(vec3(0, EPSILON, NOISE(pos + vec2(0, EPSILON)) - h));\n    \n    return normalize(cross(d1, d2));\n}\n\nvec3 get_scene_color(vec3 ray_dir)\n{\n    return vec3(1.0);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0 - cosX;\n    float ret = r0 + (1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0 - OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\nvec3 apply_light(vec3 surf_norm, vec3 view_dir)\n{\n    // ambient\n    vec3 diff = OBJ_DIFF * LIGHT_AMB; \n    \n    // diffuse\n    float diff_w = clamp(dot(surf_norm, -LIGHT_DIR), 0.0, 1.0);\n    diff += OBJ_DIFF * diff_w * LIGHT_DIFF;\n    \n    // specular\n    vec3 refl_light_dir = reflect(LIGHT_DIR, surf_norm);\n    float spec_w = max(dot(-view_dir, refl_light_dir), 0.0);\n    diff += pow(spec_w, 2.0) * LIGHT_DIFF;  \n    \n    // reflect\n    float reflect_mult = FresnelReflectAmount(\n        REFRACTIVE_INDEX_OUTSIDE,\n        REFRACTIVE_INDEX_INSIDE,\n        surf_norm,\n        view_dir\n    );\n    \n    vec3 view_refl_dir = reflect(view_dir, surf_norm);\n\n    vec3 ret = vec3(0);\n    ret += diff * (1.0 - reflect_mult);\n    ret += get_scene_color(view_refl_dir) * reflect_mult;\n    return ret;\n}\n\nfloat gamma = 2.2;\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    vec3 norm = surf_norm(uv);\n    vec3 view_dir = normalize(vec3(uv, -1.0));\n    \n    vec3 col = apply_light(norm, view_dir);\n    \n    // reinhard tone mapping\n    //col = col / (col + vec3(1.0));\n    \n    // tone mapping\n    //col = lumaBasedReinhardToneMapping(col);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2SRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 371, 371, 401], [402, 402, 422, 422, 510], [512, 512, 534, 534, 654], [657, 657, 678, 678, 1291], [1293, 1293, 1312, 1312, 1589], [1591, 1591, 1617, 1617, 1844], [1846, 1846, 1882, 1882, 1906], [1908, 1908, 1984, 2012, 2528], [2530, 2530, 2579, 2594, 3323], [3344, 3344, 3391, 3391, 3580], [3583, 3583, 3639, 3639, 4009]]}
{"id": "7dlBW7", "name": "Morphing Dot Pattern", "author": "AJFarmar", "description": "You know those circle patterns from old books that used to morph from black into white on the same page? Well I made that. This even moves, and it's fairly mesmerising if I do say so myself.", "tags": ["simple", "monochrome", "dithering", "printing"], "likes": 7, "viewed": 214, "published": 3, "date": "1644957930", "time_retrieved": "2024-07-30T17:03:23.620987", "image_code": "float circ_fn(float k) { return 2.0*sqrt(0.25 - pow(k - 0.5, 2.0)); }\n\nfloat circ_pattern(vec2 v)\n{\n    float sgn = sign( (mod(v.x+1.0, 2.0)-1.0) * (mod(v.y+1.0, 2.0)-1.0) );\n    return sgn * circ_fn(mod(v.x,1.0)) * circ_fn(mod(v.y,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tide = 0.4*sin(0.003*fragCoord.x + 0.7*iTime)\n               - 0.45*cos(0.01*fragCoord.y + 0.005*fragCoord.x - 0.3*iTime)\n               + 0.3*cos(0.005*fragCoord.y + 0.4*iTime + 0.002*fragCoord.x)\n               - 0.25*sin(0.02*fragCoord.y-0.25*iTime);\n    float baseline = circ_pattern(fragCoord/30.0);\n    float v = tide - baseline;\n    float brightness = smoothstep(-1.0, 1.0, v/fwidth(v));\n    fragColor = vec4(vec3(brightness), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 69], [71, 71, 99, 99, 240], [242, 242, 299, 299, 751]]}
{"id": "sdsBWM", "name": "SCIGGLEW", "author": "SnoopethDuckDuck", "description": "absolute mess. looked really cool then closed the tab and had to redo it", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 278, "published": 3, "date": "1644955986", "time_retrieved": "2024-07-30T17:03:24.612337", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n//nabbed from blacklemori\nvec3 erot(vec3 p, vec3 ax, float rot) {\n  return mix(dot(ax, p)*ax, p, cos(rot)) + cross(ax,p)*sin(rot);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 distort(vec3 p) {\n    float time = 0.5 * iTime;\n    \n    vec3 q = p;\n    float m = 3.5 + 3. * cos( 0.4 * length(p) -  0.5 * iTime);\n    float th = 0.2 * iTime;\n    for (float i = 0.; i < 9.; i++) {\n        th += -0.1 * iTime;\n        q.xy *= Rot(th);\n        q.zy *= Rot(th);\n        q = abs(q) - m; //sabs cool too\n        m *= 0.28 + 0.1 * i;\n    }\n    \n    float spd = 0.01;\n    //float time = iTime;\n    float cx = cos(time);\n    float cy = cos(time + 2. * pi / 3.);\n    float cz = cos(time - 2. * pi / 3.);\n    q = erot(q, normalize(vec3(cx,cy,cz)), iTime);\n    return cross(p, q);\n}\n\nfloat GetDist(vec3 p) {\n   \n    \n    float sd = length(p - vec3(0, 3., -3.5)) - 2.2;\n    \n    //p = mix(sabs(p) - 0., sabs(p) - 1., 0.5 + 0.5 * thc(4., iTime));\n    \n    p = distort(p);\n    //p.xz *= Rot(4. * p.y + iTime);\n   // p = sabs(p) - 0.25;\n    float d = length(p) - 1.; // was 0.8\n    d *= 0.05; //smaller than I'd ike it to be\n    d = -smin(-d, sd); \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = z * GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3.5);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.5;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //vec3 r = reflect(rd, n);\n        /*\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        vec3 pIn = p - 30. * SURF_DIST * n;\n        float dIn = RayMarch(pIn, rdIn, -1.);\n\n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = GetNormal(pExit);\n        */\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       // col = vec3(dif);\n        \n        //float fresnel = 1.-pow(1.+dot(rd, n), 1.);\n       // col = 1. * vec3(fresnel);\n        \n        col = mix(vec3(dif), 0.5 + 0.5 * n, exp(-0.2 * length(p)));\n        //p = distort(p);\n       \n        col *= 1. + 0.6 * thc(3., 4. * n.y - 0. * iTime);\n        col = clamp(col, 0., 1.);\n       // col *= 1.-exp(-0.5 - 0.5 * p.y);\n        \n        vec3 e = vec3(1.);\n        col *= pal(length(p) * 0.1 + -0.05, e, e, e, 0.4 * vec3(0,1,2)/3.);\n        col = clamp(col, 0., 1.);\n        col *= 2. * exp(-0.2 * length(p));\n        col *= 0.8 + 0.2 * n.y;\n       \n        //col += dif;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 93, 132, 132, 199], [201, 201, 220, 220, 282], [284, 284, 313, 313, 394], [396, 396, 418, 418, 989], [991, 991, 1014, 1014, 1372], [1374, 1374, 1417, 1417, 1632], [1634, 1634, 1658, 1658, 1848], [1850, 1850, 1900, 1900, 2091], [2093, 2093, 2150, 2150, 3622]]}
{"id": "fssfDM", "name": "Weird Object", "author": "SnoopethDuckDuck", "description": "Very laggy (I think some parts are very thin from where I've distorted space - had to use very small distances to remove artifacts)", "tags": ["raymarching", "template", "artofcode"], "likes": 20, "viewed": 477, "published": 3, "date": "1644949140", "time_retrieved": "2024-07-30T17:03:25.439127", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001 \n\n//nabbed from blacklemori\nvec3 erot(vec3 p, vec3 ax, float rot) {\n  return mix(dot(ax, p)*ax, p, cos(rot)) + cross(ax,p)*sin(rot);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 distort(vec3 p) {\n    float time = 0.25 * iTime;\n    \n    float sc = 1.5;//exp(-0.5 * length(p));// + 0.5 * cos(0.5 * length(p) - iTime);\n    \n    float tp = 2.*pi/3.;\n    //float val = length(p);//.;//cos(time)*p.x + cos(time + tp)*p.y + cos(time-tp)*p.z;\n    \n    float c  = cos(time + sc * smin(p.y, p.z) + pi * cos(0.1 * iTime));\n    float c2 = cos(time + sc * smin(p.z, p.x) + pi * cos(0.1 * iTime + tp));\n    float c3 = cos(time + sc * smin(p.x, p.y) + pi * cos(0.1 * iTime - tp));\n\n    vec3 q = erot(normalize(p), normalize(vec3(c,c2,c3)), pi + 0.3 * cos(2. * length(p) - iTime));\n    //q = cross(q, vec3(c3,c,c2));\n    return cross(p, q);\n}\n\nfloat GetDist(vec3 p) {\n   \n    float sd = length(p - vec3(0, 2, -4)) - 1.2;\n    \n    //p = mix(sabs(p) - 0., sabs(p) - 1., 0.5 + 0.5 * thc(4., iTime));\n       \n    p.xz *= Rot(0.2 * iTime);\n    p = distort(p);\n    \n    //p.xz *= Rot(4. * p.y + iTime);\n    //p = sabs(p) - 0.25;\n    \n    float d = length(p) - 0.5;\n    d *= 0.05; // MUCH smaller than I'd like it to be\n       \n    // looks okayish with torus\n    /*\n    float r1 = 2.;\n    float r2 = 0.2;\n    float d1 = length(p.xz) - r1;\n    \n    float a = atan(p.x ,p.z);\n    vec2 u = vec2(d1, p.y);  \n    u *= Rot(1.5 * a);\n    u.x = abs(u.x) - r2;\n    float d2 = length(u) - r2;\n    d2 *= 0.05;\n    */\n    \n    d = -smin(-d, sd); \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = z * GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t//vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 2, -4);\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    // ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.5;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        // float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        // col = vec3(dif);\n        \n        float fresnel = pow(1.+dot(rd, n), 2.);\n        col = vec3(fresnel);\n        \n        // p = distort(p);\n        col *= 2.2 + 1.8 * thc(14., 24. * length(p) - 1. * iTime);\n        col = clamp(col, 0., 1.);\n        col *= 1.-exp(-1.1 - 0.5 * p.y);\n        col *= 0.9 + 0.5 * n.y;\n        vec3 e = vec3(1.);\n        col *= pal(length(p) * 0.2 - 0.08 * iTime, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col = clamp(col, 0., 1.);\n        col *= 2.8 * exp(-0.8 * length(p));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 94, 133, 133, 200], [202, 202, 221, 221, 283], [285, 285, 307, 307, 938], [940, 940, 963, 963, 1645], [1647, 1647, 1690, 1690, 1905], [1907, 1907, 1931, 1931, 2121], [2123, 2123, 2173, 2173, 2364], [2366, 2366, 2423, 2423, 3520]]}
{"id": "NslfDM", "name": "interpolations", "author": "FabriceNeyret2", "description": "We often have to interpolate things. but are you sure you are handling the right measure unit of the quantity, that is the logical one to interpolate ? e.g. intensity, or energy, or magnitude ? or there inverse ?\nHere I illustrate how it is not neutral.\n", "tags": ["interpolation"], "likes": 10, "viewed": 268, "published": 3, "date": "1644943766", "time_retrieved": "2024-07-30T17:03:26.235996", "image_code": "#define SQR(x)  ( (x)*(x) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u/R;\n    float x = U.x;\n\n    vec4 a0 = vec4(.1), \n         a1 = mod(iTime,2.)<1. ? vec4(1) : vec4(4,2,1,0);\n                              // with grey   with colors\n    int i = int(7.*U.y);\n//  if the right unit is F(a), then we do F⁻¹( mix( F(a0),F(a1),x ) )    \n    O = vec4(   i==6 ? mix( a0, a1, x )                    // transmit\n              : i==5 ? 1.-mix( 1.-a0, 1.-a1, x )           // opacity\n              : i==4 ? 1./mix( 1./a0, 1./a1, x )           // \n              : i==3 ? sqrt( mix( a0*a0, a1*a1, x ) )      // energy\n              : i==2 ? SQR( mix( sqrt(a0), sqrt(a1), x ) ) //\n              : i==1 ? exp( mix( log(a0), log(a1), x ) )   // magnitude\n              :        log( mix( exp(a0), exp(a1), x))     //\n            );\n    \n    O += 1./256.*texelFetch(iChannel0,ivec2(u)%1024,0);    // suppress Mach bands\n    if ( int(7.*u.y)%int(R.y) < 7 ) O =  vec4(0,1,0,0);    // separators\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 67, 67, 1013]]}
{"id": "NdlBWM", "name": "bouncy mouse circle", "author": "FutureMapper", "description": "circle that bounces to mouse", "tags": ["mouse", "circle", "bounce"], "likes": 4, "viewed": 259, "published": 3, "date": "1644936763", "time_retrieved": "2024-07-30T17:03:27.105670", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = (iResolution.xy/iResolution.yy);\n    uv = uv * aspect;\n    \n\n    // Time varying pixel color\n    vec2 pos = texture(iChannel0, vec2(0., 0.)).xy * aspect;\n    vec3 col = vec3(clamp(1.-smoothstep(length(uv-pos), 0.0, 0.05), 0., 1.)-0.8)*4.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = (iResolution.xy/iResolution.yy);\n    vec2 lastpos = texture(iChannel0, vec2(0, 0)).xy;\n    vec2 pos = texture(iChannel0, vec2(1, 0)).xy;\n    if(iFrame == 0)\n    {\n        lastpos = vec2(0.9, 0.9);\n        pos = vec2(0.9, 0.9);\n    }\n    vec2 lastTemp = lastpos;\n    lastpos = pos;\n    pos += (lastpos - lastTemp) * 0.999;\n    //pos.y -= 0.00095;\n    pos -= ((pos - (iMouse.xy / iResolution.xy))/5.);\n    \n    \n    vec3 buff;\n    if(uv.x < 0.1)\n    {\n        buff = vec3(lastpos.xy, 0.);\n    }\n    else\n    {\n        if(uv.x < 1.1)\n        {\n            buff = vec3(pos.xy, 0.);\n        }\n    }\n    \n    fragColor = vec4(buff, 0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 462]]}
{"id": "7sffWM", "name": "Squiggle Ribbon", "author": "SnoopethDuckDuck", "description": "Far away parts are very buggy (hence the dark fade), stilll some artifacts but you lose the feeling of being surrounded if you fade any more \n\n(messy code)", "tags": ["raymarching", "template", "artofcode"], "likes": 15, "viewed": 409, "published": 3, "date": "1644929517", "time_retrieved": "2024-07-30T17:03:27.857660", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n//nabbed from blacklemori\nvec3 erot(vec3 p, vec3 ax, float rot) {\n  return mix(dot(ax, p)*ax, p, cos(rot)) + cross(ax,p)*sin(rot);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 distort(vec3 p) {\n    float time = 3. * length(p) + 1.*iTime;//0. * length(p);\n    \n    float spd = 0.01;\n    float c = cos(time);\n    float c2 = cos(time + 2. * pi /3.);\n    float c3 = cos(time - 2. * pi / 3.);\n    //float s = thc(spd, pi/2. + time);\n    vec3 q = erot(vec3(c,c2,c3), normalize(vec3(c2,c3,c)), 0.5 * iTime + 3. * length(p));\n    return cross(p, q);\n}\n\nfloat GetDist(vec3 p) {\n   \n    \n    float sd = length(p - vec3(0, 3., -3.5)) - 1.2;\n    \n    //p = mix(sabs(p) - 0., sabs(p) - 1., 0.5 + 0.5 * thc(4., iTime));\n    \n    p = distort(p);\n    p.xz *= Rot(4. * p.y + iTime);\n    p = sabs(p) - 0.25;\n    float d = length(p) - 0.3;\n    d *= 0.05; //smaller than I'd ike it to be\n    d = -smin(-d, sd); \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = z * GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3.5);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.5;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //vec3 r = reflect(rd, n);\n\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        vec3 pIn = p - 3. * SURF_DIST * n;\n        float dIn = RayMarch(pIn, rdIn, -1.);\n\n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = GetNormal(pExit);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float fresnel = pow(1.+dot(rd, n), 1.);\n        col = 1. * vec3(fresnel);\n        \n       // vec3 q = distort(p);\n        col *= 2. + 1.8 * thc(10., 60. * length(p) - 1. * iTime);\n        col = clamp(col, 0., 1.);\n       // col *= 1.-exp(-0.5 - 0.5 * p.y);\n       // col *= 0.5 + 0.5 * n;\n        vec3 e = vec3(1.);\n        col *= pal(length(p) * 3. - 0.05 * iTime, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col = clamp(col, 0., 1.);\n        col *= exp(-1.2 * length(p));\n        col *= 3.;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sffWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 93, 132, 132, 199], [201, 201, 220, 220, 282], [284, 284, 313, 313, 394], [396, 396, 418, 418, 768], [770, 770, 793, 793, 1137], [1139, 1139, 1182, 1182, 1397], [1399, 1399, 1423, 1423, 1613], [1615, 1615, 1665, 1665, 1856], [1858, 1858, 1915, 1915, 3274]]}
{"id": "NsXfWM", "name": "Bandlimited Synthesis 2b", "author": "FabriceNeyret2", "description": "around iq's \"Bandlimited Synthesis 2\" [url]https://shadertoy.com/view/wtXfRH[/url]\n- left: exact box filter  right:  spline filter ( pseudoGaussian )\n- top: using fwidth      bottom : using L2 gradient.    blue = isovalue\n- click: see 2PI band instead PI ", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 22, "viewed": 430, "published": 3, "date": "1644914310", "time_retrieved": "2024-07-30T17:03:28.621617", "image_code": "// variant of \"Bandlimited Synthesis 2\" by iq. https://shadertoy.com/view/wtXfRH\n\n#define fwidth2(x) length(vec2(dFdx(x),dFdy(x)))\n\nvoid mainImage(out vec4 O,  vec2 U )\n{\n\tvec2  R = iResolution.xy, p = 2.*U-R;\n    float a = 400.* ( atan(p.y,p.x) + .05*iTime ),               // rays pattern\n          f = iMouse.z > 0. ? 1. : .5,                           // click = 2PI band instead of PI\n          w = p.y>0. ? fwidth(a): fwidth2(a),                    // L1 or L2 gradient\n          v = p.x<0. ?  cos(a)* sin(.5*w)/(.5*w)                 // box filter\n                      : cos(a)* smoothstep(f*6.28,0.,w);         // spline filter ( ~gauss )\n \n    O = vec4( pow( .5+.5*v , 1./2.2 ) );                         // display ( to sRGB )\n    \n    O = mix(O, vec4(0,0,1,0), smoothstep(.03,0.,abs(w-3.14) ) ); // isovalue\n    R = U-.5 - floor(R/2.); if (R.x*R.y==0.) O = vec4(1,0,0,0);  // red separators\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 170, 170, 904]]}
{"id": "7ssfWN", "name": "Hammersley Sampling Test", "author": "JuanDeager", "description": "A quick sample showing importance sampling using a Hammersley sequence for pseudorandom numbers.\n\nTime-based rotation isn't actually used in practice, it just makes this shader a little less boring to visualize :D", "tags": ["test", "sample", "distribution"], "likes": 6, "viewed": 342, "published": 3, "date": "1644905455", "time_retrieved": "2024-07-30T17:03:29.383580", "image_code": "#define SAMPLES 200u\n#define MODE 1\n// mode 0: display points as cartesian\n// mode 1: display points as polar\n// mode 2: display points as uniform polar\n// mode 3: secret :)\n\n#define PI (3.141592653)\n#define TWO_PI (2.0 * PI)\n\n// reverses the bits of the input\nuint MyBitfieldReverse(uint i)\n{\n\tuint b =  ( uint(i) << 16u) | (uint(i) >> 16u );\n\tb = (b & 0x55555555u) << 1u | (b & 0xAAAAAAAAu) >> 1u;\n\tb = (b & 0x33333333u) << 2u | (b & 0xCCCCCCCCu) >> 2u;\n\tb = (b & 0x0F0F0F0Fu) << 4u | (b & 0xF0F0F0F0u) >> 4u;\n\tb = (b & 0x00FF00FFu) << 8u | (b & 0xFF00FF00u) >> 8u;\n    return b;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n  return vec2(\n    float(i) / float(N),\n    float(MyBitfieldReverse(i)) * 2.3283064365386963e-10\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // rotate the UV\n    float t = iTime * .25;\n    mat2 rot = mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n    uv = (rot * (uv - 0.5)) + 0.5;\n\n    // accumulate color based on proximity to samples\n    vec3 color = vec3(0, 0, 0);\n    uint s = uint(ceil(float(SAMPLES) * (.5 + .5 * sin(iTime))));\n    for (uint i = 0u; i < s; i++)\n    {\n        float weight = 1.0;\n        vec2 point = vec2(0.0);\n#if MODE == 0\n        point = Hammersley(i, SAMPLES);\n#elif MODE == 1 || MODE == 2 || MODE == 3\n        vec2 xi = Hammersley(i, SAMPLES);\n    #if MODE == 1\n        weight = max(.10, 3.0 * xi.x);\n    #elif MODE == 2\n        xi.x = sqrt(xi.x);\n    #elif MODE == 3\n        xi.x = float(i) / float(SAMPLES);\n        xi.y = float(i) / float(SAMPLES) * PI;\n        xi.y = log(xi.y);\n        weight = .25;\n    #endif\n        float r = xi.x * 0.5;\n        float theta = xi.y * TWO_PI;\n        point = vec2(0.5) + vec2(r * cos(theta), r * sin(theta));\n#endif\n        float str = 1.0 - smoothstep(0.0, .02 * weight, distance(uv, point));\n        color.rb += str;\n        color.g += str * float(i) / float(SAMPLES);\n    }\n    \n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 261, 293, 293, 583], [585, 585, 618, 618, 722], [724, 724, 779, 779, 2051]]}
{"id": "fssfDN", "name": "Valentwine 2", "author": "Mipmap", "description": "Valentine? Valenline? Valentwine? Happy Valentine's Day.\nColor and density tweak of \"Lover 2\" by FabriceNeyret2. https://shadertoy.com/view/ssjyWc", "tags": ["heart", "reproduction", "dondeti"], "likes": 4, "viewed": 316, "published": 3, "date": "1644888489", "time_retrieved": "2024-07-30T17:03:30.154519", "image_code": "// Fork of \"Valentwine\" by Mipmap. https://shadertoy.com/view/fsffW4\n// 2022-02-15 01:27:14\n\n// Fork of \"Lover 2\" by FabriceNeyret2. https://shadertoy.com/view/ssjyWc\n// 2022-02-14 12:52:00\n\n// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  \n    vec4 bg = vec4(1.000,0.859,0.878,0.0);\n    Q = bg;\n    float c = B( U ).z;\n    if (c > 0.0) \n        Q = vec4(c, 0.0, 0.0, 0.0); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n", "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n#define  k ( .2 * R.x*R.y )\nMain \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    if ( i < k ) {\n        for (float j = -20.; j <= 20.; j++) \n            if (j!=0.) {\n                vec4 a = A(_21(mod(i+j,k)));\n                vec2 r = a.xy-Q.xy;\n                float l = length(r);\n                f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n            }\n        for (float x = -2.; x <= 2.; x++)\n            for (float y = -2.; y <= 2.; y++) {\n                vec2 u = vec2(x,y);\n                vec4 d = D(Q.xy+u);\n                f -= 100.*d.w*u;\n            }\n        if (length(f)>.1) \n            f = .1*normalize(f);\n        Q.zw += f-.03*Q.zw;\n        Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n\n        vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n        //Q.zw = mix(Q.zw,m.zw,0.1);\n        //Q.xy = mix(Q.xy,m.xy,0.01);\n        if (Q.x>R.x)\n            Q.y=.5*R.y,Q.z=-10.;\n        if (Q.x<0.)\n            Q.y=.5*R.y,Q.z=10.;\n    }\n    if (iFrame < 1 || keyClick(32)) {\n        if ( i > k ) \n            Q = vec4(R+i,0,0); \n        else\n            Q = vec4(.5*R + .25*R.y* cos( 6.28*i/k + vec2(0,1.57)), 0,0 );\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n        for (int y=-1;y<=1;y++)\n            XY(U,Q,B(U+vec2(x,y)));\n        \n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-6.));\n    XY(U,Q,vec4(Q.x+6.));\n    \n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    \n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    \n    float l = sg(U,a1.xy,a2.xy);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    //Q = mix(Q,D(U),.5);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "NsffWN", "name": "mushroom heart", "author": "hnh", "description": "This is the by-product of some kaleidoscopic/plane geometry experiments. Will elaborate later on (if anyone cares ;-). ", "tags": ["2d", "heart", "kifs", "symmetry", "ornament"], "likes": 13, "viewed": 374, "published": 3, "date": "1644877046", "time_retrieved": "2024-07-30T17:03:31.028183", "image_code": "\nconst float PI = 3.14159265;\n\nvec4 flip(vec2 p) {\n    vec3 a = vec3(0.0998); int ni = 58;  // parameters\n    vec3 q= vec3(p, .12);  // scale\n    vec3 t;\n    for(int i=0; i<ni; i++) {\n        a = sin(a);\n        a = vec3(1.-a.y-a.x,a.y,a.x)*PI;\n\n        vec3 c = cos(a), s = sin(a);\n        mat3 N= mat3(1, 0, 0,\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);\n    \n        for(int j=0; j<3; j++) {\n            t[j] = dot(q, N[j]);\n            if(t[j] < 0.) {q -= 2.*t[j]*N[j]*vec3(1,1,0);}\n        }\n    }\n    return vec4(q.xy, t.yz);\n}\n\n\n\nvoid mainImage(out vec4 O, vec2 U) {        \n    U = (U - .5*iResolution.xy)/iResolution.y;\n\t\n    float eps= 1e-5;\n    vec2 u = flip((U-vec2(1,-.3)*eps)*2.).xy;\n    U = flip(U*2.).xy;\n    u = (U-u)/eps;\n    \n    O = texture(iChannel0,U-iTime*.01);\n    O = .7-.5*cos(5.*O);  // color, not the best...\n    O *= .5 + .15*u.x;  // relief\n}\n\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsffWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 50, 50, 567], [571, 571, 607, 607, 906]]}
{"id": "NdsfW4", "name": "Into the techno dome", "author": "mrange", "description": "License CC0: Into the techno dome\nA simple extension of \"Follow the Light\" I made earlier.\nThe tunnel forks and the fork is picked randomly.\nBased on: https://www.shadertoy.com/view/XsBXWt", "tags": ["raymarch"], "likes": 11, "viewed": 472, "published": 3, "date": "1644871028", "time_retrieved": "2024-07-30T17:03:31.786156", "image_code": "// License CC0: Into the techno dome\n// A simple extension of \"Follow the Light\" I made earlier.\n// The tunnel forks and the fork is picked randomly.\n// Thought it turned out nice.\n// Based on: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 70\n#define NORM_OFF        0.0001\n#define PCOS(x)         (0.5 + 0.5*cos(x))\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat fractal(vec3 pos) {\n  vec3 tpos =pos;\n  const float sz = 6.0;\n  tpos.z    = abs(0.5*sz-mod(tpos.z, sz));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif\n\n  // Splits the tunnel\n  const float splitDist = 50.0;\n  float mz = mod(p.z, splitDist);\n  float n  = floor(p.z/splitDist);\n  float h  = hash(n);\n  float off = 1.75*smoothstep(15.0, 35.0, mz);\n\n  p.x -= h>0.5 ? off : -off;\n  p.x = abs(p.x);\n  p.x -= 1.0+off;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  return fractal(p); \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = cam(ro.z+10.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0), 1.0);  \n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.75, 2.25, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.2, 1.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.75, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*06.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsfW4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1096, 1156, 1184, 1204, 1280], [1282, 1342, 1364, 1364, 1412], [1414, 1497, 1536, 1536, 1625], [1627, 1627, 1657, 1657, 1685], [1687, 1781, 1839, 1839, 2320], [2322, 2392, 2414, 2414, 2553], [2583, 2583, 2608, 2608, 2985], [2987, 2987, 3005, 3078, 3637], [3639, 3639, 3687, 3687, 3882], [3884, 3884, 3907, 3907, 4115], [4117, 4117, 4148, 4148, 5487], [5489, 5489, 5520, 5520, 5884], [5886, 5986, 6007, 6007, 6080], [6081, 6181, 6203, 6203, 6252], [6254, 6254, 6309, 6309, 6486]]}
{"id": "fdfBDN", "name": "Colourful turbulence", "author": "forprix", "description": "a bit laggy tho", "tags": ["noise", "color", "rgb", "colour", "smooth"], "likes": 1, "viewed": 264, "published": 3, "date": "1644855310", "time_retrieved": "2024-07-30T17:03:32.596988", "image_code": "const float radius = 20.0;\nconst float PI = 3.1415926538;\n\n\n\nfloat rand(in vec2 p, in float s) {\n    return fract(sin(dot(vec3(p, s),vec3(12.9894,78.233,144.7272))) * 43758.5453);\n}\n\nvec3 noise(in vec2 coord, in float seed) {\n    vec3 a;\n    a.x = rand(coord, seed + 1.);\n    a.y = rand(coord, seed + 2.);\n    a.z = rand(coord, seed + 3.);\n\treturn a;\n}\n\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax )\n\t\t\th = ( g - b ) / cDelta;\n\t\telse if ( g == cMax )\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\telse\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\n\t\tif ( h < 0.0)\n\t\t\th += 6.0;\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\nvec3 hsl2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat rand(float co) {\n    return fract(sin(dot(vec2(co, co + 20055552.), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 step4(vec2 vec) {\n    \n    float rTime = iTime * rand(vec, 0.) * 5.;\n    \n    float qb = float(int(rTime));\n    \n    vec3 a = noise(vec, float(int(rTime) - 1));\n    \n    return a + (noise(vec, qb) - a) * (rTime - qb);\n}\nvec3 step3(vec2 vec) {\n    vec3 sum = vec3(0, 0, 0);\n    int i = 0;\n    \n    for (int x = int(-radius); x <= int(radius); ++x)\n    \tfor (int y = int(-radius); y <= int(radius); ++y) {\n            float d = sqrt(float(x * x + y * y));\n            if (d <= radius) {\n                float k = 1. - d / radius;\n            \ti++;\n            \tsum += step4(vec2(vec.x + float(x), vec.y + float(y))) * k;\n\t\t\t}\n        }\n    \n    sum /= float(i);\n    \n    \n    return sum;\n}\n\n\nvec3 step2(vec2 vec) {\n    vec3 hsl = rgb2hsl(step3(vec));\n    hsl.y = 33333.;\n    return hsl2rgb(hsl);\n}\n\nvec3 step1(vec2 vec) {\n    return step2(vec);\n}\n\nconst int gaytest = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = step1(fragCoord.xy);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 96, 96, 181], [183, 183, 225, 225, 352], [354, 354, 380, 380, 946], [947, 947, 969, 969, 1111], [1114, 1114, 1136, 1136, 1228], [1230, 1230, 1252, 1252, 1454], [1455, 1455, 1477, 1477, 1922], [1925, 1925, 1947, 1947, 2030], [2032, 2032, 2054, 2054, 2079], [2105, 2105, 2162, 2162, 2240]]}
{"id": "fsXfWN", "name": "Frosted Forest", "author": "eiffie", "description": "trees", "tags": ["tree"], "likes": 69, "viewed": 900, "published": 3, "date": "1644852242", "time_retrieved": "2024-07-30T17:03:33.547447", "image_code": "//Frosted Forest by eiffie\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=1.,shadowCone=0.5;\n//Beestie based on marius's strandbeest leg https://www.shadertoy.com/view/ltG3z1\n//which is based on...\n// Visualizing Theo Jansen's Strandbeest basic leg linkage\n// http://www.strandbeest.com/\n// See http://www.strandbeest.com/beests_leg.php for names & values.\n\n// distance from point p to line segment ab\nvec2 seg(vec2 a, vec2 b, vec2 p){\n  vec2 pa=p-a,ba=b-a;\n  float t=dot(pa,ba)/dot(ba,ba);\n  float d=length(pa-ba*clamp(t,0.0,1.0));\n  return vec2(d,max(d,0.5-abs(t-0.5)));\n}\n// intersect point between two 2d circles (x,y,r)\nvec2 intersect(vec3 c0, vec3 c1) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y, dxy.x) * (h/d);\n    return p2 + rxy;\n}\nfloat iZ,iY;\nfloat DEB(vec3 p0){\n  const float a = .38,b = .415,c = .393,d = .401,e = .558,f = .394,g = .367;\n  const float h = .657,i = .49,j = .50,k = .619,l = .078,m = .15;\n  float sx=1.0,dB=max(abs(p0.x)-2.0,abs(p0.z)-3.75);\n  if(p0.x<0.0){sx=-1.0;p0.z-=0.5;}\n  float t=(-time*1.5+(sin(-time*0.1)+2.0)*floor(mod(p0.z,10.))+1.57*sx)*sx;\n  float x=sx*p0.x-0.2;\n  vec2 crank = vec2(0, 0);         \n  vec2 axle = crank - vec2(a, -l);\n  vec2 pedal = crank + vec2(m*cos(t), -m*sin(t));\n  vec2 uv=vec2(-x,-p0.y);\n  // draw \"frame\"\n  vec2 ds = seg(vec2(0, l), axle, uv);\n  ds = min(ds, seg(vec2(0, l), crank, uv));\n  ds = min(ds, seg(pedal, crank, uv));\n  // compute linkage points\n  vec2 P1 = intersect(vec3(pedal, j), vec3(axle, b));  // bej\n  vec2 P2 = intersect(vec3(axle, c), vec3(pedal, k));  // cgik\n  vec2 P3 = intersect(vec3(P1, e), vec3(axle, d));  // edf\n  vec2 P4 = intersect(vec3(P3, f), vec3(P2, g)); // fgh\n  vec2 P5 = intersect(vec3(P4, h), vec3(P2, i));  // hi\n  ds = min(ds, seg(P1, axle, uv));\n  ds = min(ds, seg(P3, axle, uv));\n  ds = min(ds, seg(P1, P3, uv));\n  ds = min(ds, seg(P2, P4, uv));\n  ds = min(ds, seg(P2, P5, uv));\n  ds = min(ds, seg(P4, P5, uv));\n  ds = min(ds, seg(pedal, P1, uv));\n  ds = min(ds, seg(pedal, P2, uv));\n  ds = min(ds, seg(P2, axle, uv));\n  ds = min(ds, seg(P3, P4, uv));\n  float z=abs(fract(p0.z)-0.5)-0.2;\n  float d2=max(ds.y,z);\n  float d3=min(length(uv),length(uv-axle));\n  float d1=sqrt(ds.x*ds.x+z*z);\n  d1=min(min(min(d1,min(d2,d3))-0.01,(1.2-fract(p0.z))*iZ),abs(p0.x)+0.2);\n  return max(d1,abs(p0.z)-3.75);\n}\nfloat reed(vec3 p){return max(length(p.xz)-.02+p.y*.02,abs(p.y-.5)-.5);}\nfloat DE(vec3 p0){\n  const float zd=30.;\n  float x=-zd*1.5+iTime*.25;\n  vec3 p=p0+vec3(x,sin(p0.x+2.*sin(p0.z))*.08-.95,-zd-3.);\n  float db=max(abs(p.y)-1.,max(abs(p.x)-2.,abs(p.z)-3.75));\n  if(db<.2)db=DEB(p);\n  p=p0;\n  float rnd=1.5+sin(floor(p.x*.5)+floor(p.z*.5));\n  float dy=.2*clamp(p.y+.4,0.,1.);\n  p+=sin(p.zxy+2.*sin(p.yzx))*dy;\n  \n  float dg=min(p.y,db),d=10.,dr=1.;\n  bool tree=p.x<-x || abs(p.z-zd-3.)>2.75;\n  p.xz=mod(p.xz,2.)-1.;\n  p.xz=abs(p.xz);\n  p.xz-=p.y*p.y*.3;\n  if(!tree){p*=2.;dr*=2.;rnd=-1.;}\n  d=reed(p)/dr;\n  \n  for(int i=0;i<3;i++){if(float(i)>rnd)continue;\n    p.y-=.42;\n    p*=2.;dr*=2.;\n    p.xz=abs(vec2(p.x+p.z,p.x-p.z))*.707;\n    p.xz-=p.y*p.y*.3;\n    d=min(d,reed(p)/dr);\n  }\n  \n  return min(db,min(dg*2.,d*(1.-.5*dy)/iY));\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0,1,0)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 bg(vec3 rd){\n  float d=max(0.,rd.x+rd.y+rd.z);\n  return vec3(d*d*.25)+rd*.05;\n}\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<12;i++){\n  if(t>lightDist)break;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t)+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\nvec3 path(float t){return vec3(t+.1+cos(t*.23)*2.,.3+.1*sin(t),t);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=min(time,81.85)*0.5;//camera, lighting and object setup\n vec3 ro=path(tim); \n vec3 rd=lookat(path(tim+.1)-ro)*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)/size.y,2.0)); \n focalDistance=1.0;iZ=1./rd.z;iY=1.+max(0.,2.*rd.y);\n aperture=0.007*focalDistance;\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25),L=normalize(vec3(.4,.4,.2)),bcol=bg(rd);\n vec4 col=vec4(bcol,0.);//color accumulator, .w=alpha\n float t=0.0,d=1.,h[8]=float[8](0.,0.,0.,0.,0.,0.,0.,0.);//distance traveled\n int H=0;\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>50.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  d=DE(ro+rd*t);\n  if(d<rCoC){h[H++]=t;}//d+=.5*rCoC*linstep(rCoC,-rCoC,d);}\n  d*=0.8+0.2*rand2();//add in noise to reduce banding and create fuzz\n  t+=d;\n }\n for(int i=7;i>=0;i--){if(h[i]==0.)continue;\n   vec3 p=ro+rd*h[i];//back up to previos checkpoint\n   float rCoC=CircleOfConfusion(t);\n   float d=DE(p),Drd=DE(p+rd*rCoC),Drt=DE(p+rt*rCoC),Dup=DE(p+up*rCoC);\n   vec3 N=normalize(rd*(Drd-d)+rt*(Drt-d)+up*(Dup-d));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   vec3 scol=vec3(0.4*(1.0+dot(N,L)+.2));//difffuse\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   p+=N*max(0.,-d+0.001);//avoid self shadow\n   scol*=FuzzyShadow(p,L,1.5,shadowCone,rCoC);//now stop the shadow march at light distance\n   float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   scol=mix(scol,bcol,t/50.);\n   col=mix(col,vec4(scol,min(col.w+alpha,1.)),alpha);//blend in the new color \n }\n fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "sound_code": "#define bps 4.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 5.0; \n  else if(n<3.0)n= -2.0; \n  else if(n<4.0)n= 4.0; \n  else if(n<5.0)n= 7.0; \n  else if(n<6.0)n= 4.0; \n  else if(n<7.0)n= 2.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major +3rd\n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.757,0.001);//silly fm synth instruments \n instr sitar=instr(2.0,.2,8.0,0.0,0.51,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(500.0,.5,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.1252,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.505,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2;\n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.0625)+nofs(b2*0.25)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n2+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   if(mod(i,1.)<1.){\n     a+=I(n0.x+67.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n     a+=I(n0.x+72.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n   }\n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+64.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+60.,time,t1,epiano)*n1.y*.125; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     a+=I(n1.x+24.0,t1/bps+0.008*sin(t1*3.0),t1,bassdrum)*2.0;\n     //a+=I(n2.x+31.0,t1/bps+0.008*sin(t1*2.0),t1,bassdrum)*2.0;\n     \n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+97.0,time+Sin(t2*372.0),t2,stick)*n2.y*.15;\n     \n      // a+=I(96.0,time,t2,stick)*n2.y*.25;\n       \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 452, 485, 485, 624], [625, 675, 709, 709, 963], [977, 977, 996, 996, 2525], [2526, 2526, 2545, 2545, 2598], [2599, 2599, 2617, 2617, 3358], [3360, 3360, 3393, 3455, 3519], [3520, 3520, 3541, 3541, 3635], [3636, 3636, 3677, 3677, 3710], [3794, 3794, 3808, 3896, 3990], [3991, 3991, 4008, 4008, 4075], [4076, 4076, 4157, 4157, 4383], [4384, 4384, 4403, 4403, 4451], [4452, 4452, 4509, 4509, 6341]]}
{"id": "fsffW4", "name": "Valentwine", "author": "Mipmap", "description": "Valentine? Valenline? Valentwine? Happy Valentine's Day.\nColor tweak of \"Lover 2\" by FabriceNeyret2. https://shadertoy.com/view/ssjyWc", "tags": ["heart", "reproduction", "dondeti"], "likes": 6, "viewed": 399, "published": 3, "date": "1644844473", "time_retrieved": "2024-07-30T17:03:34.313399", "image_code": "// Fork of \"Lover 2\" by FabriceNeyret2. https://shadertoy.com/view/ssjyWc\n// 2022-02-14 12:52:00\n\n// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  \n    vec4 bg = vec4(1.000,0.859,0.878,0.0);\n    Q = bg;\n    float c = B( U ).z;\n    if (c > 0.0) \n        Q = vec4(c, 0.0, 0.0, 0.0); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n", "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n#define  k ( .02 * R.x*R.y )\nMain \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    if ( i < k ) {\n    for (float j = -20.; j <= 20.; j++) \n        if (j!=0.) {\n        vec4 a = A(_21(mod(i+j,k)));\n\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n    }\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f -= 100.*d.w*u;\n    }\n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw += f-.03*Q.zw;\n    Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n    Q.zw = mix(Q.zw,m.zw,0.1);\n    Q.xy = mix(Q.xy,m.xy,0.01);\n    if (Q.x>R.x)Q.y=.5*R.y,Q.z=-10.;\n    if (Q.x<0.)Q.y=.5*R.y,Q.z=10.;\n    }\n     if (iFrame < 1 || keyClick(32)) {\n        if ( i > k ) \n          Q = vec4(R+i,0,0); \n        else\n          Q = vec4(.5*R + .25*R.y* cos( 6.28*i/k + vec2(0,1.57)), 0,0 );\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n        for (int y=-1;y<=1;y++) {\n            XY(U,Q,B(U+vec2(x,y)));\n        }\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-6.));\n    XY(U,Q,vec4(Q.x+6.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    \n    float l = sg(U,a1.xy,a2.xy);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    //Q = mix(Q,D(U),.5);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsffW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "sdsBDH", "name": "Dynamic Block Grid", "author": "dr2", "description": "Varying randomly sized mobile blocks", "tags": ["blocks"], "likes": 14, "viewed": 403, "published": 3, "date": "1644835090", "time_retrieved": "2024-07-30T17:03:35.168114", "image_code": "// \"Dynamic Block Grid\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Constant gap between adjacent blocks (full 3D extension of \"Random Rectangular Tiling\",\n// the fixed-width channels were used in, e.g., \"Green Mercury\")\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nvec2 pMid[4], pEdge[4], qcMin, ip;\nfloat tCur, dstFar, eFac, eRound, gSize;\nconst float pi = 3.1415927;\n\n#define H(z) (0.5 + 0.5 * cos (1.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nvoid CellParms ()\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 ee[4];\n  float hp;\n  e = vec3 (-1., 0., 1.);\n  ee[0] = e.xz;\n  ee[1] = e.zz;\n  ee[2] = e.zx;\n  ee[3] = e.xx;\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5) + pEdge[k] * ee[k];\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, bs;\n  vec2 qc;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++) {\n    qc = ip + pMid[k];\n    q.xz = p.xz - gSize * qc;\n    qc = floor (qc);\n    bs.xz = pEdge[k] - eFac + 0.05;\n    bs.y = 0.4 * (bs.x + bs.z) + 0.1 * Hashfv2 (qc);\n    q.y = p.y - gSize * bs.y;\n    d = gSize * PrRound4BoxDf (q / gSize, bs - eRound, eRound);\n    if (d < dMin) {\n      dMin = d;\n      qcMin = qc;\n    }\n  }\n  return dMin;\n}\n\n#if 1\n\nfloat ObjRay (vec3 ro, vec3 rd)  // (cell-based ray-marching)\n{\n  vec3 p, rdi;\n  vec2 fp, ipP;\n  float dHit, d, eps;\n  eps = 0.001;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  dHit = eps;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    fp = p.xz + 0.5;\n    ip = floor (fp / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    d = ObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((gSize * (ip + step (0., rd.xz)) - fp) * rdi.xz)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\n#else\n\nfloat ObjRay (vec3 ro, vec3 rd)  // (simple ray-marching - visual artifacts)\n{\n  vec3 p;\n  vec2 ipP;\n  float dHit, d;\n  dHit = 0.;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    ip = floor ((p.xz + 0.5) / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\n#endif\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 ipP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    ip = floor ((p.xz + 0.5) / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 q, b;\n  float dstObj, dstGrnd, sh, nDotL, s;\n  eFac = 0.2;\n  eRound = 0.2;\n  gSize = 1.;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  if (dstObj < dstFar || rd.y < 0.) {\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (Hashfv2 (qcMin), 0.7, 1.)), 0.2);\n      nDotL = max (dot (vn, ltDir), 0.);\n      nDotL *= nDotL;\n      s = 1.;\n    } else {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      vn = VaryNf (16. * ro, vn, 0.5);\n      col4 = vec4 (0.4, 0.4, 0.4, 0.);\n      ip = floor ((ro.xz + 0.5) / gSize);\n      CellParms ();\n      s = 1.;\n      for (int k = 0; k < 4; k ++) {\n        q = ro.xz - gSize * (ip + pMid[k]);\n        b = pEdge[k] - eFac + 0.1;\n        s = min (s, gSize * PrRound4Box2Df (q / gSize, b - eRound, eRound));\n      }\n      col4 *= 1. + 0.7 * (1. - smoothstep (0.01, 0.02, abs (s)));\n      s = 1.;\n      for (int k = 0; k < 4; k ++) {\n        q = ro.xz - gSize * (ip + pMid[k]);\n        b = pEdge[k] - eFac;\n        s = min (s, gSize * PrRound4Box2Df (q / gSize, b - eRound, eRound));\n      }\n      s = 0.5 + 0.5 * smoothstep (0., 0.02, s - 0.02);\n      nDotL = max (dot (vn, ltDir), 0.);\n    }\n    sh = (dstGrnd <= dstFar) ? min (s, ObjSShadow (ro + 0.01 * vn, ltDir)) : 1.;\n    col = col4.rgb * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 1.;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * sin (0.1 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.12 * pi);\n  ltDir = normalize (vec3 (0.7, 1.5, -1.));\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.07 * tCur, 6., 0.2 * tCur);\n  zmFac = 4.;\n  dstFar = 120.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsBDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[821, 821, 840, 840, 1870], [1872, 1872, 1894, 1894, 2324], [3474, 3474, 3495, 3495, 3750], [3752, 3752, 3789, 3789, 4198], [4200, 4200, 4235, 4235, 5815], [5817, 5817, 5873, 5873, 6599], [6601, 6601, 6648, 6648, 6715], [6717, 6717, 6765, 6765, 6832], [6834, 6834, 6856, 6856, 6883], [6885, 6885, 6921, 6921, 7127], [7129, 7129, 7159, 7159, 7272], [7274, 7274, 7298, 7298, 7415], [7449, 7449, 7473, 7473, 7533], [7535, 7535, 7559, 7559, 7671], [7673, 7673, 7698, 7698, 7884], [7886, 7886, 7915, 7915, 8127], [8129, 8129, 8168, 8168, 8425]]}
{"id": "sdlfDH", "name": "test_heart_214", "author": "nblord", "description": "copy from https://www.shadertoy.com/view/XsfGRn", "tags": ["test"], "likes": 3, "viewed": 219, "published": 3, "date": "1644834927", "time_retrieved": "2024-07-30T17:03:36.025820", "image_code": "// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\t\n    // background color\n    vec3 bcol = vec3(0.1,0.6,0.8-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n    // shape\n\tp.y -= 0.25;\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n\t// color\n\tfloat s = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.4*r;\n\ts = 0.3 + 0.7*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.9*r,0.8)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep( -0.05, 0.05, d-r) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlfDH.jpg", "access": "api", "license": "proprietary-license", "functions": [[668, 668, 725, 725, 1529]]}
{"id": "7dXfDH", "name": "2D Homography", "author": "mla", "description": "A 2D homography (projective transformation of the plane) is determined by 4 points.\n\nMouse: click and drag reference points.\na: highlight reference quadrilateral\nn: show normals\n<up>/down>: zoom\n ", "tags": ["2d", "projective", "homography", "collineation"], "likes": 29, "viewed": 654, "published": 3, "date": "1644829140", "time_retrieved": "2024-07-30T17:03:36.848620", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 2D Homography, Matthew Arcus, mla, 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// A 2D homography (projective transformation of the plane) is\n// determined by 4 points, here the corners of a square texture.\n// Use the mouse to change the mapping - sometimes the texture\n// is split by the line at infinity.\n//\n// Mouse: click and drag reference points.\n// a: highlight reference quadrilateral\n// n: show normals at quadrilateral corners\n// <up>/down>: zoom\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat lwidth = 0.004;\nfloat pwidth = 0.04;\n\n// Map p0,p1,p2,p3 to triangle of reference & unit point,\n// (1,0,0),(0,1,0),(0,0,1),(1,1,1)\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  // Then scale each row so p3 maps to unit point (1,1,1)\n  // Divide by zero can only happen if 3 points collinear\n  vec3 t = 1.0/(m*p3);\n  return mat3(t[0],0,0, 0,t[1],0, 0,0,t[2])*m;\n}\n\nmat3 rproject(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n   return rproject(vec3(p0,1),vec3(p1,1),vec3(p2,1),vec3(p3,1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  setscale();\n  vec2 p = map(fragCoord.xy);\n  float px = fwidth(p.x);\n\n  vec2 p0 = getselection(0);\n  vec2 p1 = getselection(1);\n  vec2 p2 = getselection(2);\n  vec2 p3 = getselection(3);\n  mat3 m = rproject(p0,p1,p2,p3);\n  mat3 n = rproject(vec2(0,0),vec2(0,1),vec2(1,1),vec2(1,0));\n  mat3 t = inverse(n)*m;\n  // t maps screen coords to 'canonical' coords\n  // inverse(t) maps canonical coords to screen coords\n  vec3 uv = t*vec3(p,1);\n  float z = uv.z;\n  uv /= z;\n  // so screen lines are mapped to canonical lines by transpose(inverse(t))\n  // so canonical lines mapped to screen lines by transpose(t)\n  // the normal is just the slope of the line, ie. the xy component:\n  mat3x2 tt = transpose(mat2x3(t));\n  vec2 nx0 = tt*vec3(0,1,0); // Just tt[1] in fact\n  vec2 ny0 = tt*vec3(1,0,0); // Just tt[0] in fact\n  vec2 nx1 = tt*vec3(0,1,-1);\n  vec2 ny1 = tt*vec3(1,0,-1);\n\n  vec3 color = pow(texture(iChannel0,uv.xy).xyz,vec3(2.2));\n  color *= min(2.5*z*z,1.0); // depth fade\n  if (key(CHAR_A) &&\n      !(uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)) {\n     color *= 0.5;\n  }\n\n  float d = segment(p,p0,p1);\n  d = min(d,segment(p,p1,p2));\n  d = min(d,segment(p,p2,p3));\n  d = min(d,segment(p,p3,p0));\n  color = mix(vec3(0.75),color,smoothstep(0.0,px,d-lwidth));\n  if (key(CHAR_N)) {\n    d = 1e8;\n    d = min(d,segment(p,p0,p0+nx0));\n    d = min(d,segment(p,p0,p0+ny0));\n    d = min(d,segment(p,p1,p1+nx1));\n    d = min(d,segment(p,p1,p1+ny0));\n    d = min(d,segment(p,p2,p2+nx1));\n    d = min(d,segment(p,p2,p2+ny1));\n    d = min(d,segment(p,p3,p3+nx0));\n    d = min(d,segment(p,p3,p3+ny1));\n    color = mix(vec3(1,0,0),color,smoothstep(0.0,px,d-0.5*lwidth));\n  }\n  d = distance(p,p0);\n  d = min(d,distance(p,p1));\n  d = min(d,distance(p,p2));\n  d = min(d,distance(p,p3));\n  color = mix(vec3(1),color,smoothstep(0.0,px,d-pwidth));\n  \n  //d = distance(p,p0+nx);\n  //d = min(d,distance(p,p0+ny));\n  //color = mix(vec3(1,0,0),color,smoothstep(0.0,px,d-pwidth));\n  \n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.xyz = vec3(initselection(i-1),1234); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 1.2;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int nselections = 4;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-1,-1);\n  if (i == 1) return vec2(-1,1);\n  if (i == 2) return vec2(1,1);\n  if (i == 3) return vec2(1,-1);\n  return vec2(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nfloat segment(vec2 p, vec2 a, vec2 b, bool doclamp) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  if (doclamp) h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  return segment(p,a,b,false);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return rgb;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 814, 865, 972, 1213], [1215, 1215, 1266, 1266, 1333], [1335, 1335, 1392, 1392, 3459]]}
{"id": "7dlfW8", "name": "loopless convol/filter w. MIPmap", "author": "FabriceNeyret2", "description": "loopless filter:\nGenerates 32x32 imagelets of F1 * F2 with the different offsets, with F1 and F2 two 32x32 images.\nMIPmap level 6 automatically does the sum.\nYou could easily adapt for bigger image * smaller filter.\nClick to see the buffer content.\n", "tags": ["filter", "convolution", "loopless", "gpmipmap"], "likes": 8, "viewed": 354, "published": 3, "date": "1644828775", "time_retrieved": "2024-07-30T17:03:37.687378", "image_code": "// === display result of convolution, or buffer content if click.\n// loop version for comparison: see https://www.shadertoy.com/view/7ssfDH\n\nvoid mainImage( out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n          \n    O = textureLod( iChannel0, vec3(U,1), iMouse.z<=0. ? 6. : 0. );\n    \n    if ( iMouse.z<=0. ) O /= 1.1*textureLod( iChannel0, vec3(0,0,1), 10.).a;\n    // don't put the .a if you want normalization per channel\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// select your images to convolute. or image + filter\n\n//#define F1(U)  vec4(1)\n  #define F1(U)  texture(iChannel2, U )\n//#define F1(U)  texture(iChannel2, clamp(U,0.,1.))\n  \n//#define F2(U)  vec4( smoothstep(.5,0.,  length(U-.5) ) ) // ~Gaussian\n  #define F2(U)  vec4( smoothstep(.25,0., abs( length(U-.5) -.25 ) ) ) // ring\n\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    O-=O;\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;               // like buffA, but 1024 x 1024.\n//  --------------------------------\n\n    vec4 f1 = F1( fract(U/32.) ),\n       //f2 = F2( floor(U/32.)/32.*2.-1. + fract(-U/32.));\n         f2 = F2( fract(U/32.)*2.-1. + 1.-floor(U/32.)/32.);\n    O = f1*f2;                       // convolution contribution\n                                     // sum in MIPmap LOD 6\n                                     \n    O.a = max(O.r, max(O.g,O.b));    // for normalization\n // f2 = F2( fract(U/32.) );\n // O.a = max(f2.r, max(f2.g,f2.b)); // for normalization\n}", "cube_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 180, 180, 469]]}
{"id": "7ssBW8", "name": "Triangle Wave Nebula", "author": "jarble", "description": "Another experiment with triangle wave fractal noise.", "tags": ["fractal"], "likes": 7, "viewed": 227, "published": 3, "date": "1644826346", "time_retrieved": "2024-07-30T17:03:38.516162", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+vec2(0,1.5))*scale)-.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 128.*2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    for(int i=0;i<9;i++)\n    {\n        uv = triangle_wave(uv,scale);\n        uv = triangle_wave(uv.yx,scale)+triangle_wave(uv-.5,scale)+col.x*(uv.x)/2.;\n        col.x = (uv.x+uv.y);\n        col = abs(col.yzx-col);\n    }\n    fragColor = vec4(min(vec3(1.),col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 90], [91, 91, 148, 148, 612]]}
{"id": "7l33Df", "name": "Fork Fork Fork  gchipunov 426", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 1, "viewed": 254, "published": 3, "date": "1644802661", "time_retrieved": "2024-07-30T17:03:39.506514", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.12*clamp(sqrt(exp(iTime)),exp(r1-r2)*0.55,a2+r1+a2*iTime) + (r1-r2)*0.55;\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(fract(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33Df.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 826]]}
{"id": "7lcGWX", "name": "Fork Fork Fork  gchipunov 321", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 184, "published": 3, "date": "1644802651", "time_retrieved": "2024-07-30T17:03:40.341282", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 871]]}
{"id": "7t3GWX", "name": "Fork Fork Fork  gchipunov 110", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 162, "published": 3, "date": "1644802639", "time_retrieved": "2024-07-30T17:03:41.284760", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/2.5 +col/ 5.0 +mix(col3,col2,cos(iTime));//;\ncol5 = col5 + col11/col10;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3GWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 806]]}
{"id": "Ntd3Rs", "name": "Fork Oblivion r gchipunov 585", "author": "gchipunov", "description": "A simple sci-fi radar.", "tags": ["2d", "radar"], "likes": 0, "viewed": 208, "published": 3, "date": "1644802459", "time_retrieved": "2024-07-30T17:03:42.103570", "image_code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define green vec3(0.03,0.969,0.09)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\n\nfloat alien1(vec2 uv, vec2 center)\n{\n    float r = length(uv - (center.xy/2.0));\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    \n    if(sin(iTime)> 0.5)\n    {\n    finalColor += circle3(uv, c, 213.0, 4.0) * blue1;\n    }   \n    \n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n        finalColor += bip2(uv,c+p) * red;\n        \n            p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+17.0)+11.2*iTime);\n        finalColor += bip2(uv,c+p) * blue2;// mathed alien\n        \n            p = 50.0*MOV(9.54,1.7,1.37,1.8,sin(0.5*iTime+17.0)+1.2*iTime);\n        finalColor += alien1(uv,c+p) * green;\n        \n    }\n\n    fragColor = vec4( finalColor, sin(iTime) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 622, 676, 700, 1329], [1331, 1331, 1394, 1394, 1497], [1499, 1499, 1578, 1578, 1788], [1789, 1789, 1853, 1853, 2180], [2182, 2182, 2235, 2235, 2656], [2658, 2658, 2708, 2708, 2902], [2903, 2903, 2951, 2951, 3272], [3273, 3273, 3307, 3307, 3353], [3354, 3354, 3388, 3388, 3612], [3614, 3614, 3650, 3650, 3883], [3885, 3885, 3942, 3942, 5455]]}
{"id": "7t33WX", "name": "Club lights raap 1 gchipunov 439", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 165, "published": 3, "date": "1644802411", "time_retrieved": "2024-07-30T17:03:42.938339", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(500000.0*iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(500000.0*iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(500000.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t33WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 907]]}
{"id": "ft33Wf", "name": "Fork gradiant s gchipunov 842", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 138, "published": 3, "date": "1644802336", "time_retrieved": "2024-07-30T17:03:43.757149", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n\n    // Output to screen\n    fragColor = vec4(col2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 365]]}
{"id": "Nl3GDf", "name": "Fork gredtient  gchipunov 394", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 136, "published": 3, "date": "1644802320", "time_retrieved": "2024-07-30T17:03:44.514125", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\nvec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 518]]}
{"id": "ftc3Wf", "name": "gredtient gchipunov 293", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 134, "published": 3, "date": "1644802267", "time_retrieved": "2024-07-30T17:03:45.510461", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\nvec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 518]]}
{"id": "NsScWt", "name": "Synthwave grid landscape", "author": "nyri0", "description": "More fun synthwave stuff.\nIncrease FSAA if your GPU can handle it. If you're experiencing low framerate, set FSAA to 1 and decrease MAX_ITER.\nSet JUMP to true for more fun.", "tags": ["retro", "synthwave"], "likes": 7, "viewed": 580, "published": 3, "date": "1644797671", "time_retrieved": "2024-07-30T17:03:46.298355", "image_code": "const vec3 BG = vec3(0, 0, 0);\nconst float EPS = 0.001;\nconst float FOVH = 70.0;\nconst float D = 0.1;\nconst float MAX_DIST = 30.0;\nconst int MAX_ITER = 400;\nconst float AMBIENT = 0.1;\nconst int FSAA = 2;\nconst float GRID_DIM = 1.0;\nconst bool JUMP = false;\n\nfloat jTime;\n\n\nfloat sq(float x) {\n    return x*x;\n}\n\n// From https://www.shadertoy.com/view/Msf3WH\nvec2 hashv( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hashv(i+0.0)), dot(b,hashv(i+o)), dot(c,hashv(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// From https://www.shadertoy.com/view/WttXWX\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(vec2 vf) {\n    uint offset = vf.x < 0.0 ? 13u : 0u;\n    uvec2 vi = uvec2(abs(vf));\n    return float(hash(vi.x + (vi.y<<16) + offset)) / float( 0xffffffffU );\n}\n\nfloat vertex_height(vec2 vf) {\n    float offset = - 2.0 + 2.0*smoothstep(5., 8., abs(vf.x));\n    float amplitude = mix(0.5, 2., smoothstep(7., 12., abs(vf.x)));\n    return amplitude * hash(vf) + offset + (JUMP ? 0.2*abs(sin(4.*iTime)) : 0.);\n}\n\n// Adapted from https://www.shadertoy.com/view/tsScRK\nfloat height_and_color_map(vec2 proj){\n    proj /= GRID_DIM;\n    proj.x -= 0.5;\n    vec2 d = fract(proj);\n    proj -= d;\n    bool gd = dot(d,vec2(1))<1.;\n    vec2 pt = proj + (gd ? 0. : 1.);\n    float n2 = vertex_height(proj+vec2(1,0));\n    float n3 = vertex_height(proj+vec2(0,1));\n    float nt = vertex_height(pt);\n    float nmid = mix(n2,n3,d.y);\n    float nv, dx;\n    if(gd) {\n        nv = mix(nt,n3,d.y);\n        dx = d.x/(1.-d.y);\n\t} else {\n        nv = mix(n2,nt,d.y);\n        dx = (1.-d.x)/(d.y);\n\t}\n    return mix(nv,nmid,dx);\n}\n\n\n// Signed distance function that defines the scene.\nfloat sdf(in vec3 pos ) {    \n    return pos.y - height_and_color_map(pos.xz);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec3 cameraPos, in vec3 lookDir, in vec2 screenDim, in vec2 uv,\n                inout vec3 col) {\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookPerH = normalize(cross(lookDir, up));\n    vec3 lookPerV = normalize(cross(-lookDir, lookPerH));\n    vec3 screenCenter = cameraPos + lookDir;\n    vec3 screenPos = screenCenter + 0.5 * screenDim.x * uv.x * lookPerH\n                     + 0.5 * screenDim.y * uv.y * lookPerV;\n    \n    vec3 rayDir = normalize(screenPos - cameraPos);\n    \n    float t = 0.0;\n    float dist;\n    vec3 pos;\n    int iter;\n    do {\n        pos = cameraPos + t * rayDir;\n        dist = sdf(pos);\n        t += 0.5*dist;\n        iter++;\n    } while(iter < MAX_ITER && dist < MAX_DIST && dist > EPS);\n    \n    if(dist <= EPS) {\n        vec3 new_col = vec3(0, 0, 0);\n        \n        vec3 nml = normalize(vec3(\n            dist - sdf(pos - vec3(EPS, 0, 0)),\n            dist - sdf(pos - vec3(0, EPS, 0)),\n            dist - sdf(pos - vec3(0, 0, EPS))\n        ));\n    \n        float dx = mod(pos.x-GRID_DIM/2.0, GRID_DIM);\n        dx = min(dx, GRID_DIM-dx);\n        float dz = mod(pos.z, GRID_DIM);\n        dz = min(dz, GRID_DIM-dz);\n        float col_t = smoothstep(4., 7., abs(pos.x));\n        vec3 col_dark = mix(vec3(0.3, 0, 0.3), vec3(0.1, 0.2, 0.3), col_t);\n        vec3 col_bright = mix(vec3(1., 0.9, 1.), vec3(0.9, 1., 1.), col_t);\n        vec3 lightDir = vec3(0.0, -0.5, 1);\n        new_col = mix(new_col, col_dark, clamp(dot(-lightDir, nml), 0.0, 1.0));\n        new_col = mix(col_bright, new_col, smoothstep(0.02, 0.04, min(dx, dz)));\n        \n        //new_col = mix(new_col, vec3(0,0,0), smoothstep(15., 30., cameraPos.z - pos.z));\n        col = mix(new_col, col, smoothstep(28., 30., cameraPos.z - pos.z));\n    }\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float screenWidth = 2.0 * D * atan(0.5 * FOVH);\n\n    vec3 cameraPos = vec3(0, 0, -2.*iTime);\n    vec3 lookDir = vec3(0, 0, -D);\n    vec2 screenDim = vec2(screenWidth, screenWidth / aspectRatio);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    \n    // Pixel coordinates fixed with correct aspect ratio\n    vec2 uvf = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec3 col = BG;\n    \n    // Stars\n    float noiseVal = noise(60.0 * uvf);\n    float whiteIntensity = smoothstep(0.6, 1.0, noiseVal);\n    col = mix(col, vec3(1,1,1), whiteIntensity);\n    \n    // Sun\n    const vec2 sun_c = vec2(0, 0.25);\n    const float sun_r = 0.4;\n    if(length(uvf-sun_c) < sun_r) {\n        vec3 sun_col = mix(vec3(1, .4, .8), vec3(1, 1, .3), (uv.y-sun_c.y+sun_r)/(2.*sun_r));\n        const float BAND_HEIGHT = 0.02;\n        float dy = mod(uvf.y, BAND_HEIGHT) / BAND_HEIGHT;\n        col = mix(sun_col, vec3(0,0,0), smoothstep(0.25, 0.35, abs(dy-0.5)));\n    }\n    \n    // Grid\n    rayMarcher(cameraPos, lookDir, screenDim, uv, col);\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsScWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 292, 292, 310], [312, 358, 380, 380, 495], [496, 496, 522, 522, 1004], [1006, 1052, 1071, 1071, 1185], [1187, 1187, 1208, 1208, 1357], [1359, 1359, 1389, 1389, 1602], [1604, 1658, 1696, 1696, 2195], [2198, 2250, 2275, 2275, 2330], [2332, 2356, 2472, 2472, 4111], [4113, 4113, 4153, 4153, 5363], [5365, 5365, 5422, 5422, 5679]]}
{"id": "fdsBW8", "name": "triangle neural network", "author": "icantcomeupwithausername", "description": "a simple 4 layer neural network trained on a 28 by 28 image of a triangle, the image is blurry because some float precision was lost during conversion and because the display resolution is much bigger than the training image", "tags": ["triangle", "regression", "neuralnetwork"], "likes": 4, "viewed": 395, "published": 3, "date": "1644795330", "time_retrieved": "2024-07-30T17:03:47.064307", "image_code": "vec3 propogateForward(vec2 uv){\n    //input layer with 2 neurons, linear activation\n    float n1l1 = uv.x * 3.12208 - 1.5857;\n    float n2l1 = uv.y * -2.76058 + 1.48786;\n   \n    //1st hidden layer with 8 neurons, ReLU activation\n    float n1l2 = n1l1 * 0.136199 + n2l1 * 1.34946 + 1.30498;\n    n1l2 = max(0.0, n1l2);\n   \n    float n2l2 = n1l1 * -0.00199323 + n2l1 * 0.802998 + 0.721039;\n    n2l2 = max(0.0, n2l2);\n   \n    float n3l2 = n1l1 * -0.119881 + n2l1 * 0.698856 + 0.598374; \n    n3l2 = max(0.0, n3l2);\n   \n    float n4l2 = n1l1 * 0.0644318 + n2l1 * 0.714568 + 0.557587;\n    n4l2 = max(0.0, n4l2);\n   \n    float n5l2 = n1l1 * -0.141386 + n2l1 * 0.983542 + 1.02368;\n    n3l2 = max(0.0, n5l2);\n   \n    float n6l2 = n1l1 * -1.63856 + n2l1 * 0.98378 + -1.11278;\n    n6l2 = max(0.0, n6l2);\n   \n    float n7l2 = n1l1 * 0.0327053 + n2l1 * 1.14091 + 1.22367;\n    n7l2 = max(0.0, n7l2);\n   \n    float n8l2 = n1l1 * 2.20044 + n2l1 * 1.49318 + -1.50316;\n    n8l2 = max(0.0, n8l2);\n    \n    //2nd hidden layer with 8 neurons, ReLU activation\n    float n1l3 = n1l2 * -0.732157 + n2l2 * -0.891932 + n3l2 * 0.818177 + n4l2 * -0.166244 + n5l2 * 0.504675 + n6l2 * -1.91107 + n7l2 * 0.669006 + n8l2 * -1.33386 + 0.313964; \n    n1l3 = max(0.0, n1l3);\n    \n    float n2l3 = n1l2 * 1.10302 + n2l2 * 0.0999441 + n3l2 * -0.0343741 + n4l2 * -0.833773 + n5l2 * -1.21369 + n6l2 * -0.566044 + n7l2 * 0.452029 + n8l2 * -0.316553 + -0.671326;\n    n2l3 = max(0.0, n2l3);\n    \n    float n3l3 = n1l2 * -0.68761 + n2l2 * 0.847783 + n3l2 * -0.0601765 + n4l2 * 0.124069 + n5l2 * -1.12233 + n6l2 * -0.370512 +  n7l2 * -0.550546 +  n8l2 * -0.344858 + 0.388379;\n    n3l3 = max(0.0, n3l3);\n    \n    float n4l3 = n1l2 * -0.167778 + n2l2 * -0.219596 + n3l2 * -0.412508 + n4l2 * 1.15054 + n5l2 * -0.389043 + n6l2 * 0.0321998 + n7l2 * 0.351151 + n8l2 * -0.321243 + -0.217014;\n    n4l3 = max(0.0, n4l3);\n    \n    float n5l3 = n1l2 * 1.4767 + n2l2 * -0.769722 + n3l2 * 0.0979612 + n4l2 * -0.615703 + n5l2 * 0.271538 + n6l2 * -0.355892 + n7l2 * -1.13254 + n8l2 * -0.873667 + -0.364012;\n    n5l3 = max(0.0, n5l3);\n    \n    float n6l3 = n1l2 * 0.938561 + n2l2 * 0.0767593 + n3l2 * -0.663377 + n4l2 * 0.699145 + n5l2 * -0.647789 + n6l2 * 0.405287 + n7l2 * -0.684911 + n8l2 * -1.21433 + -0.394118;\n    n6l3 = max(0.0, n6l3);\n    \n    float n7l3 = n1l2 * -1.2359 + n2l2 * 0.263993 + n3l2 * 0.306471 + n4l2 * -0.473546 + n5l2 * 0.321738 + n6l2 * -1.39976 + n7l2 * 0.814785 + n8l2 * -0.901326 + 0.281957;\n    n7l3 = max(0.0, n7l3);\n    \n    float n8l3 = n1l2 * 0.306962 + n2l2 * -0.205671 + n3l2 * -0.612426 + n4l2 * -0.404743 + n5l2 * -1.01003 + n6l2 * -0.258058 + n7l2 * 1.05767 + n8l2 * -1.66925 + 0.134617; \n    n8l3 = max(0.0, n8l3);\n    \n    //output layer with 3 neurons, linear activation\n    float n1l4 = n1l3 * 1.32311 + n2l3 * -0.514979 + n3l3 * -0.114528 + n4l3 * -0.573265 + n5l3 * 0.403032 + n6l3 * -0.864705 + n7l3 * -1.39364 + n8l3 * 0.0461393 + -0.00597041;\n    float n2l4 = n1l3 * 0.28029 + n2l3 * -1.01897 + n3l3 * -0.788003 + n4l3 * 0.524296 + n5l3 * -1.16218 + n6l3 * -1.07429 + n7l3 * -0.199235 + n8l3 * 1.59994 + -0.022515;  \n    float n3l4 = n1l3 * 0.274414 + n2l3 * -0.566775 + n3l3 * -0.975647 + n4l3 * -0.787626 + n5l3 * 0.517561 + n6l3 * 0.206326 + n7l3 * 0.841286 + n8l3 * -0.0625629 + 0.0094759;  \n    \n    return vec3(n1l4,n2l4,n3l4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv += vec2(0.5,-0.5);\n    uv.y *= -1.0;\n    \n    if(uv.x < 0.99 && uv.y < 0.94 && uv.y > 0.07 && uv.x > 0.03){\n        fragColor = vec4(propogateForward(uv),1.0);\n    }else{\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 83, 3321], [3323, 3323, 3379, 3379, 3695]]}
{"id": "7sXfDH", "name": "CC0: Follow the light", "author": "mrange", "description": "Result after messing around on sunday night", "tags": ["fractal", "raymarch"], "likes": 19, "viewed": 395, "published": 3, "date": "1644791334", "time_retrieved": "2024-07-30T17:03:47.918024", "image_code": "// License CC0: Follow the light\n// Result after messing around on sunday night\n// Based on an old favorite: https://www.shadertoy.com/view/XsBXWt\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  17.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n\n#define TWISTS\n\n#if defined(TWISTS)\n#define PATHA (0.75*vec2(0.1147, 0.2093))\n#define PATHB (0.5*vec2(13.0, 3.0))\nvec3 cam(float z)  {\n    return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#else\nvec3 cam(float z)  {\n    return vec3(0.0, 0.0, z);\n}\n\nvec3 dcam(float z)  {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 ddcam(float z)  {\n    return vec3(0.0);\n}\n#endif\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p.y-=.25;\n  p.xy*=ROT(radians(30.0));\n  p=p*2.0/clamp(dot(p.xyz,p.xyz),0.24,1.0);\n  return p;\n}\n\nvec3  g_trap0 = vec3(0.0);\n\nfloat rail(vec3 pos) {\n  vec3 tpos =pos;\n  tpos.z    = abs(3.-mod(tpos.z, 6.));\n  vec4 p    = vec4(tpos,1.);\n  \n  vec3 trap0pos = vec3(-2., 0.2, -3.0);\n  vec3 trap0 = vec3(1E6);\n  \n  for (int i=0; i < 4; ++i) {\n    p = formula(p);\n    trap0 = min(trap0, abs(p.xyz-trap0pos));\n  }\n  g_trap0 = trap0;\n  \n  float fr=(length(max(vec3(0.),p.xyz-1.5))-1.0)/p.w;\n\n  return fr;\n}\n\nfloat df(vec3 p) {\n  // Space distortion found somewhere on shadertoy, don't remember where\n  vec3 wrap = cam(p.z);\n  vec3 wrapDeriv = normalize(dcam(p.z));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n#if defined(TWISTS)\n  vec3 ddcam = ddcam(p.z);\n  p.xy *= ROT(-16.0*ddcam.x);\n#endif  \n\n  p.x -= 1.0;\n  p.y = -pabs(p.y, 1.5);\n  p.y -= -1.5;\n\n  float dr = rail(p); \n  return dr;  \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 bgcol  = vec3(2.0, 1.0, 0.75).zyx;\n  vec3 lightPos     = cam(ro.z+10.0);\n  \n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  vec3  trap0 = g_trap0;\n\n  float pulse = smoothstep(0.0, 1.0, sin(TAU*TIME*0.25));\n  float sr    = mix(2.0, 3.0, pulse);\n  float sd    = sphered(ro, rd, vec4(lightPos, sr), t);\n\n  vec3 gcol   = mix(1.0, 1.75, pulse)*sd*sd*bgcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos  = ro + t*rd;\n  vec3 nor  = normal(pos);\n  vec3 refl = reflect(rd, nor);\n  float ii  = float(iter)/float(MAX_RAY_MARCHES);\n  vec3 ld   = normalize(lightPos - pos);\n  float fre = abs(dot(rd, nor));\n  fre *= fre;\n  fre *= fre;\n  float spe = fre*pow(max(dot(refl, ld), 0.), 10.);\n  float fo  = smoothstep(0.9, 0.4, t/MAX_RAY_LENGTH);\n  float ao  = 1.0-ii;\n\n  vec3 col = vec3(0.0);\n  col += pow(smoothstep(0.5, 1.0, trap0.x*0.25)*1.3, mix(6.0, 2.0, pulse))*0.5*bgcol*mix(0.5, 1.6, pulse);\n  col += smoothstep(0.7, 0.6, trap0.z)*smoothstep(0.4, 0.5, trap0.z)*ao*bgcol*mix(0.05, 0.4, pulse);\n  col += spe*bgcol*mix(0.66, 1.5, pulse);\n  col *= 1.0-sd*sd;\n  col *= fo;\n  col += gcol;\n  return col;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME*2.5;\n  \n  vec3 cam  = cam(z);\n  vec3 dcam = dcam(z);\n  vec3 ddcam= ddcam(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*4.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 2.0/tanh(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect3d(p, q);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXfDH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[968, 1068, 1089, 1089, 1162], [1163, 1263, 1285, 1285, 1334], [1336, 1396, 1424, 1444, 1520], [1522, 1605, 1644, 1644, 1733], [1735, 1735, 1765, 1765, 1793], [1795, 1889, 1947, 1947, 2428], [2430, 2500, 2522, 2522, 2661], [2691, 2691, 2713, 2713, 3062], [3064, 3064, 3082, 3155, 3487], [3489, 3489, 3537, 3537, 3732], [3734, 3734, 3757, 3757, 3965], [3967, 3967, 3998, 3998, 5131], [5133, 5133, 5164, 5164, 5528], [5530, 5530, 5585, 5585, 5762]]}
{"id": "7sffW8", "name": "Painted Chars", "author": "VPas", "description": "Try paint 2d chars on rock.", "tags": ["2d"], "likes": 3, "viewed": 240, "published": 3, "date": "1644781735", "time_retrieved": "2024-07-30T17:03:48.679987", "image_code": "const mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat noise(vec2 p) {\n\treturn texture(iChannel2, p / 256.).r;\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = m*p*2.02;\n    f += 0.2500*noise(p); p = m*p*2.03;\n    f += 0.1250*noise(p); p = m*p*2.01;\n    f += 0.0625*noise(p);\n    return f/0.9375 * 2. - 1.;\n}\n\nfloat rect(vec2 p, vec2 hs) {\n    vec2 a = abs(p) - hs;\n    return step(max(a.x, a.y), 0.);\n}\n\nfloat TextSDF(vec2 p, float glyph){ \n\tfloat v = texture(iChannel0, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w;\n    float start = 0.5;\n    float border = 0.003;\n    return smoothstep(start + border, start, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 p = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    \n    vec3 background = texture(iChannel3, p * 0.5 + vec2(0.12, -0.05)).rgb;\n    \n    p *= 1.4;\n    float depth = background.r * 0.299 + background.g * 0.587 + background.b * 0.114;\n    vec3 normal = vec3(dFdx(depth), dFdy(depth), 0.333) * 3.;\n    \n    float number = floor(mod(time, 256.) * 2.);\n    \n    vec2 textureP = (p + vec2(0.5, +0.5));\n    textureP += texture(iChannel1, p).xy * 0.01;\n    \n    vec2 fbm = vec2(fbm4(textureP * 10.), fbm4(textureP * 10. + vec2(13., 7.)));\n    \n    float textAlpha = TextSDF(textureP + fbm * 0.06, number) * rect(p, vec2(0.5));\n    \n    float fbm2 = fbm4(textureP * 10. + vec2(53., 17.)) * 0.2 + 0.8;\n    float depthToBrightness = 0.3 + 1.7 * depth;\n    float lightForNormal = dot(normal, normalize(vec3(0.3, 0.3, 0.9)));\n    vec3 color = vec3(textAlpha * fbm2 * vec3(0.4, 0.85, 0.95) * depthToBrightness * lightForNormal) + background * (1. - textAlpha);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sffW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 64, 64, 106], [108, 108, 128, 128, 326], [328, 328, 357, 357, 421], [423, 423, 458, 458, 654], [656, 656, 713, 713, 1762]]}
{"id": "fsfBD8", "name": "3D Squiggly Things", "author": "SnoopethDuckDuck", "description": "Quite happy with this - very laggy and messy code tho", "tags": ["raymarching", "template", "artofcode"], "likes": 39, "viewed": 694, "published": 3, "date": "1644774145", "time_retrieved": "2024-07-30T17:03:49.704248", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 35.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define pi 3.14159\n\nfloat h21 (float a, float b, float zoom) {\n    a = mod(a, zoom); b = mod(b, zoom);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\n// rand value that changes with val (time usually)\nfloat rand(vec2 ipos, float val) {\n    float a = 2. * pi * h21(ipos);\n    float c = cos(a), s = sin(a);\n    \n    float f = floor(val);\n    \n    // current value (using 0.01 so it looks \"random\" for longer)\n    float v = h21(vec2(c * f, s * f) + 0.01 * ipos);\n    // next value\n    float v2 = h21(vec2(c * (f + 1.), s * (f + 1.)) + 0.01 * ipos);\n    \n    // smooth lerp between values\n    return mix(v, v2, smoothstep(0., 1., fract(val)));\n}\n\nfloat GetDist(vec3 p) {\n    // Rotate xz plane with height + time\n    vec2 uv = p.xz;\n    uv *= Rot(0.28 * p.y - 0.1 * iTime);\n    uv *= 3.;\n    \n    // Cut into grid\n    vec2 ipos = floor(uv) + 0.5;\n    vec2 fpos = uv - ipos;\n    \n    // Rand values\n    float h = h21(ipos);\n    float h2 = rand(ipos, h + 0.2 * iTime);\n    \n    // Each cell rotates with height+time, randomly\n    float time = h * 4. * iTime + p.y * h2 * 9.; // + 2. * pi * h; // dont need offset\n    vec2 q = h2 * 0.1 * vec2(cos(time), sin(time));\n    \n    // Radius of each squiggle (height+time), offset randomly\n    float r = 0.1 * (1. + 0.5 * cos(2. * pi * h + 4. * p.y + iTime));\n    float d = length(fpos - q) - r; \n    \n    // Cut sphere out of squiggles so we can see - smin looks nice\n    float sd = length(p - vec3(0, -3.5, -1.3)) - 0.7;\n\n    // (artifacts appear in furthest tiles if d is larger)\n    d = -smin(-0.35 * d, sd); \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    // (sphere cut-out doesnt follow mouse, but you can still look)\n    vec3 ro = vec3(0, -3.5, -1.3);\n    if (iMouse.z > 0.) {\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        //col = vec3(dif);\n        \n        vec3 rdIn = refract(rd, n, 1./IOR);\n        \n        vec3 pEnter = p - n*SURF_DIST*30.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit);\n        \n        float fresnel = pow(1.+dot(rd, n), 3.);\n        col = 2.5 * vec3(fresnel);\n        \n        // No idea what this does, but I need it\n        col *= 0.55 + 0.45 * cross(nExit, n); \n        \n        //col = clamp(col, 0., 1.); // clamp removes highlighting that I want       \n        \n        // Cylinder length\n        float ln = length(p.xz);\n        \n        // Stripey patterns etc\n        vec3 e = vec3(1.);\n        col *= pal(4.*ln + .05*iTime, e, e, e, \n                   0.5 + 0.5 * thc(3., 20.*p.y + 10.*ln - 8.*iTime) * vec3(0,1,2)/3.);\n        \n        // Darken with height\n        col *= (0.32 * p.y + .95);\n        \n        // Fake shadows (I think)\n        col *= 0.8 + 1. * n.y; \n        \n        // Darken in a cylinder (less aliasy thingies from far away / fake vignette)\n        col *= clamp(1. - 0.3 * ln, 0., 1.);\n        //float val = 0.5 + 0.5 *  thc(4., -0.2 * p.y + 1. * iTime);//clamp(5. + 5. * cos(p.y + iTime), 0., 1.);\n        \n        // Mix col with fres vertically, fake fog\n        fresnel = pow(1.+dot(rd, n), 1.);\n        col = mix(col, vec3(fresnel), clamp(-0.3 + 0.15 * p.y, 0., 1.));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col += 0.04;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 86, 86, 148], [170, 170, 212, 212, 331], [333, 384, 418, 418, 824], [826, 826, 849, 891, 1748], [1750, 1750, 1793, 1793, 2025], [2028, 2028, 2052, 2052, 2242], [2244, 2244, 2294, 2294, 2485], [2487, 2487, 2544, 2544, 4695]]}
{"id": "fdXBWH", "name": "N Tileable Water Caustic", "author": "Mipmap", "description": "Tweak of [url]https://shadertoy.com/view/MdlXz8[/url], made tile number a parameter (TILES)\n\nCheck out the #define to see the tiling.\nSee it full-screen if you can.", "tags": ["water", "caustic"], "likes": 2, "viewed": 226, "published": 3, "date": "1644766763", "time_retrieved": "2024-07-30T17:03:50.606835", "image_code": "// Fork of \"Tileable Water Caustic\" by Dave_Hoskins. https://shadertoy.com/view/MdlXz8\n// 2022-02-13 15:37:46\n\n// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n#define TILING\n#define TILES 16.0\n//#define SHOW_TILING_BORDERS\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef TILING\n\tvec2 p = mod(uv*TAU*TILES, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n\n\t#ifdef SHOW_TILING_BORDERS\n\t// Flash tile borders...\n\tvec2 pixel = TILES / iResolution.xy;\n\tuv *= TILES;\n\tfloat f = floor(mod(iTime*.5, TILES)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n\tfragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 430, 488, 488, 1616]]}
{"id": "sslfz7", "name": "Offset Grid Prism Traversal", "author": "Shane", "description": "A cell by cell traversal of offset rectangular columns. There are also options to traverse hexagon prisms and rectangles on a regular grid.", "tags": ["procedural", "raytracing", "grid", "hexagon", "rectangle", "brick", "traversal", "fly"], "likes": 49, "viewed": 964, "published": 3, "date": "1644757721", "time_retrieved": "2024-07-30T17:03:51.553305", "image_code": "/*\n\n    Offset Grid Prism Traversal\n    ---------------------------\n\n    See Buffer A for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Offset Grid Prism Traversal\n    ---------------------------\n    \n    I wanted to produce a grid traverser that most wouldn't have seen, so \n    here's a grid of towering offset rectangular prisms. So far, all cell\n    by cell traversal tilings on Shadertoy have consisted of edge-to-edge \n    arrangements; The defalt scene here is not. Additionally, I wanted to \n    construct something that could only be raytraced via a cell by cell \n    traversal approach. That is to say, a scene with so much overlap that \n    you couldn't raymarch it on a repeat grid... I wouldn't say raymarching \n    this would be impossible, but I haven't seen it done yet.\n    \n    I've had a glitchy version of this sitting around for a while, but wasn't \n    motivated to fix it and finish it until recently. I'm not a fan of \n    writing traversal code, but like a lot of people, I can write a regular \n    square grid pylon or voxel traverser without too much trouble -- Mostly\n    becaues that was a pretty common coding task back in the 90s, or the \n    olden days, as some of the younger crowd would say. :)\n    \n    Because I was lazy and didn't want to start from scratch, I used IQ's\n    \"Grid of Cylinders\" as a template. There's not much of the original left\n    at this point, but that shader and a few of IQ's other ones were an \n    invaluable reference, which I've listed below. I also referenced a couple\n    of Fizzer's examples.\n    \n    It would have been nice to render a few samples, but I'd imagine slow \n    machines would have a hard enough time rendering this in one sample mode, \n    so I left it alone. However, I did the next best thing and utilized IQ's \n    temporal camera reprojection routine to give the impression that a few \n    samples were taken. I've said this before, but I feel IQ's reprojection\n    code is one of the coolest underutilized pieces of code on here.\n    \n    There's a bit of code here, but not too much. For whatever reason, I got\n    bored and included options to raymarch hexagons and a non offset rectangle\n    option. That complicated things a bit, but if you were to traverse just a\n    single grid, the code size and entanglement would drop considerably.\n    \n    I plan to put up some more interesting traversals later. By the way, if\n    you're interested in less common 3D traversals, Fizzer's work is definitely \n    worth looking at.\n    \n    \n    References:\n    \n    // Raymarching inside of traversed cells. Very cool, and I intend to\n    // make use of it at some stage. In fact, I used it as a template for \n    // the example you're looking at, then proceeded to overwrite almost \n    // all of it. However, I did keep a couple of cool lighting snippets \n    // and variable names. :)\n    Grid of Cylinders - iq\n    https://www.shadertoy.com/view/4dSGW1\n    \n    // IQ's 3D hexagonal traverser: It's beautifully rendered and the \n    // traversal code leaves very little room for improvement.\n    Hexagonal Grid Traversal - 3D -- iq\n    https://www.shadertoy.com/view/WtSfWK\n    \n    // I like the traversal code on this. When producing a single traverser of\n    // a tiled plane with joining neighboring vertex points, this is the method\n    // I'll be using.\n    Triangle Grid Traversal - fizzer\n    https://www.shadertoy.com/view/WtBfDd\n    \n    // A rough 2D version of this that is much easier to consume. If \n    // you can understand the following, then this will make more sense.\n    Offset Grid Traversal - Shane\n    https://www.shadertoy.com/view/fdScWd\n    \n    \n    \n*/\n\n// Maximum distance.\n#define FAR 1e8\n\n// Make use of IQ's well written temporal reprojection code. Unfortunately, \n// if you have a slow machine, all you'll see is blur, so you'll need\n// to turn it off.\n#define REPROJECTION\n\n\n// Hexagon option. \n//#define HEXAGON\n\n// Offset grid rows.\n#define OFFSET\n\n// Hexgons must have an offset defined.\n#ifdef HEXAGON\n#ifndef OFFSET\n#define OFFSET\n#endif\n#endif\n\n#define sqrt3 1.7320508 // sqrt(3.).\n\n// Scale.\n#ifdef HEXAGON\n// Hexagons will only work with the \"1 to sqrt3\" ratio -- Scaling is fine though. \n// At some stage, I'll arrange for anything to work, but it's not trivial.\nconst vec2 s = vec2(1, sqrt3)*1.5; \n#else\n// Rectangle dimensions. Any numbers should work. Obviously, vec2(1)\n// will produce squares.\nconst vec2 s = vec2(1.5, 1); \n#endif\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n \n// IQ's vec2 to float hash function.\nfloat hash21(vec2 p) { return fract(sin(dot(p, vec2(1 , 113)))*43758.5453123); }\n \n\n// The path is a 2D sinusoid that varies over time, which depends upon the \n// frequencies and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2((cos(z*.36/8.)*1. - sin(z*.2/8.)*1.2)*6., sin(z*.12/2.)*3.);\n} \n\n\n// The height function.\nfloat map(vec2 p){ \n    \n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy).xyz;  tx *= tx;\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = min(f, .44); // Ground noise, so it doesn't look too flat.\n    \n    // Using the camera path to carve out a channel for the camera to glide through.\n    vec2 pth = path(p.y);\n    float pX = abs(p.x - pth.x); // The channel.\n    f *= clamp(pX*pX/24., 0., 1.); // Carving it out.\n    \n    // Returning the terrain and ground noise, then adding the undulating camera\n    // height to keep the ground close to the viewer for that rollercoaster feel. :)\n\treturn f*40. + f2*14. + pth.y;\n}\n\n// Sign function without the zero, which can cause problems for some routines.\nvec3 sign2(in vec3 p){ return vec3(p.x<0.? -1 : 1, p.y<0.? -1 : 1,  p.z<0.? -1 : 1); }\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n \n\n// Grid cell function.\nvec2 gridID(vec2 p){\n\n    \n    // Returns the cell center position-based IDs for a hexagon \n    // grid, offset rectangle grid and regular rectangle grid.\n\n    #ifdef HEXAGON\n    \n    // Hexagons.  \n    //\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, sqrt3/3.))) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? hC.xy : hC.zw + .5;\n    \n    #else\n    \n    // Rectangles.   \n    //    \n    #ifdef OFFSET\n    // Rectangles with an offset. \n    vec2 idOff = vec2(0);\n    if(mod(floor(p.y/s.y), 2.)>.5){\n       p.x -= s.x/2.;\n       idOff.x += .5;\n    }\n    vec2 ip = floor(p/s) + .5;\n    //p -= (ip)*s;\n    return ip + idOff;\n    #else\n    // Rectangles with no offset. \n    vec2 ip = floor(p/s) + .5;\n    //p -= (ip)*s;\n    return ip;\n    #endif    \n    \n    #endif\n  \n}\n\n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n\n    // Normally, there'd be more checks, but the boundary lines \n    // have been chosen such that a hit will always occur.    \n    float s = dot(p - ro, n)/dot(rd, n);\n    return s<0. ? 1e8 : s;\n}\n*/\n\n// Ray origin, point on the line, normal. \nfloat rayLineF(vec2 ro, vec2 p, vec2 n){\n\n    // Normally, there'd be more checks, but the boundary lines \n    // have been chosen such that a hit will always occur.    \n    return dot(p - ro, n);\n    \n}\n\n \n// Cell by cell prism traversal: It is literally the same as 2D traversal,\n// but you're testing for a top plane hit as well. That's explained below.\n// There are three sets of tile traversals here. All are regular and monohedral,\n// and two are edge-to-edge. The offset retangles are not edge-to-edge, so need \n// to be handled differently.\nvec4 raycast( in vec3 ro, in vec3 rd ){\n\n    // Result, unit vector directions, and initial postion.\n    vec4 res = vec4(1e8); // Distance, face ID and cell ID.\n    vec3 srd = sign2(rd); \n    vec3 pos3 = ro; \n    \n    \n    \n    #ifdef HEXAGON\n    // Hexagon edge normals -- Only three faces and the top can be hit by the ray.\n    // Any three normals will do.\n    vec3 i1 = vec3(.5, 0, .5); // Right forward face index.\n    vec3 i2 = vec3(1, 0, 0); // Right face index.\n    vec3 i3 = vec3(-.5, 0, .5); // Left forward face index.\n    vec3 n1 = vec3(.5, 0, sqrt3/2.); // Right forward.\n    vec3 n2 = vec3(1, 0, 0); // Right face normal.\n    vec3 n3 = vec3(-.5, 0, sqrt3/2.); // Left forward.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n\n    // Back face selection: When the ray swings in the direction of the \n    // back face, use the opposing index and normal. You can only use this\n    // trick when there's... opposing face symmetry involved. Although, with \n    // an assymetric polygon, you'll still want to check this to avoid doing\n    // the ray face distance calculation.\n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz);\n    float d3 = dot(rd.xz, n3.xz); \n    // As discussed above.\n    if(d1<0.) { i1 *= -1.; n1 *= -1.; }\n    if(d2<0.) { i2 *= -1.; n2 *= -1.; }\n    if(d3<0.) { i3 *= -1.; n3 *= -1.; }\n    \n    vec3 invN = -1./vec3(dot(rd, n1), dot(rd, n2), dot(rd, n3));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec3 t;\n\n    #else\n    // Square edge normals -- Only two faces and the top can be hit by the ray.\n    // Any two normals will do. Indexes and normals are the same, in this case.\n    vec3 n1 = vec3(1, 0, 0); // Right face normal.\n    vec3 n2 = vec3(0, 0, 1); // Forward (or back) face normal.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n    \n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz); \n\n    if(d1<0.) n1 *= -1.;\n    if(d2<0.) n2 *= -1.;\n    \n    vec2 invN = -1./vec2(dot(rd, n1), dot(rd, n2));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec2 t;\n    \n    #endif\n    \n\n    \n    \n    // Minimum top plane distance.\n    float tT;\n    \n    // Minimum plane difference, and total distance.\n    float mint = 0.;// dist = 0.;\n     \n    // Plane hit. The default is no hit.\n    int hit = 0;\n    \n    vec2 ip = gridID(pos3.xz);\n    \n    for(int i = 0; i<160; i++){\n       \n         \n        res.zw = ip*s;\n        float ma = map(res.zw); \n         \n        \n        // At this point, we haven't advanced the ray to the back of the cell boundary,\n        // so we're at one of the front cell face positions. Therefore, check to see if \n        // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n        // then break.\n        if(pos3.y<ma){\n            // Hit a side.\n            hit = 1;\n            break; \n        \n        } \n             \n        #ifdef HEXAGON        \n        // Hexagon.\n        // Ray origin, ray direction, point on the line, normal.\n        // Side face distances.\n        t.x = rayLineF(pos3.xz, res.zw + i1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, res.zw + i2.xz*s*.5, -n2.xz);\n        t.z = rayLineF(pos3.xz, res.zw + i3.xz*s*.5, -n3.xz);\n        \n        t *= invN;\n        \n        mint = min(min(t.x, t.y), t.z);   \n        \n        // Normal selection, but not needed here.\n        //vec3 n = t.x>t.y && t.x<t.z? n1 : t.y<t.z? n2 : n3;\n    \n        #else\n        \n        // Square.\n        // Ray origin, ray direction, point on the line, normal. \n        // Side face distances.\n        t.x = rayLineF(pos3.xz, res.zw + n1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, res.zw + n2.xz*s*.5, -n2.xz);\n       \n        t *= invN;\n \n        mint = min(t.x, t.y);\n        \n        // Normal selection, but not needed here.\n        //vec3 n = t.x<t.y? n1 : n2;\n \n        #endif\n        \n        // Top face distance.\n        tT = (ma - pos3.y)/(rd.y);\n        tT = tT<0. ? 1e8 : tT;\n        \n        \n        // We've now advanced to one of the back faces of the cell. Check to see whether\n        // we're still under the pylon height, and if so, we've hit the top face --  \n        // I always have to think about this, but the logic is that we haven't hit a front\n        // cell face and we're still under the height, so we've hit the top. Anyway, mark \n        // the top face as hit, advance the distance in the Y direction to the top face, \n        // then break.\n        if(tT<mint){\n            \n            //dist += tT;\n            pos3 += rd*tT; \n            hit = 2;\n            break;\n             \n        }      \n\n         \n         // Top plane, early exit.\n         //if(pos3.y>60.) { dist = 1e8; break; }\n         \n        \n         // Adding the minimum distance.\n         //dist += mint;\n         // Updating the position.\n         pos3 += rd*mint; \n         \n         // For hexagon and non offset rectangles, and other tilings where all vertices\n         // are shared by neighbors, you should call this once (outside the loop), then \n         // add the index relating to the shortest side. However, for offset rectangles, \n         // this isn't the case, so we call it every iteration. Having said that, it's \n         // not a hugely expensive operation and there's no face normal selection, so\n         // all in all, this isn't too bad at all.\n         ip = gridID(pos3.xz + srd.xz*.001);\n    \n    } \n    \n     \n    if(hit>0){\n\n        // Flag a top hit for use in normal calculations.\n        // The prism sides are calculated via polar angles.\n        res.y = hit == 2? 0. : 1.; \n        /*\n        // Face ID, to determine normals.\n        #ifdef HEXAGON        \n        res.y = t.x<t.y && t.x<t.z && t.x<tT? 1. : t.y<t.z && t.y<tT? 2. : t.z<tT? 3. : 0.;\n        if(res.y == 1. && d1<0.) res.y *= -1.;\n        if(res.y == 2. && d2<0.) res.y *= -1.;\n        if(res.y == 3. && d3<0.) res.y *= -1.;\n        #else\n        res.y = t.x<t.y && t.x<tT? 1. : t.y<tT? 2. : 0.;      \n        if(res.y == 1. && d1<0.) res.y *= -1.;\n        if(res.y == 2. && d2<0.) res.y *= -1.;\n        #endif\n        */\n        \n        res.x = length(pos3 -  ro);\n       \n    }\n    else {\n    \n        // If we don't record a hit, max out the distance.\n        res.x = 1e8;\n        //res.y = -1e8;\n    }\n  \n    // Return the distance, the faceID and the cell ID.\n    return res; // length(ro - pos3) \n    \n}    \n  \n\n \n  \n\n// Cell by cell prism traversal for shadows:\nfloat castShadowRay(in vec3 ro, in vec3 rd){\n\n    // Unit ray direction vector and initial position.\n    vec3 srd = sign2(rd);\n    vec3 pos3 = ro;\n    \n    \n    #ifdef HEXAGON\n    // Hexagon edge normals -- Only three faces and the top can be hit by the ray.\n    // Any three normals will do.\n    vec3 i1 = vec3(.5, 0, .5); // Right forward face index.\n    vec3 i2 = vec3(1, 0, 0); // Right face index.\n    vec3 i3 = vec3(-.5, 0, .5); // Left forward face index.\n    vec3 n1 = vec3(.5, 0, sqrt3/2.); // Right forward.\n    vec3 n2 = vec3(1, 0, 0); // Right face normal.\n    vec3 n3 = vec3(-.5, 0, sqrt3/2.); // Left forward.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n\n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz);\n    float d3 = dot(rd.xz, n3.xz); \n\n    if(d1<0.) { i1 *= -1.; n1 *= -1.; }\n    if(d2<0.) { i2 *= -1.; n2 *= -1.; }\n    if(d3<0.) { i3 *= -1.; n3 *= -1.; }\n    \n    vec3 invN = -1./vec3(dot(rd, n1), dot(rd, n2), dot(rd, n3));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec3 t;\n\n    #else\n    // Square edge normals -- Only two faces and the top can be hit by the ray.\n    // Any two normals will do. Indexes and normals are the same, in this case.\n    vec3 n1 = vec3(1, 0, 0); // Right face normal.\n    vec3 n2 = vec3(0, 0, 1); // Forward (or back) face normal.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n    \n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz); \n\n    if(d1<0.) n1 *= -1.;\n    if(d2<0.) n2 *= -1.;\n    \n    vec2 invN = -1./vec2(dot(rd, n1), dot(rd, n2));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec2 t;\n    \n    #endif\n    \n \n    float mint = 0.; \n    \n    // Result: Shadowed or not.\n    float res = 1.;\n    \n    vec2 ip = gridID(pos3.xz);\n    \n    \n    for(int i = 0; i<64; i++){\n       \n        vec2 id = ip*s; \n        \n        float ma = map(id);  \n\n        if(pos3.y<ma){\n            // Hit a side.\n            res = 0.;\n            break; \n        \n        }\n        \n        #ifdef HEXAGON        \n        // Hexagon.\n        // Ray origin, ray direction, point on the line, normal. \n        t.x = rayLineF(pos3.xz, id + i1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, id + i2.xz*s*.5, -n2.xz);\n        t.z = rayLineF(pos3.xz, id + i3.xz*s*.5, -n3.xz);\n        \n        t *= invN;\n \n        mint = min(min(t.x, t.y), t.z); \n        \n        #else\n        \n        // Square.\n        // Ray origin, ray direction, point on the line, normal. \n        t.x = rayLineF(pos3.xz, id + n1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, id + n2.xz*s*.5, -n2.xz);\n \n        t *= invN;\n        \n        mint = min(t.x, t.y);\n        \n        #endif\n        \n        // Top plane distance.\n        float tT = (ma - pos3.y)/(rd.y);\n        tT = tT<0. ? 1e8 : tT; \n     \n        // Top plane hit.\n        if(tT<mint){\n         \n            // Hit the top.\n            res = 0.;\n            break;\n        }  \n\n        // Top plane, early exit.\n        //if(pos3.y>60.){ dist = 1e8; break; }\n         \n      \n        pos3 += rd*mint; \n        \n        ip = gridID(pos3.xz + srd.xz*.001);\n    \n    }    \n \n    return res;\n}    \n  \n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better one than this somewhere. \nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    #ifdef REPROJECTION\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    float resT = 1e8;\n    #endif\n\n    // Screen coordinates: The coordinates are already in one to one ratio form, so \n    // a simple translation and scaling is all that is necessary in this setting.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Experiment involving random jittering: Visually speaking, it's better in some \n    // ways and worse in others. There are always trade offs with cheaper effects.\n    //vec2 tm = fract(iTime*vec2(.01327, .02183));\n    //uv += (vec2(hash21(uv + tm.x), hash21(uv + tm.y)) - .5)/2./iResolution.y;\n    \n    \n    // Lens warping -- Needs to be performed camera side to work with\n    // temporal reprojection, but I've forgotten how... I'll look at one\n    // of Dr2's examples at some stage to see how it's done.\n    //uv *= 1. + dot(uv, uv)*.2;\n    \n \n    // Ray origin.\n    vec3 ro = vec3(0, 7, iTime*8.);\n    \n    \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(0, -.0, 1.);//vec3(0, -.25, iTime);  \n \n    \n\t// Sending the camera and \"look at\" vectors along the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n\n    vec3 fwd = normalize(lk - ro);    \n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    \n    // Camera movement. Rotation, swivle, etc.\n    mCam *= rot(vec3(-path(ro.z).x/32., 0, 0)); // Camera roll.\n    //mCam *= rot(vec3(0, 0, iTime/4.)); // Camera pitch.\n    \n    // Unit direction ray.\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n \n    // Directional light.\n    vec3 ld = normalize(vec3(.2, .7, .8)); \n    \n    \n    // Sky function, based on one of IQ's simple snippets. \t\n    float sun = clamp(dot(rd, ld), 0., 1.);\n    vec3 sky = mix(vec3(1, .75, .6), vec3(1, .75, .6).xzy, max(rd.y, 0.)*.5);\n    sky += .3*pow(sun, 4.);\n    \n    // Scene function, initially set to the sky.\n    vec3 col = sky;\n\n    // Raycasting.\n    vec4 res = raycast( ro, rd );\n    vec2 cellID = res.zw;\n    float ry = res.y;\n    float t = res.x;\n    \n    // If we've hit the scene geometry, render it.\n    if(t<1e8 - 1e-4){\n    \n    \n        // 3D surface postion.\n        vec3 pos = ro + rd*t;\n        float rnd = hash21(cellID + .04);\n        \n        // Local 2D cell face coordinates -- Centered at vec2(0).\n        vec2 lP = pos.xz - cellID;\n        \n        // Cell height.\n        float h = map(cellID);\n        \n        #ifdef REPROJECTION\n        // Only save the initial hit point and \n        // distance. Ignore other bounces.\n        resPos = pos;\n        resT = t;\n        #endif\n        \n       \n         \n        \n        #ifdef HEXAGON\n        const float aNum = 6.;\n        #else\n        const float aNum = 4.;\n        #endif\n         \n        \n        // Normal and texture UV coordinates. You should do this via face\n        // identification in your raycasting function, but I was curious\n        // to see if could be done this way. You can, but I wouldn't advise\n        // it. I'll update this with something easier to read later.\n        //\n        // Top facing.\n        vec3 nor = vec3(0, 1, 0);\n        vec2 tuv = pos.xz - hash21(cellID + .2 + h)*8.;// - vos;\n\n        if(abs(res.y)>.01){\n        \n           vec2 qq = lP; // Centered 2D cell face coordinates.\n           \n           #ifdef HEXAGON\n           qq *= rot2(-3.14159/aNum); \n           // Prism side angle matrix, relative to the center.\n           float aa = (floor(atan(qq.y, qq.x)/6.2831*aNum) + .5)/aNum;\n           mat2 mR = rot2(-aa*6.2831);\n           // Right plane, then rotate.\n           nor.xz = mR*vec2(1, 0);\n           nor.y = 0.;\n           \n            // UV coordinates.\n           // The X coordinate is the local XZ coordinates dotted with the \n           // face normal. There are other ways to do this, but that's the \n           // easist way. The Y coordinate is just the Y position.\n           tuv = vec2(dot((lP), nor.xz), pos.y);\n           // Adjusting the UV by the height and a random figure for some \n           // cell face texture variance. \n           tuv -= vec2(hash21(cellID + aa + .1), h);\n           \n           \n           // Rotating the normal back to the center.\n           nor.xz *= rot2(3.14159/aNum);\n           #else\n           \n           float aa;\n           if(dot(qq, s.yx)<0.) {\n               if(dot(qq, s.yx*vec2(1, -1))<0.){ nor = vec3(-1, 0, 0); aa = 0.; tuv.x = qq.y; }\n               else{ nor = vec3(0, 0, -1); aa = 1.; tuv.x = qq.x; }\n           }\n           else {\n               if(dot(qq, s.yx*vec2(1, -1))>0.){  nor = vec3(1, 0, 0); aa = 2.; tuv.x = qq.y; }\n               else{ nor = vec3(0, 0, 1); aa = 3.; tuv.x = qq.x; }\n           }\n           \n           tuv.y = pos.y;\n           \n           //tuv = vec2(dot((pos.xz - vos), nor.xz*rot2(3.14159/aNum)), pos.y);\n           tuv -= vec2(hash21(cellID + aa + .1), h);\n           #endif\n           \n           \n        }\n        \n        \n          \n\n        // Object color.\t\n        vec3 objCol = .5 + .45*sin(rnd*6.2831/6. + vec3(0, 1, 2)/3. + 2.);\n\n        // Applying some texture.\n        vec3 tx = texture(iChannel1, rot2(-3.14159/6.)*tuv/4. + h).xyz; tx *= tx;\n        vec3 tx2 = texture(iChannel1, rot2(3.14159/3.)*tuv/2. + .33).xyz; tx2 *= tx2;\n        tx = mix(tx, tx2, .5);\n        objCol *= .35 + tx*1.5;\n     \n        \n        // Very rough ambient occlusion. It's designed to give the feel of AO,\n        // but it won't be winning any awards, that's for sure. :)\n        float occ = 1.;//   + nor.y*.5; // Occlusion.\n        float ds = 1.; // Analogous to sample spread. // .01*t           \n        float k = .3;//.05/ds;  // Intensity.\n        float dst = ds*1.; // Initial distance.          \n\n        for(int i = 0; i<4; i++){\n            //vec2 oCoord = pos.xz + nor.xz*dst;\n            //vec2 ps = mix(oCoord, gridID(oCoord)*s, .5);\n             float hn = map(pos.xz + nor.xz*dst);\n             //float hn = map(mix(vos, pos.xz, .5) + nor.xz*dst);\n             //float hn = map(gridID(pos.xz + nor.xz*dst)*s);\n             occ -= (dst - max(pos.y + nor.y*dst  - hn, 0.))*k;//*smoothstep(-1., 1., h - hn);\n             dst += ds;\n             k *= .5;\n        }\n        \n        occ = clamp(occ, 0., 1.);\n       \n        // This is a left over line from IQ's cylinder traversal example that I\n        // forgot to take out until after the coloring was done, so it's here to stay. :)\n        // If you were to attribute some science to it, buildings would be more shadowy\n        // at ground level... Yeah, I'm not convinced either. :D\n        occ *= pow(clamp((pos.y + .01)/(h + .01), 0., 1.), 2.);\n        // Manipulating for whatever shade we're after. \n        occ = mix(occ, occ*occ, .5)*.8 + .2;\n     \n        // Lighting.\n \n  \n        // Diffuse lighting term.\n        float dif = max(dot(nor, ld), 0.);\n        \n        // Shadows.\n        //\n        // Old fashioned hard shadows. Not as nice as soft ones, but still appreciated. :) \n        // Actually, if you were path tracing, then soft shadows would be the result anyway.\n        // You could also blur these on a separate buffer then reintegrate.\n        float shad = 0.;\n        if(dif>0.){ shad = castShadowRay(pos + nor*1e-3, ld); }\n\n        \n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some silhouette lighting.\n        float rim = pow(clamp(1. + dot(rd, nor), 0., 1.), 5.);\n        \n         \n        // Specular reflection. \n        float spe = pow(clamp(dot(ld, reflect(rd, nor)), 0., 1.), 4.);\n        \n\n        // Putting the above terms together. \n        col = objCol*(dif*shad + .5 + vec3(2, .4, .3)*spe*shad + sky*rim*2.);\n \n        \n        col *= occ;\n        \n        \n         \n        \n        #ifdef HEXAGON\n        float shape = max(abs(lP.y)*.8660254 + abs(lP.x)*.5, abs(lP.x)) - s.x/2.;\n        #else\n        vec2 aLP = abs(lP) - s/2.;\n        float shape = max(aLP.x, aLP.y);\n        #endif\n        \n        // Top face edge height.\n        float edgeY = pos.y - h;\n        \n        // Shape edge.\n        float shapeEdge = abs(shape);\n        shapeEdge = abs(shapeEdge - edgeY) - .03;\n    \n       \n        #ifdef HEXAGON\n        // Hexagon vertical edges.\n        // Lines eminating from the center to the vertices.\n        vec2 p = rot2(3.14159/aNum)*lP; \n        float a = mod(atan(p.x, p.y), 6.2831)/6.2831;\n        a = (floor(a*aNum) + .5)/aNum;\n        p *= rot2(a*6.2831);\n        float edge = abs(p.x) - .02; \n        #else\n        vec2 p = lP;\n        // Square vertical edges. Much easier. :)\n        float edge = -min(abs(p.x) + .04 - s.x/2., abs(p.y) + .04 - s.y/2.);\n        #endif\n         \n        // Chop out the inside face lines... I'm making this up as\n        // I go along. I'll tidy it up later.  :) \n        edge = max(edge, -(shape + .02));\n\n      \n        // Combining the top face edge with the side edges.\n        edge = min(edge, shapeEdge);\n\n\n        // Cheap reflective pass. A full reflective pass would be nicer, but\n        // this is the next best thing. Trace out from the hit point along\n        // the direction ray. If we hit the scene, add nothing, but if we\n        // hit the sky, index into a sky-looking cube map. Not perfect, but\n        // any stretch, but it gives a pretty cool reflective pass glow.\n \n        vec3 refl = reflect(rd, nor);\n        float resRef = castShadowRay(pos + nor*2e-3, refl);\n        //t = resRef.x;\n\n        vec3 refTex = textureLod(iChannel2, refl, 0.).rgb; refTex *= refTex;\n    \n        //float rsun = clamp(dot(refl, ld), 0., 1.);\n        //vec3 rsky =  mix(vec3(1, .75, .6), vec3(1, .75, .6).xzy, max(rd.y, 0.)*.5);\n        //rsky = (rsky + .3*pow(rsun, 4.));\n        vec3 spec = resRef<.5? vec3(0) : refTex*4. ;\n\n        float fr = mix(.03, .25, pow(max(0., 1. + dot(rd, nor)), 3.));\n\n        col = mix(col, spec, fr);\n \n        // Occlusion debug.\n        //col = vec3(occ);\n         \n       \n      \n        // Applying edges at the end.\n        float sf = 3./450.*(1.35 + t*t*.005);\n        col = mix(col, col*1.8, (1. - smoothstep(0., sf, edge - .05))); \n        col = mix(col, col*.1, (1. - smoothstep(0., sf, edge))); \n    \n  \n\n        // Fogging out to the horizon..\n        col = mix( col, sky, smoothstep(0., 1., t*t/140./140.));\n        //col = mix(sky, col, exp(-t*t/120./120.)); // Alternative.\n         \n    }\n    \n    // Another one of IQ's touches that I like. Running a small portion of sunlight\n    // over the whole scene for a little extra scattering.\n    col += pow(sun, 8.)*.08;\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col = clamp(col, 0., 1.)*pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    \n\n\n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #ifdef REPROJECTION\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel3, ivec2(0, 0), 0),\n                           texelFetch(iChannel3, ivec2(1, 0), 0),\n                           texelFetch(iChannel3, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z;//*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod( iChannel3, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./4.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], ro));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], ro));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], ro));\n    } \n    #else\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    //vec4 preCol = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    //float blend = (iFrame < 2) ? 1. : 1./8.; \n    //fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    fragColor = vec4(max(col, 0.), 1);\n    #endif\n    \n     \n    //fragColor = vec4(max(col, 0.), 1);\n}", "buffer_a_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 169, 245, 484]]}
{"id": "7dlfDn", "name": "cap with max boolean", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["primitive"], "likes": 3, "viewed": 226, "published": 3, "date": "1644742819", "time_retrieved": "2024-07-30T17:03:52.306291", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat map(vec3 p){\n    p.xy*=rot(iTime*1.);\n    p.xz*=rot(iTime*1.);\n    // This is a 2D SDF to 3D trick.\n    // 1. Calculate 2D SDF\n    float sdf2d=abs(length(p.xy)-1.)-.2;\n    // 2. Calculate 1D SDF\n    float d=abs(p.z)-.3;\n    // 3. Combie them by max(boolean)\n    return max(sdf2d,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-3);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 93, 93, 283], [285, 285, 303, 303, 575], [577, 577, 634, 634, 854]]}
{"id": "7dsBDn", "name": "hexagon test 2022 2 13", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["primitive"], "likes": 3, "viewed": 259, "published": 3, "date": "1644741908", "time_retrieved": "2024-07-30T17:03:53.057283", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat map(vec3 p){\n    p.xy*=rot(iTime*.5);\n    p.xz*=rot(iTime*.3);\n    float sdf2d=sdHexagon(p.xy,.8);\n    return sdHexagon(vec2(sdf2d,p.z),.3);\n    // return length(vec2(sdf2d,p.z)) - .3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-3);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 93, 93, 283], [285, 285, 303, 303, 477], [479, 479, 536, 536, 756]]}
{"id": "sssBDn", "name": "Voxel Glitch", "author": "lambmeow", "description": "This an attempt to create a voxel environment. It looks like the more I increase the size of the y value of the voxel, the more distorted it gets. ill have to look into it a little more", "tags": ["sdf", "beat", "voxel", "fail", "type"], "likes": 9, "viewed": 462, "published": 3, "date": "1644741901", "time_retrieved": "2024-07-30T17:03:53.873102", "image_code": "//voxel glitch\n//lambmeow 2/13/22\n//Thanks for UnstableLobster + Shane for a fix to my voxel issue!\n\n//we can also just move ss to the mainImage but eh...\nfloat h;\nfloat ss(vec3 v)\n{   \n    vec2 iv = floor(v.xz );\n    float z= v.z;\n    //v.xy *= rot(mod((z/600.), 2.* 3.141529)) * 2.;\n    v.xz = fract (v.xz);\n\n    v.xz-= vec2(0.5,1);\n    \n    vec3 u = texture(iChannel0, iv/200.).grb * 5.;\n    \n    \n    vec3 b = abs(v) - vec3(.45, sin(iTime + u.x) * u.y/2. + u.y/2., .45);\n    h = b.y;\n    return length(max(b,0.)) + min (max(b.x, max(b.y, b.z)), 0.);\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    float a = iTime* 0.3;\n    u *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    u.y = -abs(u.y);\n    vec3 ro = vec3(0, 10, -10. + iTime * 25.), rd = normalize(vec3(u, 2.)), pp = ro;\n    float dd = 0., ll = 0.;\n    \n    for(int i = 0; i < 255; i++)\n    {\n       pp = ro+rd * ll;\n       //quick fix\n       dd = ss(pp);\n       ll +=dd * 0.1;\n       if(ll > 350. || dd < 0.001)\n           break;\n    }\n    \n    \n    // Output to screen\n    vec3 ff = vec3(0.3,.0,.2);\n    float atten = 1./(1. + ll * .025) * max(1.-dd,0.);\n    atten *= smoothstep(0.,1., 1.+ h) + .45;\n    \n     c = texture(iChannel0, floor(pp.xz)/200.) * atten + vec4(ff,1.) * (1.- atten);\n     \n    }", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 182, 182, 555], [558, 558, 599, 649, 1362]]}
{"id": "7ssfWn", "name": "round box example", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["primitive"], "likes": 1, "viewed": 198, "published": 3, "date": "1644741195", "time_retrieved": "2024-07-30T17:03:54.623097", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p){\n    p.xy*=rot(iTime*.5);\n    p.xz*=rot(iTime*.3);\n    vec3 v = vec3(1, 2, 3);\n    p -= clamp(p, -v, v); // extending modifier\n    float r = .1; // .0;\n    return length(p) - r; // round\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-10);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 257], [259, 259, 316, 316, 537]]}
{"id": "sdsBDn", "name": "Sonic test site", "author": "El_Sargo", "description": "Infinite plane of speakers using domain repetition.", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 326, "published": 3, "date": "1644741192", "time_retrieved": "2024-07-30T17:03:55.684260", "image_code": "const int AA = 2;\nconst vec3 sun = normalize(vec3(3.21,1,-0.4));\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n//iq\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\n//iq\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\n\nfloat pow2(float a){\n    return a* a;\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y - h;\n}\n//iq\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n//iq\nfloat sdTorus( vec3 p, float t, float r)\n{\n  vec2 q = vec2(length(p.xz)- t,p.y);\n  return length(q)- r;\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat posSin(float f){\n    return sin(f)*0.5+1.;\n}\n\nfloat sdSpeaker(vec3 p, float amplitude){\n    p -= vec3(0,-0.3,0);\n    \n    return\n                smin(\n                    min(\n                        sdCutHollowSphere(p - vec3(0, -1. + amplitude*2., 0.), .4,-.15, 0.01),\n                        sdSphere(p - vec3(0, -1.4 + amplitude*2., 0.), 0.1)\n                        ),\n                    sdTorus(p - vec3(0,-0.30,0.), 0.4, 0.03),\n                    0.01\n                    );                 \n}\nvec2 localHex(vec2 p){\n    const float z = sqrt(1.-0.25);\n    const vec2 g = vec2(1.5,z);\n    vec2 tile = mod(p+g,2.*g)-g;        \n    if (abs(tile.y) > z/0.5*(1.-abs(tile.x))){tile = mod(tile,2.*g)-g;}\n    return tile;\n}\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 repeat(vec3 p) {\n    const vec2 c = vec2(1.2);\n    vec2 x = localHex(p.xz*1.5)/1.5;\n    return vec3(x.x, p.y, x.y);\n}\n\nfloat sdScene(vec3 p, float amplitude) {\n        vec3 q = p;\n        p = repeat(p);\n            \n        vec2 id = p.xz-q.xz;\n        \n        float off = hash12(round(id)*10.);\n        amplitude = smoothstep(0.,1.,texture(iChannel0, vec2(0.02+off*0.5, 0)).x)*0.15+0.35;\n\n        return smin(\n                    sdSpeaker(p, amplitude),\n                    opSubtraction(\n                                   sdSphere(p - vec3(0, -0.5, 0.), 0.47),\n                                   sdPlane(p, -.6)\n                                  ),\n                    0.001\n                    );\n}\n\n//iq\nvec3 softshadow( in vec3 ro, in vec3 rd, float amplitude, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdScene(ro + rd*t, amplitude);\n        if( h<0.001 )\n            return vec3(0.0);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return mix(vec3(res),vec3(1.000,0.702,0.602)*res,smoothstep(1.,-.5,abs(0.5-res)));\n}\n\n//iq\nvec3 calcNormal( in vec3 p, float amplitude ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene(p + k.xyy*h, amplitude ) + \n                      k.yyx*sdScene(p + k.yyx*h ,amplitude ) + \n                      k.yxy*sdScene(p + k.yxy*h, amplitude ) + \n                      k.xxx*sdScene(p + k.xxx*h, amplitude ) );\n}\n\nfloat calcAO(vec3 pos, vec3 nor,float a){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=0; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = sdScene(pos+h*nor, a);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 intersection(vec3 ro, vec3 rd){\n    \n    //Boring variables\n    float zslice = -.158;//cos(stime);\n    vec3 pos = ro;\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    float T = 0.;\n    \n    //Colour \n    float h = sdScene(pos,0.);\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<40; ++i) {\n    \n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = sdScene(p,0.);\n        \n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n    return ro+T*rd;;\n}\nvec3 SC;\nfloat amplitude;\nvec3 render(vec2 uv ){\nvec3 rd = normalize(vec3(uv, .4));\n    rd *= rotx(0.8);\n    vec3 rp = vec3(0.0, 1, iTime);\n\n\n\n    rp = intersection(rp,rd);\n\n    vec3 scl = vec3(.99, .9, .8);\n    vec3 amb = vec3(.9, .95, .99);\n    vec3 nor = calcNormal(rp, amplitude);\n    vec3 sha = softshadow(rp, sun, amplitude, .01, 2.,10.);\n   float occ = calcAO(rp, nor, amplitude);\n    vec3 hvc = normalize(sun-rd);\n    vec2 loc = localHex(rp.xz*1.5)/1.5;\n    vec3 p = vec3(loc.x, rp.y, loc.y)-vec3(0,-.5,0);\n    float l = length(p);\n    vec3 lnr = normalize(-p);\n    vec3 bcl = mix(vec3(uv+vec2(0.5),0.5)*SC.r*1.3,\n                  vec3(.01),\n                  1.-smoothstep(0.44,0.456,length(repeat(rp).xz)));\n    vec3 col = 1.5*bcl * scl * sha * max(0.,dot(nor,sun)); \n         col += pow(max(0.,dot(hvc,nor)),100.)*sha*scl;\n         col += .1*bcl*amb*occ;\n         \n         col += pow(dot(nor, lnr), 8.)*vec3(0.361,0.020,0.020);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera setup...\n    //https://www.shadertoy.com/view/4tGfz3\n    SC = texture(iChannel0, vec2(0.02, 0)).xyz;\n    amplitude = smoothstep(0.,1.,SC.x)*0.15+0.35;\n\n\n    vec3 col;\n    float inv = 1./float(AA);\n    for (int x=0;x<AA;x++){\n    for (int y=0;y<AA;y++){\n        vec2 delta = vec2(x,y)*inv-0.5;\n        vec2 uv = (fragCoord.xy + delta) / iResolution.xy;\n        uv -= vec2(0.5);\n        uv.y /= iResolution.x / iResolution.y;\n    \n        col += render(uv)*inv*inv;\n    }}\n        \n    fragColor = sqrt(vec4(clamp(col, vec3(0.,0.,0.), vec3(1.,1.,1.)),1.0));\n}", "image_inputs": [{"id": 31936, "src": "https://soundcloud.com/ian-brinkerhoff/spongebob-trap-remix-the-krusty-krab?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 86, 86, 213], [214, 214, 234, 234, 361], [362, 362, 382, 382, 509], [510, 515, 577, 577, 761], [763, 768, 809, 809, 870], [873, 873, 893, 893, 912], [914, 914, 945, 945, 967], [968, 973, 1016, 1016, 1038], [1039, 1044, 1086, 1086, 1149], [1151, 1151, 1183, 1183, 1211], [1213, 1213, 1235, 1235, 1263], [1265, 1265, 1306, 1306, 1721], [1722, 1722, 1744, 1744, 1943], [1944, 1984, 2006, 2006, 2123], [2125, 2125, 2146, 2146, 2247], [2249, 2249, 2289, 2289, 2834], [2836, 2841, 2934, 2934, 3352], [3354, 3359, 3427, 3427, 3779], [3781, 3781, 3822, 3822, 4084], [4086, 4086, 4122, 4150, 5308], [5335, 5335, 5357, 5357, 6267], [6269, 6269, 6326, 6392, 6897]]}
{"id": "sslfWn", "name": "Rainbow panels", "author": "jarble", "description": "Another triangle-wave fractal pattern.", "tags": ["fractal", "knot", "lace"], "likes": 5, "viewed": 267, "published": 3, "date": "1644736955", "time_retrieved": "2024-07-30T17:03:56.506062", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);  \n    float t1 = 4.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        //float scale = scale+col.x/16.;\n        for(int k = 0; k < 12; k++){\n            \n            //uv /= -scale-col.x;\n            uv /= -scale;\n            uv -= offset + (t2.yx)/(scale);\n            //uv -= offset + (t2.yx)/(scale+length(col));\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx-.5+float(i),scale);\n            \n            t3 = triangle_wave(-uv,scale);\n            \n            uv.yx = (t2+t3)/scale;\n            //offset -= col.x/16.;\n            //offset += offset1;\n            col.x = abs(uv.x+uv.x-col.x);\n            col = col.yzx;\n        }\n\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1351]]}
{"id": "7lySWh", "name": "Entwined", "author": "davidar", "description": "Inspired by [url]https://www.shadertoy.com/view/fsjyR3[/url]", "tags": ["simulation", "heart", "convolution", "diffusion", "kernel", "ca", "reaction", "differential", "growth", "meandering"], "likes": 28, "viewed": 439, "published": 3, "date": "1644736308", "time_retrieved": "2024-07-30T17:03:57.638036", "image_code": "void mainImage( out vec4 r, in vec2 u )\n{\n    vec2 uv = u / iResolution.xy;\n    \n    // edge detection\n    vec4 dx = texGradX(iChannel0, uv);\n    vec4 dy = texGradY(iChannel0, uv);\n    r = sqrt(dx*dx + dy*dy);\n    \n    // layering\n    vec4 mask = texBlur(iChannel0, uv);\n    float blend = smoothstep(.45, .55, uv.x);\n    r.xy *= mask.xy - vec2(1. - blend, blend) * mask.yx;\n    \n    // colours\n    r = 1. - clamp(2. * r, 0., 1.);\n    r.y -= .5 - .5 * r.x;\n    \n    // paper\n    r -= .05 * texture(iChannel1, .5 * u / iChannelResolution[1].xy).x;\n    \n    // shadow\n    float shadow = .1 * length(texBlur(iChannel0, (u + vec2(-5, 5)) / iResolution.xy));\n    shadow *= smoothstep(0., 4e-3 * iResolution.y, iTime);\n    shadow *= 1. - clamp(mask.x + mask.y, 0., 1.);\n    r -= shadow;\n    \n    //if (abs(u.x - .5 * iResolution.x) / iResolution.y > .5) r = vec4(0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 char(vec2 p, int c) {\n    if (p.x < 0. || p.x > 1. || p.y < 0.|| p.y > 1.) return vec4(0,0,0,1);\n    return texture(iChannel2, p/16. + fract(vec2(c, 15-c/16)/16.));\n}\n\nvoid mainImage(out vec4 r, vec2 u) {\n    vec2 i = u-u; r -= r;\n    int z = 15;\n    for(int k = (2*z+1)*(2*z+1); k-->0;) {\n        i = vec2(k%(2*z+1),k/(2*z+1)) - float(z);\n        float q = mix(.015, .06, smoothstep(0., 16e-3 * iResolution.y, iTime));\n        r += .5 * texelFetch(iChannel0,ivec2(i+u),0) * (1. - q*dot(i,i))*exp(-q*dot(i,i));\n    }\n    vec2 uv = u/iResolution.xy;\n    r = clamp(r,0.,1.);\n    if (iFrame < 9) {\n        if (u.x < .25 * iResolution.x) r.x = 1.;\n        if (u.x > .75 * iResolution.x) r.y = 1.;\n        //if (u.y < .05 * iResolution.y) r.z = 1.;\n    }\n    \n    vec2 p = vec2(3.7,2.7) * (uv - vec2(.5,.38));\n    float heart = distance(p, vec2(0, sqrt(abs(p.x))));\n    if(heart > 1.) r = vec4(0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* Texture Stencil Library https://www.shadertoy.com/view/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https://davidar.io/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. / vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n// Gaussian/binomial blur\n// https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n// Laplacian, optimal 9-point stencil\n// https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) / 6.;\n}\n\n// horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) / 8.;\n}\n\n// vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) / 8.;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lySWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 861]]}
{"id": "7dlfWn", "name": "Gem Rug Fractal", "author": "jarble", "description": "A golden gem-studded carpet pattern.", "tags": ["fractal", "carpet", "gem", "rug"], "likes": 13, "viewed": 380, "published": 3, "date": "1644736213", "time_retrieved": "2024-07-30T17:03:58.509705", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+vec2(0,1.5))*scale)-.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 3.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    for(int i=0;i<6;i++)\n    {\n        uv = triangle_wave(uv,scale);\n        //uv -= col.x*uv.x; //makes a nice \"gilded\" pattern\n        uv = triangle_wave(uv.yx,scale)+triangle_wave(uv-.5,scale);\n        col.x = (uv.x+uv.y);\n        col = abs(col.yzx-col);\n        \n        //animated jiggly thing\n        //uv.x += col.x*uv.y/(2.+triangle_wave(uv.yx+iTime,scale).x);\n    }\n    fragColor = vec4(min(vec3(1.),col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 90], [91, 91, 148, 148, 762]]}
{"id": "NdsBDn", "name": "SenaglFlag", "author": "BaOusmane88", "description": "Ba Ousmane", "tags": ["baousmane"], "likes": 2, "viewed": 182, "published": 3, "date": "1644709153", "time_retrieved": "2024-07-30T17:03:59.381375", "image_code": "//https://www.shadertoy.com/view/WdVcDW\n\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1.0, 0.882, 0.067);\n  //float box = sdBox(uv, vec2(0.2, 0.1), vec2(-0.2, 0));\n  float star = sdStar5(uv, 0.12, 0.45);\n  \n  col = mix(vec3(0, 0.57, 0), col, step(0., star));\n  //col = mix(vec3(0, 0, 1), col, step(0., box));\n  \n  return col;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //\n    \n     vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n      uv -= 0.5; // <-0.5,0.5>\n      uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n      vec3 col = drawScene(uv);\n       \n      // Output to screen\n      fragColor = vec4(col,1.0);\n      \n      vec2 xy = fragCoord.xy; \n      xy.x = xy.x / iResolution.x; \n    xy.y = xy.y / iResolution.y; \n    fragColor = vec4(0.0, 0.6, 0.0, 0.0); \n      \n     if(uv.x > -0.33){ \n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); \n         vec3 col = drawScene(uv);\n       \n      // Output to screen\n      fragColor = vec4(col,1.0);\n    }\n    if(uv.x > 0.33){\n         fragColor = vec4(1.0, 0.0, 0.0, 0.0); \n          vec3 col = drawScene(uv);\n       \n      // Output to screen\n         //fragColor = vec4(col,0.0);\n    }\n    //\n    \n    \n   \n    //vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //p.x *= iResolution.x/iResolution.y;\n    \n    //vec3 col = FivePointStar(p,vec2(0.0,0.0),0.21,0.5,vec3(1.0,0.9,0.0));\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n     //vec2 xy = fragCoord.xy;  \n    //xy.x = xy.x / iResolution.x; \n    //xy.y = xy.y / iResolution.y; \n    //fragColor = vec4(0.0, 0.6, 0.0, 0.0); \n    //if(xy.x > 0.33){ \n        //fragColor = vec4(1.6, 1.6, 0.0, 1.6); \n    //}\n    //if(xy.x > 0.66){\n         //fragColor = vec4(1.0, 0.0, 0.0, 1.0); \n    //}\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n     //vec2 center = iResolution.xy * 0.5; \n     //float radius = 0.25 * iResolution.y;\n    //fragColor = Star(fragCoord.xy, center, radius, vec4(1.0, 0.0, 0.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 93, 93, 451], [453, 453, 478, 478, 738], [744, 744, 801, 813, 2392]]}
{"id": "ssByRw", "name": "vibrant polar rave firebreath ", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 7, "viewed": 688, "published": 3, "date": "1644707095", "time_retrieved": "2024-07-30T17:04:00.394665", "image_code": "// Fork of \"polar rave\" by firebreathz. https://shadertoy.com/view/7l2Gzw\n// 2021-06-13 21:22:36\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 21:01:10\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.25;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*4.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 9.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*.993;\n    band += 0.000000000001;\n    \n    s = texture( iChannel0, vec2(band,-10.000) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 8;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-0)/n)*n);\n    }\n    \n    float h = PI*1.0200004;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.0001,0.875,f);\n    col *= smoothstep(0.999999,0.0000625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 20.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.0005*smoothstep(1.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.0002)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(10.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2200026.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 326, 326, 407], [409, 409, 451, 451, 510], [512, 512, 537, 537, 2097], [2099, 2099, 2156, 2156, 3421]]}
{"id": "fdsfWn", "name": "RawTex", "author": "AnonymouseCoder", "description": "A shader that displays the raw data sent to it", "tags": ["texture"], "likes": 0, "viewed": 181, "published": 3, "date": "1644706703", "time_retrieved": "2024-07-30T17:04:01.366068", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 outp = texture(iChannel0, uv);\n    fragColor = outp;\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]]}
{"id": "7dSSD3", "name": "Sharp Shiny Blue Ballz", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 7, "viewed": 267, "published": 3, "date": "1644706656", "time_retrieved": "2024-07-30T17:04:02.383348", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*3600./vec2(80000.,80000.), iResolution.y>700. ? 6000. : 4000.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.1))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<1;\n\tbool lightsilver = section>2 && section<12;\n\tbool lightgreen = section>5;\n\tbool lightpink = section>7 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.1:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1414]]}
{"id": "7tcXRj", "name": "space filling curve", "author": "xnio94", "description": "space filling curve (zigzag curve or z curve)", "tags": ["zcurve", "spacefillingcurve"], "likes": 2, "viewed": 227, "published": 3, "date": "1644681231", "time_retrieved": "2024-07-30T17:04:03.216122", "image_code": "//take 2D point (x,y) and liniearaz it as a 1D float\n//k is the precession for pixel precision it can be log2(resolution)+1\nfloat to1D(float x, float y, int k)\n{\n    float z=0.;\n    int n=2;\n    float xx=0.,yy=0.;\n    for(int i=0;i<k;i++){\n        z*=2.;  if(x-xx>=1./float(n)) {z+=1.; xx+=1./float(n);}\n        z*=2.;  if(y-yy>=1./float(n)) {z+=1.; yy+=1./float(n);}\n        n*=2;\n    }\n    z = z / pow(2.,float(2*k));\n    return z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float z = to1D(uv.x,uv.y,10);\n    \n    float col = 0.; //sin(z*100.);//*pow(2.,iTime/10.);\n    \n    float r = .01;\n    z +=iTime/1000.;\n    col = smoothstep(r,r+.0001,fract(z*8.));\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 124, 161, 161, 435], [438, 438, 495, 545, 843]]}
{"id": "7ssBz7", "name": "Z curve", "author": "FabriceNeyret2", "description": "Among the various space-filling curves, Z-curve https://en.wikipedia.org/wiki/Z-order_curve are used on GPU to index nD textures into linear memory so that close (u,v,...) are (generally) stored close in memory ( good for cache, parallelism, etc ).", "tags": ["hilbert", "zcurve", "zcurve", "mortoncode", "peano"], "likes": 15, "viewed": 401, "published": 3, "date": "1644669610", "time_retrieved": "2024-07-30T17:04:04.066847", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    int s = 0;\n    for (int i=0; i < 12; i++, u /= 2. )\n        s +=  ( int(u.y)%2*2 + int(u)%2 ) << i+i;\n    \n    vec2 R = // iResolution.xy;\n                exp2(ceil(log2(iResolution.xy))); // round to upper power of 2\n    float v = float(s)/ R.x/R.y;                  // Z-curve index\n    O = hue( 16.* v ) * sqrt(.1+1.7*v);           // display hue and luminance along index\n  //O = fract(v*32.) * hue( v );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "sdlBz7", "name": "shortest binary decomposition", "author": "FabriceNeyret2", "description": ".", "tags": ["binary", "short", "golf"], "likes": 11, "viewed": 276, "published": 3, "date": "1644667083", "time_retrieved": "2024-07-30T17:04:04.920564", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = vec4( int(u/=4.) >> int(u.y)  & 1 );     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 90]]}
{"id": "7dsBR7", "name": "binary search runtime: stats", "author": "FabriceNeyret2", "description": "variant of \"binary search runtime\" by ArmandB. https://shadertoy.com/view/7dsBRM\nabout distrib of  y = binary search iterations to get x (white).\n\n Here, store all results for range 0-iRes.x , or 0-R.x*R.y if mouse click\nred: y = Gauss( avg, stddev )\n", "tags": ["algorithm", "gpmipmap"], "likes": 3, "viewed": 332, "published": 3, "date": "1644661143", "time_retrieved": "2024-07-30T17:04:05.857060", "image_code": "// variant of \"binary search runtime\" by ArmandB. https://shadertoy.com/view/7dsBRM\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    // --- display first raw of values ( y = binary search iterations to get x )\n    ivec2 I = ivec2(u/4.);\n    O = vec4( I.y == int(texelFetch(iChannel0,ivec2(I.x,0),0)) );\n    \n    // --- show statistics\n    \n    vec2 M = texture(iChannel0, vec2(.5), 99.).xy;\n    float m = M.x,               // average value,\n          s = sqrt( M.y - m*m ), // std dev \n          \n          y = ( float(I.y) - m ) / s;\n    O.r += exp2( -.5* y*y );     // show gaussian statistics\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u -= .5;\n    \n    int res = iMouse.z<0. ? int(R.x) : int(R.x*R.y),\n      coord = iMouse.z<0. ? int(u.x) : int(u.x+R.x*u.y);\n\n    int l = 0,\n        r = res-1,\n        c = 0, m;\n    \n    for ( ; c < res; c++) {\n        m = (r+l)/2;\n        if     (m == coord)  break;\n        else if (m < coord) l = m-1;\n        else if (m > coord) r = m+1;\n    }\n \n    O = vec4(c,c*c,0,0);   // to get moments 1 and 2 in max MIPmap LOD\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7d2cWR", "name": "Voronoi??", "author": "i11212", "description": " Free to use", "tags": ["ex"], "likes": 1, "viewed": 330, "published": 3, "date": "1644653864", "time_retrieved": "2024-07-30T17:04:06.616032", "image_code": "/*\nMade By I11212\nTwitter: https://twitter.com/i11212_?t=us2GzKso5JLrTiwYIxuueg&s=09\nYoutube: https://youtube.com/channel/UCg21GlDi4TtGe-9CNpSlR9A\n*/\n\n#define matrot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define amount 4.0\n#define saturate(x) clamp(x,0.0,1.0)\n\nhighp float voronoi(\n\thighp vec2 x){\nhighp float n = 0.0;\nfor(int i = 0; i<int(amount); i++){\nn = max(n, abs(\n\t\tsin(x.x)*\n        cos(x.y))),\n\nx *= matrot(0.25),\n\nx += vec2(sin(iTime),\n\tcos(iTime))/(\n\tamount/2.0),\n\nx += float(i)/amount;\n\t}\nreturn 1.0-(n);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/(iResolution.x,\n    iResolution.y);\n\n    fragColor = vec4(voronoi(uv*16.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2cWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 578, 578, 681]]}
{"id": "7dsBRM", "name": "binary search runtime", "author": "ArmandB", "description": "the x axis is the index of the array, the y axis is how may iterations the binary search algorithm takes to reach that index\ndrag on green bar to change scale", "tags": ["algorithm"], "likes": 1, "viewed": 194, "published": 3, "date": "1644644937", "time_retrieved": "2024-07-30T17:04:07.557514", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float zoom = 0.0;\n    \n    if (iMouse.x > iResolution.x*0.95 && iMouse.z > 0.0){\n        zoom = iMouse.y;\n    }\n    \n    ivec2 res = ivec2(iResolution.xy/zoom);\n    ivec2 coord = ivec2(fragCoord.xy/zoom);\n\n    int m = res.x; //the middle of the array\n    int l = 0; //left index\n    int r = res.x-1; //right index\n    int c = -1; //itterations\n    for (int i = 0; i < res.x; i++) {\n        m = (r+l)/2;\n        if (m == coord.x) {\n            c = i;\n            break;\n        } else if (m < coord.x) {\n            l = m-1;\n        } else if (m > coord.x) {\n            r = m+1;\n        }\n    }\n    if (fragCoord.x > iResolution.x*0.99){\n        if (round(fragCoord.y)==round(iMouse.y/10.0)*10.0) {\n            fragColor = vec4(1);\n        } else {\n            fragColor = vec4(0.1,0.8,0,1);\n        }\n    } else {\n        fragColor = vec4(coord.y == c);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 927]]}
{"id": "NdsBz7", "name": "Speeding Exhaust", "author": "oneshade", "description": "Meh", "tags": ["smoke", "speeding", "exhaust"], "likes": 17, "viewed": 208, "published": 3, "date": "1644633655", "time_retrieved": "2024-07-30T17:04:08.307509", "image_code": "#define iTime (5.0 * iTime)\n#define TAU 6.2831853072\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y - vec2(0.0, 0.5);\n    float unit = 2.0 / iResolution.y;\n\n    float zoom = mod(10.0 * iTime, TAU);\n    float y = uv.x * cos(10.0 * log(uv.x) - zoom) / 10.0;\n\n    float diff = exp(uv.x * 4.0);\n    float fade = exp(-uv.x * 2.0);\n\n    fragColor = vec4(1.0 - smoothstep(unit * diff, 0.0, abs(uv.y - y)) * fade);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 109, 109, 458]]}
{"id": "NdsfR7", "name": "bouncing balls", "author": "xnio94", "description": "i was inspired from this gif https://twitter.com/incre_ment/status/1492288142258282496\n(the uncolored version is a perfect loop every 4 seconds)", "tags": ["marching", "loop", "analyticalbouncing"], "likes": 5, "viewed": 289, "published": 3, "date": "1644631105", "time_retrieved": "2024-07-30T17:04:09.167210", "image_code": "#define pi 3.14\n\n#ifdef HW_PERFORMANCE\n    #if HW_PERFORMANCE==0\n    #define AA 1.\n    #else\n    #define AA 2.   // make this 2 or 3.. for better antialiasing\n    #endif\n#else\n#define AA 1.\n#endif\n\nconst float MAXD = 100.;\nconst float MAXSHD = 4.5;\nconst float MAXRD = 15.;\nfloat t;\n// 2d rotation\nvec2 rot(vec2 p, float r) {\n\tfloat c = cos(r), s = sin(r);\n\treturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\nfloat dcube( vec3 p, float b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//dh hight\n//a phase 0 to 1\nfloat bounce(float dh,float a)\n{\n    if (dh==0.) return 0.;\n    float g=10.;\n    float v0 = sqrt(dh*4.*g);\n    float t = mod(iTime + a*v0/g+ 0.*v0/g,v0/g); \n    return -g*t*t+v0*t;\n}\nvec4 opu(vec4 a,vec4 b){ return (a.x<b.x) ? a : b;}\nvec4 map(vec3 p)\n{\n    vec3 blue = vec3(.7,.7,.9); //normalize(vec3(.3,.4,.8));\n    vec3 pink = vec3(1.,.8,.9);\n    vec3 q=p;\n    p.x=mod(p.x,4.)-2.;\n    float s = (q.x-p.x)/4.-.5;\n\tvec3 u = p;   \n    float x = mod(iTime*4. ,4.);\n    float r = 1.;\n\n\n    vec4 plan = vec4(p.y,blue-.1);\n    vec4 cube = vec4(10., blue*.3-.1 +.5*vec3(1.,sin(s*77.+49.)*.5+.5,sin(s*33.)*.5+.5)*.3+.7 ) ;\n    cube.x = dcube(p - vec3(0., .65, 0.),.65);\n    \n    \n    float h = bounce(10./4.,.5); //period =1.\n    \n    \n    vec4 ball = vec4(0. ,pink);\n    ball.x = length(p - vec3(x,r+h,0.))-r;\n    \n    vec4 ball2 = vec4(0. ,pink);\n    ball2.x = length(p - vec3(x-4.,r+h,0.))-r;\n        \n\n    \n    vec4 o = opu(ball, ball2);\n    o = opu(o, plan);\n    o = opu(o, cube);\n    \n    \n    //o.yzw = vec3(1.,.8,.9); //color \n    \n    return o;//vec4(d,1.,0.,0.);\n}\n//simple raymarch\nvec4 rayMarch(vec3 rO, vec3 rD)\n{   \n    float d = 0.;\n    vec4 D;\n    for (int i = 0; i<130 &&  d < MAXD; i++)\n    {\n        D = map(rO + rD * d);\n        //d += D.x;\n        if (D.x > .5)  d += D.x*.5;   else d += D.x;\n        if (D.x < 3e-4)  break;\n    }\n    return vec4(d, D.yzw);\n}\n\n//to learn about normal using sdf\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    vec2 N = vec2(0., 1e-2);\n    return normalize(vec3(map(p-N.yxx).x, map(p-N.xyx).x, map(p-N.xxy).x));\n}\nvec3 simpleSky(vec3 p){   \n    return vec3(.5,.6,1.-p.y);\n}\n// you can learn more about soft shadows in this article https://iquilezles.org/articles/rmshadows\nfloat shadows(vec3 or, vec3 lD)\n{\n    const float k = 1.5;\n    float res = 1.;\n    float t = 0.;\n    for (int i = 0; i < 40; i++)\n    {\n        float d = map(or + lD*t).x;\n        res = min(res, .5 + d * k / t);\n        if (res < .01|| t > MAXSHD) break;\n        t += d;\n    }\n    res = max(res, 0.);\n    return smoothstep(.3, 1., res);\n}\nvec4 render(in vec2 fragCoord )\n{\n    float fov = iResolution.x;\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    uv = uv - .5;\n    uv /= fov;\n    float ww=1.+ t*.05;\n    vec3 dis = vec3(iTime,2.,0.);\n    vec3 or = vec3(-1.,.5, 1.)*16.+dis;\n    //or.y = 20.;\n    //or.y-=17.5;\n    vec3 w = normalize(vec3(0.,0.,0.)-or+dis);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rD = normalize(w*1.5+uv.x*u+uv.y*v);\n\t   \n    vec4 d = rayMarch(or, rD);\n    vec3 col = vec3(0,0,0);\n    \n    if (d.x < MAXD)\n    {\n        vec3 p = or + d.x * rD;\n    \tvec3 nrm = normal(p);\n        vec3 sun = -normalize(vec3(.4, 2., .8));\n        \n        col = vec3(dot(sun,nrm)) *d.yzw;\n        //col *= d.yzw; //colloring\n        col *= vec3(shadows(p - sun * 0.01, -sun));\n\n    }\n    else \n    {\n        col = simpleSky(rD);\n    }\n    \n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    t = iTime*2.25; // globale time\n    for(float a=0.;a<AA;a++)\n        fragColor += render(fragCoord + a/AA);\n    fragColor /=AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 298, 325, 325, 410], [411, 411, 443, 443, 530], [531, 559, 591, 591, 741], [742, 742, 766, 766, 793], [794, 794, 812, 812, 1628], [1629, 1647, 1680, 1680, 1934], [1936, 2015, 2036, 2036, 2143], [2144, 2144, 2167, 2167, 2203], [2204, 2303, 2336, 2336, 2641], [2642, 2642, 2675, 2675, 3523], [3524, 3524, 3581, 3581, 3741]]}
{"id": "fdXfz7", "name": "Glow Ball", "author": "me_123", "description": "I made this on accident, i was trying to make spheres inside a ball using voronoi. ", "tags": ["procedural", "3d", "raymarching", "voronoi", "mouse", "animation", "ball"], "likes": 27, "viewed": 560, "published": 3, "date": "1644593984", "time_retrieved": "2024-07-30T17:04:10.052842", "image_code": "float t;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat vorinoi(in vec3 p) { //3d vorinoi\n    p.z += t;\n\tvec3 gv = floor(p);\n    vec3 f = fract(p);\n    float d = 1.0; //starting distance\n    for (int x = -1; x <= 1; x += 1) {\n        for (int y = -1; y <= 1; y += 1) {\n            for (int z = -1; z <= 1; z += 1) {\n            \tvec3 pp = vec3(x, y, z);\n                vec3 p = gv-pp;\n                vec3 of = (sin(hash33(p)+(t+10.)*hash33(p*0.5))-0.5)*0.5; //animated 3d cells\n                \n                d = min(d, length(pp+of+f));\n            }\n        }\n    }\n    return d;\n}\nfloat sdf(in vec3 p) { //signed distance function - vorinoi inside a sphere\n    float v = (vorinoi(p*5.))-0.3;\n\treturn max(length(p)-1., v/5.);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    //ray marching with low step counts looks great !\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 10; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p);\n        d0 += d;\n        if (d < 0.001 || d0 > 100.) break;\n    }\n    return vec3(mix(pow(p, vec3(2., 4.0, 2)), vec3(0), clamp((d0-1.8), 0.0, 1.0)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = vec2(t*0.2, 1.5);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*2.3;\n    vec3 rd = getRay(-normalize(ro), uv);\n    \n    //render\n    vec3 color = getColor(ro, rd);\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 53, 80, 290], [291, 291, 313, 369, 494], [495, 495, 521, 534, 1032], [1033, 1033, 1055, 1108, 1178], [1179, 1179, 1218, 1272, 1543], [1544, 1544, 1601, 1601, 2030]]}
{"id": "NdXBz7", "name": "Autograph Machine", "author": "eiffie", "description": "I built a machine to sign my artwork but haven't used it yet since the machine to create artwork is harder to make. I may have to build a machine to complete it. ", "tags": ["cursive"], "likes": 34, "viewed": 416, "published": 3, "date": "1644592660", "time_retrieved": "2024-07-30T17:04:11.017264", "image_code": "//Autograph Machine by eiffie\n#define rez iResolution.xy\n#define pi 3.14159\nmat2 rmat(float a){float ca=cos(a),sa=sin(a);return mat2(ca,sa,-sa,ca);}\nfloat tube(vec3 pa, vec3 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nvec2 curl(float a1, float a2, float t, float h, float w){\n  return vec2(t+sin(a2*pi*2.)*w,(1.-cos(a1*pi*2.))*h*.5+.75);\n}\nvec2 eiffie(float t){\n  float b=t*8.,a=fract(b),a2=a,aa=4.-abs(b-4.),s,h=.125,w=.075;\n  b=floor(b);if(b==4.)aa=2.;else if(b==5.)aa=3.;\n  s=b;\n  if(b>2.){s-=1.;if(b>4.)s-=1.;}\n  if(aa<1.){s+=a;\n  }else if(aa<2.){w=.04;s+=a;\n  }else if(aa<3.){h=.2;\n    if(a<.75)s+=a;else{s+=.75;a2=.75;}\n  }else{h=-.15;\n    if(a<.25){s+=.75;a2=-.25;}\n    else {h+=(a-.25)*(a-.25)*0.2;s+=1.-a;a2=-a*a-.1875;if(a>.85){w=-w;s+=.6;}}\n  }\n  vec2 v=curl(a,a2,s/6.,h,w);\n  return v;\n}\nfloat getAng(){return abs(mod(0.1*iTime,2.)-1.);}\n\nfloat disc(vec3 p, float s){\n  float a=atan(p.x,p.y)/(pi*2.);if(a<0.)a+=1.;\n  float r=length(p.xy);\n  vec3 e=vec3(eiffie(a),0.)-vec3(.5,0.,0.),b=vec3(0);\n  e.xy=e.xy*rmat((.5-a)*pi*.25);\n  b.y=e.y-sqrt(1.-e.x*e.x);\n  vec3 f=normalize(cross(b-e,vec3(0,0,1)))*s;\n  r-=e.y+f.y*.7-0.05;\n  //return max(max(r,p.y>0.?s>0.?.05-p.x:.05+p.x:0.),abs(p.z)-.05);\n  return max(max(r,-max(abs(p.x)-.05,-p.y)),abs(p.z)-.05);\n}\nfloat wav(float t){return abs(fract(t)-.5);}\nfloat gear(vec3 p, float r, float f){\n  float a=atan(p.x,p.y)/(pi*2.);\n  r=length(p.xy)-r;\n  r*=sign(f);\n  return max(max(r-wav(a*f)*.2,-r-.15),abs(p.z+0.1)-.05);\n}\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p){\n  vec3 pc=p;pc.xy=pc.xy*rmat((.5-getAng())*pi*.25);\n  vec3 ps=pc;\n  float a=getAng();\n  mat2 rmx=rmat(a*pi*2.);\n  ps+=vec3(1.,1.,.0);\n  ps.xy=ps.xy*rmx;\n  pc+=vec3(-1.,1.,.0);\n  pc.xy=pc.xy*rmx;\n  float dc=disc(pc,-1.),ds=disc(ps,1.);\n  vec3 e=vec3(eiffie(a),0.)-vec3(.5,0.,0.),b=vec3(0);\n  b.y=e.y-sqrt(1.-e.x*e.x);\n  vec3 f=normalize(cross(b-e,vec3(0,0,1)));\n  float dt=tube(p-e,b-e);\n  dt=min(dt,tube(p-e,b-e+f));\n  dt=min(dt,tube(p-e,b-e-f));\n  dt-=0.02;\n  p.xy=rmat(-a*pi*.02+.03)*p.xy;\n  float g=gear(p,1.75,-60.);//gear(p,.87,30.);\n  g=min(g,min(gear(pc,.2,8.),gear(ps,.2,8.)));\n  float d=min(min(dc,ds),min(dt,min(g,-p.z+.1)));\n  \n  if(mcol.x>0.){\n    vec3 col=vec3(.4,.25,.1);\n    vec2 v;\n    if(d==ds)v=ps.xy;\n    else if(d==dc)v=pc.xy;\n    else if(d==dt)v=vec2(1);\n    else if(d==g){v=vec2(10.5);col=col.grb;}\n    else {v=vec2(10.5);col=col.bgr;}\n    mcol+=abs(0.75+.25*sin(dot(v,v+v.yx*.1)*80.))*col;\n  }\n  return d;\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,4.*d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=1.0/rez.x;\n  for(int i=0;i<64;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>20.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.025,-0.5));\n  vec3 col=vec3(0);\n  if(d<px*t*5.0 && t<20.){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec3 scol=mcol*0.25;\n    if(scol.b>scol.r){\n      if(abs(so.x)<.02 && so.y<0. && so.y>-.4)scol=vec3(0.);\n      vec3 p=so;\n      t=max(abs(p.x)-.6,abs(p.y-.8)-.2);\n      if(t<0.){\n        d=1.;p.z=0.;\n        float a=getAng();t=0.;\n        for(int i=0;i<24;i++){\n          vec3 v=vec3(eiffie(t),0.);v.x-=.5;\n          float b=length(p-v);\n          d=min(d,b);\n          t+=b*.2;\n          if(t>a)break;\n        }\n        d=smoothstep(0.0,0.025,d);\n        scol=vec3(d);\n      }\n    }\n    float dif=0.5+0.5*dot(N,L);\n    float shad=ShadAO(so,L);\n    col=1.5*scol*dif*shad;\n  }\n  return col;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez)/rez.x;\n  randomize(U.xy);\n  vec3 rd=normalize(vec3(uv.xy,1.0));\n  vec3 ro=vec3(0,0,-4);\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 3.\n#define pi 3.14159\n//int N[8]=int[8](0,2,4,5,7,5,4,0);\nint N[8]=int[8](0,5,3,4,5,4,3,0);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==6.)||(n2==8.))note=-100.;//mixolydian +minor 3rd \n return note; \n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n} \nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+cos(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\n\nvec2 mainSound(int samp, float time){\n  float tim=mod(time*bps,128.);\n  float bt=floor(tim),t=fract(tim);\n  int n1=N[int(bt/64.)];\n  int n0=n1+N[int(bt/8.)%8],n=n0+N[int(bt)%8],n2=n0+N[int(bt/2.)%8],n4=n0+N[int(bt/4.)%8];\n  vec2 v=I(n+36,t,vec3(1.-t*.5,1.,t),vec4(10.,1.0,12.,t*.3),vec4(1.014,0.005,1.,.5))*.25;\n  t=fract(tim/2.);\n  float fo=pow(1.-t,20.0);\n  v+=I(n2+60,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/4.);\n  fo=pow(1.-t,20.0);\n  v+=I(n4+60,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/8.);\n  fo=pow(1.-t,20.0);\n  v+=I(n0+60,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,2.0,48.,t*.8),vec4(1.014,0.005,1.,.5));\n  return v*.1;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 95, 95, 148], [149, 149, 178, 178, 237], [238, 238, 295, 295, 359], [360, 360, 381, 381, 819], [820, 820, 835, 835, 869], [871, 871, 899, 899, 1282], [1283, 1283, 1302, 1302, 1327], [1328, 1328, 1365, 1365, 1492], [1514, 1514, 1531, 1531, 2462], [2463, 2463, 2492, 2502, 2638], [2650, 2650, 2676, 2676, 2750], [2752, 2752, 2789, 2789, 2926], [2927, 2927, 2956, 2956, 3828], [3829, 3829, 3867, 3867, 4011]]}
{"id": "NdXfzM", "name": "MFSDF Fractal preset", "author": "PauloFalcao", "description": "This is an instance of https://www.shadertoy.com/view/sdffR4\nClone this and change the #define values for f values using the original shader to find the values", "tags": ["fractal", "fork", "preset", "mfsdf"], "likes": 9, "viewed": 256, "published": 3, "date": "1644588259", "time_retrieved": "2024-07-30T17:04:11.984677", "image_code": "// MFSDF Fractal preset 001\n// By PauloFalcao\n\n// This is a instance of the shader\n// https://www.shadertoy.com/view/sdffR4\n\n// CHANGE F VALUES USING https://www.shadertoy.com/view/sdffR4\n// TO FIND VALUES\n\n//Left\n#define f1 0.94\n#define f2 0.29\n#define f3 0.50\n#define f4 0.20\n#define f5 0.25\n#define f6 0.15\n#define f7 0.63\n#define f8 0.10\n#define f9 0.05\n\n//Right\n#define f10 0.58\n#define f11 0.79\n#define f12 1.00\n#define f13 1.00\n#define f14 1.00\n#define f15 1.00\n#define f16 0.45\n#define f17 0.26\n#define f18 0.42\n\n//END\n\n\n#define SEED_VARIATION 0.0\n\n\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}float mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o502144_LookAtX = 0.000000000;\nconst float p_o502144_LookAtY = 0.000000000;\nconst float p_o502144_LookAtZ = 0.000000000;\nconst float p_o502144_CamD = 1.500000000;\nconst float p_o502144_CamZoom = 1.000000000;\nconst float p_o502144_SunX = 2.500000000;\nconst float p_o502144_SunY = 2.500000000;\nconst float p_o502144_SunZ = 2.500000000;\nconst float p_o502144_AmbLight = 0.250000000;\nconst float p_o502144_AmbOcclusion = 1.000000000;\nconst float p_o502144_Shadow = 1.000000000;\nconst float p_o502144_Gamma = 1.300000000;\nconst float p_o502134_Correction = 0.000000000;\nconst float p_o502161_k = 0.199000000;\n#define p_o502157_BaseColor_r (f13)\n#define p_o502157_BaseColor_g (f14)\n#define p_o502157_BaseColor_b (f15)\nconst float p_o502157_BaseColor_a = 1.000000000;\nconst float p_o502157_Metallic = 0.002000000;\nconst float p_o502157_Specular = 0.500000000;\nconst float p_o502157_Roughness = 0.000000000;\nconst float p_o502157_Emission = 0.000000000;\nconst float p_o502157_Normal = 0.000000000;\nconst float p_o502157_Alpha = 0.000000000;\nconst float p_o502157_AmbientOcclusion = 0.000000000;\nconst float p_o502157_scale = 0.963000000;\nconst float p_o502157_TranlateX = 0.148000000;\nconst float p_o502157_TranlateY = -0.386000000;\nconst float p_o502157_TranlateZ = 0.295000000;\nconst float p_o502157_RotateX = 0.000000000;\nconst float p_o502157_RotateY = 0.000000000;\nconst float p_o502157_RotateZ = 0.000000000;\nvec3 o502157_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o502157_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502157_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502157_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502157_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502157(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502157_TranlateX,p_o502157_TranlateY,p_o502157_TranlateZ),vec3(p_o502157_RotateX,p_o502157_RotateY,p_o502157_RotateZ)*6.28318530718)/p_o502157_scale;\n\tfloat sdf=o502157_input_sdf3d(uv.xyz, _seed_variation_)*p_o502157_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502157_AmbientOcclusion*o502157_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502157_Alpha*o502157_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502157_Normal*o502157_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502157_Emission*o502157_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502157_Roughness*o502157_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502157_Specular*o502157_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502157_Metallic*o502157_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502157_BaseColor_r, p_o502157_BaseColor_g, p_o502157_BaseColor_b, p_o502157_BaseColor_a).rgb*o502157_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\n#define p_o502140_BaseColor_r (f10)\n#define p_o502140_BaseColor_g (f11)\n#define p_o502140_BaseColor_b (f12)\nconst float p_o502140_BaseColor_a = 1.000000000;\nconst float p_o502140_Metallic = 0.000000000;\nconst float p_o502140_Specular = 0.500000000;\nconst float p_o502140_Roughness = 0.000000000;\nconst float p_o502140_Emission = 0.000000000;\nconst float p_o502140_Normal = 0.000000000;\nconst float p_o502140_Alpha = 0.000000000;\nconst float p_o502140_AmbientOcclusion = 0.000000000;\nconst float p_o502140_scale = 0.984000000;\nconst float p_o502140_TranlateX = -0.083000000;\nconst float p_o502140_TranlateY = 0.147000000;\nconst float p_o502140_TranlateZ = 0.000000000;\nconst float p_o502140_RotateX = 0.000000000;\nconst float p_o502140_RotateY = 0.000000000;\nconst float p_o502140_RotateZ = 0.000000000;\nconst float p_o502162_scale = 0.579000000;\n#define p_o502162_scale_x (f16*32.0)\n#define p_o502162_scale_y (f17*32.0)\n#define p_o502162_scale_z (f18*32.0)\nconst float p_o502162_transx = 0.000000000;\nconst float p_o502162_transy = 0.000000000;\nconst float p_o502162_transz = 0.000000000;\nconst float p_o502162_persistence = 0.500000000;\nconst float p_o502162_brightness = 0.000000000;\nconst float p_o502162_contrast = 4.139000000;\nfloat o502162_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o502162_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o502140_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec3 o502162_0_out = vec3(o502162_bc(o502162_fbm((p).xyz*vec3(p_o502162_scale_x,p_o502162_scale_y,p_o502162_scale_z)*0.5*p_o502162_scale+vec3(p_o502162_transx,p_o502162_transy,p_o502162_transz),p_o502162_persistence, _seed_variation_)*0.5+0.5,p_o502162_contrast,p_o502162_brightness, _seed_variation_));vec3 o502162_0_1_tex3d = clamp(o502162_0_out,vec3(0),vec3(1));\n\nreturn o502162_0_1_tex3d;\n}\nfloat o502140_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502140_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502140_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502140_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502140(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502140_TranlateX,p_o502140_TranlateY,p_o502140_TranlateZ),vec3(p_o502140_RotateX,p_o502140_RotateY,p_o502140_RotateZ)*6.28318530718)/p_o502140_scale;\n\tfloat sdf=o502140_input_sdf3d(uv.xyz, _seed_variation_)*p_o502140_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502140_AmbientOcclusion*o502140_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502140_Alpha*o502140_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502140_Normal*o502140_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502140_Emission*o502140_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502140_Roughness*o502140_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502140_Specular*o502140_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502140_Metallic*o502140_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502140_BaseColor_r, p_o502140_BaseColor_g, p_o502140_BaseColor_b, p_o502140_BaseColor_a).rgb*o502140_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o502134_input_obj3d(vec4 p, float _seed_variation_) {\nvec4 o502157_0_1_v4v4 = PBRObjectMaker_o502157((p), _seed_variation_);\nvec4 o502140_0_1_v4v4 = PBRObjectMaker_o502140((p), _seed_variation_);\nvec4 o502161_0_1_v4v4 = mfsdf3d_smooth_union(o502157_0_1_v4v4, o502140_0_1_v4v4,p_o502161_k);\n\nreturn o502161_0_1_v4v4;\n}\nconst float p_o502156_xyz = 0.799000000;\nconst float p_o502156_x = 1.000000000;\nconst float p_o502156_y = 1.000000000;\nconst float p_o502156_z = 1.000000000;\n#define p_o502155_ax (f1*360.0-180.0+f2*20.0+sin(iTime*0.9)*50.0*f9)\n#define p_o502155_ay (f3*360.0-180.0+f4*20.0+sin(iTime*0.8)*50.0*f9)\n#define p_o502155_az (f5*360.0-180.0+f6*20.0+sin(iTime)*50.0*f9)\n#define p_o502153_smooth (max(f8*0.05,0.001))\n#define p_o502154_x (f7*0.5+0.1)\nconst float p_o502154_y = 0.256000000;\nconst float p_o502154_z = 0.202000000;\nvec4 o502134_input_trans3d(vec4 p, float _seed_variation_) {\nvec4 o502152_0_1_v4v4 = (vec4((vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).xyz-vec3(p_o502154_x, p_o502154_y, p_o502154_z),(vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).w));\nvec4 o502154_0_1_v4v4 = o502152_0_1_v4v4;\nvec4 o502153_0_1_v4v4 = o502154_0_1_v4v4;\nvec4 o502155_0_1_v4v4 = o502153_0_1_v4v4;\nvec4 o_o502156_0=o502155_0_1_v4v4;vec4 o502156_0_1_v4v4 = vec4(o_o502156_0.xyz,(p).w/min(min(p_o502156_x, p_o502156_y), p_o502156_z)/p_o502156_xyz);\n\nreturn o502156_0_1_v4v4;\n}\nfloat o502134_input_custombool(vec2 uv, float _seed_variation_) {\n\nreturn min((uv).x,(uv).y);\n}\n\nvec4 for_fold_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n  }\n  vec4 o=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  return vec4(o.xyz,o.w/p.w);\n}\n\nvec4 for_min_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\td.w=d.w/p.w;\n\tm=m.w<d.w?m:d;\n  }\n  return m;\n}\n\nvec4 for_custom_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\tfloat a=m.w;\n\tfloat b=d.w/p.w;\n\tfloat v=o502134_input_custombool(vec2(a,b), _seed_variation_);\n    float e=0.001;\n\tvec2 n=normalize(vec2(o502134_input_custombool(vec2(a+e,b), _seed_variation_)-o502134_input_custombool(vec2(a-e,b), _seed_variation_),\n                          o502134_input_custombool(vec2(a,b+e), _seed_variation_)-o502134_input_custombool(vec2(a,b-e), _seed_variation_)));\t\t\t\t\n\tm=vec4(mix(m.xyz,d.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),v);\n  }\n  return vec4(m.xyz,m.w/(1.0+p_o502134_Correction));\n}\nvec4 o502144_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o502134_0_1_v4v4 = for_fold_o502134(vec4((vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).xyz,1.0),(vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).w, _seed_variation_);\nvec4 o502167_0_1_v4v4 = o502134_0_1_v4v4;\n\nreturn o502167_0_1_v4v4;\n}\nvec3 o502144_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o502144_SunX,p_o502144_SunY,-p_o502144_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o502144(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o502144_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o502144_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o502144_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o502144_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o502144(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o502144_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o502144( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o502144_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o502144( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = o502144_input_mfsdf(vec4( ro + rd*t ,0.0), _seed_variation_).w;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o502144(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.1))*6.0),(sin(iTime*0.03)+2.0),(cos(sin(iTime*0.1))*4.0))*p_o502144_CamZoom;\n\tvec3 lookat=vec3(p_o502144_LookAtX,p_o502144_LookAtY,p_o502144_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o502144_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o502144(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o502144_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o502144_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o502144_SunX,p_o502144_SunY,p_o502144_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o502144(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o502144(p,n, _seed_variation_),p_o502144_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o502144(p,light,0.05,5.0, _seed_variation_),p_o502144_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o502144_AmbLight)),max(l,p_o502144_AmbLight))*max(cAO,p_o502144_AmbLight)*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o502144(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o502144(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o502144_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o502144_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o502144_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o502144_Gamma));\n}\n\n\n\n\nvec3 shader(vec2 fragCoord){\n    \n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o502144_0_1_rgb = raymarch_o502144((UV), _seed_variation_);\n\n    return vec3(o502144_0_1_rgb);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    fragColor = vec4(shader(fragCoord),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 605, 605, 909], [2216, 2287, 2320, 2320, 2493], [2619, 2639, 2675, 2917, 3909], [3909, 3909, 3963, 3963, 4031], [4033, 4033, 4085, 4085, 4447], [4449, 4449, 4509, 4509, 4579], [4581, 4581, 4639, 4639, 5028], [5030, 5030, 5091, 5091, 5159], [5161, 5161, 5220, 5220, 5614], [5614, 5614, 5648, 5648, 5952], [5984, 5984, 6019, 6019, 6108], [6132, 6206, 6241, 6241, 6358], [6360, 6360, 6393, 6393, 6689], [6691, 6691, 6727, 6727, 6934], [6936, 6936, 6971, 6971, 7180], [7182, 7182, 7219, 7219, 7308], [7310, 7310, 7360, 7360, 7907], [7909, 7909, 7957, 7957, 8227], [9668, 9668, 9736, 9736, 9757], [9758, 9758, 9826, 9826, 9841], [9842, 9842, 9910, 9910, 9925], [9926, 9926, 9995, 9995, 10010], [10011, 10011, 10078, 10078, 10107], [10108, 10108, 10173, 10173, 10202], [10203, 10203, 10268, 10268, 10283], [10284, 10284, 10360, 10360, 10375], [10376, 10376, 10435, 10435, 10463], [10929, 10929, 10991, 10991, 12621], [13855, 13855, 13929, 13929, 14210], [14212, 14212, 14296, 14296, 14346], [14347, 14347, 14415, 14415, 14810], [14811, 14811, 14879, 14879, 14894], [14895, 14895, 14963, 14963, 14978], [14979, 14979, 15048, 15048, 15063], [15064, 15064, 15131, 15131, 15160], [15161, 15161, 15226, 15226, 15255], [15256, 15256, 15321, 15321, 15336], [15337, 15337, 15413, 15413, 15428], [15429, 15429, 15488, 15488, 15516], [15982, 15982, 16044, 16044, 17674], [17674, 17674, 17732, 17732, 17996], [18515, 18515, 18575, 18575, 20561], [20562, 20562, 20627, 20627, 20657], [20659, 20659, 20730, 20730, 20911], [20913, 20913, 20983, 20983, 21253], [21255, 21255, 21328, 21328, 22078], [22079, 22079, 22137, 22137, 22482], [22483, 22483, 22541, 22541, 22667], [22669, 22745, 22798, 22798, 23188], [23190, 23190, 23289, 23289, 23484], [23486, 23531, 23605, 23605, 23907], [23909, 23954, 24063, 24063, 24415], [24417, 24417, 24473, 24473, 26525], [26530, 26530, 26558, 26558, 26874], [26878, 26878, 26934, 26934, 26982]]}
{"id": "NslBRN", "name": "Whoa is that a Mandelbrot Set?!!", "author": "trigophers", "description": "updated 9/2/23\ncredit to Inigo Quilez for continuous iteration count", "tags": ["fractal", "mandelbrot", "mountain"], "likes": 7, "viewed": 347, "published": 3, "date": "1644568448", "time_retrieved": "2024-07-30T17:04:12.805483", "image_code": "vec3 colorize(float its) {\n    float x = mod(its*6.0, 6.0);\n    return vec3((x<4.50)?smoothstep(4.0, 0.4, x):smoothstep(0.0, 1.4, x-4.6),\n                (x<4.25)?smoothstep(2.2, 0.1, x):smoothstep(0.0, 2.1, x-3.9),\n                (x<2.00)?smoothstep(1.1, 0.0, x):smoothstep(0.0, 4.0, x-2.0));\n}\n\nfloat mandelbrot(vec2 c) {\n    vec2 z = c;\n    float i = 0.;\n    for (i; i<512.; i++) {\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)+c;\n        if (dot(z,z) > 16.0) break;\n    }\n    if (i == 512.) {\n        return -1.;\n    }\n    \n    //iq wrote continuous iteration count\n    return i - log2(log2(dot(z,z))) + 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    vec3 col;\n    float di = distance(fragCoord/iResolution.y, vec2(0.5*(iResolution.x/iResolution.y), 0.5));\n \n    vec3 mcol;\n    vec2 tuv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    float d = iTime/5.;\n    vec2 n = vec2(tuv.x*cos(d)-tuv.y*sin(d), tuv.y*cos(d)+tuv.x*sin(d));\n    float revt = (sin(d)+1.)*7.+8.;\n    float z = (revt*revt/pow(2., revt));\n    float r = mandelbrot(n*z+vec2(-0.167426747312500013323, 1.04127240284375));\n    if (r<0.) {\n        mcol = vec3(0, 0, 0);\n    } else {\n        mcol = vec3(colorize(r/40.0+iTime/24.0));\n    }\n    \n    vec3 tcol = texture(iChannel0, uv).xyz;\n    \n    float s = smoothstep(0.0, 1.0, di);\n\n    fragColor = vec4((1.0-s)*mcol + s*tcol, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265358979\n\nfloat f(vec2 p, vec2 t) {\n    return cos(t.x+p.y+cos(t.y+PI*p.x));\n}\n\nfloat g(vec2 p, vec2 t) {\n    return cos(t.x+p.x+cos(t.y+PI*p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec3 dat = texture(iChannel0, tuv).xyz;\n    \n    float d = distance(vec2(f(uv*5.+dat.xy+sin(iTime/10.0), vec2(dat.x+dat.y, iTime+dat.x)), g(uv*5.+dat.xz, vec2(iTime/10.0, dat.z))), vec2(0));\n    vec3 col = vec3(d/(2.+dat/3.));\n\n    // Output to screen\n    fragColor = (vec4(col*vec3(dat.y+0.3, dat.z+0.2, dat.x+0.1),1.0)+vec4(dat, 1.0))/2.0;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 296], [298, 298, 324, 324, 615], [617, 617, 674, 674, 1441]]}
{"id": "Nssfz4", "name": "odos|Truchet Tiles v2", "author": "ErinZ", "description": "Truchet Tiles v2 with more types", "tags": ["2d"], "likes": 9, "viewed": 363, "published": 3, "date": "1644562391", "time_retrieved": "2024-07-30T17:04:13.560464", "image_code": "#define S(v,r) smoothstep( r, r+ 5./iResolution.y, v )\n#define s(v,r,sc) smoothstep(r+sc*3./iResolution.y,r-sc*3./iResolution.y, v)  \n\n\nvec2 hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) ); \n    return fract(sin(p)*43758.37); \n}\nfloat logo(vec2 uv);\n\nvec2 rotate(vec2 uv, float a){\n    vec2 q;\n    q.x = cos(a)*uv.x + sin(a)*uv.y;\n    q.y = -sin(a)*uv.x + cos(a)*uv.y; \n    return q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float scale = 5.+3.*iMouse.x/iResolution.y;\n    vec2 uv1 = uv*scale+vec2(iTime,0);//scale and tile\n    vec2 gv = fract(uv1)-.5;//grid uv\n    \n    vec3 col;\n    //if(gv.x>.48 ||gv.y>.48) col = vec3(1,0,.6);//grid line\n\n    vec2 n = hash(floor(uv1));\n    gv = rotate(gv,floor(n.x*4.)*1.5708);//n.x - random dirction\n    int ty = int(floor(n.y*6.));//n.y - random tile\n    \n    float w = 0.16666667;\n    \n    float m;\n    switch(ty){\n    case 0://2 arc\n    m = s(abs(length(gv-0.5)-0.5),w,scale)+s(abs(length(gv+0.5)-0.5),w,scale);break;\n    case 1://1 arc\n    m = s(abs(length(gv-0.5)-0.5),w,scale)+s(length(gv+vec2(0,.5)),w,scale)+s(length(gv+vec2(.5,0)),w,scale);break;\n    case 2://1 line\n    m = s(abs(gv.x),w,scale)+s(length(abs(gv)-vec2(.5,0)),w,scale);break;\n    case 3://t line\n    m = s(gv.x,w,scale)-s(length(abs(gv)-vec2(.5)),2.*w,scale)+s(length(gv+vec2(-.5,0)),w,scale);break;\n    case 4://+ line\n    m = 1.-s(length(abs(gv)-vec2(.5)),2.*w,scale);break;\n    case 5:\n    default:\n    //4pt\n    m = s(length(abs(gv)-vec2(0,.5)),w,scale)+s(length(abs(gv)-vec2(.5,0)),w,scale);break;\n    }\n    m = clamp(m,0.,1.);\n    \n    col += m*.6;\n    col =mix(col,vec3(1),logo(uv));\n    fragColor = vec4(col,1.0);\n}\n\n \nfloat logo(vec2 uv){\n    float n = S(.05,abs(length(uv-vec2(-1.23,0))-.12));\n    n *= 1.-S(-1.25,uv.x);\n    n =max(n, S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29)));\n    n += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\n    n += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\n    n += clamp((1.+S(-.6,uv.x)-S(.05,uv.y)),0.,1.)*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\n    n += clamp((1.-S(-.6,uv.x)+S(-.05,uv.y)),0.,1.)*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\n    return n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nssfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 154, 154, 261], [284, 284, 314, 314, 418], [421, 421, 478, 478, 1753], [1757, 1757, 1777, 1777, 2221]]}
{"id": "NslBR4", "name": "wall experiments", "author": "jorge2017a2", "description": "wall experiments", "tags": ["wallexperiments"], "likes": 11, "viewed": 266, "published": 3, "date": "1644551082", "time_retrieved": "2024-07-30T17:04:14.312453", "image_code": "///modificado por jorge2017a2\n//referencia\n//https://www.shadertoy.com/view/3sfGWB\n///by  StanislavPetrovV\n//https://github.com/StanislavPetrovV/Advanced_RayMarching\n//https://www.youtube.com/watch?v=2fcO9RUOGg4\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\n ///aportacion by ocb --11-feb-2022\n \nconst float FOV = 1.0;\nconst int MAX_STEPS = 128;\nconst float MAX_DIST = 100.;\nconst float EPSILON = 0.001;\n#define PI 3.14159265\n#define TAU (2.*PI)\n\n\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 normal) {\n    normal = abs(normal);\n    normal = pow(normal, vec3(5.0));\n    normal /= normal.x + normal.y + normal.z;\n    return (texture(tex, p.xy * 0.5 + 0.5) * normal.z +\n            texture(tex, p.xz * 0.5 + 0.5) * normal.y +\n            texture(tex, p.yz * 0.5 + 0.5) * normal.x).rgb;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdQuads( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n    vec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e3.y - e0.y*e3.x );\n    vec2 d = min( min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 \t   vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) )),\n                       vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 pared01(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);\n    vec3 p0=p;\n    p.x= opRep1D(p.x, 4.5 );\n    vec3 p1=p;\n    vec3 p2=p;\n    \n    vec2 uv=p1.xy;\n    vec2 uvRef=uv-vec2(0.1,0.2);\n    vec3 col=vec3(1.0);\n    vec3 bcol = vec3(0.55,0.55,0.6);\n    vec3 mcol = vec3(0.25,0.25,0.3);\n    \n    \n    float bl0 = sdQuads(vec2(0.1,0.1),vec2(-0.1,0.15),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float bl1 = sdQuads(vec2(0.5,-0.05),vec2(0.1,0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float bl2 = sdQuads(vec2(-0.1,0.05),vec2(-0.3,-0.1),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float bl3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.6,-0.3),vec2(-0.6,-1.5),vec2(-0.3,-1.5),uvRef);\n    float blD = unionSDF(bl0,bl1);\n    float blD1 = unionSDF(bl2,bl3);\n    float blD2 = unionSDF(blD,blD1);\n    \n    uv=p2.xy;\n    uvRef=uv-vec2(1.25,0.2);\n    float ml0 = sdQuads(vec2(0.1,-0.2),vec2(-0.1,-0.25),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float ml1 = sdQuads(vec2(0.5,0.1),vec2(0.1,-0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float ml2 = sdQuads(vec2(-0.1,-0.2),vec2(-0.3,-0.15),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float ml3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.65,-0.3),vec2(-0.65,-1.5),vec2(-0.3,-1.5),uvRef);\n    float mlD = unionSDF(ml0,ml1);\n    float mlD1 = unionSDF(ml2,ml3);\n    float mlD2 = unionSDF(mlD,mlD1);\n    \n    float dfin = unionSDF(blD2,mlD2);\n    float  d1=sdBox( uv-vec2(0.25,-0.45), vec2(0.25,0.25) );\n    float  d2=sdBox( uv-vec2(1.1,-0.45), vec2(0.25,0.25) );\n    dfin= differenceSDF(dfin, d1);\n    dfin= differenceSDF(dfin, d2);\n    \n    p.z=abs(p.z)-1.0;\n    float d3=sdBox(p, vec3(1.5,1.5,0.15) );\n    dfin= intersectSDF(dfin, d3);\n    float d4=sdBox(p-vec3(0.0,-0.2,0.0), vec3(2.5,0.05,0.15) );\n    float d5=sdBox(p-vec3(0.0,-1.0,0.0), vec3(2.5,0.25,0.15) );\n    dfin = unionSDF(dfin,d4);\n    dfin = unionSDF(dfin,d5);    \n      res =opU2(res, vec2(dfin,100.0));\n      return res;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec3 tmp, op = p;\n    vec2 res;\n    // plane\n    float planeDist=p.y+1.0;\n    //float planeID = 2.0;\n    float planeID = 101.0;\n    vec2 plane = vec2(planeDist, planeID);\n    res=plane;\n    vec2 re1= pared01(p);\n    res =opU2(res, re1);\n    return res;\n}\n\nvec3 getMaterial(vec3 p, float id, vec3 normal) {\n    vec3 m;\n    switch (int(id)) \n    {\n        case 1:\n        m = vec3(0.9, 0.0, 0.0); break;\n\n        case 2:\n        m = vec3(0.2 + 0.4 * mod(floor(p.x*0.5) + floor(p.z*0.5), 2.0)); break;\n\n        case 3:\n            m = vec3(0.7, 0.8, 0.9); break;\n\n        case 4:\n            vec2 i = step(fract(0.5 * p.xz), vec2(1.0 / 10.0));\n            m = ((1.0 - i.x) * (1.0 - i.y)) * vec3(0.37, 0.12, 0.0); break;\n        case 100:\n            m = triPlanar(iChannel0, p , normal); m=m*m; break;\n        case 101:\n            m = triPlanar(iChannel1, p , normal);  break;\n            \n      }  \n    return m;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    vec2 hit, object;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + object.x * rd;\n        hit = map(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = map(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal) {\n    float occ = 0.0;\n    float weight = 1.0;\n    for (int i = 0; i < 8; i++) {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = map(p + normal * len).x;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\nvec3 getLight(vec3 p, vec3 rd, float id, vec3 plightPos ) \n{   vec3 lightPos = plightPos;\n    vec3 L = normalize(lightPos - p);\n    vec3 N = getNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n    vec3 color = getMaterial(p, id, N);\n    vec3 specColor = vec3(0.6, 0.5, 0.4);\n    vec3 specular = 1.3 * specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = 0.9 * color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = 0.05 * color;\n    vec3 fresnel = 0.15 * color * pow(1.0 + dot(rd, N), 3.0);\n\n    // shadows\n    float shadow = getSoftShadow(p + N * 0.02, normalize(lightPos));\n    // occ\n    float occ = getAmbientOcclusion(p, N);\n    // back\n    vec3 back = 0.5 * color * clamp(dot(N, -L), 0.0, 1.0);\n    return  (back+ambient + fresnel) * occ + (specular * occ + diffuse) * shadow;    \n}\n\nmat3 getCam(vec3 ro, vec3 lookAt) {\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0, 1, 0), camF));\n    vec3 camU = cross(camF, camR);\n    return mat3(camR, camU, camF);\n}\n\nvoid mouseControl(inout vec3 ro) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    pR(ro.yz, m.y * PI * 0.39 - 0.39);\n    pR(ro.xz, m.x * TAU);\n}\n\nvec3 render(vec2 uv) \n{\n    vec3 col = vec3(0);\n    vec3 background = vec3(0.5, 0.8, 0.9);\n    \n     float t;\n    t=mod(iTime*0.5,500.0);\n        \n    vec3 ro=vec3(0.0,-0.5,0.15);\n   ro.x=t;\n    //mouseControl(ro);\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   rd= rotate_y(rd, radians(90.0));\n    vec3 light_pos1= vec3(-10.0, 120.0, 10.0 );\n \tvec3 light_pos2= vec3(10.0, 30.0, -25.0 );\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec2 object = rayMarch(ro, rd);\n\n    if (object.x < MAX_DIST) {\n        vec3 p = ro + object.x * rd;\n        col += getLight(p, rd, object.y,light_pos2);\n        //col += getLight(p, rd, object.y,light_pos1);\n        //col/=2.0;\n        // fog\n        col = mix(col, background, 1.0 - exp(-1e-7 * object.x * object.x * object.x));\n    } else \n    {\n        //col += background - max(0.7 * rd.y, 0.0);\n        ///by ocb --11-feb-2022\n          col += smoothstep(.45,.9,texture(iChannel1,vec2(.1/rd.y-.02*iTime,.3*rd.z)).z) + background - max(0.7 * rd.y, 0.0);\n    }\n    return col;\n}\n\nvec2 getUV(vec2 offset, vec2 frag) \n{   return (2.0 * (frag.xy + offset) - iResolution.xy) / iResolution.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec3 color= render( getUV(vec2(0.0), fragCoord)  );  \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 627, 627, 711], [714, 714, 750, 750, 795], [796, 806, 853, 853, 880], [881, 881, 924, 924, 951], [952, 952, 1000, 1000, 1028], [1040, 1040, 1074, 1074, 1170], [1171, 1171, 1205, 1205, 1296], [1297, 1297, 1331, 1331, 1422], [1423, 1423, 1457, 1457, 1552], [1554, 1554, 1586, 1586, 1628], [1631, 1631, 1683, 1683, 1966], [1968, 1968, 1993, 1993, 2012], [2013, 2013, 2038, 2038, 2057], [2058, 2058, 2094, 2094, 2122], [2124, 2124, 2161, 2161, 2235], [2237, 2237, 2313, 2313, 3109], [3111, 3111, 3133, 3133, 5017], [5020, 5020, 5038, 5038, 5297], [5299, 5299, 5348, 5348, 5956], [5958, 5958, 5991, 5991, 6258], [6260, 6260, 6284, 6284, 6434], [6436, 6436, 6480, 6480, 6802], [6804, 6804, 6852, 6852, 7140], [7142, 7142, 7202, 7202, 7956], [7958, 7958, 7993, 7993, 8166], [8168, 8168, 8202, 8202, 8310], [8312, 8312, 8335, 8335, 9336], [9338, 9338, 9375, 9375, 9447], [9449, 9449, 9506, 9506, 9660]]}
{"id": "sdffR4", "name": "MFSDF Fractal", "author": "PauloFalcao", "description": "Fractal using MFSDF scene description, and using the awesome Good sliders from shader XtG3Rt\nBecause of the 18 sliders it takes sometime to compile... \nLeft Sliders are the fractal parameters, bottom one is the animation speed\nRight Sliders are colors", "tags": ["fractal", "mfsdf"], "likes": 28, "viewed": 696, "published": 3, "date": "1644538796", "time_retrieved": "2024-07-30T17:04:15.569094", "image_code": "// MFSDF Fractal\n// By PauloFalcao\n//\n// This is a fractal using the MSSDF scene description explained here\n// https://www.shadertoy.com/view/7dySRc\n//\n// Use https://www.shadertoy.com/view/NdXfzM to shade presets\n//\n// Made in the node base material maker\n// Sliders from the awesome Good shader https://www.shadertoy.com/view/XtG3Rt\n//\n// Youtube video playing with this on material maker\n// https://www.youtube.com/watch?v=LbkMJ1xJFQ0\n//\n// The original Material Maker file is here\n// https://www.materialmaker.org/material?id=362\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n\nvoid mainImage( out vec4 o, in vec2 p ){\n    o = texture(iChannel0,p.xy/iResolution.xy); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// MFSDF Fractal\n// By PauloFalcao\n//\n// This is a fractal using the MSSDF scene description explained here\n// https://www.shadertoy.com/view/7dySRc\n//\n// Made in the node base material maker\n// Sliders from the awesome Good shader https://www.shadertoy.com/view/XtG3Rt\n//\n// Youtube video playing with this on material maker\n// https://www.youtube.com/watch?v=LbkMJ1xJFQ0\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n\n\n#define SEED_VARIATION 0.0\n\nfloat f1,f2,f3,f4,f5,f6,f7,f8,f9;\nfloat f10,f11,f12,f13,f14,f15,f16,f17,f18;\n\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}float mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o502144_LookAtX = 0.000000000;\nconst float p_o502144_LookAtY = 0.000000000;\nconst float p_o502144_LookAtZ = 0.000000000;\nconst float p_o502144_CamD = 1.500000000;\nconst float p_o502144_CamZoom = 1.000000000;\nconst float p_o502144_SunX = 2.500000000;\nconst float p_o502144_SunY = 2.500000000;\nconst float p_o502144_SunZ = 2.500000000;\nconst float p_o502144_AmbLight = 0.250000000;\nconst float p_o502144_AmbOcclusion = 1.000000000;\nconst float p_o502144_Shadow = 1.000000000;\nconst float p_o502144_Gamma = 1.300000000;\nconst float p_o502134_Correction = 0.000000000;\nconst float p_o502161_k = 0.199000000;\n#define p_o502157_BaseColor_r (f13)\n#define p_o502157_BaseColor_g (f14)\n#define p_o502157_BaseColor_b (f15)\nconst float p_o502157_BaseColor_a = 1.000000000;\nconst float p_o502157_Metallic = 0.002000000;\nconst float p_o502157_Specular = 0.500000000;\nconst float p_o502157_Roughness = 0.000000000;\nconst float p_o502157_Emission = 0.000000000;\nconst float p_o502157_Normal = 0.000000000;\nconst float p_o502157_Alpha = 0.000000000;\nconst float p_o502157_AmbientOcclusion = 0.000000000;\nconst float p_o502157_scale = 0.963000000;\nconst float p_o502157_TranlateX = 0.148000000;\nconst float p_o502157_TranlateY = -0.386000000;\nconst float p_o502157_TranlateZ = 0.295000000;\nconst float p_o502157_RotateX = 0.000000000;\nconst float p_o502157_RotateY = 0.000000000;\nconst float p_o502157_RotateZ = 0.000000000;\nvec3 o502157_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o502157_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502157_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502157_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502157_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502157(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502157_TranlateX,p_o502157_TranlateY,p_o502157_TranlateZ),vec3(p_o502157_RotateX,p_o502157_RotateY,p_o502157_RotateZ)*6.28318530718)/p_o502157_scale;\n\tfloat sdf=o502157_input_sdf3d(uv.xyz, _seed_variation_)*p_o502157_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502157_AmbientOcclusion*o502157_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502157_Alpha*o502157_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502157_Normal*o502157_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502157_Emission*o502157_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502157_Roughness*o502157_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502157_Specular*o502157_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502157_Metallic*o502157_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502157_BaseColor_r, p_o502157_BaseColor_g, p_o502157_BaseColor_b, p_o502157_BaseColor_a).rgb*o502157_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\n#define p_o502140_BaseColor_r (f10)\n#define p_o502140_BaseColor_g (f11)\n#define p_o502140_BaseColor_b (f12)\nconst float p_o502140_BaseColor_a = 1.000000000;\nconst float p_o502140_Metallic = 0.000000000;\nconst float p_o502140_Specular = 0.500000000;\nconst float p_o502140_Roughness = 0.000000000;\nconst float p_o502140_Emission = 0.000000000;\nconst float p_o502140_Normal = 0.000000000;\nconst float p_o502140_Alpha = 0.000000000;\nconst float p_o502140_AmbientOcclusion = 0.000000000;\nconst float p_o502140_scale = 0.984000000;\nconst float p_o502140_TranlateX = -0.083000000;\nconst float p_o502140_TranlateY = 0.147000000;\nconst float p_o502140_TranlateZ = 0.000000000;\nconst float p_o502140_RotateX = 0.000000000;\nconst float p_o502140_RotateY = 0.000000000;\nconst float p_o502140_RotateZ = 0.000000000;\nconst float p_o502162_scale = 0.579000000;\n#define p_o502162_scale_x (f16*32.0)\n#define p_o502162_scale_y (f17*32.0)\n#define p_o502162_scale_z (f18*32.0)\nconst float p_o502162_transx = 0.000000000;\nconst float p_o502162_transy = 0.000000000;\nconst float p_o502162_transz = 0.000000000;\nconst float p_o502162_persistence = 0.500000000;\nconst float p_o502162_brightness = 0.000000000;\nconst float p_o502162_contrast = 4.139000000;\nfloat o502162_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o502162_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o502140_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec3 o502162_0_out = vec3(o502162_bc(o502162_fbm((p).xyz*vec3(p_o502162_scale_x,p_o502162_scale_y,p_o502162_scale_z)*0.5*p_o502162_scale+vec3(p_o502162_transx,p_o502162_transy,p_o502162_transz),p_o502162_persistence, _seed_variation_)*0.5+0.5,p_o502162_contrast,p_o502162_brightness, _seed_variation_));vec3 o502162_0_1_tex3d = clamp(o502162_0_out,vec3(0),vec3(1));\n\nreturn o502162_0_1_tex3d;\n}\nfloat o502140_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502140_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502140_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502140_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502140(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502140_TranlateX,p_o502140_TranlateY,p_o502140_TranlateZ),vec3(p_o502140_RotateX,p_o502140_RotateY,p_o502140_RotateZ)*6.28318530718)/p_o502140_scale;\n\tfloat sdf=o502140_input_sdf3d(uv.xyz, _seed_variation_)*p_o502140_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502140_AmbientOcclusion*o502140_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502140_Alpha*o502140_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502140_Normal*o502140_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502140_Emission*o502140_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502140_Roughness*o502140_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502140_Specular*o502140_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502140_Metallic*o502140_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502140_BaseColor_r, p_o502140_BaseColor_g, p_o502140_BaseColor_b, p_o502140_BaseColor_a).rgb*o502140_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o502134_input_obj3d(vec4 p, float _seed_variation_) {\nvec4 o502157_0_1_v4v4 = PBRObjectMaker_o502157((p), _seed_variation_);\nvec4 o502140_0_1_v4v4 = PBRObjectMaker_o502140((p), _seed_variation_);\nvec4 o502161_0_1_v4v4 = mfsdf3d_smooth_union(o502157_0_1_v4v4, o502140_0_1_v4v4,p_o502161_k);\n\nreturn o502161_0_1_v4v4;\n}\nconst float p_o502156_xyz = 0.799000000;\nconst float p_o502156_x = 1.000000000;\nconst float p_o502156_y = 1.000000000;\nconst float p_o502156_z = 1.000000000;\n#define p_o502155_ax (f1*360.0-180.0+f2*20.0+sin(iTime*0.9)*50.0*f9)\n#define p_o502155_ay (f3*360.0-180.0+f4*20.0+sin(iTime*0.8)*50.0*f9)\n#define p_o502155_az (f5*360.0-180.0+f6*20.0+sin(iTime)*50.0*f9)\n#define p_o502153_smooth (max(f8*0.05,0.001))\n#define p_o502154_x (f7*0.5+0.1)\nconst float p_o502154_y = 0.256000000;\nconst float p_o502154_z = 0.202000000;\nvec4 o502134_input_trans3d(vec4 p, float _seed_variation_) {\nvec4 o502152_0_1_v4v4 = (vec4((vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).xyz-vec3(p_o502154_x, p_o502154_y, p_o502154_z),(vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).w));\nvec4 o502154_0_1_v4v4 = o502152_0_1_v4v4;\nvec4 o502153_0_1_v4v4 = o502154_0_1_v4v4;\nvec4 o502155_0_1_v4v4 = o502153_0_1_v4v4;\nvec4 o_o502156_0=o502155_0_1_v4v4;vec4 o502156_0_1_v4v4 = vec4(o_o502156_0.xyz,(p).w/min(min(p_o502156_x, p_o502156_y), p_o502156_z)/p_o502156_xyz);\n\nreturn o502156_0_1_v4v4;\n}\nfloat o502134_input_custombool(vec2 uv, float _seed_variation_) {\n\nreturn min((uv).x,(uv).y);\n}\n\nvec4 for_fold_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n  }\n  vec4 o=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  return vec4(o.xyz,o.w/p.w);\n}\n\nvec4 for_min_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\td.w=d.w/p.w;\n\tm=m.w<d.w?m:d;\n  }\n  return m;\n}\n\nvec4 for_custom_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\tfloat a=m.w;\n\tfloat b=d.w/p.w;\n\tfloat v=o502134_input_custombool(vec2(a,b), _seed_variation_);\n    float e=0.001;\n\tvec2 n=normalize(vec2(o502134_input_custombool(vec2(a+e,b), _seed_variation_)-o502134_input_custombool(vec2(a-e,b), _seed_variation_),\n                          o502134_input_custombool(vec2(a,b+e), _seed_variation_)-o502134_input_custombool(vec2(a,b-e), _seed_variation_)));\t\t\t\t\n\tm=vec4(mix(m.xyz,d.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),v);\n  }\n  return vec4(m.xyz,m.w/(1.0+p_o502134_Correction));\n}\nvec4 o502144_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o502134_0_1_v4v4 = for_fold_o502134(vec4((vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).xyz,1.0),(vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).w, _seed_variation_);\nvec4 o502167_0_1_v4v4 = o502134_0_1_v4v4;\n\nreturn o502167_0_1_v4v4;\n}\nvec3 o502144_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o502144_SunX,p_o502144_SunY,-p_o502144_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o502144(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o502144_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o502144_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o502144_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o502144_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o502144(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o502144_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o502144( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o502144_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o502144( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = o502144_input_mfsdf(vec4( ro + rd*t ,0.0), _seed_variation_).w;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o502144(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.1))*6.0),(sin(iTime*0.03)+2.0),(cos(sin(iTime*0.1))*4.0))*p_o502144_CamZoom;\n\tvec3 lookat=vec3(p_o502144_LookAtX,p_o502144_LookAtY,p_o502144_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o502144_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o502144(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o502144_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o502144_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o502144_SunX,p_o502144_SunY,p_o502144_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o502144(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o502144(p,n, _seed_variation_),p_o502144_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o502144(p,light,0.05,5.0, _seed_variation_),p_o502144_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o502144_AmbLight)),max(l,p_o502144_AmbLight))*max(cAO,p_o502144_AmbLight)*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o502144(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o502144(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o502144_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o502144_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o502144_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o502144_Gamma));\n}\n\n\n\n\nvec3 shader(vec2 fragCoord){\n    \n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o502144_0_1_rgb = raymarch_o502144((UV), _seed_variation_);\n\n    return vec3(o502144_0_1_rgb);\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n//   Awesome slider lib from Good shadertoy.com/view/XtG3Rt START  //\n/////////////////////////////////////////////////////////////////////\nconst vec4 _sa=vec4(16777216.,65536.,256.,1.);const vec4 _sb=vec4\n(1./16777216.,1./65536.,1./256.,1.);vec4 _sc(int v){vec4 r=\nfloor(float(v)*_sb);r.yzw-=r.xyz*256.;return r;}float _sd(const in\nvec4 v){return dot(v,_sa);}vec4 _se(const in float v){bool n=sign(v)\n==-1.;vec4 r=floor(abs(v)*1000.*_sb);r.gba-=r.rgb*256.;if(n)r.r\n+=256.;return r;}float _sf(in vec4 v){float m=1.;if(v.r>=256.){v.r-=\n256.;m=-1.;}return dot(v,_sa)/1000.*m;}bool _sg(in vec2 p,in vec2 a)\n{return floor(p)==a;}void _sh(vec4 v,vec2 a,inout vec4 c,vec2 p){\nif(_sg(p,a))c=v;}vec4 _si(vec2 a){return texture(iChannel0,(floor(a)\n+0.5)/iChannelResolution[0].xy);}void _sj(int v,vec2 a,inout vec4 c,\nvec2 p){if(_sg(p,a))c=_sc(v);}float _sk(vec2 a){return _sd(_si(a));}\nvoid _sl(float v,vec2 a,inout vec4 c,vec2 p){if(_sg(p,a))c=_se(v);}\nfloat _sm(vec2 a){return _sf(_si(a));}float _sn(vec2 p,vec4 b){vec2\nd=abs(-b.xy-b.zw*.5 + p)-b.zw*.5;return max(d.x,d.y);}float _so(vec2\np,vec4 b,float r){vec2 s=b.zw*.5-vec2(r);vec2 d=abs(-b.xy-b.zw*.5+p)\n-s;return min(max(d.x,d.y),0.)+length(max(d,0.))-r;}float _sp\n(float n,float b){return mod(floor(n/exp2(floor(b))),2.);}float\n_sq(float n,float i){return mod(n/pow(10.,i),10.);}float _sr(int n\n,vec2 p){p=floor(p);int i=n==0?0x69996:n==1?0x62227:n==2?0xE168F:\nn==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:n==6?0x68E96:n==7?0xF1244:\nn==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;return\n_sp(float(i),mod(p.y,5.)*4.+3.-p.x);}float _ss(in float v,in\nfloat f,in vec2 p,vec2 l,int z){p-=l;p/=float(z);float n=floor(p.x/\n5.);p.x-=n*5.;if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.)return\n0.;if(sign(v)<0.){if(n==0.)return _sr(10,p);n-=1.;v=abs(v);}float i\n=floor(v)==0.?1.:floor(log(v)/2.302585)+1.;float c=i+f;if(f>0.)\n{v*=pow(10.,f);}if(i<=n){if(i==n)return _sr(11,p);n-=1.;}if(c<=n)\nreturn 0.;return _sr(int(_sq(v,c-n-1.)),p);}const vec2 _st=vec2(0,4)\n;float slider(in float id,in vec4 c,in vec2 l,in vec2 j,inout vec4 q,\ninout float u){float v=_sm(vec2(id,0));vec4 g=_si(vec2(id,3));float\nk=_sk(_st);float w=_so(floor(j),vec4(l,124,20),5.);w=max(-w-2.,w);\nif(g.x==0.){v=c.x;g.x=.05;_sl(v,vec2(id,0),q,j);}if(iMouse.z<=0.){g.g\n=0.;_sh(vec4(0),_st,q,j);}else if(_sn(iMouse.xy,vec4(l,120,20))<2.&&k\n==0.){g.g=.05;_sj(int(id),_st,q,j);}else if(g.g>0.&&k==id){float h=\nclamp(iMouse.x,l.x,l.x+120.)-l.x;v=mix(c.y,c.z,h/120.);v=floor(v/c.\nw)*c.w;_sl(v,vec2(id,0),q,j);}w=min(w,_so(floor(j),vec4(l+vec2(2,2),\n120.*(v-c.y)/(c.z-c.y),16),3.));u=min(u,-_ss(v,2.,j,l+vec2(128,8)\n,1));u=min(u,w);_sh(g,vec2(id,3),q,j);return v;}\n/////////////////////////////////////////////////////////////////////\n//   Awesome slider lib from Good shadertoy.com/view/XtG3Rt END    //\n//   Minified by PauloFalcao                                       //\n/////////////////////////////////////////////////////////////////////\n\n\n\nvoid drawSliders(inout vec4 col, in vec2 sp ){\n    \n    float xp;\n    float yp;\n    \n    //Number of sliders\n    float n_sliders=9.0;\n    \n    //Aux vars\n    float ui = 0.;\n\n    //left\n    xp=20.0;\n    yp=n_sliders*25.0;  \n    //    VarName     VarId     InitVal StartVal EndVal StepVal\n    f1 = slider(1.0, vec4(0.82,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f2 = slider(2.0, vec4(0.37,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f3 = slider(3.0, vec4(0.44,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f4 = slider(4.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f5 = slider(5.0, vec4(0.22,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f6 = slider(6.0, vec4(0.50,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f7 = slider(7.0, vec4(0.59,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f8 = slider(8.0, vec4(0.24,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f9 = slider(9.0, vec4(0.60,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);\n\n    xp=iResolution.x-170.0;\n    yp=n_sliders*25.0;\n    //right\n    //    VarName     VarId     InitVal StartVal EndVal StepVal\n    f10 = slider(10.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f11 = slider(11.0, vec4(0.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f12 = slider(12.0, vec4(0.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f13 = slider(13.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f14 = slider(14.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f15 = slider(15.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f16 = slider(16.0, vec4(0.50,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f17 = slider(17.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f18 = slider(18.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);\n\n\n\n    if(sp.y > 5.){\n        col = vec4(shader(sp), 1.0);\n    }\n\n    if(sp.y > 5.){//Slider  R    G    B\n        col = mix(col, vec4(1.0, 1.0, 1.0, 1.0), clamp(-ui, 0.0, 1.0));\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 p ){\n    o = p.y <= 5.? texture(iChannel0,p.xy/iResolution.xy) : vec4(0);\n    drawSliders(o, p);   \n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdffR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1264, 1264, 1304, 1304, 1355]]}
{"id": "sslfRH", "name": "Blob blob the blobby blob blob", "author": "SnoopethDuckDuck", "description": "was trying to play around with 4D stuff intersecting 3D space. idk what this is though, very messy code", "tags": ["raymarching", "template", "artofcode"], "likes": 23, "viewed": 583, "published": 3, "date": "1644516828", "time_retrieved": "2024-07-30T17:04:16.341030", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat sdBox(vec4 p, vec4 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min( max(max(p.x, p.y), max(p.z, p.w)), 0. );\n}\n\n#define pi 3.14159\n\nfloat shape(vec4 q) {\n    float as = 2.; \n    float ls = 0.5;\n    float t = 0.5;\n    //q.xw *= Rot(as * atan(q.x, q.w) + ls * length(q.xw) - 0. * iTime);// - 2. * pi / 3.);\n    //q.yw *= Rot(as * atan(q.y, q.w) + ls * length(q.yw) - 0. * iTime);\n    //q.zw *= Rot(as * atan(q.z, q.w) + ls * length(q.zw) - 0. * iTime);// + 2. * pi / 3.);\n    float m = 1.;\n    // fractal q.w (no idea what this does)\n    for (int i = 0; i<5; i++) {\n        q.w = sabs(q.w) - m;\n        m *= 0.5;\n    }\n    q.xy *= Rot(as * smin(q.w, q.z) + t * iTime);\n    q.yz *= Rot(as * smin(q.x, q.w) + t * iTime);\n    q.zw *= Rot(as * smin(q.y, q.x) + t * iTime);\n    q.wx *= Rot(as * smin(q.z, q.y) + t * iTime);\n    \n    // torus looks trippy as fuck but is buggy\n    /*\n    float r1 = 0.5;\n    float r2 = 0.3;\n    float d1 = length(q.xz) - r1;\n    float d2 = length(vec2(q.w, d1)) - r2;\n    */\n    // sharper box makes curves more distinguished\n    float b = 0.5 - 0.5 * thc(4., 0.5 * q.w + 0.25 * iTime);\n    float m1 = mix(0.2, 0.4, b);\n    float m2 = mix(0.7, 0.1, b);\n    float d = sdBox(q, vec4(m1)) - m2; \n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    float w = length(p) * 2. + 0.25 * iTime;\n\n    // tried using blacklemori's technique with q.w\n    // couldnt get it working outside of the sphere\n    float center = floor(w) + 0.5;\n   // float neighbour = center + ((w < center) ? -1.0 : 1.0);\n\n    vec4 q = vec4(p, w);\n    //float a = atan(p.x, p.z);\n    \n    float me = shape(q - vec4(0,0,0,center));\n    //float next = shape(q - vec4(0,0,0,neighbour)); // incorrect but looks okay\n    float d = me;//smin(me, next);\n    \n    float d2 = length(p) - 1.;\n   // d = -smin(d, -d2);\n    //d = max(d, d2);\n    return 0.7 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = z * GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        vec3 rdIn = refract(rd, n, 1./IOR);\n        \n        vec3 pEnter = p - n*SURF_DIST*30.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit);\n        \n        float fresnel = pow(1.+dot(rd, n), 3.);\n        col = 2.5 * vec3(fresnel);\n        col *= 0.55 + 0.45 * cross(nExit, n);\n        //col *= 1. - exp(-0.1 * dIn);\n        col = clamp(col, 0., 1.);\n       // col = 1.-col;\n       vec3 e = vec3(1.);\n        col *= (p.y + 0.95) * pal(1., e, e, e, vec3(0.,0.33,0.66)); //cba to lookup color\n        col *= 0.6 + 0.4 * n.y;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col += 0.04;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslfRH.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1557, 1557, 1586, 1586, 1667], [1670, 1670, 1699, 1699, 1792], [1814, 1814, 1835, 1835, 2915], [2917, 2917, 2940, 2940, 3517], [3519, 3519, 3562, 3562, 3777], [3779, 3779, 3803, 3803, 3993], [3995, 3995, 4045, 4045, 4236], [4238, 4238, 4295, 4295, 5613]]}
{"id": "fdfBz4", "name": "Mandelbroccolini", "author": "xenn", "description": "Custom mandelbox", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 10, "viewed": 361, "published": 3, "date": "1644516640", "time_retrieved": "2024-07-30T17:04:17.814091", "image_code": "\n// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/24.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .1\n        \t\t  + bloom(.2 * iResolution.y, .3, fragCoord) * .1;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime iTime/16.0\n#define Epsilon .003+(0.002*sin(iTime*18.82))\n#define RenderDistance 1.950\n#define Steps 222\n#define ShadowSteps 7\n#define AoSteps 9\n#define AoStrength .2\n#define GiSkipSteps 7\n#define GiStrength 0.33\n\nvec3 CamPos;\nvec3 CamDir;\nfloat CamFocalLength;\n\nfloat Power;\nfloat PhiShift;\nfloat ThetaShift;\n\nfloat distanceEstimation(vec3 pos) {\n    if(length(pos) > 1.5) return length(pos) - 1.2;\n    vec3 z = pos;\n    float dr = 1.0, r = 0.0, theta, phi;\n    for (int i = 0; i < 11; i++) {\n        r = length(z);\n        if (r>1.5) break;\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        theta = acos(z.z/r) * Power + ThetaShift;\n        phi = atan(z.y,z.x) * Power + PhiShift;\n        float sinTheta = sin(theta);\n        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 normalEstimation(vec3 pos){\n\tfloat dist = distanceEstimation(pos);\n\tvec3 xDir = vec3(dist, 0, 0);\n\tvec3 yDir = vec3(0, dist, 0);\n\tvec3 zDir = vec3(0, 0, dist);\n\treturn normalize(vec3(\tdistanceEstimation(pos + xDir),\n\t\t\t\t\t\t\tdistanceEstimation(pos + yDir),\n\t\t\t\t\t\t\tdistanceEstimation(pos + zDir))\n\t\t\t\t\t- vec3(dist));\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < Steps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon){\n            n = normalEstimation(pos);\n            for(int i = 0; i < 2; i++){\n        \t\tdist = 2.0*Epsilon - distanceEstimation(pos);\n                pos += n*dist;\n            }\n            return true;\n        }\n        pos += dir * dist;\n        if(length(pos-CamPos) > RenderDistance) break;\n    }\n    return false;\n}\n\nvec3 nee(vec3 pos, vec3 n, vec3 lDir, vec3 lColor, float lRadius){\n    vec3 pos0 = pos;\n    float minAngle = Pi;\n    float dnrd = dot(n, -lDir);\n    if(dnrd < 0.0) return vec3(0);\n    for(int i = 0; i < ShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon) return vec3(0.0);\n        pos -= lDir * dist * 10.0; //goes 10 times faster since we don't need details\n        if(length(pos-CamPos) > RenderDistance) break;\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return lColor * dnrd * min(minAngle/lRadius, 1.0);\n}\n\n\n\nvec3 directLight(vec3 pos, vec3 n){\n\tvec3 totLights = vec3(0.0);\n    //yellow light\n\ttotLights += nee(pos, n, normalize(vec3(-.5, -1, -1)), vec3(.7, .5, .3) *3.0, .1);\n    //purple light\n\ttotLights += nee(pos, n, normalize(vec3(.5, 1, -1)), vec3(.3, .3, .7) * 4.0, .1);\n\treturn totLights * 0.750;\n}\n\nvec3 rotateZ(vec3 v, float phi){\n    return vec3(cos(phi)*v.x - sin(phi)*v.y, cos(phi)*v.y + sin(phi)*v.x, v.z);\n}\n\nvec3 background(vec3 dir){\n    dir = rotateZ(dir, iTime / 3.0);\n    vec3 col = (texture(iChannel0, dir.xzy).rgb)/1.5;\n    col-= (texture(iChannel1, dir.xzy).rgb)/1.5;\n    col*= (texture(iChannel2, dir.xzy).rgb)/1.50;\n    col+=col;\n\treturn col*col + col;\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 oldPos = pos;\n    vec3 n, ambientColor = vec3(0.0), gi = vec3(0.0);\n    for(int i = 0; i < AoSteps; i++){\n        n = normalEstimation(pos);\n        pos += distanceEstimation(pos) * n;\n        ambientColor += background(n);\n        if(i != 0 && mod(float(i), float(GiSkipSteps)) == 0.0) gi += directLight(pos, n);\n    }\n    ambientColor /= float(AoSteps);\n    gi /= ceil(float(AoSteps)/float(GiSkipSteps) - 1.0);\n    float expectedDist = distanceEstimation(oldPos) * pow(2.0, float(AoSteps));\n    float ao = pow(length(pos-oldPos)/expectedDist, AoStrength);\n    return max(ao * ambientColor, vec3(0.0)) + GiStrength * gi;\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(background(dir), RenderDistance);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\n\n/*\n*/\n\n#define M_NONE -1.0\n#define M_NOISE -1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#define OCTAVES 2\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 128;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.001;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot((k1-q),k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nmat3 scale(float x,float y,float z){\n    return mat3(\n    vec3(x,0.,0.),vec3(0.,y,0.),vec3(0.,0.,z)\n    );\n}\n\nfloat head(vec3 sP){\n    float s1 = length(sP*scale(1.2,1.0,1.0)-vec3(0.0,0.5,0.0))-0.5;\n    float s2 = length(sP*scale(1.2,1.3,1.2)-vec3(0.0,0.12,0.15))-0.4;\n    float s3 = opSmU(s1,s2,0.2);\n    //float s5 = opSmU(s3,neck,0.1);\n    float s6 = sdCone((sP-vec3(0.,0.25,0.34))*rotateX(-2.1),0.22,0.2,0.0)-0.03;\n    float s7 = opSmU(s3,s6,0.1);\n    float s8 = length(sP-vec3(0.0,-0.08,0.27))-0.2;\n    float s9 = opSmU(s7,s8,0.1);\n    float s10 = length((vec3(abs(sP.x),sP.y,sP.z)-vec3(0.4,0.25,-0.03))*rotateY(0.37)*rotateZ(1341.6)*rotateX(1149.15)*scale(8.0,1.0,1.2))-0.12;\n    float s11 = opSmU(s9,s10,.05);\n    float s12 = length(sP-vec3(0.0,-0.14,0.56))-0.09;\n    float s13 = opSmS(s12,s11,0.1);\n    return s13;\n}\n\nfloat displace(vec3 sP,float geo){\n    float final;\n    if(geo<=0.01){\n        float disp = geo-(0.1*fbm(sP*3.0*rotateY(iTime+12.0*(0.3*(sin(sP.y*1.0+iTime*12.3))+0.6))+vec3(0.,0.,2.0*iTime))-0.195);\n    \tfinal = opSmS(disp,geo,0.3);\n    }else{\n        final = geo;\n    }\n    return final;\n}\n\n\nfloat sceneSDF(vec3 sP) {\n    vec3 sPh=sP*rotateY(noise(vec3(iTime*0.5))-0.5)*rotateX(0.1*noise(vec3(iTime*5.5+123.456))-0.09)*rotateZ(0.1*noise(vec3(iTime*0.5+222.111))-0.05);\n    \n\tfloat head = head(sPh);\n\n    float s4 = sdCapsule(sP-vec3(0.0,-0.5,-0.15),1.0,0.26);\n    float s14 = length(sP-vec3(0.0,-0.7,-0.18))-0.4;\n    float s15 = opSmU(s4,s14,0.1);\n    float s16 = length(vec3((sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s17 = opSmU(s15,s16,0.5);\n    float s16n = length(vec3(-(sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s18 = opSmU(s17,s16n,0.5);\n    float torso = opSmU(s18,s4,0.1);\n    torso-=0.03*noise(sP*8.0);\n    torso = displace(sP,torso);\n    head-=0.03*noise(sPh*8.0);\n    head = displace(sPh,head);\n    float final=opSmU(torso,head,0.01);\n\n    return final;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth;\n    float dd=0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = (sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth=dd;\n        }else if(dist>MAX_DIST){\n\t\t\treturn dd;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=3;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))/d);\n    }\n    return ao;\n}\n\n//    fragColor = vec4(color, 1.0);\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(vec3(0), FocalDistance);\n        return;\n    }\n    \n    CamPos = vec3(1.0, -0, 01.0);\n    CamDir = normalize(vec3(-2, -.3, -1));\n    CamFocalLength = 2.5+(01.0*cos(iTime));\n    \n    Power = 3.0 + 6.0 * abs(sin(iTime*1.0));\n    ThetaShift = iTime * 3.0;\n    PhiShift = iTime * 2.0;\n    \n    vec2 screenPos = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n    vec3 camX = normalize(vec3(-CamDir.y, CamDir.x, 0.0));\n    vec3 camY = cross(camX, CamDir);\n    vec3 centerSensor = CamPos - CamDir * CamFocalLength;\n    vec3 posOnSensor = centerSensor + camX * screenPos.x + camY * screenPos.y;\n    vec3 dir = normalize(CamPos - posOnSensor);\n    \n    vec4 colorAndDepth = colorAndDepth(CamPos, dir);\n    \n//    fragColor = vec4(max(colorAndDepth.rgb, vec3(0.0)), max(min(colorAndDepth.a, RenderDistance), 0.0));\n//}\n\tvec3 dirt = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf = shortestDistanceToSurface(eye, dirt);\n    if(sdf>MAX_DIST || sdf==0.0){\n        fragColor = vec4(0.0);\n        return;\n    }\n    float dist = sdf;\n    vec3 p = eye + dist * dirt;\n    vec3 N = eN(p);\n    float occ = 1.0-AO(p,N);\n\n    vec3 ref = (reflect(dirt,N));\n    color=(texture(iChannel0,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n    color*=(texture(iChannel1,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n        if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(vec3(0), FocalDistance);\n        return;\n    }\n    \n    CamPos = vec3(2.50+(1.0*sin(iTime/2.)), 0, 0.50);\n    CamDir = normalize(vec3(-2, -.3, -1));\n    CamFocalLength = (2.0+(1.0*cos(iTime)));\n    \n    Power = 7.0 + 5.0 * abs(sin(iTime/8.0));\n    ThetaShift = iTime * 3.0;\n    PhiShift = iTime * 4.0;\n    \n/*    vec2 screenPos = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n    vec3 camX = normalize(vec3(-CamDir.y, CamDir.x, 0.0));\n    vec3 camY = cross(camX, CamDir);\n    vec3 centerSensor = CamPos - CamDir * CamFocalLength;\n    vec3 posOnSensor = centerSensor + camX * screenPos.x + camY * screenPos.y;\n    vec3 dir = normalize(CamPos - posOnSensor);\n    \n    vec4 colorAndDepth = colorAndDepth(CamPos, dir);\n  */  \n    fragColor = vec4(max(colorAndDepth.rgb, vec3(0.0)), max(min(colorAndDepth.a, RenderDistance), 0.0));\n}\n    \n\n", "buffer_a_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "/*extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.4, .6, .9) * factor + vec3(1.2) * (0.250*factor);\n    fragColor = vec4(col, 1.0);\n}\n*/\n//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 colo = vec3(.5 + (0.5 * sin(iTime/3.14159265359)), .5 + (0.5 * (cos(iTime/1.570796326795))), .5 + (0.5 * (sin(iTime/6.28318530718)))) * factor + vec3(1.2) * (1.0*factor);\n//    fragColor = vec4(col, 1.0);\n//}\n// float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 - (0.5 * (cos(iTime/6.28318530718))), .5 - (0.5 * (sin(iTime/3.14159265359))), .5 - (0.5 * (cos(iTime/1.570796326795)))) * factor * vec3(1.2) * (1.0+factor);\n//    fragColor = vec4(col, 1.0);\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(0,0,0)/ 255.0;\n    vec3 horizonCol = vec3(0,0,0)/ 255.0;\n//    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    vec3 groundCol = col;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 coloro = skyCol;\n    horizonCol = mix (vec3(0,0,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, colo, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, colo, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = mix(vec4(colo,1.0),vec4(col,1.0),vec4(colo,1.0));\n}", "cube_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.25\n#define LensRatio 0.05\n#define Margins 0.0\n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 2.0;\nconst float depthScale = 8.0;\nconst float maxDepth = 2.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 0.25*vec3(0.7,0.50,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(0.70,0.50,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = 0.2;\nconst float bloomRadius = 0.6;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 0.1;\nconst float fringeStart = 0.33;\n\n// Bokeh settings\nconst float bokehScale = 0.0075;\nconst float bokehClamp = 0.00125;\nconst float bokehForceSharp = 0.001;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 4.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 2.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 2.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 263], [265, 265, 322, 322, 628], [630, 630, 687, 687, 947]]}
{"id": "NsfBz8", "name": "FBM: Just Painting #2", "author": "Yusef28", "description": "Another fbm experiment using all the most rudimentary functions.", "tags": ["2d", "noise", "fbm", "texture", "shadow", "lighting", "abstract", "brownian", "stripes", "pattern", "marble", "aesthetic", "sparkles", "fractional"], "likes": 27, "viewed": 650, "published": 3, "date": "1644513539", "time_retrieved": "2024-07-30T17:04:18.661826", "image_code": "float noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nfloat rnd(float a){\n    return fract(sin(a*234.15)*41240.91);\n}\n#define pi acos(-1.)\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\n//vec3 wrap(vec3 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n\n\n  vec3 col =vec3(0.);// mix(vec3(0.2,0.3,0.5),vec3(0.2,0.6,0.4),((uv.y+0.5))*1.);\n  col += pow(mix(\n             texture(iChannel0, uv*2.5 +vec2(floor(iTime*0.2+uv.x),0.)*0.5).r,\n             texture(iChannel0, uv*2.5 +vec2(floor(iTime*0.2+1.+uv.x),0.)*0.5).r,\n             smoothstep(0.,1.,fract(iTime*0.2+uv.x))\n             ),9.);\n  \n\n  vec3 theColor;\n  \n  for(float i = 1.; i < 14.; i++){\n      vec2 altUV = uv;\n      float j = pow(rnd(i)*0.6,0.5);//i/19.;\n      theColor = vec3(j,j*j*j,j*j*0.27)+texture(iChannel1,uv).rrr*0.1;\n      uv = uv + vec2(iTime/(80.-i*2.),0.);\n      float faa = fbm(uv + i*100., 5., 6.);\n      faa = abs(faa);\n      float shadow = smoothstep(0.5,0.3,faa);\n      col=mix(col, theColor*0.1, shadow*0.5);\n      \n      //uv = uv + vec2(iTime/(80.+i*8.),0.);\n      float faa2 = fbm(uv + i*100. + .03, 5., 6.);\n      float shadow2 = clamp(smoothstep(0.4,0.36,faa2),0.,1.);\n      col=mix(col, vec3(0.), shadow2*0.7);\n      \n      float stripes = smoothstep(0.3,0.2,abs(fract((uv.y-uv.x)*(15.+i*1.3))-0.5));\n      \n      float f = max(0.,smoothstep(0.4,0.39,faa));\n      float g = max(0.,smoothstep(0.4,0.39,faa));\n      float h = clamp(g - max(0.,smoothstep(0.36,0.34,faa)),0.,1.);\n      \n      if(mod(i,3.)==0.){\n          stripes = 1.;\n          theColor = theColor.bgg;\n          theColor += pow(\n                          mix(\n                          texture(iChannel0, altUV*2.5 +vec2(floor(iTime*0.3+uv.x),0.)*0.5).r,\n                          texture(iChannel0, altUV*2.5 +vec2(floor(iTime*0.3+1.+uv.x),0.)*0.5).r,\n                          smoothstep(0.,1.,fract(iTime*0.3+uv.x))\n                      ),6.);\n                \n          theColor= mix(theColor,texture(iChannel1,uv*2.).r*theColor,0.5-h*0.5);\n      }\n      \n      \n      //float f = max(0.,smoothstep(0.4,0.39,faa));\n      col=mix(col,theColor-(stripes+texture(iChannel0,uv).rrr)*0.04,f);\n\n      //float g = max(0.,smoothstep(0.4,0.39,faa));\n     // float h = clamp(g - max(0.,smoothstep(0.36,0.34,faa)),0.,1.);\n      col=mix(col,theColor*0.9-texture(iChannel1,uv*8.).rrr*0.13,h);\n      \n  }\n\n    col *=1.3;\n \n\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 25.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.3); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig*1.4,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 83], [85, 85, 104, 104, 148], [170, 170, 193, 209, 531], [579, 579, 597, 597, 662], [663, 663, 701, 701, 912], [914, 932, 989, 989, 3434]]}
{"id": "7slfRH", "name": "odos|TurchetTile v1", "author": "ErinZ", "description": "TurchetTile v1 changes between line and arc", "tags": ["2d"], "likes": 2, "viewed": 282, "published": 3, "date": "1644511295", "time_retrieved": "2024-07-30T17:04:19.401846", "image_code": "#define S(v,r) smoothstep( r, r+ 5./iResolution.y, v )\n\n\nfloat hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) ); \n    float f = dot(p,vec2(82.291,19.283));\n    return fract(sin(f)*43758.37); \n}\nfloat logo(vec2 uv);\n\nfloat dist(vec2 p,float t){\n    p=abs(p);\n    return pow(pow(p.x,t)+pow(p.y,t),1./t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 uv1=uv*3. + vec2(iTime*0.4,0);\n    vec2 gv = fract(uv1)-.5;//grid uv\n    \n    vec3 col;\n    //if(gv.x>.48 ||gv.y>.48) col = vec3(1,0,.6);//grid line\n\n    if(hash(floor(uv1))<0.5) gv.x*=-1.;//add random\n    \n    \n    float t = clamp(sin(iTime),-.5,.5)+1.5;//1~2\n    float w = t*-0.1+0.35;\n    \n    float m = 2.-smoothstep(w,w+15./iResolution.y,abs(dist(gv-0.5,t)-0.5))\n                -smoothstep(w,w+15./iResolution.y,abs(dist(gv+0.5,t)-0.5));//patterrn\n         // m=smoothstep(w,w+15./iResolution.y,abs(dist(gv+.5,t)-.5));\n\n    //display\n    m *= S(0.75,1.-abs(uv.y));\n    col = mix(col,vec3(0,0,1),S(1.2,abs(uv.x))*S(0.6,abs(uv.y)));//bluebox\n    col =mix(col,vec3(1),m+logo(uv));//white patterns\n    \n    //col= vec3(0);\n    //col += smoothstep(0.,0.05,abs(dist(gv-0.5,1.)-0.5));\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n \nfloat logo(vec2 uv){\n    float n = S(.05,abs(length(uv-vec2(-1.23,0))-.12));\n    n *= 1.-S(-1.25,uv.x);\n    n =max(n, S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29)));\n    n += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\n    n += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\n    n += clamp((1.+S(-.6,uv.x)-S(.05,uv.y)),0.,1.)*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\n    n += clamp((1.-S(-.6,uv.x)+S(-.05,uv.y)),0.,1.)*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\n    return n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 76, 76, 225], [248, 248, 275, 275, 335], [338, 338, 395, 395, 1295], [1299, 1299, 1319, 1319, 1763]]}
{"id": "sdsfR8", "name": "SerenityOS Intro (Better AA)", "author": "kleinesFilmroellchen", "description": "SerenityOS tribute\n\nThis fork includes better anti-aliasing at the cost of performance. Increase ANTIALIAS_SIZE for better AA with worse performance.", "tags": ["sdf", "yinyang", "serenityos"], "likes": 2, "viewed": 216, "published": 3, "date": "1644503281", "time_retrieved": "2024-07-30T17:04:20.165803", "image_code": "// SerenityOS Ladyball, fragment shader by movAX13h, Feb. 2022\n// thanks to iq for sdCappedTorus and polynomial smooth min\n// thanks to IWBTShyGuy and Shane for support\n\n#define REFLECTION\n#define ANTIALIAS\n#define ANTIALIAS_SIZE 2\n#define ANTIALIAS_POINT_COUNT ((2*ANTIALIAS_SIZE+1) * (2*ANTIALIAS_SIZE+1))\n\n// --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pih 1.5707963267949\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time;\nvec3 sunPos;\nvec3 sun;\nfloat focus;\nfloat far;\n\nstruct Hit\n{\n\tfloat d;\n\tfloat ref;\n\tfloat spec;\n};\n\n    \nHit scene(vec3 p)\n{\n\tvec3 q = p;\n    \n\tHit h = Hit(1.0e6, 0.1, 0.2);\n    p.zy = rotate(p.zy, 0.7); // tilt\n    p.xy = rotate(p.xy, -3.0*iTime); // spin\n\n\t// yin-yang\n\tfloat a = max(sdCappedTorus(p, vec2(1.0, 0.0), 0.5, 0.4), sdSphere(p, 0.42));    \n    float b = sdSphere(p, 0.4);\n\th.d = smin(a, b, 0.01);\n    \n    // dots\n    float c = sdSphere(p-vec3(0.4, 0.0, 0.0), 0.14);\n    c = min(c, sdSphere(p-vec3(0.21, 0.32, 0.0), 0.1));\n    c = min(c, sdSphere(p-vec3(-0.1, 0.4, 0.0), 0.06));\n    c = max(c, sdSphere(p, 0.43));\n    h.d = smin(h.d, c, 0.01);\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 ray, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n    // determine color based on radius\n    float r = length(ray); // because we know object is at origin\n    vec3 col = vec3(0.0);\n    float red = smoothstep(0.4, 0.41, r)*smoothstep(0.43, 0.416, r);\n    col = mix(col, vec3(0.871,0.047,0.008), red);\n\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).gbr;\n}\n\nvec3 march(in vec2 fragCoord) \n{   \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) / resolution.y;\n\t\n\tfloat d = 6.0;\n\tfloat t = 1.2*sin(time*0.1+35.0) ;\n\tvec3 cp = vec3(d*cos(t), 0.8+sin(0.2*time), d*sin(t)); // circle center\n    \n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy/resolution.xy-0.5);\n\t\td = 8.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t// raymarch scene    \n    for(int i=0; i < 110; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d*0.8;\n\t\tray += dir * h.d*0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n    \n\tcol = colorize(ray, h.spec, n, dir, sun)*m;\n    \n\tif (dist < far && h.d < 0.0001)\n\t{\t\n        #ifdef REFLECTION\n\t\t// MIRROR (from obj to reflected normal direction)\t\t\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(ray2, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist/far);\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n    return col;\n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    time = iTime + 7.0;\n\tsunPos = vec3(10.0, 15.0, -10.0);\n\tsun = normalize(sunPos);\n\tfocus = 9.0+2.0*cos(0.35*time);\n\tfar = 30.0;    \n    \n    // simple anti-aliasing\n    #ifdef ANTIALIAS\n    vec3 col = vec3(0.0);\n    for(int i = -ANTIALIAS_SIZE; i <= ANTIALIAS_SIZE; ++i)\n    {\n        for(int j = -ANTIALIAS_SIZE; j <= ANTIALIAS_SIZE; ++j)\n        {\n            col += march(fragCoord+vec2(i,j)/float(ANTIALIAS_SIZE));\n        }\n    }\n    col /= float(ANTIALIAS_POINT_COUNT);\n    #else\n    vec3 col = march(fragCoord);\n    #endif    \n      \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.7; \n\tcol = pow(col, vec3(1.0 / 2.2)); // gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 397, 430, 430, 453], [455, 455, 525, 525, 665], [667, 667, 697, 697, 783], [785, 785, 824, 824, 913], [1032, 1032, 1051, 1051, 1602], [1604, 1604, 1625, 1625, 1804], [2377, 2377, 2399, 2399, 2441], [2443, 2443, 2475, 2475, 3988], [3997, 3997, 4055, 4055, 4766]]}
{"id": "fdsfR8", "name": "Shifting Maze [SmoothLife Fork]", "author": "kuza", "description": "The underlying render loop started as a fork / reused code from an implementation of SmoothLife.", "tags": ["smoothlife"], "likes": 3, "viewed": 260, "published": 3, "date": "1644489685", "time_retrieved": "2024-07-30T17:04:21.090331", "image_code": "const vec3 CellColor = vec3(0.7, 0.2, 0.5);\nconst vec3 RingColor = vec3(0.18264283284, 0.09533356, 0.41);\nconst vec3 DiskColor = vec3(-0.11, -0.2, -0.17);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);\n    \n    float c = 1.0 - buffer.z;\n    float c2 = 1. - texture(iChannel0, uv + .5/iResolution.xy).y;\n    color += vec3(0.9132141642, 0.4766678, 1.0)*max(c2*c2 - c*c, 0.)*4.;\n    \n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//Conventions:\n// x component = outer radius / ring\n// y component = inner radius / disk\n/*\n   _\n /   \\\n|  O  |\n \\ _ /\n*/\nconst float PI = 3.14159265358979323846264338327950288419716939937511;\nconst float dt = 0.093157;\n\n\nconst vec2 r = vec2(11.93, 3.53);\n\n// SmoothLifeL rules\nconst float b1 = 0.51024;\nconst float b2 = 0.72048;\nconst float d1 = 0.84096;\nconst float d2 = 0.88192;\n\nconst float alpha_n = 0.1765;\nconst float alpha_m = 0.3439;\n/*------------------------------*/\n\nconst float KEY_SPACE  = 32.5/256.0;\n\n\n// 1 out, 3 in... <https://www.shadertoy.com/view/4djSRW>\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+1.3819);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n\n/* ---------------- Sigmoid functions ------------------------------------ */\n\n// TODO: reduce unnecessary parameters (remove arguments, use global consts)\n\nfloat sigmoid_a(float x, float a, float b) {\n    return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b));\n}\n\n// unnecessary \nfloat sigmoid_b(float x, float b, float eb) {\n    return 1.0 - sigmoid_a(x, b, eb);\n}\n\nfloat sigmoid_ab(float x, float a, float b, float ea, float eb) {\n    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);\n}\n\nfloat sigmoid_mix(float x, float y, float m, float em) {\n    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);\n}\n\n/* ----------------------------------------------------------------------- */\n\n// SmoothLifeL\nfloat transition_function(vec2 disk_ring) {\n    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),\n                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m\n                      );\n}\n\n// unnecessary (?)\nfloat ramp_step(float steppos, float t) {\n    return clamp(t-steppos+0.5, -0.38175802271764944397367562012, 1.38175802271764944397367562012);\n}\n\n// unnecessary\nvec2 wrap(vec2 position) { return fract(position); }\n\n// Computes both inner and outer integrals\n// TODO: Optimize. Much redundant computation. Most expensive part of program.\nvec2 convolve(vec2 uv) {\n    vec2 result = vec2(0.0);\n    for (float dx = -r.x; dx <= r.x; dx++) {\n        for (float dy = -r.x; dy <= r.x; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            vec2 offset = d / iResolution.xy;\n            vec2 samplepos = wrap(uv + offset);\n            //if(dist <= r.y + 1.0) {\n                float weight = texture(iChannel0, samplepos).x;\n            \tresult.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));\t\n            \t\n            //} else if(dist <= r.x + 1.) {\n                //float weight = texture(iChannel0, uv+offset).x;\n\t\t\t\tresult.y += weight * (1.0-ramp_step(r.y, dist));\n            //}\n        }\n    }\n    return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Compute inner disk and outer ring area.\n    vec2 area = PI * r * r;\n    area.x -= area.y;\n    /* -------------------------------------*/\n    \n    // TODO: Cleanup.\n    color = texture(iChannel0, uv).xyz;\n    vec2 normalized_convolution = convolve(uv.xy).xy / area;\n    color.x = color.x + dt * (0.018175802271764944397367562012 * transition_function(normalized_convolution) - 0.0078175802271764944397367562012);\n    color.yz = normalized_convolution;\n    color = clamp(color, 0.0175802271764944397367562012, 0.938175802271764944397367562012);\n    \n    // Set initial conditions. TODO: Move to function / cleanup\n    if(iFrame < 10 || texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {\n        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n    }\n    \n    if(iMouse.z > 0.) {\n        //vec2 dst = abs(uv - iMouse.xy/iResolution.xy);\n        float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);\n        /*if(max(dst.x * iResolution.x/iResolution.y, dst.y) < 0.05) {\n        \tcolor = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n        }*/\n        if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));\n        }\n        /*if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.0)/iResolution.x, dst) * (1.0 - step((r.x-0.5)/iResolution.x, dst));\n        }*/\n    }\n    \n   \n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 615]]}
{"id": "ssffzn", "name": "Glass Table Pathtraced", "author": "jackdavenport", "description": "I decided to see what it took to actually use pathtracing and try to accurately simulate the light of the glass. This two shader experience has just taught me how much I hate shading glass and will probably never attempt it again lol. Use mouse to look.", "tags": ["shadow", "glass", "pathtracer", "table", "reflect", "refract"], "likes": 9, "viewed": 369, "published": 3, "date": "1644473598", "time_retrieved": "2024-07-30T17:04:21.930086", "image_code": "void mainImage(out vec4 col, in vec2 coord) {\n    vec4 buf = texture(iChannel0, coord/iResolution.xy);\n    col = buf / buf.w;\n    \n    // red bar is used as a rough sample counter\n    // when it spans across the screen there's at least 100,000\n    // samples done\n    if(coord.y < 2.) {\n        float x = iResolution.x * buf.w / 100000.;\n        if(coord.x < x) {\n            col = vec4(1.,0.,0.,1.);\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Material {\n    vec3 diffuse;\n    vec3 emission;\n    float smoothness;\n};\n\n// distance functions\n// source: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// source: https://www.shadertoy.com/view/MsdGzl\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nvec3 cosineDirection(in vec3 nor) {\n    float u = frand();\n    float v = frand();\n    \n    // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}", "buffer_a_code": "#define MAX_ITER 80\n#define MAX_DIST 15.\n#define MIN_DIST .001\n\n#define BOUNCES 6\n\nconst vec3 SUN_DIR = normalize(vec3(45.,30.,-45.));\nconst vec3 SUN_COL = vec3(1.);\n\nvec2 dstMin(vec2 a, float bt, float bm) {\n    return a.x < bt ? a : vec2(bt,bm);\n}\n\nvec2 dstScene(vec3 p, bool noGlass) {\n    vec2 d = vec2(p.y,0.);\n    \n    d = dstMin(d, sdBoxFrame(p-vec3(0.,.4,0.), vec3(1.,.4,.8), .05), 1.);\n    d = dstMin(d, length(p-vec3(.4,1.06,0.))-.2, 3.);\n    \n    \n    d = dstMin(d, length(p-vec3(-.8,1.06,.5))-.2, 3.);\n    \n    if(!noGlass) {\n        d = dstMin(d, sdCappedCylinder(p-vec3(0.,.85,0.), 1.3, .02), 2.);\n    }\n    return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float mint, bool noGlass) {\n    float t = mint;\n    float m = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec2 d = dstScene(ro+rd*t, noGlass);\n        if(abs(d.x) < MIN_DIST || t > MAX_DIST) break;\n        t += d.x;\n        m  = d.y;\n    }\n    return vec2(t,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(\n        dstScene(p+e.xyy,false).x-dstScene(p-e.xyy,false).x,\n        dstScene(p+e.yxy,false).x-dstScene(p-e.yxy,false).x,\n        dstScene(p+e.yyx,false).x-dstScene(p-e.yyx,false).x\n    );\n    return normalize(n);\n}\n\nvoid material(inout Material mat, in float id, in vec3 p) {\n    if(id == 0.) { // ground\n        mat.diffuse    = texture(iChannel0, p.xz / 2.).rgb;\n        mat.smoothness = 0.;\n    } else if(id == 1.) { // metal frame\n        mat.diffuse    = vec3(.5);\n        mat.smoothness = .9;\n    } else if(id == 2.) { // glass top\n        mat.diffuse    = vec3(.4,.4,.6); \n        mat.smoothness = 1.;\n    } else if(id == 3.) { // ball\n        mat.diffuse    = vec3(1., .2, .2);\n        mat.smoothness = .1;\n    }\n}\n\nvec3 lightRay(in vec3 n, in vec3 r, in Material mat) {\n    if(frand() < .05) return mix(SUN_DIR,cosineDirection(n),.01);\n    else if(frand() < mat.smoothness) return r;\n    else return cosineDirection(n);\n}\n\n//void refractionRayThroughSurface(inout vec3 ro, inout vec3 rd, in vec3 n) {\n//    rd = normalize(refract(rd, n, 1./1.52));\n//    ro = ro + rd * .001;\n//    // if the point is still inside the glass surface, march until\n//    // it's not anymore\n//    float d = dstScene(ro, false).x;\n//    if(d < 0.) {\n//        ro += rd * -d;\n//        d = dstScene(ro, false).x;\n//    }\n//}\n\nvec3 glassLightRay(in vec3 n, in vec3 r, in vec3 rd, in Material mat, in int s, inout bool refr) {\n    float fres = pow(max(-dot(rd,n),0.),.3);\n    if(frand() < fres) {\n        refr = true;\n        return normalize(refract(rd,n,1./1.52));\n    } else {\n        return lightRay(n, r, mat);\n    }\n}\n\nvec3 sky(in vec3 rd) {\n    float sunDot = dot(SUN_DIR,rd);\n    float sunFac = smoothstep(sunDot,.98,1.);\n    return mix(vec3(.8),vec3(20.),1.-pow(sunFac,5.));\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec3 col   = vec3(0.);\n    vec3 mask  = vec3(1.);\n    float dist = MAX_DIST;\n    \n    for(int i = 0; i < BOUNCES; i++) {\n        vec2 hit = raymarch(ro, rd, 0., false);\n        \n        if(hit.x < MAX_DIST) {\n            vec3 p = ro+rd*hit.x;\n            vec3 n = normal(p, hit.x);\n            vec3 r = normalize(reflect(rd, n));\n        \n            // get material data and direct lighting\n            Material mat;\n            material(mat, hit.y, p);\n            \n            // get next ray based on material\n            bool refr = false;\n            if(hit.y == 2.) {\n                rd = glassLightRay(n, r, rd, mat, i, refr);\n            }\n            else rd = lightRay(n, r, mat);\n            \n            // calculate new mask\n            mask *= mat.diffuse;\n            if(hit.y != 2.) {\n                mask *= max(dot(rd,n),0.);\n            }\n            \n            // calculate new ray origin depending on if\n            // the next ray is reflection or refraction\n            if(!refr) {\n                ro = p+n*.02;\n            } else {\n                ro = p+rd*.07;\n            }\n            \n            if(i == 0) dist = hit.x;\n        } else {\n            col += mask * sky(rd);\n            break;\n        }\n    }\n    \n    float fog = min(exp(dist-MAX_DIST),1.);\n    col = mix(col, vec3(.8), fog);\n    return col;\n}\n\nvec3 cameraPath() {\n    if(iMouse.xy == vec2(0.)) {\n        float a = 14.36 * .5;\n        float d = 3.;\n        return vec3(cos(a),1.5/d,sin(a))*d+vec3(0.,.4,0.);\n    } else {\n        vec2 m = iMouse.xy/iResolution.xy;\n        float rx = 1.27079632679 * m.y;\n        float ry = 6.28318530718 * m.x;\n        float cx = cos(rx), sx = sin(rx);\n        float cy = cos(ry), sy = sin(ry);\n        return vec3(0.,.4,0.)+vec3(cy*cx,sx,sy*cx)*3.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n    \n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = cameraPath();\n    vec3 rd = vec3(uv, 1.);\n    \n    vec3  f = normalize(-ro);\n    vec3  u = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3  v = normalize(cross(u,f));\n    \n    rd = mat3(u,v,f) * rd;\n    \n    vec4 accum = texture(iChannel1, fragCoord/iResolution.xy);\n    if(iFrame == 0 || iMouse.z > 0.) accum = vec4(0.);\n    \n    fragColor.rgb = accum.rgb + shade(ro, normalize(rd));\n    fragColor.a   = accum.a + 1.;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 418]]}
{"id": "fsffRH", "name": "Three Point Circumcircle", "author": "oneshade", "description": ".", "tags": ["triangle", "circle", "geometry", "points", "circumcircle", "boundingcircle"], "likes": 19, "viewed": 193, "published": 3, "date": "1644457878", "time_retrieved": "2024-07-30T17:04:22.755878", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Align SDF with an axis\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    up = normalize(up);\n    return p * mat2(up.y, -up.x, up);\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\n// vec3(x, y, radius)\nvec2 perp(in vec2 v) { return vec2(-v.y, v.x); }\nvec3 circumcircle(in vec2 a, in vec2 b, in vec2 c) {\n    vec2 baT = perp(b - a), cb = c - b;\n    vec2 pos = (a + b + baT * dot(c - a, cb) / dot(baT, cb)) / 2.0;\n    return vec3(pos, length(a - pos));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Animated points\n    vec2 a = vec2(sin(iTime * 0.75), cos(iTime));\n    vec2 b = vec2(cos(iTime), sin(iTime * 1.25));\n    vec2 c = vec2(cos(iTime * 1.25), cos(iTime * 0.5));\n\n    // Midpoints\n    vec2 abMid = (a + b) / 2.0;\n    vec2 bcMid = (b + c) / 2.0;\n    vec2 caMid = (c + a) / 2.0;\n\n    // Target points for perpendicular bisectors\n    vec2 abPerp = abMid + perp(b - abMid);\n    vec2 bcPerp = bcMid + perp(c - bcMid);\n    vec2 caPerp = caMid + perp(a - caMid);\n\n    drawSDF(abs(sdBox(axisAlign(uv - abMid, abPerp - abMid) + 0.08, vec2(0.08))), vec3(1.0));\n    drawSDF(abs(sdBox(axisAlign(uv - bcMid, bcPerp - bcMid) + 0.08, vec2(0.08))), vec3(1.0));\n    drawSDF(abs(sdBox(axisAlign(uv - caMid, caPerp - caMid) + 0.08, vec2(0.08))), vec3(1.0));\n\n    // Triangle edges\n    drawSDF(sdSegment(uv, a, b), vec3(0.5, 0.4, 0.0));\n    drawSDF(sdSegment(uv, b, c), vec3(0.5, 0.4, 0.0));\n    drawSDF(sdSegment(uv, c, a), vec3(0.5, 0.4, 0.0));\n\n    // Perpendicular bisectors\n    drawSDF(sdLine(uv, abMid, abPerp), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdLine(uv, bcMid, bcPerp), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdLine(uv, caMid, caPerp), vec3(1.0, 0.8, 0.0));\n\n    // Circumcircle center\n    vec3 circ = circumcircle(a, b, c);\n    drawSDF(sdDisk(uv, circ.xy, 0.05), vec3(1.0, 0.0, 0.0)); // Center\n    drawSDF(abs(sdDisk(uv, circ.xy, circ.z)), vec3(0.0, 1.0, 0.0)); // Circle\n\n    // Midpoints\n    drawSDF(sdDisk(uv, abMid, 0.03), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdDisk(uv, bcMid, 0.03), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdDisk(uv, caMid, 0.03), vec3(0.0, 0.0, 1.0));\n\n    // Points\n    drawSDF(sdDisk(uv, a, 0.05), vec3(1.0));\n    drawSDF(sdDisk(uv, b, 0.05), vec3(1.0));\n    drawSDF(sdDisk(uv, c, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsffRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 128, 167, 167, 231], [233, 241, 289, 289, 321], [323, 323, 358, 358, 438], [440, 440, 490, 490, 598], [600, 600, 647, 647, 738], [740, 762, 784, 784, 810], [811, 811, 863, 863, 1012], [1014, 1014, 1069, 1069, 2964]]}
{"id": "fsXBz8", "name": "SerenityOS Intro Ladyball", "author": "movAX13h", "description": "SerenityOS tribute", "tags": ["sdf", "yinyang", "serenityos"], "likes": 14, "viewed": 419, "published": 3, "date": "1644450034", "time_retrieved": "2024-07-30T17:04:23.638518", "image_code": "// SerenityOS Ladyball, fragment shader by movAX13h, Feb. 2022\n// thanks to iq for sdCappedTorus and polynomial smooth min\n// thanks to IWBTShyGuy and Shane for support\n\n#define REFLECTION\n#define ANTIALIAS\n\n// --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pih 1.5707963267949\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time;\nvec3 sunPos;\nvec3 sun;\nfloat focus;\nfloat far;\n\nstruct Hit\n{\n\tfloat d;\n\tfloat ref;\n\tfloat spec;\n};\n\n    \nHit scene(vec3 p)\n{\n\tvec3 q = p;\n    \n\tHit h = Hit(1.0e6, 0.1, 0.2);\n    p.zy = rotate(p.zy, 0.7); // tilt\n    p.xy = rotate(p.xy, -3.0*iTime); // spin\n\n\t// yin-yang\n\tfloat a = max(sdCappedTorus(p, vec2(1.0, 0.0), 0.5, 0.4), sdSphere(p, 0.42));    \n    float b = sdSphere(p, 0.4);\n\th.d = smin(a, b, 0.01);\n    \n    // dots\n    float c = sdSphere(p-vec3(0.4, 0.0, 0.0), 0.14);\n    c = min(c, sdSphere(p-vec3(0.21, 0.32, 0.0), 0.1));\n    c = min(c, sdSphere(p-vec3(-0.1, 0.4, 0.0), 0.06));\n    c = max(c, sdSphere(p, 0.43));\n    h.d = smin(h.d, c, 0.01);\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 ray, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n    // determine color based on radius\n    float r = length(ray); // because we know object is at origin\n    vec3 col = vec3(0.0);\n    float red = smoothstep(0.4, 0.41, r)*smoothstep(0.43, 0.416, r);\n    col = mix(col, vec3(0.871,0.047,0.008), red);\n\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).gbr;\n}\n\nvec3 march(in vec2 fragCoord) \n{   \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) / resolution.y;\n\t\n\tfloat d = 6.0;\n\tfloat t = 1.2*sin(time*0.1+35.0) ;\n\tvec3 cp = vec3(d*cos(t), 0.8+sin(0.2*time), d*sin(t)); // circle center\n    \n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy/resolution.xy-0.5);\n\t\td = 8.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t// raymarch scene    \n    for(int i=0; i < 120; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d*0.8;\n\t\tray += dir * h.d*0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n    \n\tcol = colorize(ray, h.spec, n, dir, sun)*m;\n    \n\tif (dist < far && h.d < 0.0001)\n\t{\t\n        #ifdef REFLECTION\n\t\t// MIRROR (from obj to reflected normal direction)\t\t\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(ray2, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist/far);\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n    return col;\n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    time = iTime + 7.0;\n\tsunPos = vec3(10.0, 15.0, -10.0);\n\tsun = normalize(sunPos);\n\tfocus = 9.0+2.0*cos(0.35*time);\n\tfar = 30.0;    \n    \n    // simple anti-aliasing\n    #ifdef ANTIALIAS\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 2; ++i)\n    {\n        for(int j = 0; j < 2; ++j)\n        {\n            col += march(fragCoord+vec2(i,j)/2.0);\n        }\n    }\n    col /= 4.0;\n    #else\n    vec3 col = march(fragCoord);\n    #endif    \n      \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.7; \n\tcol = pow(col, vec3(1.0 / 2.2)); // gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 329, 329, 352], [354, 354, 424, 424, 564], [566, 566, 596, 596, 682], [684, 684, 723, 723, 812], [931, 931, 950, 950, 1501], [1503, 1503, 1524, 1524, 1703], [2276, 2276, 2298, 2298, 2340], [2342, 2342, 2374, 2374, 3887], [3896, 3896, 3954, 3954, 4566]]}
{"id": "fdfBz8", "name": "luminance-reaction illusion", "author": "ap", "description": "The brighter square appears to be moving ahead.", "tags": ["illusion", "luminance", "reaction"], "likes": 4, "viewed": 260, "published": 3, "date": "1644442497", "time_retrieved": "2024-07-30T17:04:24.644828", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Blank background\n    vec3 col = vec3(0.0f);\n    \n    int box_count = 8;\n    \n    float sz = 5.0f * iResolution.x / 400.0f;\n    float speed = 3.0f;\n    \n    for(int i = 0; i < box_count; i++)\n    {\n        float lum = mix(0.9, 0.1, float(i)/float(box_count-1));\n        \n        float y = (iResolution.y * 0.5) + (iResolution.y * 0.35) * sin(iTime * speed);\n        float x = mix(iResolution.x * 0.25, iResolution.x * 0.75,  float(i)/float(box_count-1));\n        \n        if(abs(fragCoord.x - x) < sz && abs(fragCoord.y - y) < sz)\n        {\n            col = vec3(lum);\n        }\n    }    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 802]]}
{"id": "fssyWj", "name": "rolling orchestra", "author": "xnio94", "description": "i was inspired by a gif i saw in Twitter, when i tried to recreate it using raymarching i ended up with this.\nchange H value to see more variants", "tags": ["loop", "repeat", "rolling"], "likes": 14, "viewed": 326, "published": 3, "date": "1644426429", "time_retrieved": "2024-07-30T17:04:25.442695", "image_code": "#define pi 3.14\n\n#ifdef HW_PERFORMANCE\n    #if HW_PERFORMANCE==0\n    #define AA 1.\n    #else\n    #define AA 2.   // make this 2 or 3.. for better antialiasing\n    #endif\n#else\n#define AA 1.\n#endif\n\nconst float MAXD = 100.;\nconst float MAXSHD = 3.;\nconst float MAXRD = 15.;\nfloat t;\n// 2d rotation\nvec2 rot(vec2 p, float r) {\n\tfloat c = cos(r), s = sin(r);\n\treturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\nfloat H = .4; //size of the cross sphere raduis is cqlculated based on this\n// rolling a vector u in a closed path (square of length h, in plan y=0)\n// f is the animation parametre (iTime)\nvec3 roll4(vec3 u, float h, float f)\n{\n    float s=.5;\n    float c = .03; //this add a clamping effect i think it look cooler\n    f = floor(f)+smoothstep(s,1.+c,fract(f));\n    f*=pi;\n    float b = f/pi/2.;\n    float a = b + .5;\n    a =(max(0., 2.*fract(a) - 1. ) + floor(a));  \n    b = abs(  max(0., 2.*fract(b)-1.) + floor(b)- floor(b/2.+.25)*2.);\n    u.x += (2.-h)*  (4.*abs(fract(a/2.)-.5)-1.);\n    u.z += (2.-h)*  (4.*abs(fract(b/2.)-.5)-1.);\n    u.zy = rot(u.zy,b*pi);\n    u.xy = rot(u.xy,a*pi);\n    return u;   \n}\n// rolling wheel (1/4 of a sphere)\nfloat wheel(vec3 p,float r)\n{\n    float d = length(p) - r;\n    return max(-p.z,max(-p.x,d));\n}\n// 1d-elongated cylindre\nfloat cyl(in vec3 p, in float r,in float h)\n{\n    p.x -=clamp(p.x,-h,h);    \n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// 2d-elongated sphere \nfloat sph(in vec3 p, in float r,in float h)\n{\n    p.xz -=clamp(p.xz,-h,h);    \n    return length(p)-r;\n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cros(in vec3 p, in float r,in float h)\n{\n    float d = min(cyl(p,r,h),cyl(p.zyx,r,h));\n    /*\n    for(int i=0;i<6;i++)\n    {\n        p.y -= r/2. + r/2.;// r*2.-.5+r/4.;\n        r/=1.4;\n        h-=r/sqrt(2.);\n        d = min(d, sph(p,r,h));\n    }\n    */\n    return d;\n}\n// surface texture\nfloat text(vec3 u)\n{\n    return  0.; //remove this to apply surface textures\n    u *= 6.28*10.;\n    //u = abs(fract(u/10.)-.5)*4.-1.;\n    u = sin(u/2.);\n    return 0.015*( u.x*u.y*u.z )  ;\n}\nvec4 opu(vec4 a,vec4 b){ return (a.x<b.x) ? a : b;}\nvec4 map(vec3 p)\n{\n    vec3 blue = normalize(vec3(.3,.4,.8));\n    vec3 q=p;\n    p.xz=mod(p.xz,4.)-2.;\n    vec2 s = (q.xz-p.xz)/4.-.5;\n\tvec3 u = p;        \n    \n    float h = H;\n    float r = (4.-h*2.)/3.14;\n    u.y-=r;\n    \n    q = u;\n    q.xz = abs(u.xz) - vec2(2.);\n    float frame = cros(q,r,h);\n    if(fract(s.x/2.+s.y/2.)>.25) frame += text(u);\n    vec4 plan = vec4(p.y,blue-.1);\n    vec4 wall = vec4(frame,blue);\n\n    float c = t*.2 +s.y+2.*s.x; //; -  0.*s.y/2.;\n    float c2 = c +1.+mod(s.x*s.y,2.); //; -  0.*s.y/2.;\n    p = roll4(u,h,c);\n    float w1 = wheel(p , r);\n    w1 += text(p);\n    p = roll4(u,h,c2);\n    float w2 = wheel(p , r);\n    //w2 += text(p);\n    vec4 wheel1 = vec4(w1, blue); \n    vec4 wheel2 = vec4(w2, blue*0.65);\n    wheel1 = opu(wheel1,wheel2);\n\n    vec4 o = opu(plan,opu(wheel1,wall));\n    o.x -= .04;//+0.01*(sin(p.x*40.)*sin(p.y*40.));\n    o.yzw = vec3(1.,.8,.9); //color \n    \n    return o;//vec4(d,1.,0.,0.);\n}\n//simple raymarch\nvec4 rayMarch(vec3 rO, vec3 rD)\n{   \n    float d = 0.;\n    vec4 D;\n    for (int i = 0; i<130 &&  d < MAXD; i++)\n    {\n        D = map(rO + rD * d);\n        //d += D.x;\n        if (D.x > .5)  d += D.x*.5;   else d += D.x;\n        if (D.x < 3e-4)  break;\n    }\n    return vec4(d, D.yzw);\n}\n\n//to learn about normal using sdf\n//https://iquilezles.org/articles/normalsSDF\n\n#define ZERO (min(iFrame,0))\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return -normalize(n);\n}\nvec3 simpleSky(vec3 p){   \n    return vec3(.5,.6,1.-p.y);\n}\n// you can learn more about soft shadows in this article https://iquilezles.org/articles/rmshadows\nfloat shadows(vec3 or, vec3 lD)\n{\n    const float k = 1.5;\n    float res = 1.;\n    float t = 0.;\n    for (int i = 0; i < 40; i++)\n    {\n        float d = map(or + lD*t).x;\n        res = min(res, .5 + d * k / t);\n        if (res < .01|| t > MAXSHD) break;\n        t += d;\n    }\n    res = max(res, 0.);\n    return smoothstep(.3, 1., res);\n}\nvec4 render(in vec2 fragCoord )\n{\n    float fov = iResolution.x;\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    uv = uv - .5;\n    uv /= fov;\n    float ww=t*.025;\n    vec3 or = vec3(cos(ww),.6+sin(ww*1.5345)*.2,sin(ww))*10.*(sin(ww*1.37)+3.);\n    //or.y = 20.;\n    //or.y-=17.5;\n    vec3 w = normalize(vec3(0.,0.,0.)-or);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rD = normalize(w*1.5+uv.x*u+uv.y*v);\n\t   \n    vec4 d = rayMarch(or, rD);\n    vec3 col = vec3(0,0,0);\n    \n    if (d.x < MAXD)\n    {\n        vec3 p = or + d.x * rD;\n    \tvec3 nrm = normal(p);\n        vec3 sun = -normalize(vec3(.4, 2., .8));\n        \n        col = vec3(dot(sun,nrm)) *d.yzw;\n        //col *= d.yzw; //colloring\n        col *= vec3(shadows(p - sun * 0.01, -sun));\n\n    }\n    else \n    {\n        col = simpleSky(rD);\n    }\n    \n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    t = iTime*2.25; // globale time\n    for(float a=0.;a<AA;a++)\n        fragColor += render(fragCoord + a/AA);\n    fragColor /=AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 297, 324, 324, 409], [424, 599, 637, 637, 1118], [1119, 1154, 1183, 1183, 1248], [1249, 1274, 1319, 1319, 1461], [1462, 1486, 1531, 1531, 1699], [1700, 1700, 1746, 1746, 1974], [1975, 1994, 2014, 2014, 2184], [2185, 2185, 2209, 2209, 2236], [2237, 2237, 2255, 2255, 3183], [3184, 3202, 3235, 3235, 3489], [3600, 3646, 3674, 3772, 4016], [4017, 4017, 4040, 4040, 4076], [4077, 4176, 4209, 4209, 4514], [4515, 4515, 4548, 4548, 5395], [5396, 5396, 5453, 5453, 5613]]}
{"id": "fdlBzr", "name": "Star with diffraction spikes", "author": "gmiller123456", "description": "Based on \"The Art of Code\" https://www.youtube.com/watch?v=rvDo9LvfoVE&t=544s", "tags": ["astronomy"], "likes": 5, "viewed": 324, "published": 3, "date": "1644420333", "time_retrieved": "2024-07-30T17:04:26.428060", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col=vec3(0);\n    float d=length(uv);\n    float m=.04/d;\n    \n    float flare=max(0.,1.-abs(uv.x*uv.y*iResolution.x*3.));\n    \n    col+=m;\n    col+=flare;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 389]]}
{"id": "fsXfzr", "name": "Ink Interacting", "author": "SamOrantin", "description": "Use your mouse click and drag to interacting the ink", "tags": ["ink"], "likes": 8, "viewed": 169, "published": 3, "date": "1644410939", "time_retrieved": "2024-07-30T17:04:27.367548", "image_code": "vec4 color1 = vec4(0.17,0.19,0.18,1.0);\nvec4 color2 = vec4(0.0,0.0,0.0,1.0);\nvec4 color3 = vec4(0.0,0.0,0.0,1.0);\nfloat multiplier = 1.0;\nfloat midPosition = 1.0;\n\n#define NUM_OCTAVES 5\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    vec4 c = texture(iChannel0, uv);\n    //uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 tex = texture(iChannel1, uv);\n    \n    float l = max(pow(clamp(((c.x+c.y+c.z)/2.7)*multiplier,0.0,1.0),2.0),pow(clamp(((c.x+c.y+c.z)/2.6)*multiplier,0.0,1.0),12.0));\n    \n    vec4 res1 = mix(color1, color2, smoothstep(0.0,midPosition,l));\n    vec4 res2 = mix(res1, color3, smoothstep(midPosition,1.0,l));\n    \n    fragColor = texture(iChannel2, uv);\n    fragColor = texture(iChannel1, uv);\n    fragColor = res2;\n    //fragColor = c;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat timeMultiply = 0.2;\nfloat noiseScale = 3.5;\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p, float time)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p, float t)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p , t ); p = p*2.01;\n    f += 0.25000*simplex3D( p , t ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p , t ); p = p*2.03;\n    f += 0.06250*simplex3D( p , t ); p = p*2.04;\n    f += 0.03125*simplex3D( p , t ); \n\n\treturn f;\n}\n\n\nfloat baseColorModify(in float C)\n{\n    return smoothstep(0.6,0.65,C);\n}\n\nfloat boxMask(vec2 uv, vec2 pivot, vec2 bounds, float falloff)\n{\n\tvec2 p = abs(uv - pivot);\n\tp = max(p - (bounds * 0.5), 0.);\n\t\n\treturn 1.0 - min(length(p) / max(falloff, 0.00001), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    float time = timeMultiply * iTime;\n    \n    float n = fbm(vec3(time,vec2(uv*noiseScale)),time)*0.5+0.5;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    \n    \n    vec2 box_position = vec2(0.5 * aspect, 0.5); // center of screen\n\n    vec2 box_bounds = vec2(0.8*aspect, 0.7);\n    \n    float box_falloff = 0.1;\n\n    float box = min(boxMask(fragCoord.xy / iResolution.yy, box_position, box_bounds, box_falloff),0.9);\n                \n                \n    n = baseColorModify(n)*(1.0-box);\n\n    fragColor = vec4(n);\n}", "buffer_a_inputs": [], "buffer_b_code": "float sampleDistance = 1.0;\nfloat diffusion = 2.0;\nfloat turbulence = 1.9;\nfloat fluidify = 0.017;\nfloat attenuate = 0.001;\n\nfloat boxMask(vec2 uv, vec2 pivot, vec2 bounds, float falloff)\n{\n\tvec2 p = abs(uv - pivot);\n\tp = max(p - (bounds * 0.5), 0.);\n\t\n\treturn 1.0 - min(length(p) / max(falloff, 0.00001), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    \n    vec4 baseColor = texture(iChannel0, uv);\n    \n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 box_position = vec2(0.5 * aspect, 0.5); // center of screen\n\n    vec2 box_bounds = vec2(0.55*aspect, 0.2);\n    \n    float box_falloff = 0.4;\n\n    float box = boxMask(fragCoord.xy / iResolution.yy, box_position, box_bounds, box_falloff);\n    \n    \n    vec2 sDist = sampleDistance/iResolution.xy;\n    \n    vec4 newColor = texture(iChannel1, uv);\n    vec2 turb = (texture(iChannel3, uv).xy*2.0-1.5)*2.;\n    vec2 dirVec = uv - vec2(0.5,0.5);\n\n    vec4 newColor1 = texture(iChannel1, uv + vec2(1.0,0.0)*sDist);\n    vec4 newColor2 = texture(iChannel1 , uv + vec2(-1.0,0.0)*sDist);\n    vec4 newColor3 = texture(iChannel1, uv + vec2(0.0,1.0)*sDist);\n    vec4 newColor4 = texture(iChannel1, uv + vec2(0.0,-1.0)*sDist);\n    \n    vec4 newColor5 = texture(iChannel1, uv + vec2(1.0,1.0)*sDist);\n    vec4 newColor6 = texture(iChannel1, uv + vec2(-1.0,1.0)*sDist);\n    vec4 newColor7 = texture(iChannel1, uv + vec2(1.0,-1.0)*sDist);\n    vec4 newColor8 = texture(iChannel1, uv + vec2(-1.0,-1.0)*sDist);\n     \n    vec2 t = (newColor1.x+newColor1.y+newColor1.z)/3.0 * vec2(1.0,0.0);\n    t += (newColor2.x+newColor2.y+newColor2.z)/3.0 * vec2(-1.0,0.0);\n    t += (newColor3.x+newColor3.y+newColor3.z)/3.0 * vec2(0.0,1.0);\n    t += (newColor4.x+newColor4.y+newColor4.z)/3.0 * vec2(0.0,-1.0);\n    \n    t += (newColor5.x+newColor5.y+newColor5.z)/3.0 * vec2(1.0,1.0);\n    t += (newColor6.x+newColor6.y+newColor6.z)/3.0 * vec2(-1.0,1.0);\n    t += (newColor7.x+newColor7.y+newColor7.z)/3.0 * vec2(1.0,-1.0);\n    t += (newColor8.x+newColor8.y+newColor8.z)/3.0 * vec2(-1.0,-1.0);\n    \n    t /= 8.0;\n    \n    float mouseRegion = texture(iChannel2,uv).x;\n    \n    vec2 dir = vec2(t*(mouseRegion*0.+1.0)*diffusion+turb*turbulence + dirVec*0.7)*iTimeDelta*0.2 + (texture(iChannel2,uv).yz*2.-1.)*0.06;\n    \n    vec4 res = texture(iChannel1, uv+dir);\n    \n    if(iFrame<10 || sin(float(iFrame)/75.) > 0.)\n    {\n    \tfragColor =  mix(res-0.002*mouseRegion, baseColor, clamp(baseColor.a*fluidify + attenuate,0.0,1.0)) + 0.01*baseColor;\n    }\n    else\n    {\n    \tfragColor = mix(res-0.002*mouseRegion, baseColor, clamp(baseColor.a*fluidify + attenuate,0.0,1.0));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 speed = vec2(1.0,2.0);\nfloat v = 30.0;\nfloat dist = 0.3;\nfloat random1 = 1.0;\nfloat random2 = 100.0;\n\nfloat noiseScale = 1.;\n\nfloat timeMultiply = 0.1;\n\n#define NUM_OCTAVES 7\n\nfloat boxMask(vec2 uv, vec2 pivot, vec2 bounds, float falloff)\n{\n\tvec2 p = abs(uv - pivot);\n\tp = max(p - (bounds * 0.5), 0.);\n\t\n\treturn 1.0 - min(length(p) / max(falloff, 0.00001), 1.0);\n}\n\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n}  \n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 turbulence (in vec2 _st) {\n    \n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    float m1 = mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n    \n    float a1 = random(i+1.0);\n    float b1 = random(i + vec2(1.0, 0.0));\n    float c1 = random(i + vec2(0.0, 1.0));\n    float d1 = random(i + vec2(1.0, 1.0));\n\n    vec2 u1 = f * f * (3.0 - 2.0 * f);\n\n    float m2 = mix(a1, b1, u1.x) +\n            (c1 - a1)* u1.y * (1.0 - u1.x) +\n            (d1 - b1) * u1.x * u1.y;\n    return vec2(m1,m2);\n}\n\nvec2 fbmV ( in vec2 _st) {\n\n    vec2 v = vec2(0.0);\n    vec2 a = vec2(0.5);\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * turbulence(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= vec2(0.5);\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= ratio;\n    \n    float time = timeMultiply * iTime;\n    \n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 box_position = vec2(0.5 * aspect, 0.5); // center of screen\n\n    vec2 box_bounds = vec2(0.55*aspect, 0.2);\n    \n    float box_falloff = 0.4;\n\n    float box = boxMask(fragCoord.xy / iResolution.yy, box_position, box_bounds, box_falloff);\n\n   \n    vec2 r = vec2(0.);\n    vec2 q = vec2(0.);\n    q.x = fbmV(uv*noiseScale*3.0 + 7.10*time).x;\n    q.y = fbmV(uv*noiseScale*3.0 + vec2(1.0)).x;\n    \n    vec2 turb1 = fbmV(uv*noiseScale*13.0 + 1.0*q + vec2(1.7,9.2)+ 0.35*time )*0.5+0.5;\n    vec2 turb2 = fbmV(uv*noiseScale*152.0 + 1.0*q + vec2(8.3,2.8)+ 0.326*time)*0.5+0.5;\n    \n    vec2 turb = (turb1 + turb2)/2.;\n    \n    fragColor = vec4(turb,0.,0.);\n      \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float mouseMask(vec2 p,vec2 uv,float r,float smoothness){\n\n    float dist = sqrt(dot(uv-p,uv-p));\n    return smoothstep(r,r-smoothness,dist);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    \n    vec2 uv1 = (fragCoord.xy/iResolution.y);\n    \n    float ratio = iResolution.x/iResolution.y;\n    \n    vec4 pf = texture(iChannel0, uv);\n    \n    vec2 m = iMouse.xy/iResolution.y;\n    float mask = mouseMask(m,uv*vec2(ratio,1),0.2,0.1);\n    float mask1 = mouseMask(m,uv*vec2(ratio,1),0.3,0.4);\n    vec2 force = mask1*(- uv1 + m);\n    fragColor = vec4(max(pf.x*0.98,mask), vec2(force*0.5+0.5),0.);\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n#define NUM_OCTAVES 6\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n*/", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 215, 215, 323], [327, 327, 384, 384, 1005]]}
{"id": "7dffzn", "name": "Fake vortices: pseudo-Coriolis+G", "author": "FabriceNeyret2", "description": "variant of https://shadertoy.com/view/fd2cDd\nusing Gabor random splats in cell + v*t phase\n\nshows how to procedurally mimic Coriolis-like effect : velocity direction tilt + intensity grow toward the Hi an Lo pressure poles, forming weather scale vortices.", "tags": ["noise", "waves", "vortex", "directional", "gabor", "coriolis"], "likes": 11, "viewed": 391, "published": 3, "date": "1644403536", "time_retrieved": "2024-07-30T17:04:28.230241", "image_code": "// variant of https://shadertoy.com/view/fd2cDd\n// variant from https://shadertoy.com/view/7dByWK\n\n#define hue(v)    ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // utils from https://www.shadertoy.com/view/llySRh\n#define rot(a)     mat2(cos(a),-sin(a),sin(a),cos(a))\n#define hash(p)    fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 2.5* U/iResolution.y;\n\tvec2 g; float V = .05;\n\tfloat n = psrdnoise(U + vec2(V*iTime, 0), vec2(0), .2*iTime, g); // g returns gradient\n    \n// ------------------------------------------------------------ \n\n    O = hue(.5 + .5*n) ; // coloring the positive and negative \"vortices\"\n    U *= 10.;\n    g *= rot(1.57*(1.+n));                // mimic Coriolis velocity direction tilt  // g *= rot(1.57*  n   );          \n#define Vr(n) 1./(1.-abs(n))\n    float f = 2.*Vr(n),                   // mimic speed increase toward poles\n          v = 0., fc;\n    vec2  I = floor(U), F,P,g0;           // cells to display vectors or Gabor splats\n\n    for( int k=0; k < 9; k++) {           // cumul neighbor cells since splat covers out\n        P = I + vec2(k%3-1,k/3-1);\n        F = U - P - hash(P);              // random location in cell\n        fc = Vr( psrdnoise(P/10. + vec2(V*iTime, 0), vec2(0), .2*iTime, g0) ); // for anim speed we need f sampled at center\n        v +=   sin( f* dot(F,g) + 6.28*hash(P+.5).x - .02*fc*iTime ) // random phase + time\n             * exp(-.5 *5.*dot(F,F) );    // draw Gabor splat\n    }\n    O = (.5+.5*v) * (O+1.)/2.;\n // O += .5+.5*v - O;                     // B & W\n // O *= smoothstep(1.5,.0, abs(v)/min(1.,fwidth(v)) ); // contour lines\n \n                                          // draw white spot at poles\n // O = mix(O, vec4(1), smoothstep(-.8,.8, (abs(n)-.8)/fwidth(n) ) ); \n // O = mix(O, vec4(1), smoothstep(.8,.0, abs(n)/fwidth(n) ) ); // isoline 0   \n\n}\n", "image_inputs": [], "common_code": "// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 392, 392, 1890]]}
{"id": "fsXBzr", "name": "Glass Table", "author": "jackdavenport", "description": "A simple model of a modern glass table. This was mostly an attempt to correctly shade realtime glass without resorting to pathtracing or using lots of samples. Instead it uses two passes (refraction and reflection) and a trick for transparent shadows.", "tags": ["shadow", "glass", "table", "reflect", "refract"], "likes": 6, "viewed": 304, "published": 3, "date": "1644387552", "time_retrieved": "2024-07-30T17:04:28.993201", "image_code": "precision highp float;\n\n#define MAX_ITER 80\n#define MAX_DIST 15.\n#define MIN_DIST .001\n\n#define SAMPLES 2\n#define BOUNCES 3\n\nconst vec3 SUN_DIR = normalize(vec3(45.,30.,-45.));\nconst vec3 SUN_AMB = vec3(.15);\n\nvec2 dstMin(vec2 a, float bt, float bm) {\n    return a.x < bt ? a : vec2(bt,bm);\n}\n\nvec2 dstScene(vec3 p, bool noGlass) {\n    vec2 d = vec2(p.y,0.);\n    \n    d = dstMin(d, sdBoxFrame(p-vec3(0.,.4,0.), vec3(1.,.4,.8), .05), 1.);\n    d = dstMin(d, length(p-vec3(.4,1.06,0.))-.2, 3.);\n    \n    if(!noGlass) {\n        d = dstMin(d, sdCappedCylinder(p-vec3(0.,.85,0.), 1.3, .02), 2.);\n    }\n    return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float mint, bool noGlass) {\n    float t = mint;\n    float m = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec2 d = dstScene(ro+rd*t, noGlass);\n        if(abs(d.x) < MIN_DIST || t > MAX_DIST) break;\n        t += d.x;\n        m  = d.y;\n    }\n    return vec2(t,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(\n        dstScene(p+e.xyy,false).x-dstScene(p-e.xyy,false).x,\n        dstScene(p+e.yxy,false).x-dstScene(p-e.yxy,false).x,\n        dstScene(p+e.yyx,false).x-dstScene(p-e.yyx,false).x\n    );\n    return normalize(n);\n}\n\nvoid material(inout Material mat, in float id, in vec3 p) {\n    if(id == 0.) { // ground\n        mat.diffuse  = texture(iChannel0, p.xz / 2.).rgb;\n        mat.specular = vec3(.1);\n        mat.shine    = 4.;\n        mat.reflective = 0.;\n    } else if(id == 1.) { // metal frame\n        mat.diffuse  = vec3(.5);\n        mat.specular = vec3(1.);\n        mat.shine    = 50.;\n        mat.reflective = .9;\n    } else if(id == 2.) { // glass top\n        mat.diffuse  = vec3(.4,.4,.6);\n        mat.specular = vec3(1.);\n        mat.shine    = 80.;\n        mat.reflective = 1.;\n    } else if(id == 3.) { // ball\n        mat.diffuse  = vec3(1., .2, .2);\n        mat.specular = vec3(.4);\n        mat.shine    = 30.;\n        mat.reflective = .1;\n    }\n}\n\n// source: https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, bool noGlass )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = dstScene(ro + rd*t, noGlass).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 r, Material mat, bool noGlass) {\n    float ndotl = max(dot(n,SUN_DIR),0.);\n    float rdotl = max(dot(r,SUN_DIR),0.);\n    float shd   = softshadow(p, SUN_DIR, .01, MAX_DIST, 40., noGlass);\n    return mat.diffuse * (ndotl * shd + SUN_AMB) + mat.specular * pow(rdotl,mat.shine) * shd;\n}\n\nvec3 shade(vec3 oro, vec3 ord) {\n    vec3 fin = vec3(0.);\n    \n    for(int s = 0; s < SAMPLES; s++) {\n        vec3 col   = vec3(0.);\n        vec3 mask  = vec3(1.);\n        float mint = 0.;\n        float last = -1.;\n        float dist = 0.;\n        \n        vec3 ro = oro;\n        vec3 rd = ord;\n        \n        for(int b = 0; b < BOUNCES; b++) {\n            vec2 hit = raymarch(ro, rd, mint, last == 2.);\n            if(hit.x > 0. && hit.x < MAX_DIST) {\n                vec3 p = ro + rd * hit.x;\n                vec3 n = normal(p, hit.x);\n                vec3 r = normalize(reflect(rd, n));\n\n                Material mat;\n                material(mat, hit.y, p);\n                \n                col += mask * lighting(p, n, r, mat, s > 0);\n                \n                float fres = pow(max(-dot(rd,n),0.),.4);\n                \n                // on first pass, glass uses refraction instead\n                if(hit.y == 2. && s == 0) {\n                    r = normalize(refract(rd, n, 1./1.52));\n                    mask *= fres;\n                } else {\n                    mask *= mat.diffuse * mat.reflective * (1.-fres);\n                }\n                 \n                ro = p;\n                rd = r;\n                mint = .1;\n                last = hit.y;                   // set last material id\n                \n                if(b == 0) dist = hit.x;        // set distance for fog\n                if(mat.reflective < .01) break; // if material isn't reflective, dont bounce\n            } else {\n                col += mask * vec3(.8);\n                break;\n            }\n        }\n        \n        float fog = min(exp(dist-MAX_DIST),1.);\n        col = mix(col, vec3(.8), fog);\n        \n        fin += col / float(SAMPLES);\n    }\n    \n    return fin;\n}\n\nvec3 cameraPath() {\n    float a = iTime * .5;\n    float d = 3.;\n    return vec3(cos(a),1.5/d,sin(a))*d+vec3(0.,.4,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = cameraPath();\n    vec3 rd = vec3(uv, 1.);\n    \n    vec3  f = normalize(-ro);\n    vec3  u = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3  v = normalize(cross(u,f));\n    \n    rd = mat3(u,v,f) * rd;\n    fragColor.rgb = shade(ro, normalize(rd));\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Material {\n    vec3 diffuse;\n    vec3 specular;\n    float shine;\n    float reflective;\n};\n\n// distance functions\n// source: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 251, 251, 292], [294, 294, 331, 331, 611], [613, 613, 672, 672, 917], [919, 919, 949, 949, 1214], [1216, 1216, 1275, 1275, 1956], [1958, 2011, 2102, 2102, 2444], [2446, 2446, 2513, 2513, 2764], [2766, 2766, 2798, 2798, 4539], [4541, 4541, 4560, 4560, 4661], [4663, 4663, 4720, 4720, 5066]]}
{"id": "NdfBzn", "name": "Square Tiling Example E", "author": "SnoopethDuckDuck", "description": "just playing around with things", "tags": ["tiling"], "likes": 49, "viewed": 972, "published": 3, "date": "1644370075", "time_retrieved": "2024-07-30T17:04:29.776108", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a+b*cos(2.*pi*(c*t+d));\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.x -= 1. + 0.25 * pi * 0.2 * iTime; \n    uv.y += 0.06 * cos(4. * uv.x + pi* 0.2 * iTime);\n    \n    float sc = 42. + .025 * (1. + thc(1., 4. * uv.x + uv.y + iTime));\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n       \n    // m determines what new cell the old cell lies in\n    // 3 -> small\n    // 0 -> tl big, 2 -> tr big, 4 -> bl big, 1 -> br big\n    float m = mod(2. * ipos.x - ipos.y, 5.);\n    \n    // id = 2 if small cell, id = 1 if big cell (used to make outlines same size)\n    float id = 2.;\n    vec2 o = vec2(0);\n    \n    if (m != 3.) { fpos *= 0.5;  id = 1.; }    \n    if (m == 2.)      o = vec2(1,0); // top right\n    else if (m == 4.) o = vec2(0,1); // bottom left\n    else if (m == 1.) o = vec2(1);   // bottom right\n    \n    // if in big cell, halve fpos + translate\n    fpos += 0.5 * o - 0.5;\n    ipos -= o;\n    \n    float h = h21(ipos);    \n    float v = 0.3 * ipos.x/sc + 0.25 * h + 0.2 * iTime;\n    \n    float d = sdBox(fpos, vec2(0.1)) - 0.28 - 0.1 * thc(20., 2. * pi * v);\n    float k = 10. / iResolution.y;\n    float s = smoothstep(-k, k, -d);\n        \n    float c = (0.75/sc) * ipos.y + 0.5 + 0.5 * h;\n    c *= s;\n    \n    vec3 e = vec3(1.);\n    float f = smoothstep(-0.5, 0.5, fpos.x);\n    vec3 col = c * pal(v, 0.6 * f * e, e, 0.8 * e, (0.75/sc) * ipos.y * vec3(0., 0.33, 0.66)); \n    //col -= step(sdBox(fpos, vec2(0.1)), 0.28 * id);\n    col = clamp(col, 0., 1.);\n    col += 0.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 129, 129, 166], [168, 168, 188, 188, 263], [265, 265, 302, 302, 382], [384, 384, 441, 441, 1964]]}
{"id": "7djcWt", "name": "iTimeDelta vs 1./iFrameRate", "author": "FabriceNeyret2", "description": "red: iTimeDelta ( on my system a bit steppy. because FPS submultiple of 60 constraint by the system ? )\ngreen: 1./iFrameRate . big steps because averaged on a bunch of frames ( not even rolling window !)\n", "tags": ["test", "itimedelta"], "likes": 4, "viewed": 384, "published": 3, "date": "1644341301", "time_retrieved": "2024-07-30T17:04:30.572977", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = T(u-vec2(1,0));\n    vec2 U = u/iResolution.xy;\n\n    float x = iTime;\n    for(float i = 0.; i < 1e5*(.5+.5*sin(iTime)); i++)\n        x = fract(1e5*sin(1e5*x));\n    O.b = .1*x;\n     \n    if ( u.x==.5) O.r = float(U.y/4. < iTimeDelta ),\n              //  O.g = float(U.y/4. < iTime-O.a); // equals iTimeDelta\n                  O.g = float(U.y/4. < 1./iFrameRate);\n    O.a = iTime;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0,ivec2(U),0)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 54]]}
{"id": "fd2cDd", "name": "Fake vortices : pseudo-Coriolis", "author": "FabriceNeyret2", "description": "reuse base macro noise of https://shadertoy.com/view/7dByWK\nshows how to procedurally mimic Coriolis-like effect : velocity direction tilt + intensity grow toward the Hi an Lo pressure poles, forming weather scale vortices.", "tags": ["noise", "waves", "vortex", "directional", "gabor", "coriolis"], "likes": 22, "viewed": 523, "published": 3, "date": "1644338552", "time_retrieved": "2024-07-30T17:04:31.359873", "image_code": "// variant from https://shadertoy.com/view/7dByWK\n\n\n#define hue(v)    ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define rot(a)     mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 2.5* U/iResolution.y;\n   \n\tvec2 g;\n\tfloat n = psrdnoise(U + vec2(.05*iTime, 0), vec2(0), .2*iTime, g); // g returns gradient\n    \n// ------------------------------------------------------------ \n\n    O = hue(.5 + .5*n) ; // coloring the positive and negative \"vortices\"\n    \n    U = fract(10.*U);                // cells to display vectors\n    g *= rot(1.57*(1.+n));           // mimic Coriolis velocity direction tilt\n // g *= rot(1.57*  n   );          \n    \n    float f = 2./(1.-abs(n)),        // mimic speed increase toward poles\n          v = sin(f*dot(U, g ) );    // draw vectors\n    O *= smoothstep(1.5,.0, abs(v)/min(1.,fwidth(v)) );\n    \n                                    // draw white spot at poles\n // O = mix(O, vec4(1), smoothstep(-.8,.8, (abs(n)-.8)/fwidth(n) ) ); \n // O = mix(O, vec4(1), smoothstep(.8,.0, abs(n)/fwidth(n) ) ); // isoline 0   \n\n}\n", "image_inputs": [], "common_code": "// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2cDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 212, 212, 1087]]}
{"id": "Ns2cWd", "name": "experiment_malze", "author": "malouane", "description": "based on the shader [url=https://www.shadertoy.com/view/tlKGDh]Physarum Polycephalum Simulation\n[/url] of [url=https://www.shadertoy.com/user/michael0884]michael0884[/url]\n\nuse mouse for add particles\nuse spacebar for clear the screen\n\na", "tags": ["expriment"], "likes": 8, "viewed": 332, "published": 3, "date": "1644335507", "time_retrieved": "2024-07-30T17:04:32.160732", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Voronoi Tracking Experiment 1\n\n// based on the shader https://www.shadertoy.com/view/tlKGDh of michael0884\n\n// use mouse for add particles\n// use spacebar for clear the screen\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromoneInv(vec2 p)\n{\n\treturn getPheromone(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 100.0 / min(iResolution.x, iResolution.y);\n\tfloat f = getPheromoneInv(fragCoord).x;\n\tfloat fx = (f-getPheromoneInv(fragCoord + vec2(1,0)).x)/e;\n\tfloat fy = (f-getPheromoneInv(fragCoord + vec2(0,1)).x)/e;\n\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\t\n\tfloat diff = max(dot(vec3(0,0,1), n), 0.0);\n\tfloat spec = pow(max(dot(normalize(lightDirection), reflect(vec3(0,0,1),n)), 0.0), specularPower);\n\t\t\n    fragColor.rgb = lightDiffuse * diff + lightSpecular * spec; \n\tfragColor.rgb *= 1.5;\n\t\n    //fragColor = getPheromone(fragCoord);\n    \n\tfragColor.a = 1.0;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle\n// x,y => pos [0 > iResolution.xy]\n// z   => angle [0 > 2pi]\n// abs(w) => sensor angle [0 > pi]\n// if (w > 0.0) => activation\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid SelectIfNearestNeighbor(inout vec4 pnb, vec2 p, vec2 dx)\n{\n    vec4 p_nb = getParticle(p + dx);\n    \n\tif(length(loop_d(p_nb.xy - p, iResolution.xy)) < length(loop_d(pnb.xy - p, iResolution.xy)))\n    {\n        pnb = p_nb;\n    }\n}\n\nvoid SearchForNearestNeighbor(inout vec4 pnb, vec2 p, float ring)\n{\n\t// sides\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,ring));\n\t\n\t// corners\n\tSelectIfNearestNeighbor(pnb, p, vec2(-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring));\n}\n\nvoid EmitParticle(vec2 g, inout vec4 p)\n{\n\tfloat rand = Random(g + p.xy).x;\n\t\n\tp.xy = g; // pos\n\tp.z = rand * 6.28318; // angle\n\n    // sensor angle and activation\n    p.w = mix(sensor_angle_rad_inf, sensor_angle_rad_sup, rand);\n}\n\nvoid MoveParticle(inout vec4 p)\n{\n    // left sensor\n\tfloat an = p.z + p.w;\n    vec2 sleft = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    // right sensor\n\tan = p.z - p.w;\n    vec2 sright = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    float diff_angle = \n        getPheromone(sleft).x - \n        getPheromone(sright).x;\n\t\n    p.z += dt * sensor_strenght * tanh(0.3 * diff_angle);\n\tp.xy += dt * particle_speed * vec2(cos(p.z), sin(p.z));\n    \n\tp.xy = loop(p.xy, iResolution.xy);\n}\n\nvoid PaintByMouse(vec2 g, inout vec4 p)\n{\n\tif (iMouse.z > 0.0)\n\t{\n\t\tif (length(g - iMouse.xy) < uMouseRadius)\n\t\t{\n\t\t\tEmitParticle(g, p);\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragParticles, in vec2 fragCoord )\n{\n\tfragParticles = getParticle(fragCoord);\n\t\n\tSearchForNearestNeighbor(fragParticles, fragCoord, 1.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 2.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 3.0);\n\t\n\tMoveParticle(fragParticles);\n\tPaintByMouse(fragCoord, fragParticles);\n\n\tif (iFrame < 1) // reset \n\t{\n\t\tfragParticles = vec4(0);\n        \n        // start shape\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        uv.y += sin(uv.x * 5.0) * 0.3;\n        uv.x = mod(uv.x, 0.1);\n        float st = 5.0 / iResolution.y;\n        if (length(uv) < st)\n            EmitParticle(fragCoord, fragParticles);\n\t}\n    \n    if (reset(iChannel3))\n        fragParticles = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define dt 0.25\n\n// mouse\nconst float uMouseRadius = 1.0;\n\n// particle\nconst float particle_speed = 5.0;\n\n// pheromones\nconst float gauss_coef = 1.4;\nconst float decay = 0.15;\n\n// sensor\nconst float sensor_strenght = 20.0;\nconst float sensor_distance = 20.0;\nconst float sensor_angle_rad_inf = 1.0;\nconst float sensor_angle_rad_sup = 1.8;\n\n// shading\nconst vec3 lightDiffuse = vec3(0.191553,0.267195,0.373984);\nconst vec3 lightSpecular = vec3(0.243903,1,0);\nconst vec3 lightDirection = vec3(0.08232,-0.24085,-0.58841);\nconst float specularPower = 20.0;\n\n// borderless \nvec2 loop_d(vec2 p, vec2 s){\n\treturn mod(p + s * 0.5, s) - s * 0.5;\n}\n\nvec2 loop(vec2 p, vec2 s){\n\treturn mod(p, s);\n}\n\nvec2 Random(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(123.34,234.35,345.65));\n\ta += dot(a, a + 34.45);\n\treturn fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nbool reset(sampler2D sam) {\n    return texture(sam, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}", "buffer_b_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// pheromone\n// x   => pheromone quantity\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid DiffusePheromones(vec2 g, inout vec4 fragPheromone)\n{\n    // laplacian\n\tfloat v = 0.0;\n    v += getPheromone(g + vec2(-1, 0)).x; // l\n\tv += getPheromone(g + vec2( 0, 1)).x; // t\n\tv += getPheromone(g + vec2( 1, 0)).x; // r\n\tv += getPheromone(g + vec2( 0,-1)).x; // b\n\tv -= 4.0 * fragPheromone.x;\n    \n\tfragPheromone += dt * v;\n}\n\nvoid mainImage( out vec4 fragPheromone, in vec2 fragCoord )\n{\n    fragPheromone = getPheromone(fragCoord);\n    \n    DiffusePheromones(fragCoord, fragPheromone);\n\t\n\t// write pheromones for each particles\n\tvec4 p = getParticle(fragCoord);\n\tif (p.w > 0.0)\n\t{\n\t\tfloat gauss = exp(-pow(length(fragCoord - p.xy)/gauss_coef,2.));\n\t\tfragPheromone += dt * gauss;\n\t}\n\t\n\t// dissipation  \n\tfragPheromone -= dt * decay * fragPheromone;\n    \n    if (iFrame < 1 || reset(iChannel3)) // reset \n\t\tfragPheromone = vec4(0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2cWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[318, 318, 345, 345, 413], [415, 415, 445, 445, 472], [474, 474, 531, 531, 1116]]}
{"id": "fdScWd", "name": "Offset Grid Traversal", "author": "Shane", "description": "Traversing a regular grid of rectangles, an offset grid of rectangles or hexagons.", "tags": ["2d", "grid", "hexagon", "brick", "traversal", "traverse"], "likes": 41, "viewed": 656, "published": 3, "date": "1644331459", "time_retrieved": "2024-07-30T17:04:33.119170", "image_code": "/*\n\n    Offset Grid Traversal\n    ---------------------\n    \n    Since there are so many traversers around, I figured I'd put up a less \n    common one just to show that it's possible to traverse 2D grids other \n    than regular polygons and Voronoi -- The 2D traversal here can be \n    extended to the extruded 3D version with relative ease.\n    \n    The default grid you can see consists of offset rectangles, or a brick\n    arrangement, if you prefer. There are also options for a regular rectangle \n    grid and a hexagonal one, which is inherently offset. The main routine is \n    fast enough, but could be faster. There are some very simple precalculations \n    that could be made to speed things up, but I wanted to illustrate the \n    concepts involved. You could certainly write much faster individual grid \n    traversers.\n    \n    I've been trying to render some isosurfaces lately that involve way too\n    much overlap for a simple sphere-tracing based raymarching routine, so \n    have had to resort to cell by cell grid traversal.\n    \n    I'm comfortable enough with the process, but still found it helpful to\n    reference various examples. There are heaps of nice demonstrations on \n    Shadertoy, but I found IQ and Fizzer's to be written in a style that I \n    prefer, so I referenced those most. If you'd like to learn 2D traversal,\n    then I'd recommend IQ's simple hexagon traverser. If you'd like to \n    tackle more difficult 3D traversers, have a look at some of Fizzer's\n    examples.\n    \n    Grid traversal is a pretty simple concept: Start at the ray origin point \n    and snap it to the nearest grid cell. Trace out from that point in the \n    direction of the unit direction ray to the nearest cell wall. Obtain the \n    neighboring cell, then trace out from the last point to the next cell \n    wall. Continue in the same manner until you reach the end.\n    \n    Anyway, I posted this for the novelty, but I have more interesting \n    traversals that I'll post at some stage. I also have a 3D version of this\n    that I'll put up later.\n    \n    \n    \n    // Other examples:\n    \n    \n    // There are various square cell traversal examples on here,\n    // but this is one I'd recommend looking at if you want to\n    // learn how to traverse regular polygons in 2D.\n    Hexagonal Grid Traversal - 2D -- iq\n    https://www.shadertoy.com/view/WtSBWK\n    \n    // IQ's 3D version: It's beautifully rendered and the traversal \n    // code leaves very little room for improvement.\n    Hexagonal Grid Traversal - 3D -- iq\n    https://www.shadertoy.com/view/WtSfWK\n    \n    // A very cool technical traversal example: For obvious reasons,\n    // it has a marching tetrahedron feel. It's on my list to combine\n    // one of these with the marching tetrahedrons example of mine\n    // on here. By the way, it's worth taking a look at Fizzer's other\n    // traversal examples as well.\n    Tetrahedral Voxel Traversal -- fizzer\n    https://www.shadertoy.com/view/wtfXWB\n    \n    // I think Mattz was the first to traverse hexagonal prisms\n    // on here. He's also written a box prism traverser.\n    hexwaves -- mattz\n    https://www.shadertoy.com/view/XsBczc\n    \n    // An unlisted simplified rectangle traversal example that \n    // should be much easier to understand.\n    Minimal Line Traversal - Shane\n    https://www.shadertoy.com/view/sdfBDM\n    \n    \n*/\n\n// Hexagon option. \n//#define HEXAGON\n\n// Offset grid rows.\n#define OFFSET\n\n// Hexgons must have an offset defined.\n#ifdef HEXAGON\n#ifndef OFFSET\n#define OFFSET\n#endif\n#endif\n\n// Dark layout option.\n//#define DARK\n\n#define sqrt3 1.7320508\n\n\n// Scale.\n#ifdef HEXAGON\n// Hexagons will only work with the \"1:sqrt3\" ratio, but scaling is fine.\n// At some stage, I'll arrange for anything to work, but it's not trivial.\nconst vec2 s = vec2(1, sqrt3); \n#else\n// Rectangle dimensions. Any numbers should work. Obviously, the same two\n// numbers will produce squares.\nconst vec2 s = vec2(1.5, 1); \n#endif\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more, but it isn't\n   // a GPU intensive example, so it'll do.\n   float s = dot(p - ro, n)/dot(rd, n);\n   return s<0. ? 1e8 : s;\n\n}\n*/\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(in vec2 p, in vec2 a, in vec2 b){\n\t\n    p -= a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(p, ba)/dot(ba, ba), 0., 1.);\n\treturn length(p - ba*h);\n}\n \n\n\n\n\n// Grid cell function.\nvec4 getGrid(vec2 p){\n\n    \n    // Returns the local coordinates and cell center position-based\n    // IDs for a hexagon grid, offset rectangle grid and regular\n    // rectangle grid.\n\n    #ifdef HEXAGON\n    \n    // Hexagons.  \n    //\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, sqrt3/3.))) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n    \n    #else\n    \n    // Rectangles.   \n    //    \n    #ifdef OFFSET\n    // Rectangles with an offset. \n    vec2 idOff = vec2(0);\n    if(mod(floor(p.y/s.y), 2.)>.5){\n       p.x -= s.x/2.;\n       idOff.x += .5;\n    }\n    vec2 ip = floor(p/s) + .5;\n    p -= (ip)*s;\n    return vec4(p, ip + idOff);\n    #else\n    // Rectangles with no offset. \n    vec2 ip = floor(p/s) + .5;\n    p -= (ip)*s;\n    return vec4(p, ip);\n    #endif    \n    \n    #endif\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor. With larger resolutions, you want larger \n    // cells, but not so large that everything lacks detail... I'm not a\n    // fan of catering to multiple resolutions, but it is what it is. :)\n    #ifdef HEXAGON\n    float sc = 1./8.*(450./iResolution.y*.5 + .5);\n    #else\n    float sc = 1./10.*(450./iResolution.y*.5 + .5);\n    #endif\n    float sf = 1./(iResolution.y*sc);\n    \n    \n    // Scaling.\n    vec2 p = uv/sc;\n\n    \n    // Note that the scale is partly dependent on screen size, which means\n    // the ray origin will be different for different resolutions.\n    vec2 ro = vec2(sin(iTime/2.)/3., cos(iTime/2.)/4.)/sc;\n    \n    // The unit direction vector. It's already normalized, but it's\n    // good practice to do it.\n    vec2 rd = normalize(vec2(cos(iTime/4.), sin(iTime/4.)));\n    \n    \n    // Moving the camera up, or the scene down, depending on your perspective.\n    // I like it, but Moire patterns (or something along those lines) get in \n    // the way at lower resolutions, so it's off by default.\n    //p.y += iTime/8.;\n    //ro.y += iTime/8.;\n     \n    \n    \n    // Creating the grid for the background cells.\n    vec4 cell = getGrid(p);\n    \n  \n    // Vertices and lines to render at each ray step.\n    float ln = 1e5;\n    float vert = 1e5; \n    \n    \n    // Describing the shape sides via their normals: You'll note that only\n    // half the faces (or sides) are described; That's because only half \n    // are in front of the ray at any given time. When the back face \n    // condition is met (dot(rd, n)<0.), we simply flip the normal, so that\n    // the face behind it is visible. If the the polygon didn't have the \n    // correct symmetry (like an assymetric hexagon, etc), then you'd have\n    // to list all sides.\n    //\n    // Note that the hexagon normals are in index form. They're multiplied\n    // by the scaling factor (s = vec2(1, 1.732)) to turn them into normalized\n    // hexagon side normals. Adding indices then scaling is more accurate, \n    // which is important when doing 3D traversals.\n    #ifdef HEXAGON\n    //\n    // Hexagon.\n    //\n    vec2 n1 = vec2(-.5, .5); // Left face down.\n    vec2 n2 = vec2(1, 0); // Right face.\n    vec2 n3 = vec2(.5, .5); // Right face down.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing\n    // cell wall, if you prefer), use the normal from the back back cell wall.\n    n1 = dot(rd, n1*s)<0.? -n1 : n1;\n    n2 = dot(rd, n2*s)<0.? -n2 : n2; \n    n3 = dot(rd, n3*s)<0.? -n3 : n3; \n    #else\n    //\n    // Rectangle.\n    //\n    vec2 n1 = vec2(0, 1); // Top face, or line.\n    vec2 n2 = vec2(1, 0); // Righ face, or line.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing\n    // cell wall, if you prefer), use the normal from the back back cell wall.\n    n1 = dot(rd, n1)<0.? -n1 : n1;\n    n2 = dot(rd, n2)<0.? -n2 : n2;\n\n    #endif\n \n \n \n    // Cell hit flag.\n    int hit = 0;\n    \n    // Initiate the ray position at the ray origin.\n    vec2 pos = ro;\n    \n     \n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<24; i++){\n    \n        // Obtain the coordinates of the cell that the current ray position \n        // is contained in -- I've arranged for the cell coordinates to \n        // represent the cell center to make things easier.\n        //\n        // Note that we're edging the ray just over the line to avoid hitting \n        // the cell we've just come from. You could edge by the side normal, \n        // but that requires more calculation.\n        //\n        // The last thing to mention is that you'd normally do this outside \n        // the loop once, then add cell wall indices, but the offset rectangles\n        // complicate things a little, so we're doing it the slow way. Having\n        // said that, it's not a big calculation, so the GPU will get over it. :)\n        vec2 ip = getGrid(pos + rd*1e-4).zw;\n        // Technically, it should be this, but no one will notice. :)\n        //vec2 ip = getGrid(pos + min(float(i), 1.)*rd*1e-4).zw;\n        \n        // Ray intersection from the currect cell position to each of the \n        // visible cell walls: Note that the normal is inward facing. Also,\n        // the point on the line is the cell center plus half the cell scale\n        // distance in the direction of the cell wall.\n        #ifdef HEXAGON\n        // Ray origin, ray direction, point on the line and normal.\n        float t1 = rayLine(pos, rd, (ip + n1*.5)*s, -n1*vec2(1, sqrt3));\n        float t2 = rayLine(pos, rd, (ip + n2*.5)*s, -n2*vec2(1, sqrt3));\n        // Extra side consideration for the hexagon.\n        float t3 = rayLine(pos, rd, (ip + n3*.5)*s, -n3*vec2(1, sqrt3));\n        float t = min(min(t1, t2), t3); \n        #else\n        // Ray origin, ray direction, point on the line and normal.\n        float t1 = rayLine(pos, rd, (ip + n1*.5)*s, -n1);\n        float t2 = rayLine(pos, rd, (ip + n2*.5)*s, -n2);\n        float t = min(t1, t2);\n        #endif \n        \n     \n        // Mark the vertex point and ray\n        vert = min(vert, (length(p - pos)  - .1));\n        ln = min(ln, (distLine(p, pos, (pos + rd*t)) - .015));\n        \n     \n        // If this cell's ID matches the ID of the backgound cell, \n        // flag it as hit in order to color it, or whatever.\n        if(length(cell.zw - ip)<.001){ hit = 1; }\n        \n        \n        // Advance the ray position.\n        pos += rd*t;\n    \n    }\n    \n     \n    // Last vertex point.\n    vert = min(vert, (length(uv - pos)  - .01)/sc);\n    \n \n \n    // Rendering.\n    //\n    //\n    // Rendering the background grid. We're taking two samples for bump mapping\n    // purposes. An easier, and less lazy, way would be to use IQ's hexagon\n    // and rectangle gradient fields. :)\n    vec2 acell = abs(cell.xy);\n    vec2 acell2 = abs(cell.xy - normalize(vec2(1, -2))*.01*sc); // Offset sample.\n    #ifdef HEXAGON\n    // Hexagon grid hexagons.\n    float hx = max(acell.y*sqrt3/2. + acell.x*.5, acell.x) - s.x/2.;\n    float hx2 = max(acell2.y*sqrt3/2. + acell2.x*.5, acell2.x) - s.x/2.;\n    #else\n    acell -= s/2.;\n    acell2 -= s/2.;\n    float hx = max(acell.y, acell.x);\n    float hx2 = max(acell2.y, acell2.x);\n    #endif\n    \n    // Bump map, or highlight value.\n    float b = max(hx2 - hx, 0.)/(.01*sc);    \n    \n    // Two colors to decorate the background and hightlighted cells. There are\n    // two color schemes: Dark and textured.\n    #ifdef DARK\n    vec3 col1 = vec3(.04) + hash21(cell.zw)*.02;\n    vec3 col2 = vec3(5, 12, 1)*col1;\n    //vec3 col2 = vec3(3, .1, 15)*col1; // Reverse.\n    #else\n    // Using a texture to color the cells.\n    vec3 tx = texture(iChannel0, cell.zw*s*sc/8. + .5 + vec2(1, 2)*fract(iTime*.0002)).xyz; tx *= tx;\n    // Hacky way to brighten up the dark spots.\n    if(dot(tx, vec3(.299, .587, .114))<.1) tx = tx/(.5 + dot(tx, vec3(.299, .587, .114))) + .03;\n     // Two colors to decorate the background and hightlighted cells.\n    vec3 col1 = smoothstep(-.05, .5, tx.yzx);\n    vec3 col2 = smoothstep(-.02, .5, tx.yzx)*1.35;\n    #endif\n    \n   \n    \n    // Adding some bump highlighting.\n    col1 += (col1*.5 + .5)*b*b*.125;\n    col2 += (col2*.5 + .5)*vec3(4, 1, .5)*b*b*.25 + .03;\n    \n    // Line pattern.\n    float lnSc = 7.;\n    float pat = (abs(fract((p.x - p.y)*lnSc) - .5)*2. - .25)/lnSc;\n    pat = smoothstep(0., sf*2., pat);\n    \n    \n    \n    // Scene color.\n    vec3 col = vec3(0);\n    \n    sc = 1./12.;\n    if(hit == 0){\n        // If the cell hasn't been hit by the ray, render the purple background.\n        col = mix(col, mix(col1, col2.xxx, .05)*1.5, 1. - smoothstep(0., sf, hx + .004/sc));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, hx + (.0045 + .004)/sc));\n        col = mix(col, col1*(pat*.75 + .25), 1. - smoothstep(0., sf, hx + (.0045 + .008)/sc ));\n    }\n    else {\n        // Render the hit cells with something that stands out. I've chosen lime green...\n        // for better or worse. :D\n        col = mix(col, col2*1.5 + .1, 1. - smoothstep(0., sf, hx + .004/sc));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, hx + (.0045 + .004)/sc));\n        col = mix(col, col2.xzy*(pat*.5 + .5), 1. - smoothstep(0., sf, hx + (.0045 + .008)/sc ));\n        \n        float cCntr = length(cell.xy) - .1;\n        //float cCntr = hx + .4;    \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, cCntr))); // Border.\n        col = mix(col, col2, (1. - smoothstep(0., sf, cCntr + .004/sc))); // Top layer.\n\n    } \n     \n    // Render the ray over the background.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln))); // Dark line.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert))); // Vertices.\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, vert + .003/sc));\n    \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdScWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3985, 4013, 4034, 4034, 4097], [4401, 4459, 4507, 4719, 4759], [4761, 4818, 4866, 4866, 4977], [4984, 5007, 5028, 5190, 5896], [5898, 5898, 5954, 5989, 14955]]}
{"id": "NdjcDt", "name": "Approval Seeking Behavior SB", "author": "IWBTShyGuy", "description": "Shyguy needs love! Click (or drag) on the hearts on the screen to give them to Shyguy!", "tags": ["bitmap", "love", "shyguy", "approvalseeking"], "likes": 19, "viewed": 406, "published": 3, "date": "1644330527", "time_retrieved": "2024-07-30T17:04:34.243165", "image_code": "// Copyright © 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// bitmap reference: https://www.spriters-resource.com/\n//\n// font reference:\n// - https://www.shadertoy.com/view/4dtGD2\n// - https://www.shadertoy.com/view/4s3fzl\n\nconst float PI = 3.141592653;\n\nconst uint BITMAP[] = uint[](\n    0u,0u,0u,1431307605u,1430258005u,1426073685u,1409288725u,1342259845u,1074090145u,1397760u,5592320u,22369600u,89478480u,0u,0u,0u,\n    0u,0u,5506368u,22353296u,89478820u,89478548u,89478484u,22369616u,5592384u,1398016u,349184u,86016u,16384u,0u,0u,0u,\n    5592320u,22544208u,111771636u,447381501u,447373300u,1704367440u,1704367444u,1789566964u,1789550580u,1516928976u,443113428u,1990557684u,2102785533u,1476222933u,534140240u,89826560u,\n    0u,5592320u,22544208u,111771636u,447381501u,447373300u,1704367440u,1704367444u,1789566964u,1789550580u,1516928976u,443113428u,1990557684u,1968668509u,1501517221u,1788171924u,\n    0u,0u,0u,0u,0u,1118481u,0u,0u,286331136u,69905u,0u,304087040u,288638019u,273u,536870912u,1144136226u,\n    286475332u,1u,1717903904u,1145319974u,1119044u,1965162496u,628586359u,1145324611u,275u,2004317778u,1144153975u,288638017u,2002919424u,2004318071u,1142178853u,536875332u,\n    1450594933u,1126659666u,288637236u,576070144u,1965172085u,289682007u,570425619u,577905190u,2187817506u,1119032u,572989952u,1914839666u,411669111u,570425344u,577905191u,2457301538u,\n    34969u,576135680u,1965172085u,2290647671u,570425344u,1450594919u,1114076754u,4420u,2004230656u,2004318071u,336872023u,570425344u,2004318069u,1126659959u,69956u,2003968000u,\n    2004317991u,340018213u,536870913u,1999075154u,1145202551u,1127492u,1965101056u,628586279u,1145324612u,285212689u,1734681139u,1145324069u,18039876u,873730320u,1144136226u,1145324612u,\n    1091567892u,1145324564u,1125205060u,18105412u,1142178064u,1145324612u,1144066356u,286261523u,1713652497u,1145324566u,1118481u,571543808u,577205794u,288559394u,1u,573850641u,\n    1145323810u,70724u,823201792u,1145324612u,1270551364u,570425361u,1144067413u,1527989316u,18068821u,1431654912u,860111637u,1431655761u,570425618u,827675989u,1431441715u,1189205u,\n    572661760u,17895970u,572662306u,0u,268435456u,1118481u,0u,0u,286331424u,4369u,0u,572661760u,288638002u,17u,572522496u,841377381u,\n    17904708u,0u,2004317474u,1145251191u,4404u,1985085440u,1735882615u,340018226u,536870913u,2004318050u,1143306103u,1131588u,1383407616u,1985107574u,1145324327u,570425620u,\n    628433494u,1113027874u,288637252u,572924416u,1914839666u,340013671u,570429764u,577905191u,2188866082u,289608776u,572989952u,1914839666u,881431159u,570429713u,628433495u,2457302306u,\n    17905817u,1382490624u,1985107574u,412648039u,570425345u,2004318070u,844593015u,17897603u,2004165136u,2004318071u,1091846951u,588321076u,1999075186u,337999735u,323241009u,2001871889u,\n    1735882535u,1145319746u,1141969732u,1999074595u,1145316727u,289686596u,573850384u,1109747557u,1145324612u,1091567892u,572662068u,1145324594u,18039876u,1125388544u,1145324612u,876889156u,\n    268435473u,1145324561u,1145324612u,70468u,1141964800u,1145324612u,288638020u,0u,1712534544u,876884758u,273u,554696704u,577205794u,286462242u,0u,573809425u,\n    1144197410u,69946u,1244729344u,1152033860u,323241028u,268435457u,1145319697u,329532484u,1129403u,357900800u,1145324609u,3042269972u,1375731729u,1125864789u,1431385156u,1201493u,\n    1431642624u,288567733u,626349490u,536870930u,287449634u,572653841u,8738u,0u,0u,0u,0u,0u,0u,286331136u,286331153u,0u,\n    0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,286331152u,286331153u,69905u,0u,0u,\n    0u,0u,0u,0u,0u,0u,0u,0u,0u,841027856u,858993459u,286401331u,1u,0u,0u,0u,\n    0u,0u,0u,0u,0u,0u,0u,857805056u,1145324579u,858932292u,4370u,0u,0u,0u,0u,0u,\n    0u,0u,0u,0u,0u,857804800u,1716864035u,1146447462u,17969970u,0u,0u,0u,0u,0u,0u,0u,\n    0u,0u,0u,839974912u,2004239395u,2004318071u,590496871u,17u,0u,0u,0u,0u,0u,0u,0u,0u,\n    0u,554696704u,2004173363u,2004318071u,609711991u,70195u,0u,0u,0u,0u,0u,0u,0u,0u,0u,285212672u,\n    2003051314u,2004318071u,2004318071u,287519302u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,1967338257u,2004318071u,\n    2004318071u,859068279u,273u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1110651152u,2004318071u,2004318071u,611809143u,\n    70451u,0u,0u,0u,0u,0u,0u,0u,0u,0u,858919168u,2004318052u,2004318071u,2004318071u,287519558u,0u,\n    0u,0u,0u,0u,0u,0u,0u,0u,856752128u,1215788067u,2004318276u,2219083639u,858933111u,17u,0u,0u,\n    0u,0u,0u,0u,0u,0u,554696704u,2541110067u,2006205508u,1145665399u,879196484u,70195u,0u,0u,0u,0u,\n    0u,0u,0u,0u,268435456u,2000827169u,1145324616u,1149728632u,2005156932u,17969956u,0u,0u,0u,0u,0u,0u,\n    0u,0u,0u,1680023824u,1145324663u,1199010884u,1145324612u,305284727u,1u,0u,0u,2863267840u,0u,0u,0u,0u,\n    0u,2987462656u,1145337716u,2004108356u,1145324615u,726103876u,273u,0u,0u,2852126720u,43690u,178956970u,0u,0u,0u,2853175296u,\n    1148679754u,1950630980u,1145325431u,1735869508u,109220u,0u,0u,0u,178955946u,2863311360u,2730u,0u,0u,268435456u,2004307402u,1145324612u,\n    1145534324u,2000962628u,28103799u,0u,0u,0u,2841029280u,1722417322u,11184725u,0u,0u,0u,2003094016u,1145325687u,2272753732u,2219066436u,\n    2890299255u,0u,0u,0u,2522521600u,2863311446u,2863031914u,10u,0u,0u,1984167936u,1150777207u,2004325444u,1145325943u,1735882617u,68u,\n    0u,0u,1788870656u,2863224470u,1717988010u,43685u,0u,0u,1413480448u,2004318071u,2004370504u,1149728631u,2004318084u,279927u,0u,0u,\n    2852126720u,1767282026u,1722458282u,178939750u,0u,0u,1073741824u,4008605556u,2004318071u,2004318071u,4000806775u,71792622u,0u,0u,0u,2522441130u,\n    2862656101u,2792842858u,170u,0u,0u,4008146244u,2004319982u,2004318071u,3883366263u,1467936494u,68u,0u,0u,1767287456u,11163285u,2003200682u,\n    698982u,0u,0u,3883222016u,2004807406u,2004318071u,2004318071u,2129587943u,17511u,0u,0u,2522521600u,178674021u,1722460672u,2863031927u,0u,\n    0u,1984167936u,2012147319u,2004318071u,2004318071u,4008605559u,4482935u,0u,0u,1789526016u,2775144086u,2862612490u,1449555818u,170u,0u,1091637248u,\n    2004318070u,2004318071u,2004318071u,2004318071u,342325111u,17u,0u,2852126720u,1704355430u,2730u,1719102122u,43622u,0u,286331136u,2004317761u,2004318071u,\n    2004318071u,2004318071u,1735882615u,1118484u,0u,2684354560u,1717986906u,43606u,2007670784u,178939494u,0u,554766592u,2004173346u,2004318071u,2004318071u,2004318071u,\n    2004318071u,287450199u,17u,0u,1717988010u,11183718u,2852126720u,2774951541u,10u,554766336u,1967338303u,2004318071u,2004318071u,2004318071u,2004318071u,859068279u,\n    1118499u,0u,1717938688u,178611814u,0u,1717992106u,2726u,4044423168u,1127428915u,2004318052u,2004318071u,2004309367u,2004318071u,877033335u,287519539u,1u,\n    1521090560u,2858837606u,10u,1722458112u,697958u,554762240u,858993459u,2004309027u,2004318071u,2000975735u,2004318071u,1165457271u,858993458u,4371u,2684354560u,1449551274u,\n    170u,2852126720u,178611813u,554766336u,858993663u,1984181043u,2004318071u,1148680055u,2004318071u,1735882615u,858993476u,287306547u,1u,1717938688u,43686u,0u,\n    2774948522u,286326794u,858993459u,1127428915u,2004318052u,2004318071u,2004318020u,2004318071u,858993734u,858993459u,69919u,1721368576u,698778u,0u,296394752u,286263969u,\n    858993458u,858993459u,2004239411u,2004318071u,2004309367u,2004318071u,858997863u,858993459u,286405427u,1788870656u,178956886u,0u,286261248u,285875131u,858993649u,858993459u,\n    1413690163u,2004318327u,2004318071u,2272753527u,859063671u,858993459u,4080218931u,2684354833u,2863310442u,0u,285212672u,437400353u,858993425u,858993459u,858993459u,1989497924u,\n    2004318071u,1735882615u,860112217u,858993459u,858993459u,1119027u,2702272938u,0u,268435456u,288568081u,858988970u,858993459u,858993459u,1145316147u,2004317784u,1735882615u,\n    843334789u,858993459u,858993459u,288568115u,555133457u,273u,0u,590553360u,872064337u,858993459u,858993459u,2452828979u,1700021401u,1449621366u,697582661u,858993459u,\n    858993459u,858993459u,379232531u,1122098u,0u,859508992u,2857786035u,858993459u,858993459u,2570269491u,1150711385u,1145324612u,1718174788u,859019669u,858993459u,858993459u,\n    1788949299u,301150998u,0u,839974912u,1722463027u,858993573u,858993459u,2570269491u,1771534181u,1968600951u,2506585975u,2572580713u,858993459u,858993459u,2939368243u,858986857u,\n    283u,2970615808u,2703438655u,859022693u,858993459u,2570269491u,1503098725u,1969715063u,2004318071u,2004456823u,859019606u,858993459u,858993459u,856778410u,70195u,268435456u,\n    590561057u,866802338u,871576371u,2469606195u,1501001557u,1450669942u,2004318071u,2507634551u,966092663u,4080218931u,858993459u,827746867u,17969971u,0u,858988816u,984232499u,\n    1060320051u,858993459u,2541188697u,1735882613u,2004318054u,2004318071u,1735883095u,858993557u,858996531u,2775200563u,305345329u,1u,857804800u,858993459u,590558003u,858993459u,\n    2004317587u,2004318041u,2004317798u,2004318071u,1989506935u,859395703u,857944883u,2855482163u,858993578u,274u,2970615808u,858993471u,858993459u,858993467u,2004310323u,2004317591u,\n    2004313719u,2004318071u,2524411767u,2506585973u,858993459u,858993467u,858993459u,72691u,268435456u,858996497u,858993459u,858993587u,2003432243u,2004326007u,2003199863u,2004318071u,\n    2004318071u,2004314455u,858996630u,859026227u,858993459u,17953587u,0u,858919168u,858993459u,859042099u,1989358387u,2003400567u,1718056823u,2004318071u,2004318071u,2002347895u,\n    859395703u,825439027u,858993459u,287519539u,0u,554762240u,858993459u,858919731u,2469606195u,2037872502u,1735882615u,2004318054u,2004318071u,1499953015u,4184307575u,858993459u,\n    858993427u,523449139u,17u,268435456u,858993185u,856765235u,858993459u,1467447199u,2004318073u,2004317798u,2004318071u,1735882615u,1735882645u,858993557u,871441203u,858993459u,\n    274u,0u,841093392u,554840883u,858993459u,2004314419u,2004317847u,2004248183u,2004318071u,2004318071u,2004260199u,859805287u,288568115u,858993458u,70131u,0u,\n    554762240u,304226850u,858993649u,1771647795u,2004326263u,1986426743u,2004318071u,2004318071u,1989502583u,4183193463u,858993459u,858923282u,1118755u,0u,268435456u,572662033u,\n    858993169u,1496527667u,2006411669u,1719105399u,2004318070u,2004318071u,2505467767u,1719105398u,858993557u,572596019u,17900066u,0u,0u,286331136u,858919185u,858993459u,\n    2526373465u,2004318071u,2004318054u,2004318071u,2576980374u,2004317845u,859018598u,287519539u,286401058u,0u,0u,285212672u,1058083089u,858993459u,1449548083u,2004318105u,\n    2004318071u,2004318071u,1717983591u,2004261225u,871978599u,590558003u,286400785u,1u,0u,0u,2970681344u,858993459u,1704932147u,2004194662u,2004318071u,2004318071u,\n    1717933943u,1989572966u,1066755703u,858993459u,286331379u,17u,0u,0u,285212672u,858993441u,4080218931u,2036754009u,2004318071u,2004318071u,1721202551u,2524538486u,\n    4187317878u,858993459u,286995251u,17u,0u,0u,0u,858988817u,858993459u,1717149491u,1719105429u,2576980377u,2524411766u,1768322918u,4187317849u,858993459u,\n    305345331u,17u,0u,0u,0u,857805056u,858993459u,2670932787u,2576963993u,2004313753u,1734973798u,1718056537u,4187575701u,858993459u,858993459u,4370u,\n    0u,0u,0u,554762240u,858993459u,858993459u,1771238195u,2004318071u,2523363191u,1719104921u,1067030933u,858993459u,858993459u,1118771u,0u,0u,\n    0u,285212672u,858996513u,858993459u,858993459u,2004317842u,2004318071u,1735882615u,859777366u,858993459u,858993459u,286454579u,0u,0u,0u,0u,\n    858923281u,858993459u,858993459u,2004427571u,2004318071u,2004318071u,858953319u,858993459u,858993459u,304296755u,17u,0u,0u,0u,841027840u,858993459u,\n    858993459u,1496527667u,2004318071u,2004318071u,865429111u,858993459u,858993459u,590558003u,4370u,0u,0u,0u,2970681344u,858993442u,858993459u,858993459u,\n    1719104927u,1717986918u,4183189366u,858993459u,858993459u,858993459u,1121058u,0u,0u,0u,268435456u,858925841u,858993459u,858993459u,1431958323u,2576980373u,\n    2505397593u,858993471u,858993459u,858993459u,17936931u,0u,0u,0u,0u,722538768u,858996722u,858993459u,2670932787u,859777433u,2576978675u,858993657u,\n    858993459u,4080218931u,286990895u,1u,0u,0u,0u,286326784u,286331153u,859828753u,858993459u,858993459u,858993459u,858993459u,858993459u,288355123u,\n    286331153u,17u,0u,0u,0u,286326784u,859042481u,286335743u,858993441u,858993459u,858993459u,858993459u,858993459u,286331443u,791887858u,1118491u,\n    0u,0u,0u,286261248u,554766609u,858993458u,571544307u,858993459u,858993459u,858993459u,858993459u,1059131682u,590558003u,286331154u,17u,0u,\n    0u,285212672u,4080267793u,857805074u,590558003u,4062318865u,858993471u,858993459u,573567795u,858919185u,573780787u,4081000721u,69906u,0u,0u,268435456u,\n    858993169u,523449139u,858993441u,287454003u,286331153u,286331153u,286331153u,858993169u,305345331u,858996497u,286405427u,0u,0u,0u,858988816u,858993459u,\n    857808691u,858993459u,1145324067u,1431655765u,1145324629u,858993442u,305345331u,858993649u,590558003u,17u,0u,0u,871436544u,858993459u,322122547u,858993457u,\n    590558003u,1145324610u,574899268u,858993459u,573780787u,858993457u,858993459u,4399u,0u,0u,571539456u,858993471u,858993459u,4080185907u,858993459u,587150131u,\n    872358434u,858993459u,590558003u,858993467u,858993459u,17965811u,0u,0u,285212672u,2863276578u,858989226u,573780787u,859042355u,858993459u,858993459u,858993459u,\n    858993459u,858993458u,2863276595u,304261802u,1u,0u,0u,3433734673u,715836620u,858993459u,4062392883u,858993459u,858993459u,858993459u,791884595u,858993459u,\n    3433734707u,2865552861u,274u,0u,0u,3721046688u,3722304989u,858991276u,857944883u,859042338u,858993459u,858993459u,804467507u,858993458u,3721044531u,3722304989u,\n    11184845u,0u,0u,3721046528u,3722304989u,984407517u,858993459u,572662579u,858993663u,858993459u,587150131u,858993442u,3721044787u,3722304989u,2865618397u,10u,\n    0u,3702169600u,3722304989u,3722304989u,858993580u,791884595u,4280427042u,858993471u,572665855u,858993186u,3721016115u,3722304989u,3722304989u,43692u,0u,3399483392u,\n    3722304989u,3722304989u,859491805u,858993459u,572662323u,572662306u,572662306u,858989090u,3718460211u,3722304989u,3722304989u,11193565u,0u,2852126720u,3722304986u,3722304989u,\n    2900221405u,858993459u,586363699u,572662306u,572662306u,858923554u,3660788531u,3722304989u,3722304989u,2865552861u,10u,0u,3722304170u,3722304989u,3722304989u,858995405u,\n    858993459u,572662307u,572662306u,857874978u,2738041651u,3722304989u,3722304989u,3437092317u,2730u,0u,3722095104u,3722304989u,3722304989u,866962909u,590558003u,586363711u,\n    572662306u,1059201570u,858993459u,3722304970u,3722304989u,3722304989u,699084u,0u,3668574208u,3722304989u,3722304989u,2899172829u,858993458u,572665651u,572662306u,1059201570u,\n    858993459u,3722304035u,3722304989u,3722304989u,178965709u,0u,2852126720u,3722304970u,3722304989u,3453869533u,858991308u,4281545523u,572662306u,1072833058u,858993459u,3722224179u,\n    3722304989u,3722304989u,2865548765u,10u,0u,3722291882u,3722304989u,3722304989u,555404492u,858993459u,4294914867u,859832319u,858993459u,3701550899u,3722304989u,3722304989u,\n    2899107293u,170u,0u,3702169600u,3722304989u,3722304989u,718064861u,858988827u,858993459u,858993459u,858993459u,2870030131u,3722304988u,3722304989u,3436043741u,43692u,\n    0u,2862612480u,3722304970u,3722304989u,3435974109u,555426346u,858993471u,858993459u,858993459u,722539251u,3722304674u,3722304989u,3437092317u,699084u,0u,0u,\n    3722226346u,3722304989u,3435978205u,572664748u,1072828699u,858993459u,4080218931u,582029615u,3722097186u,3722304989u,3453869533u,11185356u,0u,0u,3400179712u,3722304989u,\n    3436043741u,572697804u,296886818u,872358417u,587150131u,573247761u,3391234594u,3722304989u,3453869533u,178965708u,0u,0u,2852126720u,3722300074u,3436043741u,582667468u,\n    572662306u,286374690u,286331153u,572701457u,572662306u,3722304683u,3437092317u,2863320268u,0u,0u,0u,3400182432u,3435978204u,732744908u,572662306u,572662306u,\n    572662306u,572662306u,572662306u,3721048610u,3435978205u,2863320268u,10u,0u,0u,2862612480u,3435965098u,2863451340u,2970685713u,572662459u,572662306u,3149013538u,\n    286331153u,2702250257u,3435973834u,2863312076u,10u,0u,0u,0u,2863311520u,2863311530u,286331162u,286331153u,286331153u,286331153u,286331153u,286331153u,\n    2863311377u,2863311530u,10u,0u,0u,0u,2852126720u,2863311530u,170u,286331152u,286331153u,286331153u,286331153u,0u,2862612480u,2863311530u,0u,0u,0u\n);\n\nconst int FONT[] = int[](\n 0x69f99, 0x79797, 0xe111e, 0x79997, 0xf171f, 0xf1711, 0xe1d96, 0x99f99, \n 0xf444f, 0x88996, 0x95159, 0x1111f, 0x9f999, 0x9bd99, 0x69996, 0x79971,\n 0x69b5a, 0x79759, 0xe1687, 0xf4444, 0x99996, 0x999a4, 0x999f9, 0x99699,\n 0x99e8e, 0xf843f, 0x6bd96, 0x46444, 0x6942f, 0x69496, 0x99f88, 0xf1687,\n 0x61796, 0xf8421, 0x69696, 0x69e84, 0x66400, 0x0faa9, 0x0000f, 0x00600,\n 0x0a500, 0x02720, 0x0f0f0, 0x08421, 0x33303, 0x69404, 0x00032, 0x00002,\n 0x55000, 0x00000, 0x00202, 0x42224, 0x24442);\n\nconst vec4 BLACK = vec4(0, 0, 0, 1);\nconst vec4 SEMI_WHITE = vec4(252, 252, 252, 255) / 255.0;\nconst vec4 SEMI_RED = vec4(252, 0, 0, 255) / 255.0;\n\nconst vec4 SHYGUY_BLACK = vec4(40, 40, 40, 255) / 255.0;\nconst vec4 SHYGUY_RED = vec4(216, 40, 0, 255) / 255.0;\n\nconst vec4 STEEL_RED = vec4(228, 0, 127, 255) / 255.0;\nconst vec4 STEEL_HIGHLIGHT = vec4(252, 127, 252, 255) / 255.0;\n\nconst vec4 RED_HIGHLIGHT = vec4(252, 127, 127, 255) / 255.0;\n\nconst vec4 BAR_FRAME = vec4(228, 228, 228, 255) / 255.0;\n\nconst vec4 STORY_PALLET[] = vec4[](\n    vec4(0),\n    vec4(0x63, 0x08, 0x08, 0xff) / 255.0,\n    vec4(0x21, 0x21, 0x21, 0xff) / 255.0,\n    vec4(0x84, 0x08, 0x10, 0xff) / 255.0,\n    vec4(0xce, 0x29, 0x31, 0xff) / 255.0,\n    vec4(0x63, 0x63, 0x84, 0xff) / 255.0,\n    vec4(0xb5, 0xc6, 0xd6, 0xff) / 255.0,\n    vec4(0xe7, 0xe7, 0xef, 0xff) / 255.0,\n    vec4(0x5a, 0x21, 0x08, 0xff) / 255.0,\n    vec4(0xd6, 0x9c, 0x39, 0xff) / 255.0,\n    vec4(0xa5, 0x18, 0x21, 0xff) / 255.0,\n    vec4(0x42, 0x31, 0x63, 0xff) / 255.0\n);\n\nconst vec4 GOURMET_PALLET[] = vec4[](\n    vec4(0),\n    vec4(0x39, 0x08, 0x18, 0xff) / 255.0,\n    vec4(0x7b, 0x21, 0x42, 0xff) / 255.0,\n    vec4(0xad, 0x31, 0x5a, 0xff) / 255.0,\n    vec4(0x21, 0x21, 0x21, 0xff) / 255.0,\n    vec4(0x8c, 0x9c, 0xa5, 0xff) / 255.0,\n    vec4(0xb5, 0xbd, 0xc6, 0xff) / 255.0,\n    vec4(0xd6, 0xd6, 0xd6, 0xff) / 255.0,\n    vec4(0x6b, 0x7b, 0x84, 0xff) / 255.0,\n    vec4(0x42, 0x52, 0x5a, 0xff) / 255.0,\n    vec4(0x08, 0x10, 0x39, 0xff) / 255.0,\n    vec4(0x63, 0x18, 0x29, 0xff) / 255.0,\n    vec4(0x29, 0x4a, 0x7b, 0xff) / 255.0,\n    vec4(0x39, 0x6b, 0xa5, 0xff) / 255.0,\n    vec4(0xce, 0x73, 0x73, 0xff) / 255.0,\n    vec4(0x94, 0x21, 0x4a, 0xff) / 255.0\n);\n\nconst int I_want_your_Love[] = int[](\n    73, 32, 119, 97, 110, 116, 32, 121, 111, 117, 114, 32, 76, 111, 118, 101\n);\n\nconst int CLICK[] = int[](67, 108, 105, 99, 107, 32, 127);\n\nstruct ShyGuyStatus {\n    int mode;\n    int currentHeart;\n    float elapsed;\n} status;\n\nvoid initStatus() {\n    vec4 data = texelFetch(iChannel0, ivec2(0, 1), 0);\n    int currentHeart = int(data.x); float elapsed = iTime - data.y;\n    bool thumbnail = texelFetch(iChannel0, ivec2(1, 1), 0).x == 1.0;\n    if (thumbnail) status = ShyGuyStatus(1, 3, 1.0);\n    else if (currentHeart < 8) status = ShyGuyStatus(0, currentHeart, elapsed);\n    else if (currentHeart < 24) status = ShyGuyStatus(1, currentHeart - 8, elapsed);\n    else if (currentHeart < 56) status = ShyGuyStatus(2, currentHeart - 24, elapsed);\n    else status = ShyGuyStatus(3, 0, elapsed);\n}\n\nvec4 steel(in ivec2 u) {\n    switch (BITMAP[15 - u.y]>>2*u.x&3u) {\n        case 0u: return STEEL_RED;\n        case 2u: return STEEL_HIGHLIGHT;\n        default: return vec4(0);\n    }\n}\n\nvec4 bitmapShyGuy(in ivec2 u, in int idx, in bool red) {\n    switch (BITMAP[32 + 15 - u.y + (idx % 2) * 16]>>u.x*2&3u) {\n        case 1u: return BLACK;\n        case 2u: return SEMI_WHITE;\n        case 3u: return red ? SHYGUY_RED : SHYGUY_BLACK;\n        default: return vec4(0);\n    }\n}\n\nvec4 storyShyGuy(in ivec2 u, in int idx) {\n    idx = 512 + 28 * (32 - u.y + (idx % 2) * 33) + u.x;\n    u = ivec2(idx % 8, idx / 8);\n    return STORY_PALLET[BITMAP[u.y]>>u.x*4&15u];\n}\n\nvec4 groumetGuy(in ivec2 u) {\n    int idx = 2360 + 114 * (93 - u.y) + u.x;\n    u = ivec2(idx % 8, idx / 8);\n    return GOURMET_PALLET[BITMAP[u.y]>>u.x*4&15u];\n}\n\nvec4 heart(in ivec2 u) {\n    switch (BITMAP[31 - u.y]>>u.x*2&3u) {\n        case 1u: return SEMI_RED;\n        case 2u: return RED_HIGHLIGHT;\n        default: return vec4(0);\n    }\n}\n\nvoid collapse(inout ivec2 v, in int idx, in float gen) {\n    float t = max(status.elapsed - 1.5, 0.0),\n    r = PI * noise11(float(idx) + gen);\n    v -= ivec2(vec2(cos(r) * t, sin(r) * t - t * t) * 64.0);\n}\n\nvec4 renderBase(in ivec2 u) {\n    vec4 res = vec4(0);\n    for (int i = -6; i < 5; i++) {\n        ivec2 v = u - ivec2(i * 16 + 8, 3 * 16);\n        if (status.mode == 3) collapse(v, i, 0.0);\n        if (v == abs(v) && 15 - v == abs(15 - v)) res = max(res, steel(v));\n    }\n    for (int i = 0; i < 3; i++) {\n        ivec2 v = u - ivec2(-72, i * 16);\n        if (status.mode == 3) collapse(v, i, -100.0);\n        if (v == abs(v) && 15 - v == abs(15 - v)) res = max(res, steel(15 - v.yx));\n        v = u - ivec2(56, i * 16);\n        if (status.mode == 3) collapse(v, i, 100.0);\n        if (v == abs(v) && 15 - v == abs(15 - v)) res = max(res, steel(15 - v.yx));\n    }\n    return res;\n}\n\nvec4 renderShyguy(in ivec2 u) {\n    vec4 res = vec4(0);\n    switch (status.mode) {\n        case 0:\n        case 1: {\n            u -= ivec2(-8, 64);\n            ivec2 size = ivec2(16, 16);\n            if (u == abs(u) && size - u - 1 == abs(size - u - 1)) {\n                int idx = int(mod(iTime * 2.0, 4.0));\n                if (idx / 2 == 1) u.x = 15 - u.x;\n                res = bitmapShyGuy(u, idx % 2, status.mode == 1);\n            }\n            break;\n        }\n        case 2: {\n            u -= ivec2(-14, 64);\n            ivec2 size = ivec2(28, 33);\n            if (u == abs(u) && size - u - 1 == abs(size - u - 1)) {\n                int idx = int(mod(iTime * 2.0, 4.0));\n                if (idx / 2 == 1) u.x = 27 - u.x;\n                res = storyShyGuy(u, idx % 2);\n            }\n            break;\n        }\n        case 3: {\n            float t = max(status.elapsed - 1.5, 0.0);\n            u -= ivec2(-57, 64.0 - 64.0 * t * t);\n            ivec2 size = ivec2(114, 94);\n            if (u == abs(u) && size - u - 1 == abs(size - u - 1)) {\n                res = groumetGuy(u);\n            }\n            break;\n        }\n    }\n    return int(min(status.elapsed * 30.0, 9.0)) % 2 == 0 && res.x != 0.0 ? vec4(1) : res;\n}\n\nivec2 getHeartPosition(in int i) {\n    vec4 data = texelFetch(iChannel0, ivec2(i, 0), 0);\n    vec2 originalPosition = data.xy; float t = data.w;\n    return t == 1.0 ? ivec2(-100) : ivec2(mix(originalPosition, vec2(0, 72), t));\n}\n\nvec4 renderHeart(in ivec2 u) {\n    vec4 res = vec4(0);\n    for (int i = 0; i < 20; i++) {\n        ivec2 v = u - getHeartPosition(i) + 8;\n        res = abs(v) == v && abs(16 - v) == 16 - v ? max(heart(v), res) : res;\n    }\n    return res;\n}\n\nstruct DChar { ivec2 uv; int idx; };\nint codeTranslate(int c) { return c == 127 ? 49 : c < 97 ? c < 65 ? c == 32 ? 49 : c : c - 65 : c - 97; }\nvec4 letter(in ivec2 u, in int c) { return vec4(c = u.x < 4 ? (FONT[c]>>4*u.y+u.x)&1 : 0, c, c, 1); }\nDChar getDiscreteCenterLettersIndex(in ivec2 u, in int size, in int yBase, in int len) {\n    u = (u - ivec2(-5 * size * len / 2, yBase)) / size;\n    int idx = (u.x + 5) / 5 - 1;\n    u.x -= idx * 5;\n    idx = u == abs(u) && 4 - u == abs(4 - u) && 0 <= idx && idx < len ? idx : -1;\n    return DChar(u, idx);\n}\n\nvec4 renderLetter(in ivec2 u) {\n    DChar c = getDiscreteCenterLettersIndex(u, 2, 220, I_want_your_Love.length());\n    if(c.idx != -1) return letter(c.uv, codeTranslate(I_want_your_Love[c.idx]));\n    c = getDiscreteCenterLettersIndex(u, 2, 190, CLICK.length());\n    if(c.idx != -1) return letter(c.uv, codeTranslate(CLICK[c.idx]));\n    return vec4(0);\n}\n\nfloat heartFillRatio() {\n    float fCurrentHeart = float(status.currentHeart);\n    switch (status.mode) {\n        case 0: return fCurrentHeart / 8.;\n        case 1: return fCurrentHeart / 16.;\n        case 2: return fCurrentHeart / 32.;\n        default: return 1.;\n    }\n}\n\nvec4 renderHeartBar(in ivec2 u, in int screenWidth) {\n    u -= ivec2(screenWidth / 2 - 20, 75);\n    ivec2 size = ivec2(8, 136);\n    int k = abs(u.y - 68) - 64;\n    if (k == 0 || k == 1) return abs(u.x - 4) < 4 ? BAR_FRAME : vec4(0);\n    else if (k == 2) return abs(u.x - 4) < 3 ? BAR_FRAME : vec4(0);\n    else if (k == 3) return abs(u.x - 4) < 1 ? BAR_FRAME : vec4(0);\n    else if (k < 0) {\n        k = abs(u.x - 4);\n        if (k > 3) return vec4(0);\n        else if (k == 3) return BAR_FRAME;\n        else return u.y - 5 < int(heartFillRatio() * 128.0) ? RED_HIGHLIGHT : BLACK;\n    }\n    return vec4(0);\n}\n\nvec4 renderWhiteHeart(in ivec2 u) {\n    u -= ivec2(22, 186);\n    if (0 <= u.x && u.x < 16 && 0 <= u.y && u.y < 16) {\n        int c = heart(u) == vec4(0) ? 0 : 1;\n        return vec4(c, c, c, 1);\n    }\n    return vec4(0);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    initStatus();\n    vec2 r = iResolution.xy;\n    int screenWidth = int(r.x / r.y * 256.0);\n    ivec2 u = ivec2(U / r.y * 256.0) - ivec2(screenWidth / 2, 0);\n    O = renderHeartBar(u, screenWidth);\n    O = O.w != 0.0 ? O : renderHeart(u);\n    O = O.w != 0.0 ? O : renderBase(u);\n    O = O.w != 0.0 ? O : renderShyguy(u);\n    O = O.w != 0.0 ? O : renderWhiteHeart(u);\n    O = O.w != 0.0 ? O : renderLetter(u);\n    O = O.w != 0.0 ? O : BLACK;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Memory Buffer\n//\n// The MIT License\n// Copyright © 2022 IWBTShyGuy\n//\n\n/*\nmemory layout\n\nrow 0: heart status\nEach pixel represents one heart status.\n    vec2(original_position), clicked_time, move_parameter\n\n- original_position: pixel coordinate, y-height == 256, x-center == 0\n- clicked_time: if heart has not been clicked, this parameter is 0.0.\n- move_parameter: the parameter of heart move in [0, 1]. Default is 0.0.\n\npixel (0, 1):\n- channel 0: the number of hearts that shyguy gets\n- channel 1: previous time that shyguy gets heart\n- channel 2: time if heart velocity is took into account\n- channel 3: previous frame iTime\n\npixel (1, 1):\n- channel 0: if thumnail, this value is 1.0, else 0.0.\n*/\n\nivec2 heartOriginalPosition(in int i) {\n    vec2 r = iResolution.xy;\n    float t = texelFetch(iChannel0, ivec2(0, 1), 0).z,\n        screenWidth = r.x / r.y * 256.0,\n        yFirst = float(i) * 16.0 + 8.0,\n        id = floor((yFirst + t / 32.0) / 16.0);\n    return ivec2(\n        screenWidth * (noise11(id) - 0.5),\n        mod(yFirst + t * 10.0, 320.0) - 32.0\n    );\n}\n\nvec4 heartPositionBuffer(in int i) {\n    ivec2 p = heartOriginalPosition(i),\n    previousPosition = ivec2(texelFetch(iChannel0, ivec2(i, 0), 0).xy);\n    int currentHeart = int(texelFetch(iChannel0, ivec2(0, 1), 0).x);\n    float clickedTime = iFrame == 0 || p.y < previousPosition.y ?\n        0.0 : texelFetch(iChannel0, ivec2(i, 0), 0).z;\n    if ((iMouse.z > 0.0 || iMouse.w > 0.0) && clickedTime == 0.0 && currentHeart < 56) {\n        vec2 r = iResolution.xy;\n        int screenWidth = int(r.x / r.y * 256.0);\n        ivec2 v = ivec2(iMouse.xy / r.y * 256.0) - ivec2(screenWidth / 2, 0) - p + 8;\n        clickedTime = abs(v) == v && abs(16 - v) == 16 - v ? iTime : 0.0;\n    }\n    float t = clickedTime > 0.0 ? min((iTime - clickedTime) * 2.0, 1.0) : 0.0;\n    return vec4(p, clickedTime, t);\n}\n\nint gotHeart() {\n    int res = 0;\n    for (int i = 0; i < 20; i++) {\n        float previousParameter = texelFetch(iChannel0, ivec2(i, 0), 0).w;\n        float currentParameter = heartPositionBuffer(i).w;\n        res += previousParameter < 1.0 && currentParameter == 1.0 ? 1 : 0;\n    }\n    return res;\n}\n\nfloat heartVelocity(int currentHeart) {\n    if (currentHeart < 8) return 1.0;\n    else if (currentHeart < 24) return 2.0;\n    else if (currentHeart < 56) return 4.0;\n    else return 8.0;\n}\n\nvec4 currentStatusBuffer() {\n    if (iFrame == 0) return vec4(0, -100, iTime, iTime);\n    vec4 res = texelFetch(iChannel0, ivec2(0, 1), 0);\n    int got = gotHeart();\n    if (got != 0) {\n        res.x += float(got);\n        res.y = iTime;\n    }\n    res.z += (iTime - res.w) * heartVelocity(int(res.x));\n    res.w = iTime;\n    return res;\n}\n\nfloat isThumbnail() {\n    if (iFrame == 0) return iTime < 9.0 ? 0.0 : 1.0;\n    else return texelFetch(iChannel0, ivec2(1, 1), 0).x;\n}\n\nvoid mainImage(out vec4 O, in vec2 FC) {\n    ivec2 U = ivec2(FC);\n    if (U.y == 0) O = heartPositionBuffer(U.x);\n    else if (U == ivec2(0, 1)) O = currentStatusBuffer();\n    else if (U == ivec2(1, 1)) O.x = isThumbnail();\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\nfloat noise11(float x) {\n    return noise31(x).x;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjcDt.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[18602, 18602, 18621, 18621, 19166], [19168, 19168, 19192, 19192, 19351], [19353, 19353, 19409, 19409, 19638], [19640, 19640, 19682, 19682, 19822], [19824, 19824, 19853, 19853, 19984], [19986, 19986, 20010, 20010, 20166], [20168, 20168, 20224, 20224, 20373], [20375, 20375, 20404, 20404, 21055], [21057, 21057, 21088, 21088, 22288], [22290, 22290, 22324, 22324, 22518], [22520, 22520, 22550, 22550, 22759], [22798, 22798, 22824, 22824, 22903], [22904, 22904, 22939, 22939, 23005], [23006, 23006, 23094, 23094, 23313], [23315, 23315, 23346, 23346, 23668], [23670, 23670, 23694, 23694, 23942], [23944, 23944, 23997, 23997, 24551], [24553, 24553, 24588, 24588, 24775], [24777, 24777, 24816, 24816, 25260]]}
{"id": "NsjyWt", "name": "Music - Ballad", "author": "ersh", "description": "More experiments with instrument synthesis. Added stereo.", "tags": ["music"], "likes": 6, "viewed": 305, "published": 3, "date": "1644326883", "time_retrieved": "2024-07-30T17:04:35.502797", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "const float bpm = 70.;\nfloat T;\nfloat seed;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float t) {\n    float p = ((seed+=1.) + mod(t, 21.435214) * 1500. + 50.0);\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat mixc(float a, float b, float r) { return mix(a, b, clamp(0., 1., r)); }\n\n//float note2freq(float note) { return 440. * exp2(-10./12.) * exp2(note/12.); }\nfloat note2freq(float note) { return 440. * exp2(-2./12.) * exp2(note/12.); }    // transposed to the current key\n\nfloat sinhz(float x) { return sin(6.2831*x); }\nfloat saw(float x) { return abs((fract(x-0.25)-0.5)*2.)*2.-1.; }\nfloat sawt(float x) { return fract(x-0.5)*2.-1.; }\n\nfloat distort(float x) { return sin(3.1415926/2.*x*2.); }\n\nfloat kick(float t) { return distort(t*40.*sin(0.3/(t+0.0001))*exp(-t*30.)*0.35); }\nfloat hh(float t, float decay) { return hash11(mod(t,1./4500.))*(exp(-t*decay) + t*200.*clamp(1.-t*100.,0.,1.)); }\nfloat snare2(float t) { return t*3. * hash11(floor(t*8000.)/8000.)*exp(-t*10.); }\nfloat snare(float t) { return snare2(t) + hash11(t)*sawt(t*40.)*smoothstep(0.08,0.,t); }\n\nfloat padsynth(float t, float note) {\n    float freq = note2freq(note);\n    float h1 = saw(freq*t) + saw(freq*t*2.)/2. + saw(freq*t*3.)/6. + saw(freq*t*4.)/5. + sawt(freq*t*8.)/10.;\n    float h2 = sinhz(freq*t) + sinhz(freq*t*2.)/2.;\n    return mixc(h1, h2, 1.-exp(-t*2.));\n}\n\nfloat basssynth(float t, float note, float soft) {\n    float freq = note2freq(note-24.);\n    float p = freq*t;   //    p = p/smoothstep(0.,0.1,p);\n    float h1 = sawt(p) * (1. + sin(0.1/(t+0.00001))*0.3), h2 = sinhz(p), h3 = sinhz(p/2.);\n    return (mixc(h1, h2, 1.-exp(-t*1.2) + soft) + h2/3. + h3)*exp(-t*0.2);\n}\nfloat basssynth(float t, float note) { return basssynth(t, note, 0.); }\n\nfloat t(float offset) { return T - 60./bpm*4. * offset; }\nfloat m(float repeat, float offset) { return mod(T - 60./bpm*4. * offset, 60./bpm*4. * repeat); }\nfloat m(float repeat) { return m(repeat, 0.); }\n#define T(a,b)   (float(a)/float(b))\n#define T1(a)    (1./float(a))\n#define M(a,b)   m(float(a)/float(b))\n#define M1(a)    m(1./float(a))\n#define MM(a,b,c,d)  m(float(a)/float(b), float(c)/float(d))\n\nfloat s(float offset, float len) { return step(60./bpm*4. * offset, T) * (1. - step(60./bpm*4. * (offset+len), T)); }\nfloat s(float offset) { return step(60./bpm*4. * offset, T); }\nfloat ss(float offset, float len, float decay) {\n    return step(60./bpm*4. * offset, T)\n        * (1. - smoothstep(60./bpm*4. * (offset+len), 60./bpm*4. * (offset+len+decay), T))\n    ;\n}\nfloat ss(float offset, float len) { return ss(offset, len, 0.5); }\nfloat st(float offset1, float offset2) { return step(60./bpm*4. * offset1, T) * (1. - step(60./bpm*4. * offset2, T)); }\n\nvec2 pan(float smpl, float a) { return vec2(smpl * cos(a), smpl * (1.-cos(a)))*1.5; }\n\n#define DETUNE(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE+0.2) + FUNC(TIME, NOTE-0.1))/6.\n#define DETUNE2(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE-0.2) + FUNC(TIME, NOTE+0.1))/6.\n#define SYNTH(TIME, NOTE)               vec2(DETUNE(padsynth, TIME, NOTE)*0.7, DETUNE2(padsynth, TIME, NOTE)*0.7)\n#define VIBRATO(FREQ, DEPTH)           (1. + sinhz(T*FREQ)*DEPTH)\n#define TREMOLO(FREQ, DEPTH)           sinhz(T*FREQ)*DEPTH\n#define V                               VIBRATO(5.5, 0.3)\n#define ORGAN(TIME, NOTE)               distort(DETUNE(padsynth, TIME, NOTE)+DETUNE(padsynth, TIME, NOTE+12.)*0.4)*0.2\n\n#define BASSSYNTH(TIME, NOTE)       vec2(DETUNE(basssynth, TIME, NOTE), DETUNE2(basssynth, TIME, NOTE))\n\nvec2 drumpat() {\n    return vec2(0.\n        + kick(m(1.))\n        + kick(m(1., 1./2.+1./16.))*0.3\n        + kick(m(1., 1./2.+1./8.))\n        + hh(M(1,8), 50.)*0.2\n        + hh(MM(1,8,1,16), 10.)*0.08\n        + snare(m(T1(2), T1(4)))\n    );\n}\n\nvec2 pat1(float time) {\n    T = time;\n    T = m(4.);\n    return vec2(0)\n        + drumpat()\n\n        + BASSSYNTH(m(4.), 0.) * s(0., 1.)\n        + BASSSYNTH(m(4., 1.), -4.) * s(1., 1.)\n        + BASSSYNTH(m(4., 2.), -2.) * s(2., 1.)\n        + BASSSYNTH(m(4., 3.), -7.) * s(3., 1./2.)\n        + BASSSYNTH(m(4., 3.+2./4.), -5.) * s(3.+2./4., 1./4.)\n        + BASSSYNTH(m(4., 3.+3./4.), -2.) * s(3.+3./4., 1./4.)\n\n        + SYNTH(t(0.)+2., -12. + 7.) * ss(0., 1./8.)*0.3\n        + SYNTH(t(1./8.), 3.) * ss(3./8., 1./8.)\n        + SYNTH(t(3./8.), 2.) * ss(4./8., 1./8.)\n        + SYNTH(t(4./8.), 3.) * ss(5./8. + 1./16., 1./8., 1.)\n        + SYNTH(t(7./8.), 0.) * ss(7./8., 1./8., 1.5)\n\n        + SYNTH(t(2.+1./8.), 3.) * ss(2.+3./8., 1./8.)\n        + SYNTH(t(2.+3./8.), 2.) * ss(2.+4./8., 1./8.)\n        + SYNTH(t(2.+5./8.), 3.) * ss(2.+5./8. + 1./16., 1./8.)\n        + SYNTH(t(2.+7./8.), 0.) * ss(2.+7./8., 1./8.)\n\n        + SYNTH(t(3.), 3.) * ss(3.+1./8.+1./16., 1./8.)\n        + SYNTH(t(3.+3./8.), 2.) * ss(3.+3./8., 1./8., 0.75)\n        ;\n}\n\nvec2 pat2(float time) {\n    T = time;\n    T = m(4.);\n    float[] ts1 = float[] (\n        0.,\n        1. + 1./4. + 1./8.,\n        1. + 1./4. + 1./8. + 1./16.,\n        1. + 1./2.,\n        \n        2.,\n        3. - 1./8.,\n        3.,\n        3. + 3./16.,\n        3. + 6./16.,\n        3. + 10./16.,\n        3. + 13./16.\n    );\n    return vec2(0)\n        + pat1(time)\n\n        + pan(\n              (ORGAN(time+0.3, 12. + 7.)\n            + ORGAN(time+0.3, 12. + 3.))/2. * V * st(ts1[0], ts1[1])\n            + (ORGAN(time, 12. + 5.)\n            + ORGAN(time, 12. + 2.))/2. * st(ts1[1], ts1[2])\n            + (ORGAN(time, 12. + 7.)\n            + ORGAN(time, 12. + 3.))/2. * st(ts1[2], ts1[3])\n            + (ORGAN(time, 12. + 3.)\n            + ORGAN(time, 12. + 0.))/2. * V * ss(ts1[3], ts1[4]-ts1[3]-1./8., 1./6.)\n\n            + (ORGAN(t(2.)+0.3, 12. + 5.)\n            + ORGAN(t(2.)+0.3, 12. + 2.))/2. * V * st(ts1[4], ts1[5])\n            + ORGAN(t(2.)+2., 12. + 3.)    * V * st(ts1[5], ts1[6])\n            + ORGAN(t(2.)+2., 12. + 2.)    * V * st(ts1[6], ts1[7])\n            + ORGAN(t(2.)+2., 12. + 0.)    * V * st(ts1[7], ts1[8])\n            + ORGAN(t(2.)+2.,       7.)    * V * st(ts1[8], ts1[9])\n            + ORGAN(t(2.)+2., 12. + 2.)    * V * ss(ts1[9], 1./4., 1./8.)\n            , m(2.)*0.4)\n        ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    T = time;\n    seed = 10.;\n\n    float p1 = m(16.);\n    float p2 = m(16., 8.);\n    return p1 < p2 ? pat1(p1) : pat2(p2);\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "fdjyWt", "name": "Music - Techno", "author": "ersh", "description": "Experimenting with instrument synthesis.", "tags": ["music"], "likes": 5, "viewed": 273, "published": 3, "date": "1644325229", "time_retrieved": "2024-07-30T17:04:36.247805", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "const float bpm = 126.;\nfloat T;\nfloat seed;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float t) {\n    float p = ((seed+=1.) + mod(t, 21.44352345) * 1500. + 50.0);\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat nf(float t, float freq) { return hash11(floor(t*freq)/freq); }\nfloat mixc(float a, float b, float r) { return mix(a, b, clamp(0., 1., r)); }\n\n//float note2freq(float note) { return 440. * exp2(-10./12.) * exp2(note/12.); }\nfloat note2freq(float note) { return 440. * exp2(-2./12.) * exp2(note/12.); }    // transposed to the current key\n\nfloat sinhz(float x) { return sin(6.2831*x); }\nfloat saw(float x) { return abs((fract(x-0.25)-0.5)*2.)*2.-1.; }\nfloat sawt(float x) { return fract(x-0.5)*2.-1.; }\n\nfloat kick(float t) { return t*40.*sin(0.8/(t+0.0001))*exp(-t*30.)*0.9; }\nfloat hh(float t) {\n    return hash11(mod(t,1./4500.))*t*200.*clamp(1.-t*100.,0.,1.);\n}\nfloat snare(float t) { return hash11(t)*sawt(t*40.)*smoothstep(0.08,0.,t); }\nfloat snare2(float t) { return hash11(t)*smoothstep(0.18,0.,t)*0.4; }\n\nfloat padsynth(float t, float note) {\n    float freq = note2freq(note);\n    float h1 = saw(freq*t) + saw(freq*t*2.)/2. + saw(freq*t*3.)/6. + saw(freq*t*4.)/5. + sawt(freq*t*8.)/10.;\n    float h2 = sinhz(freq*t) + sinhz(freq*t*2.)/2.;\n    return mixc(h1, h2, 1.-exp(-t*2.));\n}\n\nfloat basssynth(float t, float note, float soft) {\n    float freq = note2freq(note-24.);\n    float p = freq*t;   //    p = p/smoothstep(0.,0.1,p);\n    float h1 = sawt(p), h2 = sinhz(p);\n    return (mixc(h1, h2, t*15. + soft)+h2/3.)*exp(-t*12.);\n}\nfloat basssynth(float t, float note) { return basssynth(t, note, 0.); }\n\nfloat m(float repeat, float offset) { return mod(T - 60./bpm*4. * offset, 60./bpm*4. * repeat); }\nfloat m(float repeat) { return m(repeat, 0.); }\n#define T(a,b)   (float(a)/float(b))\n#define T1(a)    (1./float(a))\n#define M(a,b)   m(float(a)/float(b))\n#define M1(a)    m(1./float(a))\n#define MM(a,b,c,d)  m(float(a)/float(b), float(c)/float(d))\n\nfloat s(float offset, float len) { return step(60./bpm*4. * offset, T) * (1. - step(60./bpm*4. * (offset+len), T)); }\nfloat s(float offset) { return step(60./bpm*4. * offset, T); }\n\n#define DETUNE(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE+0.2) + FUNC(TIME, NOTE-0.1))/3.\n#define SYNTH(TIME, NOTE)               DETUNE(padsynth, TIME, NOTE)\n#define CHORD(TIME, N, N2, N3)         (SYNTH(TIME, float(N)) + SYNTH(TIME, float(N+N2)) + SYNTH(TIME, float(N+N3)))*0.6\n\nfloat drumpat() {\n    return 0.\n        + kick(M1(4))\n        + hh(M1(16))*0.2\n        + snare(m(T1(2), T1(4)))\n    ;\n}\n\nfloat pat1(float time) {\n    T = time;\n    T = m(8.);\n    return 0.\n        + drumpat()\n        + CHORD(m(1.),         0, 4, 7)*exp(-2.0*m(1.))\n        + CHORD(m(2., T(3,4)), 0, 4, 9)*exp(-3.5*m(2., T(3,4)))\n        + basssynth(M1(4), -12.)\n        + basssynth(m(T1(4), T1(8)), 0.)\n        + basssynth(m(1., -T1(16)), 0., 0.6)\n        + snare(m(4., -T(4,8)))\n        + snare(m(4., -T(3,8)))\n        + snare(m(4., -T(2,8))) + snare2(m(4., -T(2,8)))\n        + snare(m(4., -T(1,8)))\n        + snare(m(4., -T(1,16)))\n        ;\n}\n\nfloat pat2(float time) {\n    T = time;\n    T = m(8.);\n    return 0.\n        + drumpat()\n        + snare2(m(T1(2), T(1,4)))\n        + SYNTH(m(4.), 4.-12.) * exp(-0.5*m(1.))/2.\n        + SYNTH(m(4., 1.), -1.)* exp(-0.3*m(4., 1.))/2.  * s(1.)\n        + SYNTH(m(4., 2.), 2.) * exp(-0.2*m(4., 2.))/2. * s(2.)\n        + SYNTH(m(4., 3.), 4.) * exp(-0.1*m(4., 3.))/2.  * s(3.)\n        + basssynth(M1(4), -12. + 4.)\n        + basssynth(m(T1(1), T(3,16)), 0. + 4.)\n        + basssynth(m(T1(1), T(6,16)), 0. + 4.)\n        + basssynth(m(T1(1), T(8,16)), 0. + 4., 0.6)/2.\n        + basssynth(m(2., -T1(8)), 12. + 2., 0.9)\n        + basssynth(m(2., -T1(16)), 0. + 2., 0.6)\n        + snare(m(4., -T(4,8)))\n        + snare(m(4., -T(3,8)))\n        + snare(m(4., -T(7,16)))\n        + snare(m(4., -T(2,8)))\n        + snare(m(4., -T(1,8)))\n        + snare(m(4., -T(1,16)))\n        ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    T = time;\n    seed = 10.;\n\n    float p1 = m(12.);\n    float p2 = m(12., 8.);\n    return vec2(\n        p1 < p2 ? pat1(p1) : pat2(p2)\n    );\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "NsBcDd", "name": "CirclesStuff", "author": "antoinefortin", "description": "asdfdsfgf", "tags": ["sfd"], "likes": 4, "viewed": 257, "published": 3, "date": "1644305476", "time_retrieved": "2024-07-30T17:04:37.119474", "image_code": "vec2 Hash12(float t)\n{\n    float x = fract(sin(t * 674.3) * 453.2);float y = fract(sin(t * 2674.3) * 453.2);\n    return vec2(x,y);\n}\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n   \n    uv *= 1.522222f;\n   \n    uv.x = abs(uv.x) - .5;\n    uv.x -= .15;\n    \n    uv = rotate(uv, iTime + uv.x * sin(iTime + uv.y));\n    \n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.; i < 125.0; i++)\n    {\n        \n        vec2 dir= Hash12(i) - .5;\n        float t = dir.x +(abs(sin(iTime * .125)) + dir.x) * 1.5;\n        float d = length(uv+dir*(2.5 *sin(dir.x * cos(dir.y)))*t);\n        d -= length(uv-dir*t *  cos(iTime)) *  3.1566;\n        d  = abs(d * .17);\n        float brightness = 0.0005 * (abs(sin(uv.x)) + .5);\n        \n        col+= vec3(brightness / d) * vec3(abs(sin(i)) * .55, abs(sin(i * i)), abs(cos(i)));\n        \n    \n    }\n    col.r += Hash12(uv.x * abs(sin(uv.y))).x * .05;\n  //  col = vec3(Hash12(12.).x);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 132], [134, 134, 170, 170, 260], [263, 263, 320, 370, 1265]]}
{"id": "NdBcDd", "name": "LinesSWtuff", "author": "antoinefortin", "description": "fdsiufhvfdkljhgf", "tags": ["sfkjhfdjikdh"], "likes": 1, "viewed": 216, "published": 3, "date": "1644304923", "time_retrieved": "2024-07-30T17:04:38.014082", "image_code": "#define NUM_PARTICLES 20.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 674.3) * 453.2);\n    float y = fract(sin(t * 2674.3) * 453.2);\n    \n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.; i < NUM_PARTICLES; i++)\n    {\n        vec2 dir= Hash12(i) - .5;\n        float t = .5 +  sin(iTime + sin(uv.x));\n        float d = length(uv-dir*t - sin(iTime));\n        d -= length(uv-dir*t);\n         \n     \n        \n        float brightness = 0.001;\n        \n        col += vec3(brightness / d);\n        \n    \n    }\n  //  col = vec3(Hash12(12.).x);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 169], [171, 171, 228, 278, 832]]}
{"id": "NdSyDd", "name": "Cylinder Gradient 3D", "author": "Dain", "description": "Signed distance to an cylinder along with its analytic gradient", "tags": ["gradient", "cylinder"], "likes": 4, "viewed": 274, "published": 3, "date": "1644296656", "time_retrieved": "2024-07-30T17:04:38.833890", "image_code": "\n//The floor shows the internal distance/gradient\n//Norm is scaled into 0-1 range for visualization to verify signs\n\n//Set to 1 to show numeric gradient to verify that it matches analytic\n#define SHOW_NUMERIC_GRADIENT 0\n\n//if 1 it scales norm into 0-1, if 0 it takes abs\n#define SHOW_FULL_NORM_RANGE 1\n\n\nfloat sdgCylinder(vec3 p, vec2 rh,  out vec3 norm) {\n\tfloat lp = length(p.xy);\n\tvec2 a = vec2(lp - rh.x, abs(p.z) - rh.y);\n\n\tfloat bmax = max(a.x, a.y);;\n\tfloat d = bmax;\n\t\t\n\tbool useCircle = a.x >= a.y;\n\tnorm = vec3(useCircle? p.xy: vec2(0.0,0.0), useCircle? 0.0:p.z);\n\n\tbool need2ndSqrt = min(a.x, a.y) >0.0;\n\n\tif (need2ndSqrt){//Only need this if at diagonal \n\t\tvec2 b = max(a,0.0);\n\t\td = sqrt( dot(b,b))+ min(bmax,0.0);\n\t\tnorm = vec3(p.x, p.y, sign(p.z)* b.y) * vec3(b.x, b.x, lp);\n\t}\n    //This version normalizes as it is likely less instructions than getting the gradient length correct analytially\n    //For my use (triplanar texturing mostly) gradient length is irrelevant, so I just skip this\n    norm = normalize(norm);\n    return d;\n}\n\n//Version with purely analytic gradient length(TODO)\nfloat sdgCylinderAnalyticGL(vec3 p, vec2 rh,  out vec3 norm) {\n        float d2_xy = dot(p.xy,p.xy);\n        float rsqrtD2 = inversesqrt(d2_xy);\n\t\tfloat lp = d2_xy*rsqrtD2;\n\t\tvec2 a = vec2(lp - rh.x, abs(p.z) - rh.y);\n\n\t\tfloat bmax = max(a.x, a.y);;\n\t\tfloat d = bmax;\n\t\t\n\t\tbool useCircle = a.x >= a.y;\n        //correct\n\t\tnorm = vec3(useCircle? p.xy*rsqrtD2: vec2(0.0,0.0), useCircle? 0.0:sign(p.z));\n\n\t\tbool need2ndSqrt = min(a.x, a.y) >0.0;\n\n\t\tif (need2ndSqrt){//Only need this if at diagonal \n\t\t\tvec2 b = max(a,0.0);\n\t\t\td = sqrt( dot(b,b))+ min(bmax,0.0);\n            //TODO: correct the length\n\t\t\tnorm = vec3(p.x, p.y, sign(p.z)* b.y) * vec3(b.x, b.x, lp);\n            norm = normalize(norm);//cheat for now if we get inside this part\n\t\t}\n\n\t\treturn d;\n}\n\n            \n//Rest of code by mostly by paniq\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nvec2 doModelWithNorm( vec3 p, out vec3 norm) {\n\n    float Size = 1.5;\n   // float d = Tetrahedron(p, Size, 0.0);\n   float round = .8*abs(sin(iTime*.3));\n   round=round*round*round;\n   float rd = abs(cos(iTime*.1))*.5 + 1.0;//,norm;\n   vec2 rad = vec2(rd*.5, rd);\n    float d = sdgCylinder(p, rad, norm )-round;\n    \n#if SHOW_NUMERIC_GRADIENT == 1\n//  if(iMouse.z<=0.0){//show  numeric gradients when left mouse is held\n\n     const float eps = 0.0001;\n     const vec3 e = vec3(eps,0.0, 0.0);\n     norm = normalize(vec3(sdgCylinder( p +e.xyz, rad, norm )- sdgCylinder( p -e.xyz, rad, norm ),\n                      sdgCylinder( p +e.yxz, rad, norm )- sdgCylinder( p -e.yxz, rad, norm ),\n                      sdgCylinder( p +e.yzx, rad, norm )- sdgCylinder( p -e.yzx, rad, norm )));\n  //   }\n#endif\n#if SHOW_FULL_NORM_RANGE == 1\n    norm = norm*.5 + .5;\n #else\n    norm = abs(norm);\n#endif\n                             \n\t// d = min(d,length(p)-Size);//use to verify sphere size and tet match up\n    vec2 rr = add_plane(p, vec2(d,0.0));\n \n    return rr;\n}\nvec2 doModel( vec3 p) {\nvec3 norm;\n    return doModelWithNorm(p, norm);\n}\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 norm,norm2;\n    float k = doModelWithNorm(pos,norm).y;\n    float d = doModelWithNorm(vec3(pos.x,0.0,pos.z),norm2).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    vec4 objCOlor = vec4(0.1,.01,1.0,0.1);\n    objCOlor.xyz = norm;\n    return mix(objCOlor, //nor * 0.5 + 0.5,\n               vec4(norm2,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n //   col += mal.w*Texture2D(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n#if 0\n    vec3 norm;\n    doModelWithNorm(pos, norm);\n#if SHOW_FULL_NORM_RANGE ==1\n    norm = norm*2.0 -1.0;\n#endif\n    return (norm);\n    \n#else//for lighting we want the ground plane etc, so do it numerically\n        const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n    vec3 norm;\n#endif\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x+1.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 356, 356, 1050], [1052, 1105, 1167, 1167, 1862], [1877, 1911, 1994, 1994, 2117], [2119, 2119, 2146, 2146, 2181], [2183, 2183, 2210, 2210, 2241], [2243, 2243, 2270, 2270, 2300], [2303, 2303, 2324, 2324, 2356], [2358, 2358, 2390, 2390, 2421], [2423, 2423, 2469, 2469, 3474], [3475, 3475, 3498, 3498, 3548], [3549, 3902, 3947, 3947, 4309], [4522, 4522, 4606, 4606, 5247], [5249, 5249, 5299, 5299, 5727], [5729, 5729, 5761, 5761, 6418], [6420, 6420, 6468, 6468, 7047], [7049, 7049, 7113, 7113, 7291], [7293, 7293, 7329, 7329, 7423], [7425, 7425, 7482, 7482, 9206]]}
{"id": "fdSyWd", "name": "Square Tiling Example", "author": "SnoopethDuckDuck", "description": "wanted to replace if statements with functions but couldn't think of anything concise", "tags": ["e"], "likes": 14, "viewed": 305, "published": 3, "date": "1644293748", "time_retrieved": "2024-07-30T17:04:39.662674", "image_code": "// Fabrice's golfed version\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,A, o,\n          U = ( u - .5*R ) / R.y;\n    float s = 14. +  cos(3.5 * U.x + iTime)/4., \n          k = s/R.y, i,h,c;\n    U *= s;\n    I = floor(U);\n    U -= I;\n    \n    int b = int( mod( I+I - I.y, 5. ));\n    i = b != 3 ? U *= .5, 1. : 2.;  \n    o = vec2( b>0 && b<3, b==1 || b==4 );\n    A = abs( U += .5*o - .5 );\n    \n    h = 6.28 * fract(1e4*sin(dot(I-o,R-17.))); \n    O =   smoothstep(k, -k, .5 - mix( max(A.x,A.y), length(U), c = .5 + .5*cos(h + 3.14*i + iTime) ) \n                            - (.05 + .1*c) * i )\n        * ( 1. + cos(6.28*( h + .05*iTime + vec4(0,1,2,0)/3. )) ) \n        + .14;\n}\n\n\n// Original version\n/*\n#define pi 3.14159\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a+b*cos(2.*pi*(c*t+d));\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float sc = 14. + 0.25 * cos(3.5 * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.;\n    vec2 fpos = fract(sc * uv) - 0.;\n       \n    // m determines what new cell the old cell lies in\n    // 3 -> small\n    // 0 -> tl big, 2 -> tr big, 4 -> bl big, 1 -> br big\n    float m = mod(2. * ipos.x - ipos.y, 5.);\n    \n    // id = 2 if small cell, id = 1 if big cell (used to make outlines same size)\n    float id = 2.;\n    vec2 o = vec2(0);\n    \n    if (m != 3.) { fpos *= 0.5;  id = 1.; }    \n    if (m == 2.)      o = vec2(1,0); // top right\n    else if (m == 4.) o = vec2(0,1); // bottom left\n    else if (m == 1.) o = vec2(1);   // bottom right\n    \n    // if in big cell, halve fpos + translate\n    fpos += 0.5 * o - 0.5;\n    ipos -= o;\n    \n    float h = 2. * pi * h21(ipos);\n    \n    float c = cos(h + pi * id + iTime);    \n    float d = mix(mlength(fpos), length(fpos), 0.5 + 0.5 * c);\n    \n    float k = 5. / iResolution.y;\n    float s = 1. - smoothstep(-k, k, -d + 0.5 - (0.1 + 0.05 * c) * id);// - length(fpos);\n\n    vec3 e = vec3(1.);\n    vec3 col = s * pal(h + 0.05 * iTime, e, e, e, vec3(0., 0.33, 0.66));\n    col += 0.14;\n    \n    fragColor = vec4(col,1.0);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 66, 66, 700]]}
{"id": "fsSyWc", "name": "Sunrise showers", "author": "electric_boogie", "description": "Many dots moving, computationally efficient. Original idea was to have dots move around in many directions and use jfa to find nearest seed, but I found this on the way.\n\nClick & move to show the effect of not overwriting the previous state.", "tags": ["simple", "accident", "jfa"], "likes": 3, "viewed": 240, "published": 3, "date": "1644277495", "time_retrieved": "2024-07-30T17:04:40.498440", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define BLACK vec3(0.)\n#define WHITE vec3(1.)\n#define RED   vec3(1., 0., 0.)\n#define BLUE  vec3(0.,0.,1.)\n#define GREEN vec3(0., 0., 1.)\n#define CYAN  vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define COL(X) vec4(X, 0.)\n\n//=================================================\n// Hash without sine, from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//=================================================\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//=================================================\n// Rand / RandColor\n// From https://www.shadertoy.com/view/Mdy3DK\n//=================================================\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\n// Modified to return vec4\nvec4 RandColor (vec2 co)\n{\n    return vec4\n    (\n        Rand(co),\n        Rand(co*2.143),\n        Rand(co*3.163),\n        0.\n\t);\n}\n", "buffer_a_code": "#define NOISE 0.999\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R;\n\n    vec4 me = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float angle = me.z;\n\n\n    // Neighbours\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0., -1.), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1., 0.), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0., 1.), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1., 0.), 0);\n\n    vec4 ne = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1., -1.), 0);\n    vec4 nw = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1., -1.), 0);\n    vec4 se = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1., 1.), 0);\n    vec4 sw = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1., 1.), 0);\n\n\n    vec4 m = (n + e + s + w) / 4. + ((ne + nw + se + sw) / 4. * 0.3);\n\n    fragColor = me;\n\n    vec2  p_loc = (uv - 0.5);\n    float p = smoothstep(0.05, 0., length(p_loc) - 0.2);\n    fragColor += vec4(p, 0. , 0., 0.);\n\n    // Figure out if we have a moving pixel as neighbour\n    vec4 next = vec4(0.);\n    if (ne.w > 0.) next = ne;\n    if (nw.w > 0.) next = nw;\n    if (se.w > 0.) next = se;\n    if (sw.w > 0.) next = sw;\n    if (n.w > 0.) next = n;\n    if (e.w > 0.) next = e;\n    if (s.w > 0.) next = s;\n    if (w.w > 0.) next = w;    \n\n    if (me.w == 1.0){\n        // We are a seed\n        float angle = hash12(uv * 100.);\n        vec4 col = vec4(fragCoord.x + 1. , fragCoord.y,angle, 1.0);\n        fragColor = col;\n        \n    } else if (next.xy == fragCoord.xy){\n        // We are the neighbour of a moving pixel. Compute next and store here.\n        float seed = -hash12(fragCoord * iTime);\n\n        next.x += round(cos(seed));\n        next.y += round(sin(seed));\n        next.w += 0.1; \n    \n        fragColor = next;\n\n        \n    } else {\n        if (fragCoord.x > iMouse.x) {\n\n            fragColor = vec4(1.5 - uv.y + sin(iTime/3.14), \n                             -uv.y * 0.2 + sin(iTime/3.14) * 0.3, \n                             uv.y * 0.2 + cos(iTime/3.14) * 0.2, 0.0);\n        }\n        \n    }\n\n//=================================================\n// Init. Create randomly placed dots from noise\n//=================================================\n    if (iFrame <= 1){\n        float t = texture(iChannel1, uv).x;\n        float v = Rand(uv * t);\n        if (v > NOISE){\n            float angle = hash12(uv);\n            vec4 col = vec4(fragCoord.x + 0. , fragCoord.y,angle, 1.0);\n            fragColor = col;\n        } else {\n            fragColor = COL(BLACK);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]]}
{"id": "7s2cWc", "name": "Lover 3", "author": "wyatt", "description": "Subdividing the string for Fabrice ", "tags": ["ribbon"], "likes": 18, "viewed": 684, "published": 3, "date": "1644264254", "time_retrieved": "2024-07-30T17:04:41.582541", "image_code": "// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 19:18:47\n\nMain \n    vec4 b = B(U);\n    \n    Q = vec4(1,.5,.5,1)-b.zzzz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; int I;\n\nfloat N;\n\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n", "buffer_a_code": "Main \n    float i = _12(U);\n    float M = 7.;\n    float N = 100.+M*float(I/2);\n    if (I%2>0) {\n        Q = A(_21(mod(i,N)));\n\n        vec2 f = vec2(0);\n\n        for (float j = -100.; j <= 100.; j+=1.) \n        if (j!=0.) {\n\n            vec4 a = A(_21(mod(i+j,N)));\n            vec2 r = a.xy-Q.xy;\n            float l = length(r);\n            if (l>0.)\n            f += 5.*r/l/l/l*(l-abs(j));\n        }\n        for (float x = -2.; x <= 2.; x++)\n        for (float y = -2.; y <= 2.; y++) if (x!=0.||y!=0.) {\n            vec2 u = vec2(x,y);\n            vec4 d = D(Q.xy+u);\n            f -= 3.*d.w*u;\n        }\n        if (length(f)>.1) f = .1*normalize(f);\n        Q.zw += f-.03*Q.zw;\n        Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n\n        vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n        Q.zw = mix(Q.zw,m.zw,0.1);\n        Q.xy = mix(Q.xy,m.xy,0.01);\n    } else if (I< 1) {\n        Q = vec4(0,0,0,0);\n        float a = 6.28318530718*i/N;\n        Q.xy = .5*R+N/3.1*vec2(sin(a),cos(a));\n    } else {\n        float j = i/N*(N-M);\n        vec4 a = A(_21(mod(floor(j),N-M)));\n        vec4 b = A(_21(mod(ceil(j),N-M)));\n        Q = mix(a,b,fract(j));\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+2.*vec2(x,y)));\n    }\n    XY(U,Q,vec4(Q.x-1.));\n    XY(U,Q,vec4(Q.x+1.));\n    XY(U,Q,vec4(Q.x-2.));\n    XY(U,Q,vec4(Q.x+2.));\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-7.));\n    XY(U,Q,vec4(Q.x+7.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(mod(Q.x,R.x*R.y)));\n    vec4 a2 = A(_21(mod(Q.x+1.,R.x*R.y)));\n    vec4 a3 = A(_21(mod(Q.x-1.,R.x*R.y)));\n    float l1 = sg(U,a1.xy,a2.xy);\n    float l2 = sg(U,a1.xy,a3.xy);\n    if (length(a1-a2)>14.) l1 = 1e9;\n    if (length(a1-a3)>14.) l2 = 1e9;\n    float l = min(l1,l2);\n    Q.z = Q.w = .4*smoothstep(5.,4.,l);\n    Q.w -= .2*heart(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,6.)*B(U+vec2(x,0)).w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,6.)*C(U+vec2(0,y)).w;\n        \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2cWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ssjyWc", "name": "Lover 2", "author": "FabriceNeyret2", "description": "Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3  \ntrying to mimic Karthik Dondeti https://twitter.com/d0ndeti/status/1479814051366539264 series.\n\n- A:use close curve, starting as circle. k partics\n- I: basic drawing\nstill, there are crossings.", "tags": ["paper", "reproduction", "dondeti"], "likes": 384, "viewed": 496128, "published": 3, "date": "1644259512", "time_retrieved": "2024-07-30T17:04:42.756403", "image_code": "// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  Q = B( U ).zzzz; }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n", "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n#define  k ( .02 * R.x*R.y )\nMain \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    if ( i < k ) {\n    for (float j = -20.; j <= 20.; j++) \n        if (j!=0.) {//  && j+i>=0. && j+i<R.x*R.y) {\n        vec4 a = A(_21(mod(i+j,k)));\n        //if (j!=0. && j+i>=0. && j+i<R.x*R.y) {\n        //vec4 a = A(_21(i+j));\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n    }\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f -= 100.*d.w*u;\n    }\n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw += f-.03*Q.zw;\n    Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n    Q.zw = mix(Q.zw,m.zw,0.1);\n    Q.xy = mix(Q.xy,m.xy,0.01);\n    if (Q.x>R.x)Q.y=.5*R.y,Q.z=-10.;\n    if (Q.x<0.)Q.y=.5*R.y,Q.z=10.;\n    }\n     if (iFrame < 1 || keyClick(32)) {\n        if ( i > k ) \n          Q = vec4(R+i,0,0); \n        else\n          Q = vec4(.5*R + .25*R.y* cos( 6.28*i/k + vec2(0,1.57)), 0,0 );\n    //  Q = vec4(i-.5*R.x*R.y,.5*R.y,0,0);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-7.));\n    XY(U,Q,vec4(Q.x+7.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    vec4 a3 = A(_21(Q.x-1.));\n    float l1 = sg(U,a1.xy,a2.xy);\n    float l2 = sg(U,a1.xy,a3.xy);\n    float l = min(l1,l2);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    Q = mix(Q,D(U),.5);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "sd2cW3", "name": "Falkirk Wheel", "author": "dr2", "description": "The world's only rotating boat lift, in Scotland - happy 20th birthday (mouseable)", "tags": ["water", "boat", "diorama", "canal", "engineer"], "likes": 25, "viewed": 410, "published": 3, "date": "1644251887", "time_retrieved": "2024-07-30T17:04:43.786648", "image_code": "// \"Falkirk Wheel\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Examine the gear mechanism\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, bLen, hGap, cRad, zMid, zLen, armAng, gState, bPos, bDir, bId;\nint idObj;\nconst int idBase = 1, idSup = 2, idArm = 3, idRing = 4, idAx = 5, idGate = 6, idGr1 = 7, idGr2 = 8,\n   idChan = 9, idRail = 10, idBoat = 11, idBoatH = 12, idTun = 13, idGrnd = 14, idWat = 15;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 pArm, pGate;\n  vec3 q, qq, sp;\n  vec2 db;\n  float dMin, d, dd, r, h, nt1, nt2, bGap, cCut;\n  dMin = dstFar;\n  pArm = vec4 (2.7, 1.2, 4.7, 5.19);\n  pGate = vec4 (0.85, 0.2, 0.05, 0.01);\n  bGap = bLen + 0.45;\n  cCut = bGap - 0.2;\n  nt1 = 60.;\n  nt2 = 20.;\n  p.y -= hGap + 0.15;\n  qq = p;\n  qq.xy = Rot2D (qq.xy, armAng);\n  sp = sign (vec3 (qq.x, p.yz));\n  q = p;\n  q.y -= - hGap - 1.05;\n  db = vec2 (hGap + 0.7, bLen + 0.6);\n  d = max (PrBoxDf (q, vec3 (db, 0.9).xzy), - PrCylDf (q - vec3 (0., hGap + 1., 0.),\n     db.x + 0.9, db.y - 0.3));\n  DMINQ (idBase);\n  q = qq;\n  d = max (PrBox2Df (q.xy, pArm.xy), pArm.z - length (vec2 (q.x, abs (q.y) - pArm.w)));\n  dd = cRad - length (vec2 (abs (q.x) - hGap, q.y));\n  d = SmoothMax (max (min (min (max (d, dd), abs (dd + 0.15) - 0.15),\n     max (max (max (length (vec2 (abs (q.x), sp.x * q.y)) - hGap - 1.4, sp.x * q.y - 3.),\n     hGap + 0.7 - abs (q.x)), sp.x * q.y)), dd), abs (abs (q.z) - bLen) - 0.1, 0.02);\n  DMINQ (idArm);\n  q = p;\n  q.xy = q.yx;\n  d = max (PrBox2Df (q.xy, pArm.xy), pArm.z - length (vec2 (q.x, abs (q.y) - pArm.w)));\n  dd = cRad - length (vec2 (abs (q.x) - hGap, q.y));\n  d = SmoothMax (max (min (max (d, dd), abs (dd + 0.15) - 0.15), - hGap - 0.25 - p.y),\n     max (- bGap - 0.2 - q.z, abs (mod (q.z, 2. * bGap) - bGap) - 0.15), 0.02);\n  d = max (d, q.z - zMid - zLen);\n  DMINQ (idSup);\n  q = qq;\n  d = PrCylDf (q, 0.3, bLen + 0.7);\n  DMINQ (idAx);\n  q.x = abs (q.x) - hGap;\n  q.xy = Rot2D (q.xy, - armAng * sp.x);\n  d = min (max (abs (length (q.xy) - cRad + 0.16) - 0.1, abs (q.y + 0.3) - 0.35),\n     max (abs (q.y + 0.5) - 0.15, abs (q.x) - 0.85));\n  d = max (d, abs (q.z) - cCut);\n  DMINQ (idChan);\n  d = max (max (abs (q.y + 0.18) - 0.1, abs (q.x) - cRad + 0.2), abs (q.z) - cCut);\n  DMINQ (idWat);\n  if (gState > 0. || gState == 0. && sp.y * sp.z < 0.) {\n    q.z = abs (q.z);\n    q.y += 0.2;\n    d = PrRoundBoxDf (q - vec3 (0., 0., cCut - 0.05), pGate.xyz - pGate.w, pGate.w);\n    DMINQ (idGate);\n    q.y -= 0.2;\n  }\n  q.x = abs (q.x) - 0.93;\n  d = min (PrCylDf (vec3 (q.xz, abs (q.y - 0.22) - 0.06).xzy, 0.02, bLen - 0.07),\n     max (abs (q.z) - bLen + 0.07, PrCylDf (vec3 (q.x, q.y - 0.14, mod (q.z + 0.2, 0.4) -\n     0.2).xzy, 0.02, 0.14)));\n  DMINQ (idRail);\n  q = p;\n  q.y -= hGap * sp.z;\n  dd = max (cCut - abs (q.z), abs (q.z - zMid) - zLen);\n  d = max (min (max (abs (length (q.xy) - cRad + 0.16) - 0.1, abs (q.y + 0.3) - 0.35),\n     max (abs (q.y + 0.5) - 0.15, abs (q.x) - 0.85)), dd);\n  DMINQ (idChan);\n  d = max (max (abs (q.y + 0.18) - 0.1, abs (q.x) - cRad + 0.2), dd);\n  DMINQ (idWat);\n  if (gState > 0.) {\n    q = p - vec3 (0., hGap * sp.z - 0.2, (cCut + 0.05) * sp.z);\n    d = PrRoundBoxDf (q, pGate.xyz - pGate.w, pGate.w);\n    DMINQ (idGate);\n  }\n  q = qq;\n  q.x = abs (q.x) - hGap;\n  q.xy = Rot2D (q.xy, - armAng * sp.x);\n  d = max (abs (length (q.xy) - cRad + 0.05) - 0.05, abs (abs (q.z) - bLen - 0.03) - 0.12);\n  DMINQ (idRing);\n  q.z -= bLen + 0.18;\n  d = max (abs (length (q.xy) - cRad - 0.02) - 0.09, abs (q.z) - 0.02);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (nt1 * atan (q.y, - q.x) / (2. * pi) + 0.5) / nt1));\n  d = max (d, - PrCaps2Df (vec2 (q.y, q.x + 1.2), 0.035, 0.01));\n  DMINQ (idGr1);\n  q = p;\n  q.z -= bLen + 0.18;\n  d = max (abs (length (q.xy) - cRad - 0.02) - 0.09, abs (q.z) - 0.02);\n  d = min (d, PrCylDf (vec3 (q.x, abs (q.y) - 1.05, q.z - 0.05), 0.07, 0.05));\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (nt1 * atan (q.y, - q.x) / (2. * pi) + 0.5) / nt1));\n  d = max (d, - PrCaps2Df (vec2 (q.y, q.x + 1.2), 0.035, 0.01));\n  DMINQ (idGr1);\n  q = qq;\n  q.z -= bLen + 0.1;\n  q.x = abs (q.x) - 0.5 * hGap;\n  d = PrCylDf (q, 0.2, 0.06);\n  DMINQ (idArm);\n  d = PrCylDf (q, 0.45, 0.03);\n  q.xy = Rot2D (q.xy, (nt1 / nt2) * armAng * sp.x);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (nt2 * atan (q.y, - q.x) / (2. * pi) + 0.5) / nt2));\n  d = min (d, PrCylDf (q - vec3 (-0.4, 0., 0.05), 0.03, 0.06));\n  DMINQ (idGr2);\n  if (gState > 0.) {\n    q = qq;\n    bId = - sp.x;\n    q.x -= hGap * sp.x;\n    q.xy = Rot2D (q.xy, - armAng);\n  } else {\n    q = p;\n    bId = bDir * sp.y;\n    q.yz -= vec2 (hGap, bPos) * sp.y;\n  }\n  q.z *= bId;\n  d = max (PrCapsDf (q, 0.4, 1.), q.y);\n  DMINQ (idBoatH);\n  d = min (PrCapsDf (q - vec3 (0., 0., -0.1), 0.3, 0.75),\n     PrCylDf ((q - vec3 (0., 0.3, 0.6)).xzy, 0.1, 0.2));\n  DMINQ (idBoat);\n  q = p;\n  q.y += hGap + 0.15;\n  h = 0.2 * (Fbm2 (0.5 * q.xz) - 0.5) * smoothstep (0.9, 2., abs (q.x));\n  d = max (abs (PrRoundBoxDf (q - vec3 (0., 29.7 - h, zMid), vec3 (15., 10. + h, zLen - 15.),\n     20.)) - 0.2, dot (q.yz, sin (0.02 * pi + pi * vec2 (0.5, 1.))) - 7. + 2. * h);\n  d = max (d, - PrBox2Df (q.xz, db));\n  q.y -= hGap * (1. + sp.z) + 0.15;\n  q.z = abs (q.z - zMid) - zLen - 5.;\n  dd = max (q.z, zMid - ((sp.z > 0.) ? -3. : 12.) - q.z);\n  r = length (q.xy) - cRad;\n  if (dd < 0.) d = max (d, 0.2 - r);\n  DMINQ (idGrnd);\n  d = min (max (abs (r - 0.1) - 0.1, dd), max (r, abs (q.z) - 0.1));\n  DMINQ (idTun);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.002 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 32.;\n  col = mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.3, 0.4, 0.5), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, rdo, vn, vnw;\n  vec2 vf;\n  float dstObj, tc, tg, spd, a, sh, nDotL;\n  bool isWat;\n  bLen = 2.5;\n  hGap = 3.2;\n  cRad = 1.1;\n  zMid = -10.;\n  zLen = 35.;\n  spd = 0.03;\n  tc = mod (spd * tCur, 1.);\n  bDir = - sign (tc - 0.5);\n  tg = 0.3;\n  gState = (0.5 - abs (tc - 0.5) > tg) ? 1. : 0.;\n  if (gState == 0.) {\n    bPos = 35. * (1. - smoothstep (0.1, 0.9, (0.5 - abs (tc - 0.5)) / tg));\n    armAng = 0.5 * pi;\n  } else {\n    bPos = 0.;\n    armAng = pi * (0.5 + smoothstep (0.2, 0.8, (tc - tg) / (1. - 2. * tg)) *\n       sign (2. * floor (mod (spd * tCur, 2.)) - 1.));\n  }\n  isWat = false;\n  rdo = rd;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0 && dstObj < dstFar && idObj == idWat) {\n      ro += dstObj * rd;\n      vnw = VaryNf (vec3 (4., 4., 2.) * qHit + 0.5 * vec3 (0., 0., tCur), vec3 (0., 1., 0.), 0.2);\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      isWat = true;\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    vf = vec2 (0.);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idRing || idObj == idAx) a = atan (qHit.y, - qHit.x);\n    if (idObj <= idGr2) {\n      if (idObj == idBase) {\n        col4 = vec4 (0.7, 0.6, 0.5, 0.) * (0.8 + 0.2 * Fbm2 (32. *\n           (((abs (vn.z) < 0.99) ? qHit.xz : qHit.xy)))) * (0.9 + 0.1 *\n           smoothstep (0., 0.01, abs (fract (qHit.z) - 0.5) - 0.02));\n        vf = vec2 (64., 1.);\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.8, 0.8, 0.8, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.01,\n           abs (abs (abs (qHit.x) - 1.6) - 0.1) - 0.01));\n        vf = vec2 (64., 0.3);\n      } else if (idObj == idArm) {\n        col4 = vec4 (0.95, 0.95, 0.6, 0.2);\n        if (abs (qHit.x) < hGap) col4 *= (0.8 + 0.2 * smoothstep (0., 0.01,\n           abs (abs (qHit.y) - 0.3) - 0.01));\n        vf = vec2 (64., 0.2);\n      } else if (idObj == idRing) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.01,\n           abs (fract (60. * a / (2. * pi)) - 0.5) - 0.05));\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.8, 0.8, 0.8, 0.2) * (0.9 + 0.1 * step (0., cos (8. * a)));\n      } else if (idObj == idGate) {\n        col4 = vec4 (0.4, 0.5, 0.2, 0.1) * (0.8 + 0.2 * step (0., PrBox2Df (qHit.xy,\n           vec2 (0.7, 0.1))));\n      } else if (idObj == idGr1) {\n        col4 = vec4 (0.8, 0.6, 0.2, 0.2);\n      } else if (idObj == idGr2) {\n        col4 = vec4 (0.9, 0.7, 0.2, 0.2);\n      }\n    } else {\n      if (idObj == idChan) {\n        col4 = vec4 (0.8, 0.9, 1., 0.1) * (0.8 + 0.2 * smoothstep (0., 0.01,\n           abs (abs (qHit.x) - 0.8) - 0.01));\n        vf = vec2 (64., 0.2);\n      } else if (idObj == idRail) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2);\n      } else if (idObj == idBoatH) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.);\n      } else if (idObj == idBoat) {\n        if (abs (qHit.y - 0.15) < 0.03 || qHit.y > 0.4) col4 = vec4 (1., 0., 0., 0.2);\n        else col4 = (bId > 0.) ? vec4 (0.3, 0.8, 0.8, 0.2) : vec4 (0.8, 0.8, 0.3, 0.2);\n      } else if (idObj == idTun) {\n        col4 = vec4 (0.7, 0.6, 0.5, 0.) * (0.8 + 0.2 * smoothstep (0.,0.01,\n           abs (fract (qHit.z) - 0.5) - 0.01));\n        vf = vec2 (64., 1.);\n      } else if (idObj == idGrnd) {\n        col4 = mix (vec4 (0., 0.5, 0., 0.), vec4 (0.1, 0.45, 0.1, 0.), smoothstep (0.4, 0.6,\n           Fbm2 (0.5 * ro.xz)));\n        vf = vec2 (4., 1.);\n      }\n    }\n    if (vf.y > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    nDotL = max (dot (vn, sunDir), 0.);\n    if (idObj == idArm || idObj == idGr1 || idObj == idGr2) nDotL *= nDotL;\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, normalize (vec3 (sunDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (dot (sunDir,\n       reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = SkyCol (rd);\n  }\n  if (length (vec2 (ro.x, ro.y - 0.05 - hGap * (1. + sign (ro.z)))) < 1.1 * cRad)\n     col *= 0.2 + 0.8 * smoothstep (0., 1., zLen - ((sign (ro.z) > 0.) ? 10. : 5.) - abs (ro.z));\n  if (isWat) col = mix (vec3 (0., 0.1, 0.), 0.9 * col, 1. - 0.8 * pow (dot (- rdo, vnw), 2.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid, ut, mSize, msw;\n  float el, az, zmFac, asp, sr;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid = (1. - mSize.y) * vec2 (asp, -1.);\n  ut = abs (uv - mMid) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    msw = 2. * mPtr.xy - mMid / vec2 (asp, 1.);\n    if (Maxv2 (abs (msw)) < mSize.y) {\n      regId = 1;\n      msw /= 2. * mSize.y;\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (Maxv2 (ut) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1;\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += 0.7 * pi * msw.y;\n  } else {\n    az += 0.9 * pi * (2. * SmoothBump (0.25, 0.75, 0.24, mod (0.01 * tCur, 1.)) - 1.);\n    el -= 0.07 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, -0.08 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -30.);\n  zmFac = (vuId == 0) ? 3.5 : 7.;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 3.) col = vec3 (0.8, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2cW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1192, 1192, 1214, 1214, 6176], [6178, 6178, 6211, 6211, 6395], [6397, 6397, 6418, 6418, 6673], [6675, 6675, 6712, 6712, 6941], [6943, 6943, 6966, 6966, 7367], [7369, 7369, 7404, 7404, 11585], [11587, 11587, 11643, 11643, 13543], [13545, 13545, 13577, 13577, 13677], [13679, 13679, 13725, 13725, 13772], [13774, 13774, 13807, 13807, 13896], [13898, 13898, 13940, 13940, 13991], [13993, 13993, 14036, 14036, 14100], [14102, 14102, 14146, 14146, 14206], [14208, 14208, 14230, 14230, 14257], [14259, 14259, 14281, 14281, 14308], [14310, 14310, 14355, 14355, 14447], [14449, 14449, 14494, 14494, 14532], [14534, 14534, 14591, 14591, 14674], [14676, 14676, 14712, 14712, 14918], [14920, 14920, 14950, 14950, 15063], [15097, 15097, 15121, 15121, 15233], [15235, 15235, 15260, 15260, 15446], [15448, 15448, 15469, 15469, 15624], [15626, 15626, 15655, 15655, 15867], [15869, 15869, 15908, 15908, 16165]]}
{"id": "fs2cDc", "name": "Simple Hexagon grid", "author": "MarcoF", "description": "Hexagonal grid.\nAnother approch: https://www.shadertoy.com/view/ssjcW3", "tags": ["grid", "hexagon"], "likes": 6, "viewed": 297, "published": 3, "date": "1644250582", "time_retrieved": "2024-07-30T17:04:44.749075", "image_code": "float scale = 16.;\n\nvoid pixel2cubial(vec2 uv, out vec3 cellCoord, out vec3 cellUv) {\n\t#define HX vec2(1.0, 0.0)\n\t#define HY vec2(0.5, 0.866)\n\t#define HMAT mat2(HX, HY)\n\n\tvec2 axial = inverse(HMAT) * uv;\n\tvec3 cubial = vec3(axial, -axial.x - axial.y);\n\tcellCoord = round(cubial);\n\tvec3 dist = abs(cubial - cellCoord);\n\tif (dist.x > dist.y && dist.x > dist.z) {\n\t\tcellCoord.x = -cellCoord.y - cellCoord.z;\n\t}\n\telse if (dist.y > dist.z) {\n\t\tcellCoord.y = -cellCoord.x - cellCoord.z;\n\t}\n\telse {\n\t\tcellCoord.z = -cellCoord.x - cellCoord.y;\n\t}\n\n\tcellUv = cubial - cellCoord;\n}\n\n// cubialDistance\n// finds the distance between 2 hex cell positions\nfloat cubialDistance(vec3 a, vec3 b) {\n\tvec3 c = abs(a - b);\n\treturn max(c.x, max(c.y, c.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    uv *= scale;\n    \n    // find cubial coordinate\n\tvec3 cellCoord, cellUv;\n\tpixel2cubial(uv, cellCoord, cellUv);\n\n\tvec3 col = cos(cellCoord + iTime) * 0.5 + 0.5;\n    \n    vec3 dist = abs(cellUv.xyz - cellUv.zxy);\n    \n    // outline\n\tfloat s = smoothstep(0.0, 0.05, 1.0 - max(dist.x, max(dist.y, dist.z)));\n\tcol *= s;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2cDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 85, 85, 571], [573, 642, 680, 680, 737], [739, 739, 796, 796, 1194]]}
{"id": "ssjcW3", "name": "Hexagons grid 2", "author": "MarcoF", "description": "A different way to make an hexagons grid.\nFirst way: https://www.shadertoy.com/view/fs2cDc", "tags": ["grid", "hexagon"], "likes": 4, "viewed": 254, "published": 3, "date": "1644250550", "time_retrieved": "2024-07-30T17:04:45.560904", "image_code": "float scale = 16.0;\n\nbool flatTop = true;\n\nvec4 rect2hex(vec2 p){\n\tvec2 var = flatTop ? vec2(1., .5) : vec2(.5, 1.);\n    \n    vec2 s = flatTop ? vec2(1.7320508, 1.) : vec2(1., 1.7320508);\n    \n\tvec4 hC = floor(vec4(p, p - var)/s.xyxy) + .5;\n\tvec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    //vec4 hC = floor(vec4(p/s, p/s + .5));\n\t//vec4 h = p.xyxy - vec4(hC.xy + .5, hC.zw)*s.xyxy;\n\n\treturn dot(h.xy, h.xy) < dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nfloat edgeDistance(vec2 p) {\n\tp = abs(p);\n    \n\tfloat var = flatTop ? p.y : p.x;\n    \n    vec2 s = flatTop ? vec2(1.7320508, 1.) : vec2(1., 1.7320508);\n    \n\treturn max(dot(p, s*.5), var);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    uv *= scale;\n    \n    vec4 uvHex = rect2hex(uv);\n    \n    float ed = edgeDistance(uvHex.xy); // Edge distance.\n\tfloat cDist = dot(uvHex.xy, uvHex.xy); // Relative squared distance from the center.\n\n    vec3 col = vec3(0.);\n\tcol.rg = cos(uvHex.zw + iTime) * 0.5 + 0.5;\n    \n    // outline\n\tcol *= 1.0 - smoothstep(0.48, 0.5, ed);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 65, 65, 482], [484, 484, 512, 512, 674], [676, 676, 733, 733, 1144]]}
{"id": "Ns2yDc", "name": "Triangle grid", "author": "MarcoF", "description": "a simple way to make a triangular grid", "tags": ["grid", "triangle"], "likes": 5, "viewed": 372, "published": 3, "date": "1644248816", "time_retrieved": "2024-07-30T17:04:46.339822", "image_code": "#define PI 3.1415926535\n\nvec2 rotate(vec2 original, float angle, vec2 pivot){\n\tmat2 rotation = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\tvec2 final = original;\n\tfinal -= pivot;\n\tfinal *= rotation;\n\tfinal += pivot;\n\treturn final;\n}\n\nvec3 simplexGrid (vec2 uv) {\n\tvec3 xyz = vec3(0.0);\n\n\tfloat f2d = 0.3660254038; //(sqrt(3.) - 1.) / 2.;\n\tf2d *= (uv.x + uv.y);\n    \n    vec2 skew = vec2(0.0);\n    \n\tskew.x = uv.x + f2d;\n\tskew.y = uv.y + f2d;\n    \n    //skew.x = 1.1547 * uv.x;\n\t//skew.y = uv.y + 0.5 * skew.x;\n\n\n\tif (skew.x > skew.y) {\n\t\txyz.xy = 1.0 - vec2(skew.x, skew.y - skew.x);\n\t\txyz.z = skew.y;\n\t}\n\telse {\n\t\txyz.yz = 1.0 - vec2(skew.x - skew.y, skew.y);\n\t\txyz.x = skew.x;\n\t}\n\n\treturn xyz;\n}\n\nfloat scale = 10.;\nfloat lineSize = 0.05;\nfloat lineBlur = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n\tuv = rotate(uv, -PI/4., vec2(0.));\n    \n\tuv *= scale;\n    \n    vec3 uvT = simplexGrid(uv);\n\tvec3 cellCoord = floor(uvT);\n\tvec3 cellUv = fract(uvT);\n    \n    vec3 col = vec3(0.0);\n\tcol = cellUv;\n\tcol = cos(cellCoord+iTime) * 0.5 + 0.5;\n\n\t// outline\n    for (int i = 0; i < 3; i++) {\n        col *= smoothstep(lineSize / 2. - lineBlur, lineSize / 2. + lineBlur, cellUv[i]);\n        col *= smoothstep(lineSize / 2. - lineBlur, lineSize / 2. + lineBlur, 1. - cellUv[i]);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2yDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 77, 77, 244], [246, 246, 274, 274, 709], [777, 777, 834, 834, 1386]]}
{"id": "fsjyDc", "name": "Simple Rectangular grid", "author": "MarcoF", "description": "Simple rectangular grid", "tags": ["grid", "rectangle", "rect", "squares"], "likes": 3, "viewed": 248, "published": 3, "date": "1644246293", "time_retrieved": "2024-07-30T17:04:47.084830", "image_code": "#define LINESIZE 0.1\n\nvec2 scale = vec2(20., 20.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    //uv *= SCALE;\n    uv *= scale;\n    \n\tvec2 cellCoord = floor(uv);\n\tvec2 cellUv = fract(uv);\n\n\tvec3 col = vec3(0.0);\n\tcol.rg = cos(cellCoord + iTime) * 0.5 + 0.5;\n    \n    // outline\n    float lineSizeY = LINESIZE * scale.y / scale.x;\n\tcol *= step(LINESIZE/2., cellUv.x);\n    col *= 1. - step(1. - LINESIZE/2., cellUv.x);\n\tcol *= step(lineSizeY/2., cellUv.y);\n    col *= 1. - step(1. - lineSizeY/2., cellUv.y);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 109, 109, 601]]}
{"id": "NsjcD3", "name": "Sin Sequencer - Sound", "author": "gfy_9001", "description": "Sin Seq", "tags": ["sin", "audio", "sequencer", "sinewave"], "likes": 3, "viewed": 223, "published": 3, "date": "1644240175", "time_retrieved": "2024-07-30T17:04:47.888680", "image_code": "vec3 sinCol(int i, vec2 uv)\n{\n    return 0.5 + 0.5 * cos(float(i) + iTime + uv.xyx + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepMax = bpm2ms(BPM);\n    float stepTime = mod(iTime, stepMax);\n        \n    stepCounter = int(mod(iTime / stepMax, float(SEQ_LENGTH)));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float xP = stepTime / (stepMax * float(SEQ_LENGTH));\n    float x = float(stepCounter) / float(SEQ_LENGTH);\n    \n    if (uv.x <= x + xP)\n        fragColor = vec4(sinCol(stepCounter, uv + vec2(stepTime)), 1.0);\n    else\n        fragColor = vec4(sinCol(stepCounter, -uv * vec2(stepTime)) * vec3(0.1),1.0);\n        \n    if (uv.x <= x)\n        fragColor *= vec4(vec3(0.5), 1.0);\n}\n", "image_inputs": [], "sound_code": "// https://en.wikipedia.org/wiki/Piano_key_frequencies\n// f(n) = 2^((n - 49) / 12) * 440.\nfloat KeyToHz(float key)\n{\n    float k = (key - 49.) / 12.;\n    return pow(2., k) * 440.;\n}\n\n#define KEY_0_A KeyToHz(49.)\n#define KEY_0_C KeyToHz(52.)\n#define KEY_0_D KeyToHz(54.)\n#define KEY_0_E KeyToHz(56.)\n\n// Toggle me between [0, 1]\n#define USE_FM 0\n#define USE_LFO 0\n\nfloat Amp(float a)\n{\n    return a * 0.1;\n}\n\nfloat SquareWave(float a, float f, float p, float t)\n{\n    return Amp(a) * sign(sin(T_PI * f * t + p));\n}\n\nfloat SinWave(float f, float a, float t)\n{\n    return Amp(a) * sin(T_PI * f * t);\n}\n\nfloat SawWave(float p, float a, float t)\n{\n    float period_t = t/p;\n    return Amp(a) * (2.0 * (period_t - floor(0.5 + period_t)));\n}\n\nfloat FMSin(float time)\n{\n    // modulating frequency\n    float mf = 1. / 40.;\n    return SinMod(time, mf, 0., 1.);\n}\n\nfloat LFO(float time)\n{\n    // modulating frequency\n    float mf = 1. / 8.2;\n    return SinMod(time, mf, 0., 1.);\n}\n\nfloat AmpEnvelope(float s, float curve_amount, float t)\n{\n    return s * exp(curve_amount * t);\n}\n\n//\n// 1x8 Sequencer\n//\n// The key of each tone is placed in 'seq'\n//\n// Each step lasts 1/4 bar for a given BPM before moving to the next step\n//\n// The tone is generated from 'SinWave' function. You can also generate a more interesting tone by changing USE_FM 0 to USE_FM 1\n//\n// The tone for a given step is put through the 'AmpEnvelope' which reduces the amplitude over a short duration (attuenuating the signal)\n//\n\nvec2 mainSound( int samp, float time )\n{\n    float seq[SEQ_LENGTH] = float[SEQ_LENGTH] (KEY_0_A, KEY_0_C, KEY_0_D, KEY_0_E, KEY_0_A, KEY_0_A, KEY_0_C, KEY_0_A);\n\n    float stepMax = bpm2ms(BPM);\n    float stepTime = mod(time, stepMax);    \n    \n    stepCounter = int(mod(time / stepMax, float(SEQ_LENGTH)));\n    \n    float f = seq[stepCounter];\n    float a = 1.5;\n    float envelope_curve = -8.;\n    \n    // set USE_FM to 0 or 1 above\n#if USE_FM\n    f *= 0.5; // lower octave\n    envelope_curve = -12.; // sharper curve\n    float m = FMSin(stepTime);\n    f = m*m - (f *.8); // some funky shit\n    a += 4.; // VERY VERY WAY MORE STRONGER... volume\n#if USE_LFO\n    f = (m*m)*0.5; // changing sound, more wub\n#endif    \n#endif\n    \n    float s = SinWave(f, a, stepTime);\n    \n    // set USE_LFO to 0 or 1 above\n#if USE_LFO\n    s *= LFO(stepTime);\n    envelope_curve = -3.;\n#endif\n    \n    float e = AmpEnvelope(s, envelope_curve, stepTime);\n    \n    return vec2(e);\n}", "sound_inputs": [], "common_code": "#define BPM 700.\n#define SEQ_LENGTH 8\n\n#define EPSILON 0.00001\n#define PI 3.1415926536\n#define T_PI 6.2831853072\n\nint stepCounter = 0;\n\nfloat bpm2ms(float bpm)\n{\n    float min_in_ms = 60000.0;\n    float beat_ms = (min_in_ms / bpm) / 1000.0;\n    return beat_ms;\n}\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = T_PI / b;\n    return sin(p * (x + c)) + d;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 100], [102, 102, 159, 159, 737]]}
{"id": "fs2cD3", "name": "SPECTRA :::.", "author": "ENDESGA", "description": "function for a reasonably accurate optical spectrum", "tags": ["spectrum", "light", "optical", "rainbow", "spectra"], "likes": 9, "viewed": 348, "published": 3, "date": "1644239142", "time_retrieved": "2024-07-30T17:04:48.676574", "image_code": "#define T iTime\n#define R iResolution.xy\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923\n\n// special quotients (was custom fixed-point LUT)\n#define q5d3   .1666666\n#define q5d6   .8333333\n#define q1d12  .0833333\n#define q1d3   .3333333\n#define q1d2   .5\n\nvec3 spectra( float x, float l ) {\n    \n    // (optional) rectangular expand\n    x = mix((x * .5)+.25,x,1. - l);\n    \n    return vec3(\n    // RED + VIOLET-FALLOFF\n    -q1d12 * ( l - 1. ) * (\n    cos( PI * max( 0., min( 1., 12. * abs( ( q1d12 * l + x - q5d6 ) / ( l + 2. ) ) ) ) ) + 1. )\n    + q1d2 * cos( PI * min( 1., ( l + 3. ) * abs( -q5d3 * l + x - q1d3 ) ) ) + q1d2,\n    // GREEN, BLUE\n    q1d2 + q1d2 * cos( PI * min(\n    vec2( 1. ), abs( vec2( x ) - vec2( q1d2, ( 1.0 - ( ( 2. + l ) / 3. ) * q1d2 ) ) )\n    * vec2( 3. + l ) ) ) );\n}\n\nvoid mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = (I / R);\n    vec2 v = (uv.y > .5) ?\n        ((uv.y > .75) ?\n        vec2((1.-cos(T))*.5, 0.) : // full spectrum\n        vec2((1.-cos(T))*.5, .75)) : // warm to cold, sunset/sunrise\n        vec2(uv.x,1.-uv.y*2.);\n        \n    O = vec4( spectra( v.x, v.y ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 319, 361, 824], [826, 826, 867, 867, 1146]]}
{"id": "NsjyD3", "name": "malleable shape", "author": "MarcoF", "description": "A fun little shader I made to experiment with polar coordinates", "tags": ["abstract", "polar", "shape"], "likes": 9, "viewed": 217, "published": 3, "date": "1644234655", "time_retrieved": "2024-07-30T17:04:49.475438", "image_code": "#define PI 3.14159265359\n\nvec2 rotate(vec2 original, float angle, vec2 pivot) {\n    mat2 rotation  = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 final = original;\n    final -= pivot;\n    final *= rotation;\n    final += pivot;\n    return final;\n}\n\nvec2 cart2pol(vec2 uv) {\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    a = mod(a, PI * 2.0);\n    return vec2(r, a);\n}\n\n//  Function from Inigo Quilez\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat easySmoothstep(float edge, float smoothness, float x){\n\treturn smoothstep(edge - smoothness, edge + smoothness, x);\n}\n\nfloat nSpikes = 3.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - (fragColor.xy = iResolution.xy) ) / fragColor.y ;\n    \n    float t = mod(iTime * 0.2, PI*2.0);\n    \n    uv = rotate(uv, t, vec2(0.0));\n    \n    vec2 polarUv = cart2pol(uv);\n    \n    vec3 hsb = vec3(1.0);\n\n\thsb.y = 0.6;\n    \n    hsb.z = (1. - polarUv.x) * 0.5 + 0.5;\n    \n    hsb.x = -fract(iTime * 0.1);\n    \n    t = sin(iTime * 1.0);\n    \n    float s = 0.5 + t * sin(polarUv.y * nSpikes) * 0.1;\n    \n    float c = easySmoothstep(s, 0.05, polarUv.x);\n    \n    if (c < 0.5) {\n\t\thsb.x += polarUv.x * 0.2;\n\t}\n\telse {\n\t\thsb.x += polarUv.x * 0.1;\n\t\thsb.x = mod(hsb.x + 0.2, 1.0);\n\t}\n    \n    if (c >= 0.5) {\n        hsb.z *= smoothstep(0.5, 0.6, c);\n    }\n    else {\n        hsb.z *= smoothstep(0.5, 0.4, c);\n    }\n    \n    vec3 col = hsb2rgb(hsb);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 79, 79, 265], [267, 267, 291, 291, 400], [402, 475, 501, 501, 660], [662, 662, 722, 722, 785], [808, 808, 865, 865, 1673]]}
{"id": "sdSyWc", "name": "Sound Experiment #3", "author": "oneshade", "description": "Weird warbling.", "tags": ["sound", "experiment", "warbling"], "likes": 10, "viewed": 178, "published": 3, "date": "1644210103", "time_retrieved": "2024-07-30T17:04:50.395977", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\nfloat whiteNoise(in float time) {\n    return fract(495.381 * cos(937.385 * time + 18.387));\n}\n\nfloat squareWave(in float time) {\n    return 1.0 - 2.0 * mod(floor(2.0 * time), 2.0);\n}\n\nfloat triWave(in float time) {\n    return 1.0 - abs(mod(4.0 * time + 1.0, 4.0) - 2.0);\n}\n\nfloat sineWave(in float time) {\n     return sin(TAU * fract(time));\n}\n\nfloat makeNoise(in float time) {\n    //time = 10.0 * sin(2.0 * time + sin(10.0 * time));\n    time = 5.0 * sin(time + sin(3.0 * time));\n    time = mod(time, 0.5);\n    float env = 0.0;\n    float envTime = 50.0 * time;\n    if (envTime < 1.0) env = 2.0 * envTime;\n    else if (envTime < 2.0) env = 3.0 - envTime;\n    else if (envTime < 4.0) env = 1.0;\n    else if (envTime < 5.0) env = 5.0 - envTime;\n    return sineWave(200.0 * time) * env * 0.5;// * 0.01;\n}", "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1411]]}
{"id": "fdBcDc", "name": "Fluttery Circles", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 31, "viewed": 451, "published": 3, "date": "1644191780", "time_retrieved": "2024-07-30T17:04:51.203817", "image_code": "#define pi 3.14159\n\n#define h21(a) fract(sin(dot(a, vec2(13,79))) * 4e5 )\n#define thc(a,b) tanh(a * cos(b)) / tanh(a)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.45 * iTime;\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.y += 0.12 * time;\n    //time += uv.x * 4.;\n    float sc = 10.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float h = h21(ipos);\n    float h2 = 2. * pi * h21(ipos + 2.);\n    \n    vec2 p = fract(fpos - 4. * thc(2., vec2(h2, 2. * pi * h) + time)) - 0.5;\n        \n    float d = length(p);\n    float k = 1. + h;\n    float s = smoothstep(-k, k, -d + 0.2);\n    \n    vec2 pw = vec2(5. + 4. * thc(20., 8. * d + h2 + time));\n    vec2 b = pow(1. - 4. * fpos * fpos, pw);\n    \n    vec3 e = vec3(1.5);\n    // 50% chance of having white in it, .5+.5*cos gives white to some of it\n    float cp = step(0.5 + 0.5 * step(h, 0.5) * cos(8. * d), 0.5);\n    vec3 col = pal(h2 + 0.25 * d, e, e, e, cp * vec3(0.,0.33,0.66));\n    col *= b.x * b.y * s; // * step(h21(ipos + 1.), 0.5); \n    col += 0.16;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 187, 187, 230], [232, 232, 289, 289, 1239]]}
{"id": "sdSyz3", "name": "The Dark Side of the Moon", "author": "nyri0", "description": "Increase AA for better anti-aliasing, or decrease if you experience a low framerate.\nIt looks a bit different than the original Pink Floyd album cover because this shader follows accurate refraction laws.", "tags": ["pink", "cover", "floyd"], "likes": 18, "viewed": 423, "published": 3, "date": "1644188503", "time_retrieved": "2024-07-30T17:04:52.318836", "image_code": "#define AA 4\n#define SPEED 0.5\n#define PI 3.14159265\n#define N_RED 1.25\n#define N_PURPLE 1.45\n\nfloat sq(float x) {\n    return x * x;\n}\n\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec2 grad( ivec2 z )\n{\n    // 2D to 1D\n    int n = z.x+z.y*11111;\n    // Hugo Elias hash\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n}\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return 0.5 + 0.5*\n        mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                  dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n        mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n             dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat length_sq(vec2 x) {\n    return dot(x, x);\n}\n\nfloat segment_df(vec2 uv, vec2 p0, vec2 p1) {\n  float l2 = length_sq(p1 - p0);\n  float t = clamp(dot(uv - p0, p1 - p0) / l2, 0.0, 1.0);\n  vec2 projection = p0 + t * (p1 - p0);\n  return distance(uv, projection);\n}\n\n// https://stackoverflow.com/a/2049593/8259873\nfloat segment_side(vec2 p0, vec2 p1, vec2 p2)\n{\n    return (p0.x - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (p0.y - p2.y);\n}\n\n\nbool triangle_in(vec2 uv, vec2 p0, vec2 p1, vec2 p2)\n{\n    float d0 = segment_side(uv, p0, p1);\n    float d1 = segment_side(uv, p1, p2);\n    float d2 = segment_side(uv, p2, p0);\n\n    bool has_neg = (d0 < 0.0) || (d1 < 0.0) || (d2 < 0.0);\n    bool has_pos = (d0 > 0.0) || (d1 > 0.0) || (d2 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\n// From https://iquilezles.org/articles/smin\nfloat smin( float a, float b )\n{\n    float k = 0.05;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat triangle_sdf(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n    float p0p1 = segment_df(uv, p0, p1);\n    float p1p2 = segment_df(uv, p1, p2);\n    float p2p0 = segment_df(uv, p2, p0);\n    return triangle_in(uv, p0, p1, p2) ? min(-smin(p0p1, smin(p1p2, p2p0)),-0.001) : min(p0p1, min(p1p2, p2p0));\n}\n\nvoid line_seg_inter(vec2 p0, vec2 p1, vec2 q0, vec2 q1, out vec2 inter, out float t) {\n    mat2 A;\n    A[0] = p1 - p0;\n    A[1] = q0 - q1;\n    vec2 b = q0 - p0;\n    vec2 st = inverse(A) * b;\n    t = st.x;\n    inter = (1.0-st.y)*q0 + st.y*q1;\n}\n\n// Absolute angle between the two vectors\nfloat angle_between(vec2 a, vec2 b) {\n    return acos(dot(a, b));\n}\n\nmat2 rotation_mat(float alpha) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat2(c, s, -s, c);\n}\n\nfloat refraction(float n0, float theta0, float n1) {\n    return asin(n0/n1*sin(theta0));\n}\n\nvec2 par_coord(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d) {\n    // Change of basis to (c-a, b-a)\n    mat2 change0;\n    change0[0] = c-a;\n    change0[1] = b-a;\n    \n    // Coordinates of uv wrt (c-a, b-a)\n    vec2 uv_coord = inverse(change0) * (uv-a);\n    \n    // Coordinates of d wrt (c-a, b-a)\n    vec2 d_coord = inverse(change0) * (d-a);\n    \n    // Change  coordinates so that c and d are at x=1\n    uv_coord.x /= 1.0 + uv_coord.y * (d_coord.x - 1.0) / d_coord.y;\n    \n    return uv_coord;\n}\n\nfloat antisigmoid(float x) {\n    return 0.25*(1.0-pow(2.0*(x-0.5), 3.0)) + 0.5*(1.0-x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Triangle\n    const float c = 1.2;\n    //float alpha = 0.2 * sin(SPEED*iTime);\n    float alpha = 0.0;\n    mat2 alpha_mat = rotation_mat(alpha);\n    vec2 tc = vec2(0.0, 1.0);\n    vec2 t0 = vec2(-c/2.0, -c/(2.0*sqrt(3.0)));\n    vec2 t1 = vec2(0.0, c/sqrt(3.0));\n    vec2 t2 = vec2(c/2.0, -c/(2.0*sqrt(3.0)));\n    vec2 t0b = tc + alpha_mat * (t0-tc);\n    vec2 t1b = tc + alpha_mat * (t1-tc);\n    vec2 t2b = tc + alpha_mat * (t2-tc);\n    \n\n    // Incoming ray\n    //float beta = radians(15.0);\n    float beta = radians(15.0 + 5.0*sin(SPEED*iTime));\n    const vec2 p1 = vec2(-2.0, -0.27);\n    vec2 p0 = p1 - 5.0 * vec2(1.0, tan(beta));\n    \n    // First intersection\n    vec2 inter0;\n    float t;\n    line_seg_inter(p0, p1, t0b, t1b, inter0, t);\n    float angle0 = angle_between(normalize(p1-p0), normalize(t1b-t0b));\n    \n    // First refraction\n    float gamma_red = beta - PI/2.0 + angle0 + refraction(1.0, PI/2.0-angle0, N_RED);\n    vec2 p2_red = inter0 + vec2(cos(gamma_red), sin(gamma_red));\n    float gamma_purple = beta - PI/2.0 + angle0 + refraction(1.0, PI/2.0-angle0, N_PURPLE);\n    vec2 p2_purple = inter0 + vec2(cos(gamma_purple), sin(gamma_purple));\n    \n    // Second intersections\n    vec2 inter1_red;\n    line_seg_inter(inter0, p2_red, t1b, t2b, inter1_red, t);\n    float angle1_red = angle_between(normalize(p2_red-inter0), normalize(t2b-t1b));\n    vec2 inter1_purple;\n    line_seg_inter(inter0, p2_purple, t1b, t2b, inter1_purple, t);\n    float angle1_purple = angle_between(normalize(p2_purple-inter0), normalize(t2b-t1b));\n    \n    // Second refractions\n    float eta_red = gamma_red - (refraction(N_RED, PI/2.0 - angle1_red, 1.0) - PI/2.0 + angle1_red);\n    vec2 p3_red = inter1_red + 3.0*vec2(cos(eta_red), sin(eta_red));\n    float eta_purple = gamma_purple - (refraction(N_PURPLE, PI/2.0 - angle1_purple, 1.0) - PI/2.0 + angle1_purple);\n    vec2 p3_purple = inter1_purple + 3.0*vec2(cos(eta_purple), sin(eta_purple));\n    \n    vec4 colSum = vec4(0);\n    for(int i = 0; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            vec2 sampleCoord = fragCoord + vec2(float(i) / float(AA), float(j) / float(AA));\n\n            // uv is centered and such that the vertical values are between -1\n            // and 1 while preserving the aspect ratio.\n            vec2 uv = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n\n            const vec3 BG = vec3(0, 0, 0);\n            vec3 col = BG;\n            \n            if(segment_df(uv, p0, inter0) < 0.008) col = vec3(1, 1, 1);\n    \n            float prism_intensity = 0.0; // TODO: use\n            float prism_ray_sdf = triangle_sdf(uv, inter0, inter1_red, inter1_purple);\n            if(prism_ray_sdf < 0.008) {\n                prism_intensity = 1.0-clamp((uv.x-inter0.x)/(inter1_red.x-inter0.x), 0.0, 1.0);\n            }\n\n            float t_sdf = triangle_sdf(uv, t0b, t1b, t2b);\n            if(t_sdf < 0.0 && t_sdf > -0.1) prism_intensity = max(prism_intensity, sq(smoothstep(-0.1, 0.0, t_sdf)));\n\n            float grain = noise(200.0*uv);\n            float asig = antisigmoid(prism_intensity);\n            float grain_intensity = smoothstep(asig, asig+0.2, grain) * prism_intensity;\n            col = mix(col, mix(vec3(0.2, 0.7, 0.8), vec3(1, 1, 1), sq(prism_intensity)), grain_intensity);\n\n            vec2 rainbow_st = par_coord(uv, inter1_red, p3_red, inter1_purple, p3_purple);\n            if(rainbow_st.y > 0.0 && rainbow_st.x > 0.0 && rainbow_st.x < 1.0) {\n                if(rainbow_st.x < 1.0/6.0) col = mix(vec3(0.9, 0.1, 0.05), vec3(0.9, 0.2, 0.0), grain);\n                else if(rainbow_st.x < 2.0/6.0) col = mix(vec3(0.9, 0.3, 0.0), vec3(0.95, 0.5, 0.0), grain);\n                else if(rainbow_st.x < 3.0/6.0) col = mix(vec3(1.0, 0.85, 0.0), vec3(0.9, 0.75, 0.0), grain);\n                else if(rainbow_st.x < 4.0/6.0) col = mix(vec3(0.35, 0.6, 0.0), vec3(0.5, 0.7, 0.0), grain);\n                else if(rainbow_st.x < 5.0/6.0) col = mix(vec3(0.0, 0.6, 0.85), vec3(0.1, 0.7, 0.9), grain);\n                else col = mix(vec3(0.5, 0.2, 0.5), vec3(0.55, 0.25, 0.55), grain);\n            }\n            \n            colSum += vec4(col, 1.0);\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 114, 114, 134], [136, 1194, 1216, 1232, 1425], [1426, 1426, 1452, 1452, 1827], [1829, 1829, 1854, 1854, 1878], [1880, 1880, 1925, 1925, 2092], [2094, 2141, 2188, 2188, 2264], [2267, 2267, 2321, 2321, 2600], [2602, 2647, 2679, 2679, 2783], [2785, 2785, 2841, 2841, 3079], [3081, 3081, 3167, 3167, 3324], [3326, 3368, 3405, 3405, 3435], [3437, 3437, 3469, 3469, 3553], [3555, 3555, 3607, 3607, 3645], [3647, 3647, 3704, 3741, 4139], [4141, 4141, 4169, 4169, 4230], [4232, 4232, 4289, 4305, 8487]]}
{"id": "fsBcWc", "name": "quadBezierTriangle QuaternionCam", "author": "ollj", "description": "move = ESDF             +TG (=up down)   \nrotate = arrows/mouse +WR(roll)\nray2TriangleBezierQuadratic is analytic (4 roots or less) fast and precise\n\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs", "tags": ["bspline", "bezierpatch", "fly", "aabv", "pqfm", "bpatch", "quaternioncamera", "tracequadratic"], "likes": 2, "viewed": 129, "published": 3, "date": "1644181394", "time_retrieved": "2024-07-30T17:04:53.787907", "image_code": "//remove the line below to only show the background\n#define showbezier\n\n\n//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\n//to better approach this, lets add ANY background, with the same camera\n\n\n\n//using\n//https://www.shadertoy.com/view/llj3Rz\n//but with a buffered quaternion camera\n//only to have any backdrop other than a grey void\n\n\n// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n/*\nvoid mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel2,u/iResolution.xy, -100.0 );\n //o=mainImageD(o,u);\n  //o+=mainImage2(o,u);\n}\n*/\n\n\n//using\n//https://www.shadertoy.com/view/llj3Rz\n//but with a buffered quaternion camera\n//only to have any backdrop other than a grey void\n\n// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float h = dot( oc, oc ) - b*b;\n    return sqrt( max(0.0,h)) - sph.w;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\n}    \n\n// https://iquilezles.org/articles/spherefunctions/\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return (pos - sph.xyz)/sph.w;    \n}\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    vec3 n = d*d;\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x ) m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.5 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\n//--------------------------------------------------------------------\n\nconst vec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\nfloat rayTrace( in vec3 ro, in vec3 rd )\n{\n    return shpIntersect( ro, rd, sph1 );\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 r = pos.xz - sph1.xz;\n    float h = 1.0-2.0/(1.0+0.3*dot(r,r));\n    return pos.y - h;\n}\n\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\n{\n    float t = 0.0;\n    \n    // bounding plane\n    float h = (1.0-ro.y)/rd.y;\n    if( h>0.0 ) t=h;\n\n    // raymarch\n    for( int i=0; i<20; i++ )    \n    {        \n        vec3 pos = ro + t*rd;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    return t;    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col = background( rd, lig );\n    \n    // raytrace stuff    \n    float t = rayTrace( ro, rd );\n\n    if( t>0.0 )\n    {\n        vec3 mat = vec3( 0.18 );\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph1 );\n            \n        float am = 0.1*iTime;\n        vec2 pr = vec2( cos(am), sin(am) );\n        vec3 tnor = nor;\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\n\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\n        pr = vec2( cos(am2), sin(am2) );\n        vec3 tnor2 = nor;\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\n\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\n\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\n\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\n        sea *= 0.15;\n\n        vec3 land = vec3(0.02,0.04,0.0);\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\n        land *= 0.5;\n\n        float los = smoothstep(0.45,0.46, l);\n        mat = mix( sea, land, los );\n\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\n\n        mat = mix( mat, vec3(0.93*0.15), clouds );\n\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\n        mat *= 0.8;\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\n        lin += 0.01;\n        col = mat * lin;\n        col = pow( col, vec3(0.4545) );\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\n\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\n    }\n    \n    // raymarch stuff    \n    float tmax = 20.0;\n    if( t>0.0 ) tmax = t; \n    t = rayMarch( ro, rd, tmax );    \n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n\n        vec2 scp = sin(2.0*6.2831*pos.xz);\n\n        vec3 wir = vec3( 0.0 );\n        wir += 1.0*exp(-12.0*abs(scp.x));\n        wir += 1.0*exp(-12.0*abs(scp.y));\n        wir += 0.5*exp( -4.0*abs(scp.x));\n        wir += 0.5*exp( -4.0*abs(scp.y));\n        wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\n\n        col += wir*0.5*exp( -0.05*t*t );\n    }        \n\n    // outter glow\n    if( dot(rd,sph1.xyz-ro)>0.0 )\n    {\n        float d = sphDistance( ro, rd, sph1 );\n        vec3 glo = vec3(0.0);\n        glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n        glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n        glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n        col += glo*1.5;\n    }        \n    \n    //col *= smoothstep( 0.0, 6.0, iTime ); //fade in from black\n\n    return col;\n}\n\n/*\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}*/\n\nvec4 mainImage2(in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif \n\n        float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n        float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n        \n        //vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n        //vec3 rt = vec3( 1.0, 0.0, 0.0 );\n\n       // mat3 cam = setCamera( ro, rt, 0.35 );\n        \n        vec3 ro=get(camP0).xyz;\n        vec4 q=get(camA0); //get() always gets from ichannel2\n        mat3 cam=q2m(q);\n        \n        const float FOV=1.;\n        vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n         vec3 rd=normalize(cam*vec3(1.,FOV*uv));\n        //vec3 rd = normalize( cam * vec3( p, -2.0) );\n\n        col += render( ro, rd );\n\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    vec4 o=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );\n    o=clamp(o,0.,1.);\n   // return mix(fragColor,o,.7);\n    \n    col=clamp(col,0.,1.);\n\treturn vec4( col, 1.0 ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o=vec4(0.);\n    #ifdef showbezier\n    o=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );//the bezier, buffC\n    //o=clamp(o,0.,1.);//safeguard unecessary\n    fragColor =o;\n    #endif\n    if(o.a==0.)   //if(transparent)\n    fragColor=mainImage2(fragCoord);  //backbround == https://www.shadertoy.com/view/llj3Rz\n    //both use quzaternion-camera of buffB\n}\n\n/*\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    \n    \n    fragColor = vec4( render( ro + cam*fragRayOri,\n                                   cam*fragRayDir ), 1.0 );\n                                   \n  // fragColor=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );\n\n}*/\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){\n  ;float d=PHYSICS_RADIUS//-df(r.xyz) //include df() as distance field function here to collide the dcamera\n  ;if (d>0.)r.xyz+=0. //+normal(r)*d //optional collision \n  //include the function that estimates the surface normal of the df() function here \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart= vec4(.5,0,.27,0)*pi; //vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2022-02 union of \n//https://www.shadertoy.com/view/wlSyzd (quadratic bezier triangle   2022-01)\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n//camera starting position\nconst vec4 posStart=vec4(-3,3,1,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=-100.\n ,LIN_ACCE=7.//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=7.//linear drag\n ,ANG_DRAG=2.//angular drag\n;\n#endif\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\n/*v3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n*/\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n/*\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n\n//float df (vec3 u){u=repeat(u);return mandelBulb (u);}\n//vec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\n\nvec3 normal(in vec3 p\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n*/\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}\n\n", "buffer_c_code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//scaling to merger this with others as enironment-set\nconst float scale=.2;\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//p1,p2,p3 corners of base triangle\n//c1,c0 6 CW heights (a vec3 for corners and a vec3 for midpoints)\n//... (orthogonal to triangle plane)\n//res=resolution.x (screen width in pixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5\n  ){cd+=v2(0,.3,.3)\n   ;v2 ci=S+a.y*E;//closest interection(hopefully)\n   //;if (dot(ci,-d)<0.)return vec4(0.); //check if intersection is behind camera\n   ;return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n   ;}}\n  ;return v3(0,0,0,2);}//no intersection\n//\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\n//\n/*\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n*/\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;u/=scale\n;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w\n;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\n\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.z,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.x,.2))\n         ;}//paint 6 CVs as spheres\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\n//a faster and insignificantly less precise 3d line segment distance.\n//https://www.shadertoy.com/view/ssyXzy\nfloat angularSeg16(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float e = dot(d, a),\n      f = dot(d, b),\n\t  w = dot(b, b) - f * f;\n    vec3 x = a + b * (abs(w) < 1e-7 ? .5 : clamp((e * f - dot(b, a)) / w, 0., 1.)); // closest point on segment\n    float s = dot(d, x);\n    return s < 0. ? 3e38 // behind camera -> infinity\n        : dot(x, x) - s * s; // AngularDistanceSquaredDotted\n}\nbool segmentMask(vec3 d,vec3 a,vec3 b //viewRayDir, segmentStart,segmenrEnd\n){float tiny=.001 ;\n    float g =angularSeg16(d, a, b)+tiny;\n    g = sqrt(g); // un-square squared signed distance\n    g -= .022+tiny; // thickness\n    return (g <= .01)\n    ;}\n\nfloat drawTri(v2 v,v2 d,v2 p1,v2 p2,v2 p3,float o\n){float t0=0.\n ;p1.z+=o\n ;p2.z+=o\n ;p3.z+=o \n ;v-=o\n ;t0=+v0(segmentMask(d,p1,p2))\n ;t0+=v0(segmentMask(d,p1,p3))\n ;t0+=v0(segmentMask(d,p2,p3));//base triangle done\n ;return t0;\n}\n\nv3 drawPrism(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b\n){//position,direction, 3*trianglecorners , 3*CV ,3*CV\n float t0=0.;\n p1-=v;\n p2-=v;\n p3-=v;\n v3 c=v3(0);\n      t0+=drawTri(v,d,p1,p2,p3,0.);//triangle at z=0\n      t0+=v0(segmentMask(d,p1,p1+vec3(0,0,a.x)));\n      t0+=v0(segmentMask(d,p2,p2+vec3(0,0,a.y)));\n      t0+=v0(segmentMask(d,p3,p3+vec3(0,0,a.z)));//3 corner CV done\n      vec3 m1=mix(p1,p2,.5);\n      vec3 m2=mix(p1,p3,.5);\n      vec3 m3=mix(p2,p3,.5);//3 triangle midpoints\n      t0+=v0(segmentMask(d,m1,m1+vec3(0,0,b.z)));\n      t0+=v0(segmentMask(d,m2,m2+vec3(0,0,b.y)));\n      t0+=v0(segmentMask(d,m3,m3+vec3(0,0,b.x)));//3 midpoint CVs done\n      if (t0>1.)t0=1.;//capping brightness of all the above\n      \n      float mi=min(min(min(a.x,a.y),min(a.z,b.z)),min(b.x,b.y));//min of 6\n      float ma=max(max(max(a.x,a.y),max(a.z,b.z)),max(b.x,b.y));//max of 6\n      t0+=drawTri(v,d,p1,p2,p3,mi)*.3;//triangle at z=mi (dimmed, uncapped)\n      t0+=drawTri(v,d,p1,p2,p3,ma)*.3;//triangle at z=ma\n return v3(t0)*.4;//thin dark grey dithered lines\n}\n\nv3 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3,vec2 uv\n){//position,direction, trianglecorners , ScreenSpaceUv(for dither only)\n ;p1*=scale\n ;p2*=scale\n ;p3*=scale\n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0])*scale, b=cos(pq[2])*scale //a and b are 9 cv heights\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v3(.5,.5,.5,0)//if(ray misses AABV)return grey transparent\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5)){ //if(color is still backgound color == no compositing effect \n //if condition is lazy condition, lazy coding, but weorks)\n c.xyz=mix(c.xyz,cd,.5);//debug color output, 2 cases are colored differently\n  //last color is like saturation here.\n  //if(mod(iTime*.4,1.)<.5)\n  if(board(uv/2.)==0.)  return vec4(0.);}//pixel-perfect a1pha dithering of the debug output\n  //thich mostly just shows the AABV-box\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;o+=drawPrism(v,d,p1,p2,p3,a,b);\n ;return vec4(o.xyz,1.);\n;}\n\nv3 scene(v2 o,v2 d,v1 uv\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o.zxy,d.zxy,p1,p2,p3,uv)\n ;}//origin,direction\n\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get() always gets from ichannel2\n ;mat3 cam=q2m(q)\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n ;O=v3(scene(get(camP0).xyz,rd,U));}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3611, 3663, 3722, 3722, 3897], [3899, 3951, 4009, 4009, 4138], [4140, 4192, 4264, 4264, 4453], [4459, 4511, 4555, 4555, 4595], [4597, 4597, 4665, 4665, 4915], [4917, 4917, 4938, 4938, 5032], [5034, 5034, 5061, 5061, 5422], [5483, 5483, 5524, 5524, 6390], [6511, 6511, 6553, 6553, 6596], [6598, 6598, 6624, 6624, 6721], [6723, 6723, 6777, 6777, 7081], [7083, 7083, 7122, 7122, 10125]]}
{"id": "NdByWc", "name": "UTCG Fishy", "author": "galactustrombone", "description": "Starter code for competition at the end of UTCG shaders workshop", "tags": ["utcg2022"], "likes": 2, "viewed": 48, "published": 3, "date": "1644180599", "time_retrieved": "2024-07-30T17:04:54.525934", "image_code": "const float M_PI = 3.14159265358979323846264338327950288;\n\nfloat mandel (float cx, float cy) {\n\tfloat x = 0.;\n\tfloat y = 0.;\n\tint i;\n\tfor (i = 0; i < 64; i++) {\n\t\tif ((x*x + y*y) > 4.) {\n\t\t  break;\n\t\t}\n\t\tfloat xtemp = x*x - y*y + cx;\n\t\ty = 2.*x*y + cy;\n\t\tx = xtemp;\n\t}\n\treturn sqrt(float(i) / 64.);\n}\n\n// 2d rotation matrix: rot(angle) * vector will rotate the vector by angle clockwise\nmat2 rot(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nbool isInCircle(vec2 centre, float radius, vec2 point)\n{\n    // return true if point is closer to centre than radius\n    return length(point - centre) < radius;\n}\n\n// ---------------- helpers above ----------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates from centre - centre is (0, 0)\n    vec2 uv = (fragCoord - vec2(iResolution.x, iResolution.y) / 2.) / iResolution.y;\n    \n    float speedup = 0.25;\n    \n    vec2 t = 6. * (uv - vec2(1.5 * iResolution.x / iResolution.y * (fract(iTime * speedup) - 0.5),\n                             0.2 * sin(iTime)));\n    t = rot(cos(iTime) * 0.2) * t;\n    vec4 col = vec4(mandel(t.x, t.y), 0.1, 1, 1);\n    \n    float bubbleR = 0.1;\n    float bubbleSize = bubbleR + bubbleR / 2. * sin(iTime / 5. + cos(uv.x * 5.));\n    for (int i = 0; i < 20; i++)\n    {\n        float weirdTime = iTime * float(i + 1) / 20.;\n        vec2 bubbleCentre = vec2(0.5 * sin(iTime + float(i * i * i)),\n                                 1.5 * (weirdTime - floor(weirdTime) - 0.5));\n        if (isInCircle(bubbleCentre, bubbleSize, uv))\n        {\n            col += vec4(0.1, 0.1, 0.1, 1);\n        }\n    }\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdByWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 94, 94, 300], [302, 387, 410, 410, 478], [480, 480, 536, 596, 642], [696, 696, 753, 809, 1686]]}
{"id": "fdBcW3", "name": "My Second Pathtraced Scene", "author": "oneshade", "description": "Following @demofox's second tutorial: [url=https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy]https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/[/url]", "tags": ["globalillumination", "pathtracer", "stochastic"], "likes": 22, "viewed": 407, "published": 3, "date": "1644179558", "time_retrieved": "2024-07-30T17:04:55.822468", "image_code": "// Based on https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// and https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy\n\n// https://64.github.io/tonemapping/#uncharted-2\nvec3 Uncharted2(in vec3 color) {\n    color *= 2.0;\n\n    float A = 0.15, B = 0.50, C = 0.10;\n    float D = 0.20, E = 0.02, F = 0.30;\n    color = (((A * color + C * B) * color + D * E) / ((A * color + B) * color + D * F)) - E / F;\n\n    //float whiteMax = 4.0;\n    //color /= (((A * whiteMax + C * B) * whiteMax + D * E) / ((A * whiteMax + B) * whiteMax + D * F)) - E / F;\n    color *= 1.9335;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb /= fragColor.a; // Average\n    fragColor.rgb = Uncharted2(fragColor.rgb); // Tonemap\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545)); // Gamma correct\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings\n#define MAX_BOUNCES 16\n#define EPSILON 0.001\n\n// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    float hitDist;\n    vec3 hitPos;\n    vec3 surfNor;\n    vec2 surfUv;\n    int objId;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float percentSpecular;\n    float roughness;\n    vec3 specularColor;\n};\n\n// RNG utilities\nuint wangHash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n \nvec3 randUnitVec(inout uint state) {\n    float z = rand01(state) * 2.0 - 1.0;\n    float a = rand01(state) * TAU;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Camera basis matrix\nmat3 getCameraBasis(in vec2 an) {\n    vec2 c = cos(an), s = sin(an);\n    return mat3(       c.x, 0.0,        s.x,  // Right\n                s.x * -s.y, c.y,  c.x * s.y,  // Up\n                 s.x * c.y, s.y, -c.x * c.y); // Forward\n}\n\n// Update with closest intersection\nvoid addRayHit(inout HitInfo curHit, in HitInfo newHit) {\n    if (newHit.hitDist > 0.0) {\n        if (curHit.hitDist < 0.0) curHit = newHit;\n        else if (newHit.hitDist < curHit.hitDist) curHit = newHit;\n    }\n}\n\n// Transformations\nmat4 Translate(in vec3 t) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\nmat4 Scale(in vec3 s) {\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateX(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0,  co,  si, 0.0,\n                0.0, -si,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateY(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co, 0.0,  si, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -si, 0.0,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateZ(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co,  si, 0.0, 0.0,\n                -si,  co, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// Primitive intersectors\n// Ray vs. Plane intersection\nHitInfo planeIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float hitDist = -ray.pos.y / ray.dir.y;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = transpose(matInv)[1].xyz; // To worldspace\n    vec2 surfUv = hitPos.xz;\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // To worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}\n\n// Ray vs. Sphere intersection\nHitInfo sphereIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - 1.0;\n\n    float dis = b * b - a * c;\n    if (dis < 0.0) return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    float hitDist = (-b - sign(c) * sqrt(dis)) / a;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = (transpose(matInv) * vec4(hitPos, 0.0)).xyz; // Convert normal to worldspace\n    vec2 surfUv = vec2(atan(hitPos.z, hitPos.x), atan(hitPos.y, length(hitPos.xz)));\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // Convert position to worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}", "buffer_a_code": "HitInfo traceRay(in Ray ray) {\n    HitInfo hit = HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    // Ground plane\n    addRayHit(hit, planeIsect(ray, mat4(1.0), 1));\n\n    // Big sphere light\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 1.0, -5.0)), 2));\n\n    // Silver metallic spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.5, -5.0)) * Scale(vec3(0.5)), 3));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.0, 0.5, -5.0)) * Scale(vec3(0.5)), 3));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.15, -4.05)) * Scale(vec3(0.15)), 3));\n\n    // Green metallic spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.4, -3.0)) * Scale(vec3(0.4)), 4));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.0, 0.4, -3.0)) * Scale(vec3(0.4)), 5));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.4, -3.0)) * Scale(vec3(0.4)), 6));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 0.4, -3.0)) * Scale(vec3(0.4)), 7));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.0, 0.4, -3.0)) * Scale(vec3(0.4)), 8));\n\n    // Small sphere lights\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.1, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n\n    // Large opaque glass spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 0.75, -4.0)) * Scale(vec3(0.75)), 9));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.0, 0.75, -4.0)) * Scale(vec3(0.75)), 9));\n\n    // Sphere lights over the opaque glass spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 1.9, -4.0)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.0, 1.9, -4.0)) * Scale(vec3(0.2)), 2));\n\n    return hit;\n}\n\nMaterial getMaterial(in vec2 surfUv, in int objId) {\n    Material mtl = Material(vec3(0.0), vec3(0.0), 0.0, 0.0, vec3(0.0));\n\n    // Ground plane\n    if (objId == 1) mtl = Material(vec3(1.0, 0.4, 0.2), vec3(0.0), 0.5, 0.7, vec3(1.0, 0.4, 0.2));\n\n    // Big sphere light\n    if (objId == 2) mtl = Material(vec3(0.0), vec3(2.0), 0.0, 0.0, vec3(0.0));\n\n    // Silver metallic spheres\n    if (objId == 3) mtl = Material(vec3(0.0), vec3(0.0), 1.0, 0.0, vec3(1.0));\n\n    // Green metallic spheres with increasing roughness\n    if (objId == 4) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.0, vec3(0.0, 1.0, 0.0));\n    if (objId == 5) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.25, vec3(0.0, 1.0, 0.0));\n    if (objId == 6) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.5, vec3(0.0, 1.0, 0.0));\n    if (objId == 7) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.75, vec3(0.0, 1.0, 0.0));\n    if (objId == 8) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 1.0, vec3(0.0, 1.0, 0.0));\n\n    // Large opaque glass spheres\n    if (objId == 9) mtl = Material(vec3(1.0), vec3(0.0), 0.5, 0.0, vec3(1.0));\n\n    return mtl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Load last frame\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Jitter UVs for antialiasing\n    fragCoord += vec2(rand01(rngState), rand01(rngState));\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera ray\n    mat3 cam = getCameraBasis(vec2(0.0, -0.8));\n    Ray ray = Ray(vec3(0.0, 4.0, -0.5), normalize(cam * vec3(uv, 1.0)));\n\n    // Pathtrace!\n    vec3 acc = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    for (int bounce=0; bounce < MAX_BOUNCES; bounce++) {\n        HitInfo hit = traceRay(ray);\n        if (hit.hitDist < 0.0) break;\n        Material mtl = getMaterial(hit.surfUv, hit.objId);\n\n        hit.surfNor = normalize(hit.surfNor); // Normalize the surface normal as a final step\n        hit.surfNor *= sign(dot(hit.surfNor, -ray.dir)); // Flip towards the camera\n\n        // Accumulate bounce light\n        acc += mtl.emissive * throughput;\n\n        // Step to the surface\n        ray.pos = hit.hitPos + hit.surfNor * EPSILON;\n\n        // Choose specular reflection with chance percentSpecular\n        if (rand01(rngState) < mtl.percentSpecular) {\n            vec3 diffuseRay = normalize(hit.surfNor + randUnitVec(rngState));\n            vec3 specularRay = reflect(ray.dir, hit.surfNor);\n            ray.dir = normalize(mix(specularRay, diffuseRay, mtl.roughness * mtl.roughness));\n            throughput *= mtl.specularColor;\n        }\n\n        // Reflect diffusely otherwise\n        else {\n            ray.dir = normalize(hit.surfNor + randUnitVec(rngState));\n            throughput *= mtl.albedo;\n        }\n\n        // Russian roulette optimization\n        float stopChance = max(throughput.r, max(throughput.g, throughput.b));\n        if (rand01(rngState) > stopChance) break;\n        throughput /= stopChance;\n    }\n\n    // Accumulate frame\n    fragColor.rgb += acc;\n    fragColor.a += 1.0;\n\n    // Restart on mouse down\n    if (iMouse.z > 0.0) {\n        fragColor = vec4(0.0);    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 265, 297, 297, 676], [678, 678, 733, 733, 973]]}
{"id": "7d2cWV", "name": "Fork Creation by MarcoF", "author": "MarcoF", "description": "Creation with customizing variables.\nCredits to Danilo Guanabara.", "tags": ["creation"], "likes": 2, "viewed": 291, "published": 3, "date": "1644163324", "time_retrieved": "2024-07-30T17:04:56.669204", "image_code": "float zoom = 0.6;\nfloat timeMul = 1.0;\nfloat colorDistortion = 0.05;\nfloat rays = 0.3;\nfloat lMul = 9.0;\nfloat tMul = 2.0;\nfloat a = 1.;\nfloat brightness = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y;\n    uv = (2.*fragCoord - (fragColor.xy = iResolution.xy) ) / fragColor.y ;\n    \n\tuv *= zoom;\n    \n\tvec3 color = vec3(0.0);\n\n\tfloat l = length(uv);\n\tfloat t = iTime * timeMul;\n\tvec2 uv1;\n    \n\tfor (int i = 0; i < 3; i++) {\n\t\tt += colorDistortion;\n\t\tuv1 = uv + uv / l * (sin(t) + rays) * abs(sin(l*lMul - t*tMul));\n        \n\t\tfloat c = length(abs(mod(uv1, a) - (a/2.)));\n\t\tcolor[i] = 0.01 / c;\n\t}\n\n\tfragColor = vec4(brightness * color / l, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2cWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 218, 218, 702]]}
{"id": "sdjyDV", "name": "procedural marble", "author": "Angramme", "description": "f", "tags": ["f"], "likes": 3, "viewed": 312, "published": 3, "date": "1644163235", "time_retrieved": "2024-07-30T17:04:57.493002", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    for(int i=0; i<5; i++){\n        uv += vec2(.37, -.3);\n        uv = vec2(sin(uv.x*6.+uv.y*9.8)*.5+.5, cos(uv.y*6.68+uv.x*7.3)*.5*.5);\n    }\n    \n    float x = smoothstep(.4, .9, sin((uv.x-uv.y)*2.*3.1415)*.5+.5);\n    vec3 col = mix(vec3(27./255., 20./255., 33./255.), vec3(225./255., 253./255., 249./255.), x);\n    \n    // float y = smoothstep(.4, .9, sin(iTime+ (uv.x+uv.y)*2.*3.1415)*.5+.5);\n    // col += .5*mix(vec3(27./255., 20./255., 33./255.), vec3(225./255., 253./255., 249./255.), y);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 711]]}
{"id": "ss2cDK", "name": "fbm 1D, 2D, 3D functions", "author": "MarcoF", "description": "fbm functions in 1D, 2D and 3D.  \nYou can change the pseudorandom and noise functions with the functions of your choice.\nNote: I didn't invent these functions, this shader is a simple and clean view of this useful functions found online.", "tags": ["fbm"], "likes": 3, "viewed": 280, "published": 3, "date": "1644160436", "time_retrieved": "2024-07-30T17:04:58.256959", "image_code": "//\n// Pseudorandom functions.\n//\n\nfloat random (float x) {\n\tfloat f = 43758.5453123;\n\treturn fract(sin(x) * f);\n}\n\nfloat random (vec2 x) {\n\tvec2 r = vec2(12.9898, 78.233);\n\treturn random(dot(x, r));\n}\n\n//\n// Basic noise functions.\n//\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat fr = fract(x);\n\treturn mix(random(i), random(i + 1.0), fr);\n}\n\nfloat noise(vec2 x){\n\tvec2 i = floor(x);\n\tvec2 fr = fract(x);\n\tfr = fr*fr*(3.0-2.0*fr);\n\tfloat res = mix(\n\t\tmix(random(i), random(i+vec2(1.0,0.0)), fr.x),\n\t\tmix(random(i + vec2(0.0,1.0)), random(i + vec2(1.0,1.0)), fr.x),\n\t\tfr.y);\n\treturn res*res;\n}\n\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat noise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//\n// FBM functions.\n//\n\nfloat fbm (float x, int octaves, float amplitude, float frequency, float lacunarity, float gain) {\n\tfloat value = 0.0;\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tvalue += amplitude * noise(x * frequency);\n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\nfloat fbm (vec2 x, int octaves, float amplitude, float frequency, float lacunarity, float gain) {\n\tfloat value = 0.0;\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tvalue += amplitude * noise(x * frequency);\n\t\tx *= rot;\n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\nfloat fbm(vec3 x, int octaves, float amplitude, float frequency, vec3 shift, float lacunarity, float gain) {\n\tfloat value = 0.0;\n    for (int i = 0; i < octaves; ++i) {\n        float sn = noise(x * frequency);\n        value += amplitude * sn;\n        x += shift;\n        frequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\n//\n// FBM functions with default values.\n//\n\nfloat fbm(float x, int octaves) {\n\treturn fbm(x, octaves, 0.5, 1.0, 2.0, 0.5);\n}\n\nfloat fbm(vec2 x, int octaves) {\n\treturn fbm(x, octaves, 0.5, 1.0, 2.0, 0.5);\n}\n\nfloat fbm(vec3 uv, int octaves) {\n    return fbm(uv, octaves, 0.5, 1.0, vec3(8), 2.0, 0.5);\n}\n\n//\n// Main\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 5. * fragCoord/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    if (mod(iTime, 15.) < 5.)\n    {\n        col.r = fbm(uv.x + iTime, 2);\n    }\n    else if (mod(iTime, 15.) < 10.)\n    {\n        col.g = fbm(uv + iTime, 2);\n    }\n    else\n    {\n        col.b = fbm(vec3(uv, iTime), 2) * 2.;\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2cDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 58, 58, 113], [115, 115, 138, 138, 200], [235, 235, 257, 257, 347], [349, 349, 369, 369, 598], [600, 647, 668, 668, 705], [706, 706, 733, 733, 781], [783, 783, 803, 803, 2639], [2666, 2666, 2764, 2764, 2934], [2936, 2936, 3033, 3033, 3307], [3309, 3309, 3417, 3417, 3645], [3692, 3692, 3725, 3725, 3772], [3774, 3774, 3806, 3806, 3853], [3855, 3855, 3888, 3888, 3948], [3965, 3965, 4022, 4022, 4368]]}
{"id": "NsByWK", "name": "Grid distortion 2d", "author": "MarcoF", "description": "distortion effect using noise", "tags": ["noise", "distortion"], "likes": 8, "viewed": 328, "published": 3, "date": "1644145591", "time_retrieved": "2024-07-30T17:04:59.160543", "image_code": "\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\nfloat snoise(vec2 v) {\n\t// Precompute values for skewed triangular grid\n\tvec4 C = vec4(\n\t\t0.211324865405187, //(3.0-sqrt(3.0))/6.0\n\t\t0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n\t\t-0.577350269189626, // -1.0 + 2.0 * C.x\n\t\t0.024390243902439); // 1.0 / 41.0\n\n\t//C.w += time * 0.0005;\n\n\t// First corner (x0)\n\tvec2 i  = floor(v + dot(v, C.yy));\n\tvec2 x0 = v - i + dot(i, C.xx);\n\n\t// Other two corners (x1, x2)\n\tvec2 i1 = vec2(0.0);\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0):vec2(0.0, 1.0);\n\tvec2 x1 = x0.xy + C.xx - i1;\n\tvec2 x2 = x0.xy + C.zz;\n\n\t// Do some permutations to avoid\n\t// truncation effects in permutation\n\ti = mod289(i);\n\tvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\tm = m*m;\n\tm = m*m;\n\n\t// Gradients:\n\t//  41 pts uniformly over a line, mapped onto a diamond\n\t//  The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\n\t// Normalise gradients implicitly by scaling m\n\t// Approximation of: m *= inversesqrt(a0*a0 + h*h);\n\tfloat a = 1.79284291400159;\n\tfloat b = 0.85373472095314;\n\tm *= a - b * (a0*a0 + h*h);\n\n\t// Compute final noise value at P\n\tvec3 g = vec3(0.0);\n\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\tg.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n\treturn 130.0 * dot(m, g);\n}\n\nfloat fbm(vec2 uv, int octaves, float amplitude, float frequency, vec2 shift, float lacunarity, float gain) {\n\tfloat value = 0.0;\n    for (int i = 0; i < octaves; ++i) {\n        float sn = snoise(uv * frequency);\n        value += amplitude * sn;\n        uv += shift;\n        frequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\nfloat easySmoothstep(float edge, float smoothness, float x){\n\treturn smoothstep(edge - smoothness, edge + smoothness, x);\n}\n\nfloat line(float uv, float pos, float size) {\n\treturn 1.0 - easySmoothstep(size * 0.5, 0.05, abs(uv - pos));\n}\n\nfloat changeRange(float iValue, float iMin, float iMax, float fMin, float fMax) {\n\tfloat fValue = (iValue-iMin) / (iMax-iMin);\n\tfValue *= fMax - fMin;\n\tfValue += fMin;\n\treturn fValue;\n}\n\nvec2 scale(in vec2 original, in vec2 scale, in vec2 pivot){\n\tscale = 1.0 / scale;\n\tmat2 s = mat2(scale.x, 0.0, 0.0, scale.y);\n\tvec2 final = original;\n\tfinal -= pivot;\n\tfinal *= s;\n\tfinal += pivot;\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    //uv.x += iTime * 0.1;\n    \n    float n = fbm(uv * 0.3 + vec2(iTime * 0.1, 0.), 1, 1.0, 4.0, vec2(0.), 2.0, 0.5);\n    \n\tvec2 uvR = scale(uv, vec2(1.0) + n*0.05, vec2(0.5));\n    \n    //grid\n    vec2 uvGrid = fract(uvR * 10.);\n    \n    float lx = 1.0-line(uvGrid.x, 0.025, 0.05);\n\tfloat ly = 1.0-line(uvGrid.y, 0.025, 0.05);\n\tcol = vec3(1.0) * min(lx, ly);\n    \n\tfloat shade = changeRange(n, -1.0, 1.0, 0.0, 1.0);\n\tcol *= vec3(1.0) * shade;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsByWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 26, 47, 47, 94], [95, 95, 116, 116, 163], [164, 164, 186, 186, 227], [229, 544, 566, 615, 1967], [1969, 1969, 2078, 2078, 2309], [2311, 2311, 2371, 2371, 2434], [2436, 2436, 2481, 2481, 2546], [2548, 2548, 2629, 2629, 2733], [2735, 2735, 2794, 2794, 2948], [2950, 2950, 3007, 3007, 3558]]}
{"id": "fsjcDV", "name": "Torus example", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["primitive"], "likes": 5, "viewed": 253, "published": 3, "date": "1644143116", "time_retrieved": "2024-07-30T17:05:00.059141", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p){\n    p.xy*=rot(iTime*.5);\n    p.xz*=rot(iTime*.3);\n    float h=sin(iTime)*.5+.5;\n\n    // repeat x=0 slice between -h to h which means this line stretches simple circle align x-axis \n    p.x-=clamp(p.x,-h,h);\n    \n    // This block itself makes a dounut by the following steps:\n    // 1. calculate distance from edge of circle(radius is 0.3)\n    // 2. SDF of circle in a space of Z and distance from the circle which looks a donut in 3D space.\n    return length(vec2(\n        length(p.xy)-.3, // 1\n        p.z))-.1; // 2\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-3);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 590], [592, 592, 649, 649, 869]]}
{"id": "fdjcDV", "name": "short raymarch example", "author": "takahiroando", "description": "based on:\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["motionblur"], "likes": 1, "viewed": 218, "published": 3, "date": "1644142363", "time_retrieved": "2024-07-30T17:05:01.091380", "image_code": "float sphere(vec3 p) {\n    return length(p) - 2.0;\n}\n\n\nfloat map(vec3 p) {\n    vec3 c = vec3(20.0);\n    return sphere(mod(p + 0.5 * c, c) - 0.5 * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,-1)); // I prefer OpenGL coordinate!\n    vec3 p=vec3(5.0,0,-10.0 * iTime);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 52], [55, 55, 74, 74, 151], [153, 153, 210, 210, 473]]}
{"id": "7sScWy", "name": "Platinum Jubbly", "author": "mla", "description": "To mark the occasion of the Platinum Jubilee of Elizabeth II, by the Grace of God, of the United Kingdom of Great Britain and Northern Ireland and of Her other Realms and Territories Queen, Head of the Commonwealth, Defender of the Faith.", "tags": ["warhol", "art", "rle", "reproduction", "queen", "jubilee", "runlengthencoding"], "likes": 25, "viewed": 669, "published": 3, "date": "1644138781", "time_retrieved": "2024-07-30T17:05:02.843696", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Platinum Jubilee. mla, 2022\n//\n// I thought it would be fun to do something with run-length encoding (a\n// suggestion by Fabrice on https://www.shadertoy.com/view/fdjyzy#), which\n// works best on large blocks of color, something like a Warhol screen print\n// eg. https://www.npg.org.uk/collections/search/portrait/mw08322/Queen-Elizabeth-II\n// and by an extraordinary coincidence, today, February 6th, happens to be the\n// 70th anniversary of Her Majesty's accession to the throne, so I've added some\n// appropriate music as well. Not the Sex Pistols, alas. I couldn't find a\n// decent MIDI.\n//\n////////////////////////////////////////////////////////////////////////////////\n// Horizontally tile the window with an irregularly sized image from buffer.\n// Buffer image is rotated by 90° for better fit with landscape aspect ratio.\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // x scroll a whole number of pixels.\n  fragCoord.x += max(1.0,floor(float(iFrame)/1024.0*iResolution.x));\n  vec2 uv = fragCoord.xy/iResolution.y;\n  uv.y = 1.0-uv.y; // Flip y\n  uv.y *= iResolution.y/iResolution.x;\n  uv.x -= 0.5*(iResolution.x/iResolution.y-WIDTH/HEIGHT); // Centre x\n  uv *= HEIGHT/iResolution.y; // Scale for y dimension\n  float xwidth = WIDTH/iResolution.y;\n  float xoffset = floor(uv.x/xwidth);\n  uv.x -= xoffset*xwidth;\n  vec3 col = texture(CHAN,uv.yx).rgb;\n  int xindex = int(xoffset)+12;\n  // Some simple Warholian color manipulations\n  for (int i = 0; i < xindex%6; i++) {\n    col = col.gbr;\n    if (i==3) col.rg = col.gr;\n  }\n  if (xindex%2 != (xindex+2)/6%2) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 16 color GIF, cropped, run length encoded and packed into an array of uvec4s\n// Upper 4 bits of each byte is the runlength-1 (we don't need 0 length runs,\n// obviously), lower 4 bits is the color index.\n//\n// This only reduces data size by about 50%, but enough to pack into 2k uvec4s.\n// Still a lot of redundancy in the data, so further compression possible.\n//\n// Original image by Andy Warhol.\n//\n// Does basic coloring here rather than in Image tab to get the benefit\n// of texture filtering.\n//\n////////////////////////////////////////////////////////////////////////////////\nconst uvec4 data[] = uvec4[](\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf050f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f050f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f050u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x50f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf050f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f050f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f050u,0xf0f0f0f0u,0x01700190u),\nuvec4(0x03021120u,0x33020302u,0x30010402u,0xf0f0f001u),\nuvec4(0xf0f0f0f0u,0xf0f0b0f0u,0xf0f0f0f0u,0xa00180f0u),\nuvec4(0x02e30201u,0xf0f00104u,0xf0f0f0f0u,0xf0c0f0f0u),\nuvec4(0xf0f0f0f0u,0x31a0f0f0u,0x23020130u,0x01800104u),\nuvec4(0xf0044302u,0xf0f0f0f0u,0xa0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x80f0f0f0u,0x14530204u,0xe0010213u,0x03020411u),\nuvec4(0x12015004u,0x11040204u,0xf0f0f0f0u,0xb0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x60f0f0f0u,0x24123301u,0x10010213u),\nuvec4(0x1110f001u,0x04830430u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x50f0f0f0u,0x50012301u,0x01a0f011u),\nuvec4(0x01041302u,0x02040120u,0xf0f00203u,0x70f0f0f0u),\nuvec4(0x00f0f005u,0xf0f0f0f0u,0x40f0f0f0u,0xb0041304u),\nuvec4(0xa0950025u,0x00040201u,0x01060206u,0x01130130u),\nuvec4(0xf0f0f0f0u,0x70f0f0f0u,0xf0f0f0f0u,0x0180f0f0u),\nuvec4(0x01130190u,0x05205590u,0x70050470u,0x02011001u),\nuvec4(0x02030204u,0x10040240u,0x33121401u,0xf0f0f004u),\nuvec4(0xb0f0f0f0u,0xf0f0f0f0u,0x20f0f0f0u,0x70011301u),\nuvec4(0x24152075u,0x01a02427u,0x01100104u,0x10011013u),\nuvec4(0x93041001u,0xf0f0f004u,0x90f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0170f0f0u,0x02033204u,0x13010403u,0x00153001u),\nuvec4(0x20053014u,0x17b80714u,0x13016004u,0x01030220u),\nuvec4(0x01501170u,0x01020302u,0xf0f0f0f0u,0xf070f0f0u),\nuvec4(0xf0f0f0f0u,0x040110f0u,0x40c31203u,0x18071005u),\nuvec4(0x04050427u,0x0428f817u,0x02030150u,0x01030210u),\nuvec4(0x130110f0u,0xf0f0f004u,0x60f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0200f0f0u,0x11041243u,0x01000100u,0x01020100u),\nuvec4(0x04001520u,0x0408f8f8u,0x10050005u,0x03021301u),\nuvec4(0xf0050407u,0x01130420u,0xf0f0f0f0u,0xf040f0f0u),\nuvec4(0xf0f0f0f0u,0x130201e0u,0x05201104u,0x04203500u),\nuvec4(0x10150001u,0x4318f804u,0x043004c8u,0x10043813u),\nuvec4(0x0201f005u,0xf0010203u,0xf0f0f0f0u,0xf0f020f0u),\nuvec4(0x80f0f0f0u,0x04011001u,0x30041302u,0x20153015u),\nuvec4(0x00050105u,0x07050005u,0x98a308f8u,0x88070407u),\nuvec4(0x05000507u,0x130100f0u,0xf0f0f0f0u,0xf020f0f0u),\nuvec4(0xf0f0f0f0u,0x23040190u,0x05100102u,0x05100500u),\nuvec4(0x05040704u,0x05040500u,0x04000520u,0x535843f8u),\nuvec4(0x000448f8u,0x0100f005u,0x01300406u,0xf0011406u),\nuvec4(0xf0f0f0f0u,0xf0f0f080u,0x0680f0f0u,0x15000433u),\nuvec4(0x44881430u,0xb80733e8u,0x0748f823u,0x100100f0u),\nuvec4(0x14013004u,0x01060302u,0xf0f0f0f0u,0xf0f060f0u),\nuvec4(0x70f0f0f0u,0x04021302u,0x04200510u,0x23e8f807u),\nuvec4(0xf81308f8u,0x17141748u,0x0120f034u,0xf0011304u),\nuvec4(0xf0f0f0f0u,0xf0f0f040u,0x0460f0f0u,0x25000413u),\nuvec4(0x48070410u,0x2388f817u,0x982318f8u,0xf8140504u),\nuvec4(0x00040708u,0x0601e015u,0xf0010203u,0xf0f0f0f0u),\nuvec4(0xf0f0f020u,0x0450f0f0u,0x04400113u,0x08f8f807u),\nuvec4(0xf8031813u,0x88131803u,0xf8041007u,0x05101428u),\nuvec4(0x020301e0u,0xf0f0f0f0u,0xf0f020f0u,0x40f0f0f0u),\nuvec4(0x05101304u,0xf8f80410u,0x13281328u,0x28130774u),\nuvec4(0x08032813u,0x07e8f813u,0xd0150004u,0xf0010302u),\nuvec4(0xf0f0f0f0u,0xf0f0f010u,0x0430f0f0u,0xf8400113u),\nuvec4(0x181328f8u,0x04031407u,0x15100510u,0x23385302u),\nuvec4(0x0718f8f8u,0x0301e005u,0xf0f0f002u,0xf010f0f0u),\nuvec4(0x70f0f0f0u,0x04320401u,0x13012001u,0x07340001u),\nuvec4(0x1318f8f8u,0x00150418u,0x35061304u,0x04064302u),\nuvec4(0xf8132807u,0x050448f8u,0x040302d0u,0xf0f0f0f0u),\nuvec4(0xf0f000f0u,0x0150f0f0u,0x01047302u,0x00011302u),\nuvec4(0x58f8f807u,0x01301533u,0x02061306u,0x00250213u),\nuvec4(0x07041005u,0xf803c813u,0x05000498u,0x060114b0u),\nuvec4(0xf0f01114u,0xf0a0f0f0u,0x40f0f0f0u,0x11021304u),\nuvec4(0x23021110u,0x04000102u,0x37781378u,0x13a80338u),\nuvec4(0x05400317u,0x02430509u,0x19051915u,0x03060005u),\nuvec4(0xf813c807u,0x54100788u,0x14116005u,0x04060206u),\nuvec4(0xf0f0f0f0u,0xf0f0f080u,0x130430f0u,0x02017004u),\nuvec4(0x78041004u,0x04075813u,0x18044005u,0x0713a803u),\nuvec4(0x40010304u,0x03061305u,0x0a030604u,0x03045509u),\nuvec4(0xb8070506u,0x1798f813u,0x00040768u,0x04017005u),\nuvec4(0xf0f00113u,0xf060f0f0u,0x10f0f0f0u,0xc0012304u),\nuvec4(0x58236804u,0x00054004u,0x13080405u,0x04181398u),\nuvec4(0x02400103u,0x05090503u,0x06030509u,0x01135509u),\nuvec4(0x03b80710u,0x38140718u,0xf8070407u,0x01a00488u),\nuvec4(0xf0040302u,0x50f0f0f0u,0xf0f0f0f0u,0x02230100u),\nuvec4(0x7804b001u,0x00075813u,0x07080704u,0x28070004u),\nuvec4(0x28138813u,0x40020304u,0x09150013u,0x35060305u),\nuvec4(0x04030119u,0x03b80720u,0x38200507u,0x14100407u),\nuvec4(0xb00768f8u,0xf0011301u,0x30f0f0f0u,0xf0f0f0f0u),\nuvec4(0x02041301u,0x05300113u,0x78140724u,0x0328f813u),\nuvec4(0x28138807u,0x13401304u,0x06030130u,0x00052005u),\nuvec4(0x20010302u,0x2013b807u,0x30075801u,0x48f80704u),\nuvec4(0x0302c007u,0xf0f00104u,0xf010f0f0u,0x01e0f0f0u),\nuvec4(0x04000413u,0x00040300u,0x03e80714u,0x17081418u),\nuvec4(0x980307b8u,0x40133813u,0x00010302u,0x03040001u),\nuvec4(0x03014001u,0xb8042004u,0x01030207u,0x05076820u),\nuvec4(0x17a80730u,0x05000478u,0x011301a0u,0xf0f0f0f0u),\nuvec4(0xf0f0f000u,0x300413e0u,0x13f80713u,0x20050708u),\nuvec4(0x08030807u,0x06047803u,0x13681403u,0x30010358u),\nuvec4(0x01020301u,0x40051310u,0x10010302u,0x98033804u),\nuvec4(0x01100103u,0x07347807u,0x140004a8u,0x10050068u),\nuvec4(0x50052005u,0x00010302u,0xf0f0f001u,0xf0f0f0d0u),\nuvec4(0x020302d0u,0x04000601u,0x08f81308u,0x30050413u),\nuvec4(0x07384307u,0x00131504u,0x48136807u,0x04400113u),\nuvec4(0x13070413u,0x03013005u,0x38110004u,0x04038823u),\nuvec4(0x04020310u,0x28f80328u,0x10050007u,0x14074807u),\nuvec4(0x08070807u,0x03027004u,0xf0f0f001u,0xf0f0f0e0u),\nuvec4(0x001301c0u,0x08070301u,0x0708f813u,0x30010613u),\nuvec4(0x13280302u,0x20010408u,0x05040301u,0x13481378u),\nuvec4(0x23025001u,0x30090a06u,0x10010302u,0xa8033804u),\nuvec4(0x04000403u,0x04000103u,0x04781318u,0x48131807u),\nuvec4(0x00050004u,0x0417c804u,0xf0011350u,0xf0d0f0f0u),\nuvec4(0x01b0f0f0u,0x05000413u,0xf8070833u,0x01130813u),\nuvec4(0x07020320u,0x04130718u,0x14030430u,0x13581368u),\nuvec4(0x03014001u,0x05160502u,0x01100509u,0x07200203u),\nuvec4(0x03081328u,0x00040388u,0x04200203u,0x04680318u),\nuvec4(0x68130710u,0x48040004u,0x04175853u,0x01130120u),\nuvec4(0xc0f0f0f0u,0xb0f0f0f0u,0x00020304u,0x38031805u),\nuvec4(0x03985307u,0x02030708u,0x01030110u,0x04001400u),\nuvec4(0x04300703u,0x13681403u,0x40011358u,0x15060301u),\nuvec4(0x10150403u,0x10010304u,0x18033804u,0x04038803u),\nuvec4(0x20020300u,0x58031804u,0x13041007u,0x63281778u),\nuvec4(0x04380358u,0x01132005u,0xb0f0f0f0u,0xa0f0f0f0u),\nuvec4(0x07101301u,0x13085348u,0x04081388u,0x00010302u),\nuvec4(0x20040301u,0x24030804u,0x01030410u,0x58136805u),\nuvec4(0x03025013u,0x03000901u,0x13101506u,0x13380410u),\nuvec4(0x04070318u,0x00040368u,0x00050013u,0x00130807u),\nuvec4(0x04170405u,0x04130110u,0x13b823a8u,0x01100448u),\nuvec4(0xf0f00203u,0xf0f0b0f0u,0x130190f0u,0x38070004u),\nuvec4(0x23280733u,0x04081388u,0x03101307u,0x18071004u),\nuvec4(0x04080703u,0x14030110u,0x48170368u,0x01300513u),\nuvec4(0x05000203u,0x05030704u,0x02030110u,0x38040100u),\nuvec4(0x14031813u,0x00040368u,0x00010304u,0x04031804u),\nuvec4(0x00011370u,0xd8238807u,0x20073813u,0xf0f00302u),\nuvec4(0xf0f0b0f0u,0x030690f0u,0x38040002u,0x18040723u),\nuvec4(0x78142307u,0x18040713u,0x02000403u,0x03020103u),\nuvec4(0x07080318u,0x03011005u,0x04135814u,0x40134800u),\nuvec4(0x10040301u,0x04030804u,0x01030110u,0x13380410u),\nuvec4(0x04000318u,0x10020368u,0x08070304u,0x60040713u),\nuvec4(0x10020301u,0x78137804u,0x38137803u,0x03011004u),\nuvec4(0xf0f0f002u,0xf0f0f0a0u,0x04011390u,0x07182338u),\nuvec4(0x10010433u,0x08136804u,0x02031807u,0x23020100u),\nuvec4(0x04080318u,0x03040011u,0x05135814u,0x13380700u),\nuvec4(0x01030240u,0x13080410u,0x01030410u,0x03380710u),\nuvec4(0x04011318u,0x20020368u,0x18130804u,0x03026004u),\nuvec4(0x58072001u,0x88137813u,0x10043813u,0xf0f00302u),\nuvec4(0xf0f0a0f0u,0x030480f0u,0x93280402u,0x04200102u),\nuvec4(0x13381318u,0x20011338u,0x03180307u,0x03013006u),\nuvec4(0x13580402u,0x38070005u,0x13400603u,0x01032820u),\nuvec4(0x20030200u,0x18033807u,0x18040113u,0x04032813u),\nuvec4(0x13080720u,0x13600418u,0x13580430u,0x28140728u),\nuvec4(0x38138813u,0x02030110u,0x90f0f0f0u,0x80f0f0f0u),\nuvec4(0x13380113u,0x04010428u,0x07043001u,0x03581308u),\nuvec4(0x10011348u,0x03181304u,0x07134004u,0x00051358u),\nuvec4(0x04033804u,0x03012005u,0x28071002u,0x03000203u),\nuvec4(0x38041002u,0x00131813u,0x18030804u,0x01130703u),\nuvec4(0x03080720u,0x04500428u,0x07300203u,0x03080358u),\nuvec4(0x28073504u,0x48170413u,0x10073813u,0xf0f00413u),\nuvec4(0xf0f080f0u,0x030470f0u,0x13280402u,0x05300428u),\nuvec4(0x23280400u,0x03580358u,0x13010002u,0x04031704u),\nuvec4(0x58071340u,0x04000513u,0x050a1328u,0x04030420u),\nuvec4(0x13380500u,0x10020300u,0x18133807u,0x18040013u),\nuvec4(0x30330807u,0x07030807u,0x13600708u,0x07051001u),\nuvec4(0x03071358u,0x05101501u,0x28142338u,0x00043833u),\nuvec4(0x04061304u,0x05e0f0f0u,0xf0f0f060u,0x02030470u),\nuvec4(0x07182328u,0x05041704u,0x13180704u,0x48071308u),\nuvec4(0x02035803u,0x04030400u,0x40040320u,0x13580713u),\nuvec4(0x13280710u,0x03022015u,0x48040001u,0x02030403u),\nuvec4(0x13380710u,0x06030708u,0x13280400u,0x04301308u),\nuvec4(0x05070813u,0x00130450u,0x58070005u,0x03010813u),\nuvec4(0x48074004u,0x08330213u,0x01004813u,0x03010403u),\nuvec4(0xf0f0f004u,0xf0f0f050u,0x38030270u,0x88031813u),\nuvec4(0x07032813u,0x03580348u,0x20130402u,0x40020304u),\nuvec4(0x03680713u,0x04080710u,0x20151308u,0x48041013u),\nuvec4(0x01000423u,0x08133807u,0x04000113u,0x20060358u),\nuvec4(0x08030405u,0x04137007u,0x13580410u,0x02030418u),\nuvec4(0x07580440u,0x18071005u,0x00044813u,0x03040014u),\nuvec4(0xf0f0f001u,0xf0f0f040u,0x13001140u,0x04181328u),\nuvec4(0x08236813u,0x48071307u,0x01335803u,0x13080410u),\nuvec4(0x07030240u,0x00050368u,0x03080718u,0x01101504u),\nuvec4(0x58050013u,0x01000423u,0x08030748u,0x48041013u),\nuvec4(0x07300a13u,0x01700803u,0x04050013u,0x07580738u),\nuvec4(0x04400203u,0x07034807u,0x07180110u,0x01104813u),\nuvec4(0x06030100u,0x40f0f0f0u,0x30f0f0f0u,0x04001301u),\nuvec4(0x08132807u,0x13010007u,0x05075318u,0x58030200u),\nuvec4(0x23480703u,0x18041001u,0x04300113u,0x01780703u),\nuvec4(0x04132804u,0x00010005u,0x00040304u,0x04136804u),\nuvec4(0x03074810u,0x05040308u,0x13480400u,0x07051005u),\nuvec4(0x70070308u,0x10010302u,0x58033807u,0x01301307u),\nuvec4(0x38070403u,0x08141803u,0x48130a07u,0x03023004u),\nuvec4(0x40f0f0f0u,0x20f0f0f0u,0x10041301u,0x18032807u),\nuvec4(0x53011500u,0x02200718u,0x48135803u,0x05000a13u),\nuvec4(0x03280400u,0x03043001u,0x28070488u,0x20090513u),\nuvec4(0x04000113u,0x00021368u,0x04235805u,0x48040005u),\nuvec4(0x18072013u,0x13700703u,0x13380710u,0x30020368u),\nuvec4(0x05010304u,0x07032807u,0x58131538u,0x04100507u),\nuvec4(0xf0f02103u,0xf0f010f0u,0x130110f0u,0x00050004u),\nuvec4(0x00041338u,0x48041015u,0x07000417u,0x48070308u),\nuvec4(0x13380413u,0x38041005u,0x04300403u,0x28048803u),\nuvec4(0x15060307u,0x10130110u,0x10236807u,0x14130748u),\nuvec4(0x03070403u,0x04020338u,0x03280500u,0x40010408u),\nuvec4(0x00040304u,0x68233805u,0x05200203u,0x04100307u),\nuvec4(0x07281318u,0x13000504u,0x01040768u,0x01140302u),\nuvec4(0xf0f00500u,0xf0f0f0f0u,0x04130100u,0x03580420u),\nuvec4(0x04254006u,0x04080400u,0x13080700u,0x00070348u),\nuvec4(0x07131807u,0x03481004u,0x13013002u,0x150413b8u),\nuvec4(0x04030410u,0x23780400u,0x03074810u,0x03040007u),\nuvec4(0x28030807u,0x00040813u,0x07032807u,0x01030260u),\nuvec4(0x23380700u,0x03180738u,0x13052002u,0x13071817u),\nuvec4(0x00050417u,0x58130005u,0x02070623u,0xf0f0f004u),\nuvec4(0xf0f0f030u,0x04030200u,0x68070410u,0x01030201u),\nuvec4(0x04180460u,0x13040500u,0x00070348u,0x07031804u),\nuvec4(0x07000708u,0x13401348u,0x050713a8u,0x03022009u),\nuvec4(0x88040004u,0x07000113u,0x02100758u,0x08132823u),\nuvec4(0x02033814u,0x04001360u,0x14283338u,0x30040318u),\nuvec4(0x07380307u,0x20350603u,0x07233813u,0x01300408u),\nuvec4(0xf0f00114u,0xf0f0f0e0u,0x00051301u,0x04077804u),\nuvec4(0x00011307u,0x28073005u,0x48131004u,0x08040513u),\nuvec4(0x58141813u,0x03044013u,0x150413a8u,0x01030220u),\nuvec4(0x04139800u,0x07580700u,0x13480410u,0x03480718u),\nuvec4(0x03015006u,0x38070004u,0x08130803u,0x13181407u),\nuvec4(0x13073004u,0x03070807u,0x18137002u,0x20044823u),\nuvec4(0x04061401u,0xf0d0f0f0u,0x0302f0f0u,0x88070002u),\nuvec4(0x13180704u,0x48043004u,0x03040005u,0x08141348u),\nuvec4(0x78071813u,0x01300103u,0x08138813u,0x00133015u),\nuvec4(0x01239804u,0x00075807u,0x78135804u,0x04500403u),\nuvec4(0x38040103u,0x07030813u,0x13281704u,0x07052004u),\nuvec4(0x04280718u,0x04883370u,0x04020120u,0xf0010706u),\nuvec4(0xf0f0b0f0u,0x011301e0u,0x38049804u,0x10050013u),\nuvec4(0x04000458u,0x03480703u,0xa8130814u,0x02400403u),\nuvec4(0x08038803u,0x30050004u,0x98070013u,0x14030203u),\nuvec4(0x07000758u,0x03881348u,0x03025004u,0x13280401u),\nuvec4(0x48140318u,0x07300113u,0x02700748u,0x00049823u),\nuvec4(0x03060005u,0x03040004u,0xa0f0f004u,0x04e0f0f0u),\nuvec4(0x07000203u,0x03481788u,0x58051004u,0x58131004u),\nuvec4(0x03080704u,0x400403b8u,0x15a80301u,0x00130130u),\nuvec4(0x031203a8u,0x8823c804u,0x13500403u,0x08133800u),\nuvec4(0x48040113u,0x06012013u,0x05073807u,0xa8042360u),\nuvec4(0x03022007u,0x04030120u,0xf090f0f0u,0x1305d0f0u),\nuvec4(0x68070504u,0x13481713u,0x10045820u,0x03880302u),\nuvec4(0x500403b8u,0x00048813u,0x13013005u,0x0603a804u),\nuvec4(0xa8070601u,0x98130803u,0x03500403u,0x13280402u),\nuvec4(0x07001318u,0x10041338u,0x13140304u,0x40150407u),\nuvec4(0x00041301u,0x0337b805u,0x01132005u,0xf080f0f0u),\nuvec4(0x1304d0f0u,0x08032804u,0x23180307u,0x04035807u),\nuvec4(0x05480710u,0x78130410u,0x0413a803u,0x78130440u),\nuvec4(0x13501507u,0x03079804u,0x98011006u,0x0403a833u),\nuvec4(0x04020350u,0x07180328u,0x48050403u,0x13010513u),\nuvec4(0x03040004u,0x04402502u,0x05100413u,0x040703f8u),\nuvec4(0x01130201u,0xf080f0f0u,0x0413d0f0u,0x03081328u),\nuvec4(0x03682328u,0x38041002u,0x68133004u,0x0413a813u),\nuvec4(0x14030130u,0x04700778u,0x07980703u,0x07200503u),\nuvec4(0x13a83378u,0x03014004u,0x13180702u,0x04001318u),\nuvec4(0x05061338u,0x07100413u,0x01600203u,0x78053013u),\nuvec4(0x06233843u,0xf0040304u,0xf0f080f0u,0x041301c0u),\nuvec4(0x08070328u,0x04332803u,0x20051348u,0x00070807u),\nuvec4(0x03042005u,0x03a80378u,0x01200508u,0x88040013u),\nuvec4(0x98137005u,0x20090603u,0xd8136807u,0x01400413u),\nuvec4(0x13280203u,0x00051308u,0x04133807u,0x07150113u),\nuvec4(0x50020308u,0x15301304u,0x03285348u,0x00050738u),\nuvec4(0xf0f00703u,0xf0f07005u,0x020304c0u,0x08132804u),\nuvec4(0x07131813u,0x13381403u,0x08012005u,0x13014007u),\nuvec4(0x07981358u,0x01200708u,0x07050013u,0x04700488u),\nuvec4(0x01039803u,0x48042005u,0x0703e823u,0x03044005u),\nuvec4(0x08033804u,0x04000403u,0x03062338u,0x08042004u),\nuvec4(0x13044013u,0x33180760u,0x03380328u,0x02050438u),\nuvec4(0x15f0f003u,0xc0f0f060u,0x03280713u,0x18230708u),\nuvec4(0x00130813u,0x07032804u,0x18052005u,0x00050004u),\nuvec4(0x03020005u,0x100438f8u,0x01020304u,0x53380704u),\nuvec4(0x02700408u,0x01077803u,0x07041015u,0x07f82328u),\nuvec4(0x04500703u,0x05680703u,0x13380700u,0x10040304u),\nuvec4(0x40132804u,0x04400113u,0x38331807u,0x38033803u),\nuvec4(0x03040007u,0x70f0f001u,0x05b0f0f0u,0x03280713u),\nuvec4(0x07000708u,0x13070338u,0x03280405u,0x04200507u),\nuvec4(0x05000718u,0x68030120u,0x0507a803u,0x0468b304u),\nuvec4(0x03076001u,0x06050758u,0x04010504u,0x17683318u),\nuvec4(0x50041388u,0x68070204u,0x13380400u,0x05000316u),\nuvec4(0x13280700u,0x04030230u,0x18070530u,0x38031823u),\nuvec4(0x28033803u,0x01032407u,0xf070f0f0u,0x1304b0f0u),\nuvec4(0x07331807u,0x03041348u,0x13180501u,0x00050007u),\nuvec4(0x00072804u,0x58b30214u,0x02041273u,0x400407e8u),\nuvec4(0x05047805u,0x0804150au,0x00048823u,0x07137807u),\nuvec4(0x07020460u,0x38040758u,0x04030123u,0x07000500u),\nuvec4(0x10011328u,0x10020302u,0x28040005u,0x38033813u),\nuvec4(0x28032813u,0x04080400u,0xf0060403u,0x101520f0u),\nuvec4(0x04b0f0f0u,0x18032813u,0x04135803u,0x18050203u),\nuvec4(0x05000413u,0x83080700u,0x0233f302u,0x00050001u),\nuvec4(0x07047805u,0x04580714u,0x07580430u,0x07040915u),\nuvec4(0x0004a813u,0x08038805u,0x04015015u,0x38075807u),\nuvec4(0x03000723u,0x38071001u,0x04000113u,0x15000203u),\nuvec4(0x13280400u,0x13380348u,0x07280328u,0x22030418u),\nuvec4(0x1005c0f0u,0xf0f00045u,0x070302b0u,0x13180328u),\nuvec4(0x13040358u,0x03080700u,0x02000408u,0x04060743u),\nuvec4(0x00150001u,0x38070415u,0x00079807u,0x48040015u),\nuvec4(0x30052407u,0x25000554u,0x04480700u,0xd8070400u),\nuvec4(0x04050007u,0x01041378u,0x03220614u,0xa8070004u),\nuvec4(0x01051803u,0x07000103u,0x04030748u,0x00070300u),\nuvec4(0x28070015u,0x18035813u,0x08030817u,0x48130807u),\nuvec4(0x01070307u,0xb0f00403u,0xf0f07005u,0x180213b0u),\nuvec4(0x03040713u,0x03020368u,0x03180502u,0x07230708u),\nuvec4(0x05100728u,0x04001520u,0x00040728u,0x04572405u),\nuvec4(0xf0341730u,0x14060520u,0x05071817u,0x0817c804u),\nuvec4(0x78040004u,0x00340263u,0x0004c807u,0x04000306u),\nuvec4(0x14030758u,0x05001507u,0x68132807u,0x05100403u),\nuvec4(0x10080307u,0x13580307u,0x04030400u,0xf030f0f0u),\nuvec4(0x1305a0f0u,0x02032804u,0x05137813u,0x02132804u),\nuvec4(0x05074804u,0x05803570u,0x05500500u,0x060470f0u),\nuvec4(0x07080430u,0x07880400u,0x07101704u,0x01881408u),\nuvec4(0x68079005u,0x06074807u,0x68070302u,0x03040307u),\nuvec4(0x04000504u,0x03181338u,0x04030738u,0x03060005u),\nuvec4(0x01000418u,0x00135803u,0xf0040301u,0xf0f030f0u),\nuvec4(0x041305a0u,0x07021728u,0x04011378u,0x00042308u),\nuvec4(0x04073807u,0xf0f0f005u,0x00040130u,0x07300204u),\nuvec4(0x27281418u,0x07040024u,0x07281708u,0x90150478u),\nuvec4(0x18145807u,0x33120733u,0x10072338u,0x38033807u),\nuvec4(0x07042803u,0x04050103u,0x04053803u,0x06135803u),\nuvec4(0xf0030200u,0xf0f030f0u,0x041305a0u,0x07100428u),\nuvec4(0x00077368u,0xf0142705u,0x1460f0f0u,0x04401600u),\nuvec4(0x04071817u,0x48070570u,0x00049807u,0x10052005u),\nuvec4(0x23880005u,0x00050407u,0x23780704u,0x38040004u),\nuvec4(0x03072813u,0x00050348u,0x28070607u,0x04030700u),\nuvec4(0x03070348u,0xf0040311u,0xf0f020f0u,0x071305a0u),\nuvec4(0x04000428u,0x03075348u,0x00050728u,0xf0f0f001u),\nuvec4(0x000107a0u,0x01700403u,0x1704a014u,0x07040514u),\nuvec4(0x07381708u,0x07140560u,0x04181378u,0x07000500u),\nuvec4(0x07180758u,0x04010304u,0x03381338u,0x00133807u),\nuvec4(0x04010301u,0x03040718u,0x38070006u,0x01170803u),\nuvec4(0xf0f00403u,0xb0f0f020u,0x00043813u,0x88430807u),\nuvec4(0xf0f00504u,0x800520f0u,0x03110301u,0x15a0f001u),\nuvec4(0x04000500u,0x58541738u,0x08040007u,0x00043813u),\nuvec4(0x07240005u,0x07180728u,0x07040700u,0x03480338u),\nuvec4(0x00070348u,0x28150301u,0x00050603u,0x18033804u),\nuvec4(0x14001703u,0xf000f0f0u,0x0306b0f0u,0x23071438u),\nuvec4(0xf0050498u,0x0130f0f0u,0x03018005u,0xf0030401u),\nuvec4(0x01001490u,0x05000510u,0x07c80704u,0x28131714u),\nuvec4(0x00152004u,0x07281734u,0x03381405u,0x03480358u),\nuvec4(0x03040004u,0x08070005u,0x48150413u,0x04131807u),\nuvec4(0x06070400u,0xf0f0f0f0u,0x070304b0u,0x07230728u),\nuvec4(0xf0050488u,0x0650f0f0u,0x07048004u,0x00030400u),\nuvec4(0x0460f001u,0x05700107u,0x05049814u,0x07131704u),\nuvec4(0x04450024u,0x04000438u,0x00041708u,0x48033804u),\nuvec4(0x28070403u,0x04050413u,0x07040007u,0x04080308u),\nuvec4(0x38070500u,0x04180407u,0xf0070630u,0xa0f0f0e0u),\nuvec4(0x18130005u,0x07281423u,0xf0050438u,0x0470f0f0u),\nuvec4(0x07048006u,0x01030400u,0x50f00400u,0x14010016u),\nuvec4(0x07381470u,0x00040704u,0x01130415u,0x38041570u),\nuvec4(0x25100407u,0x03280400u,0x38041348u,0x00050703u),\nuvec4(0x18050607u,0x05040713u,0x04380700u,0x40051800u),\nuvec4(0xf0010306u,0xa0f0f0c0u,0x03060005u,0x04071308u),\nuvec4(0x24073807u,0xf0150915u,0x0450f0f0u,0x30142007u),\nuvec4(0x04000207u,0xf0140103u,0x01070140u,0x01030400u),\nuvec4(0x50240590u,0xc0060304u,0x14073807u,0x04001500u),\nuvec4(0x07380328u,0x38040103u,0x05000703u,0x08070403u),\nuvec4(0x00040817u,0x38030704u,0x08070004u,0x07035004u),\nuvec4(0x600540f0u,0x05a0f0f0u,0x18230400u,0x05043803u),\nuvec4(0x15190510u,0x60f0f0f0u,0x14200704u,0x00020730u),\nuvec4(0x14010304u,0x07a00180u,0x03040004u,0x0510f004u),\nuvec4(0x02030400u,0x173405d0u,0x00150004u,0x07040704u),\nuvec4(0x14030738u,0x00041338u,0x18040304u,0x04051803u),\nuvec4(0x04480603u,0x07080400u,0x05100500u,0xc0f01700u),\nuvec4(0x01b0f0f0u,0x13080713u,0x05103418u,0xf0f00509u),\nuvec4(0x070490f0u,0x03301420u,0x03040006u,0x70040704u),\nuvec4(0x04900604u,0x06040107u,0x05f00103u,0x13010001u),\nuvec4(0x053005e0u,0x07052014u,0x07040714u,0x07030408u),\nuvec4(0x03380700u,0x07000408u,0x13080706u,0x04030718u),\nuvec4(0x00044805u,0x05000417u,0x06100504u,0x1540f007u),\nuvec4(0x70f0f050u,0x13011001u,0x04281318u,0x25000407u),\nuvec4(0x60f0f0f0u,0x07043005u,0x07041001u,0x07030120u),\nuvec4(0x01030400u,0x04600407u,0x14100103u,0x04070140u),\nuvec4(0x06030400u,0x040100f0u,0x01030700u,0x083560f0u),\nuvec4(0x07080407u,0x04001714u,0x07080338u,0x01070600u),\nuvec4(0x18130804u,0x04000403u,0x37081448u,0x04000418u),\nuvec4(0x20f00103u,0xf0f04035u,0x07130490u,0x04380308u),\nuvec4(0x25000407u,0x60f0f0f0u,0x03043014u,0x01140004u),\nuvec4(0x07030120u,0x04030400u,0x01500407u,0x01000703u),\nuvec4(0x40040704u,0x04000307u,0xf0010302u,0x03040015u),\nuvec4(0x0590f004u,0x08140500u,0x10170004u,0x08132807u),\nuvec4(0x01030407u,0x03070005u,0x15040318u,0x1803b804u),\nuvec4(0x04030104u,0x404510f0u,0x0480f0f0u,0x03080713u),\nuvec4(0x06030748u,0xf0f0f035u,0x05101460u,0x04030600u),\nuvec4(0x20010410u,0x00060301u,0x03040306u,0x03015004u),\nuvec4(0x04031401u,0x03001420u,0x03070104u,0x0105f006u),\nuvec4(0x07030100u,0x1405b0f0u,0x04000407u,0x07050007u),\nuvec4(0x04181328u,0x05000603u,0x27030800u,0x04000500u),\nuvec4(0x03580358u,0x03010708u,0x1520f004u,0x70f0f060u),\nuvec4(0x04011304u,0x03073813u,0xf0f00504u,0x060110f0u),\nuvec4(0x30040704u,0x01040014u,0x14030600u,0x20070600u),\nuvec4(0x00040301u,0x03040304u,0x01175004u,0x01030704u),\nuvec4(0x07000500u,0x04000314u,0xe0010703u,0x00050405u),\nuvec4(0xf0010307u,0x040704c0u,0x03380445u,0x03040718u),\nuvec4(0x07080725u,0x05070406u,0x03280710u,0x04081388u),\nuvec4(0x30f00407u,0xf0f06005u,0x14130460u,0x03073813u),\nuvec4(0xf0153004u,0x040100f0u,0x27018001u,0x14200413u),\nuvec4(0x04100100u,0x00040703u,0x03012017u,0x03040004u),\nuvec4(0x40040304u,0x07140301u,0x24000703u,0x06070103u),\nuvec4(0xe0041301u,0x00010405u,0xf0060301u,0x001500f0u),\nuvec4(0x58070005u,0x15170007u,0x06171807u,0xe8040007u),\nuvec4(0x04031813u,0x10f00500u,0x20050025u,0x0450f0f0u),\nuvec4(0x00010703u,0x27180307u,0x010a0403u,0x04260440u),\nuvec4(0x0490f001u,0x04501427u,0x00110703u,0x04070306u),\nuvec4(0x14000417u,0x07130400u,0x20040701u,0x00040301u),\nuvec4(0x03040304u,0x03044004u,0x03040704u,0x04070004u),\nuvec4(0x01031403u,0x20041304u,0x14800504u,0x04032001u),\nuvec4(0x1430f0f0u,0x07050468u,0x28040004u,0x17060307u),\nuvec4(0x13980348u,0xf0040318u,0x25100530u,0x40f0f010u),\nuvec4(0x01070304u,0x28030700u,0x05040314u,0x17043001u),\nuvec4(0xf0051114u,0x01040180u,0x06130400u,0x00040104u),\nuvec4(0x00011304u,0x04010401u,0x00042302u,0x27040014u),\nuvec4(0x01201701u,0x04000603u,0x04030403u,0x04030440u),\nuvec4(0x11030207u,0x17010317u,0x20012700u,0x16800104u),\nuvec4(0x04030120u,0x800590f0u,0x04057804u,0x07000103u),\nuvec4(0x04030728u,0x98035803u,0x04032803u,0x003560f0u),\nuvec4(0x0130f0f0u,0x04000113u,0x07180703u,0x20240304u),\nuvec4(0xf0041704u,0x331130f0u,0x01040702u,0x04030110u),\nuvec4(0x17010410u,0x00070400u,0x03060706u,0x01201701u),\nuvec4(0x03040017u,0x40040304u,0x00033706u,0x00071304u),\nuvec4(0x07131403u,0x01071410u,0x20040680u,0xf0010304u),\nuvec4(0x04801490u,0x17000458u,0x07380400u,0x03581703u),\nuvec4(0x05042738u,0x03180307u,0x20f00507u,0x10251015u),\nuvec4(0x0730f0f0u,0x27100403u,0x03010708u,0x10060104u),\nuvec4(0x04030701u,0xf00104f0u,0x01000530u,0x04030714u),\nuvec4(0x01100500u,0x06300403u,0x07040007u,0x03041700u),\nuvec4(0x00070601u,0x06071005u,0x04030400u,0x03400603u),\nuvec4(0x07020704u,0x03170006u,0x07010314u,0x00040704u),\nuvec4(0x80071401u,0x05100604u,0xb0f01700u,0x70040706u),\nuvec4(0x04180701u,0x07000500u,0x07480504u,0x08037803u),\nuvec4(0x10150407u,0x18030415u,0x05300403u,0xf03055d0u),\nuvec4(0x030420f0u,0x03011004u,0x01070807u,0x07010603u),\nuvec4(0x03040004u,0x05000106u,0xf00601d0u,0x01301540u),\nuvec4(0x01001110u,0x04300403u,0x00061403u,0x07040706u),\nuvec4(0x17301701u,0x04030400u,0x04300603u,0x02030403u),\nuvec4(0x07031403u,0x04170103u,0x01030407u,0x04070100u),\nuvec4(0x04017006u,0x03000520u,0x07c0f004u,0x17800403u),\nuvec4(0x05010735u,0x03180358u,0x00040348u,0x15040725u),\nuvec4(0x07180307u,0x70059005u,0x10050015u,0xf0f00025u),\nuvec4(0x07030110u,0x08030120u,0x03070007u,0x00040700u),\nuvec4(0x00040304u,0x0704f005u,0x040110f0u,0x07101550u),\nuvec4(0x03010004u,0x07214006u,0x04030400u,0x03040107u),\nuvec4(0x03072001u,0x04030400u,0x06173017u,0x01030703u),\nuvec4(0x17030137u,0x04101704u,0x70070607u,0x15100405u),\nuvec4(0xf0010304u,0x01070630u,0x04030760u,0x35101550u),\nuvec4(0x48071507u,0x48031803u,0x00150403u,0x15070804u),\nuvec4(0x07080307u,0xf0040704u,0xf0100580u,0x030710f0u),\nuvec4(0x07033004u,0x14030105u,0x03010007u,0x40050004u),\nuvec4(0x0704a005u,0x000604e0u,0x06170307u,0x03143004u),\nuvec4(0x03010004u,0x07056004u,0x04030104u,0x04031407u),\nuvec4(0x01030720u,0x17040304u,0x03045730u,0x01020304u),\nuvec4(0x03010713u,0x04071004u,0x10018017u,0xf0070615u),\nuvec4(0x03070440u,0x13015006u,0x140625a0u,0x03180358u),\nuvec4(0x00040348u,0x18040005u,0x08070314u,0xf0170403u),\nuvec4(0x05000550u,0xf0f01500u,0x06030400u,0x07001740u),\nuvec4(0x01070103u,0x05001700u,0x070410f0u,0x071301d0u),\nuvec4(0x17330703u,0x06130714u,0x04030100u,0x11070160u),\nuvec4(0x04170403u,0x04200403u,0x03040103u,0x01201701u),\nuvec4(0x03061703u,0x03041702u,0x07011314u,0x01050003u),\nuvec4(0x04070107u,0x09101570u,0xe0040705u,0x03046005u),\nuvec4(0x04400407u,0x90010703u,0x04060005u,0x07035807u),\nuvec4(0x03480308u,0x1804250au,0x07030704u,0x04050708u),\nuvec4(0x30f00103u,0x00f0f065u,0x06075017u,0x07140301u),\nuvec4(0x01030400u,0x10f00500u,0x04a00117u,0x03171306u),\nuvec4(0x11040604u,0x03100763u,0x30140007u,0x01000701u),\nuvec4(0x06070403u,0x20040700u,0x03140304u,0x01030700u),\nuvec4(0x17030410u,0x03040304u,0x00030704u,0x01070307u),\nuvec4(0x06100403u,0x04030007u,0x01001540u,0x05090510u),\nuvec4(0x10f00407u,0x20010405u,0x40041301u,0xb0040307u),\nuvec4(0x03680706u,0x03173814u,0x04180435u,0x04081703u),\nuvec4(0x04070400u,0xf05540f0u,0x040304f0u,0x01030440u),\nuvec4(0x07010304u,0x04030004u,0x20f00500u,0x90010304u),\nuvec4(0x01073301u,0x14300107u,0x07042307u,0x07030001u),\nuvec4(0x01301400u,0x04031107u,0x04030017u,0x14030420u),\nuvec4(0x03070003u,0x03071001u,0x07010327u,0x00060701u),\nuvec4(0x03020413u,0x07000501u,0x04030004u,0x05300540u),\nuvec4(0x01071509u,0x073400f0u,0x13011004u,0x03043001u),\nuvec4(0x7804b007u,0x28170407u,0x08142527u,0x15071837u),\nuvec4(0x15200407u,0xf00045f0u,0x070301e0u,0x07030140u),\nuvec4(0x07041700u,0x01030400u,0x0630f005u,0x04070403u),\nuvec4(0x01000130u,0x00070316u,0x01800406u,0x01030704u),\nuvec4(0x07000607u,0x04060103u,0x00050400u,0x03140701u),\nuvec4(0x01070604u,0x03042017u,0x01030401u,0x00010306u),\nuvec4(0x04170301u,0x04070417u,0x13040107u,0x10040304u),\nuvec4(0x04000704u,0x05000103u,0x25300520u,0x10f00604u),\nuvec4(0x07042005u,0x03041004u,0xb0134007u,0x04077804u),\nuvec4(0x06033817u,0x14180410u,0x14380703u,0x05000407u),\nuvec4(0x001540f0u,0x04e0f005u,0x17400403u,0x07060310u),\nuvec4(0xf0170006u,0x04030450u,0x20010307u,0x06231706u),\nuvec4(0x000401d0u,0x03040017u,0x06011401u,0x07010001u),\nuvec4(0x01040314u,0x03070407u,0x14030120u,0x07060103u),\nuvec4(0x04030410u,0x04070407u,0x00061701u,0x04070307u),\nuvec4(0x00050103u,0x17000607u,0x05801500u,0x60f01500u),\nuvec4(0x10040704u,0x30040307u,0xb0040307u,0x06076807u),\nuvec4(0x03172807u,0x07180714u,0x48030700u,0x00141604u),\nuvec4(0xa0050005u,0x10154015u,0x4017e0f0u,0x00040301u),\nuvec4(0x07040301u,0x04030104u,0x030450f0u,0x07030104u),\nuvec4(0x04070110u,0x07010406u,0x0400f004u,0x03010007u),\nuvec4(0x06000714u,0x01171004u,0x04031403u,0x20010307u),\nuvec4(0x03010407u,0x01030601u,0x01030400u,0x01030207u),\nuvec4(0x00060700u,0x10370301u,0x01050304u,0x05000403u),\nuvec4(0xf0f00540u,0x00040306u,0x30070304u,0xb0060304u),\nuvec4(0x38176805u,0x05060307u,0x06000438u,0x00044807u),\nuvec4(0x06070405u,0x35700530u,0xf0101530u,0x040304d0u),\nuvec4(0x01030440u,0x04030400u,0x03040007u,0x0450f004u),\nuvec4(0x07000603u,0x01000103u,0x50f00107u,0x00040304u),\nuvec4(0x00140207u,0x00040704u,0x07010704u,0x04030104u),\nuvec4(0x00173017u,0x03060407u,0x07040001u,0x14002704u),\nuvec4(0x03040001u,0x04070607u,0x04001710u,0xf0f00103u),\nuvec4(0x07030170u,0x05130100u,0x06030420u,0x176804c0u),\nuvec4(0x05041328u,0x04180708u,0x07180415u,0x25040704u),\nuvec4(0x00040700u,0x80050005u,0x10154015u,0x0307d0f0u),\nuvec4(0x10174001u,0x03040037u,0x0450f001u,0x06000703u),\nuvec4(0x04000403u,0x60f00107u,0x04000607u,0x01000417u),\nuvec4(0x04000407u,0x00170007u,0x30170607u,0x07010704u),\nuvec4(0x07101701u,0x17040703u,0x10010400u,0x16070307u),\nuvec4(0x04030410u,0xf0070301u,0x030690f0u,0x03070004u),\nuvec4(0x03042004u,0x1804d007u,0x01070817u,0x07032804u),\nuvec4(0x28030710u,0x00040725u,0x25040705u,0x10070400u),\nuvec4(0x00057005u,0x10155005u,0x0301c0f0u,0x10175007u),\nuvec4(0x17000427u,0x130160f0u,0x04030400u,0x01070400u),\nuvec4(0x070460f0u,0x00041711u,0x00060701u,0x17010704u),\nuvec4(0x20013700u,0x06040704u,0x01001701u,0x04070427u),\nuvec4(0x04370430u,0x04001710u,0xf0f00103u,0x06030490u),\nuvec4(0x06030600u,0x07030120u,0x041724e0u,0x03180405u),\nuvec4(0x18072507u,0x04150407u,0x04000507u,0x15140708u),\nuvec4(0x0005070au,0x70157005u,0xc0f01005u,0x50040304u),\nuvec4(0x00010304u,0x04030203u,0x60f01700u,0x03111304u),\nuvec4(0x03040007u,0x1770f001u,0x01170600u,0x01001700u),\nuvec4(0x00170107u,0x01302704u,0x17011407u,0x04030400u),\nuvec4(0x06400417u,0x06070607u,0x01070410u,0xf0f01700u),\nuvec4(0x070304a0u,0x07030600u,0x07030120u,0x040005e0u),\nuvec4(0x14000407u,0x04030807u,0x05171500u,0x07342500u),\nuvec4(0xb0052748u,0xc0f09005u,0x01600307u,0x17030117u),\nuvec4(0x03070001u,0x130160f0u,0x01030711u,0xf0010704u),\nuvec4(0x04070170u,0x04070401u,0x11030700u,0x00170407u),\nuvec4(0x07402701u,0x04030114u,0x04030400u,0x01301407u),\nuvec4(0x01001427u,0x04000703u,0xf0f00403u,0x060306a0u),\nuvec4(0x07030400u,0x01130120u,0x070605e0u,0x07140500u),\nuvec4(0x15000403u,0x00040804u,0x07982425u,0x9015a00au),\nuvec4(0x0703c0f0u,0x37030170u,0x03060001u,0x0760f001u),\nuvec4(0x04000403u,0x07010403u,0x070190f0u,0x06070104u),\nuvec4(0x04030400u,0x04060700u,0x07000107u,0x14400703u),\nuvec4(0x00040311u,0x07040304u,0x24070450u,0x01030410u),\nuvec4(0xf0f01700u,0x040307b0u,0x07030100u,0x07030120u),\nuvec4(0x000604f0u,0x03180405u,0x00090507u,0x04070804u),\nuvec4(0x07a81735u,0x30059015u,0xb0f05005u,0x80040304u),\nuvec4(0x17030701u,0x03040001u,0x0150f004u,0x00040307u),\nuvec4(0x01040304u,0x04a0f007u,0x00170107u,0x00040304u),\nuvec4(0x05010724u,0x14300127u,0x04030100u,0x07041700u),\nuvec4(0x04030750u,0x03011005u,0x03040006u,0xb0f0f004u),\nuvec4(0x00040307u,0x04201705u,0x00f00703u,0x03180425u),\nuvec4(0x07182507u,0x0400150au,0x050007c8u,0x051005a0u),\nuvec4(0x06b0f060u,0x05700103u,0x17040100u,0x07030110u),\nuvec4(0x030760f0u,0x03040006u,0xf0040007u,0x000704d0u),\nuvec4(0x14001701u,0x00010706u,0x01070406u,0x01070430u),\nuvec4(0x00010304u,0x40070417u,0x04060704u,0x01001720u),\nuvec4(0xc0f0f017u,0x00040307u,0x20070304u,0xf0040304u),\nuvec4(0x04001500u,0x15040718u,0x25071804u,0x1507d804u),\nuvec4(0xf09005a0u,0x600117b0u,0x20171025u,0xf0010307u),\nuvec4(0x07030450u,0x04030100u,0xd0f00100u,0x00010705u),\nuvec4(0x01040304u,0x04070407u,0x01402400u,0x07040104u),\nuvec4(0x40340001u,0x04101417u,0x04000403u,0xf0f00107u),\nuvec4(0x010307c0u,0x06030400u,0x06000500u,0x01300103u),\nuvec4(0x15a00406u,0x15070817u,0x07180400u,0x03381405u),\nuvec4(0xf0050798u,0x17b0f060u,0x15190560u,0x04201700u),\nuvec4(0x50f00703u,0x00060304u,0xf0040301u,0x040700f0u),\nuvec4(0x04070400u,0x07040600u,0x07040001u,0x06014004u),\nuvec4(0x07101701u,0x07014014u,0x00172014u,0xf0040704u),\nuvec4(0x0706d0f0u,0x03070001u,0x17011004u,0x07030640u),\nuvec4(0x080605a0u,0x07250714u,0xf8040318u,0x50150407u),\nuvec4(0xa0f0d015u,0x60070301u,0x30170045u,0xf0010307u),\nuvec4(0x07030740u,0x07030100u,0x0600f0f0u,0x17010004u),\nuvec4(0x07060400u,0x04010004u,0x07010460u,0x07010004u),\nuvec4(0x01001660u,0x00011710u,0xd0f0f017u,0x01001701u),\nuvec4(0x04100117u,0x0a400703u,0x4405a004u,0x28041507u),\nuvec4(0x04178817u,0x15060827u,0x25700570u,0xa0f00510u),\nuvec4(0x70040304u,0x00050015u,0x03043017u,0x0640f007u),\nuvec4(0x01000703u,0xf0f00407u,0x01001400u,0x14010706u),\nuvec4(0x04100406u,0x01071460u,0x14601400u,0x04080420u),\nuvec4(0x01070400u,0x04d0f0f0u,0x07000703u,0x06200603u),\nuvec4(0x20f00403u,0x04050415u,0x38071507u,0x05047807u),\nuvec4(0x14070507u,0x30150408u,0xf0659015u,0x040304a0u),\nuvec4(0x05001570u,0x07401700u,0x30f00403u,0x07101701u),\nuvec4(0x00f0f004u,0x01100401u,0x90340107u,0x01101701u),\nuvec4(0x200a6005u,0x01001701u,0xf0f00407u,0x040304e0u),\nuvec4(0x04030700u,0xf0170110u,0x04001540u,0x48040007u),\nuvec4(0x05472807u,0x17050724u,0x20054025u,0x10153015u),\nuvec4(0xa0f00025u,0x80010304u,0x40170025u,0x04030701u),\nuvec4(0x030730f0u,0x04070004u,0x0905f0f0u,0x0710050au),\nuvec4(0xa0240006u,0x01900407u,0x01001730u,0xf0f00607u),\nuvec4(0x030701e0u,0x00060714u,0x03040005u,0x0550f004u),\nuvec4(0x05070600u,0x170504a8u,0x07040704u,0x04080506u),\nuvec4(0x10153025u,0x10352015u,0x07a0f035u,0x25800103u),\nuvec4(0x01501700u,0xf0040307u,0x07030420u,0xf0040600u),\nuvec4(0x060b05c0u,0x1b060b0cu,0x0004060cu,0x04900514u),\nuvec4(0x05900107u,0x00041720u,0xf0f00607u,0x060304f0u),\nuvec4(0x17301700u,0x0550f005u,0x04070600u,0x06000498u),\nuvec4(0x07180407u,0x25170506u,0x05100550u,0x25001550u),\nuvec4(0xa0f00500u,0x10159017u,0x50010706u,0x04030701u),\nuvec4(0x170110f0u,0xa0f01400u,0x161b0c09u,0x0c0b060du),\nuvec4(0x092c061bu,0x1770050au,0x0a1701c0u,0xf0f01100u),\nuvec4(0x060701e0u,0x07040004u,0x00050001u,0xf0040304u),\nuvec4(0x04000560u,0x0605a807u,0x18050007u,0x08070007u),\nuvec4(0x00f02506u,0xf0150035u,0x05a017a0u,0x03040500u),\nuvec4(0x07016004u,0x10f00408u,0x01070304u,0x5b0990f0u),\nuvec4(0x1c0b0c17u,0x1b0d060bu,0x160b1706u,0x0115090cu),\nuvec4(0x15900407u,0x0b0d170au,0xf0f0f00du,0x0a10041au),\nuvec4(0x04200406u,0x70f00703u,0x78070415u,0x07140804u),\nuvec4(0x04181504u,0x25070805u,0x154005c0u,0xa0f00520u),\nuvec4(0x7017e017u,0x04080701u,0x070410f0u,0x0d70f006u),\nuvec4(0x371e161bu,0x0d060706u,0x4e07060bu,0x0b061e07u),\nuvec4(0x0b061716u,0x1c0b0d0cu,0x0c4b061bu,0xf0050c2bu),\nuvec4(0x3005d0f0u,0x04200104u,0x80f00117u,0x07040005u),\nuvec4(0x07050758u,0x15070604u,0x07060024u,0x1065e035u),\nuvec4(0x06a0f005u,0x17d00107u,0x17600510u,0x0410f001u),\nuvec4(0x40f00403u,0x060b0c05u,0x2f0e17beu,0x1e07280eu),\nuvec4(0x26070e17u,0x0637460bu,0x1c160b0du,0xf0f00c1bu),\nuvec4(0x001500f0u,0x17040005u,0x0015a0f0u,0x07480704u),\nuvec4(0x04260704u,0x05040807u,0x05040804u,0x00f00509u),\nuvec4(0x20051015u,0x06a0f005u,0x04d00403u,0x05000408u),\nuvec4(0x06500500u,0x0720f007u,0x0530f004u,0x0e07161bu),\nuvec4(0x0e8f0eafu,0x163e0718u,0x4b16b70eu,0xf0f0090cu),\nuvec4(0x040005f0u,0x05300408u,0x002570f0u,0x05065807u),\nuvec4(0x04180417u,0x35040807u,0x15700570u,0xf0002520u),\nuvec4(0x010706a0u,0x050017e0u,0xf0f01480u,0x47060960u),\nuvec4(0x0e9fff1eu,0x160f1e0fu,0x062e070eu,0x06070e07u),\nuvec4(0x1c2b060bu,0xf0150d3bu,0x0704b0f0u,0x05b0f004u),\nuvec4(0x07043500u,0x27000448u,0x35000738u,0x15500500u),\nuvec4(0x25301560u,0xf017a0f0u,0x00040306u,0xf0058005u),\nuvec4(0x0c0540f0u,0x060b062bu,0x3edfff0eu,0x1e1f1e3fu),\nuvec4(0x27160e16u,0x0c4b061eu,0x05600509u,0x1701d0f0u),\nuvec4(0x65e0f004u,0x00042807u,0x04281407u,0x00f02405u),\nuvec4(0x00551005u,0x17a0f005u,0x070301f0u,0x05100500u),\nuvec4(0x0540f0f0u,0x0b160d40u,0x1e061b0du,0x9f2edfffu),\nuvec4(0x07060f2eu,0x170e170eu,0x0c0b0d16u,0x15092c1bu),\nuvec4(0x0701f0f0u,0xf0f00106u,0x18045500u,0x09071507u),\nuvec4(0x05071804u,0x30013706u,0x10155035u,0x0190f075u),\nuvec4(0x17f00117u,0x05100501u,0x3015f0f0u,0x07062405u),\nuvec4(0x07260b06u,0xdfffff0eu,0x0e06074eu,0x0b371607u),\nuvec4(0x0b0c1b3cu,0xf005090cu,0x04000590u,0xf0f00607u),\nuvec4(0x18044520u,0x07041507u,0x00451415u,0x05000607u),\nuvec4(0x05000520u,0x75202530u,0x080490f0u,0x04f00107u),\nuvec4(0x05000408u,0x0100f0f0u,0x37340105u,0xffffff7eu),\nuvec4(0x27167e2fu,0x1b0c1b46u,0xf005090cu,0x04080470u),\nuvec4(0xd0f00540u,0x18070035u,0x07061504u,0x75001795u),\nuvec4(0x85201520u,0x170690f0u,0x0700f004u,0x70f00403u),\nuvec4(0xb7040715u,0xffffff4eu,0x5e1f2ebfu,0x06271827u),\nuvec4(0xf0090c4bu,0x04070440u,0xf0f00500u,0x18072530u),\nuvec4(0x14072507u,0x17043500u,0x00060708u,0x30350015u),\nuvec4(0xf0a50015u,0xf0042790u,0xf0170100u,0x08070970u),\nuvec4(0x160a0607u,0x060b0617u,0x0f0e1617u,0xffffff2eu),\nuvec4(0x1e0f3eefu,0x0e071617u,0x0b1c1b37u,0x10f0091cu),\nuvec4(0x00040701u,0x30f0f005u,0x07280415u,0x16000504u),\nuvec4(0x25040705u,0x05073807u,0x15001500u,0x80f0f530u),\nuvec4(0x07140304u,0x070610f0u,0x0460f001u,0x1c0b0608u),\nuvec4(0x0d5b161bu,0xffff2e06u,0x3e6fffffu,0x072b0607u),\nuvec4(0x0b0d0608u,0x090c0b2cu,0x050017f0u,0x0540f0f0u),\nuvec4(0x04280400u,0x04050725u,0x00050408u,0x05044804u),\nuvec4(0xf5104500u,0x1780f015u,0xf0070500u,0xf0170110u),\nuvec4(0x0b170150u,0x2e160706u,0x070e0736u,0xffffff1eu),\nuvec4(0x070ecfffu,0x17061b16u,0x1b1c1b06u,0x05a0050cu),\nuvec4(0x00f01700u,0x1560f005u,0x05063524u,0x05040704u),\nuvec4(0x10055807u,0x00250015u,0x70f015f5u,0x10070304u),\nuvec4(0x05f00106u,0x04030600u,0x080740f0u,0x2e0f0e06u),\nuvec4(0xffff6e0fu,0x2fffffffu,0x05bb161eu,0x010704a0u),\nuvec4(0x2580f0f0u,0x05044500u,0x07581704u,0x40050004u),\nuvec4(0xf0e51035u,0x04080770u,0x10f01410u,0x30f01705u),\nuvec4(0x070e2704u,0x1f5e0706u,0xffffff0eu,0x2e5fffffu),\nuvec4(0x1b1c4b16u,0x04079009u,0x85a0f0f0u,0x07680704u),\nuvec4(0x15000504u,0x35000510u,0x60f0e510u,0x30070801u),\nuvec4(0x0420f005u,0x20f00408u,0x07060a17u,0xff7e0716u),\nuvec4(0xffffffffu,0x0e1f1e6fu,0x0b2c3b16u,0x04078009u),\nuvec4(0x6015e0f0u,0x04752005u,0x10150768u,0x00551055u),\nuvec4(0x0760f0b5u,0x70f00108u,0xf0070801u,0x07030410u),\nuvec4(0x2607060cu,0xffff2e07u,0xafffffffu,0x263e0f0eu),\nuvec4(0x0c0b2c2bu,0xf0070460u,0x65a015f0u,0x04075804u),\nuvec4(0x30150025u,0x20151025u,0x0150f0b5u,0x90f00708u),\nuvec4(0xf0040807u,0x04080600u,0x3e260b0cu,0xffffffffu),\nuvec4(0x064edfffu,0x0c1b0c3bu,0x07500c0bu,0x00f0f006u),\nuvec4(0x0055a005u,0x45074807u,0xf5001580u,0x0650f005u),\nuvec4(0x90f00107u,0xf0040304u,0x2b001700u,0xffff4e06u),\nuvec4(0xffffffffu,0x0d1b072fu,0x0c2b0c0bu,0x04400c0bu),\nuvec4(0x00f0f007u,0x0765a005u,0x09050748u,0x10151015u),\nuvec4(0x00550015u,0x0140f0d5u,0x04054017u,0x04e01427u),\nuvec4(0x04f00403u,0x061b0017u,0xffffff3eu,0x5fffffffu),\nuvec4(0x1c4b1607u,0x05100c0bu,0xf0040600u,0x0005a0f0u),\nuvec4(0x07480765u,0x35102500u,0xe5006500u,0x080440f0u),\nuvec4(0x14054004u,0xc0140827u,0xf0060801u,0x05040804u),\nuvec4(0xff3e0d0bu,0xffffffffu,0x070e6fffu,0x0c0b160eu),\nuvec4(0x0c2b0c0bu,0xf0040620u,0x0015a0f0u,0x04380465u),\nuvec4(0x05000406u,0x45000570u,0x30f0d500u,0x20070801u),\nuvec4(0x01140706u,0x07040120u,0x07c00708u,0x0807f004u),\nuvec4(0x060b0501u,0xffffff1eu,0x9fffffffu,0x160e0f0eu),\nuvec4(0x093b0c1bu,0xf0f01410u,0x65b00500u,0x00072804u),\nuvec4(0x000a0704u,0x40150015u,0x30f035f5u,0x20040807u),\nuvec4(0x20044706u,0x07080701u,0x17f017b0u,0x060b0900u),\nuvec4(0xffffff0eu,0xafffffffu,0x3b0c064eu,0x00090b0du),\nuvec4(0xf0f00405u,0x55c00500u,0x04180704u,0x04080400u),\nuvec4(0x25000500u,0x8500a530u,0x080420f0u,0x06016004u),\nuvec4(0x01070807u,0x07000500u,0x07a00403u,0x0801e006u),\nuvec4(0x0b0c0006u,0xffffff07u,0xcfffffffu,0x0c0b063eu),\nuvec4(0x050b0d3bu,0x00f0f0f0u,0x05001475u,0x15002517u),\nuvec4(0xf5003530u,0x0110f005u,0x07019017u,0x00040708u),\nuvec4(0x90170105u,0xe0040701u,0x00040807u,0xff0e060cu),\nuvec4(0xffffffffu,0x0f0edfffu,0x0c16070eu,0x050c162bu),\nuvec4(0x05300500u,0x7590f0f0u,0x00060724u,0x10052005u),\nuvec4(0xf0f53035u,0x01170100u,0x041804b0u,0x08040500u),\nuvec4(0x60050004u,0xe0010804u,0x0b000117u,0xffff0e06u),\nuvec4(0xffffffffu,0x2e1f0edfu,0x061b0c06u,0xf0090607u),\nuvec4(0xa00540f0u,0x17080775u,0x50050005u,0x10257005u),\nuvec4(0x0701f095u,0x04d00408u,0x10060807u,0x70040806u),\nuvec4(0x0804e017u,0x0b090007u,0xffffff06u,0xffffffffu),\nuvec4(0x061e0f1eu,0x0b07162bu,0xf0f0f009u,0x07045500u),\nuvec4(0x30250418u,0x10455025u,0x0807f095u,0x0704f004u),\nuvec4(0x05000608u,0x50040807u,0xe0040701u,0x00040304u),\nuvec4(0xff070b0cu,0xffffffffu,0x1e0fffffu,0x4b060e0fu),\nuvec4(0xf0f00c17u,0x044500f0u,0x15061807u,0x15501560u),\nuvec4(0x95101500u,0x040804e0u,0x01f00500u,0x00040807u),\nuvec4(0x20011705u,0xe0170005u,0x00011701u,0xff0e060cu),\nuvec4(0xffffffffu,0x1e1fffffu,0x0b070e0fu,0x0c172b0du),\nuvec4(0xf005f0f0u,0x25270435u,0x05001560u,0x01d0b580u),\nuvec4(0x0130f017u,0x00040807u,0x00070804u,0x07061005u),\nuvec4(0x0804e001u,0x0c050007u,0xffffff07u,0xffffffffu),\nuvec4(0x0e1f1e2fu,0x070c3b06u,0xe0f00506u,0x40056005u),\nuvec4(0x04351005u,0x15070405u,0x05500500u,0x15100500u),\nuvec4(0x17d0b550u,0x0140f001u,0x07000517u,0x04000108u),\nuvec4(0x01100417u,0x0804b004u,0x0b0c0004u,0xffffff0eu),\nuvec4(0xffffffffu,0x061b1e5fu,0x0b07062bu,0x0550f0f0u),\nuvec4(0x05001500u,0x00141540u,0x90150704u,0x10255005u),\nuvec4(0x0804c0a5u,0x5005f004u,0x00040701u,0x20063701u),\nuvec4(0xb0040701u,0x05040807u,0xffff060cu,0xffffffffu),\nuvec4(0x262e6fffu,0xf009172bu,0x000530f0u,0x30040701u),\nuvec4(0x04151005u,0x20060415u,0x00057005u,0xc0957025u),\nuvec4(0x1500f017u,0x14201450u,0x00051001u,0x1701b017u),\nuvec4(0x0e0b0900u,0xffffffffu,0x6fffffffu,0x061e072eu),\nuvec4(0x07060c0du,0xf0f0050bu,0x01000510u,0x20150117u),\nuvec4(0x20350b35u,0x20052015u,0x50550005u,0x0804b085u),\nuvec4(0x0510f004u,0x05400500u,0x01080480u,0x040804b0u),\nuvec4(0xff0b0c05u,0xffffffffu,0x3e8fffffu,0x172b0e07u),\nuvec4(0xb0f0050cu,0x10052005u,0x15200117u,0x05001700u),\nuvec4(0x25103504u,0x75605580u,0x150117b0u,0x04e015f0u),\nuvec4(0x05000708u,0x040807a0u,0xffff071cu,0xffffffffu),\nuvec4(0x073e8fffu,0x071b060eu,0xf0250b08u,0x05100590u),\nuvec4(0x08070400u,0x20050004u,0x00170005u,0x15000605u),\nuvec4(0x00040510u,0x00258005u,0x10051015u,0x00250035u),\nuvec4(0x0517b005u,0x05b01509u,0x11040130u,0x04200550u),\nuvec4(0x07d00708u,0x0b0c0408u,0xffffff0eu,0xffffffffu),\nuvec4(0x0b064e9fu,0x09070816u,0x0025b0f0u,0x04070804u),\nuvec4(0x07500500u,0x00140008u,0x00050015u,0x25000406u),\nuvec4(0x45002550u,0x17b09510u,0x00150915u,0x0401a005u),\nuvec4(0x04570807u,0x08073001u,0x05000407u,0x01040180u),\nuvec4(0xff061c17u,0xffffffffu,0x1ecfffffu,0x060b0607u),\nuvec4(0x0b07060bu,0x40151005u,0x1015f005u,0x04070806u),\nuvec4(0x17600500u,0x00040600u,0x00050015u,0x10040605u),\nuvec4(0x00255005u,0xa0951045u,0x15060801u,0x01704509u),\nuvec4(0x07080704u,0x01050104u,0x07163714u,0x00040703u),\nuvec4(0x04069005u,0x0c060800u,0xffff0e06u,0xffffffffu),\nuvec4(0x072ebfffu,0x07260b06u,0x05200906u,0x15201520u),\nuvec4(0x05001550u,0x08070430u,0x70051007u,0x06070017u),\nuvec4(0x06401500u,0x05000407u,0x45101540u,0x04a09510u),\nuvec4(0x00550408u,0x08046015u,0x04800104u,0x04b00447u),\nuvec4(0x08040007u,0xff0e0c06u,0xffffffffu,0x3ecfffffu),\nuvec4(0x0e061b06u,0x100c0608u,0x00051005u,0x01041605u),\nuvec4(0x180714c0u,0x20053007u,0x00050005u,0x06070017u),\nuvec4(0x05300500u,0x04080610u,0x45300500u,0xa5001510u),\nuvec4(0x050017a0u,0x05202500u,0x04080460u,0x01301560u),\nuvec4(0x90051005u,0x06001701u,0x0e060b08u,0xffffffffu),\nuvec4(0xcfffffffu,0x1b16072eu,0x0b07080eu,0x25041005u),\nuvec4(0x06040500u,0x17840617u,0x05040718u,0x17204540u),\nuvec4(0x15001700u,0x05001510u,0x04080400u,0x05002500u),\nuvec4(0xa5005510u,0x04080490u,0x05401520u,0x25901760u),\nuvec4(0x05802500u,0x07080700u,0x1e061700u,0xffffffffu),\nuvec4(0xbfffffffu,0x0607163eu,0x1b071e0cu,0x15101710u),\nuvec4(0xb7040110u,0x10652014u,0x00172005u,0x00650017u),\nuvec4(0x08060005u,0x20050007u,0xe5200604u,0x15a01790u),\nuvec4(0x04070450u,0x04b015b0u,0x1e270527u,0xffffffffu),\nuvec4(0xbfffffffu,0x0c0b263eu,0x06080e0bu,0x0804100bu),\nuvec4(0x15100407u,0x05001130u,0x25300120u,0x05400540u),\nuvec4(0x07001700u,0x00050004u,0x00450015u,0x07160806u),\nuvec4(0x06050005u,0xe5000507u,0x04080480u,0x17602590u),\nuvec4(0x058025a0u,0x14080400u,0x1e170a07u,0xffffffffu),\nuvec4(0xafffffffu,0x072e0f1eu,0x080e2b16u,0x00050b06u),\nuvec4(0x17080705u,0x0015e004u,0x34051005u,0x05100510u),\nuvec4(0x07051710u,0x05041001u,0x17105500u,0x10041701u),\nuvec4(0x00050704u,0x70350085u,0x30f01701u,0x00070804u),\nuvec4(0x05600405u,0x04901500u,0x06000708u,0x07080607u),\nuvec4(0xffffff1eu,0xffffffffu,0x06074ebfu,0x080e2b07u),\nuvec4(0x10090b06u,0x06040701u,0x05212427u,0x0506040au),\nuvec4(0x27001540u,0x00040604u,0x10150005u,0x04070017u),\nuvec4(0x05001710u,0x14101500u,0x00040807u,0x00050417u),\nuvec4(0x00850017u,0x08067035u,0x1500f004u,0x07201700u),\nuvec4(0x0420f004u,0x17100708u,0x0e070806u,0xffffffffu),\nuvec4(0xcfffffffu,0x1b06274eu,0x06070806u,0x0005000cu),\nuvec4(0x06141706u,0x05500487u,0x07301700u,0x00051004u),\nuvec4(0x0a170005u,0x00173507u,0x07060015u,0x07081706u),\nuvec4(0x00011710u,0x00060701u,0x60950015u,0x10f01701u),\nuvec4(0x05170015u,0x00f01710u,0x07080701u,0x08040001u),\nuvec4(0xff1e0817u,0xffffffffu,0x2edfffffu,0x060e0607u),\nuvec4(0x060b060bu,0x050d1708u,0x04000500u,0x04070807u),\nuvec4(0x05301530u,0x06000530u,0x15000107u,0x00060700u),\nuvec4(0x00150005u,0x30070417u,0x10040804u,0x00040804u),\nuvec4(0x06180701u,0x07080400u,0x04080410u,0x00650015u),\nuvec4(0x08016015u,0x2500f004u,0x04170400u,0x01d01700u),\nuvec4(0x07180704u,0x08071001u,0x1e080706u,0xffffffffu),\nuvec4(0xcfffffffu,0x070b363eu,0x0b1e0816u,0x27064005u),\nuvec4(0x15240524u,0x04080450u,0x07002500u,0x30050006u),\nuvec4(0x07040704u,0x00050015u,0x17150017u,0x05370005u),\nuvec4(0x04080700u,0x05001710u,0x04609500u,0x00f00608u),\nuvec4(0x00170045u,0x05200517u,0x11100104u,0x18070604u),\nuvec4(0x05000417u,0x07080400u,0x1e08070cu,0xffffffffu),\nuvec4(0xdfffffffu,0x0b16172eu,0x15062726u,0x05000407u),\nuvec4(0x06370110u,0x04600514u,0x05000708u,0x00060730u),\nuvec4(0x00050015u,0x07040804u,0x10050005u,0x10040701u),\nuvec4(0x00040804u,0x04081704u,0x10170400u,0x00010804u),\nuvec4(0x080460a5u,0x2510f004u,0x07080400u,0x04301704u),\nuvec4(0x15201487u,0x01080701u,0x0e08070bu,0xffffffffu),\nuvec4(0xefffffffu,0x1756073eu,0x04071516u,0x35701510u),\nuvec4(0x01000500u,0x05000117u,0x07000500u,0x15000408u),\nuvec4(0x27100500u,0x00050025u,0x00040804u,0x00050704u),\nuvec4(0x08040704u,0x08071004u,0x08040005u,0x0760b504u),\nuvec4(0x10f00108u,0x17040015u,0x07080701u,0x14061450u),\nuvec4(0x01101540u,0x00040807u,0x0e08070bu,0xffffffffu),\nuvec4(0xefffffffu,0x071e071eu,0x08072b16u,0x00090b06u),\nuvec4(0x05000607u,0x15003530u,0x07201500u,0x05000408u),\nuvec4(0x04000500u,0x05000408u,0x05100500u,0x10042700u),\nuvec4(0x00070835u,0x07041015u,0x00070804u,0x04080405u),\nuvec4(0x00170500u,0xf01760a5u,0x06070430u,0x08070001u),\nuvec4(0x05700107u,0x30140604u,0x08170401u,0x0b050007u),\nuvec4(0xff0e0807u,0xffffffffu,0x4edfffffu,0x060d0617u),\nuvec4(0x0d1b171bu,0x05001700u,0x05401540u,0x08070410u),\nuvec4(0x00250004u,0x00070804u,0x17046005u,0x00152004u),\nuvec4(0x00151017u,0x17040804u,0x08040005u,0x17050004u),\nuvec4(0x1760a500u,0x070510f0u,0x07140708u,0xa0040708u),\nuvec4(0x08570401u,0x09100417u,0x0e08070bu,0xffffffffu),\nuvec4(0xdfffffffu,0x071b464eu,0x0a060708u,0x04080400u),\nuvec4(0x15700500u,0x08070410u,0x20150407u,0x15070804u),\nuvec4(0x05101520u,0x04070600u,0x06003500u,0x04300508u),\nuvec4(0x08040007u,0x08040005u,0x00171006u,0xf01760a5u),\nuvec4(0x04570110u,0x013405f0u,0x070b0940u,0xffff0e08u),\nuvec4(0xffffffffu,0x363eefffu,0x0e08062bu,0x00050d06u),\nuvec4(0x00250117u,0x07045005u,0x10060708u,0x17050015u),\nuvec4(0x05000106u,0x15003500u,0x04070400u,0x04003500u),\nuvec4(0x15000408u,0x00070400u,0x00040804u,0x17101705u),\nuvec4(0x200520b5u,0xf0f0f017u,0x0d001510u,0x0e080706u),\nuvec4(0xffffffffu,0xefffffffu,0x1b06074eu,0x08060b0du),\nuvec4(0x150c060eu,0x00040804u,0x24050035u,0x04070807u),\nuvec4(0x10051001u,0x01060705u,0x15101500u,0x06002520u),\nuvec4(0x05200507u,0x04080400u,0x00070430u,0x00060705u),\nuvec4(0x00051705u,0x00050807u,0xf0176095u,0x2015c0f0u),\nuvec4(0x06091004u,0xffffff18u,0xffffffffu,0x26073effu),\nuvec4(0x08060c1bu,0x100b0607u,0x04080605u,0x17044500u),\nuvec4(0x05047014u,0x05307510u,0x05040500u,0x04101500u),\nuvec4(0x15000408u,0x00060400u,0x10040704u,0x00050807u),\nuvec4(0x60b50807u,0xf0f0f017u,0x10060400u,0x0708060cu),\nuvec4(0xffffff0eu,0xffffffffu,0x06074effu,0x060b173bu),\nuvec4(0x17050015u,0x3005a005u,0x40a51005u,0x05040005u),\nuvec4(0x05002500u,0x15000408u,0x05001400u,0x07100407u),\nuvec4(0x17000508u,0xf01760b5u,0x0700f0f0u,0x060c1004u),\nuvec4(0xffff0807u,0xffffffffu,0x4e0fffffu,0x0b0d2b06u),\nuvec4(0x00051b17u,0x07080415u,0x05000500u,0x15302530u),\nuvec4(0x35001500u,0x25005500u,0x15101500u,0x04070500u),\nuvec4(0x04001500u,0x07050005u,0x08041004u,0xb5170004u),\nuvec4(0x04080460u,0x07f0f0f0u,0x0d040001u,0xffff1806u),\nuvec4(0xffffffffu,0x0f0effffu,0x174b063eu,0x0005001bu),\nuvec4(0x08040005u,0xf0050007u,0x25000500u,0x1520b500u),\nuvec4(0x05070500u,0x25002500u,0x08041014u,0xb5170004u),\nuvec4(0x04080460u,0x04e0f0f0u,0x0a170107u,0xff0e0807u),\nuvec4(0xffffffffu,0x6effffffu,0x07060c3bu,0x10150b0du),\nuvec4(0x08040005u,0xf0150004u,0x25300500u,0x15103540u),\nuvec4(0x25070500u,0x09003500u,0x07040015u,0xb517000au),\nuvec4(0x04000540u,0xf0f00408u,0x170017e0u,0x0e080709u),\nuvec4(0xffffffffu,0x0e9fffffu,0x1e172e1fu,0x16075ebfu),\nuvec4(0x08060c1bu,0x00050b06u,0x08070035u,0xe0051004u),\nuvec4(0x00351045u,0x00051055u,0x05060005u,0x04005500u),\nuvec4(0x07150005u,0x00170004u,0x170160a5u,0x07e0f0f0u),\nuvec4(0x09040814u,0xff0e0807u,0xffffffffu,0x075e6fffu),\nuvec4(0x265e8f8eu,0x0608062bu,0x2510090bu,0x07080710u),\nuvec4(0x4500f004u,0x85001520u,0x05041500u,0x07009510u),\nuvec4(0x00170504u,0xf01770a5u,0x0804d0f0u,0x0c001704u),\nuvec4(0xffff0807u,0xffffffffu,0x2e273e3fu,0x0e176e07u),\nuvec4(0x1b268e6fu,0x55001c17u,0x08070400u,0x05000407u),\nuvec4(0xb51075a0u,0x85302500u,0x04050a00u,0xa5000408u),\nuvec4(0xf0011770u,0x0704c0f0u,0x00010806u,0xbf08070cu),\nuvec4(0xff3e073eu,0xcfffffffu,0x2726374eu,0x0706072eu),\nuvec4(0x0f0e0716u,0x178e2f0eu,0x0b171b06u,0x0005100cu),\nuvec4(0x10051005u,0x10061704u,0x00859005u,0x00350085u),\nuvec4(0x00a51015u,0x00040804u,0x080470a5u,0xc0f0f001u),\nuvec4(0x0b100427u,0x5e9f0807u,0x2e070e27u,0xffffffffu),\nuvec4(0x16372e6fu,0x0e37360bu,0x0b162e17u,0x0f2e0706u),\nuvec4(0x1b16177eu,0x0c0b0806u,0x00051005u,0x00010704u),\nuvec4(0xa0054405u,0x00d51085u,0x00b50005u,0xb5040704u),\nuvec4(0x04080470u,0x04b0f0f0u,0x06100127u,0x160e8f18u),\nuvec4(0x0e170e07u,0xffffae07u,0x061eefffu,0x08c71637u),\nuvec4(0x1617180eu,0x07060b0du,0x071e079eu,0x08060b06u),\nuvec4(0x10050c06u,0x08040005u,0x18040107u,0x14110407u),\nuvec4(0x35600500u,0xf5001500u,0x0700e500u,0x0170b514u),\nuvec4(0xf0f00608u,0x37000590u,0x0e030620u,0x07260e7fu),\nuvec4(0x167e271eu,0xffff1e07u,0x272e9fffu,0x56370816u),\nuvec4(0x5e070607u,0x1c0b0637u,0x06ce060bu,0x090b171bu),\nuvec4(0x04100500u,0x17043708u,0x05041708u,0xd5001590u),\nuvec4(0x0645f500u,0x70b50604u,0xf0040801u,0x0801a0f0u),\nuvec4(0x05101704u,0x5f0e0807u,0x070e070eu,0x076e075eu),\nuvec4(0x3e071e66u,0x4edfffffu,0x16271627u,0x1b161b1du),\nuvec4(0x0e071e16u,0x06075607u,0xae062b0au,0x061b0607u),\nuvec4(0x050c0b07u,0x04000500u,0x04050417u,0x50050420u),\nuvec4(0x00056005u,0x0015f5f5u,0x040a0605u,0x0470a500u),\nuvec4(0x15300408u,0x1740f0f0u,0x10040804u,0x0e080705u),\nuvec4(0x3e360e4fu,0x07061e07u,0x27c6074eu,0x7fffff1eu),\nuvec4(0x1726070eu,0x0b063716u,0x2b0d1b1du,0x0b071e26u),\nuvec4(0x2b260726u,0x07062b16u,0x0607068eu,0x0608060bu),\nuvec4(0x0004050cu,0x17050005u,0x10151004u,0x0025a015u),\nuvec4(0xc51025f5u,0xb5041509u,0x04080170u,0xf0f02520u),\nuvec4(0x04080430u,0x07052017u,0x0e4f0e08u,0x5e060b06u),\nuvec4(0x1e170607u,0x06270e17u,0x160b560bu,0xff3e1607u),\nuvec4(0x16074fffu,0x2607060bu,0x2d060708u,0x0d0c2b0cu),\nuvec4(0x3e07060bu,0x066e1706u,0x5e17067bu,0x08360e07u),\nuvec4(0x14050b07u,0x04000500u,0x04070807u,0x05003510u),\nuvec4(0x35302500u,0xb5103510u,0x55100500u,0x07104500u),\nuvec4(0x70950004u,0xf0040801u,0x0450f025u,0x07010607u),\nuvec4(0x07092004u,0x070e3f08u,0x3e060b16u,0x06670877u),\nuvec4(0x660b0617u,0x1e0f0e07u,0x0e2fffffu,0x07161726u),\nuvec4(0x0c0d0608u,0x2e07265bu,0x1e2f0e2fu,0x16071e1fu),\nuvec4(0x6e07067bu,0x0c0b1736u,0x00040704u,0x18041005u),\nuvec4(0xd0010407u,0x10151035u,0x65f51055u,0x70a50406u),\nuvec4(0xf0040805u,0x0520f025u,0x04070100u,0x01080400u),\nuvec4(0x0d000500u,0x0e3f0807u,0x47062b06u,0x77581758u),\nuvec4(0x3e060b46u,0x1e0fffffu,0x08071627u,0x1b0c1b07u),\nuvec4(0x060d0b0du,0x3eff0e07u,0x3b0c4b07u,0x16375e06u),\nuvec4(0x140c0607u,0x15000407u,0x08170400u,0x05207407u),\nuvec4(0x15001510u,0x75001500u,0x35002500u,0x1400c500u),\nuvec4(0x17809500u,0x20f045e0u,0x17101701u,0x04100500u),\nuvec4(0x070e2f18u,0x07061b06u,0x270e1708u,0x073e071eu),\nuvec4(0x6718270eu,0x1e17560bu,0x172eefffu,0x07080706u),\nuvec4(0x4b0d1c06u,0x3e4fff06u,0x4e066b16u,0x0e070607u),\nuvec4(0x17060b07u,0x04050c0bu,0x15000408u,0x07040510u),\nuvec4(0x05142728u,0xf5301520u,0x04e50045u,0x80950007u),\nuvec4(0xf065c017u,0x01170015u,0x01070400u,0x18062005u),\nuvec4(0x1b060e2fu,0x370e0706u,0x3e2f3e26u,0x27181716u),\nuvec4(0x3b160708u,0xafff3e07u,0x0708274eu,0x4b0c0d06u),\nuvec4(0x6fff0e16u,0x060e1f1eu,0x264e065bu,0x060b0617u),\nuvec4(0x040c0607u,0x04080405u,0x05301500u,0x15200124u),\nuvec4(0xc5102510u,0x0785f500u,0x070480a5u,0x35500550u),\nuvec4(0x05701500u,0x00060780u,0x00170005u,0x08072005u),\nuvec4(0x070e1f0eu,0x070e061bu,0x070ecf5eu,0x17060d0bu),\nuvec4(0x0b064708u,0xff3e1b0du,0x0e072e9fu,0x06070817u),\nuvec4(0x2b0d0c0bu,0x6fff0e26u,0x0f2e0f0eu,0x5b06070eu),\nuvec4(0x16074e06u,0x160b0617u,0x0106090cu,0x00040804u),\nuvec4(0x3005d005u,0x00450095u,0x00450015u,0x070500c5u),\nuvec4(0x080480a5u,0x9005f004u,0x04077005u,0x04000500u),\nuvec4(0x07400107u,0x0e1f0e08u,0x2e060b06u,0x460e4fffu),\nuvec4(0x46470807u,0x1e9fff1eu,0x17080716u,0x162b0d06u),\nuvec4(0xcfff0e07u,0x3b16074eu,0x0e074e06u,0x0b071637u),\nuvec4(0x0007040cu,0x00040804u,0x10050015u,0x00152005u),\nuvec4(0x20557004u,0x00350015u,0x00c50045u,0x90a50704u),\nuvec4(0x20f0f017u,0x00051014u,0x05400407u,0x072f0807u),\nuvec4(0x5fff2e26u,0x0827063eu,0x36170817u,0x1e8fff0eu),\nuvec4(0x06170b06u,0xff2e063bu,0x1e1f0effu,0x063b1607u),\nuvec4(0x06276e07u,0x0c06070bu,0x01070405u,0x01070807u),\nuvec4(0x14700510u,0x45600500u,0x35003500u,0x0005f500u),\nuvec4(0x00040725u,0x40179085u,0x05e0f005u,0x00070410u),\nuvec4(0x07013005u,0x260e2f08u,0xbfff0e07u,0x1718174eu),\nuvec4(0xff0e0726u,0x06071e5fu,0x063b060bu,0x1fffff0eu),\nuvec4(0x0f0e0f0eu,0x060e073eu,0x077e062bu,0x0b060706u),\nuvec4(0x090c0607u,0x04011700u,0x11140708u,0x17040130u),\nuvec4(0x45501510u,0xf5002510u,0x06070085u,0x04908500u),\nuvec4(0x25200108u,0x2005b0f0u,0x04600704u,0x1e2f0807u),\nuvec4(0x0e071607u,0x1f0ecfffu,0x3728072eu,0x0e4fff0eu),\nuvec4(0x1e064b16u,0x1e680edfu,0x06179e9fu,0x6e07062bu),\nuvec4(0x071b0607u,0x000c0b06u,0x04111705u,0x04170827u),\nuvec4(0x20050427u,0x10156005u,0x00040705u,0x041095f5u),\nuvec4(0x90850007u,0x30040804u,0x05e0f015u,0x04600106u),\nuvec4(0xff5e3f18u,0x073e1fffu,0xff0e1718u,0x3b061e3fu),\nuvec4(0x0ebf0706u,0x1f486e48u,0x17ae0f2eu,0x1e161b06u),\nuvec4(0x26074e07u,0x00051c17u,0x10042704u,0x30142714u),\nuvec4(0x10058005u,0x04070005u,0xc5008540u,0x00070400u),\nuvec4(0x4017a085u,0x05e0f005u,0x0e080480u,0x2fff2e3fu),\nuvec4(0xbf1e183eu,0xff1e273eu,0x4b060e2fu,0x380e9f0eu),\nuvec4(0x2e0f1e07u,0x1f1e2708u,0xee07080eu,0x061b1607u),\nuvec4(0x175e071eu,0x0c060726u,0x07042009u,0x20040708u),\nuvec4(0xd0053005u,0x07050005u,0x00050004u,0x00351005u),\nuvec4(0x070005f5u,0x04a09504u,0xe0f0f007u,0x2f0e0807u),\nuvec4(0x081eef3eu,0x18574807u,0x074e0f4eu,0xff0e060bu),\nuvec4(0x2b061e2fu,0x0e6f1e06u,0x07062718u,0x1627682eu),\nuvec4(0x1f4e072eu,0x9e36176eu,0x07061b06u,0x00090b06u),\nuvec4(0x27041015u,0xe0056004u,0x35000517u,0xf5004500u),\nuvec4(0x95040704u,0x040804a0u,0x07d0f0f0u,0x1e5f0e08u),\nuvec4(0x47581e9fu,0x37261706u,0x1f1e0716u,0x060b062eu),\nuvec4(0x0d073fffu,0x187f062bu,0x0b0a0607u,0x17182e06u),\nuvec4(0x0877260eu,0x175e1f7eu,0x5e060b06u,0x0b162e07u),\nuvec4(0x091b0806u,0x01100530u,0x25140617u,0x040005d0u),\nuvec4(0x15000408u,0x05002500u,0xf5001500u,0xb0a50704u),\nuvec4(0xc0f0f017u,0x0e080701u,0x270e0fffu,0x47064706u),\nuvec4(0x072e1708u,0x07060d26u,0x162e0f1eu,0x0e1fff0eu),\nuvec4(0x5f0e3b06u,0x071d1718u,0x17081f0eu,0x0a061b06u),\nuvec4(0x060b0a06u,0x17060b0du,0xfe080706u,0x060b060eu),\nuvec4(0x060b169eu,0x50091b07u,0x05541005u,0x050005c0u),\nuvec4(0x00040701u,0x10251005u,0x00750045u,0x07040035u),\nuvec4(0x04b09500u,0xf0f00107u,0x080705b0u,0x080eef0eu),\nuvec4(0x28970887u,0x0b1d0617u,0x08164e16u,0x3b0eff0eu),\nuvec4(0x084f0e06u,0x060d0b17u,0x07081f0eu,0x47361b16u),\nuvec4(0x061b1d16u,0x16de0617u,0x071617aeu,0x60090b06u),\nuvec4(0x30058005u,0x00251015u,0x08040005u,0x10252004u),\nuvec4(0x040745f5u,0x17c09500u,0x04b0f0f0u,0x080eef18u),\nuvec4(0x18070647u,0x290c1a07u,0x0704290cu,0x07081706u),\nuvec4(0x661d0b06u,0xff08070bu,0x0e063b06u,0x0c06183fu),\nuvec4(0x0e1f0e0bu,0x0b060708u,0x0c0b060du,0x0c290c09u),\nuvec4(0x1b0a470bu,0x7e060706u,0x0e2f0e0fu,0x2607be07u),\nuvec4(0x090b0607u,0x15b03590u,0x00170520u,0x00251005u),\nuvec4(0x040035f5u,0x95000408u,0x070804c0u,0x04a0f0f0u),\nuvec4(0x070edf18u,0x06070816u,0x06070807u,0x0c290608u),\nuvec4(0x093c0d0bu,0x0d0b0a07u,0x06080706u,0x065b1d0bu),\nuvec4(0x0edf180eu,0x083e064bu,0x060c0607u,0x07180e1fu),\nuvec4(0x0b1c160bu,0x1b1c0b06u,0x060b1619u,0x1b0d0617u),\nuvec4(0xee0f9e16u,0x1b071617u,0x50050009u,0xd0150005u),\nuvec4(0x08041025u,0x30250004u,0x040035f5u,0x95000408u),\nuvec4(0x040807d0u,0x0790f0f0u,0x07df0703u,0x06070816u),\nuvec4(0x0b080e37u,0x0f061c09u,0x0b0c0d0eu,0x0b17090cu),\nuvec4(0x08061b06u,0x0c2d0607u,0x081e072bu,0x064b06dfu),\nuvec4(0x1b07082eu,0x06181f07u,0x160e060bu,0x0e0f061cu),\nuvec4(0x0d07090bu,0x0607041cu,0x1c17160eu,0x070b0c0bu),\nuvec4(0x46de0f7eu,0x60091b07u,0x00140005u,0x0045b005u),\nuvec4(0x00040804u,0x10551025u,0x001700d5u,0x0804d0a5u),\nuvec4(0xf0052004u,0x080750f0u,0x060ecf07u,0x1706070au),\nuvec4(0x071f0e16u,0x1b1f073cu,0x060c0b07u,0x0e0f0607u),\nuvec4(0x17060b06u,0x1e062b26u,0xbf0e080fu,0x07066b0eu),\nuvec4(0x0b0c0708u,0x080e0f0eu,0x0e0b0a07u,0x07060e0fu),\nuvec4(0x1f0e0b0cu,0x1c07040bu,0x06070609u,0x17060e1fu),\nuvec4(0x060c0b1cu,0x074efe07u,0x060b160bu,0x60091b07u),\nuvec4(0x04070005u,0x171035d0u,0x40350055u,0x08250095u),\nuvec4(0xe0a50007u,0xf0010807u,0x080780f0u,0x070ebf0eu),\nuvec4(0x0d060b2du,0x070e2f06u,0x09262c0du,0x07061c17u),\nuvec4(0x1b072f06u,0x0e070807u,0x2e060b06u,0x0ebf180fu),\nuvec4(0x0607066bu,0x181e060bu,0x2f060b07u,0x0c07060eu),\nuvec4(0x061f060bu,0x062c0607u,0x0e2f0b07u,0x0d0c160bu),\nuvec4(0x1f7e161bu,0x065e0f2eu,0x060b160bu,0x090b0c07u),\nuvec4(0x04000550u,0x80051007u,0x00151005u,0x00171405u),\nuvec4(0x00250045u,0x00c52005u,0x00040804u,0x0804e0a5u),\nuvec4(0x80f0f004u,0xbf0e0804u,0x0b060a07u,0x0b0d0c0du),\nuvec4(0x070e2f0eu,0x06091c04u,0x08070407u,0x06171c06u),\nuvec4(0x061b073fu,0x1e1f2e17u,0x5b0ebf18u,0x0e161706u),\nuvec4(0x0b0a1708u,0x060e3f0eu,0x0b0c0b07u,0x1c090427u),\nuvec4(0x3f061709u,0x0d0c2b06u,0x5e8f2e46u,0x06072627u),\nuvec4(0x0160090bu,0x05000407u,0x05a00500u,0x14170500u),\nuvec4(0x10750055u,0xf0c517c5u,0xf0040807u,0x080470f0u),\nuvec4(0x160eaf0eu,0x0a1d0a07u,0x0e2f0e06u,0x092c0607u),\nuvec4(0x0c041706u,0x0e06071bu,0x07062e4fu,0x181e3f08u),\nuvec4(0x064b0ebfu,0x171e1f0eu,0x0e060d0bu,0x1c17065fu),\nuvec4(0x0a3c091bu,0x3f060708u,0x0b0a2b16u,0x1e160e06u),\nuvec4(0x07368e8fu,0x600c0b06u,0x00051017u,0x10055025u),\nuvec4(0x08040005u,0x00053001u,0x45f50015u,0x04080700u),\nuvec4(0x04f0b500u,0xf0f00708u,0x0e080470u,0x1a062eafu),\nuvec4(0x3f0e1706u,0x2c0b0706u,0x07062c29u,0x0e8f0e0bu),\nuvec4(0x0f3e0f08u,0x4b07bf18u,0x161e1f0eu,0x7f0e060bu),\nuvec4(0x06070607u,0x090c094cu,0x0f060c17u,0x1b1e1f0eu),\nuvec4(0x07061b0du,0x5e7f3e1fu,0x170b2617u,0x0805501cu),\nuvec4(0x50050004u,0x00050005u,0x10150005u,0x00250017u),\nuvec4(0x10553005u,0x04350075u,0xc5000408u,0x080700f0u),\nuvec4(0x60f0f001u,0x9f0e0804u,0x170e162eu,0x161f3e08u),\nuvec4(0x5c090c07u,0x6f160804u,0x0e1f281eu,0x0eaf182fu),\nuvec4(0x1f0e4b06u,0x0b060708u,0x160e9f0eu,0x090c0407u),\nuvec4(0x040c190cu,0x0e081708u,0x16070e1fu,0x9f1e461bu),\nuvec4(0x062b078eu,0x050c0b07u,0x04080440u,0x25300500u),\nuvec4(0x05000500u,0x07140110u,0x00150004u,0x45f53015u),\nuvec4(0xf0e50708u,0x04080400u,0x0540f0f0u,0x0e080700u),\nuvec4(0x0e062e9fu,0x2e280e0fu,0x160e0807u,0x1c290a07u),\nuvec4(0x3f1b0804u,0x0627080eu,0x0e1f0e17u,0x0eaf182fu),\nuvec4(0x2f073b06u,0x162e9837u,0x08272617u,0x0e0f0e07u),\nuvec4(0x0b060e18u,0x060e0716u,0x3e07061eu,0x2b079e5fu),\nuvec4(0x0b060706u,0x08044009u,0x50050004u,0x00050015u),\nuvec4(0x05240704u,0x15001510u,0x35200530u,0x0807a500u),\nuvec4(0xf0d50004u,0x04080100u,0x1760f0f0u,0x3f1eaf0eu),\nuvec4(0x2e07180eu,0x17060728u,0x060a0406u,0x070c0607u),\nuvec4(0x0e07280eu,0x1e070e17u,0x0e1f1e0fu,0x0eaf180fu),\nuvec4(0x0e062b07u,0x0e271e2fu,0x67583e17u,0x06040b06u),\nuvec4(0x0e17080eu,0x1e16070fu,0x5e8f8e0fu,0x172b1607u),\nuvec4(0x04400c0bu,0x05000408u,0x25400500u,0x05301701u),\nuvec4(0x15001500u,0x05500500u,0x95100500u,0x00070804u),\nuvec4(0x1710f0e5u,0x0530f0f0u,0x07080400u,0x0e2fff0eu),\nuvec4(0x0e170e38u,0x06040657u,0x5e171807u,0x180f0e7fu),\nuvec4(0x2b061eafu,0x182e6f0eu,0x4f0e1f1eu,0x090c0b07u),\nuvec4(0x0807062cu,0x3e0f3e17u,0x0f0e3fffu,0x1b26072eu),\nuvec4(0x0c0b0706u,0x04080440u,0x05000500u,0x15000510u),\nuvec4(0x08040500u,0x10150004u,0x10150015u,0x00052025u),\nuvec4(0x00750035u,0xf005f517u,0x01080710u,0x0440f0f0u),\nuvec4(0x4fff0708u,0x080e080eu,0x0e0a0607u,0x0e270e1fu),\nuvec4(0x08070e0fu,0xaf3e171eu,0x061eaf18u,0x2eaf0e2bu),\nuvec4(0x1f081e38u,0x37060708u,0xff1e0b26u,0x3b165eafu),\nuvec4(0x20050b17u,0x05001701u,0x05004500u,0x07080400u),\nuvec4(0x15301504u,0x25002500u,0x15001510u,0x04008500u),\nuvec4(0xf5000408u,0x080410f0u,0x40f0f004u,0xff070804u),\nuvec4(0x0817287fu,0x1e071807u,0x0e0f0e28u,0x0e9f2e0fu),\nuvec4(0x1eaf181fu,0x0e062b06u,0x082758efu,0x26070e27u),\nuvec4(0x3ecfff07u,0x171b3607u,0x0500090bu,0x00040700u),\nuvec4(0x00252005u,0x07040005u,0x20152004u,0x10050025u),\nuvec4(0x00050065u,0x08150075u,0x05f50007u,0xf01720f0u),\nuvec4(0x080440f0u,0x08afff07u,0x280e181eu,0xef4e0f1eu),\nuvec4(0x061eaf18u,0xff0e062bu,0x07080e2fu,0xffff4e06u),\nuvec4(0x1b075e0fu,0x060c0b16u,0x050c0b07u,0x01070400u),\nuvec4(0x10050004u,0x07040035u,0x00150004u,0x10050075u),\nuvec4(0x08043025u,0x35003507u,0x04080400u,0xf005f500u),\nuvec4(0x04080720u,0x0430f0f0u,0xffffff17u,0xaf0e08afu),\nuvec4(0x2b06071eu,0x1e7fff0eu,0x4e4fffffu,0x081b3607u),\nuvec4(0x00050c06u,0x04081704u,0x15100500u,0x01080400u),\nuvec4(0x05200500u,0x15005530u,0x14070400u,0x04080407u),\nuvec4(0x15003500u,0x05080700u,0xf005f500u,0x04080420u),\nuvec4(0x0430f0f0u,0xffff0708u,0x0f1e6fffu,0xaf0e080eu),\nuvec4(0xff1e461eu,0x8ebfffffu,0x070c0b26u,0x20090c06u),\nuvec4(0x10040804u,0x07041015u,0x20050004u,0x00554015u),\nuvec4(0x04080405u,0x07000718u,0x15000408u,0x05001500u),\nuvec4(0xf5000708u,0x0730f015u,0xf0f00108u,0x04000500u),\nuvec4(0xffff0e08u,0x1f1e6fffu,0x1eaf0e08u,0x3e070607u),\nuvec4(0xbfffffffu,0x2b16076eu,0x0608040cu,0x0015000cu),\nuvec4(0x04010408u,0x01170117u,0x05400500u,0x65101500u),\nuvec4(0x04000417u,0x07000507u,0x05002508u,0x08041500u),\nuvec4(0x00050004u,0x0430f0f5u,0xf0f00408u,0x0e080720u),\nuvec4(0x9fffffffu,0xaf0e080eu,0xff4e072eu,0x1edfffffu),\nuvec4(0x160b1627u,0x0c06082bu,0x27050015u,0x15002714u),\nuvec4(0x05101510u,0x04204520u,0x05000408u,0x00171510u),\nuvec4(0x00150005u,0x35f51715u,0x011740f0u,0x0710f0f0u),\nuvec4(0xffff0708u,0x080e9fffu,0x6e071ebfu,0xbfffffffu),\nuvec4(0x0706172eu,0x0b060b06u,0x170c0b06u,0x0550150cu),\nuvec4(0x00040704u,0x10152005u,0x00051025u,0x04070415u),\nuvec4(0x04450017u,0x55000708u,0x00040804u,0x40f025f5u),\nuvec4(0xf0020804u,0x080710f0u,0xffffff0eu,0x180f0e7fu),\nuvec4(0xffffbeafu,0x062eafffu,0x06071607u,0x0c0b061bu),\nuvec4(0x00090c17u,0x20050005u,0x10151005u,0x04851005u),\nuvec4(0x17080500u,0x45000408u,0x00070804u,0x45f51755u),\nuvec4(0x080450f0u,0x00f0f004u,0xffff0e17u,0xbf189fffu),\nuvec4(0xffffffaeu,0x46171eafu,0x0c0d160bu,0x090b0704u),\nuvec4(0x05102570u,0x25002520u,0x27080700u,0x65040500u),\nuvec4(0x45070804u,0x04080700u,0x50f045f5u,0xf0f01701u),\nuvec4(0x0e080400u,0x9fffffffu,0xff9ebf18u,0x1ebfffffu),\nuvec4(0x0e160e07u,0x060b1607u,0x0b080a1bu,0x00055009u),\nuvec4(0x07855015u,0x15001704u,0x04005500u,0x25000408u),\nuvec4(0x04080700u,0xf045f500u,0x04080460u,0xff27f0f0u),\nuvec4(0x089fffffu,0x072eaf0eu,0xffffff6eu,0x06074eafu),\nuvec4(0x085b0617u,0x05000906u,0x25400510u,0x25101520u),\nuvec4(0x20070400u,0x00150065u,0x04003517u,0x65f50408u),\nuvec4(0x080470f0u,0x17e0f004u,0xffff0e06u,0x080e7fffu),\nuvec4(0x7e072ebfu,0x9fffffffu,0x0c3b662eu,0x0906080bu),\nuvec4(0x05100500u,0x05200540u,0x00140110u,0x15140015u),\nuvec4(0x05006500u,0x04080400u,0x04001500u,0x75f50708u),\nuvec4(0x080280f0u,0x27d0f004u,0x8fffffffu,0xffaebf18u),\nuvec4(0x2eafffffu,0x0b0c3b66u,0x20090b07u,0x00052005u),\nuvec4(0x04052025u,0x15170407u,0x15040700u,0x14008500u),\nuvec4(0x08073500u,0xf075f504u,0xd0f01790u,0xff070807u),\nuvec4(0x188fffffu,0xffff8ecfu,0x763eafffu,0x090b074bu),\nuvec4(0x15001520u,0x05101500u,0x04070500u,0x00151400u),\nuvec4(0x25102504u,0x07001520u,0x04002504u,0xf5000408u),\nuvec4(0x0490f075u,0x10f00408u,0x08079005u,0xffffff07u),\nuvec4(0x7ebf188fu,0xffff0e2fu,0x072e9fffu,0x0b1c3b46u),\nuvec4(0x00050608u,0x05040005u,0x25001500u,0x25072500u),\nuvec4(0x04000500u,0x00150005u,0x00150045u,0x25040804u),\nuvec4(0x00070801u,0xa0f085f5u,0x0510f017u,0xff061790u),\nuvec4(0x188fffffu,0xffff7ebfu,0x262edfffu,0x0c4b160bu),\nuvec4(0x050b070au,0x10350420u,0x04070045u,0x95104500u),\nuvec4(0x00150034u,0xf5040804u,0x04a0f095u,0xb0f00108u),\nuvec4(0xff060804u,0x088fffffu,0xff6ecf0eu,0x2edfffffu),\nuvec4(0x1b0d3b46u,0x050b0704u,0x25001410u,0x15300500u),\nuvec4(0x00450004u,0x01751005u,0x35000407u,0x00040804u),\nuvec4(0xa0f095f5u,0xf0040801u,0x070804b0u,0xffffff0eu),\nuvec4(0x6edf087fu,0xbfffffffu,0x0b06073eu,0x0b0c3b26u),\nuvec4(0x250c160cu,0x05000407u,0x00040580u,0x00050035u),\nuvec4(0x04550025u,0xf5175508u,0x17b0f0b5u,0x0804b0f0u),\nuvec4(0xffff0e04u,0xcf087fffu,0xffffff7eu,0x5b161edfu),\nuvec4(0x060c2b0du,0x04100c07u,0x00150007u,0x30050005u),\nuvec4(0x00050015u,0x00251045u,0x00040745u,0xf5011735u),\nuvec4(0x02b0f0b5u,0xa0f00107u,0x0e070804u,0x6fffffffu),\nuvec4(0x6edf080eu,0xdfffffffu,0x062b162eu,0x09161c3bu),\nuvec4(0x45040710u,0x25000570u,0x15002500u,0x07042520u),\nuvec4(0x07012500u,0xc5f50408u,0x0804b0f0u,0x04a0f001u),\nuvec4(0xff0e0708u,0x0e6fffffu,0xff5eef08u,0x3ecfffffu),\nuvec4(0x4b163b06u,0x00090b07u,0x00010704u,0x30351035u),\nuvec4(0x040701e5u,0x08072500u,0xf0d5f504u,0x040804b0u),\nuvec4(0x0804a0f0u,0xffff0704u,0xef186fffu,0xffffff5eu),\nuvec4(0x06172ebfu,0x068b060bu,0x0800050bu,0x10040507u),\nuvec4(0x30153015u,0x07950035u,0x00050004u,0x04080701u),\nuvec4(0xf0d5f500u,0xf00207c0u,0x040805a0u,0xffffff06u),\nuvec4(0x5eff186fu,0xafffffffu,0x1b36072eu,0x04057b06u),\nuvec4(0x04070408u,0x75702500u,0x07005500u,0x04150004u),\nuvec4(0x00040807u,0xc0f0e5f5u,0xf0010802u,0xff0617a0u),\nuvec4(0x086fffffu,0x073eef0eu,0xffffff2eu,0x26170eafu),\nuvec4(0x0c1b0c7bu,0x00070400u,0x15000407u,0x55005590u),\nuvec4(0x00040700u,0x18040005u,0x05f5f504u,0x0804c0f0u),\nuvec4(0x07a0f004u,0xffff0408u,0x0e086fffu,0x3e172eefu),\nuvec4(0x8fffffffu,0x5b26172eu,0x040c2b0cu,0x07000408u),\nuvec4(0xa0050004u,0x151400b5u,0x07080400u,0xf025f5f5u),\nuvec4(0x040801c0u,0x0804a0f0u,0xffff0e04u,0xff085fffu),\nuvec4(0x3e16071eu,0x8fffffffu,0x160b262eu,0x096b0d0bu),\nuvec4(0x07050017u,0x60050004u,0x00e52015u,0xf5070804u),\nuvec4(0xd0f035f5u,0xf0010704u,0x04080490u,0xffffff0eu),\nuvec4(0x1fff0e5fu,0x060b060eu,0xffff1e07u,0x072e8fffu),\nuvec4(0x0705bb16u,0x17050004u,0x0807e5d0u,0x45f5f507u),\nuvec4(0x0804d0f0u,0x0490f004u,0xff0e0408u,0x7fffffffu),\nuvec4(0x061b061eu,0xffffff2eu,0x36171e6fu,0x040705abu),\nuvec4(0x05501710u,0xd5001510u,0x08070400u,0xf5f50004u),\nuvec4(0x17e0f045u,0x080190f0u,0xffff0602u,0x1e7fffffu),\nuvec4(0x3e061b06u,0x5fffffffu,0xcb06072eu,0x0407000cu),\nuvec4(0x15011710u,0x75000560u,0x15000500u,0x04180400u),\nuvec4(0x55f5f500u,0x0804e0f0u,0xc005b004u,0xff060204u),\nuvec4(0x8fffffffu,0x061b070eu,0xffff3e07u,0x164e2fffu),\nuvec4(0x0c2b0c8bu,0x00040700u,0x04070405u,0x25a00500u),\nuvec4(0x05200500u,0x08070500u,0xf5000407u,0xf0f065f5u),\nuvec4(0xc005b017u,0xff040704u,0x8fffffffu,0x061b060eu),\nuvec4(0xffffff5eu,0x0e072e1fu,0xbb060b06u,0x0408040cu),\nuvec4(0x05080410u,0x05400510u,0x35101530u,0x08070400u),\nuvec4(0x00351004u,0xe5f50025u,0x0804f0f0u,0x0480f004u),\nuvec4(0xff0e0408u,0x7fffffffu,0x060b061eu,0xff2e0f2eu),\nuvec4(0x173effffu,0x000cbb26u,0x07040517u,0x40250004u),\nuvec4(0x00050005u,0x10250015u,0x07080704u,0x00650005u),\nuvec4(0xf015f5f5u,0x080400f0u,0x0780f001u,0xffff0e02u),\nuvec4(0x1e7fffffu,0x6e060b06u,0x3effffffu,0x0d6b4607u),\nuvec4(0x3400092bu,0x10250005u,0x00152005u,0x00150015u),\nuvec4(0x08070405u,0xf5000407u,0xf0f0b5f5u,0xf0020710u),\nuvec4(0xffff2780u,0x1e7fffffu,0x0e0f3e16u,0xffff1e0fu),\nuvec4(0x66072edfu,0x050009abu,0x05200530u,0x25101540u),\nuvec4(0x00043704u,0xf0d5f5f5u,0x080410f0u,0x0470f004u),\nuvec4(0xffff0708u,0x1e7fffffu,0x3e3f2e06u,0x2ebfffffu),\nuvec4(0x099b8607u,0x24004500u,0x45100510u,0x15141714u),\nuvec4(0xf5009500u,0xf0f035f5u,0x01080220u,0x080460f0u),\nuvec4(0xffffff07u,0x061e7fffu,0x172e1f3eu,0x2eafffffu),\nuvec4(0x099b8617u,0x17003500u,0x01040704u,0x45000510u),\nuvec4(0x05002500u,0xf5100500u,0xf0f0c5f5u,0xf0011730u),\nuvec4(0x04080450u,0xffffff0eu,0x071e6fffu,0x062e0f4eu),\nuvec4(0xffff0e0bu,0x0e072e9fu,0x6b062b36u,0x00092b0cu),\nuvec4(0x10040745u,0x20153014u,0x00250005u,0xf5f52005u),\nuvec4(0x40f0f0c5u,0xf0050017u,0x0e020740u,0x1e8fffffu),\nuvec4(0x172ebfffu,0x0607084eu,0xffff060bu,0x36274e8fu),\nuvec4(0x0c8b161bu,0x00150900u,0x01150014u,0x15100500u),\nuvec4(0x15002500u,0xa5100520u,0xf5003500u,0x40f0f0c5u),\nuvec4(0x50f01701u,0x8fffff27u,0xafff0e08u,0x4e16072eu),\nuvec4(0x0e2b0708u,0x3e6fffffu,0x0e070e07u,0x260b4607u),\nuvec4(0x056b060bu,0x25101500u,0x00040704u,0x10051005u),\nuvec4(0xf5f50095u,0x50f0f0d5u,0x40f01701u,0xffff1804u),\nuvec4(0x1e2f088fu,0x072e5fffu,0x06171e46u,0xffff0e2bu),\nuvec4(0x3e072e6fu,0x09db2617u,0x08046510u,0x10052002u),\nuvec4(0x00151025u,0x10150065u,0xa5f51075u,0x0270f0f0u),\nuvec4(0x20f00107u,0xffff1801u,0x0f0e088fu,0xff0e1718u),\nuvec4(0x06372e2fu,0x0607061bu,0x072b0608u,0x4e5fffffu),\nuvec4(0x66071627u,0x25000c9bu,0x08272400u,0x10050004u),\nuvec4(0x30050095u,0x00851025u,0xf0f0a5f5u,0x04080480u),\nuvec4(0x070500f0u,0xffff0708u,0x37380e8fu,0x280e1fffu),\nuvec4(0x061b0637u,0x0e3b0708u,0x4e4fffffu,0x06070e17u),\nuvec4(0x362b0607u,0x25091c7bu,0x07680704u,0x15100500u),\nuvec4(0x25307510u,0x45f5f510u,0x0490f0f0u,0x07f00408u),\nuvec4(0xffff0718u,0x0e080e9fu,0x1c040708u,0x0718ff07u),\nuvec4(0x042b2416u,0x062b0617u,0x4e5fffffu,0x26070e17u),\nuvec4(0x061b261bu,0x04250c6bu,0x05078807u,0x35700500u),\nuvec4(0xf5103530u,0xf0f045f5u,0x020704a0u,0x2804c001u),\nuvec4(0xffff0e07u,0x072b06dfu,0x0708bf1eu,0x06671416u),\nuvec4(0xff1e063bu,0x173e5fffu,0x0b060716u,0x050c8b56u),\nuvec4(0x05b80400u,0x05900500u,0x1500b540u,0xf0a5f500u),\nuvec4(0x0201b0f0u,0x04b00408u,0xffffff48u,0x180e170eu),\nuvec4(0x07080e8fu,0x075b0d8bu,0x5fffff1eu,0x0706073eu),\nuvec4(0x0b160716u,0x1b0d3b46u,0x05090b0du,0x17180704u),\nuvec4(0x05000478u,0x55500500u,0x09006510u,0x1905990cu),\nuvec4(0x591c6935u,0xd0f0f00cu,0x04070204u,0x38071580u),\nuvec4(0x1fffffffu,0x084e282eu,0xfb06070fu,0xffff2e07u),\nuvec4(0x0e064e5fu,0x260b1627u,0x0c6b061bu,0x17380705u),\nuvec4(0x05000478u,0x35400510u,0x25100510u,0x09001500u),\nuvec4(0xf01cfcfcu,0x0524f0f0u,0xff481560u,0x2e3fffffu),\nuvec4(0xdb061e58u,0xff0e0716u,0x276e8fffu,0x6b061b56u),\nuvec4(0x04e8070cu,0xf5100500u,0x09250015u,0xf01cfcfcu),\nuvec4(0x05a0f0f0u,0xffff4804u,0x066e5fffu,0xff2e06ebu),\nuvec4(0x666e8fffu,0x060b260bu,0x280b0c5bu,0x0004b807u),\nuvec4(0x00a50005u,0xfcfc09a5u,0xf0f0f01cu,0x04000590u),\nuvec4(0xffffff58u,0x0b062e5fu,0x3e16db0cu,0x2e9fffffu),\nuvec4(0x06073627u,0x160b261bu,0x0c3b060bu,0x17782704u),\nuvec4(0x00250408u,0xfcfc65f5u,0xf0f0f02cu,0x04001590u),\nuvec4(0xffffff48u,0x06071e7fu,0x262b264bu,0xff0e1f4eu),\nuvec4(0x175e5fffu,0x07060716u,0x7b260b16u,0x7807341cu),\nuvec4(0x05001514u,0xf5100500u,0x2cfcfc35u,0xa0f0f0f0u),\nuvec4(0x48070005u,0xafffffffu,0x1e07260eu,0x060b1607u),\nuvec4(0x8fffff7eu,0x1b76174eu,0x1c0d3b36u,0x00150409u),\nuvec4(0x45077804u,0xb5203540u,0x1cfcfc09u,0xa0f0f0f0u),\nuvec4(0x48070005u,0xffffff0eu,0x06078e9fu,0xbfffff4eu),\nuvec4(0x0716075eu,0x6b263b46u,0x00150409u,0x35048804u),\nuvec4(0x85008540u,0x1cfcfc09u,0x11e0f0f0u,0x07000590u),\nuvec4(0xffffff58u,0xffff9eefu,0x56175ecfu,0x162b061bu),\nuvec4(0x353b0d2bu,0x40458807u,0x00350015u,0x2c090095u),\nuvec4(0xf0dcfc09u,0x05a0f0f0u,0xff580400u,0x3fffffffu),\nuvec4(0xdfffff3eu,0x0b36175eu,0x0b062b06u,0x040c4b26u),\nuvec4(0x78043507u,0x15001507u,0x65101500u,0x09008510u),\nuvec4(0xccfc093cu,0x05f0f0f0u,0xff5815a0u,0x4fffffffu),\nuvec4(0xffffff0eu,0x26071e1fu,0x460b1607u,0x0d0b260bu),\nuvec4(0x05140c3bu,0x78041504u,0x05001504u,0x45101510u),\nuvec4(0x05001500u,0xfc097500u,0x60f01cfcu,0x40f0f005u),\nuvec4(0xff580405u,0xffffffffu,0x0e4fffffu,0x0b171e0fu),\nuvec4(0x2b460706u,0x0b0c3b36u,0x0504070cu,0x68040114u),\nuvec4(0x25104507u,0x85205510u,0xf02cfcfcu,0x04e0f0f0u),\nuvec4(0xffffff48u,0xffffffffu,0x46074e4fu,0x560b160bu),\nuvec4(0x090b076bu,0x58071405u,0x20350407u,0x00e53015u),\nuvec4(0x2cfcfc05u,0xd0f0f0f0u,0x07040005u,0xffffff28u),\nuvec4(0xffffffffu,0x1b465e3fu,0x1b060b36u,0x0b076b06u),\nuvec4(0x27240025u,0x15201504u,0xf5102520u,0x2cfcfc09u),\nuvec4(0xf0f0f0f0u,0xff080420u,0xffffffffu,0x4e5fffffu),\nuvec4(0x0704ab96u,0x1500550bu,0x15001510u,0x15300500u),\nuvec4(0x25000500u,0xfc09a500u,0xf0052cfcu,0x20f0f0f0u),\nuvec4(0xffffff07u,0xffffffffu,0x66075e4fu,0x0c6b360bu),\nuvec4(0x050b0407u,0x25008500u,0x55101510u,0x05002500u),\nuvec4(0x0c097500u,0x0cfcfc09u,0xf0f0f0f0u,0xff080230u),\nuvec4(0xffffffffu,0x2e5fffffu,0x0b0c6bc6u,0x050c0407u),\nuvec4(0x25606500u,0x0510a510u,0xfc094510u,0xf0f02cfcu),\nuvec4(0x0430f0f0u,0xffff0e08u,0xffffffffu,0x2eff1e3fu),\nuvec4(0x4b560b46u,0x04072b0cu,0x1530050cu,0x25201580u),\nuvec4(0x55306510u,0xf02cfcfcu,0x40f0f0f0u,0xffff0e02u),\nuvec4(0xffffffffu,0x2eff1e3fu,0x7b561b36u,0x0c0a0804u),\nuvec4(0x20f00500u,0x20950005u,0x2cfcfc65u,0xf0f0f0f0u),\nuvec4(0xff080240u,0xffffffffu,0x2e1f0effu,0x06372eefu),\nuvec4(0x0c4b6607u,0x0a08041bu,0x5005900cu,0x00353015u),\nuvec4(0xfc555025u,0xf0f02cfcu,0x0440f0f0u,0xffffff08u),\nuvec4(0x0ecfffffu,0x3eef5e1fu,0x0e074627u,0x04078b16u),\nuvec4(0xa005800cu,0x10151005u,0x10050045u,0x2cfcfc55u),\nuvec4(0xf0f0f0f0u,0x08020540u,0xef2e7fffu,0x0837081eu),\nuvec4(0xdf5ecf0eu,0x0f2e1f0eu,0x0f0ecf9eu,0x071e173eu),\nuvec4(0x060e0726u,0x086b061bu,0x15000c04u,0xf5a01540u),\nuvec4(0x2cfcfc55u,0xf0f0f0f0u,0xff080450u,0x0e7f5e4fu),\nuvec4(0x07c21708u,0xa2070e6fu,0x6e070604u,0x3e0f7e0fu),\nuvec4(0x0e070e17u,0x27169ecfu,0x0a089b06u,0x3015000cu),\nuvec4(0x30155015u,0x15f50025u,0xf02cfcfcu,0xf015c0f0u),\nuvec4(0xff080460u,0x0e162e5fu,0xd2070207u,0x1e074231u),\nuvec4(0x3412f217u,0x27362706u,0x0706070eu,0x0706071eu),\nuvec4(0x16078edfu,0x0c5b2627u,0x0c0b070au,0x101540f0u),\nuvec4(0x1c0900f5u,0xf0fcfc09u,0x50f0f0f0u,0x4fff0701u),\nuvec4(0x0a16072eu,0x01f15204u,0x81047204u,0x050a24e2u),\nuvec4(0x160b0a01u,0xcf270607u,0x070e077eu,0x9b260716u),\nuvec4(0xf00c0b08u,0x75200540u,0x55001500u,0xf02cfcfcu),\nuvec4(0x60f0f0f0u,0x5fff0802u,0x220e170eu,0x1281f104u),\nuvec4(0x4221f104u,0x161b0d81u,0xcf1e070bu,0x4607167eu),\nuvec4(0x0c0b0c6bu,0x0c04080au,0x100540f0u,0x10351015u),\nuvec4(0x09252015u,0xf02cfcfcu,0x60f0f0f0u,0x5fff1804u),\nuvec4(0x320e0f1eu,0x14510491u,0xf1f13431u,0x0b062b09u),\nuvec4(0x7edf1e06u,0x1b0c6b76u,0x0c040804u,0x002560f0u),\nuvec4(0xfc850055u,0xf0f02cfcu,0x0270f0f0u,0x0e9fff08u),\nuvec4(0x14721192u,0x11f11441u,0x0aa11204u,0x07160b06u),\nuvec4(0x8edf2e06u,0x160b2607u,0x080b2c6bu,0x40f00c04u),\nuvec4(0x00551005u,0x09850015u,0xf01cfcfcu,0x70f0f0f0u),\nuvec4(0x9fff1804u,0xe2f2f20eu,0x01048104u,0x5e07160au),\nuvec4(0x0b369edfu,0x1b0c3b26u,0x04070b1cu,0x1570f00cu),\nuvec4(0xc5003500u,0xf0fcfc09u,0x70f0f0f0u,0xff0e1704u),\nuvec4(0xf2f20e9fu,0x310211d2u,0x0b141204u,0x7edf7e06u),\nuvec4(0x162b1617u,0x172b1c5bu,0x05b0050cu,0xa5007590u),\nuvec4(0xfcfc0900u,0xf005b0f0u,0x70f00520u,0xff080702u),\nuvec4(0xf2f20eafu,0x220112f2u,0x7e160d04u,0x8b369edfu),\nuvec4(0x0b173b1cu,0x8015a005u,0x10050055u,0x09550045u),\nuvec4(0x90f0fcfcu,0xd0f0f005u,0x08070204u,0xf208afffu),\nuvec4(0x0432f2f2u,0xff6e160du,0x0b06179eu,0x6b160b06u),\nuvec4(0x08041b1cu,0x15a0050bu,0x85008570u,0xfc092500u),\nuvec4(0xf0f0f0fcu,0x070290f0u,0xafff0e08u,0xf2f2f208u),\nuvec4(0x060b0112u,0x0f4ecfbeu,0x1b16073eu,0x0804bb16u),\nuvec4(0x15a00504u,0x35102530u,0x15102500u,0x05103500u),\nuvec4(0xfcfc0500u,0xf0f0f00cu,0x071490f0u,0x07bfff08u),\nuvec4(0x04f2f2f2u,0xafbe060bu,0x173e1f6eu,0x3b0c8b36u),\nuvec4(0xa0090408u,0x20351015u,0x00957015u,0x0cfcfc05u),\nuvec4(0xf0f0f0f0u,0x0e0804b0u,0x1f0e8fffu,0xc2f2f207u),\nuvec4(0xce170604u,0x1617deafu,0x1c7b060bu,0x170b0c0bu),\nuvec4(0x1015a009u,0x40154025u,0x00351005u,0x0cfcfc55u),\nuvec4(0xf0f00580u,0x0420f0f0u,0xbfff0e08u,0x92f2f208u),\nuvec4(0x070e0714u,0x17ee8feeu,0x0b3c7b36u,0x15a00917u),\nuvec4(0x35301510u,0x75203510u,0xfcfc0900u,0xf015700cu),\nuvec4(0x20f0f0f0u,0xff080705u,0xf2f20ecfu,0xfe060472u),\nuvec4(0xfe6f1e0fu,0x3c1b5607u,0x0c0b0c1bu,0x0b08041bu),\nuvec4(0x053005a0u,0x15000530u,0x15000510u,0x09006530u),\nuvec4(0x800cfcfcu,0xf0f0f005u,0x180430f0u,0x1f0eafffu),\nuvec4(0x42f2f207u,0x6f3efe07u,0x3b361efeu,0x1b2c1b3cu),\nuvec4(0xa0040804u,0x40054005u,0x30450015u,0xfc090065u),\nuvec4(0xf0f00cfcu,0x07e0f0f0u,0xdfff0e08u,0xf2f2070eu),\nuvec4(0x9f3efe07u,0x171617feu,0x2c0b0c2bu,0x081b4c0bu),\nuvec4(0x05900507u,0x45400530u,0x25009500u,0xfcfc0900u),\nuvec4(0x0520f00cu,0xa0f0f0f0u,0xffff180au,0xa2f2080fu),\nuvec4(0x6e0f9e07u,0x6e9f1e1fu,0x06178e07u,0x0b0c5b17u),\nuvec4(0x0b0c1b0cu,0x08072b0cu,0x10158004u,0x00154025u),\nuvec4(0x00951005u,0xfcfc0935u,0xf0f0f00cu,0x1806f0f0u),\nuvec4(0x0e1fffffu,0x2722f218u,0x2efe0f0eu,0x4ebf0e0fu),\nuvec4(0x06277e17u,0x0b2c6b17u,0x08044b0cu,0xa0059004u),\nuvec4(0x10851025u,0xfc051005u,0x05801cfcu,0xf0f01530u),\nuvec4(0x0e00f0f0u,0x4fffff18u,0x0817181eu,0xfe3f0e87u),\nuvec4(0x074eef3eu,0x1706277eu,0x3c0b0c6bu,0x041b0c1bu),\nuvec4(0x05900208u,0x25002590u,0x85000500u,0xfcfc0500u),\nuvec4(0xf025c01cu,0x00f0f0f0u,0x08030e04u,0x0e1fffffu),\nuvec4(0xfeff0e0fu,0x0f1e0f4eu,0x0f0e9f0eu,0x07060efeu),\nuvec4(0x0c2b0608u,0x0c2b3c2bu,0x0507083bu,0x15900580u),\nuvec4(0xc5100520u,0xf01cfcfcu,0xf0f0f0f0u,0x0e180610u),\nuvec4(0x0e3fffffu,0xfe1f1e0fu,0x0eaf1efeu,0x2e179e0fu),\nuvec4(0x07060e07u,0x2c3b0708u,0x1c2b3c0bu,0x0408072bu),\nuvec4(0x35b00580u,0x45000510u,0xfcfc4500u,0xf0f0f01cu),\nuvec4(0x0720f0f0u,0x3fffff18u,0x1f0e4f0eu,0x0f1e2f0eu),\nuvec4(0x7eaf7efeu,0x2e071e1fu,0x06070e07u,0x6c5b0708u),\nuvec4(0x042b1c2bu,0x15700408u,0x25000590u,0x05003510u),\nuvec4(0xfc093520u,0xf0f01cfcu,0x20f0f0f0u,0xff180e01u),\nuvec4(0x0f2e6fffu,0x5ebffefeu,0x16273e1fu,0x1b070807u),\nuvec4(0x0b1c1b7cu,0x07086b0cu,0x05500500u,0x05700510u),\nuvec4(0x25606510u,0x1cfcfc09u,0xf0f0f0f0u,0x0f0630f0u),\nuvec4(0x5fffff18u,0xdf1efefeu,0x080726deu,0x0c0bac3bu),\nuvec4(0x041b0d3bu,0x15600508u,0x25300540u,0x05401500u),\nuvec4(0xfcfc2540u,0xf0f0f02cu,0x0640f0f0u,0xff08070fu),\nuvec4(0x0f1e4fffu,0x9f0efefeu,0x0f2e1f1eu,0x0807266eu),\nuvec4(0x2b1c4b04u,0x08046b6cu,0x00156004u,0x20157015u),\nuvec4(0x30251015u,0xfcfc0925u,0xf0f0f01cu,0x1e50f0f0u),\nuvec4(0xffff0802u,0x0efefe6fu,0x0e079e9fu,0x060b0627u),\nuvec4(0x1c4b0402u,0x0c4b8c0bu,0x08071b0du,0x40050004u),\nuvec4(0x10058005u,0x09c53005u,0x6c099cfcu,0xf0f0f0f0u),\nuvec4(0x1e0150f0u,0xffff0802u,0x1efefe4fu,0x17066ebfu),\nuvec4(0x0c0b1746u,0x0c0b0c1bu,0x2c1b3c0bu,0x0408049bu),\nuvec4(0x15400500u,0x05000570u,0x75103520u,0xfcfc0900u),\nuvec4(0xf0f0f01cu,0x0160f0f0u,0x0803080fu,0x2fffffffu),\nuvec4(0x7ffe1f0eu,0x176e1f0eu,0x0b06170eu,0x1c1b1704u),\nuvec4(0x3c2b0c1bu,0x0a8b3c0bu,0x05900708u,0x55200540u),\nuvec4(0x15005520u,0x1cfcfc09u,0x90f0f0f0u,0x04c0f005u),\nuvec4(0x0802080eu,0x5fffffffu,0x2f2e1f1eu,0x5f2e0f2eu),\nuvec4(0x0e16078eu,0x060b0607u,0x3c3b0708u,0x0c7b6c2bu),\nuvec4(0x070b0c0bu,0x15700508u,0x65200520u,0xfc09a510u),\nuvec4(0xf0f01cfcu,0xf01580f0u,0x080f0ad0u,0xffff0802u),\nuvec4(0x4f0e4fffu,0x077eef0eu,0x0708462eu,0x4c2b2c4bu),\nuvec4(0x04cb0c0bu,0x10050408u,0x10050005u,0x10251015u),\nuvec4(0x092500f5u,0xf01cfcfcu,0xf0f0f0f0u,0x080f0490u),\nuvec4(0xffff0802u,0xef0e9fffu,0x1e07064eu,0x0b061e07u),\nuvec4(0x07080706u,0x1c9b0c2bu,0x126b0d8bu,0x20153005u),\nuvec4(0x60051005u,0xfcfc09f5u,0xf0f0f01cu,0x04a0f0f0u),\nuvec4(0x0802080fu,0xffffffffu,0x5e2f0e2fu,0x0e271607u),\nuvec4(0x2b271607u,0xab2c9b0cu,0x08044b0du,0x05200504u),\nuvec4(0x05400530u,0xfc09f530u,0xf0f01cfcu,0xb0f0f0f0u),\nuvec4(0x02080f04u,0xffffff08u,0x0f1e2fffu,0x0b17564eu),\nuvec4(0x04080706u,0x0c2b0c0bu,0x2c4b0c2bu,0x027b0d8bu),\nuvec4(0x05500a08u,0x05000500u,0xfc09f570u,0xf0f01cfcu),\nuvec4(0xa0f0f0f0u,0x0e0a0005u,0xff080208u,0x0fffffffu),\nuvec4(0x074e0f0eu,0x17760b06u,0x2b3c5b04u,0xfb1c0b0cu),\nuvec4(0x0a1b0c0bu,0x00050408u,0x60351005u,0x00151005u),\nuvec4(0x2cfcfcc5u,0xf0f0f0f0u,0x0e09d0f0u,0xff080208u),\nuvec4(0x0fffffffu,0x560b274eu,0x3b070807u,0x1b0c3b6cu),\nuvec4(0x024bfb0cu,0x25200c07u,0x25300520u,0x65106500u),\nuvec4(0xf02cfcfcu,0xf0f0f0f0u,0x08021ef0u,0xefffffffu),\nuvec4(0x0716072eu,0x1b061b16u,0x0b061706u,0xfb5c2b1cu),\nuvec4(0x040804cbu,0x20251009u,0x00655005u,0x2cfcfc95u),\nuvec4(0xf0f0f0f0u,0x0700f0f0u,0xff080218u,0x2ebfffffu),\nuvec4(0x26070607u,0x4c8b274bu,0x04cb06fbu,0x00050c07u),\nuvec4(0x35f57025u,0x1cfcfc09u,0xf0f0f0f0u,0x0610f0f0u),\nuvec4(0x0802080fu,0x9fffffffu,0x2b46073eu,0x04020706u),\nuvec4(0x2c1b2c3bu,0xab162bfbu,0x04020d0cu,0x70450009u),\nuvec4(0xfc0915f5u,0xf0f01cfcu,0xf0f0f0f0u,0x080e0420u),\nuvec4(0xff0e0802u,0x0e4fffffu,0x26172e1fu,0x4b17043bu),\nuvec4(0x0b0c2b1cu,0xdb1c0b0cu,0xab260b16u,0x0d07040cu),\nuvec4(0x10150005u,0x00156005u,0xfcfc09e5u,0xf0f0f01cu),\nuvec4(0x30f0f0f0u,0x13080e0au,0xffffff0eu,0x36173e4fu),\nuvec4(0x0407042bu,0x0c2b1c3bu,0x0d8b2c1bu,0x6b0d565bu),\nuvec4(0x0b0c1b1cu,0x25140c04u,0x05200500u,0xf5100510u),\nuvec4(0xf01cfcfcu,0xf0f0f0f0u,0x000520f0u,0x080f0e04u),\nuvec4(0xffff0802u,0x0f0e1fffu,0x2b16272eu,0x1c5b1706u),\nuvec4(0x06ab4c2bu,0x160b263bu,0x4c5b063bu,0x35040724u),\nuvec4(0x25100510u,0xfcfcd510u,0xf0f0f01cu,0x50f0f0f0u),\nuvec4(0x080f0e05u,0xffff0802u,0x272e1fffu,0x24061b16u),\nuvec4(0x1c3b0c0bu,0x1c1b3c1bu,0x160b066bu,0x064b462bu),\nuvec4(0x02041c8bu,0x15042807u,0xf5101500u,0xfcfc0925u),\nuvec4(0xf0f0f01cu,0x70f0f0f0u,0x02080f0eu,0xffff0803u),\nuvec4(0x06272eefu,0x140b0d0bu,0x0c0b0c0bu,0x1c2b4c0bu),\nuvec4(0x066b066bu,0x2607360bu,0x061b060bu,0x02040cabu),\nuvec4(0x05075807u,0x15000509u,0x35207510u,0x1cfcfc09u),\nuvec4(0xf0f0f0f0u,0x0570f0f0u,0x080f0e07u,0xffff0802u),\nuvec4(0x26073ebfu,0x0c0b141bu,0x1c0b6c2bu,0x0b261bfbu),\nuvec4(0xbb161706u,0x021c1b0cu,0x07680704u,0x65000905u),\nuvec4(0x45003500u,0xfcfc0900u,0x05b0f01cu,0xf0f0f0f0u),\nuvec4(0x1f0204b0u,0xff080208u,0x073e9fffu,0x14060b26u),\nuvec4(0x1c0b2c9bu,0x762b06bbu,0xcb060b17u,0x020c0b0du),\nuvec4(0x48171807u,0x00050905u,0x00450015u,0xfc090075u),\nuvec4(0xf0f01cfcu,0xf0f0f0f0u,0x1f080290u,0x0807080eu),\nuvec4(0x3e7fffffu,0x3b040726u,0xdb0c3b1cu,0x47167b06u),\nuvec4(0x5b161716u,0x02047b06u,0x38141807u,0x050c0507u),\nuvec4(0xc5101500u,0xfcfc0500u,0xf0f0f01cu,0x90f0f0f0u),\nuvec4(0x2f0e0802u,0x0e080708u,0x2e4fffffu,0x1c0b1437u),\nuvec4(0x0c0b0c0bu,0x26bb1c1bu,0x265b060bu,0x36070e57u),\nuvec4(0x049b062bu,0x07280402u,0x0c050438u,0x00059005u),\nuvec4(0xfc450015u,0xf0f01cfcu,0xf0f0f0f0u,0x07020490u),\nuvec4(0x02083f0eu,0xffff0e08u,0x0a02274eu,0x0c6b0c7bu),\nuvec4(0x4e07f64bu,0x3bc60e07u,0x02040b06u,0x05047807u),\nuvec4(0x3520050cu,0x25102530u,0x1cfcfc09u,0xf0f0f0f0u),\nuvec4(0x0190f0f0u,0x070e0702u,0x07082f0eu,0xff0e0802u),\nuvec4(0x1e0f2eafu,0x6b041217u,0x3b0c0b1cu,0x1ee65b0cu),\nuvec4(0x56174e17u,0x260b160bu,0x0804361bu,0x09047804u),\nuvec4(0x1005400cu,0x20152005u,0xfcfc0925u,0xf0f0f01cu),\nuvec4(0xa0f0f0f0u,0x170e0802u,0x180e2f1eu,0xff0e0807u),\nuvec4(0x0e0f4e3fu,0x8b140228u,0x4b1c1b3cu,0x07160b06u),\nuvec4(0x17262736u,0x3607169eu,0x0627061bu,0x0617160bu),\nuvec4(0x07582417u,0x05c0090cu,0x09001520u,0xf01cfcfcu),\nuvec4(0xf0f0f0f0u,0x7e12a0f0u,0x0e181e1fu,0x0f0e2fffu),\nuvec4(0x0702281eu,0x1c7b0406u,0x0c0b3c0bu,0x0e27264bu),\nuvec4(0xae070687u,0x06070e07u,0x0e173617u,0x070e0736u),\nuvec4(0x04071802u,0x0c044807u,0x70151005u,0x09251025u),\nuvec4(0xecfc091cu,0xf0f0f0f0u,0x04a0f0f0u,0x2f8e0802u),\nuvec4(0x180e582eu,0x080e0f1eu,0x1807180eu,0x3b063702u),\nuvec4(0x2b2c4b0cu,0x27165b1cu,0x071e074eu,0x17de270eu),\nuvec4(0x1716070eu,0x0827162eu,0x14280702u,0x050c0448u),\nuvec4(0x150035b0u,0xfc090c09u,0xf0f00cfcu,0xf0f0f0f0u),\nuvec4(0x080204a0u,0x1e1fbe0fu,0x17082728u,0xcb168708u),\nuvec4(0x2b1c1b0cu,0x17064b0du,0x173e074eu,0x271e17feu),\nuvec4(0x0e07164eu,0x18170207u,0x07050004u,0x0c043704u),\nuvec4(0x25800510u,0x09000510u,0xfcfc090cu,0xf0f0f00cu),\nuvec4(0xb0f0f0f0u,0x068e0802u,0x8e07260bu,0x060b1667u),\nuvec4(0x0ccb0d1bu,0x363b2c2bu,0x9e07ae07u,0x7e0f0e0fu),\nuvec4(0x07264e27u,0x18170802u,0x14070407u,0x04022407u),\nuvec4(0x20150005u,0x20252005u,0x092c0915u,0xf0f0ecfcu),\nuvec4(0xf0f0f0f0u,0x080204b0u,0x4b166e0fu,0x6b161b16u),\nuvec4(0x0dabfb06u,0xfe27162bu,0x2f1e0f3eu,0x0706077eu),\nuvec4(0x1812076eu,0x07480204u,0x0c090418u,0x00040204u),\nuvec4(0x70052015u,0x1c090005u,0xf0ecfc19u,0xf0f0f0f0u),\nuvec4(0x0204b0f0u,0x078e0f08u,0x5b060b06u,0x0cbbfb0cu),\nuvec4(0x160b0c4bu,0xfe17260bu,0x276e5f3eu,0x9802077eu),\nuvec4(0x3c041807u,0x00040204u,0xfc09b015u,0xf0f02cfcu),\nuvec4(0xf0f0f0f0u,0x080205b0u,0x4e2f1e1fu,0xfbfb1627u),\nuvec4(0xfe07367bu,0x7f0e0f2eu,0x070e076eu,0xa802077eu),\nuvec4(0x0b0c0b14u,0x04050b16u,0x30250402u,0x0c094005u),\nuvec4(0x0cfcfc09u,0xf0f0f0f0u,0x12c0f0f0u,0x0f2e1f08u),\nuvec4(0xabfb368eu,0x17466b0du,0xfeaf2efeu,0x1507b80eu),\nuvec4(0x0f0e0b09u,0x040b061eu,0x05800512u,0xfcfc0900u),\nuvec4(0xf0f0f02cu,0xc0f0f0f0u,0x1f070804u,0x376e0f4eu),\nuvec4(0x162bfb36u,0xfe27466bu,0x072eef2eu,0x0f3e0f4eu),\nuvec4(0x150004b8u,0x061e2f0eu,0x1500121bu,0x05400500u),\nuvec4(0xfc092c09u,0xf0f0f0ecu,0xc0f0f0f0u,0x2f02080bu),\nuvec4(0x0f0e2f2eu,0x3b16078eu,0x0b261b06u,0x0b16cb06u),\nuvec4(0x3efe0736u,0x0f7e0fffu,0xa802084eu,0x0e041504u),\nuvec4(0x0c0b0e5fu,0x05002512u,0xfc090530u,0xf0f02cfcu),\nuvec4(0xf0f0f0f0u,0x020705c0u,0x6f1e1f08u,0x0b66277eu),\nuvec4(0x0b261b26u,0x17a60b06u,0x1fff2efeu,0x074e1f6eu),\nuvec4(0x1504b802u,0x0e6f0804u,0x02040b06u,0x05100504u),\nuvec4(0x093c0520u,0xf0f0ecfcu,0xf0f0f0f0u,0x080207d0u),\nuvec4(0x8e7f0e3fu,0x161b5607u,0x1657561bu,0x0f4efe27u),\nuvec4(0x172eff0eu,0x081e2f1eu,0x04c81702u,0x8f080705u),\nuvec4(0x12040b0eu,0x05300500u,0x091c090cu,0xf0f0ecfcu),\nuvec4(0xf0f0f0f0u,0x080304d0u,0x0e7f0e3fu,0x56076e1fu),\nuvec4(0x6e17660bu,0x0f0efe27u,0x6e4fff1eu,0x07020e3fu),\nuvec4(0x04b81718u,0x0e9f0e07u,0x04120406u,0x19150015u),\nuvec4(0xf01cfcfcu,0xf0f0f0f0u,0x0204d0f0u,0x9f0e4f08u),\nuvec4(0x2736375eu,0x071e2706u,0x172e071eu,0x0f1e0ffeu),\nuvec4(0x5e5fff0eu,0x28120e3fu,0x07b80407u,0x060ecf08u),\nuvec4(0x25011204u,0xfcfc190cu,0xf0f0f00cu,0xd0f0f0f0u),\nuvec4(0x4f080705u,0x0f0e9f0eu,0x07ee078eu,0x0e3f3efeu),\nuvec4(0x1f4e6fffu,0x020e0f0eu,0xdf0e28f8u,0x120a060eu),\nuvec4(0x09050004u,0xfcfc090cu,0xf0f0f00cu,0xe0f0f0f0u),\nuvec4(0xff0e0207u,0xfe0f0e0fu,0x2e0f2efeu,0xcfff1e0fu),\nuvec4(0x0f0e2f4eu,0x07a80208u,0x1fff4804u,0x12040607u),\nuvec4(0xfc290c05u,0xf00c09dcu,0xf0f0f0f0u,0x0204e0f0u),\nuvec4(0x8f1e4f08u,0xfefe0f1eu,0xff0e2f5eu,0x2e1f4ecfu),\nuvec4(0x0710a812u,0x0e040708u,0x070e2fffu,0x0c04120bu),\nuvec4(0xf0fcfc19u,0xf0f0f0f0u,0x0204e0f0u,0xde5fff08u),\nuvec4(0x2f2efe0fu,0x3edfff0eu,0x48120e3fu,0x15072834u),\nuvec4(0xff0e0604u,0x040b0e5fu,0x091c0402u,0xf0f0ecfcu),\nuvec4(0xf0f0f0f0u,0x020804e0u,0xfebf0e7fu,0x4fbe0f1eu),\nuvec4(0x3eefff1eu,0x08020e2fu,0x00244807u,0x8fff2738u),\nuvec4(0x1204070eu,0x099cfc04u,0xf0f0f04cu,0xe0f0f0f0u),\nuvec4(0x08020705u,0x2eaf1e6fu,0x3e1f5e0fu,0xffffbe1fu),\nuvec4(0x1e0f0e6fu,0x9802082fu,0xff0e5807u,0x22060eafu),\nuvec4(0xf0dcfc09u,0xf0f0f0f0u,0x0207f0f0u,0x0ebfff08u),\nuvec4(0x7e0f0e8fu,0x0e7fffffu,0x0e2f0e1fu,0xff18f802u),\nuvec4(0x12042ebfu,0xf0ccfc04u,0xf0f0f0f0u,0x1806f0f0u),\nuvec4(0x6e6fffffu,0x0e9fffffu,0x1702085fu,0xffd80208u),\nuvec4(0x04073ebfu,0x9cfc0412u,0xf0f0f009u,0xf0f0f0f0u),\nuvec4(0xff020804u,0xff4e9fffu,0x4f1e8fffu,0x02082718u),\nuvec4(0x0e040798u,0x065ebfffu,0xfc041204u,0xf0f0097cu),\nuvec4(0xf0f0f0f0u,0x020705f0u,0x8fffff0eu,0xffffff0eu),\nuvec4(0xf8020e2fu,0xdfff0704u,0x2204075eu,0xf06cfc04u),\nuvec4(0xf0f0f0f0u,0x0705f0f0u,0xffff0802u,0x8fffffffu),\nuvec4(0xe8072f0eu,0x0e0b0407u,0x4e0fffffu,0x05220406u),\nuvec4(0xf0f04cfcu,0xf0f0f0f0u,0x020700f0u,0xffffff08u),\nuvec4(0x0e7fffffu,0x07a80e2fu,0x0b000428u,0x4fffff0eu),\nuvec4(0x0b070f1eu,0xfc042205u,0xf0f0f02cu,0xf0f0f0f0u),\nuvec4(0x02080600u,0xffffffffu,0x0f0e6fffu,0x3804780eu),\nuvec4(0x08041204u,0xff0e0c04u,0x3e7f0edfu,0x04090b06u),\nuvec4(0xfc050402u,0xf0f0f00cu,0xf0f0f0f0u,0x02080400u),\nuvec4(0xffffff08u,0x086fffffu,0x08245807u,0x04021817u),\nuvec4(0x07060400u,0x5f0eefffu,0x063e2f0eu,0x0204090cu),\nuvec4(0xf031fc04u,0xf0f0f0f0u,0x0705c0f0u,0xffff0802u),\nuvec4(0x4fffffffu,0x6807080eu,0x00071807u,0x0e173807u),\nuvec4(0x7f0effffu,0x064e0f0eu,0x0914091cu,0x0d1405acu),\nuvec4(0xf0f0f081u,0x70f0f0f0u,0xff0e1207u,0xffffffffu),\nuvec4(0x14b8023fu,0xff380218u,0x5f0e0fffu,0x0f0e1f1eu),\nuvec4(0x1c0b073eu,0x248c140au,0x514a4102u,0xf0f0f0f0u),\nuvec4(0x0610f0f0u,0xff080208u,0xffffffffu,0x08f80e1fu),\nuvec4(0x08072802u,0x2eefffffu,0x0b070e0fu,0x0b6c241cu),\nuvec4(0x013d412cu,0x511a011du,0xf0f0f0f0u,0x0804c0f0u),\nuvec4(0xffff0802u,0x1fffffffu,0x2807c807u,0x07041802u),\nuvec4(0xefffff08u,0x2c0b075eu,0x51396c0au,0x113d411au),\nuvec4(0xf0f0410au,0x80f0f0f0u,0xff120e0au,0xffffffffu),\nuvec4(0xc802080fu,0x04071832u,0xffff0e08u,0x5ecf0e0fu),\nuvec4(0x0b060e0fu,0x091c292cu,0x0d41092bu,0xc11d611au),\nuvec4(0xf0f0f0f0u,0x080e40f0u,0xffff0e02u,0x07ffffffu),\nuvec4(0x5802b802u,0xff0e0704u,0xef0e1fffu,0x177e1f0eu),\nuvec4(0x1e07040au,0x0d811e0fu,0x5a610d51u,0xf0f0f041u),\nuvec4(0x0806f0f0u,0xffff0802u,0x08ffffffu,0x0402b802u),\nuvec4(0x0e070437u,0x1fffffffu,0x3f6e0f1eu,0x0e1f1817u),\nuvec4(0x710a610fu,0x2a1d610du,0x512a010du,0xf0f0f0f0u),\nuvec4(0x08120480u,0xffff0802u,0x02ffffffu,0x040004c8u),\nuvec4(0xffff1817u,0x0f6e7fffu,0x180e1f1eu,0x510f0e0fu),\nuvec4(0x0d510d0au,0x010a0d81u,0xf0f0e12au,0x0410f0f0u),\nuvec4(0x08070412u,0xffffff12u,0x0208efffu,0x14070298u),\nuvec4(0xffff0705u,0x2f7ebfffu,0x0e180f0eu,0x010d411fu),\nuvec4(0x1a31f10du,0xf0f031f1u,0x1201b0f0u,0x02072804u),\nuvec4(0xffffff08u,0x0208dfffu,0x12480228u,0x18020704u),\nuvec4(0xafffffffu,0x0f6e3f0eu,0x0e180f0eu,0xf10a6108u),\nuvec4(0x81f10a31u,0x70f0f0f0u,0x38040201u,0xff07020eu),\nuvec4(0xcfffffffu,0x0ef80218u,0x0e8fffffu,0x085e4fffu),\nuvec4(0x080e0f0eu,0x1a611802u,0x1a01f10du,0xf0f0e1f1u),\nuvec4(0x381220f0u,0xff02070eu,0xbfffffffu,0x02e80208u),\nuvec4(0xffff0e18u,0x0edf0e8fu,0x02186e5fu,0x510e0718u),\nuvec4(0x610d213au,0xf11a311au,0xf0f031f1u,0x074812d0u),\nuvec4(0xffff0802u,0x089fffffu,0x3802e802u,0xffffffffu),\nuvec4(0x0812084eu,0x5102081fu,0xf13af12au,0xf0f081f1u),\nuvec4(0x34020400u,0x07024832u,0xffff0e02u,0x087fffffu),\nuvec4(0xf8070812u,0xffffff18u,0x1e1f1eafu,0x1812081fu),\nuvec4(0x3a513f0eu,0x0d310d61u,0xf13a010au,0x90f0d1f1u),\nuvec4(0x48148201u,0x08020802u,0xffffffffu,0x48070e4fu),\nuvec4(0x38076807u,0x18041802u,0xcfffffffu,0x12081f1eu),\nuvec4(0x270e1f18u,0x611a7106u,0x211d310du,0xf1f1f11au),\nuvec4(0x0420f021u,0x15500422u,0x07024807u,0xffffff12u),\nuvec4(0x02083fffu,0x480218f8u,0xcfffffffu,0x07080f1eu),\nuvec4(0x1e0f1802u,0x31290c16u,0xf10a310du,0xf1f10a11u),\nuvec4(0x219071f1u,0x01041204u,0x58041550u,0x0e021802u),\nuvec4(0xffffffffu,0xf802081fu,0xff581208u,0xff1e9fffu),\nuvec4(0x12081f0eu,0x060e0f08u,0x3c190d04u,0xf10d41f1u),\nuvec4(0x41f1f1f1u,0x04520410u,0x00010025u,0x07051905u),\nuvec4(0x08120748u,0xffff0802u,0x0e0fffffu,0x2812e802u),\nuvec4(0x18040007u,0x0eafffffu,0x0e0f3ecfu,0x0f080208u),\nuvec4(0x3c19060eu,0xf1f12c09u,0xb1f1f1f1u,0x05311204u),\nuvec4(0x15240109u,0x04582409u,0xff120812u,0x0fffffffu),\nuvec4(0x2814e812u,0xff080714u,0xbf0ebfffu,0x0f0e0f1eu),\nuvec4(0x0e081208u,0x9c090d07u,0x1a910ac1u,0xf1f10d81u),\nuvec4(0x202261f1u,0x04120419u,0x0c090501u,0x04582204u),\nuvec4(0x08120812u,0xefffffffu,0x02e80208u,0x0e083714u),\nuvec4(0xafffffffu,0x12080f1eu,0x0d070e08u,0x0a0db1bcu),\nuvec4(0x1a611a01u,0xe1f1f1f1u,0x05041204u,0x05221510u),\nuvec4(0x04120439u,0x12044812u,0xff070218u,0x12efffffu),\nuvec4(0x022817a8u,0xffff1e18u,0x0f0ecfffu,0x0802080eu),\nuvec4(0x0b06071eu,0x1a0db1bcu,0xf1f11a81u,0x0422d1f1u),\nuvec4(0x09050905u,0x19011205u,0x12041905u,0x04581204u),\nuvec4(0x120e0812u,0x0f0eaf0eu,0xdfffff1eu,0x14b80208u),\nuvec4(0xffffff58u,0x1eaf0e0fu,0x0812080fu,0x26070e0fu),\nuvec4(0x3ac1ac0bu,0x1a310a11u,0xf1f10a21u,0x012271f1u),\nuvec4(0x19050603u,0x09051205u,0x78421915u,0x0e081204u),\nuvec4(0xaf0e0207u,0xff3e0f1eu,0x020e9fffu,0x073814c8u),\nuvec4(0xffff0e08u,0x0eaf0effu,0x0812080fu,0x06170e0fu),\nuvec4(0x819c0d2bu,0x011a210au,0x310a110du,0xf10a310au),\nuvec4(0x2261f1f1u,0x05071306u,0x05120109u,0x14120539u),\nuvec4(0x12146812u,0x02080e08u,0x2f9e9f08u,0x3fffff0eu),\nuvec4(0x07c80208u,0x08142804u,0x0fffffffu,0x1f0e6f0eu),\nuvec4(0x02080f0eu,0x06071f07u,0x1d0b2607u,0x311ac19cu),\nuvec4(0x210a310au,0xf1f1f11au,0x07333241u,0x39051215u),\nuvec4(0x05041204u,0x12147812u,0x9f121e07u,0x1f7e0f0eu),\nuvec4(0xff2e7f1eu,0x1802088fu,0x0704e802u,0xffffff08u),\nuvec4(0x0e8f0e0fu,0x0802080fu,0x360b071eu,0xc1ac1607u),\nuvec4(0x013a013au,0xf11a211au,0x3221f1f1u,0x12090653u),\nuvec4(0x12053905u,0x02040901u,0x02040788u,0x071e0704u),\nuvec4(0xde8f0802u,0x0e3f0e1fu,0x0208bfffu,0x04e80218u),\nuvec4(0xffffff18u,0x080f0e9fu,0x071e0702u,0x07260726u),\nuvec4(0xc18c0b16u,0x310a117au,0xc1f1f11au,0x53070672u),\nuvec4(0x0402040au,0x04020449u,0x02040509u,0x06041298u),\nuvec4(0x02080e07u,0x2efe6f08u,0x0e0f0e1fu,0x0208bfffu),\nuvec4(0x02680218u,0x08140748u,0x1fffffffu,0x0f0e3f3eu),\nuvec4(0x1e070208u,0x16272e17u,0x7c0b0617u,0x0a011ac1u),\nuvec4(0xf10d01f1u,0x014241f1u,0x0a010204u,0x15120183u),\nuvec4(0x00091239u,0x58020e06u,0x04122807u,0x8f121e16u),\nuvec4(0x0e3f0efeu,0x0207bfffu,0x12480228u,0x05040228u),\nuvec4(0xff080700u,0x0e1fffffu,0x0e0f0e3fu,0x0812080fu),\nuvec4(0x576e170eu,0x2ac16c04u,0xf1f10dc1u,0x0a114281u),\nuvec4(0x01129316u,0x02043905u,0x0e0a0504u,0x2802280fu),\nuvec4(0x14022807u,0x02071e16u,0x0f5e7f0eu,0x1e0f0efeu),\nuvec4(0x07085fffu,0x02880248u,0x0e040001u,0x8fffffffu),\nuvec4(0x12080f0eu,0x070e171eu,0x1706176eu,0xc14c0d16u),\nuvec4(0xf1f1f11au,0x06412251u,0x040206b3u,0x12050935u),\nuvec4(0x0f0e0501u,0x5802181eu,0x16140702u,0x02080e07u),\nuvec4(0xaefe4f08u,0x02087fffu,0x040208f8u,0xffffff0eu),\nuvec4(0x080f2e6fu,0x1e0f0702u,0x0e075e27u,0x4c0b1647u),\nuvec4(0x2a210a81u,0xf1f10a21u,0xc35642d1u,0x09350112u),\nuvec4(0x06001204u,0x02082e0fu,0x02280728u,0x07060708u),\nuvec4(0x08021e16u,0x0f3efe7fu,0xff0e0f2eu,0xf802075fu),\nuvec4(0xffff2802u,0x0f0e3fffu,0x120e0f2eu,0x070e271eu),\nuvec4(0x672e071eu,0x090c0b26u,0xf12ac11cu,0x3204f1f1u),\nuvec4(0x040733f3u,0x19150002u,0x0a011205u,0x080e2f0eu),\nuvec4(0x18142802u,0x06070802u,0x060b0607u,0x5f07020eu),\nuvec4(0x7fff6efeu,0x08f8270eu,0xffff2802u,0x0f3e3fffu),\nuvec4(0x081e1208u,0x4e071e47u,0x040b1647u,0x1a812c0bu),\nuvec4(0xf1f12a11u,0xf31622e1u,0x02010643u,0x12042915u),\nuvec4(0x3e0f0700u,0x12481208u,0x06070614u,0x120e060bu),\nuvec4(0xcf6efe5fu,0x02088f0eu,0x04e81e07u,0xffff3802u),\nuvec4(0x120e7fffu,0x170e0f08u,0x277e072eu,0x0b0d0b26u),\nuvec4(0x2ac12c0du,0xf1f10d41u,0x83f31271u,0x01020106u),\nuvec4(0x12190509u,0x0f0e0901u,0x580e0f2eu,0x06050024u),\nuvec4(0x0e1b060eu,0x2f0e0208u,0x1e0f8efeu,0x08172fffu),\nuvec4(0x3812f81eu,0x7fffffffu,0x0e080207u,0x16671ea7u),\nuvec4(0xc10c4d0au,0x91f1f12au,0x93f33204u,0x25020106u),\nuvec4(0x00120409u,0x3f0e0f06u,0x1007480eu,0x070b0004u),\nuvec4(0x070b160eu,0x5f080208u,0x4fff5efeu,0x17880208u),\nuvec4(0xff481278u,0x086fffffu,0xf70f0802u,0x16070627u),\nuvec4(0x1ad14d1au,0x3281f1f1u,0x000ab3f3u,0x05190102u),\nuvec4(0x1e0a0112u,0x08070e0fu,0x12080f0eu,0x00040708u),\nuvec4(0x06050005u,0x0b16070eu,0x08020e07u,0xff6efe4fu),\nuvec4(0x9802083fu,0x48070004u,0xffff4822u,0x02086fffu),\nuvec4(0x57f70f08u,0xd14d0a26u,0xf10a510au,0x041211f1u),\nuvec4(0x0215d3f3u,0x12011901u,0x071f0600u,0x17020812u),\nuvec4(0x14071802u,0x071e0b10u,0x07020e36u,0x1f6efe3fu),\nuvec4(0x070fff0eu,0x2817a802u,0xff0e5832u,0x085fffffu),\nuvec4(0xf70e0702u,0x3d1a1677u,0xf11ab1f1u,0xd3f33271u),\nuvec4(0x14090507u,0x05120419u,0x0702081eu,0x2812180eu),\nuvec4(0x00050407u,0x072e0602u,0x4f170e26u,0xff4e07eeu),\nuvec4(0xd802083fu,0x58021807u,0xffff0817u,0x12085fffu),\nuvec4(0x0617f70eu,0xf13d2667u,0x51f11ab1u,0xf3071204u),\nuvec4(0x090506f3u,0x0c050405u,0x0f060112u,0x88070208u),\nuvec4(0x05000407u,0x172e0204u,0x07060b06u,0x27ce5f02u),\nuvec4(0x0e0fff5eu,0x6814e802u,0xffff0e17u,0x12085fffu),\nuvec4(0xe716071eu,0x37061706u,0xd11d0a36u,0x211a210au),\nuvec4(0x4281f10du,0x0a13f3f3u,0x09050029u,0x0f060112u),\nuvec4(0x04b80208u,0x08020500u,0x0b06171eu,0x08020e06u),\nuvec4(0x5e17ce4fu,0x02081fffu,0x281205f8u,0xffff0e17u),\nuvec4(0x020e6fffu,0x47f71e07u,0x17260706u,0xc11d0a26u),\nuvec4(0x310a311au,0xf10a310du,0x04220401u,0x0433f3f3u),\nuvec4(0x05290509u,0x0f070112u,0x04b81207u,0x271e1200u),\nuvec4(0x08020e16u,0x2e37de3fu,0x12cf1e3fu,0x222807b8u),\nuvec4(0xffff1e18u,0x020e7fffu,0x97f71f07u,0x41f13a46u),\nuvec4(0x211d110du,0x0122f10au,0x43f3f30au,0x09250904u),\nuvec4(0x0e051205u,0x07c8120fu,0x3e071200u,0x3f180e17u),\nuvec4(0x0f1e07feu,0xbf1e2f1eu,0x1278020eu,0x08042258u),\nuvec4(0xffffff0eu,0x0802088fu,0x97f70e0fu,0x2a0d2a26u),\nuvec4(0x0a0d41f1u,0x12e10a51u,0xf3060104u,0x150a53f3u),\nuvec4(0x04120129u,0xd802071eu,0x4e071204u,0x5f170e07u),\nuvec4(0x1f2e27beu,0x020edf2eu,0x22480278u,0x08040004u),\nuvec4(0xffffff0eu,0x08070e7fu,0x87f70e1fu,0x2a064a16u),\nuvec4(0x04b1f1f1u,0xf3070a12u,0x090563f3u,0x06220925u),\nuvec4(0x0218071eu,0x04281768u,0x02077e12u,0x3e07de4fu),\nuvec4(0x0fff0e1fu,0x58026802u,0x15040802u,0xffff0804u),\nuvec4(0x0e088fffu,0xf7060e0fu,0x461a2677u,0xa1f1f12au),\nuvec4(0xf3f30722u,0x15190583u,0x06041209u,0x0228170eu),\nuvec4(0x04281458u,0x077e0712u,0x073e2f0eu,0x075e0f2eu),\nuvec4(0xff0e1f2eu,0x3228021fu,0x04020758u,0x08041005u),\nuvec4(0x7fffffffu,0x0a070f1eu,0x67f7060du,0x2a661a06u),\nuvec4(0x2291f1f1u,0x05a3f3f3u,0x07041249u,0x4812183eu),\nuvec4(0x04280704u,0x08176e12u,0x7e2f7e3fu,0x1fff0e1fu),\nuvec4(0x0102d802u,0xff040015u,0x06afffffu,0xf7060a1du),\nuvec4(0xf13a9657u,0x12a10ac1u,0xa3f3f304u,0x15090507u),\nuvec4(0x01120509u,0x02084e07u,0x38040748u,0x078e0412u),\nuvec4(0x1f8e2f08u,0xff0e1f7eu,0x02f8020fu,0xff070415u),\nuvec4(0x282e6fffu,0x2d06bf0eu,0x06b7f706u,0x0a0d361au),\nuvec4(0x1271f1f1u,0x06c3f3f3u,0x12350900u,0x124e0701u),\nuvec4(0x04000438u,0x9e071238u,0x0f7e1f02u,0xff7e0f0eu),\nuvec4(0x0702082fu,0x000502f8u,0xffff0e07u,0x07361e4fu),\nuvec4(0x0e081702u,0x2d0a0e6fu,0xa7f7160au,0x2a061726u),\nuvec4(0x0461f1f1u,0xc3f3f302u,0x15100107u,0x01120509u),\nuvec4(0x1206073eu,0x12381038u,0x0e07ae08u,0x4e2f7e0fu),\nuvec4(0x1fff2e07u,0xc80e0807u,0x04021807u,0x0f0e0705u),\nuvec4(0x0eefff2eu,0x07860e08u,0x0e080702u,0x0a1d072fu),\nuvec4(0xf7160a16u,0x261a36a7u,0x2251f1f1u,0x07b3f3f3u),\nuvec4(0x09152001u,0x2e041201u,0x48020417u,0x12280704u),\nuvec4(0x0e079e07u,0x6e1f0802u,0x3e072e3fu,0x020e0fffu),\nuvec4(0x1004b80eu,0x04020807u,0x2f0e0705u,0x0eafff2eu),\nuvec4(0x02261e08u,0x0e071286u,0x27161d06u,0x0697f736u),\nuvec4(0xf1f1362au,0xf3f31241u,0x053001e3u,0x01120109u),\nuvec4(0x1288223eu,0x0f6e0604u,0x020e071eu,0x3f6e1f08u),\nuvec4(0xff1e072eu,0x0007f81fu,0x04120804u,0x4f0e0700u),\nuvec4(0x079fff1eu,0x12260f0eu,0x060422a6u,0x26171627u),\nuvec4(0xf126d7f7u,0x020431f1u,0x01f3f3f3u,0x01090530u),\nuvec4(0x082e0512u,0x78040702u,0x060c1204u,0x1f0807beu),\nuvec4(0x071e5f5eu,0x180eff1eu,0x0104d80eu,0x14080218u),\nuvec4(0x0e5f1e07u,0x0f187fffu,0xb6022607u,0x22040a0bu),\nuvec4(0xf7261766u,0xf1871627u,0x020421f1u,0x03f3f3f3u),\nuvec4(0x09053001u,0x1e051204u,0x14080208u,0x27040708u),\nuvec4(0x04120014u,0x070207beu,0x3e4f7e0fu,0x08020effu),\nuvec4(0x1807a80eu,0x02080714u,0x2e140708u,0x1e2f0e1fu),\nuvec4(0x070e5fffu,0x1226070fu,0x3d360a56u,0x5622040au),\nuvec4(0x07f71627u,0xf1f19716u,0xf3f31221u,0x300103f3u),\nuvec4(0x12010905u,0x070e0701u,0x04181702u,0x14000410u),\nuvec4(0x07020405u,0x1e2f6e0fu,0x5e0f0207u,0x07ef6e4fu),\nuvec4(0x07580f08u,0x14073804u,0x08121807u,0x3e0f0714u),\nuvec4(0x4fff0e5fu,0x02361e07u,0x0a160a86u,0x46220a5du),\nuvec4(0x06071617u,0xf1a716d7u,0xf31211f1u,0x4013f3f3u),\nuvec4(0x12050905u,0x070e0701u,0x04280702u,0x24070400u),\nuvec4(0x08120400u,0x122e1f6eu,0x6e4f3e2fu,0x08af0e0fu),\nuvec4(0x680e0807u,0x18424817u,0x0e070005u,0xcfff1e0fu),\nuvec4(0x360f0807u,0x161a9602u,0x120a6d0au,0x16271637u),\nuvec4(0xf1c716a7u,0xf31201f1u,0x0713f3f3u,0x00010015u),\nuvec4(0x01120915u,0x78170e07u,0x08072004u,0x2f6e0802u),\nuvec4(0x0f07021eu,0x3f3e071eu,0x1f3e071eu,0x5f0e1f0eu),\nuvec4(0x0f080208u,0x6802a80eu,0x07000507u,0x08efff1eu),\nuvec4(0x12360f07u,0x0a160aa6u,0x0a0d0a5du,0x16171204u),\nuvec4(0x06270607u,0x0677060au,0x12f1f1d7u,0x23f3f3f3u),\nuvec4(0x05090007u,0x09150102u,0x07010204u,0x0778070eu),\nuvec4(0x08072004u,0x3f5e0802u,0x0208270eu,0x08020708u),\nuvec4(0x1e2f0e0fu,0x0e3f4e17u,0x0e02084fu,0x073812d8u),\nuvec4(0xff071004u,0x07080fffu,0x1226070fu,0x2a0d0ae6u),\nuvec4(0x0a1d2a0du,0x47160722u,0x37061a06u,0xd1f1e716u),\nuvec4(0xf302030au,0x0633f3f3u,0x02040500u,0x01091509u),\nuvec4(0x68370102u,0x07043007u,0x2f6e0802u,0x1e12170eu),\nuvec4(0x0f080218u,0x062e0f0eu,0x4f0e1f6eu,0x22f80208u),\nuvec4(0x10040708u,0xffff0e04u,0x0f020e0fu,0x8612260eu),\nuvec4(0x060a460au,0x060a0d0au,0x0a2d0401u,0x77220a1du),\nuvec4(0xf716271au,0x0306d1f1u,0xf3f3f302u,0x04050633u),\nuvec4(0x15090102u,0x01040509u,0x88070e06u,0x04100407u),\nuvec4(0x3f5e1207u,0x4812070eu,0xbe1f0e12u,0x024f0e0fu),\nuvec4(0x04180288u,0x04222807u,0x0e070615u,0x0e0fffffu),\nuvec4(0x360f0802u,0x360de602u,0x0102060au,0x0a0d0a4du),\nuvec4(0x16271204u,0x060a0627u,0xd1f127f7u,0xf3f31206u),\nuvec4(0x050433f3u,0x10450912u,0x10b80e06u,0x5e120804u),\nuvec4(0x02070e3fu,0x02080448u,0xde0f0e08u,0x88020e3fu),\nuvec4(0x10070802u,0x12040218u,0xffff1e08u,0x0f08023fu),\nuvec4(0x76122607u,0x0d0a4602u,0x5d12261au,0x2746124au),\nuvec4(0xf7060a06u,0x0dc1f117u,0xf3f3f312u,0x12000733u),\nuvec4(0x10050945u,0x04b80f04u,0x12070400u,0x0e2f5e08u),\nuvec4(0x07143812u,0x085fde12u,0x18127802u,0x18020004u),\nuvec4(0x1f080712u,0x1fffff0eu,0x070f0208u,0x02861226u),\nuvec4(0x12262d46u,0x4a3d0a16u,0x0702040du,0x07160726u),\nuvec4(0x0a060706u,0xc1f1d716u,0xf3f3f312u,0x12050643u),\nuvec4(0x05091509u,0x04001509u,0x040004c8u,0x0f081207u),\nuvec4(0x121e2f3eu,0x14000428u,0x5fce0812u,0x07680208u),\nuvec4(0x18123802u,0x08070402u,0x2fffff0eu,0x261e0208u),\nuvec4(0x36128612u,0x12361d0au,0x3a3d0a26u,0x12040a04u),\nuvec4(0x360a0716u,0xf1d72607u,0xf3f322b1u,0x050a43f3u),\nuvec4(0x35090102u,0x05000509u,0x04281498u,0x08120400u),\nuvec4(0x0e3f2e0fu,0x07380207u,0x12040718u,0x125fae17u),\nuvec4(0x12280278u,0x04010218u,0xffff0e08u,0x0f08023fu),\nuvec4(0x02961226u,0x260a1d46u,0x2d1a6612u,0x0d0a0204u),\nuvec4(0x1766120au,0x07061a06u,0x91f19706u,0xf3f3f322u),\nuvec4(0x01090753u,0x05090502u,0x05091500u,0x10980400u),\nuvec4(0x00041807u,0x0f0e1204u,0x3802086eu,0x07224807u),\nuvec4(0x12086f8eu,0x22381268u,0x08070004u,0x083fffffu),\nuvec4(0x22260f02u,0x1d461286u,0x8612260au,0x020a0d0au),\nuvec4(0x0d0a0d04u,0x0776120au,0x97160a16u,0x061291f1u),\nuvec4(0x53f3f3f3u,0x02040906u,0x09150900u,0x04051905u),\nuvec4(0x04281098u,0x5e120400u,0x48020e0fu,0x22580407u),\nuvec4(0x220e4f9eu,0x18072258u,0x08141214u,0x0e3fffffu),\nuvec4(0x160e0802u,0x36129622u,0x360a0d0au,0x5d12a612u),\nuvec4(0x46040204u,0x0627060au,0x0291f1a7u,0xf3f3f301u),\nuvec4(0x01050663u,0x45390102u,0x07040788u,0x04100718u),\nuvec4(0x126e0802u,0x0407180fu,0x12076807u,0x1e1f6e08u),\nuvec4(0x18170e0fu,0x12380207u,0x01000148u,0xff0e0812u),\nuvec4(0x0e123fffu,0x12a62216u,0x12460d36u,0x0602a604u),\nuvec4(0x020a5d0au,0xf1c77604u,0xf3f31281u,0x090673f3u),\nuvec4(0x29010205u,0x00050925u,0x04076804u,0x10042807u),\nuvec4(0x1e0f0812u,0x02070e0fu,0x07180e07u,0x12077814u),\nuvec4(0x07086e06u,0x02080702u,0x42281f08u,0x12100458u),\nuvec4(0xffff0e08u,0x0e02072fu,0x02b61226u,0x460d0a36u),\nuvec4(0x041a8612u,0x5d0a1602u,0x0716041au,0x67163736u),\nuvec4(0xf31281f1u,0x0a73f3f3u,0x01020409u,0x05590509u),\nuvec4(0x04480400u,0x07280710u,0x08020104u,0x1e121f2eu),\nuvec4(0x98070428u,0x070c0002u,0x0802084eu,0x880e082eu),\nuvec4(0x01075817u,0xff0e0812u,0x02081fffu,0xb6122607u),\nuvec4(0x461a3612u,0x122a7612u,0x6d060a16u,0x5612040au),\nuvec4(0x57060a27u,0xf30281f1u,0x0773f3f3u,0x05120905u),\nuvec4(0x45190509u,0x04480400u,0x04480400u,0x124e0812u),\nuvec4(0x9807380eu,0x060c0512u,0x0f08024eu,0x020768f8u),\nuvec4(0x0fffff28u,0x1607120eu,0x3602c612u,0x360a0d0au),\nuvec4(0x0d1a7612u,0x0a16020au,0x0a5d0a26u,0x16178602u),\nuvec4(0x1271f147u,0x73f3f3f3u,0x04090506u,0x09252902u),\nuvec4(0x00050905u,0x07044807u,0x22140728u,0x020f3e08u),\nuvec4(0x0102f807u,0x18060c09u,0x1298121eu,0x02a80718u),\nuvec4(0x0fffff28u,0x16070207u,0xa602d612u,0x123a6612u),\nuvec4(0x36020a16u,0x1a020a3du,0x0a061786u,0x71f11716u),\nuvec4(0xf3f3f302u,0x01091583u,0x09352902u,0x04980411u),\nuvec4(0x4e181220u,0x0208f802u,0x02040901u,0x0e071217u),\nuvec4(0x04681298u,0x12280400u,0xffff0e18u,0x1216120eu),\nuvec4(0x12a612d6u,0x16023a66u,0x3612060au,0x02041d0au),\nuvec4(0x07a60d0au,0x17060a06u,0xf31261f1u,0x0773f3f3u),\nuvec4(0x09121915u,0x01020145u,0x07041804u,0x30041728u),\nuvec4(0x2e0f1812u,0x08f80207u,0x04010402u,0x0e171e07u),\nuvec4(0x046812a8u,0x02180710u,0xff0e1804u,0x010207ffu),\nuvec4(0x12d62206u,0x22560a26u,0x16122a66u,0x5612060au),\nuvec4(0x0d0a040au,0x5607360au,0xf1071627u,0xf3f31261u),\nuvec4(0x050773f3u,0x05090509u,0x20090402u,0x04010201u),\nuvec4(0x04100718u,0x04071417u,0x3e081220u,0x14120e0fu),\nuvec4(0x07481748u,0x1b050004u,0x98022807u,0x68120407u),\nuvec4(0x18040005u,0xff180412u,0x0e381e5fu,0x070f0e0fu),\nuvec4(0x12160102u,0x22a602e6u,0x06122a66u,0x5612061au),\nuvec4(0x2a1d0102u,0x1a0607a6u,0xf31251f1u,0x0683f3f3u),\nuvec4(0x09150905u,0x20050204u,0x28040102u,0x02010004u),\nuvec4(0x04181704u,0x3e081220u,0x04120708u,0x04381758u),\nuvec4(0x0c000100u,0x12380705u,0x02040788u,0x04270428u),\nuvec4(0x14121810u,0x1fff0e08u,0x1207080eu,0x1f0e0817u),\nuvec4(0x1204060eu,0x3612060au,0x46124652u,0x7612460au),\nuvec4(0x1602041au,0x1206020du,0x2d011246u,0x0617a62au),\nuvec4(0xf31241f1u,0x0493f3f3u,0x02010935u,0x02011005u),\nuvec4(0x18070401u,0x38120514u,0x07041007u,0x0e0f0812u),\nuvec4(0x04d81207u,0x0c020100u,0x02580405u,0x04281298u),\nuvec4(0x07041001u,0x07080218u,0xff080704u,0x07220e0fu),\nuvec4(0x0a0e5f0eu,0x06011201u,0x16123622u,0x26022632u),\nuvec4(0x360a061au,0x122a6622u,0x06120a06u,0x04024612u),\nuvec4(0x07462a3du,0x41f10766u,0xf3f3f312u,0x35000493u),\nuvec4(0x01020409u,0x10020400u,0x02480704u,0x02181758u),\nuvec4(0x070e1718u,0x78040728u,0x24050004u,0x38126807u),\nuvec4(0x00022814u,0x58041238u,0x0e0f0814u,0x120708dfu),\nuvec4(0x070e5f08u,0x12050004u,0x36121604u,0x16124612u),\nuvec4(0x461a3612u,0x022a7612u,0x04020a16u,0x1236120au),\nuvec4(0xc61a4d0au,0x1241f10au,0x93f3f3f3u,0x0109550au),\nuvec4(0x05120104u,0x88026804u,0x1e081207u,0x58073438u),\nuvec4(0x02040b10u,0x04380288u,0x02280400u,0x32380400u),\nuvec4(0x08140718u,0x0eaf0e1fu,0x5f082208u,0x1005060eu),\nuvec4(0x0a120109u,0x12461206u,0x56124a26u,0x0412360au),\nuvec4(0x02042a66u,0x1a020116u,0x04023612u,0x0ac61a5du),\nuvec4(0xf31241f1u,0x0773f3f3u,0x01050985u,0x12680712u),\nuvec4(0x07040788u,0x14580768u,0x05000407u,0x8802010bu),\nuvec4(0x00043802u,0x05021804u,0x04780710u,0x9f1e0710u),\nuvec4(0x1207080eu,0x0e4f0e08u,0x15100a07u,0x0a120509u),\nuvec4(0x32561206u,0x010a0224u,0x461d2612u,0x2a560a22u),\nuvec4(0x0a06120du,0x120a0201u,0x6d0a1236u,0x360a362au),\nuvec4(0x31f1110au,0xf3f3f312u,0x00950783u,0x78070204u),\nuvec4(0x38142812u,0x07080734u,0x05200498u,0x02040b0cu),\nuvec4(0x14480288u,0x24300418u,0x0b002417u,0x0e0f1e07u),\nuvec4(0x0832185fu,0x0a070e4fu,0x09150005u,0x06011225u),\nuvec4(0x24326622u,0x0602010au,0x560a160au,0x460a0112u),\nuvec4(0x06120d3au,0x0602040du,0x01024602u,0x0a061a7du),\nuvec4(0x0a011a66u,0xf31231f1u,0x0783f3f3u,0x02010095u),\nuvec4(0x38127807u,0x07280704u,0x18040500u,0x10048817u),\nuvec4(0x02042c05u,0x07580278u,0x05200428u,0x090c0d26u),\nuvec4(0x3e060c05u,0x082f1e0fu,0x1f0e0832u,0x0407180eu),\nuvec4(0x19051001u,0x12040925u,0x1a962206u,0x1a02043du),\nuvec4(0x0d22660du,0x024a460au,0x36320d16u,0x1a8d0a12u),\nuvec4(0x0d2a0d66u,0xf31221f1u,0x0493f3f3u,0x01098510u),\nuvec4(0x38127802u,0x10072814u,0x38077804u,0x2c091007u),\nuvec4(0x02481207u,0x07380718u,0x05300428u,0x16071e07u),\nuvec4(0x0e2f5e07u,0x1e082208u,0x00013228u,0x12250955u),\nuvec4(0x0ab62206u,0x0a0d0a0du,0x0a061a02u,0x1d0a1266u),\nuvec4(0x0d1a460au,0x0d0a0612u,0x04024622u,0x3a561a9du),\nuvec4(0x21f10001u,0xf3f31203u,0x093583f3u,0x12040965u),\nuvec4(0x04483238u,0x00072800u,0x10047804u,0x04071807u),\nuvec4(0x161c0900u,0x04285208u,0x50140738u,0x2f8e070du),\nuvec4(0x2207080eu,0x080e1f08u,0x02110412u,0x01850905u),\nuvec4(0xc6220612u,0x1a0d143au,0x360d0a06u,0x040a1d22u),\nuvec4(0x022a063au,0x12040d16u,0x8d0a1246u,0x160a161au),\nuvec4(0x0a04010au,0xf115000du,0x02030a11u,0x83f3f3f3u),\nuvec4(0x45090507u,0x01092509u,0x52010002u,0x07000468u),\nuvec4(0x100407b8u,0x02072804u,0x070d0c01u,0x07a80706u),\nuvec4(0x0b097014u,0x4207088eu,0x0e0f0807u,0x00042208u),\nuvec4(0x05140509u,0x01096500u,0x12060a12u,0x02461aa6u),\nuvec4(0x060a0d0au,0x260a1d0au,0x0d0c0a12u,0x0602060au),\nuvec4(0x1602044au,0x1246220du,0x2a061a9du,0x0a020406u),\nuvec4(0xf119150du,0xf3f32211u,0x09a593f3u,0x05000512u),\nuvec4(0x07280214u,0x04000438u,0x48026802u,0x48040007u),\nuvec4(0x0e070422u,0x1520b807u,0x3e061c30u,0x07080e0fu),\nuvec4(0x0e180742u,0x30013207u,0x09750012u,0x060a1201u),\nuvec4(0x262ab612u,0x0d0a0604u,0x0a1d060au,0x0412160du),\nuvec4(0x12060a2du,0x06123a06u,0x4612010au,0x5a7d0a12u),\nuvec4(0x0a140a06u,0x0500050du,0x1211f119u,0xa3f3f3f3u),\nuvec4(0x020409a5u,0x00051005u,0x01145804u,0x04072812u),\nuvec4(0x07380238u,0x00075804u,0x580e0712u,0x00074817u),\nuvec4(0x10050405u,0x3e062c09u,0x0e172208u,0x0422072fu),\nuvec4(0x04420411u,0x09551005u,0x060a1200u,0x063ac622u),\nuvec4(0x163a0602u,0x060a0d0au,0x02065a12u,0x010d0a16u),\nuvec4(0x220d1602u,0x8d040246u,0x010a126au,0xf1192005u),\nuvec4(0xf3f31211u,0x750793f3u,0x12091509u,0x12251005u),\nuvec4(0x38121038u,0x02072814u,0x12280738u,0x01000418u),\nuvec4(0x1007d812u,0x063c1905u,0x07080f0eu,0x1f0e0822u),\nuvec4(0x0204061eu,0x22041104u,0x10153104u,0x12010945u),\nuvec4(0xf622060au,0x2a16041au,0x121d0a26u,0x2a260a04u),\nuvec4(0x121a0612u,0x36220516u,0x5a8d0112u,0x050a0204u),\nuvec4(0x19100510u,0xf31211f1u,0x0193f3f3u,0x09250965u),\nuvec4(0x30050204u,0x02280201u,0x38021408u,0x88025807u),\nuvec4(0x10010412u,0x48177812u,0x3c090004u,0x2217060bu),\nuvec4(0x070e1f18u,0x52200506u,0x10153001u,0x09251005u),\nuvec4(0x160a1201u,0x4602c612u,0x1a562a04u,0x360a0d12u),\nuvec4(0x0a06022au,0x040a1612u,0x7d124612u,0x0904027au),\nuvec4(0x05190510u,0x0401f119u,0xf3f3f312u,0x75000783u),\nuvec4(0x01091509u,0x02201502u,0x02180704u,0x07180218u),\nuvec4(0x02581704u,0x10042288u,0x04780204u,0x18071400u),\nuvec4(0x1c090004u,0x0842050bu,0x0a06071eu,0x05090530u),\nuvec4(0x01040201u,0x15101560u,0x01091500u,0x12160a12u),\nuvec4(0x0a5612b6u,0x12362a2du,0x1a560d0au,0x16120a12u),\nuvec4(0x1236220au,0x144a7d01u,0x59200d12u,0xf31201f1u),\nuvec4(0x0793f3f3u,0x010200c5u,0x04022005u,0x02180228u),\nuvec4(0x02781718u,0x10228807u,0x04780204u,0x04180410u),\nuvec4(0x040d0c10u,0x06170832u,0x00353005u,0x20155015u),\nuvec4(0x09252015u,0x160a1201u,0x660a2622u,0x0d1a6612u),\nuvec4(0x162a1d0au,0x0a0d0402u,0x0a264266u,0x04023622u),\nuvec4(0x0a224a8du,0xf1491520u,0xf3f3120au,0x000793f3u),\nuvec4(0x09150985u,0x09050912u,0x04170201u,0x02180208u),\nuvec4(0x880412a8u,0x04000422u,0x20076802u,0x42141807u),\nuvec4(0x06070e07u,0x20652005u,0x40050005u,0x09058005u),\nuvec4(0x161a1204u,0x660a2612u,0x063a7602u,0x061d1a0du),\nuvec4(0x0a0d0402u,0x0a041266u,0x0a160402u,0x12262201u),\nuvec4(0x0a0d3a8du,0x35000112u,0x1204f159u,0x93f3f3f3u),\nuvec4(0x0109c507u,0x05000504u,0x06040812u,0x07021812u),\nuvec4(0x22981298u,0x02040708u,0x07040718u,0x04200408u),\nuvec4(0x12040718u,0x0a1c0104u,0x30a51005u,0x60151005u),\nuvec4(0x09250005u,0x161a1204u,0x560a2612u,0x46124612u),\nuvec4(0x1d160d1au,0x010a020au,0x1a061266u,0x0a160a02u),\nuvec4(0x04022632u,0x040d3a8du,0x05000203u,0xf1590529u),\nuvec4(0xf3f3f312u,0x1005f5b3u,0x22010712u,0x02a80218u),\nuvec4(0x02280758u,0x12180218u,0x20041718u,0x01041824u),\nuvec4(0x090c0504u,0x0550d530u,0x01096540u,0x22161a12u),\nuvec4(0x12461a16u,0x32361236u,0x0a0d2a04u,0x561a0412u),\nuvec4(0x120a0612u,0x040a160au,0x0a121622u,0x040d2a8du),\nuvec4(0x99150417u,0xf3f312f1u,0x20f5b3f3u,0x02180752u),\nuvec4(0x07581298u,0x12282228u,0x04382748u,0xc5600130u),\nuvec4(0x65000570u,0x06120409u,0x2612260au,0x1612460au),\nuvec4(0x0d01041au,0x060a460au,0x060a2602u,0x0a140a04u),\nuvec4(0x12460206u,0x160a0204u,0x1204010au,0x7d0a1226u),\nuvec4(0x0704013au,0x19150004u,0x0ae16905u,0xf3f31203u),\nuvec4(0x000693f3u,0x200500c5u,0x04100122u,0x78070218u),\nuvec4(0x08172812u,0x12380207u,0x88041228u,0x01300407u),\nuvec4(0xc5100540u,0x85101520u,0x360a2209u,0x460a2612u),\nuvec4(0x1d3a1612u,0x0a0d0a66u,0x0a040612u,0x060a121du),\nuvec4(0x0a323602u,0x22040a16u,0x3a7d1226u,0x04010611u),\nuvec4(0x04e1b901u,0xf3f3f312u,0x10d501a3u,0x01121015u),\nuvec4(0x12180410u,0x00382258u,0x00026804u,0x78041228u),\nuvec4(0xf5f58004u,0x12040915u,0x260a0500u,0x360a2612u),\nuvec4(0x0d3a2612u,0x061a460au,0x04010d0au,0x042d0612u),\nuvec4(0x02060402u,0x260a2226u,0x12261214u,0x1d2a6d01u),\nuvec4(0x0102170au,0xf312e1c9u,0x07a3f3f3u,0x2510d500u),\nuvec4(0x14120500u,0x08220428u,0x12342832u,0x28040758u),\nuvec4(0x07581402u,0x0015a004u,0x0409c5f5u,0x0a050012u),\nuvec4(0x2612061du,0x1602360au,0x0a062a32u,0x0a013204u),\nuvec4(0x02161a16u,0x02043d04u,0x32061206u,0x320a160au),\nuvec4(0x1a7d1226u,0x0307011du,0x05490402u,0xf312e179u),\nuvec4(0x06a3f3f3u,0x1510e500u,0x38120110u,0x17780224u),\nuvec4(0x22180704u,0x07000428u,0x07041208u,0x07040708u),\nuvec4(0x25a00418u,0xf5009510u,0x01120105u,0x12013d00u),\nuvec4(0x12261a16u,0x1a141206u,0x0a262216u,0x0a0d2602u),\nuvec4(0x1a1d1216u,0x4206120du,0x2201161au,0x6d041226u),\nuvec4(0x03073d1au,0x59050902u,0x02e1590cu,0xb3f3f3f3u),\nuvec4(0x65097506u,0x04200520u,0x14073802u,0x1038f807u),\nuvec4(0x38020804u,0x04051004u,0x009500f0u,0x09b50015u),\nuvec4(0x00011201u,0x561a124du,0x01120402u,0x0412161au),\nuvec4(0x0a260d0au,0x1a0d0a26u,0x161a0216u,0x1236120au),\nuvec4(0x220a160du,0x6d0a1236u,0x12012d1au,0x690c5915u),\nuvec4(0xf31204d1u,0x06a3f3f3u,0x35595500u,0x08020450u),\nuvec4(0x0778f807u,0x48121004u,0x60159025u,0x120195f5u),\nuvec4(0x12014d10u,0x023a361du,0x160a0d01u,0x162d0612u),\nuvec4(0x061a261au,0x3602041au,0x1226120au,0x220a161au),\nuvec4(0x1a6d1236u,0x0412012du,0x1c590509u,0xf312d159u),\nuvec4(0x04b3f3f3u,0x09255945u,0x04126015u,0x07040798u),\nuvec4(0x07380748u,0x04280220u,0x00040807u,0x0045c065u),\nuvec4(0x010925f5u,0x4d050112u,0x1d011201u,0x0d1a161au),\nuvec4(0x161a020au,0x050d1612u,0x263a2011u,0x1246120au),\nuvec4(0x0d12061au,0x010a060au,0x01123612u,0x011d2a5du),\nuvec4(0x0ca90612u,0xf312d149u,0x0ab3f3f3u,0x49050935u),\nuvec4(0x20250915u,0x12012005u,0x07181758u,0x00043814u),\nuvec4(0x10040014u,0x04280201u,0x85080700u,0x251035c0u),\nuvec4(0x95092500u,0x01120409u,0x120a4d05u,0x260a1d01u),\nuvec4(0x141a060au,0x1612160au,0x0a80010au,0x460a0436u),\nuvec4(0x1a121a12u,0x36220a16u,0x4d010d12u,0x07122d1au),\nuvec4(0x12d119f9u,0xb3f3f3f3u,0x95595501u,0x08020510u),\nuvec4(0x14380407u,0x04380738u,0x01100110u,0x04380702u),\nuvec4(0x50040800u,0x1055c005u,0x09c50025u,0x00011201u),\nuvec4(0x0d224d0au,0x0a660d05u,0x16023602u,0x2905100au),\nuvec4(0x04012015u,0x460a0426u,0x0d121a12u,0x36120426u),\nuvec4(0x2a4d0112u,0x0b12012du,0xc109f905u,0xf3f3f312u),\nuvec4(0x052955c3u,0x75092519u,0x24120100u,0x320407e8u),\nuvec4(0x05003448u,0x65d00510u,0x65092520u,0x01093509u),\nuvec4(0x4d0a1112u,0x1d011201u,0x12062a86u,0x0500010au),\nuvec4(0x15090509u,0x05100519u,0x040a2602u,0x1a12260au),\nuvec4(0x04161a12u,0x2d123622u,0x1d1a1d01u,0x04120a01u),\nuvec4(0xc1d90539u,0xf3f3f312u,0x052955c3u,0x01008549u),\nuvec4(0x38070412u,0x4817d807u,0x00140004u,0x10151015u),\nuvec4(0x19854015u,0x091519b5u,0x12040905u,0x2d0a0501u),\nuvec4(0x12010d0au,0x02461d01u,0x1a160216u,0x00010612u),\nuvec4(0x19451905u,0x16041005u,0x160a141au,0x0d121a12u),\nuvec4(0x12040d26u,0x0d011226u,0x0d1a3d01u,0x120e0601u),\nuvec4(0xe9051915u,0xf3f302c1u,0x6506c3f3u,0x02108579u));\n\n// The offsets in data of the line segments\nconst int lines[] = int[](\n0,19,38,57,76,95,114,133,166,191,220,256,288,324,360,404,444,495,540,591,638,687,741,\n782,821,865,906,949,991,1042,1095,1157,1223,1288,1356,1419,1489,1565,1645,1727,1812,\n1900,1990,2082,2181,2274,2364,2466,2569,2677,2773,2872,2980,3078,3189,3297,3397,3495,\n3586,3676,3755,3839,3927,4010,4102,4197,4296,4395,4496,4598,4714,4815,4910,4998,5082,\n5173,5255,5334,5421,5509,5604,5696,5793,5894,5992,6093,6198,6300,6413,6528,6640,6767,\n6894,7019,7142,7269,7399,7527,7669,7800,7931,8060,8184,8298,8406,8512,8618,8721,8819,\n8917,9010,9102,9195,9282,9369,9458,9543,9630,9713,9797,9871,9940,10005,10077,10152,\n10212,10275,10350,10421,10490,10547,10602,10657,10713,10765,10821,10876,10938,11002,\n11064,11125,11187,11249,11305,11364,11422,11490,11553,11615,11677,11736,11809,11878,\n11959,12046,12128,12212,12284,12360,12439,12533,12619,12721,12810,12913,13006,13109,\n13202,13293,13377,13465,13539,13605,13680,13744,13808,13881,13941,14000,14073,14144,\n14222,14295,14382,14472,14579,14671,14770,14863,14953,15057,15151,15237,15326,15411,\n15489,15574,15652,15743,15842,15926,16024,16128,16237,16355,16477,16583,16690,16796,\n16899,17011,17121,17223,17316,17404,17487,17563,17637,17717,17784,17854,17920,17978,\n18039,18096,18160,18215,18273,18342,18393,18450,18505,18561,18616,18667,18723,18774,\n18828,18879,18930,18976,19025,19076,19134,19192,19251,19306,19351,19398,19450,19505,\n19565,19621,19676,19738,19800,19862,19919,19989,20051,20095,20137,20185,20236,20284,\n20328,20371,20420,20474,20523,20564,20608,20650,20696,20734,20775,20812,20854,20896,\n20948,21003,21063,21119,21175,21222,21275,21319,21364,21410,21457,21509,21552,21600,\n21645,21699,21746,21793,21849,21898,21953,22007,22061,22118,22168,22213,22265,22316,\n22369,22424,22482,22535,22585,22634,22686,22740,22787,22832,22872,22918,22973,23027,\n23081,23137,23200,23257,23314,23369,23430,23484,23549,23615,23684,23754,23821,23886,\n23947,23998,24052,24097,24149,24206,24262,24318,24371,24425,24473,24519,24563,24606,\n24649,24691,24727,24761,24798,24831,24866,24905,24949,24994,25039,25081,25121,25163,\n25210,25254,25297,25343,25389,25437,25478,25519,25559,25602,25653,25703,25756,25814,\n25864,25917,25973,26034,26099,26173,26239,26307,26380,26454,26527,26592,26665,26734,\n26802,26867,26930,26999,27064,27127,27195,27263,27326,27392,27456,27517,27584,27635,\n27696,27760,27832,27906,27971,28039,28118,28199,28275,28361,28446,28532,28618,28693,\n28774,28855,28938,29020,29097,29175,29264,29348,29425,29502,29576,29659,29752,29856,\n29958,30053,30144,30242,30340,30436,30530,30631,30739,30841,30943,31044,31141,31244,\n31335,31433,31535,31620,31706,31794,31877,31965,32058,32144,32221,32309,32402,32491,\n32579,32676);\n\nconst int IWIDTH = 294;\nconst int IHEIGHT = lines.length()-1;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (fragColor.w == ires) return;\n  fragColor.w = ires;\n  int col = int(fragCoord.y);\n  int row = int(fragCoord.x);\n  if (row >= IHEIGHT || col >= IWIDTH) return;\n  int rstart = lines[row];\n  int rend = lines[row+1];\n  int c = -1;\n  int colcount = 0;\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15;\n      break;\n    }\n  }\n  if (c >= 0) fragColor.rgb = getcolor(c);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const uvec4 data[] = uvec4[](\nuvec4(0xf01190f0u,0x0290f0f0u,0x02201280u,0x52031240u),\nuvec4(0xf2f2f203u,0xf010f0f2u,0xf0f0f0f0u,0x12500250u),\nuvec4(0x21102230u,0x02134210u,0xf2f2f201u,0xf010f0e2u),\nuvec4(0xf0f0f0f0u,0x11201280u,0x12030200u,0x04030220u),\nuvec4(0xf2408305u,0xf0c2f2f2u,0xf0f0f0f0u,0x501200f0u),\nuvec4(0x00111012u,0x06041553u,0x04350407u,0x02131415u),\nuvec4(0xf2f2f230u,0xf0f0f0a2u,0x02a0f0f0u,0x52003210u),\nuvec4(0x06240523u,0x06340504u,0x15130514u,0x05140524u),\nuvec4(0xf2330523u,0xe092f2f2u,0xf0f0f0f0u,0x02502170u),\nuvec4(0x16242533u,0x16140614u,0x25034534u,0x05330503u),\nuvec4(0xf2331504u,0xe072f2f2u,0xf0f0f0f0u,0x05031170u),\nuvec4(0x46643514u,0x25744624u,0x02238523u,0xf2f2f220u),\nuvec4(0xf0f0e032u,0x0220f0f0u,0x05020120u,0x17365436u),\nuvec4(0x17560436u,0x14064416u,0x45041523u,0x12032514u),\nuvec4(0x02000110u,0xc2f2f213u,0xf0a00220u,0x30f0f0f0u),\nuvec4(0x04050311u,0x07860716u,0x24160406u,0x24160756u),\nuvec4(0x13656405u,0x06142614u,0x11021514u,0xf2f2f200u),\nuvec4(0xf0f0a012u,0x0031e0f0u,0x26040302u,0x240514c7u),\nuvec4(0x24360706u,0x24062405u,0x13254416u,0x14160415u),\nuvec4(0x00110556u,0x02f2f2f2u,0xf0f0f0a0u,0x030011d0u),\nuvec4(0xf7061405u,0x05040607u,0x06670604u,0x06043604u),\nuvec4(0x07080724u,0x03250406u,0x33120312u,0x02046604u),\nuvec4(0xf2f2f211u,0xf0f0f0a0u,0x030211a0u,0x04260405u),\nuvec4(0x28071826u,0x06070647u,0x18270644u,0x06170807u),\nuvec4(0x26141617u,0x14350607u,0x03350415u,0x14050302u),\nuvec4(0x03041726u,0xf2030011u,0xf0a0c2f2u,0x02a0f0f0u),\nuvec4(0x14160405u,0x18090856u,0x06070807u,0x15043604u),\nuvec4(0x08073604u,0x66670809u,0x06042504u,0x06072614u),\nuvec4(0x25141607u,0x06070624u,0x10030504u,0xa0c2f2f2u),\nuvec4(0x80f0f0f0u,0x06040512u,0x26041504u,0x28070617u),\nuvec4(0x35143627u,0x57281726u,0x05361406u,0x05340513u),\nuvec4(0x18091744u,0x26040607u,0x04171604u,0xd2f2f203u),\nuvec4(0xf0f0f0a0u,0x05130260u,0x05230504u,0x08176604u),\nuvec4(0x14361407u,0x06050415u,0x06671827u,0x06040504u),\nuvec4(0x44130524u,0x04663455u,0xf2130546u,0xf0a0b2f2u),\nuvec4(0x1240f0f0u,0x04060513u,0x04163405u,0x27060436u),\nuvec4(0x24160416u,0x07160413u,0x16180708u,0x15140627u),\nuvec4(0x14151406u,0x84060436u,0x07163415u,0x24051406u),\nuvec4(0xa2f2f213u,0xf0f0f0a0u,0x15200210u,0x26040503u),\nuvec4(0x06071617u,0x26070614u,0x15242637u,0x07080704u),\nuvec4(0x17062708u,0x05040706u,0x06040302u,0x26141514u),\nuvec4(0x06070614u,0x15041504u,0x15031504u,0x06141604u),\nuvec4(0x02052425u,0x82f2f210u,0xf0f0f090u,0x03000120u),\nuvec4(0x06141604u,0x07080617u,0x27061426u,0x07080726u),\nuvec4(0x34050406u,0x07087706u,0x01000516u,0x14065503u),\nuvec4(0x07140607u,0x83350406u,0x04150305u,0x14162406u),\nuvec4(0xf2000205u,0xf08082f2u,0x0110f0f0u,0x07160500u),\nuvec4(0x17160708u,0x06051716u,0x16171607u,0x06170614u),\nuvec4(0x07088744u,0x00030416u,0x04052302u,0x08061315u),\nuvec4(0x15041714u,0x22531503u,0x06042503u,0x06140514u),\nuvec4(0x20050607u,0x7072f2f2u,0x02e0f0f0u,0x04020100u),\nuvec4(0x07083706u,0x07081708u,0x47140706u,0x05341516u),\nuvec4(0x18170624u,0x08090827u,0x02130506u,0x15020305u),\nuvec4(0x01021503u,0x05060905u,0x12130516u,0x45035213u),\nuvec4(0x26040564u,0x92f2f203u,0xc0f0f070u,0x00110002u),\nuvec4(0x07086704u,0x06040728u,0x06270617u,0x06343524u),\nuvec4(0x07190867u,0x03021304u,0x04030205u,0x03010023u),\nuvec4(0x16040807u,0x03152304u,0x35031032u,0x16242503u),\nuvec4(0x06041504u,0x03020304u,0x7062f2f2u,0x02c0f0f0u),\nuvec4(0x16030100u,0x09670607u,0x07080708u,0x08270604u),\nuvec4(0x13350406u,0x37261405u,0x07060706u,0x33050618u),\nuvec4(0x04030102u,0x03021302u,0x16070907u,0x23341504u),\nuvec4(0x05030002u,0x25232534u,0xf2050654u,0xf07082f2u),\nuvec4(0x0012a0f0u,0x18470301u,0x18172817u,0x07061406u),\nuvec4(0x03050426u,0x04052305u,0x37160706u,0x04063706u),\nuvec4(0x13000305u,0x02330200u,0x07180500u,0x14057406u),\nuvec4(0x06270413u,0x05035514u,0x13050664u,0x7052f2f2u),\nuvec4(0x02a0f0f0u,0x28570311u,0x06172827u,0x05044614u),\nuvec4(0x05030233u,0x06272604u,0x05142604u,0x02130213u),\nuvec4(0x10131503u,0x16090804u,0x06140604u,0x05040634u),\nuvec4(0x07190807u,0x05032506u,0x55040604u,0x03051624u),\nuvec4(0x7052f2f2u,0x0190f0f0u,0x04000100u,0x18274837u),\nuvec4(0x06242607u,0x13252604u,0x27160422u,0x14061408u),\nuvec4(0x13255325u,0x09070300u,0x17365407u,0x07190706u),\nuvec4(0x33050406u,0x03050405u,0x34250415u,0xf2f20516u),\nuvec4(0xf0f07052u,0x01001280u,0x48270603u,0x36071837u),\nuvec4(0x05143604u,0x05000243u,0x08170816u,0x05040614u),\nuvec4(0x15530513u,0x16050223u,0x16341504u,0x06071847u),\nuvec4(0x03020305u,0x74150345u,0x04060405u,0x8042f2f2u),\nuvec4(0x1280f0f0u,0x37040001u,0x27181708u,0x14763708u),\nuvec4(0x10122305u,0x17060403u,0x03053416u,0x03054325u),\nuvec4(0x25021302u,0x36141523u,0x06071817u,0x05130504u),\nuvec4(0x05140604u,0x05540564u,0x8042f2f2u,0x1190f0f0u),\nuvec4(0x67286705u,0x17260406u,0x33050426u,0x08060522u),\nuvec4(0x15142617u,0x00d31503u,0x04250302u,0x37062406u),\nuvec4(0x04464406u,0x24054416u,0x03051416u,0x8022f2f2u),\nuvec4(0x0190f0f0u,0x18670402u,0x66270837u,0x05042607u),\nuvec4(0x02000223u,0x36071804u,0x35030504u,0x02131223u),\nuvec4(0x05237200u,0x14373604u,0x14160415u,0x34560726u),\nuvec4(0x03151416u,0x4210a2f2u,0x90f0f080u,0x57160403u),\nuvec4(0x14368718u,0x24060406u,0x01120305u,0x07180400u),\nuvec4(0x35131426u,0x12001213u,0x03220190u,0x17161405u),\nuvec4(0x24050406u,0x47062436u,0x03252456u,0x221092f2u),\nuvec4(0x90f0f0a0u,0x04060804u,0x26672837u,0x06440617u),\nuvec4(0x02032504u,0x17041003u,0x04153416u,0x30321305u),\nuvec4(0x011200a1u,0x04150300u,0x24050406u,0x26972446u),\nuvec4(0xf2032524u,0xa0221082u,0x0170f0f0u,0x04051703u),\nuvec4(0x66573827u,0x02032564u,0x03000203u,0x16070804u),\nuvec4(0x25040614u,0x21200203u,0x0230d100u,0x05140503u),\nuvec4(0x66071604u,0x16373837u,0x02031524u,0x1062f200u),\nuvec4(0xf0f09032u,0x01000250u,0x14060705u,0x0736b716u),\nuvec4(0x15540618u,0x00011213u,0x16080904u,0x05041604u),\nuvec4(0xf1300203u,0x03220041u,0x08060425u,0x08872617u),\nuvec4(0x16171807u,0x05140614u,0x1072f203u,0xf0f09032u),\nuvec4(0x06040270u,0x06040614u,0x160436a7u,0x16240609u),\nuvec4(0x10230524u,0x05240704u,0x12030514u,0x3071f110u),\nuvec4(0x04050302u,0x77088706u,0x04162708u,0x03050426u),\nuvec4(0x121062f2u,0x70f0f0b0u,0x05040605u,0xa7040604u),\nuvec4(0x04469426u,0x00020305u,0x04070603u,0x03050405u),\nuvec4(0x91f13012u,0x02000110u,0x16040503u,0x18272807u),\nuvec4(0x16672817u,0x06070604u,0xf2000504u,0xb0121052u),\nuvec4(0x0570f0f0u,0x07261506u,0x44265718u,0x04560455u),\nuvec4(0x05000203u,0x02130516u,0x20c1f150u,0x07061512u),\nuvec4(0x47166708u,0x17081716u,0x08070604u,0x02030407u),\nuvec4(0x1032f200u,0xf0f0b012u,0x04031240u,0x16040506u),\nuvec4(0x25142687u,0x05131233u,0x13340604u,0x03150302u),\nuvec4(0xf1f15002u,0x05132001u,0x06071604u,0x26044604u),\nuvec4(0x06471617u,0x05170604u,0x1032f210u,0xf0f0b012u),\nuvec4(0x14031240u,0x87160405u,0x03151416u,0x00021322u),\nuvec4(0x23023322u,0xf1f15022u,0x15035031u,0x06240574u),\nuvec4(0x04061867u,0x05070806u,0x1032f200u,0xf0f0b012u),\nuvec4(0x05031240u,0x77160403u,0x23150426u,0x60320012u),\nuvec4(0x00120001u,0x00010002u,0x20a1f1f1u,0x05031002u),\nuvec4(0x06040584u,0x06071857u,0x06070604u,0x62f20002u),\nuvec4(0xf00110b0u,0x131210f0u,0x16470605u,0x05141627u),\nuvec4(0x11a00223u,0xc1f1f170u,0x05033210u,0x36140634u),\nuvec4(0x17180607u,0x05261706u,0x01050604u,0x10a072f2u),\nuvec4(0x10f0f001u,0x06040322u,0x06041627u,0x05041627u),\nuvec4(0xf1900223u,0x1091f1f1u,0x14450322u,0x17561716u),\nuvec4(0x04050446u,0xf2000103u,0x1110a062u,0x1200f0f0u),\nuvec4(0x46040200u,0x16170614u,0x02131504u,0xf1f1f170u),\nuvec4(0x031220c1u,0x24150325u,0x34061406u,0x17060806u),\nuvec4(0x04150406u,0x62f21005u,0xf00110a0u,0x001210f0u),\nuvec4(0x0514b603u,0xf1301213u,0x11f1f1f1u,0x35030220u),\nuvec4(0x06141503u,0x05142614u,0x17060706u,0x06040506u),\nuvec4(0x00120304u,0xf0a042f2u,0x002230f0u,0x76170603u),\nuvec4(0x12130514u,0xf1f1f140u,0x121021f1u,0x05840563u),\nuvec4(0x06071624u,0x05031503u,0x42f20002u,0x30f0f0a0u),\nuvec4(0xa6050022u,0x22030514u,0xf1f1f130u,0x221021f1u),\nuvec4(0x05133203u,0x050416a4u,0x23040706u,0xf2000305u),\nuvec4(0xf0f0a042u,0x02001230u,0x24563405u,0xf1302205u),\nuvec4(0x41f1f1f1u,0x62230200u,0x06640503u,0x15041604u),\nuvec4(0x02000417u,0xf2100203u,0xf0f0b022u,0x02001230u),\nuvec4(0x16040524u,0x13242604u,0xf1f12012u,0x1051f1f1u),\nuvec4(0x03120302u,0x14151342u,0x05261436u,0x22130416u),\nuvec4(0xb022f200u,0x1230f0f0u,0x17340300u,0x24061406u),\nuvec4(0x20020315u,0xf1f1f1f1u,0x43821061u,0x64060405u),\nuvec4(0x03052416u,0x00020002u,0xf0b022f2u,0x000240f0u),\nuvec4(0x07161403u,0x13056406u,0xf1f12002u,0x1061f1f1u),\nuvec4(0x10022302u,0x14055322u,0x04263415u,0x00020305u),\nuvec4(0x22f20002u,0xf0f011b0u,0x36140340u,0x12130564u),\nuvec4(0xf1f1f120u,0x120061f1u,0x22200213u,0x14050233u),\nuvec4(0x34050305u,0x05040706u,0xf2001203u,0xf011b032u),\nuvec4(0x040540f0u,0x13056446u,0xf1f13012u,0x1051f1f1u),\nuvec4(0x53222032u,0x15040605u,0x06070634u,0x00220304u),\nuvec4(0xf0b022f2u,0x100230f0u,0x06073605u,0x12130564u),\nuvec4(0xf1f1f140u,0x123041f1u,0x15033220u,0x14150203u),\nuvec4(0x17360405u,0x03020304u,0x22f20002u,0xf0f001b0u),\nuvec4(0x01000220u,0x15546603u,0xf1301213u,0x41f1f1f1u),\nuvec4(0x12403220u,0x46140553u,0x03040617u,0x32f20302u),\nuvec4(0x01401240u,0x0210f0f0u,0x03010200u,0x54160436u),\nuvec4(0x30121315u,0xf1f1f1f1u,0x20422041u,0x23052322u),\nuvec4(0x04261405u,0x06080706u,0xf2030005u,0x40124032u),\nuvec4(0x10f0f001u,0x01020002u,0x07060402u,0x24160406u),\nuvec4(0x13151406u,0xf1f13012u,0x6041f1f1u,0x43220002u),\nuvec4(0x14152315u,0x13042726u,0x124032f2u,0x50f0f040u),\nuvec4(0x07060511u,0x24061436u,0x20121325u,0xf1f1f1f1u),\nuvec4(0x43326051u,0x34350415u,0x06080716u,0xf2100504u),\nuvec4(0xf0f0a022u,0x16050160u,0x06141614u,0x12133514u),\nuvec4(0xf1f1f120u,0x326051f1u,0x05244513u,0x06271644u),\nuvec4(0xf2000304u,0xf0f0a022u,0x06051150u,0x15541624u),\nuvec4(0xf1301223u,0x41f1f1f1u,0x05133260u,0x082716b4u),\nuvec4(0x00030607u,0xf0a022f2u,0x050160f0u,0x24261406u),\nuvec4(0x23151406u,0xf1f13012u,0x6041f1f1u,0x24252332u),\nuvec4(0x47164406u,0xf2000306u,0xf0f09032u,0x14050160u),\nuvec4(0x34060706u,0x23151406u,0xf1f13012u,0x6031f1f1u),\nuvec4(0x44251342u,0x04061406u,0x07083716u,0x42f20105u),\nuvec4(0x60f0f080u,0x06140501u,0x06340607u,0x12231514u),\nuvec4(0xf1f1f140u,0x12b001f1u,0x16a41513u,0x00010557u),\nuvec4(0x027032f2u,0x0160f0f0u,0x06040603u,0x15040607u),\nuvec4(0x05140604u,0xf1302233u,0x01f1f1f1u,0x152312b0u),\nuvec4(0x07143644u,0x04060738u,0x32f20002u,0x70f0f080u),\nuvec4(0x16072603u,0x43053415u,0xf1f13012u,0x6001f1f1u),\nuvec4(0x13122032u,0x36053405u,0x08271604u,0x05060407u),\nuvec4(0x8032f200u,0x0370f0f0u,0x34050456u,0x30122325u),\nuvec4(0xf1f1f1f1u,0x10426001u,0x04051312u,0x04050416u),\nuvec4(0x07240716u,0x14051718u,0xf08042f2u,0x560370f0u),\nuvec4(0x12231564u,0x81f1f130u,0x6031f130u,0x04051382u),\nuvec4(0x04162436u,0x08070605u,0x14050607u,0x8032f203u),\nuvec4(0x0370f0f0u,0x13156456u,0xf1f14012u,0x41f17041u),\nuvec4(0x04338250u,0x14061706u,0x04061706u,0x04062706u),\nuvec4(0xf2000205u,0xf0f08022u,0x03000250u,0x84050416u),\nuvec4(0x40121315u,0x0021f1f1u,0x32000223u,0x3031f110u),\nuvec4(0x14052392u,0x08062426u,0x04371607u,0xf2000305u),\nuvec4(0xf0f08022u,0x03000250u,0x03040605u,0x13055405u),\nuvec4(0x50020022u,0x0110c1f1u,0x11303210u,0x2011f140u),\nuvec4(0x03220052u,0x36241502u,0x08471614u,0x00030506u),\nuvec4(0xf09012f2u,0x030260f0u,0x00050405u,0x03055405u),\nuvec4(0xf1901102u,0x02110061u,0x23151305u,0x20e19052u),\nuvec4(0x13220052u,0x44161435u,0x05070947u,0x12f20003u),\nuvec4(0x60f0f090u,0x00021312u,0x16240604u,0x12030514u),\nuvec4(0xf1501100u,0x05022041u,0x02531554u,0x20d14250u),\nuvec4(0x13221042u,0x44350305u,0x07092736u,0xf2000205u),\nuvec4(0xf0f09012u,0x04034260u,0x27261406u,0x02050726u),\nuvec4(0xf1300203u,0x04032031u,0x23251466u,0x13224002u),\nuvec4(0x20c10002u,0x13220052u,0x04250312u,0x04061426u),\nuvec4(0x05070836u,0x22f20002u,0x60f0f080u,0x26241332u),\nuvec4(0x05040678u,0x90010003u,0x15032091u,0x07043604u),\nuvec4(0x05042608u,0x12700203u,0xc1000223u,0x03002210u),\nuvec4(0x07043332u,0x15060726u,0x16040503u,0x08070607u),\nuvec4(0x00020507u,0xf07032f2u,0x133260f0u,0x09073605u),\nuvec4(0x17381708u,0x02050406u,0x123041b0u,0x56040523u),\nuvec4(0x00031504u,0x00424051u,0x130200d1u,0x32030200u),\nuvec4(0x06170605u,0x00010003u,0x05020011u,0x06170604u),\nuvec4(0x05070908u,0x32f20002u,0x60f0f070u,0x05031022u),\nuvec4(0x08190827u,0x09171807u,0x04061708u,0x10f01215u),\nuvec4(0x25022312u,0x00030514u,0x1012a051u,0x130200d1u),\nuvec4(0x02001312u,0x03050310u,0x03026102u,0x06070604u),\nuvec4(0x07090704u,0xf2000105u,0xf0f07032u,0x02002260u),\nuvec4(0x18370405u,0x18072847u,0x05040607u,0x42000203u),\nuvec4(0x22001270u,0x11200130u,0x23150300u,0x12400140u),\nuvec4(0x0200c120u,0x20130223u,0x00021061u,0x17040211u),\nuvec4(0x08090716u,0xf2000105u,0xf0f07032u,0x02002260u),\nuvec4(0x06070604u,0x26142607u,0x18070617u,0x55041617u),\nuvec4(0x52302203u,0x02100230u,0x06270415u,0x05040504u),\nuvec4(0xd1a00223u,0x02031200u,0x10050403u,0x03120051u),\nuvec4(0x09062102u,0x01051938u,0x6042f200u,0x2260f0f0u),\nuvec4(0x36040510u,0x16040674u,0x06070817u,0x13050654u),\nuvec4(0x40423002u,0x17051002u,0x00510314u,0x02030503u),\nuvec4(0xd1600110u,0x00130200u,0x10040603u,0x03420041u),\nuvec4(0x09080411u,0x09080708u,0x00010507u,0xf04062f2u),\nuvec4(0x001270f0u,0x26040301u,0x25133514u,0x26171614u),\nuvec4(0x03051634u,0x1302d002u,0x41050604u,0x05003112u),\nuvec4(0x22030516u,0x0200f110u,0x07050213u,0x31000104u),\nuvec4(0x02300200u,0x03010203u,0x07080906u,0x05060809u),\nuvec4(0x72f20001u,0x70f0f030u,0x36030122u,0x66541504u),\nuvec4(0x02055637u,0x040512d0u,0x02010305u,0x06040604u),\nuvec4(0x05040618u,0x06000103u,0x05040708u,0xf1100203u),\nuvec4(0x03050200u,0x05070405u,0x00110051u,0x01130011u),\nuvec4(0x07380600u,0xf2000506u,0xf0f02092u,0x04100290u),\nuvec4(0x04362426u,0x14150415u,0x03464706u,0x02405100u),\nuvec4(0x15030213u,0x07040300u,0x09080609u,0x18190407u),\nuvec4(0x17041105u,0xf1200306u,0x16250200u,0x01001105u),\nuvec4(0x31001210u,0x06110302u,0x03142807u,0xf010b2f2u),\nuvec4(0x000290f0u,0x04060502u,0x05141826u,0x05024100u),\nuvec4(0x04671804u,0x30610003u,0x02152302u,0x08041605u),\nuvec4(0x07090706u,0x06051605u,0x02110508u,0x10120314u),\nuvec4(0x050200e1u,0x06040503u,0x11000304u,0x00230200u),\nuvec4(0x02050021u,0x16170501u,0xf2030504u,0xf0f000c2u),\nuvec4(0x040312a0u,0x08090726u,0x04050305u,0x04061706u),\nuvec4(0x09071406u,0x03041748u,0x02107100u,0x05033503u),\nuvec4(0x01030607u,0x08190716u,0x02010407u,0x11040807u),\nuvec4(0xe1103200u,0x05130200u,0x20030524u,0x21200102u),\nuvec4(0x02011300u,0x05140706u,0xf0e2f203u,0x200290f0u),\nuvec4(0x06071605u,0x49280718u,0x09182918u,0x06080908u),\nuvec4(0x81000305u,0x25030200u,0x03170403u,0x05060411u),\nuvec4(0x05160806u,0x04170511u,0x02032003u,0x0200f100u),\nuvec4(0x14050203u,0x02050406u,0x12006120u,0x09080301u),\nuvec4(0x00030504u,0xf0f0e2f2u,0x02200290u,0x08070604u),\nuvec4(0x07190809u,0x07080604u,0x07091619u,0x04062938u),\nuvec4(0x0625d110u,0x46002105u,0x01001104u,0x00121300u),\nuvec4(0x01f11001u,0x15032200u,0x10220406u,0x05011071u),\nuvec4(0xf2030519u,0xf0f002f2u,0x050012b0u,0x19180706u),\nuvec4(0x04020507u,0x07090817u,0x48040518u,0x02040709u),\nuvec4(0x0500c100u,0x00021103u,0x05001102u,0x00211504u),\nuvec4(0x41f12021u,0x15033210u,0x20030203u,0x05110061u),\nuvec4(0x03050908u,0xf002f2f2u,0x0112b0f0u,0x16070402u),\nuvec4(0x05070907u,0x08370403u,0x04050709u,0x09280708u),\nuvec4(0xb1100408u,0x12000220u,0x10713200u,0x022081f1u),\nuvec4(0x05004223u,0x00510304u,0x07090411u,0x12f2f205u),\nuvec4(0x0290f0f0u,0x05010220u,0x07190716u,0x27040504u),\nuvec4(0x05041806u,0x08040516u,0x05070907u,0x0200e100u),\nuvec4(0x05032553u,0xf1100102u,0x231210b1u,0x03020002u),\nuvec4(0x09050002u,0x02610307u,0x13040907u,0xf002f2f2u),\nuvec4(0x402280f0u,0x08070605u,0x05040709u,0x07060503u),\nuvec4(0x11020504u,0x05370520u,0x030201f1u,0x03221504u),\nuvec4(0x00021302u,0x81f10031u,0x05032210u,0x02100100u),\nuvec4(0x06040200u,0x00211005u,0x04170301u,0xf2f20305u),\nuvec4(0x60f0f002u,0x00123022u,0x04172603u,0x02130005u),\nuvec4(0x01201100u,0x07160500u,0x01f10506u,0x24050200u),\nuvec4(0x30020305u,0x81f10041u,0x05131210u,0x02302102u),\nuvec4(0x31000203u,0x05042600u,0x02f2f203u,0x0280f0f0u),\nuvec4(0x02011230u,0x07060416u,0x14160416u,0x03222305u),\nuvec4(0xf1032605u,0x03121001u,0x02030514u,0xf1101140u),\nuvec4(0x23021081u,0x61000305u,0x31000200u,0x25040703u),\nuvec4(0xf012f2f2u,0x000280f0u,0x00022002u,0x17160402u),\nuvec4(0x03054406u,0x16042342u,0xf1000103u,0x00010001u),\nuvec4(0x02132502u,0x1081f160u,0x13150302u,0x11003102u),\nuvec4(0x03111022u,0xf2230506u,0xf0f012f2u,0x02302290u),\nuvec4(0x08070614u,0x03150406u,0x33120332u,0x11031604u),\nuvec4(0x2110f100u,0x50121302u,0x121091f1u,0x31021315u),\nuvec4(0x01122100u,0x04050110u,0x42f2f203u,0xf01240f0u),\nuvec4(0x04031072u,0x04160726u,0x12004305u,0x16041513u),\nuvec4(0x0071f103u,0x91f17012u,0x04052200u,0x00020305u),\nuvec4(0x01000261u,0xf2151100u,0xf0f052f2u,0x05105280u),\nuvec4(0x02131586u,0x24031210u,0xf1000316u,0x91f1a061u),\nuvec4(0x05130200u,0x71000314u,0x13023100u,0xf2106200u),\nuvec4(0x0290f0b2u,0x051072b0u,0x04362406u,0x00221305u),\nuvec4(0x24030002u,0xf1020406u,0x001110a1u,0x0200c1f1u),\nuvec4(0x00240503u,0x00910011u,0xf2108213u,0x2280f0b2u),\nuvec4(0x02008290u,0x16140604u,0x20023304u,0x14031012u),\nuvec4(0xf1f10516u,0x0300d1f1u,0x01103405u,0x03106110u),\nuvec4(0xf2f20305u,0x2280f062u,0x03009280u,0x16140604u),\nuvec4(0x22010005u,0x03002220u,0x04060406u,0xf1f1f103u),\nuvec4(0x030220a1u,0x10010044u,0xf2031591u,0xf0f062f2u),\nuvec4(0x3403b230u,0x02050406u,0x05012260u,0x00040614u),\nuvec4(0x91f1f1f1u,0x05030220u,0x14050406u,0x71000100u),\nuvec4(0x04000100u,0xf2001205u,0xf0f042f2u,0x0200a220u),\nuvec4(0x04261403u,0x50020305u,0x24050022u,0xf1f1f105u),\nuvec4(0x13121091u,0x25040604u,0x01108102u,0x12050603u),\nuvec4(0x42f2f200u,0xc200f0f0u,0x14050200u,0x03051416u),\nuvec4(0x04424002u,0x00031406u,0x71f1f1f1u,0x05230210u),\nuvec4(0x11031534u,0x21001100u,0x06040110u,0xf2f20105u),\nuvec4(0x00f0f062u,0x050200c2u,0x14260406u,0x30020305u),\nuvec4(0x04020022u,0xf1020516u,0x6031f1f1u,0x04151302u),\nuvec4(0x03150406u,0x01107102u,0x05040600u,0x62f2f200u),\nuvec4(0xc200f0f0u,0x14060310u,0x22032416u,0x03002210u),\nuvec4(0x10050416u,0x21f1f1f1u,0x05131250u,0x03022524u),\nuvec4(0x06039100u,0x03d20305u,0xf0f082f2u,0x0300d200u),\nuvec4(0x05241624u,0x03006203u,0x10030416u,0x21f1f1f1u),\nuvec4(0x02101110u,0x25241513u,0x04910213u,0xd2030506u),\nuvec4(0xf082f203u,0x00d200f0u,0x34261402u,0x03015213u),\nuvec4(0x03060406u,0x0031f110u,0x1011f1f1u,0x05041302u),\nuvec4(0x00030554u,0x14060481u,0xf2000205u,0xf0f052f2u),\nuvec4(0x0510d200u,0x05243604u,0x05004213u,0xf1000324u),\nuvec4(0xd1f12031u,0x12100100u,0x06340503u,0x00030524u),\nuvec4(0x07080371u,0x00120416u,0xf042f2f2u,0x00e200f0u),\nuvec4(0x23443605u,0x15161022u,0x31f10003u,0x20d1f120u),\nuvec4(0x05142302u,0x06142604u,0x21000205u,0x06031100u),\nuvec4(0xf2010538u,0xf0f062f2u,0x040300f2u,0x13055416u),\nuvec4(0x07030022u,0x03050306u,0x2021f110u,0x0220c1f1u),\nuvec4(0x06140533u,0x04160708u,0x15030406u,0x07050021u),\nuvec4(0x04180708u,0xf2f20100u,0xf2e0f062u,0x05030002u),\nuvec4(0x05441604u,0x05002213u,0x15030407u,0x3031f102u),\nuvec4(0x025081f1u,0x14030213u,0x14161716u,0x07060305u),\nuvec4(0x04030103u,0x08170807u,0x02000409u,0x52f2f203u),\nuvec4(0x22f2d0f0u,0x16070413u,0x05040624u,0x06031213u),\nuvec4(0x04150607u,0x2120e105u,0x7031f140u,0x26143312u),\nuvec4(0x05041607u,0x03160503u,0x16270605u,0x03070907u),\nuvec4(0xf21342f2u,0xf2d0f002u,0x07060532u,0x02130566u),\nuvec4(0x07060500u,0x04061406u,0x31002105u,0x07060500u),\nuvec4(0x31200304u,0x8011f140u,0x03020312u,0x07360415u),\nuvec4(0x06041516u,0x08050205u,0x04361809u,0x32f20002u),\nuvec4(0xd0f0e233u,0x060532f2u,0x03045617u,0x04010002u),\nuvec4(0x16270607u,0x31000504u,0x06170502u,0x20030417u),\nuvec4(0x01f14031u,0x02300130u,0x15030213u,0x06041706u),\nuvec4(0x06140617u,0x08041305u,0x04060719u,0xf2131015u),\nuvec4(0xf0e23322u,0x0022f2d0u,0x27080605u,0x05160416u),\nuvec4(0x06020002u,0x18070607u,0x15040627u,0x04050003u),\nuvec4(0x12100305u,0xf1406100u,0x02202130u,0x05130213u),\nuvec4(0x07360726u,0x04130516u,0x06070908u,0x00020407u),\nuvec4(0x5352f203u,0xf2e0f0c2u,0x04030012u,0x06144607u),\nuvec4(0x02010204u,0x09482706u,0x05261708u,0x30e140e1u),\nuvec4(0x13023021u,0x17160425u,0x05160726u,0x17050302u),\nuvec4(0x10040716u,0xc25362f2u,0x02f2f0f0u,0x08060300u),\nuvec4(0x06143607u,0x03000204u,0x29680706u,0x04170407u),\nuvec4(0x10021001u,0x10d14091u,0x03023041u,0x06242502u),\nuvec4(0x06171607u,0x03020304u,0x03261704u,0x62f20001u),\nuvec4(0xf0f0c253u,0x0300f200u,0x36170806u,0x05120514u),\nuvec4(0x09080706u,0x09280708u,0x03050608u,0x20431405u),\nuvec4(0x00e12091u,0x03023041u,0x07342502u,0x08090706u),\nuvec4(0x15020504u,0x20360706u,0xc25362f2u,0xe210f0f0u),\nuvec4(0x17060300u,0x00051446u,0x07060405u,0x06081948u),\nuvec4(0x05161305u,0x02230504u,0x02000200u,0xf1107100u),\nuvec4(0x03123041u,0x07262405u,0x06080716u,0x04050305u),\nuvec4(0x05040617u,0x02000100u,0x5342f200u,0x10f0f0d2u),\nuvec4(0x060300e2u,0x06071617u,0x05030524u,0x09380716u),\nuvec4(0x05040708u,0x04060413u,0x13051405u,0x10021322u),\nuvec4(0x1240b1f1u,0x06240503u,0x06181637u,0x06070615u),\nuvec4(0x01000304u,0x6352f210u,0xf0f000c2u,0x0300d220u),\nuvec4(0x27160706u,0x06041524u,0x03350667u,0x15040534u),\nuvec4(0x02230533u,0x3081f110u,0x03121002u,0x06370624u),\nuvec4(0x06070604u,0x07060305u,0x22100504u,0xa2235200u),\nuvec4(0xf000c273u,0x00d220f0u,0x06070602u,0x06441627u),\nuvec4(0x04262708u,0x02051405u,0x04153405u,0x02430533u),\nuvec4(0xf1000130u,0x10123011u,0x04030002u,0x37160406u),\nuvec4(0x05041716u,0x22030417u,0x92435210u,0xf000c273u),\nuvec4(0x00d220f0u,0x17260705u,0x05140604u,0x16070614u),\nuvec4(0x34071607u,0x15440305u,0x23041304u,0x23050405u),\nuvec4(0x40c15012u,0x03021032u,0x06176604u,0x06081617u),\nuvec4(0x53524015u,0x00c27382u,0xe220f0f0u,0x18171605u),\nuvec4(0x34060406u,0x16140766u,0x06040304u,0x06040524u),\nuvec4(0x13140305u,0x53050405u,0x00220002u,0x50210061u),\nuvec4(0x03122302u,0x04662405u,0x06091617u,0x93623015u),\nuvec4(0x00e28312u,0xc220f0f0u,0x07060513u,0x07180708u),\nuvec4(0x07663416u,0x03060716u,0x04050301u,0x15161407u),\nuvec4(0x05130514u,0x42031543u,0x12504100u,0x05331220u),\nuvec4(0x16040514u,0x07060447u,0x05060914u,0x93920003u),\nuvec4(0x42f22322u,0x60f002a0u,0x040503c2u,0x16083706u),\nuvec4(0x36240504u,0x06270617u,0x04033105u,0x25141746u),\nuvec4(0x25130503u,0x22000213u,0x02003100u,0x12100203u),\nuvec4(0x05131210u,0x05140513u,0x08172604u,0x05071607u),\nuvec4(0x05040704u,0x93920003u,0x52f22312u,0xb220f0f0u),\nuvec4(0x06040513u,0x05041647u,0x08073614u,0x08071817u),\nuvec4(0x21000507u,0x17160400u,0x25160709u,0x05240523u),\nuvec4(0x11102223u,0x10130210u,0x35232012u,0x08072634u),\nuvec4(0x06140637u,0x72010315u,0xf2233293u,0x20f0f052u),\nuvec4(0x041503b2u,0x07181706u,0x07161756u,0x05363708u),\nuvec4(0x14030203u,0x24262716u,0x05440523u,0x11102203u),\nuvec4(0x13008210u,0x24250302u,0x17080736u,0x05040608u),\nuvec4(0x72000334u,0xf2332293u,0x7230f052u,0x0503a270u),\nuvec4(0x18270604u,0x16171607u,0x460436a7u,0x08090807u),\nuvec4(0x06070807u,0x04350407u,0x03051426u,0x00020002u),\nuvec4(0x13721001u,0x03022302u,0x07062415u,0x17080716u),\nuvec4(0x25040608u,0x03120604u,0x23229362u,0x10f062f2u),\nuvec4(0x05b250b2u,0x28270604u,0x48273617u,0x18391807u),\nuvec4(0x08170879u,0x26440609u,0x02030524u,0x22100203u),\nuvec4(0x03153340u,0x24050302u,0x07080706u,0x27080706u),\nuvec4(0x05230406u,0x93721004u,0x62f22322u,0xa2f220f0u),\nuvec4(0x06040513u,0x08091817u,0x06070617u,0x09080627u),\nuvec4(0x08190708u,0x06071819u,0x17160437u,0x07080728u),\nuvec4(0x04260406u,0x13052416u,0x22000305u,0x02000203u),\nuvec4(0x35040503u,0x15030504u,0x08070624u,0x09070407u),\nuvec4(0x04170608u,0x04000305u,0x01001107u,0x23427352u),\nuvec4(0x40f062f2u,0x020372f2u,0x37160403u,0x47061718u),\nuvec4(0x17080706u,0x16070908u,0x13100203u,0x02010002u),\nuvec4(0x27241503u,0x07061406u,0x14161406u,0x03050415u),\nuvec4(0x03000332u,0x2706c405u,0x18070406u,0x05040817u),\nuvec4(0x07040103u,0x33020510u,0x23427312u,0x40f062f2u),\nuvec4(0x000372f2u,0x37160405u,0x07161718u,0x47160708u),\nuvec4(0x03050608u,0x02002100u,0x02000201u,0x16050233u),\nuvec4(0x05040708u,0x04362704u,0x02031245u,0x26141513u),\nuvec4(0x16140534u,0x18071627u,0x05070807u,0x07040113u),\nuvec4(0x23160001u,0x23426332u,0x40f062f2u,0x021362f2u),\nuvec4(0x26870605u,0x09071617u,0x07080917u,0x00121304u),\nuvec4(0x30320332u,0x09080403u,0x27040506u,0x04051436u),\nuvec4(0x13120516u,0x06071415u,0x56242624u,0x05271817u),\nuvec4(0x16000300u,0x05060511u,0x22000203u,0xf2234263u),\nuvec4(0xf240f062u,0x06040382u,0x16370817u,0x16071614u),\nuvec4(0x04060708u,0x32050417u,0x12601210u,0x06050001u),\nuvec4(0x04050608u,0x36070807u,0x05040634u,0x05040533u),\nuvec4(0x14060706u,0x06071406u,0x36041604u,0x00051647u),\nuvec4(0x03040302u,0x06080411u,0x73120305u,0x62f21362u),\nuvec4(0x72f240f0u,0x27060300u,0x14163708u,0x07060406u),\nuvec4(0x16040728u,0x12000504u,0x22700220u,0x16050200u),\nuvec4(0x47180604u,0x06040506u,0x05030524u,0x05040503u),\nuvec4(0x07045604u,0x16278608u,0x03000504u,0x03110305u),\nuvec4(0x06080908u,0x63120305u,0x62f21362u,0x82f240f0u),\nuvec4(0x37083705u,0x07360416u,0x36180908u,0x02102305u),\nuvec4(0x00226013u,0x14160403u,0x15073827u,0x05041604u),\nuvec4(0x24150403u,0x07163706u,0x37260708u,0x25060726u),\nuvec4(0x00111400u,0x07180904u,0x22130504u,0x02f2f223u),\nuvec4(0x72f240f0u,0x27060403u,0x04164708u,0x17083706u),\nuvec4(0x22131536u,0x20220315u,0x05020022u,0x38372604u),\nuvec4(0x16040506u,0x26541504u,0x37161708u,0x07263706u),\nuvec4(0x05041506u,0x04110304u,0x04172809u,0x23122305u),\nuvec4(0x03021372u,0x40f032f2u,0x060572f2u,0x18071837u),\nuvec4(0x36040607u,0x17080907u,0x22033526u,0x03050405u),\nuvec4(0x15021062u,0x06070604u,0x07095807u,0x34060716u),\nuvec4(0x08262406u,0x06870847u,0x16040607u,0x05110504u),\nuvec4(0x07280908u,0x13050416u,0x43821312u,0x40f022f2u),\nuvec4(0x050362f2u,0x67281716u,0x09080716u,0x04061728u),\nuvec4(0x03220325u,0x03120315u,0x05131042u,0x58270604u),\nuvec4(0x06071607u,0x06140604u,0x06173614u,0x08091807u),\nuvec4(0x06571607u,0x10041714u,0x07180605u,0x04061718u),\nuvec4(0x13524305u,0x22f24312u,0x62f240f0u,0x07160503u),\nuvec4(0x67080708u,0x08060406u,0x06272819u,0x05040514u),\nuvec4(0x02031523u,0x04235223u,0x17482706u,0x07761426u),\nuvec4(0x09082716u,0x47161718u,0x02041716u,0x18060301u),\nuvec4(0x16071827u,0x13623304u,0x22f25302u,0x72f240f0u),\nuvec4(0x87160405u,0x09080726u,0x14061748u,0x03050405u),\nuvec4(0x13052335u,0x05331012u,0x48170806u,0x06040719u),\nuvec4(0x26171614u,0x06070807u,0x18071837u,0x17162726u),\nuvec4(0x05010204u,0x07090806u,0x07182708u,0x23050406u),\nuvec4(0x63122302u,0x13321302u,0xf230f0c2u,0x26040382u),\nuvec4(0x08272667u,0x14463809u,0x23353415u,0x04052332u),\nuvec4(0x09081758u,0x06042607u,0x08270867u,0x08070817u),\nuvec4(0x06070817u,0x26070807u,0x03010304u,0x07081906u),\nuvec4(0x06280728u,0x13020504u,0x63023302u,0x12b052f2u),\nuvec4(0x0362f250u,0x26040302u,0x08370677u,0x26171819u),\nuvec4(0x06142504u,0x05240504u,0x02032233u,0x08060503u),\nuvec4(0x08071809u,0x18170827u,0x27086716u,0x27281708u),\nuvec4(0x04262708u,0x08041305u,0x18174819u,0x23040607u),\nuvec4(0x1302a302u,0x30f032f2u,0x020362f2u,0x04260403u),\nuvec4(0x08871807u,0x04470829u,0x06140503u,0x04050607u),\nuvec4(0x33050406u,0x04051322u,0x07280706u,0x07060718u),\nuvec4(0x04071908u,0x47083706u,0x09180728u,0x07180708u),\nuvec4(0x34060726u,0x27581907u,0x05041708u,0x02831223u),\nuvec4(0xf042f203u,0x0362f230u,0x26140302u,0x18171807u),\nuvec4(0x08093837u,0x06341547u,0x02530534u,0x16040523u),\nuvec4(0x07190827u,0x09080706u,0x07040617u,0x09187708u),\nuvec4(0x04060778u,0x24060706u,0x09182906u,0x07082738u),\nuvec4(0x12230506u,0xf2030283u,0xf210f042u,0x03021372u),\nuvec4(0x18073604u,0x17061817u,0x09181908u,0x25944708u),\nuvec4(0x05530203u,0x06040604u,0x28372928u,0x08070406u),\nuvec4(0x28076877u,0x05044607u,0x19080704u,0x07281768u),\nuvec4(0x83023305u,0x10f062f2u,0x163372f2u,0x38070604u),\nuvec4(0x08171807u,0x06473829u,0x15130584u,0x36040543u),\nuvec4(0x08192807u,0x08092807u,0x28870826u,0x36075809u),\nuvec4(0x08170614u,0x38072809u,0x04071827u,0x12131203u),\nuvec4(0xf062f263u,0x0392f210u,0x08072605u,0x18072807u),\nuvec4(0x08591807u,0x15840647u,0x05040503u,0x06040533u),\nuvec4(0x38070617u,0xa8d74819u,0x04250607u,0x48090807u),\nuvec4(0x38171827u,0x02030507u,0xf2631213u,0xf210f062u),\nuvec4(0x06040392u,0x08070827u,0x58170809u,0x06370839u),\nuvec4(0x05441644u,0x06145514u,0x28070607u,0x28070819u),\nuvec4(0x18270617u,0x48371807u,0x06073817u,0x08061504u),\nuvec4(0x0809e819u,0x02030504u,0xf062f293u,0x0392f210u),\nuvec4(0x08170604u,0x17081917u,0x37082968u,0x04363406u),\nuvec4(0x04055406u,0x05041506u,0x07060704u,0x19070809u),\nuvec4(0x09081708u,0x07183718u,0x27681708u,0x07260738u),\nuvec4(0x0809b869u,0xa3050406u,0x00f062f2u,0x020082f2u),\nuvec4(0x37061405u,0x68170819u,0x06371819u,0x06043634u),\nuvec4(0x05040564u,0x04050403u,0x17080716u,0x08270908u),\nuvec4(0x38173809u,0x38090817u,0x28071809u,0x08070617u),\nuvec4(0x0607c889u,0xf2930504u,0xf210f062u,0x05020072u),\nuvec4(0x19182714u,0x19081708u,0x27280938u,0x34362426u),\nuvec4(0x14061406u,0x05041506u,0x07040604u,0x09081708u),\nuvec4(0x38090827u,0x08073827u,0x0617a809u,0x09a8a908u),\nuvec4(0x05041708u,0xf072f273u,0x0072f210u,0x06041502u),\nuvec4(0x08091817u,0x68291817u,0x16242627u,0x16241654u),\nuvec4(0x06040524u,0x17180704u,0x28278809u,0x78074827u),\nuvec4(0x78d90807u,0x06071819u,0x03124305u,0x50f062f2u),\nuvec4(0x050352f2u,0x18170604u,0x28070809u,0x36177829u),\nuvec4(0x05141614u,0x56140524u,0x07041614u,0x08170809u),\nuvec4(0x09080709u,0x27083758u,0xf9580748u,0x08396829u),\nuvec4(0x02030516u,0xf092f213u,0x2332f250u,0x17060405u),\nuvec4(0x07080918u,0x37680738u,0x14154476u,0x04362726u),\nuvec4(0x18171807u,0x48190807u,0x38079867u,0x494829f9u),\nuvec4(0x05040607u,0x03123302u,0x50f042f2u,0x050332f2u),\nuvec4(0x17060413u,0x07081908u,0x37680738u,0x44052476u),\nuvec4(0x07064726u,0x07280706u,0x07282718u,0x07184738u),\nuvec4(0xf9282748u,0x17594829u,0x02031506u,0xf2031213u),\nuvec4(0xf250f042u,0x03150332u,0x09082704u,0x29281708u),\nuvec4(0x17281718u,0x14064496u,0x07081736u,0x07181726u),\nuvec4(0x09082718u,0x07184758u,0x17080738u,0x1839f918u),\nuvec4(0x08590819u,0x00031417u,0x80f092f2u,0x150302f2u),\nuvec4(0x07060503u,0x17080918u,0x17182928u,0x47261728u),\nuvec4(0x04261416u,0x07260406u,0x37061716u,0x27180728u),\nuvec4(0x58774819u,0x18492807u,0x080708c9u,0x06071889u),\nuvec4(0x82f21005u,0x02f280f0u,0x05030503u,0x09280604u),\nuvec4(0x17681968u,0x14263726u,0x06080776u,0x57080704u),\nuvec4(0x17280718u,0x08093819u,0x28173877u,0x08d90849u),\nuvec4(0x18990807u,0x01030407u,0xf2133200u,0xf280f012u),\nuvec4(0x04030023u,0xd8073807u,0x08072617u,0x06374627u),\nuvec4(0x06370604u,0x48071657u,0x07181917u,0x17388718u),\nuvec4(0xf9182928u,0x0908b908u,0x32130407u,0xf012f213u),\nuvec4(0x1223e280u,0x07180403u,0x78070809u,0x36171827u),\nuvec4(0x36270807u,0x06070837u,0x090604c7u,0x08171817u),\nuvec4(0x09180719u,0x17288708u,0xf9074908u,0x140608f9u),\nuvec4(0x13120305u,0x03220312u,0xc290f0a2u,0x05000233u),\nuvec4(0xb7980937u,0x07163708u,0x1627f706u,0x07280618u),\nuvec4(0x38071908u,0x08170827u,0xf9f96807u,0x04260769u),\nuvec4(0x13026305u,0xc290f0a2u,0x04020033u,0x47b80718u),\nuvec4(0x09084706u,0x07065708u,0x87066718u,0x07080704u),\nuvec4(0x48192718u,0x58073807u,0xf9f95817u,0x16071829u),\nuvec4(0x02130504u,0xa0f08263u,0x050233b2u,0xa8170807u),\nuvec4(0x18174647u,0x08070607u,0x18070627u,0x04870667u),\nuvec4(0x19471806u,0x19080798u,0x09181728u,0x59f9f918u),\nuvec4(0x14061708u,0x62731205u,0x43a2a0f0u,0x27090605u),\nuvec4(0x07880708u,0x17161718u,0x17180706u,0x06270806u),\nuvec4(0x08071817u,0x16070827u,0x08170837u,0x17280716u),\nuvec4(0x19c80908u,0xf9382728u,0x172859f9u,0x12050406u),\nuvec4(0xb0f07253u,0x18054392u,0x07180706u,0x67180788u),\nuvec4(0x16085728u,0x18070807u,0x16070927u,0x08070807u),\nuvec4(0x06070827u,0x09370807u,0x383718f8u,0x8918c9f9u),\nuvec4(0x03052718u,0xf0724312u,0x0433a2b0u,0x07040708u),\nuvec4(0x37a82708u,0x4706b706u,0x07181708u,0x38090816u),\nuvec4(0x16070807u,0x07480947u,0x87180738u,0x48d9f928u),\nuvec4(0x06171869u,0x23320304u,0x0210f062u,0x021372b0u),\nuvec4(0x16080603u,0x09084708u,0x37061768u,0x37063706u),\nuvec4(0x27080706u,0x06380718u,0x08072807u,0x07160827u),\nuvec4(0x09181708u,0x09181728u,0x09080708u,0xf9485708u),\nuvec4(0x187928f9u,0x03041607u,0xf0523322u,0x82901210u),\nuvec4(0x06050213u,0x16091709u,0x48190827u,0x06270627u),\nuvec4(0x06170604u,0x08370617u,0x08070837u,0x17061709u),\nuvec4(0x07181708u,0x08161708u,0x68091817u,0x08092809u),\nuvec4(0xf9f94837u,0x161718c9u,0x63120005u,0x2200f022u),\nuvec4(0x04338280u,0x08070807u,0x08170827u,0x06175809u),\nuvec4(0x26173617u,0x187738a7u,0x06070817u,0x07680704u),\nuvec4(0x49283798u,0x69f9f918u,0x03063728u,0xf0028312u),\nuvec4(0x13828032u,0x07061405u,0x07080908u,0x19180908u),\nuvec4(0x17060768u,0x07085736u,0xc7381748u,0x06070809u),\nuvec4(0x1738f807u,0x49080908u,0x69f9f908u,0x17180738u),\nuvec4(0x12030504u,0x32500263u,0x82803250u,0x04060513u),\nuvec4(0x19281706u,0x37582918u,0x07088706u,0x27281748u),\nuvec4(0x07199708u,0x19c81706u,0x08692738u,0x7869f9f9u),\nuvec4(0x93050617u,0x32404250u,0x05138280u,0x28070624u),\nuvec4(0x19070819u,0x97065748u,0x472857a8u,0x27080908u),\nuvec4(0x27882968u,0xf9184918u,0x591819f9u,0x15060758u),\nuvec4(0x40030553u,0x2002d052u,0x03050372u,0x18172405u),\nuvec4(0x38190839u,0xc8375647u,0x18372867u,0x68170819u),\nuvec4(0x48072819u,0x18491837u,0x1918d9f9u,0x17385928u),\nuvec4(0x43050416u,0x52400305u,0x820022c0u,0x16040523u),\nuvec4(0x58691807u,0xc8375637u,0x08272877u,0x09082729u),\nuvec4(0x17582778u,0xf9f92806u,0x58190829u,0x58191809u),\nuvec4(0x05041607u,0x05130503u,0xb0624003u,0x260533b2u),\nuvec4(0x08391807u,0x48091819u,0xf8570647u,0x29089708u),\nuvec4(0x27981708u,0x38060768u,0x1938e9f9u,0x09280968u),\nuvec4(0x04160758u,0x62403315u,0x0543b2a0u,0x07060706u),\nuvec4(0x29083918u,0x09281718u,0x38370857u,0x0817c809u),\nuvec4(0x08195817u,0x18290827u,0x28072819u,0x38071827u),\nuvec4(0x1938e9f9u,0x161718f8u,0x30131514u,0x03e27082u),\nuvec4(0x03020302u,0x49081706u,0x07082758u,0x27185716u),\nuvec4(0x081718f8u,0x08195817u,0x68493817u,0x08074827u),\nuvec4(0xa9f90829u,0x19182928u,0x040637e8u,0xb2301305u),\nuvec4(0x0322f210u,0x06050305u,0x58390827u,0x04070837u),\nuvec4(0x16070807u,0xf8170637u,0x07184708u,0x39780938u),\nuvec4(0x09582778u,0xf9f90718u,0x78194859u,0x05040637u),\nuvec4(0xd2f23003u,0x05231203u,0x09082706u,0x07281908u),\nuvec4(0x06382708u,0x06370637u,0x08091817u,0x4837b807u),\nuvec4(0x68190817u,0x58277839u,0xf9f93809u,0x88194849u),\nuvec4(0x30050647u,0x12f200b2u,0x19370443u,0x57380908u),\nuvec4(0x07083718u,0x09087706u,0x27680708u,0x17284728u),\nuvec4(0x37180908u,0x17783918u,0x07382728u,0x59f9f908u),\nuvec4(0x37b80938u,0x10a23006u,0x053312f2u,0x08170806u),\nuvec4(0x48070809u,0x186706d7u,0x58070809u,0x18071817u),\nuvec4(0x08270857u,0xd8471809u,0x08090807u,0xf9f95827u),\nuvec4(0x78098859u,0x30070817u,0x02f210a2u,0x05030203u),\nuvec4(0x38090714u,0x06073827u,0x086716a7u,0x08877819u),\nuvec4(0x48573867u,0x08092817u,0x18090809u,0x18092827u),\nuvec4(0x7859f9f9u,0x08079819u,0xf2108250u,0x04150322u),\nuvec4(0x27281908u,0x27161728u,0x67164716u,0x19181908u),\nuvec4(0x37261738u,0x47486708u,0x074819b8u,0x69f9f958u),\nuvec4(0x095819b8u,0xf2108250u,0x15130002u,0x08090704u),\nuvec4(0x16370857u,0x18171627u,0x18671607u,0x48191809u),\nuvec4(0x08471617u,0x28673847u,0x28072819u,0x28172819u),\nuvec4(0x08070807u,0x0889f9f9u,0x68194839u,0x12104250u),\nuvec4(0x2302f210u,0x08071405u,0x28170809u,0x36071807u),\nuvec4(0x06070807u,0x28572637u,0x28290819u,0x07040627u),\nuvec4(0x07180728u,0x07160708u,0x07060718u,0x19b82708u),\nuvec4(0x27281728u,0x0889f908u,0x3829f907u,0x42507819u),\nuvec4(0xf2101210u,0x04050322u,0x27280706u,0x27460738u),\nuvec4(0x04063706u,0x59384706u,0x06043728u,0x07381718u),\nuvec4(0x17185716u,0x39381748u,0x17280728u,0xe9f9f908u),\nuvec4(0x17483928u,0x12101280u,0x0002f210u,0x04050302u),\nuvec4(0x47081706u,0x17162738u,0x67162726u,0x27381968u),\nuvec4(0x08370604u,0x08770817u,0x28372847u,0x28091809u),\nuvec4(0x08073807u,0x0889f9f9u,0x78292849u,0xf2102270u),\nuvec4(0x14230042u,0x47080706u,0x57280718u,0x07064706u),\nuvec4(0x07080708u,0x270809c8u,0x37080716u,0x57088706u),\nuvec4(0x09283718u,0x17780918u,0x28f9f9f9u,0x58070819u),\nuvec4(0xf2103260u,0x04152342u,0x97384706u,0xd8071866u),\nuvec4(0x06270819u,0x06271657u,0x08670847u,0x18092837u),\nuvec4(0x08c97819u,0x4918b9f9u,0x07081928u,0x30e26058u),\nuvec4(0x04052362u,0x38570405u,0x08372607u,0x38671627u),\nuvec4(0x48192819u,0x16570627u,0x28170647u,0x18073857u),\nuvec4(0x08095859u,0x1899f9f9u,0x600758a9u,0x335230e2u),\nuvec4(0x05030405u,0x48072607u,0x36473607u,0x68079837u),\nuvec4(0x16871857u,0x08090817u,0x38694857u,0xf9f92807u),\nuvec4(0x383918a9u,0xf2606829u,0x13153372u,0x04060804u),\nuvec4(0x17381706u,0x27082726u,0x17183706u,0x071647c8u),\nuvec4(0x17163728u,0x09081716u,0x09183708u,0x49080728u),\nuvec4(0xf9482908u,0x6918a9f9u,0x07580928u,0x3382f250u),\nuvec4(0x06040514u,0x06040607u,0x18070807u,0x06040627u),\nuvec4(0x18672817u,0x48074827u,0x28170657u,0x06370437u),\nuvec4(0x18371827u,0x08170819u,0x08290809u,0xf9172829u),\nuvec4(0x08190849u,0x691819f9u,0x40680928u,0x139200f2u),\nuvec4(0x06141605u,0x06040607u,0x08070837u,0x28171617u),\nuvec4(0x28271867u,0x08070809u,0x16472809u,0x16074817u),\nuvec4(0x06170807u,0x08071817u,0x08190837u,0x28291807u),\nuvec4(0xf9172829u,0x08190849u,0x180908f9u,0x08292809u),\nuvec4(0x68090809u,0xa210f230u,0x17860413u,0x07161738u),\nuvec4(0x47081708u,0x09381738u,0x09080708u,0x07061718u),\nuvec4(0x17160708u,0x17060748u,0x08160718u,0x18272809u),\nuvec4(0x07292819u,0x17280718u,0xf9f91708u,0x48091889u),\nuvec4(0x28291819u,0xf2202809u,0x03b21002u,0x17761405u),\nuvec4(0x17080708u,0x77080716u,0x27480748u,0x07061728u),\nuvec4(0x17160708u,0x04060738u,0x27081706u,0x67080908u),\nuvec4(0x06082938u,0x28070807u,0x29f92817u,0x1809f908u),\nuvec4(0x38192809u,0xf2206869u,0x15038250u,0x04161426u),\nuvec4(0x16b70605u,0x48074837u,0x06673817u,0x16070847u),\nuvec4(0x293807f7u,0x07180708u,0xf9181728u,0x195859f9u),\nuvec4(0x20788908u,0x138250f2u,0x14263405u,0x67181716u),\nuvec4(0x16070816u,0x48179807u,0x040708c7u,0x07083706u),\nuvec4(0x37081708u,0x39082918u,0x09081908u,0x09180908u),\nuvec4(0x59f9f908u,0x79081958u,0x20282928u,0x238250f2u),\nuvec4(0x26041504u,0x26872614u,0x27060708u,0xd7481788u),\nuvec4(0x57060406u,0x89586708u,0xf9181718u,0x192869f9u),\nuvec4(0x19187938u,0x02f22038u,0x05238240u,0x16140503u),\nuvec4(0x38171614u,0x16073627u,0x68178827u,0x063726b7u),\nuvec4(0x68471807u,0x18090889u,0xf90839f9u,0x38192839u),\nuvec4(0xf22018d9u,0x45923012u,0x17461406u,0x56042738u),\nuvec4(0x78177827u,0x085726b7u,0x28271807u,0x08991809u),\nuvec4(0xf9f90809u,0x38190859u,0x08b91819u,0x00021829u),\nuvec4(0x924012f2u,0x07041514u,0x16071614u,0x16270827u),\nuvec4(0x78275604u,0x18677817u,0x08872627u,0x18092827u),\nuvec4(0xf9f928a9u,0x08296849u,0x02f258b9u,0x14107270u),\nuvec4(0x14160405u,0x87161706u,0x08f83756u,0x16971627u),\nuvec4(0x28170877u,0xf9f928e9u,0x18b95869u,0x80f25809u),\nuvec4(0x04020172u,0x17560406u,0x47181716u,0x27160726u),\nuvec4(0x080718f8u,0x06471607u,0x16070817u,0x28170877u),\nuvec4(0x39f91839u,0x48b9f908u,0x18993809u,0x00025809u),\nuvec4(0x007270d2u,0x09070301u,0x57160708u,0x27081706u),\nuvec4(0x27061756u,0x090807d8u,0x08071817u,0x26472807u),\nuvec4(0x18272617u,0x18490817u,0x09f9f9f9u,0x08095807u),\nuvec4(0xc21088a9u,0x04306270u,0x14070908u,0x07060706u),\nuvec4(0x27083718u,0x09385746u,0x09080798u,0x18092817u),\nuvec4(0x06171819u,0x08870604u,0x08590827u,0x18d9f9f9u),\nuvec4(0x08794817u,0x20295849u,0x006260c2u,0x07050301u),\nuvec4(0x16040719u,0x18070607u,0x26371617u,0x08070604u),\nuvec4(0x0807f827u,0x58094809u,0x37160427u,0x59382716u),\nuvec4(0x99f9f918u,0xb9082728u,0x29583928u,0x2260c220u),\nuvec4(0x02002200u,0x07280704u,0x07080746u,0x07160708u),\nuvec4(0x07061708u,0x47060406u,0x07d80708u,0x09480908u),\nuvec4(0x07080938u,0x07164736u,0x79180708u,0xf9080708u),\nuvec4(0xf908a9f9u,0x08290809u,0x28190819u,0xc2100219u),\nuvec4(0x03002260u,0x06030102u,0x07180718u,0x07086706u),\nuvec4(0x37061706u,0x09683726u,0x09481998u,0x57060758u),\nuvec4(0x07160708u,0x08177938u,0x79f9f9f9u,0x09087908u),\nuvec4(0x19182917u,0x60c21002u,0x03010032u,0x17182907u),\nuvec4(0x07183726u,0x37266706u,0x481918f8u,0x16073819u),\nuvec4(0x38370857u,0x08170869u,0xf9f91849u,0x08491899u),\nuvec4(0x38292819u,0x02191829u,0x0260c210u,0x02001200u),\nuvec4(0x07381904u,0x28271608u,0x37080617u,0x57060708u),\nuvec4(0x182908f8u,0x06073849u,0x38371857u,0x08391809u),\nuvec4(0xf9f91807u,0x190879f9u,0x09481988u,0x02f20002u),\nuvec4(0x02100200u,0x05000200u,0x09280704u,0x37061718u),\nuvec4(0x27082728u,0x09487718u,0x492809b8u,0x47286748u),\nuvec4(0x39081918u,0xf9280708u,0x0869f9f9u,0x08191819u),\nuvec4(0x08170807u,0x22f24819u,0x02100200u,0x39070310u),\nuvec4(0x17081908u,0x67183704u,0x67080908u,0x19a80958u),\nuvec4(0x07582938u,0x09183708u,0x09085708u,0x07083918u),\nuvec4(0xf9f9f928u,0x28193879u,0x38092807u,0x0022f209u),\nuvec4(0x10020002u,0x39080403u,0x07081908u,0x47480716u),\nuvec4(0x37081748u,0x09180958u,0x29282978u,0x68274827u),\nuvec4(0x07090837u,0x08072928u,0x99f9f9f9u,0x093829a8u),\nuvec4(0x020022f2u,0x04110200u,0x19083908u,0x07182708u),\nuvec4(0x09383738u,0x37081708u,0x17382938u,0x19084948u),\nuvec4(0x27383708u,0x57280718u,0x17481708u,0x79f9f9f9u),\nuvec4(0x19180908u,0x19181738u,0xf2280908u,0x01220022u),\nuvec4(0x08790600u,0x07080927u,0x19581738u,0x09f80967u),\nuvec4(0x57283918u,0x17385718u,0x37081708u,0x08291728u),\nuvec4(0x39f9f9f9u,0x29080718u,0x19380918u,0x0022f248u),\nuvec4(0x04000112u,0x08170889u,0x37081719u,0x09886778u),\nuvec4(0x272819b8u,0x17281706u,0x27281708u,0x37680708u),\nuvec4(0x89f9f9f9u,0x09080708u,0x07180908u,0x07080938u),\nuvec4(0x42f22809u,0x18a90410u,0x17180729u,0x87580918u),\nuvec4(0x09280978u,0x09080978u,0x17882718u,0x09281728u),\nuvec4(0xf9f9f998u,0x08092889u,0x58070819u,0x42f23807u),\nuvec4(0xf9060300u,0x97781728u,0x19382948u,0x18291748u),\nuvec4(0x08570607u,0x07082729u,0x09280706u,0xf9482928u),\nuvec4(0x1849f9f9u,0x28091809u,0x52f2c809u,0x38e90804u),\nuvec4(0x17780706u,0x27082708u,0x39081718u,0x17482918u),\nuvec4(0x16071829u,0x38194817u,0x28070607u,0x08060709u),\nuvec4(0xf9f94849u,0x094829f9u,0x19980708u,0x0342f228u),\nuvec4(0x2738f904u,0x57081768u,0x29083958u,0x29080758u),\nuvec4(0x07260718u,0x39181908u,0x07060718u,0x08060738u),\nuvec4(0x18070859u,0x19f9f9f9u,0x09381938u,0xf2380978u),\nuvec4(0x02000312u,0x19f90705u,0x17581738u,0x79783708u),\nuvec4(0x29081748u,0x09184718u,0x06174918u,0x69480907u),\nuvec4(0xf9080708u,0x6829f9f9u,0x88192819u,0x12f20309u),\nuvec4(0x19060300u,0x1738f908u,0x37280748u,0x09288968u),\nuvec4(0x19180718u,0x29684718u,0x38070617u,0xf9081789u),\nuvec4(0xa809f9f9u,0x08099817u,0x13923309u,0x05120302u),\nuvec4(0x3758f907u,0x37086728u,0x19987938u,0x07063708u),\nuvec4(0x16072968u,0x07794807u,0xf9f9f908u,0x38394809u),\nuvec4(0x78092809u,0x13725309u,0x04100302u,0x583908a9u),\nuvec4(0x38d70847u,0x18198879u,0x08170857u,0x47290817u),\nuvec4(0xf9188928u,0x3809f9f9u,0x08093839u,0x7253b807u),\nuvec4(0x02011213u,0x8908a906u,0x47084708u,0x39983728u),\nuvec4(0x19082918u,0x77380738u,0x18370829u,0x18790817u),\nuvec4(0x09f9f9f9u,0x17781928u,0x63582728u,0x00021372u),\nuvec4(0x08a90805u,0x08b70879u,0x06070809u,0x18299827u),\nuvec4(0x38190829u,0x28274807u,0x48070839u,0x18790817u),\nuvec4(0x18c9f9f9u,0x88192809u,0x08290817u,0x73074807u),\nuvec4(0x03000372u,0x7908b906u,0x07288738u,0x09280716u),\nuvec4(0x29081738u,0x19181918u,0x28379807u,0x08170809u),\nuvec4(0x38070819u,0xf9f91839u,0x080758d9u,0x68491809u),\nuvec4(0x72737819u,0x07030003u,0x190849f9u,0x17287708u),\nuvec4(0x09580706u,0x69082708u,0x07080918u,0x37780908u),\nuvec4(0x07181708u,0x07060738u,0x29080908u,0xf9f9f938u),\nuvec4(0x28f83968u,0x05006293u,0x0879f908u,0x06172877u),\nuvec4(0x08195807u,0x07288917u,0x37181788u,0x04064819u),\nuvec4(0x18390807u,0xf9f91819u,0x08691849u,0x28091807u),\nuvec4(0xa8071829u,0x12333819u,0xf9066243u,0x18090869u),\nuvec4(0x18370817u,0x89277847u,0x372807c8u,0x09181908u),\nuvec4(0x17040608u,0xf9381908u,0x591879f9u,0x18390718u),\nuvec4(0x2718f819u,0x12432233u,0x07031203u,0x18b908b9u),\nuvec4(0x98271817u,0x08073819u,0xf8390849u,0x38090847u),\nuvec4(0xf9f98827u,0x084928d9u,0x18090809u,0x28090819u),\nuvec4(0x18190807u,0x33171817u,0x03026312u,0xf9060200u),\nuvec4(0x08192899u,0x18096827u,0x18494819u,0x17f80749u),\nuvec4(0x09180908u,0x07081708u,0xd9f9f988u,0x29082918u),\nuvec4(0x29484938u,0x02d30758u,0xf9080300u,0x18191899u),\nuvec4(0x18097817u,0x18594809u,0x08095839u,0x18474819u),\nuvec4(0x18372819u,0xf9f92819u,0x192819f9u,0x09283948u),\nuvec4(0x07780918u,0x050002d3u,0x2899f908u,0x78170809u),\nuvec4(0x48c98809u,0x48190809u,0x08090837u,0x18173819u),\nuvec4(0x58f9f9f9u,0x28193809u,0x98174849u,0x060302d3u),\nuvec4(0x0758a9f9u,0x17480978u,0x3948c918u,0x07080748u),\nuvec4(0x09182908u,0x19080728u,0xa9f9f948u,0x19080918u),\nuvec4(0xa9080928u,0x19181928u,0xd3181728u,0xf9080502u),\nuvec4(0x4809d8b9u,0x38d91817u,0x98090809u,0x38092729u),\nuvec4(0xf9f93829u,0x183918a9u,0x08391819u,0x08094859u),\nuvec4(0x08370819u,0xd9f904e3u,0x09980918u,0xe9084908u),\nuvec4(0x09180948u,0x09780918u,0xf9480708u,0x2819f9f9u),\nuvec4(0x28191829u,0x18492829u,0x38092819u,0x06e30817u),\nuvec4(0x0758d9f9u,0x09080958u,0x3819f918u,0x18091819u),\nuvec4(0x08476819u,0x59f9f9f9u,0x29082908u,0x191819b8u),\nuvec4(0x0705d3a8u,0x1748d9f9u,0x09580908u,0x08190708u),\nuvec4(0x191809f9u,0x29180918u,0x17081758u,0x19f9f9f9u),\nuvec4(0x29080938u,0x07481908u,0x09081978u,0x0405c3b8u),\nuvec4(0x1738f9f9u,0x08095819u,0x190889f9u,0x27384908u),\nuvec4(0xf9f9f928u,0x48593809u,0x88071809u,0x18172819u),\nuvec4(0xa3190827u,0xf9060312u,0x072809f9u,0xf9082968u),\nuvec4(0x384908b9u,0xf9f93817u,0x691819f9u,0x07381938u),\nuvec4(0x29380918u,0x17081718u,0xc3280708u,0xf9f90805u),\nuvec4(0x08d9f9d8u,0xf9473849u,0x1829f9f9u,0x28179869u),\nuvec4(0x2827a809u,0xf9f904c3u,0xf9880958u,0x285908c9u),\nuvec4(0x08070817u,0x89f9f9f9u,0x09081928u,0x47181708u),\nuvec4(0x37881908u,0x0705b328u,0xd9f90819u,0x09481938u),\nuvec4(0x0889f918u,0x28590839u,0xf9f9f917u,0x080708b9u),\nuvec4(0x18172819u,0x28379867u,0x082904b3u,0x1918f9f9u),\nuvec4(0x2879f978u,0x38690829u,0xa9f9f9f9u,0x09282938u),\nuvec4(0xf7082708u,0xa3081716u,0x08290605u,0x5849f9f9u),\nuvec4(0x071879f9u,0x79082908u,0xf9f9f938u,0x07192889u),\nuvec4(0x18070819u,0x170827f7u,0x93170806u,0xf9070405u),\nuvec4(0xf92899f9u,0x08071899u,0x48691819u,0xa9f9f9f9u),\nuvec4(0xd7180768u,0x27082718u,0x93080709u,0x19080405u),\nuvec4(0x69f9f908u,0x08a9f918u,0x28090817u,0x08492869u),\nuvec4(0x18c9f9f9u,0x28190849u,0x67182709u,0x17083708u),\nuvec4(0x07081708u,0x05935809u,0x08190806u,0xf9f9f9f9u),\nuvec4(0x08270829u,0x08493899u,0x28c9f9f9u,0xf7092869u),\nuvec4(0x06570807u,0x93170837u,0x19080605u,0xf9f9f908u),\nuvec4(0x170829f9u,0x59189928u,0xb9f9f908u,0x09086938u),\nuvec4(0x87185718u,0x17082708u,0x17082718u,0x29060593u),\nuvec4(0xf9f9f908u,0x270819f9u,0xf9189928u,0x2829f9f9u),\nuvec4(0x18092859u,0x28274817u,0x38095817u,0x06071817u),\nuvec4(0x29070593u,0xf9f9f908u,0x382719f9u,0xf9f91899u),\nuvec4(0x790829f9u,0x67092748u,0x09082728u,0x07280988u),\nuvec4(0x29070593u,0xf9f9f908u,0x481719f9u,0xf9f90899u),\nuvec4(0x191869f9u,0x67088758u,0x07180706u,0x07281718u),\nuvec4(0x05931718u,0xf9181907u,0x09f9f9f9u,0xf9089978u),\nuvec4(0xc819f9f9u,0x28270857u,0x070617f7u,0x93060708u),\nuvec4(0x28090705u,0x0859f9f9u,0x070889f9u,0xf908a958u),\nuvec4(0xd819f9f9u,0x18370837u,0x06771607u,0x93271667u),\nuvec4(0x28090804u,0x1849f9f9u,0x070889f9u,0x08f9f958u),\nuvec4(0x0918c9f9u,0x271827a8u,0x57266718u,0x07262708u),\nuvec4(0x29049309u,0x49f9f908u,0x2899f918u,0x08991829u),\nuvec4(0xf90849f9u,0xa81908c9u,0x06871827u,0x06274637u),\nuvec4(0x07160427u,0x08040583u,0xf9f91809u,0x99f91849u),\nuvec4(0x79282928u,0xf9f9f918u,0x08190829u,0x18075807u),\nuvec4(0x08672817u,0x161706d7u,0x05830617u,0x08190804u),\nuvec4(0x0849f9f9u,0x293899f9u,0xf9087928u,0x2869f9f9u),\nuvec4(0x08272809u,0x18571817u,0x46270667u,0x06072607u),\nuvec4(0x07048307u,0xf9f90829u,0xf9080739u,0x48293899u),\nuvec4(0xf9f90849u,0x192869f9u,0x27081728u,0x77085718u),\nuvec4(0x17060706u,0x07081716u,0x63170816u,0x07040302u),\nuvec4(0x59f9f908u,0xf9080708u,0x08d93889u,0xf9f90839u),\nuvec4(0x191819f9u,0x07080718u,0x87081728u,0x37467708u),\nuvec4(0x05040615u,0x06030063u,0x59f9f918u,0x4899f918u),\nuvec4(0x084908b9u,0x19f9f9f9u,0x27280768u,0x17082708u),\nuvec4(0x77180718u,0x17083716u,0x02030406u,0x07050063u),\nuvec4(0x1879f9f9u,0x380799f9u,0x18492829u,0x79f9f9f9u),\nuvec4(0x17081768u,0x17080706u,0x07082718u,0x07064708u),\nuvec4(0x06075618u,0x05060807u,0x04125306u,0x69f9f908u),\nuvec4(0x1889f918u,0x28293807u,0xf9f90849u,0x377879f9u),\nuvec4(0x27080716u,0x07085708u,0x47080708u,0x08060706u),\nuvec4(0x08060807u,0x00530827u,0xf9f90603u,0x89f92869u),\nuvec4(0xf9282968u,0x68d9f9f9u,0x17162807u,0x57182708u),\nuvec4(0x57164718u,0x17160706u,0x04100233u,0x69f9f908u),\nuvec4(0xf9180928u,0x38070859u,0xf9f93829u,0x1748d9f9u),\nuvec4(0x57094728u,0x07081718u,0x37064718u,0x07060706u),\nuvec4(0x02131716u,0x03000203u,0xf9080907u,0x291849f9u),\nuvec4(0x0859f918u,0x48192817u,0x79f9f9f9u,0x17683908u),\nuvec4(0x27094718u,0x17280706u,0x19080708u,0x333706b7u),\nuvec4(0xf9060200u,0x192869f9u,0x0859f928u,0xf9f99817u),\nuvec4(0x190879f9u,0x37283768u,0x07160718u,0x07080718u),\nuvec4(0x08092809u,0x08370816u,0x23370827u,0x08050002u),\nuvec4(0xb9f90809u,0x19186918u,0x3759f938u,0xf9f9f988u),\nuvec4(0x58290879u,0x08473827u,0x07080937u,0x07080708u),\nuvec4(0x67081738u,0x23162706u,0x19060300u,0x18b9f908u),\nuvec4(0x28290879u,0xf9f859f9u,0x1849f9f9u,0x28274829u),\nuvec4(0x071839a7u,0x08075819u,0x13070677u,0x08050102u),\nuvec4(0x0859f9f9u,0x18290819u,0xf9f869f9u,0x1849f9f9u),\nuvec4(0x28274829u,0x16470607u,0x18870607u,0x77090819u),\nuvec4(0x00132706u,0xf9f90805u,0x08070859u,0x59f91859u),\nuvec4(0x19780708u,0xf9f9f938u,0x68192839u,0x17090817u),\nuvec4(0x57361706u,0x17080908u,0x27280928u,0x02037708u),\nuvec4(0xf9f90603u,0x18690879u,0x88d90869u,0xa9f9f9f9u),\nuvec4(0x07681928u,0x27060728u,0x37285736u,0x07063738u),\nuvec4(0x12064708u,0xd9f90804u,0x69086928u,0x9859f908u),\nuvec4(0xf91849f9u,0x493829f9u,0x07080718u,0x08061718u),\nuvec4(0x19570647u,0x08072807u,0x07090809u,0x57082718u),\nuvec4(0xf9070300u,0x086928e9u,0x1928d9f9u,0x0779f918u),\nuvec4(0x29f9f908u,0x07685928u,0x16470816u,0x18270807u),\nuvec4(0x08971807u,0x06470807u,0xf9f90602u,0xd9f90889u),\nuvec4(0xf9089928u,0x2869f9f9u,0x68291809u,0x37084726u),\nuvec4(0x09084718u,0x17184728u,0x07080928u,0x18090703u),\nuvec4(0x0749f9f9u,0x08070908u,0x1807a9f9u,0x08193899u),\nuvec4(0x09f9f9f9u,0x19183958u,0x47160708u,0x37184718u),\nuvec4(0x97380918u,0x07051708u,0x89f908d9u,0xf9181908u),\nuvec4(0x08b908a9u,0xf9f91819u,0x190839f9u,0x29084908u),\nuvec4(0x37082708u,0x06286708u,0x08370827u,0x28070847u),\nuvec4(0xa9070616u,0x0809f948u,0x1859f9f9u,0xf9f908d9u),\nuvec4(0x790849f9u,0x08e71918u,0x08091817u,0x07080967u),\nuvec4(0x07066706u,0x89180706u,0x0889f938u,0xf908f9f9u),\nuvec4(0xf9f908c9u,0x081918e9u,0x18470867u,0x28090827u),\nuvec4(0x07080947u,0x48070806u,0x19180617u,0xf9185918u),\nuvec4(0xf90829f9u,0xb90889f9u,0xf9f9f908u,0x08470829u),\nuvec4(0x08071617u,0x08071807u,0x08472827u,0x191806b7u),\nuvec4(0xf9080708u,0x19f9f9f9u,0xa908d948u,0x29f9f908u),\nuvec4(0x4708c918u,0x27161718u,0x47080718u,0x07183708u),\nuvec4(0x37080728u,0x18070706u,0x08190729u,0xf9f90809u),\nuvec4(0x1918c9f9u,0xf9f9f918u,0x4708c9f9u,0x97183708u),\nuvec4(0x07085706u,0x07082708u,0x18073708u,0x08191819u),\nuvec4(0xe9f9f9f9u,0xf9082918u,0xc9f9f9f9u,0x07784708u),\nuvec4(0x4708c718u,0x17080718u,0x08090808u,0x08291719u),\nuvec4(0xf9f9f9f9u,0xf9f91819u,0x08c9f9f9u,0x18574837u),\nuvec4(0x08470857u,0x08273847u,0xf9070839u,0x59f9f9f9u),\nuvec4(0x1829f918u,0x79f9f9f9u,0x07385798u,0x07182748u),\nuvec4(0x17281708u,0xf9081708u,0xf92829f9u,0xf91819f9u),\nuvec4(0xf9f91869u,0x090849f9u,0x171817b8u,0x57082798u),\nuvec4(0xf9f94708u,0xf9f93839u,0x39f91809u,0xf9080708u),\nuvec4(0x2859f9f9u,0x1817a809u,0x08096817u,0x08370837u),\nuvec4(0x59072827u,0x48b9f908u,0x69f9f9f9u,0xf9080708u),\nuvec4(0xf9f91819u,0x78075809u,0x68071827u,0x08370819u),\nuvec4(0x59072877u,0x28d9f908u,0xf9f9f9f9u,0xf9f918b9u),\nuvec4(0x08192809u,0x18077807u,0x68296827u,0xf9077807u),\nuvec4(0x170839f9u,0xf9f9f9f9u,0x09f9f9f9u,0x09183908u),\nuvec4(0x17480738u,0x59381708u,0xf9f94788u,0xf9082729u),\nuvec4(0xf9f9f9f9u,0x3839f9f9u,0x18077809u,0x38293837u),\nuvec4(0xf9376819u,0x060819f9u,0xf9f90807u,0xf9f9f9f9u),\nuvec4(0x191849f9u,0x07180788u,0x29181708u,0x390718f8u),\nuvec4(0x16c9f908u,0xf9081907u,0xf9f9f9f9u,0x0859f9f9u),\nuvec4(0x18175817u,0xf8494807u,0x09f9f907u,0x19081608u),\nuvec4(0xf9f9f908u,0xf9f9f9f9u,0x07080749u,0x07681918u),\nuvec4(0x09280908u,0x29080968u,0xf9f92758u,0x07060708u),\nuvec4(0xf9f91819u,0xf9f9f9f9u,0x070849f9u,0x09580928u),\nuvec4(0x17080918u,0x07080908u,0x08090738u,0xf9177819u),\nuvec4(0x481708f9u,0xf9f9f9f9u,0x49f9f9f9u,0x19380708u),\nuvec4(0x17580918u,0x07080908u,0x09080928u,0xf9981908u),\nuvec4(0x381708f9u,0xf9f9f9f9u,0x59f9f9f9u,0x69080918u),\nuvec4(0x19583738u,0xf9b81908u,0xf9f928f9u,0xf9f9f9f9u),\nuvec4(0x2879f9f9u,0x08193817u,0x08190809u,0x18090809u),\nuvec4(0x00004809u,0x00000000u,0x00000000u,0x00000000u));\nconst int lines[] = int[](\n0,23,47,72,102,136,168,194,235,274,313,357,411,464,513,559,613,681,743,808,873,940,\n1007,1072,1140,1202,1264,1324,1376,1433,1489,1544,1602,1662,1717,1776,1830,1886,1934,\n1985,2031,2074,2121,2167,2205,2242,2282,2324,2363,2405,2446,2483,2525,2563,2608,2653,\n2690,2726,2759,2794,2833,2868,2909,2948,2987,3024,3062,3106,3155,3201,3250,3305,3367,\n3433,3498,3562,3628,3695,3765,3834,3903,3982,4059,4134,4198,4263,4320,4383,4449,4508,\n4563,4618,4668,4714,4753,4797,4837,4878,4922,4964,5009,5056,5098,5139,5182,5227,5270,\n5321,5376,5429,5490,5555,5621,5672,5730,5788,5853,5914,5971,6031,6088,6148,6212,6284,\n6349,6409,6478,6540,6626,6702,6778,6849,6928,7004,7072,7142,7214,7288,7356,7433,7502,\n7574,7651,7721,7782,7843,7901,7963,8026,8089,8151,8206,8263,8314,8369,8426,8484,8541,\n8591,8649,8693,8742,8792,8850,8903,8953,9019,9085,9135,9190,9236,9283,9334,9385,9430,\n9483,9534,9585,9635,9685,9735,9784,9828,9884,9950,10004,10060,10112,10157,10203,10246,\n10300,10363,10436,10502,10566,10611,10667,10709,10754,10798,10842,10878,10926,10978,\n11031,11084,11149,11204,11255,11308,11366,11421,11472,11531,11581,11634,11678,11722,\n11773,11823,11869,11913,11957,11998,12043,12095,12146,12196,12246,12292,12343,12390,\n12436,12476,12523,12564,12606,12641,12685,12723,12763,12788,12821,12856,12887,12923,\n12955,12998,13031,13068,13104,13136,13170,13199,13231,13265,13300,13338,13377,13419,\n13460,13500,13545,13590,13624,13666,13711,13755,13799,13835,13874,13918,13955,14000,\n14040,14076,14118,14161,14196,14233,14269,14310,14346,14377,14407,14438,14466,14499,\n14531,14559,14586,14611,14639,14665,14698,14735,14767,14791,14818);\n\nconst int IWIDTH = 199;\nconst int IHEIGHT = lines.length()-1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  coloroffset = 14;\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (fragColor.w == ires) return;\n  fragColor.w = ires;\n  int col = int(fragCoord.y);\n  int row = int(fragCoord.x);\n  if (row >= IHEIGHT || col >= IWIDTH) return;\n  int rstart = lines[row];\n  int rend = lines[row+1];\n  int c = -1;\n  int colcount = 0;\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15;\n      break;\n    }\n  }\n  if (c >= 0) fragColor.rgb = getcolor(c);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "////////////////////////////////////////////////////////////////////////////////\n// I couldn't find a decent MIDI for God Save The Queen, which is pretty awful\n// anyway, like most \"patriotic\" music. This nice tune is from the finale of \n// Thomas Arne's masque \"Alfred\", first performed in 1740. Repeats after 76\n// seconds, in a different style.\n////////////////////////////////////////////////////////////////////////////////\n\n#define SOUND 4\nfloat speed = 0.5;\nconst ivec4 data[] = ivec4[](\nivec4(896,128,50,70),\nivec4(896,128,62,70),\nivec4(1024,256,47,68),\nivec4(1024,256,55,83),\nivec4(1024,256,62,87),\nivec4(1024,256,67,87),\nivec4(1280,256,48,78),\nivec4(1280,256,55,78),\nivec4(1280,256,64,81),\nivec4(1280,256,67,81),\nivec4(1536,64,67,77),\nivec4(1536,256,47,76),\nivec4(1536,256,55,75),\nivec4(1536,256,62,71),\nivec4(1600,64,69,87),\nivec4(1664,64,71,87),\nivec4(1728,64,72,84),\nivec4(1792,128,55,81),\nivec4(1792,128,62,77),\nivec4(1792,128,74,84),\nivec4(1792,256,43,70),\nivec4(1920,128,55,78),\nivec4(1920,128,62,77),\nivec4(1920,128,67,67),\nivec4(2048,256,50,76),\nivec4(2048,256,62,80),\nivec4(2048,384,66,86),\nivec4(2048,384,69,86),\nivec4(2304,256,50,80),\nivec4(2304,256,62,74),\nivec4(2432,64,71,85),\nivec4(2496,64,72,85),\nivec4(2560,256,43,82),\nivec4(2560,256,55,82),\nivec4(2560,256,62,74),\nivec4(2560,256,67,77),\nivec4(2560,256,71,77),\nivec4(2944,128,62,73),\nivec4(3072,64,67,91),\nivec4(3072,256,43,73),\nivec4(3072,256,55,73),\nivec4(3072,256,59,75),\nivec4(3136,64,69,88),\nivec4(3200,64,67,74),\nivec4(3264,64,69,86),\nivec4(3328,64,71,90),\nivec4(3328,256,47,83),\nivec4(3328,256,55,82),\nivec4(3328,256,62,82),\nivec4(3392,64,72,87),\nivec4(3456,64,71,80),\nivec4(3520,64,72,85),\nivec4(3584,128,50,80),\nivec4(3584,128,59,83),\nivec4(3584,128,67,85),\nivec4(3584,128,74,87),\nivec4(3712,128,50,76),\nivec4(3712,128,54,74),\nivec4(3712,128,62,70),\nivec4(3712,128,69,70),\nivec4(3840,128,50,75),\nivec4(3840,128,55,76),\nivec4(3840,128,62,76),\nivec4(3840,128,71,83),\nivec4(3968,128,50,72),\nivec4(3968,128,54,79),\nivec4(3968,128,62,77),\nivec4(3968,128,69,78),\nivec4(4096,128,67,76),\nivec4(4096,256,52,83),\nivec4(4096,256,59,83),\nivec4(4096,256,64,82),\nivec4(4224,64,69,84),\nivec4(4288,64,71,87),\nivec4(4352,128,45,80),\nivec4(4352,128,57,80),\nivec4(4352,128,61,75),\nivec4(4352,128,64,77),\nivec4(4352,128,69,77),\nivec4(4480,128,45,83),\nivec4(4480,128,57,83),\nivec4(4480,128,61,76),\nivec4(4480,128,64,73),\nivec4(4480,128,67,73),\nivec4(4608,384,50,80),\nivec4(4608,384,57,80),\nivec4(4608,384,62,82),\nivec4(4608,384,66,74),\nivec4(4992,128,50,77),\nivec4(4992,128,62,69),\nivec4(5120,128,54,80),\nivec4(5120,128,66,89),\nivec4(5248,128,50,75),\nivec4(5248,128,62,71),\nivec4(5376,128,57,86),\nivec4(5376,128,69,92),\nivec4(5504,128,54,77),\nivec4(5504,128,66,75),\nivec4(5632,128,74,96),\nivec4(5632,256,47,78),\nivec4(5632,256,54,78),\nivec4(5632,256,62,71),\nivec4(5760,64,73,80),\nivec4(5824,64,71,76),\nivec4(5888,64,69,77),\nivec4(5888,256,43,85),\nivec4(5888,256,55,85),\nivec4(5888,256,62,77),\nivec4(5952,64,67,75),\nivec4(6016,64,66,77),\nivec4(6080,64,64,77),\nivec4(6144,256,45,69),\nivec4(6144,256,54,75),\nivec4(6144,256,57,74),\nivec4(6144,256,62,74),\nivec4(6400,128,57,80),\nivec4(6400,128,66,85),\nivec4(6400,256,45,81),\nivec4(6400,256,61,84),\nivec4(6528,128,55,81),\nivec4(6528,128,64,78),\nivec4(6656,256,50,84),\nivec4(6656,256,54,75),\nivec4(6656,256,57,72),\nivec4(6656,256,62,74),\nivec4(7168,256,43,73),\nivec4(7168,256,55,73),\nivec4(7168,256,59,72),\nivec4(7168,256,67,72),\nivec4(7424,192,47,78),\nivec4(7424,192,55,78),\nivec4(7424,192,62,77),\nivec4(7424,192,67,77),\nivec4(7616,64,50,83),\nivec4(7616,64,55,83),\nivec4(7616,64,59,69),\nivec4(7616,64,62,69),\nivec4(7680,128,48,80),\nivec4(7680,128,55,80),\nivec4(7680,128,64,79),\nivec4(7808,128,48,79),\nivec4(7808,128,52,79),\nivec4(7808,128,60,70),\nivec4(8064,128,48,70),\nivec4(8064,128,55,70),\nivec4(8064,128,64,71),\nivec4(8064,128,67,71),\nivec4(8192,128,45,79),\nivec4(8192,128,57,79),\nivec4(8192,128,64,89),\nivec4(8192,128,72,89),\nivec4(8320,128,47,75),\nivec4(8320,128,56,75),\nivec4(8320,128,64,81),\nivec4(8320,128,71,81),\nivec4(8448,128,48,79),\nivec4(8448,128,57,79),\nivec4(8448,128,64,76),\nivec4(8448,128,69,76),\nivec4(8576,128,49,85),\nivec4(8576,128,57,85),\nivec4(8576,128,64,71),\nivec4(8576,128,67,71),\nivec4(8704,256,50,78),\nivec4(8704,256,57,78),\nivec4(8704,256,62,75),\nivec4(8704,256,66,75),\nivec4(9088,128,54,68),\nivec4(9088,128,57,68),\nivec4(9088,128,62,69),\nivec4(9088,128,69,69),\nivec4(9216,256,55,82),\nivec4(9216,256,59,82),\nivec4(9216,256,62,67),\nivec4(9216,256,74,90),\nivec4(9472,256,50,73),\nivec4(9472,256,57,73),\nivec4(9472,256,66,83),\nivec4(9472,256,72,75),\nivec4(9728,64,71,76),\nivec4(9728,128,47,78),\nivec4(9728,128,55,78),\nivec4(9728,128,62,69),\nivec4(9792,64,67,69),\nivec4(9856,64,72,88),\nivec4(9856,128,45,84),\nivec4(9856,128,57,84),\nivec4(9856,128,64,74),\nivec4(9920,64,69,73),\nivec4(9984,128,47,66),\nivec4(9984,128,62,72),\nivec4(9984,128,67,92),\nivec4(9984,128,74,92),\nivec4(10112,128,48,81),\nivec4(10112,128,64,81),\nivec4(10112,128,69,74),\nivec4(10112,128,72,74),\nivec4(10240,256,50,68),\nivec4(10240,256,62,69),\nivec4(10240,256,67,79),\nivec4(10240,256,71,79),\nivec4(10496,128,62,106),\nivec4(10496,256,50,75),\nivec4(10496,256,66,76),\nivec4(10496,256,69,76),\nivec4(10624,128,60,80),\nivec4(10752,512,55,82),\nivec4(10752,512,59,75),\nivec4(10752,512,62,78),\nivec4(10752,512,67,78),\nivec4(11264,256,43,77),\nivec4(11264,256,55,77),\nivec4(11264,256,62,90),\nivec4(11264,256,67,90),\nivec4(11264,256,71,90),\nivec4(11648,128,43,72),\nivec4(11648,128,55,72),\nivec4(11648,128,62,74),\nivec4(11648,128,65,74),\nivec4(11648,128,71,74),\nivec4(11776,64,48,76),\nivec4(11776,64,60,84),\nivec4(11776,64,64,84),\nivec4(11776,64,72,84),\nivec4(11904,64,48,78),\nivec4(11904,64,60,79),\nivec4(11904,64,64,79),\nivec4(11904,64,72,79),\nivec4(12160,128,50,71),\nivec4(12160,128,55,71),\nivec4(12160,128,67,71),\nivec4(12160,128,71,71),\nivec4(12288,192,72,83),\nivec4(12288,256,45,83),\nivec4(12288,256,57,83),\nivec4(12288,256,64,80),\nivec4(12480,64,71,80),\nivec4(12544,128,45,81),\nivec4(12544,128,57,81),\nivec4(12544,128,64,77),\nivec4(12544,128,69,75),\nivec4(12672,128,45,78),\nivec4(12672,128,57,78),\nivec4(12672,128,61,70),\nivec4(12672,128,67,77),\nivec4(12800,512,50,70),\nivec4(12800,512,57,80),\nivec4(12800,512,62,75),\nivec4(12800,512,66,72),\nivec4(13312,256,55,88),\nivec4(13312,256,59,88),\nivec4(13312,256,62,76),\nivec4(13312,256,74,97),\nivec4(13568,256,50,76),\nivec4(13568,256,57,76),\nivec4(13568,256,66,81),\nivec4(13568,256,72,77),\nivec4(13824,64,71,72),\nivec4(13824,128,47,88),\nivec4(13824,128,55,88),\nivec4(13824,128,62,67),\nivec4(13888,64,67,71),\nivec4(13952,64,72,91),\nivec4(13952,128,45,86),\nivec4(13952,128,57,86),\nivec4(13952,128,64,77),\nivec4(14016,64,69,75),\nivec4(14080,128,47,69),\nivec4(14080,128,62,69),\nivec4(14080,128,67,90),\nivec4(14080,128,74,90),\nivec4(14208,128,48,78),\nivec4(14208,128,64,83),\nivec4(14208,128,69,76),\nivec4(14208,128,72,76),\nivec4(14336,256,50,77),\nivec4(14336,256,62,74),\nivec4(14336,256,67,78),\nivec4(14336,256,71,78),\nivec4(14592,128,62,108),\nivec4(14592,256,50,76),\nivec4(14592,256,66,74),\nivec4(14592,256,69,74),\nivec4(14720,128,60,81),\nivec4(14848,512,55,78),\nivec4(14848,512,59,81),\nivec4(14848,512,62,75),\nivec4(14848,512,67,75),\nivec4(15360,256,43,91),\nivec4(15360,256,55,91),\nivec4(15360,256,62,91),\nivec4(15360,256,65,91),\nivec4(15360,256,67,91),\nivec4(15360,256,71,91),\nivec4(15744,128,43,87),\nivec4(15744,128,55,87),\nivec4(15744,128,62,67),\nivec4(15744,128,65,67),\nivec4(15744,128,67,67),\nivec4(15744,128,71,67),\nivec4(15872,64,48,95),\nivec4(15872,64,55,95),\nivec4(15872,64,64,85),\nivec4(15872,64,67,85),\nivec4(15872,64,72,85),\nivec4(16000,64,48,101),\nivec4(16000,64,55,101),\nivec4(16000,64,64,80),\nivec4(16000,64,67,80),\nivec4(16000,64,72,80),\nivec4(16256,128,43,83),\nivec4(16256,128,55,83),\nivec4(16256,128,62,74),\nivec4(16256,128,67,74),\nivec4(16256,128,71,74),\nivec4(16384,128,45,83),\nivec4(16384,192,60,77),\nivec4(16384,192,64,77),\nivec4(16384,192,72,77),\nivec4(16512,128,47,100),\nivec4(16576,64,62,75),\nivec4(16576,64,67,75),\nivec4(16576,64,71,75),\nivec4(16640,128,48,103),\nivec4(16640,128,60,72),\nivec4(16640,128,64,72),\nivec4(16640,128,69,72),\nivec4(16768,128,49,111),\nivec4(16768,128,58,75),\nivec4(16768,128,64,75),\nivec4(16768,128,67,75),\nivec4(16896,128,50,108),\nivec4(16896,512,57,76),\nivec4(16896,512,62,76),\nivec4(16896,512,66,76),\nivec4(17024,128,52,107),\nivec4(17152,128,50,109),\nivec4(17280,128,48,106),\nivec4(17408,256,47,111),\nivec4(17408,256,59,111),\nivec4(17408,256,62,82),\nivec4(17408,256,74,95),\nivec4(17664,256,45,92),\nivec4(17664,256,57,92),\nivec4(17664,256,66,82),\nivec4(17664,256,72,77),\nivec4(17920,64,71,77),\nivec4(17920,128,43,94),\nivec4(17920,128,55,94),\nivec4(17920,128,62,67),\nivec4(17984,64,67,66),\nivec4(18048,64,72,92),\nivec4(18048,128,45,96),\nivec4(18048,128,57,96),\nivec4(18048,128,64,83),\nivec4(18112,64,69,74),\nivec4(18176,128,47,95),\nivec4(18176,128,59,95),\nivec4(18176,128,62,70),\nivec4(18176,128,74,90),\nivec4(18304,128,48,96),\nivec4(18304,128,60,96),\nivec4(18304,128,64,84),\nivec4(18304,128,72,77),\nivec4(18432,256,50,84),\nivec4(18432,256,62,77),\nivec4(18432,256,67,77),\nivec4(18432,256,71,77),\nivec4(18688,256,50,93),\nivec4(18688,256,60,79),\nivec4(18688,256,66,79),\nivec4(18688,256,69,79),\nivec4(18944,384,43,104),\nivec4(18944,384,55,104),\nivec4(18944,384,59,69),\nivec4(18944,384,62,69),\nivec4(18944,384,67,69),\nivec4(19328,128,50,80),\nivec4(19328,128,62,66),\nivec4(19456,256,47,67),\nivec4(19456,256,55,85),\nivec4(19456,256,62,89),\nivec4(19456,256,67,89),\nivec4(19712,256,48,74),\nivec4(19712,256,55,84),\nivec4(19712,256,64,81),\nivec4(19712,256,67,81),\nivec4(19968,64,67,80),\nivec4(19968,256,47,76),\nivec4(19968,256,55,81),\nivec4(19968,256,62,70),\nivec4(20032,64,69,88),\nivec4(20096,64,71,89),\nivec4(20160,64,72,84),\nivec4(20224,128,55,85),\nivec4(20224,128,62,73),\nivec4(20224,128,74,91),\nivec4(20224,256,43,78),\nivec4(20352,128,55,83),\nivec4(20352,128,62,75),\nivec4(20352,128,67,69),\nivec4(20480,256,50,75),\nivec4(20480,256,62,82),\nivec4(20480,384,66,87),\nivec4(20480,384,69,87),\nivec4(20736,256,50,81),\nivec4(20736,256,62,78),\nivec4(20864,64,71,84),\nivec4(20928,64,72,86),\nivec4(20992,256,43,78),\nivec4(20992,256,55,78),\nivec4(20992,256,62,77),\nivec4(20992,256,67,72),\nivec4(20992,256,71,72),\nivec4(21376,128,62,72),\nivec4(21504,64,67,88),\nivec4(21504,256,43,80),\nivec4(21504,256,55,72),\nivec4(21504,256,59,74),\nivec4(21568,64,69,87),\nivec4(21632,64,67,72),\nivec4(21696,64,69,82),\nivec4(21760,64,71,85),\nivec4(21760,256,47,79),\nivec4(21760,256,55,82),\nivec4(21760,256,62,84),\nivec4(21824,64,72,86),\nivec4(21888,64,71,74),\nivec4(21952,64,72,81),\nivec4(22016,128,50,81),\nivec4(22016,128,59,82),\nivec4(22016,128,67,90),\nivec4(22016,128,74,84),\nivec4(22144,128,50,81),\nivec4(22144,128,54,75),\nivec4(22144,128,62,71),\nivec4(22144,128,69,70),\nivec4(22272,128,50,76),\nivec4(22272,128,55,80),\nivec4(22272,128,62,75),\nivec4(22272,128,71,81),\nivec4(22400,128,50,83),\nivec4(22400,128,54,78),\nivec4(22400,128,62,75),\nivec4(22400,128,69,76),\nivec4(22528,128,67,75),\nivec4(22528,256,52,82),\nivec4(22528,256,59,82),\nivec4(22528,256,64,79),\nivec4(22656,64,69,82),\nivec4(22720,64,71,88),\nivec4(22784,128,45,74),\nivec4(22784,128,57,74),\nivec4(22784,128,61,69),\nivec4(22784,128,64,77),\nivec4(22784,128,69,77),\nivec4(22912,128,45,84),\nivec4(22912,128,57,84),\nivec4(22912,128,61,75),\nivec4(22912,128,64,78),\nivec4(22912,128,67,78),\nivec4(23040,384,50,75),\nivec4(23040,384,57,75),\nivec4(23040,384,62,79),\nivec4(23040,384,66,75),\nivec4(23424,128,50,74),\nivec4(23424,128,62,69),\nivec4(23552,128,54,83),\nivec4(23552,128,66,90),\nivec4(23680,128,50,75),\nivec4(23680,128,62,80),\nivec4(23808,128,57,91),\nivec4(23808,128,69,92),\nivec4(23936,128,54,71),\nivec4(23936,128,66,77),\nivec4(24064,128,74,94),\nivec4(24064,256,47,83),\nivec4(24064,256,54,83),\nivec4(24064,256,62,69),\nivec4(24192,64,73,75),\nivec4(24256,64,71,77),\nivec4(24320,64,69,71),\nivec4(24320,256,43,84),\nivec4(24320,256,55,84),\nivec4(24320,256,62,75),\nivec4(24384,64,67,75),\nivec4(24448,64,66,75),\nivec4(24512,64,64,74),\nivec4(24576,256,45,69),\nivec4(24576,256,54,79),\nivec4(24576,256,57,72),\nivec4(24576,256,62,75),\nivec4(24832,128,57,78),\nivec4(24832,128,66,90),\nivec4(24832,256,45,78),\nivec4(24832,256,61,81),\nivec4(24960,128,55,78),\nivec4(24960,128,64,76),\nivec4(25088,256,50,80),\nivec4(25088,256,54,78),\nivec4(25088,256,57,73),\nivec4(25088,256,62,77),\nivec4(25600,256,43,68),\nivec4(25600,256,55,68),\nivec4(25600,256,59,74),\nivec4(25600,256,67,74),\nivec4(25856,192,47,76),\nivec4(25856,192,55,76),\nivec4(25856,192,62,77),\nivec4(25856,192,67,77),\nivec4(26048,64,50,84),\nivec4(26048,64,55,84),\nivec4(26048,64,59,75),\nivec4(26048,64,62,75),\nivec4(26112,128,48,75),\nivec4(26112,128,55,75),\nivec4(26112,128,64,83),\nivec4(26240,128,48,81),\nivec4(26240,128,52,81),\nivec4(26240,128,60,69),\nivec4(26496,128,48,70),\nivec4(26496,128,55,70),\nivec4(26496,128,64,73),\nivec4(26496,128,67,73),\nivec4(26624,128,45,81),\nivec4(26624,128,57,81),\nivec4(26624,128,64,92),\nivec4(26624,128,72,92),\nivec4(26752,128,47,72),\nivec4(26752,128,56,72),\nivec4(26752,128,64,73),\nivec4(26752,128,71,73),\nivec4(26880,128,48,81),\nivec4(26880,128,57,81),\nivec4(26880,128,64,74),\nivec4(26880,128,69,74),\nivec4(27008,128,49,80),\nivec4(27008,128,57,80),\nivec4(27008,128,64,77),\nivec4(27008,128,67,77),\nivec4(27136,256,50,84),\nivec4(27136,256,57,84),\nivec4(27136,256,62,77),\nivec4(27136,256,66,77),\nivec4(27520,128,54,72),\nivec4(27520,128,57,72),\nivec4(27520,128,62,68),\nivec4(27520,128,69,68),\nivec4(27648,256,55,81),\nivec4(27648,256,59,81),\nivec4(27648,256,62,67),\nivec4(27648,256,74,91),\nivec4(27904,256,50,80),\nivec4(27904,256,57,80),\nivec4(27904,256,66,81),\nivec4(27904,256,72,73),\nivec4(28160,64,71,78),\nivec4(28160,128,47,73),\nivec4(28160,128,55,73),\nivec4(28160,128,62,69),\nivec4(28224,64,67,69),\nivec4(28288,64,72,85),\nivec4(28288,128,45,82),\nivec4(28288,128,57,82),\nivec4(28288,128,64,78),\nivec4(28352,64,69,75),\nivec4(28416,128,47,66),\nivec4(28416,128,62,68),\nivec4(28416,128,67,87),\nivec4(28416,128,74,87),\nivec4(28544,128,48,83),\nivec4(28544,128,64,77),\nivec4(28544,128,69,77),\nivec4(28544,128,72,77),\nivec4(28672,256,50,68),\nivec4(28672,256,62,75),\nivec4(28672,256,67,77),\nivec4(28672,256,71,77),\nivec4(28928,128,62,106),\nivec4(28928,256,50,77),\nivec4(28928,256,66,72),\nivec4(28928,256,69,72),\nivec4(29056,128,60,76),\nivec4(29184,512,55,76),\nivec4(29184,512,59,76),\nivec4(29184,512,62,75),\nivec4(29184,512,67,75),\nivec4(29696,256,43,73),\nivec4(29696,256,55,73),\nivec4(29696,256,62,93),\nivec4(29696,256,67,93),\nivec4(29696,256,71,93),\nivec4(30080,128,43,76),\nivec4(30080,128,55,76),\nivec4(30080,128,62,73),\nivec4(30080,128,65,73),\nivec4(30080,128,71,73),\nivec4(30208,64,48,68),\nivec4(30208,64,60,82),\nivec4(30208,64,64,82),\nivec4(30208,64,72,82),\nivec4(30336,64,48,76),\nivec4(30336,64,60,77),\nivec4(30336,64,64,77),\nivec4(30336,64,72,77),\nivec4(30592,128,50,67),\nivec4(30592,128,55,67),\nivec4(30592,128,67,71),\nivec4(30592,128,71,71),\nivec4(30720,192,72,80),\nivec4(30720,256,45,82),\nivec4(30720,256,57,82),\nivec4(30720,256,64,79),\nivec4(30912,64,71,77),\nivec4(30976,128,45,81),\nivec4(30976,128,57,81),\nivec4(30976,128,64,72),\nivec4(30976,128,69,74),\nivec4(31104,128,45,78),\nivec4(31104,128,57,78),\nivec4(31104,128,61,72),\nivec4(31104,128,67,74),\nivec4(31232,512,50,72),\nivec4(31232,512,57,83),\nivec4(31232,512,62,80),\nivec4(31232,512,66,73),\nivec4(31744,256,55,83),\nivec4(31744,256,59,83),\nivec4(31744,256,62,77),\nivec4(31744,256,74,91),\nivec4(32000,256,50,77),\nivec4(32000,256,57,77),\nivec4(32000,256,66,86),\nivec4(32000,256,72,84),\nivec4(32256,64,71,72),\nivec4(32256,128,47,75),\nivec4(32256,128,55,75),\nivec4(32256,128,62,69),\nivec4(32320,64,67,67),\nivec4(32384,64,72,88),\nivec4(32384,128,45,83),\nivec4(32384,128,57,83),\nivec4(32384,128,64,80),\nivec4(32448,64,69,71),\nivec4(32512,128,47,68),\nivec4(32512,128,62,75),\nivec4(32512,128,67,89),\nivec4(32512,128,74,89),\nivec4(32640,128,48,81),\nivec4(32640,128,64,76),\nivec4(32640,128,69,75),\nivec4(32640,128,72,75),\nivec4(32768,256,50,71),\nivec4(32768,256,62,72),\nivec4(32768,256,67,79),\nivec4(32768,256,71,79),\nivec4(33024,128,62,101),\nivec4(33024,256,50,75),\nivec4(33024,256,66,77),\nivec4(33024,256,69,77),\nivec4(33152,128,60,78),\nivec4(33280,512,55,80),\nivec4(33280,512,59,79),\nivec4(33280,512,62,75),\nivec4(33280,512,67,75),\nivec4(33792,256,43,90),\nivec4(33792,256,55,90),\nivec4(33792,256,62,87),\nivec4(33792,256,65,87),\nivec4(33792,256,67,87),\nivec4(33792,256,71,87),\nivec4(34176,128,43,86),\nivec4(34176,128,55,86),\nivec4(34176,128,62,68),\nivec4(34176,128,65,68),\nivec4(34176,128,67,68),\nivec4(34176,128,71,68),\nivec4(34304,64,48,98),\nivec4(34304,64,55,98),\nivec4(34304,64,64,80),\nivec4(34304,64,67,80),\nivec4(34304,64,72,80),\nivec4(34432,64,48,99),\nivec4(34432,64,55,99),\nivec4(34432,64,64,80),\nivec4(34432,64,67,80),\nivec4(34432,64,72,80),\nivec4(34688,128,43,91),\nivec4(34688,128,55,91),\nivec4(34688,128,62,72),\nivec4(34688,128,67,72),\nivec4(34688,128,71,72),\nivec4(34816,128,45,84),\nivec4(34816,192,60,88),\nivec4(34816,192,64,88),\nivec4(34816,192,72,88),\nivec4(34944,128,47,99),\nivec4(35008,64,62,75),\nivec4(35008,64,67,75),\nivec4(35008,64,71,75),\nivec4(35072,128,48,104),\nivec4(35072,128,60,69),\nivec4(35072,128,64,69),\nivec4(35072,128,69,69),\nivec4(35200,128,49,108),\nivec4(35200,128,58,76),\nivec4(35200,128,64,76),\nivec4(35200,128,67,76),\nivec4(35328,128,50,103),\nivec4(35328,512,57,75),\nivec4(35328,512,62,75),\nivec4(35328,512,66,75),\nivec4(35456,128,52,110),\nivec4(35584,128,50,104),\nivec4(35712,128,48,110),\nivec4(35840,256,47,104),\nivec4(35840,256,59,104),\nivec4(35840,256,62,71),\nivec4(35840,256,74,95),\nivec4(36096,256,45,92),\nivec4(36096,256,57,92),\nivec4(36096,256,66,84),\nivec4(36096,256,72,77),\nivec4(36352,64,71,77),\nivec4(36352,128,43,92),\nivec4(36352,128,55,92),\nivec4(36352,128,62,69),\nivec4(36416,64,67,67),\nivec4(36480,64,72,92),\nivec4(36480,128,45,99),\nivec4(36480,128,57,99),\nivec4(36480,128,64,77),\nivec4(36544,64,69,75),\nivec4(36608,128,47,102),\nivec4(36608,128,59,102),\nivec4(36608,128,62,73),\nivec4(36608,128,74,89),\nivec4(36736,128,48,98),\nivec4(36736,128,60,98),\nivec4(36736,128,64,77),\nivec4(36736,128,72,78),\nivec4(36864,256,50,90),\nivec4(36864,256,62,77),\nivec4(36864,256,67,77),\nivec4(36864,256,71,77),\nivec4(37120,256,50,96),\nivec4(37120,256,60,70),\nivec4(37120,256,66,70),\nivec4(37120,256,69,70),\nivec4(37376,384,43,105),\nivec4(37376,384,55,105),\nivec4(37376,384,59,72),\nivec4(37376,384,62,72),\nivec4(37376,384,67,72));\n\nfloat TWOPI = 6.283185307;\n\nfloat organ1(float f, float t) {\n  // sin & cos on Intel GPUs give poor results for large arguments, hence the fract\n  float res = sin(TWOPI*fract(f*t));\n  return res*res*res;\n}\n\nfloat organ2(float f, float t) {\n  float mod = 0.1*sin(TWOPI*fract(5.0*t)); // Vibrato\n  f *= t;\n  float res = 0.0;\n  res += 0.5*sin(TWOPI*fract(1.0*f + mod));\n  res += 0.5*sin(TWOPI*fract(2.0*f + mod));\n  res += 0.1*sin(TWOPI*fract(3.0*f + mod));\n  res += 0.05*sin(TWOPI*fract(4.0*f + mod));\n  return res;\n}\n\nbool rackett = false;\nfloat organ3(float f, float t) {\n  float res = sin(TWOPI*fract(f*t));\n  if (rackett) res = sign(res); // The sound of the sausage bassoon.\n  return res;\n}\n\n// From https://www.shadertoy.com/view/ssjyDD by @athibaul\nfloat FM(float fc, float fm, float iom, float t) {\n  // NB: iom is multiplied by 2pi here.\n  return sin(TWOPI*fract(fc*t + sin(TWOPI*fract(fm*t))));\n}\n\nvec2 fmPluck(float f, float t) {\n    float fc = f; // carrier freq\n    float fm = f; // modulation freq\n    float iom = 1.0; // index of modulation\n    float env = exp(-3.0*t) * 0.1;\n    vec2 sig = vec2(0);\n    \n    sig.x += FM(f+1.0, f+1.0, iom, t) * env;\n    sig.y += FM(f-1.0, f-1.0, iom, t) * env;\n    sig += FM(f, f, 10.0, t) * exp(-20.0*t) * 0.03;\n    return sig;\n}\n\n// From: https://www.shadertoy.com/view/3scfD2 by @athibaul\n// mla: probably don't need the fract here, but it does no harm\n#define msin(x,m) sin(TWOPI*fract(x)+(m))\n\nvec2 epiano(float freq, float t, float nuance) {\n    // freq : frequency of note\n    // t : time since beginning of note\n    // nuance : 1 is mezzo-forte, smaller is piano, larger is forte\n    vec2 f0 = vec2(freq*0.998, freq*1.002);\n    \n    // Glassy attack : slightly sharp,\n    // modulated at 14 * base frequency with a sharply decaying envelope\n    // and with a relatively fast decay\n    vec2 glass = msin((f0+3.)*t, msin(14.*f0*t,0.) * exp(-30.*t) * nuance) * exp(-4.*t)  * nuance;\n    glass = sin(glass); // Distort at high nuances\n    \n    // Body of the sound : perfectly in tune,\n    // index of modulation depends on nuance and is boosted a bit for low notes\n    vec2 body = msin(f0*t, msin(f0*t,0.) * exp(-0.5*t) * nuance * pow(440./f0.x, 0.5)) * exp(-t) * nuance;\n    \n    // Pan the attack depending on which note it is\n    float panDir = clamp(log2(freq/400.)/2., -1., 1.); // -1 is left, 1 is right\n    vec2 pan = normalize(vec2(0.5-0.5*panDir, 0.5+0.5*panDir));\n    return (glass*pan + body) * 0.05 * smoothstep(0.,0.001,t);\n}\n\nvec2 note(ivec4 n, int samp) {\n  // Following ttg's suggestion to compute integer \n  // starting sample for note\n  int s0 = int(iSampleRate/(speed*1000.0)*float(n.x));\n  vec2 res = vec2(0);\n  if (samp >= s0) {\n    samp -= s0;\n    // then only convert to a time after subtracting the\n    // start sample value.\n    float t = float(samp)/iSampleRate, t0 = 0.0;\n    float pitch = float(n.z);\n    float f = 440.0*exp2((pitch-69.0)/12.0);\n    float vol = float(n.z)/127.0;\n    if (SOUND == 0) {\n      res += 0.5*vol*fmPluck(f,t);\n    } else if (SOUND == 3) {\n      res += vol*epiano(f,t,1.0);\n    } else {\n      float len = float(n.y)/(speed*1000.0);\n      float rampup = 0.1, rampdown = 0.1;\n      if (SOUND == 1) {\n        rampup = 0.01; rampdown = 0.5; len = 0.0;\n      }\n      float t1 = t0+len;\n\n      float env = smoothstep(t0,t0+rampup,t);\n      env *= (1.0-smoothstep(t1,t1+rampdown,t));\n      float s = SOUND==1 ? organ1(f,t) : SOUND == 2 ? organ2(f,t) : organ3(f,t);\n      float K = 1.0; // Lower register boost\n      res += 0.1*vol*pow(440.0/f,K)*env*s;\n    }\n  }\n  return res;\n}\n\nvec2 mainSound(int samp, float t) {\n  if (SOUND == 2) speed *= 0.8;\n  float repeat = 38.0/speed;\n  if (t > repeat) {\n    t -= repeat;\n    samp -= int(iSampleRate*repeat);\n    rackett = true;\n  }\n  //float offset = 160.0;\n  //samp += int(iSampleRate*offset); t += offset;\n  int NNOTES = data.length();\n  //if (NNOTES > 2047) return vec2(0); // Nvidia check\n  float tick = t*speed*1000.0;  // MIDI time tick\n  int i = 0, j = NNOTES;\n  while (i != j) {\n    // Binary search to find first note starting less\n    // than X ticks before t.\n    float X = 10000.0;\n    int k = i+(j-i)/2;\n    if (float(data[k].x) < tick-X) i = k+1;\n    else j = k;\n  }\n  vec2 res = vec2(0);\n  for ( ; i < NNOTES; i++) {\n    if (float(data[i]) > tick+100.0) break;\n    res += note(data[i],samp);\n  }\n  return res;\n}", "sound_inputs": [], "common_code": "#if 1\n// The Queen\n#define CHAN iChannel0\n#define WIDTH 294.0\n#define HEIGHT 462.0\n#else\n// William Kingdon Clifford\n#define CHAN iChannel1\n#define WIDTH 199.0\n#define HEIGHT 299.0\n#endif\n\nconst vec3 colors[] = vec3[](\nvec3(0x00,0x70,0xa0),\nvec3(0x00,0x70,0x90),\nvec3(0x90,0x50,0x70),\nvec3(0xf0,0xd0,0x50),\nvec3(0x60,0x70,0xb0),\nvec3(0x00,0x70,0xb0),\nvec3(0x60,0xb0,0xb0),\nvec3(0xc0,0xb0,0xb0),\nvec3(0xf0,0xa0,0xd0),\nvec3(0x00,0x80,0xb0),\nvec3(0x10,0x90,0xa0),\nvec3(0x10,0x90,0xc0),\nvec3(0x00,0x80,0xc0),\nvec3(0x00,0x90,0xb0),\nvec3(0xe0,0xe0,0xe0),\nvec3(0xf0,0xf0,0xf0));\n\nint coloroffset = 0;\nvec3 getcolor(int i) {\n  if (i < 0) return vec3(0);\n  i += coloroffset;\n  i %= colors.length();\n  return colors[i]/255.0;\n}\n// Show greyscale colors\nvec3 getcolor0(int i) {\n  return vec3( clamp(1.0-float(i)/9.0,0.0,1.0) );\n}", "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sScWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1001, 1001, 1056, 1096, 1786]]}
{"id": "NdjyWV", "name": "odos|toon fire", "author": "ErinZ", "description": "2d cartoon fire with woelry noise", "tags": ["2d", "noise"], "likes": 15, "viewed": 535, "published": 3, "date": "1644124112", "time_retrieved": "2024-07-30T17:05:03.665498", "image_code": "#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nvec2 hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) ); \n    return fract(sin(p)*43758.37); \n}\n\nfloat worley(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float r = 1.;\n    for(int i=-2;i<=2;i++){\n    for(int j=-2;j<=2;j++){\n        vec2 o = hash(n+vec2(i,j));\n        o = sin(iTime/2. + hash(n+vec2(i,j))*6.28)*0.5+0.5;//animate\n        o += vec2(i,j);\n        float D1 = distance(o,f);//Euclidean\n        r = min(r,D1);\n    }\n    }\n    return r;\n}\n\nfloat logo(vec2 uv);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float c = worley(uv + vec2(0.,-iTime))*0.5;\n    c += worley(uv*2.+vec2(sin(iTime*2.)*0.5,-iTime*6.))*0.5;//2 Layers worley\n    c += (-uv.y-0.3)*0.6;//y mask\n    \n    vec2 p = uv;\n    p.x *=1.5+smoothstep(-0.3,1.,uv.y)*1.5;\n    float m = smoothstep(1.,.5,length(p));//circle mask\n    \n    float c0 = smoothstep(.4,.6,m*c*3.);//out fire\n    float c1 = smoothstep(.5,.52,m*c*2.);//mid fire\n    float c2 = smoothstep(.5,.52,m*c*1.2*(-uv.y+0.3));//inner fire\n    float c3 = pow(worley(uv*6.+vec2(sin(iTime*4.)*1.,-iTime*16.)),8.);\n          c3 = smoothstep(.98,1.,c3)*m;//sparkle\n\n    vec3 col = vec3(1.,.4,.2)*c3;//sparkle\n    col = mix(col,vec3(.95,.1,.2)*(uv.y+.8),c0);//out\n    col = mix(col,mix(vec3(.9,.3,.2),vec3(.9,.6,.2),-uv.y),c1);//mid\n    col = mix(col,vec3(.9,.8,.2),c2);//inner\n\n    col +=logo(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 74, 74, 181], [183, 183, 204, 204, 549], [572, 572, 629, 629, 1559], [1616, 1616, 1636, 1636, 2025]]}
{"id": "sdBcDK", "name": "Morey Refracty Objecty Thingy", "author": "SnoopethDuckDuck", "description": "nothing special just a little idea", "tags": ["raymarching", "refraction", "glass", "diamond", "gem", "artofcode"], "likes": 3, "viewed": 264, "published": 3, "date": "1644092710", "time_retrieved": "2024-07-30T17:05:04.605983", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define pi 3.14159\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    //p.x += cos(2. * p.y + iTime);\n   // p.xz *= Rot(2. * p.y + iTime);\n   \n    float l = 0.5 + 0.5 * thc(4., iTime);\n    float d = sdBox(p, vec3(0.3)) - 0.3;\n    d = abs(d) - 0.2;\n    //float d = abs(length(p) - 0.8) - 0.3;\n    return 0.4* d; // lower than I'd like it to be\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float time = 0.2 * length(uv) + 0.65 * iTime;\n    float sc = 3.2;\n    vec3 ro = 3. * vec3(thc(sc, time), \n                        thc(sc, 2. * pi / 3. + time),\n                        thc(sc, 4. * pi / 3. + time));\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 2.);\n    \n    vec3 col = vec3(0.);//texture(iChannel0, rd).rgb;\n    \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 2.4;//mix(0., 1.5, 0.5 + 0.5 * thc(5., 0.6 * iTime)); // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n             \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*3000.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 rdOut = refract(rdIn, nExit, IOR);\n       \n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(-n, nExit);\n        //rdOut = reflect(rdIn, nExit);\n\n        vec3 pExit2 = pExit - nExit*SURF_DIST*3.;\n        float dExit = RayMarch(pExit2, rdOut, 1.);\n        if (dExit < MAX_DIST)\n            col = vec3(0.5 + 0.5 * rdOut);\n        \n        float fresnel = pow(1.+dot(rd, n), 4.);\n        col += 0.3 * fresnel;\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        col = mix(col, refOutside, fresnel);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 137, 137, 199], [201, 201, 230, 230, 311], [314, 314, 337, 410, 616], [618, 618, 664, 664, 880], [882, 882, 906, 906, 1096], [1098, 1098, 1148, 1148, 1339], [1341, 1341, 1398, 1398, 3110]]}
{"id": "7sScWK", "name": "tri-Sierpinski triangle zoom", "author": "FabriceNeyret2", "description": "reproducing https://twitter.com/sjpalmer1994/status/1407000529750876163", "tags": ["sierpinski", "short", "reproduction", "sierpinsky"], "likes": 24, "viewed": 375, "published": 3, "date": "1644085952", "time_retrieved": "2024-07-30T17:05:05.505578", "image_code": "#define R iResolution.xy\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\nfloat t, T;\n\nfloat S( vec2 U ) {                                   // === Sierpinski triangle\n     float O = 0., l, s = R.y/T;\n     U *= T;\n     for (int i=int(log2(R.y))-1; i>=0; i--, s/=2.) { // fractal loop\n         l = min( line(U,vec2(0,0),vec2(1,0)),        \n                  line(U,vec2(0,0),vec2(.5,.87)) );   // triangle\n        l = min(l,line(U,vec2(1,0),vec2(.5,.87)) );\n        O = max(O, smoothstep(1.5,0.,l*s ) * (i>0 ? 1. : t ) ); // fade last\n        U *= 2.;                                      // fractal recursion: 3 branches\n        if (U.y > .86) U.x-=.5, U.y-=.87;\n        else if (U.x > 1.) U.x--;   \n    }  \n    return O;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {                  // ==========================\n     vec2  U = ( u - .5*R ) /R.y + vec2(.12,.3);\n           t = fract(.3*iTime),\n           T = exp2(-t);                              // zoom factor\n\n    O = vec4( S(U),                                   // draw the 3 triangles\n              S(U+vec2(.755,.43)+ (1./T-1.)*vec2(.5,.87) ), \n              S(U+vec2(.748 +1./T-1.,-.44) ),  1 );\n    O = mix( O, vec4(O.r+O.g+O.b), .5);               // desaturate\n    O = sqrt(O);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sScWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 61, 61, 233], [248, 248, 267, 328, 884], [886, 886, 922, 969, 1398]]}
{"id": "NsBcWV", "name": "Refracty Object Thing", "author": "SnoopethDuckDuck", "description": "click to move\n\njust messing around with shapes etc", "tags": ["raymarching", "refraction", "glass", "diamond", "gem", "artofcode"], "likes": 5, "viewed": 312, "published": 3, "date": "1644085323", "time_retrieved": "2024-07-30T17:05:06.347327", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define pi 3.14159\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    p.xz *= Rot(0.3 * iTime);\n   // p.xz *= Rot(iTime);\n    //p.xz *= Rot(iTime);\n    float d2 = abs(sdBox(p, vec3(0.2)) - 0.1) - 0.05;\n   \n    float sc = 0.02;\n    p.x += sc * cos(12. * p.y + iTime);\n    p.z += sc * sin(12. * p.y + iTime);\n\n    float d = abs(length(p) - 0.6) - d2 * (0.6 + 0.1 * cos(20. * d2 - iTime));\n   // d2 -= d;\n    return 0.2 * d; // lower than I'd like it to be\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3)*.7;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.1);\n    \n    vec3 col = vec3(0.);//texture(iChannel0, rd).rgb;\n    \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.2;//mix(0., 1.5, 0.5 + 0.5 * thc(5., 0.6 * iTime)); // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n             \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*30.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        IOR = -1.; // <-- remove this to make it work like normal\n        rdOut = refract(rdIn, nExit, IOR);\n       \n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex = texture(iChannel0, rdOut).rgb;\n        \n        vec3 pExit2 = pExit - nExit*SURF_DIST*3.;\n        float dExit = RayMarch(pExit2, rdOut, 1.);\n        if (dExit < MAX_DIST) {\n           vec3 pL = pExit2 + rdOut * dExit;\n           vec3 nL = GetNormal(pL);\n           float dif = dot(nL, normalize(vec3(1,2,3)))*.5+.5;\n           dif = clamp(dif, 0., 1.); // most of this probably not needed\n           dif = smoothstep(0., 1., dif);\n           dif = pow(4. * dif * (1.-dif), 2.);\n           col = vec3(dif);\n           float fresnel = pow(1.+dot(rdOut, nL), 2.);\n           col *= clamp(fresnel, 0., 1.);\n           col *= 0.5 + 0.5 * nL;\n          \n           col *= 1. + 0.2 * thc(4., 12. * p.y + 0.5 * cos(10. * p.x));\n           //col = mix(col, texture(iChannel0, rdOut).rgb, 0.2);\n        }\n\n        float fresnel = pow(1.+dot(rd, n), 3.);\n        fresnel = 4. * fresnel * (1.-fresnel); //idk\n        fresnel *= fresnel;\n       // col = vec3(fresnel);\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        col = mix(col, refOutside, fresnel);\n       \n        \n\n    }\n    //col *= 2.;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 137, 137, 199], [201, 201, 230, 230, 311], [314, 314, 337, 337, 727], [729, 729, 775, 775, 991], [993, 993, 1017, 1017, 1207], [1209, 1209, 1259, 1259, 1450], [1452, 1452, 1509, 1509, 3946]]}
{"id": "7dScWK", "name": "Projection of Integers onto Line", "author": "pyBlob", "description": "Top: Projected grid points relative to the orange line.\nMain: Map of integers, field of view. Mouse moves projection target.\nArrow: Horizon.\n", "tags": ["visualization", "projection"], "likes": 5, "viewed": 325, "published": 3, "date": "1644082040", "time_retrieved": "2024-07-30T17:05:07.164143", "image_code": "vec3 fin(vec2 x) {\n    return vec3(x, 1);\n}\n\nvec3 inf(vec2 x) {\n    return vec3(x, 0);\n}\n\nvec2 hom(vec3 x) {\n    return x.xy / x.z;\n}\n\nvoid mainImage(out vec4 C, in vec2 O0)\n{\n    f = 5. / iResolution.y;\n    vec2 O = world(O0);\n\n    vec2 cam = vec2(3, 3) + .1 * f;\n    vec2 a0 = cam + vec2(-10, 1) / 10.;\n    vec2 b0 = cam + vec2(1, -10) / 10.;\n    if (iMouse.z > 0.)\n        cam = world(iMouse.xy + .1);\n\n    /*\n    Invariants A.1 and A.2 imply that without further constraints,\n    you can't infer camera parameters from a single image.\n    \n    Yet, the map between points on the line and projected points\n    is exactly 1:1. This can be seen as follows:\n    - Given distinct points A, B, T and \"the line\".\n        - and T not in \"the line\".\n        - and T not in line AB.\n    - For all points X in \"the line\" (including point at infinity):\n        - The line XT joins X and the projection target T.\n        - This line XT meets the screen line AB at exactly one point (possibly at infinity).\n    - For all points X in the line AB (including point at infity):\n        - The line XT joins X and the projection target T.\n        - This line XT meets \"the line\" at exactly one point (possibly at infinity).\n    -> The image can be inferred from the world and vice versa.\n    \n    Things to try:\n        - \"cf = 1\": Intersection between AB and \"the line\" stays fixed.\n        - \"sf, cf = 0, 1\": Above + Space stretches/squishes along y-axis.\n    */\n\n    // Invariant A.1: Y-scale perpendicular to line does not move projected points\n    float hf = .8 + .2 * cos(iTime / 3.);\n    cam.y *= hf;\n    a0.y*=hf;\n    b0.y *= hf;\n    \n    // Invariant A.2: Y-Shear perpendicular to line does not move projected points\n    float sf = .5 * cos(iTime / 2.);\n    //sf = 0.;\n    cam.x += cam.y * sf;\n    a0.x += a0.y * sf;\n    b0.x += b0.y * sf;\n    \n    // Invariant B: Uniform scale around projection target does not move projected points\n    // This just moves the line AB without changing its direction.\n    float cf = 1. + cos(iTime);\n    //cf = 1.;\n    vec2 a = a0 + (a0 - cam) * cf;\n    vec2 b = b0 + (b0 - cam) * cf;\n\n    C = vec4(0);\n    blend(C, vec3(0,0.2,1), abs(O.y) / f);\n    blend(C, vec3(.2,.2,.2), length(O-cam) / f - 2.);\n    blend(C, vec3(.2,.2,.2), line(O, cam, a, 0., 1e2) / f);\n    blend(C, vec3(.2,.2,.2), line(O, cam, b, 0., 1e2) / f);\n    blend(C, vec3(.2,.2,.2), length(O-a0) / f - 2.);\n    blend(C, vec3(.2,.2,.2), length(O-b0) / f - 2.);\n    vec3 ab = cross(fin(a), fin(b));\n    {\n        for (float i=-20. ; i<=20. ; i++)\n        {\n            vec2 s = vec2(1, 0) * i;\n            vec2 t = hom(cross(cross(fin(s), fin(cam)), ab));\n            blend(C, vec3(0,0.2,1), line(O, t, s) / f);\n        }\n        vec2 v = vec2(-1, 0);\n        vec2 t = hom(cross(cross(inf(v), fin(cam)), ab));\n        blend(C, vec3(0,0.2,1), arrow(O, t, t+v) / f);\n\n        blend(C, vec3(1,0.2,0), line(O, a, b) / f);\n        blend(C, vec3(.5,0,0), line(O, a, b, -1e2, 0.) / f);\n        blend(C, vec3(.5,0,0), line(O, a, b, 1., 1e2) / f);\n    }\n    \n    f = 1. / iResolution.x;\n    O = wcam(O0);\n    {\n        blend(C, vec3(0), -(O.y / f + iResolution.x * .06));\n        vec2 ca = floor(vec2(0.1, -0.01) / f) * f;\n        vec2 cb = floor(vec2(0.9, -0.01) / f) * f;\n        blend(C, vec3(1,0.2,0), line(O, ca, cb) / f);\n        blend(C, vec3(.5,0,0), line(O, ca, cb, -1e2, 0.) / f);\n        blend(C, vec3(.5,0,0), line(O, ca, cb, 1., 1e2) / f);\n        blend(C, vec3(.2,.2,.2), line(O, ca, ca-vec2(0,.02)) / f);\n        blend(C, vec3(.2,.2,.2), line(O, cb, cb-vec2(0,.02)) / f);\n        for (float i=-20. ; i<=20. ; i++)\n        {\n            vec2 s = vec2(1, 0) * i;\n            vec2 t = hom(cross(cross(fin(s), fin(cam)), ab));\n            t = ca + (cb - ca) * dot(t - a, b - a) / dot(b - a, b - a);\n            blend(C, vec3(0,0.2,1), line(O, t, t-vec2(0,.02)) / f);\n        }\n        vec2 v = vec2(-1, 0);\n        vec2 t = hom(cross(cross(inf(v), fin(cam)), ab));\n        t = ca + (cb - ca) * dot(t - a, b - a) / dot(b - a, b - a);\n        blend(C, vec3(0,0.2,1), arrow(O, t, t+vec2(0,-.04)) / f);\n    }\n    \n    C = sqrt(C);\n}\n\nvec2 world(vec2 O)\n{\n    O -= floor(iResolution.xy / 2.) + .5;\n    O *= f;\n    O += vec2(0, 2);\n    return O;\n}\n\nvec2 wcam(vec2 O)\n{\n    O -= floor(vec2(0, 1) * iResolution.xy) + .5;\n    O *= f;\n    O += vec2(0);\n    return O;\n}\n", "image_inputs": [], "common_code": "vec2 world(vec2 O);\nvec2 wcam(vec2 O);\n\nfloat line(vec2 p, vec2 a, vec2 b, float c0, float c1)\n{\n    p -= a;\n    b -= a;\n    float u = clamp(dot(p, b) / dot(b,b), c0, c1);\n    return length(p - b*u);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    return line(p, a, b, 0., 1.);\n}\n\nfloat arrow(vec2 p, vec2 a, vec2 b)\n{\n    a -= b;\n    p -= b;\n    vec2 u = .2 * a;\n    vec2 v = .4 * vec2(-u.y, u.x);\n    return min(\n        line(p, a, vec2(0), 0., 1.),\n        min(\n            line(p, vec2(0), u+v, 0., 1.),\n            line(p, vec2(0), u-v, 0., 1.)\n        )\n    );\n}\n\nfloat f;\n\nvoid blend(inout vec4 C, vec3 v, float r)\n{\n    float a = smoothstep(1.0, 0.0, r);\n    C = mix(C, vec4(v, 1), a);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dScWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 43], [45, 45, 63, 63, 88], [90, 90, 108, 108, 133], [135, 135, 175, 175, 4121], [4123, 4123, 4143, 4143, 4234], [4236, 4236, 4255, 4255, 4351]]}
{"id": "sdSyWK", "name": "odos|psrdnoise warping", "author": "ErinZ", "description": "psenoise test", "tags": ["simplexnoise"], "likes": 2, "viewed": 335, "published": 3, "date": "1644078857", "time_retrieved": "2024-07-30T17:05:07.980960", "image_code": "// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n  vec2 uv = vec2(x.x+x.y*0.5, x.y);\n  vec2 i0 = floor(uv), f0 = fract(uv);\n  float cmp = step(f0.y, f0.x);\n  vec2 o1 = vec2(cmp, 1.0-cmp);\n  vec2 i1 = i0 + o1, i2 = i0 + 1.0;\n  vec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n  vec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n  vec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n  vec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n  vec3 iu, iv, xw, yw;\n  if(any(greaterThan(period, vec2(0.0)))) {\n    xw = vec3(v0.x, v1.x, v2.x);\n    yw = vec3(v0.y, v1.y, v2.y);\n    if(period.x > 0.0)\n    xw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n    if(period.y > 0.0)\n      yw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n    iu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n  } else {\n    iu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n  }\n  vec3 hash = mod(iu, 289.0);\n  hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n  hash = mod((hash*34.0 + 10.0)*hash, 289.0);\n  vec3 psi = hash*0.07482 + alpha;\n  vec3 gx = cos(psi); vec3 gy = sin(psi);\n  vec2 g0 = vec2(gx.x, gy.x);\n  vec2 g1 = vec2(gx.y, gy.y);\n  vec2 g2 = vec2(gx.z, gy.z);\n  vec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n  w = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n  vec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n  float n = dot(w4, gdotx);\n  vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n  vec2 dn0 = w4.x*g0 + dw.x*x0;\n  vec2 dn1 = w4.y*g1 + dw.y*x1;\n  vec2 dn2 = w4.z*g2 + dw.z*x2;\n  gradient = 10.9*(dn0 + dn1 + dn2);\n  return 10.9*n;\n}\n\nfloat fbm(vec2 x,float n,out vec2 g){\n\nvec2 p = vec2(0.);\nfloat alpha = iTime*.05;\nfloat scale = .5;\n\nfloat noise = 0.;\nfor (float i = 0.;i<n;i++){\nnoise += psrdnoise(x , p, alpha, g)*scale;\nx *=2.;scale/=2.;alpha *=1.3;\n}\nreturn noise;\n}\n\nfloat pattern( in vec2 p , out vec2 g)\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ,4.,g),\n                   fbm( p + vec2(5.2,1.3),4.,g) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ,4.,g),\n                   fbm( p + 4.0*q + vec2(8.3,2.8) ,4.,g) );\n\n    return fbm( p + 4.0*r ,4.,g);\n}\n\nfloat logo(vec2 uv);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 uv1 = uv*1.5;\n    const vec2 p = vec2(8.0, 8.0);\n    float alpha = iTime*.1;\n    vec2 g;\n    float n = psrdnoise(uv1, p, alpha, g);\n    \n    \n    vec3 col;\n    col = vec3(n*0.5+0.5);\n    //warping\n    vec2 uv2 = uv*.1;\n    vec3 pa;\n    pa.x = pattern(uv2,pa.yz);\n    col = mix(vec3(0,0,0),vec3(.2,.3,.4),pa.x+n*0.3);\n    col = mix(col,vec3(.7,.3,.3),pa.x-n*0.1);\n    col = mix(col,vec3(.8,.6,.9),smoothstep(-1.,1.,pa.y)*.4);\n    \n    col= clamp(col,0.,1.);\n    col +=logo(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyWK.jpg", "access": "api", "license": "mit", "functions": [[143, 143, 213, 213, 1672], [1674, 1674, 1711, 1711, 1912], [1914, 1914, 1954, 1954, 2211], [2234, 2234, 2291, 2291, 2897], [2955, 2955, 2975, 2975, 3364]]}
{"id": "NsScDV", "name": "odos| voronoi boxes", "author": "ErinZ", "description": "refers to inigo quilez https://www.shadertoy.com/view/MdSGRc", "tags": ["voronoi"], "likes": 8, "viewed": 497, "published": 3, "date": "1644077064", "time_retrieved": "2024-07-30T17:05:08.803762", "image_code": "//refers to inigo quilez's \"Voronoi - metrics \"\n//https://www.shadertoy.com/view/MdSGRc\n\nvec2 hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) ); \n    return fract(sin(p)*43758.37); \n    //return vec2(.5,mod(p.x*.3,2.)*.5);\n}\n\nvec3 worley(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec3 r = vec3(1.);\n    for(int i=-2;i<=2;i++){\n    for(int j=-2;j<=2;j++){\n        vec2 o = hash(n+vec2(i,j));\n        o = sin(iTime/4. + hash(n+vec2(i,j))*6.28)*0.5+0.5;//animate\n        o += vec2(i,j);\n        //float D1 = distance(o,f);//Euclidean\n        //float D2 = abs(o.x-f.x)+abs(o.y-f.y);//Manhattan\n        //float D3 = max(abs(o.x-f.x),abs(o.y-f.y));//Chebyshev\n        float D4 = max(abs(o.x-f.x)*0.866+(o.y-f.y)*0.5,-(o.y-f.y));//Triangle\n        if(D4<r.x){\n        r.x = D4;//distance\n        vec2 r1 = hash(n+vec2(i,j));\n        r.y = r1.x*0.5+0.5;//for colorseed\n        r.z = 1.-step(0.0,0.5*abs(o.x-f.x)+0.866*(o.y-f.y))*(1.0+step(0.0,o.x-f.x))*0.4;//mask\n        }\n    }\n    }\n    return r;\n}\n\n\nfloat logo(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 n = worley(uv*2.);\n    \n    vec2 dp = vec2( 1.0/iResolution.y, 0.0 );\n    float d = abs(worley( 2.*(uv+dp.xy)).z - worley( 2.*(uv-dp.xy)).z )+\n              abs(worley( 2.*(uv+dp.yx)).z - worley( 2.*(uv-dp.yx)).z );\n    \n    \n    vec3 col = vec3(.5,.4,2)*n.y;\n    col *= n.z+.2;//shadow\n    col = col-n.x*0.2;//ao\n    col = clamp(col,0.,1.);\n    col += d;//outline\n    col += logo(uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsScDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 107, 107, 255], [257, 257, 277, 277, 1041], [1066, 1066, 1123, 1123, 1634], [1694, 1694, 1714, 1714, 2103]]}
{"id": "fdScDV", "name": "sized swirl", "author": "van_darkholme", "description": "Sized swirl", "tags": ["swirl"], "likes": 3, "viewed": 207, "published": 3, "date": "1644076204", "time_retrieved": "2024-07-30T17:05:09.614592", "image_code": "\n#define PI 3.14\n\n// \tColors\n#define RED \tvec3(0.00, 0.9, 1.00)\n#define BLUE \tvec3(0.04, 0.00, 0.98)\n#define BEIGE \tvec3(0.05, 0.45, 0.95)\n#define VIOLET \tvec3(0.14, 0.42, 0.96)\n\n\n#define SPEED 16.0\n\n#define SPIN_SPEED 8.0\n\n\n//\tUsual rotation.\nmat2 rotate(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n\n//\tConvert time to [0; 4 * PI].\nfloat normalizeTime()\n{\n    float tt = iTime * 1.0;\n\treturn tt - float(int(tt / 4.0 / PI)) * 4.0 * PI;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n\n    float time = normalizeTime();\n    \n    float angle = abs(acos(dot(rotate(-iTime * SPIN_SPEED) *  rotate(length(uv) * 32.0) * vec2(1, 0), uv) / length(uv)));\n    \n    vec2 p = length(uv) * (rotate(angle) * uv);\n    \n    float pLength = length(p);\n    \n    vec3 color = vec3(pLength);\n\n    float timePercent = time / (4.0 * PI);\n    \n    if (angle < 1.5 * abs(0.4 * sin(iTime) + 0.8))\n    {\n        color = RED;\n        \n        if (SPEED * pLength < time)\n        {\n           color = mix(BEIGE, color, timePercent); \n        }\n    }\n    else\n    {\n        color = VIOLET;\n    \n        if (SPEED * pLength < time)\n        {\n            color = mix(BLUE, color, timePercent);\n        }\n    }\n    \n    color *= textureLod(iChannel0, p, 0.5).xyz;\n    \n    //\tGamma correction.\n    float size = (1.0 + sin(iTime)) / 2.0 * 0.5;\n    color = pow(color, vec3(0.4545 * 2.0));\n    color *= 13.0 * (size - distance(uv, vec2(0)));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdScDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 244, 270, 270, 351], [354, 386, 409, 409, 490], [493, 493, 550, 550, 1580]]}
{"id": "fsSyDK", "name": "CC0: 3 Domes", "author": "mrange", "description": "CC0: 3 Domes\nSome saturday coding to create some domes I hope will enable some other effects to look cool.", "tags": ["raytracing"], "likes": 12, "viewed": 350, "published": 3, "date": "1644063854", "time_retrieved": "2024-07-30T17:05:10.436394", "image_code": "// CC0: 3 Domes\n//  Some saturday coding to create some domes I hope will enable some other effects\n//  to look cool.\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI      3.141592654\n#define TAU     (2.0*PI)\n#define ROT(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PERIOD  10.0\n\n#define SKYCOLOR skyColor\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {\n  vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n  vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n  vec3 k = abs(m)*boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max( max( t1.x, t1.y ), t1.z );\n  float tF = min( min( t2.x, t2.y ), t2.z );\n  if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n  outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n  return vec2( tN, tF );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n  float r2 = ra*ra;\n  vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n  vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n  float ka = 1.0/dot(d2,d2);\n  float k3 = ka* dot(ro,d3);\n  float k2 = ka* dot(o2,d2);\n  float k1 = ka* dot(o3,rd);\n  float k0 = ka*(dot(o2,o2) - r2*r2);\n  float c2 = k2 - k3*k3;\n  float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n  float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n  float p = c2*c2 + c0/3.0;\n  float q = c2*c2*c2 - c2*c0 + c1*c1;\n  float h = q*q - p*p*p;\n  if( h<0.0 ) return -1.0; //no intersection\n  float sh = sqrt(h);\n  float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n  float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n  vec2  w = vec2( s+t,s-t );\n  vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n  float r = length(v);\n  return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec3 normalSphere4(in vec3 pos) {\n  return normalize(pos*pos*pos);\n}\n\nvec3 skyColor1(vec3 ro, vec3 rd) {\n  const vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\n  const vec3 lightCol2 = vec3(8.0/8.0,5.0/8.0,5.0/8.0);\n  const vec3 lightDir1 = normalize(vec3(-0.3, 0.15, 1.0));\n  const vec3 lightDir2 = normalize(vec3(-0.33,  -0.2, -1.0));\n  \n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n  float yf       = (0.5+0.5*rd.y);\n  yf *= yf;\n  yf *= yf;\n  vec3 final     = vec3(vec3(0.25, 0.2, 0.3))*yf;\n\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(clamp(1.0 - roundBox*0.5, 0.0, 1.0), 6.0);\n  \n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 8.0*lightCol1 * pow(ld1, 400.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += 8.0*lightCol2 * pow(ld2, 400.0);\n  return final;\n}\n\nvec3 skyColor2(vec3 ro, vec3 rd) {\n  const vec3 lightDir1 = normalize(vec3(-0.3, 0.25, 1.0));\n  const vec3 lightDir2 = normalize(vec3(-0.33,  -0.3, -1.0));\n  const vec3 hiLightCol1 = HSV2RGB(vec3(0.6, 0.5, 1.0))*8.0;\n  const vec3 loLightCol1 = HSV2RGB(vec3(0.9, 0.5, 1.0))*2.0;\n  const vec3 hiLightCol2 = HSV2RGB(vec3(0.1, 0.5, 1.0))*8.0;\n  const vec3 loLightCol2 = HSV2RGB(vec3(0.5, 0.5, 1.0))*2.0;\n  const vec3 skyCol      = HSV2RGB(vec3(0.7, 0.75, 0.25));\n  \n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n\n  vec3 nb;\n  const vec3 boxDim = vec3(1000.0, 500.0, 1000.0);\n  vec2 db = rayBox(ro, rd, boxDim, nb);\n  \n  vec3 p = ro+rd*db.y;\n\n  vec3 mp = p;\n  \n  vec3 dp = abs(mp);\n  vec3 sel = abs(nb);\n  vec3 d3 = mix(dp, boxDim*2.0, sel);\n  float d = d3.x;\n  const float sm = 20.0;\n  d = pmin(d, d3.y, sm);\n  d = pmin(d, d3.z, sm);\n  \n  vec3 m3 = sin(TIME+3.0*p/boxDim);\n  float m = mix(0.75, 0.9, tanh_approx(m3.x+m3.y+m3.z));\n  m *= m;\n  m *= m;\n  vec3 hsv = vec3(0.4+mix(0.45,0.0, m), tanh_approx(0.005*mix(50.0, 10.0, m)*d), 1.0);\n  vec3 gcol = 1.5*hsv2rgb(hsv)*exp(-0.005*mix(30.0, 10.0, m)*d);\n\n\n  float dif = max(dot(rd, -nb), 0.0);\n  dif *= dif;\n  dif *= dif;\n\n  float yf       = (0.5+0.5*rd.y);\n  yf *= yf;\n\n  vec3 col = skyCol*yf;\n  \n  col += gcol;\n  if (rd.y > 0.0) {\n    const vec3 gcol = HSV2RGB(vec3(0.8, 0.33, 1.0));\n    vec3 pos  = ro + db.y*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, boxDim.xz*0.7)-50.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(10.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.0125*max(db, 0.0));\n  }\n  \n  col += loLightCol1 * pow(ld1, 10.0);\n  col += hiLightCol1 * pow(ld1, 800.0);\n  col += loLightCol2 * pow(ld2, 10.0);\n  col += hiLightCol2 * pow(ld2, 800.0);\n\n  return col;\n}\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor3(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.00125/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float tp = mod(TIME, PERIOD);\n  float np = mod(floor(TIME/PERIOD), 3.0);\n  vec3 col;\n  if (np == 0.0) {\n    col = skyColor1(ro, rd);\n  } else if (np == 1.0) {\n    col = skyColor2(ro, rd);\n  } else {\n    col = skyColor3(ro, rd);\n  }\n  \n  return col*smoothstep(0.25, 1.0, tp)*smoothstep(PERIOD-0.25, PERIOD-1.0, tp);\n}\n\n\nvec3 color(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  \n  mat3 rot = \n    rot_x(0.25*TIME)\n    *rot_y(0.33*TIME)\n    *rot_z(0.45*TIME)\n    ;\n  mat3 irot = transpose(rot);\n  \n  vec3 bro = rot*ro;\n  vec3 brd = rot*rd;\n  \n  float bi = raySphere4(bro, brd, 3.0);\n  \n  if (bi > -1.0) {\n    \n    vec3 bp = bro + bi*brd;\n    vec3 bn = normalSphere4(bp);\n    vec3 p = irot*bp;\n    vec3 n = irot*bn;\n    vec3 r = reflect(rd, n);\n    float bf = 1.0+dot(rd,n);\n    float fre = bf;\n    fre *= fre;\n    vec3 rsky = SKYCOLOR(p, r);\n    vec3 col = mix(0.125, 1.0, fre)*rsky;\n    float rdif = dot(-rd, n);\n    rdif *= rdif;\n    col += 0.25*mix(0.0125, 0.05, rdif)*vec3(1.0);\n    return mix(skyCol, col, smoothstep(1.0, 0.85, bf));\n  }\n  \n  return skyCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 3.0, 7.0);\n  ro.xz *= ROT(0.125*TIME);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float fov = tan(TAU/6.0);\n  vec2 np = p + vec2(aa); \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n\n  vec3 col = color(ro, rd);;\n\n  fragColor = vec4(sRGB(col), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 434, 455, 455, 528], [529, 629, 651, 651, 700], [854, 854, 876, 876, 1022], [1166, 1226, 1254, 1274, 1350], [1352, 1352, 1373, 1373, 1473], [1475, 1475, 1496, 1496, 1596], [1598, 1598, 1619, 1619, 1722], [1724, 1724, 1755, 1755, 1781], [1783, 1877, 1904, 1904, 1980], [1982, 2065, 2104, 2104, 2197], [2199, 2230, 2266, 2266, 2360], [2362, 2453, 2519, 2519, 2977], [2979, 3070, 3112, 3112, 3159], [3161, 3252, 3298, 3298, 4100], [4102, 4193, 4226, 4226, 4261], [4263, 4263, 4297, 4297, 5209], [5211, 5211, 5245, 5245, 6987], [6989, 6989, 7010, 7040, 7524], [7526, 7526, 7560, 7560, 8733], [8735, 8735, 8768, 8768, 9087], [9090, 9090, 9120, 9120, 9842], [9844, 9844, 9899, 9899, 10440]]}
{"id": "7dByDG", "name": "rgb circles combining", "author": "MarcoF", "description": "Small fun shader", "tags": ["rgb"], "likes": 3, "viewed": 209, "published": 3, "date": "1644060465", "time_retrieved": "2024-07-30T17:05:11.190378", "image_code": "#define PI 3.14159265359\n\nbool negative = false;\n\nfloat circle(vec2 uv, vec2 position, float radius, float blur)\n{\n\treturn 1.0 - smoothstep(radius - blur, radius + blur, length(uv - position));\n}\n\nvec2 rotate(vec2 original, float angle, vec2 pivot) \n{\n    mat2 rotation  = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 final = original;\n    final -= pivot;\n    final *= rotation;\n    final += pivot;\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// vertical range [-1, +1]\n    vec2 uv = (2.*fragCoord - (fragColor.xy = iResolution.xy) ) / fragColor.y ;\n    \n    vec3 color = vec3(0.0);\n    \n    float t = cos(iTime * 0.5) * .5;\n    \n\tcolor.r = circle(uv, vec2(0., 0. + t), 0.4, 0.01);\n    \n    uv = rotate(uv, 2. * PI / 3., vec2(0.0));\n    \n    color.g = circle(uv, vec2(0., 0. + t), 0.4, 0.01);\n    \n    uv = rotate(uv, 2. * PI / 3., vec2(0.0));\n    \n    color.b = circle(uv, vec2(0., 0. + t), 0.4, 0.01);\n    \n    if (negative) color = 1. - color;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dByDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 114, 114, 195], [197, 197, 251, 251, 437], [439, 439, 496, 524, 1038]]}
{"id": "ssjyDy", "name": "test2: exact floats ( with mod )", "author": "FabriceNeyret2", "description": "left:   mod(int, int ) is not always 0  ( lines ).\nmiddle:  mod(int + 1/pow2 , int ) is always exact ( plain white ). so mod( fragCoords, int ) is ok, good ! \nright:   otherwise it is always not exact (plain black ).", "tags": ["test", "glsl", "mod"], "likes": 6, "viewed": 257, "published": 3, "date": "1644051153", "time_retrieved": "2024-07-30T17:05:11.934389", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float i = floor(3.*U.x/iResolution.x), \n        ofs = i < 1. ? 0. : i < 2. ? .625 : .3;\n        \n    U = floor(U);\n    O = vec4 (mod(U+ofs,U ) == vec2(ofs) );  // test whether mod is exact\n    \n    if ( mod( 3.*U.x, iResolution.x ) < 6. ) O = vec4(0,1,0,1); // separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 315]]}
{"id": "7djyDy", "name": "test: exact floats", "author": "FabriceNeyret2", "description": "integers and their divisions by power of 2 can be stored exactly in floats.\nBut division often breaks this, and thus mod as well ( in particular, 3./3. is not exactly 1 ).\nIf you see a grid of dots, you have exact (1.+z)/(64.+z) and mod(U,3).\nTell me !", "tags": ["test", "glsl"], "likes": 8, "viewed": 316, "published": 3, "date": "1644050435", "time_retrieved": "2024-07-30T17:05:12.686379", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O -= O;\n    float z = min(0.,iTime); // to prevent compile-time optimizations\n    \n    for(float i=z; i<1.-z; i+= (1.+z)/(64.+z) )\n        O += vec4( mod(U,3.) == vec2(i) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 218]]}
{"id": "ssjyDG", "name": "Peripheral Drift Inverse", "author": "copperbotte", "description": "I was curious if the observed speed of the Peripheral Drift illusion, (the Rotating Snakes illusion) can be canceled out by a very slight drift. \nFor me, it appears to move at ~0.002.5 rads/sec.\n\nTunable parameters can be found at line 94.", "tags": ["math", "torus", "illusion"], "likes": 11, "viewed": 337, "published": 3, "date": "1644038535", "time_retrieved": "2024-07-30T17:05:13.428395", "image_code": "\n// The classical optical illusion. Blue background, orange center. +v is +x.\n// UV space is (0,1) in both axes.\nvec3 optical_illusion(in vec2 uv)\n{\n    const vec3 color_bg = vec3(1,0.5,0);\n    const vec3 color_fg = vec3(0,0,1);\n    const vec3 color_forw = vec3(0);\n    const vec3 color_back = vec3(1);\n    const float r_o = 0.9;\n    const float r_i = 0.7;\n    \n    vec2 xy = mod(uv, 1.0) * 2.0 - 1.0;\n    float r2 = dot(xy, xy);\n    float r_o2 = r_o*r_o;\n    float r_i2 = r_i*r_i;\n    \n    // Smoothly interpolate the ifs to prevent branching\n    // Thanks Fabrice!\n    const float dx = 0.05;\n    float r2smooth_out = smoothstep(r_o2-dx, r_o2+dx, r2);\n    float r2smooth_in = smoothstep(r_i2-dx, r_i2+dx, r2);\n\n    float xsmooth = smoothstep(-dx, dx, xy.x);\n    \n    vec3 xcolor = mix(color_back, color_forw, xsmooth);\n    vec3 forecolor = mix(color_fg, xcolor, r2smooth_in);\n    return mix(forecolor, color_bg, r2smooth_out);\n}\n\n// Generate a ray to march\nvoid generate_ray(in vec2 xy, out vec3 rPos, out vec3 rDir)\n{\n    rPos = vec3(0,0,2); // 2 from the center of the torus, right handed coordinates.\n    \n    vec3 dir = vec3(xy, -1);\n    rDir = normalize(dir);\n}\n\n// The torus sdf SHOULD BE the closest point on the tangencial ring?\n// Inputs in world position\nfloat Sdf(in vec3 wPos, in float inner_rad, in float outer_rad)\n{   \n    // Align the world position to the inner ring\n    vec2 rPos = vec2(length(wPos.xz), wPos.y);\n    \n    // Compute the offset from the outer ring\n    rPos -= vec2(outer_rad, 0);\n    \n    //SDF is this distance, offset from inner_rad\n    float sdf = length(rPos) - inner_rad;\n    \n    return sdf;\n}\n\n\n// SDF Raymarch\nvec3 raymarch(in vec3 rPos, in vec3 rDir, in float inner_rad, in float outer_rad)\n{\n    vec3 sPos = rPos;\n    \n    float dir = sign(Sdf(sPos, inner_rad, outer_rad));\n    \n    for(int i=0; i<1000; ++i)\n    {\n        float sdf = Sdf(sPos, inner_rad, outer_rad);\n        sPos += rDir * dir * sdf;\n        if(abs(sdf) < 1e-4)\n            return sPos;\n    }\n    \n    return sPos;\n}\n\n\n// Color each world position according to the location on the torus\nvec3 color_wpos(in vec3 wPos, in float inner_rad, in float outer_rad, in float speed, in vec2 scale)\n{\n    // get the torus angles\n    float phi = atan(wPos.z, wPos.x);\n    float r = length(wPos.xz);\n    float theta = atan(wPos.y, r - outer_rad);\n    \n    phi = phi - speed*iTime;\n    \n    return optical_illusion(scale*vec2(phi, theta)/3.141592);\n}\n\n// Seperate sample function for integration\nvec3 sample_image( in vec2 uv )\n{\n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    /***************************************/\n    /*         Tunable Parameters          */\n    /***************************************/\n    float inner_rad = 0.75;//0.5;//abs(0.9*sin(iTime) + 1.0);//\n    float outer_rad = 2.1 - inner_rad;\n    float speed = 2.5e-3; // radians per second\n    vec2 scale = vec2(25.0, 10.0);\n    \n    vec3 rPos, rDir;\n    generate_ray(xy, rPos, rDir);\n    vec3 sPos = raymarch(rPos, rDir, inner_rad, outer_rad);\n    \n    if(abs(Sdf(sPos, inner_rad, outer_rad)) < 0.01)\n        //col = vec3(length(sPos - rPos)/10.0);\n        col = color_wpos(sPos, inner_rad, outer_rad, speed, scale);\n    \n    // Output to screen\n    return col;\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n \n    const int samples = 4;\n    const float s_f = float(samples);\n \n    for(int i=0; i<samples; ++i)\n    {\n        vec2 rng = vec2(rnd(), rnd()) - 0.5;\n        //vec2 rng = vec2(0);\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord+rng)/iResolution.xy;\n        vec3 C = sample_image(uv);\n        C = pow(C, vec3(2.2));\n        col += C;\n    \n    }\n    \n    col /= s_f;\n    \n    // adjust for srgb color space\n    // rough approx\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 113, 148, 148, 929], [931, 958, 1019, 1019, 1167], [1169, 1266, 1331, 1384, 1634], [1637, 1653, 1736, 1736, 2029], [2032, 2100, 2202, 2230, 2449], [2451, 2495, 2528, 2588, 3353], [3355, 3447, 3460, 3460, 3503], [3505, 3505, 3562, 3562, 4127]]}
{"id": "ss2yDG", "name": "twist ladder", "author": "jorge2017a2", "description": "twist ladder", "tags": ["twistladder"], "likes": 10, "viewed": 249, "published": 3, "date": "1644033034", "time_retrieved": "2024-07-30T17:05:14.248203", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//ref Iq\n///https://www.shadertoy.com/view/7tKSWt\n/// corregido por........ pyBlob\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n///https://www.shadertoy.com/view/7tKSWt\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\n\nfloat opScaleEscalera(vec2 p, vec2 med, float num )\n{\n    float s=0.25;\n    float d1= sdStairs( p/s, med, num )*s;\n    return d1;\n}\n\n///modificado y reparacion por..... pyBlob,\nfloat opBlock(float d2, float z, float r)\n{\n    float d1 = abs(z) - r;\n    return length(max(vec2(d1, d2), 0.)) + min(max(d1, d2), 0.);\n}\n\n///modificado y reparacion por..... pyBlob,\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\t   \n    float planeDist1 = p.y+5.0;  //piso inf\n    float planeDist2 = 45.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+60.0;  //pared frente\n    float planeDist6 = p.z+60.0;  //pared atras\n    \n    res = opU3(res, vec3(planeDist1,100.0,-7.0));\n    res = opU3(res, vec3(planeDist2,100.0,-7.0));\n    res = opU3(res, vec3(planeDist3,100.0,-7.0));\n    res = opU3(res, vec3(planeDist4,100.0,-7.0));\n    \n    p.y = p.y-5.0;\n    \n    vec3 p1 = p; // sup\n    p1.z = opRep1D(p1.z, 30.0);\n\n    vec3 p2 = p; // inf\n    p2.z -= 15.;\n    // opRep only works correctly, when the repeated object is symmetric around the middle of the repetition.\n    // If you want to offset the bottom stairs, the repetition should be separate for top/bottom stairs.\n    p2.z = opRep1D(p2.z, 30.0);\n    \n    float da2 = opScaleEscalera(p1.xy-vec2(7.0,-10.0), vec2(10.0,10.0), 10.0 );\n    float dinter1 = opBlock(da2, p1.z, 5.);\n    res = opU3(res, vec3(dinter1,101.0,-1.0));\n    \n    float db2 = opScaleEscalera(vec2(-p1.x,p1.y)-vec2(7.0,-10.0), vec2(10.0,10.0), 10.0 );\n    float dinter2 = opBlock(db2, p1.z, 5.);\n    res = opU3(res, vec3(dinter2,101.0,-1.0));\n    \n    float dc2 = opScaleEscalera(vec2(-p2.x,-p2.y)-vec2(8.0,-40.0), vec2(10.0,10.0), 10.0 );\n    float dinter3 = opBlock(dc2, p2.z, 5.);\n    res = opU3(res, vec3(dinter3,101.0,-1.0));\n    \n    float dd2 = opScaleEscalera(vec2(p2.x,-p2.y)-vec2(8.0,-40.0), vec2(10.0,10.0), 10.0 );\n    float dinter4 = opBlock(dd2, p2.z, 5.);\n    res = opU3(res, vec3(dinter4,101.0,-1.0));\n\n    return res;\n}\n\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n   float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n    if (i==101 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*vec3(1.0,0.5,0.5); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n         // Exponential distance fog\n        col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 0.5 - exp2(-0.0011 * d *d ));\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/5.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,360.0);\n    itime=t;\n    \n\tlight_pos1= vec3(0.0, 60.0, -25.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, 60.0, 50.0 ); light_color2 =vec3( 1.0,1.0,1.0 );   \n   vec3 ro=vec3(0.0,20.0,0.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(t));\n   rd= rotate_z(rd, radians(t));\n   vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2yDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 583, 615, 615, 699], [701, 745, 792, 792, 819], [820, 820, 863, 863, 890], [891, 891, 939, 939, 967], [968, 1006, 1042, 1042, 1087], [1089, 1114, 1148, 1148, 1244], [1245, 1245, 1279, 1279, 1370], [1371, 1371, 1405, 1405, 1496], [1498, 1498, 1523, 1523, 1542], [1544, 1585, 1638, 1650, 2530], [2533, 2533, 2586, 2586, 2664], [2666, 2710, 2753, 2753, 2847], [2849, 2893, 2918, 2918, 4584], [4587, 4587, 4611, 4611, 4773], [4775, 4775, 4824, 4824, 5455], [5457, 5457, 5493, 5493, 5738], [5740, 5740, 5777, 5777, 6038], [6040, 6040, 6123, 6123, 6696], [6698, 6698, 6747, 6747, 6915], [6917, 6917, 7010, 7010, 7140], [7142, 7142, 7174, 7174, 7371], [7374, 7374, 7467, 7467, 7719], [7722, 7722, 7749, 7749, 7838], [7840, 7840, 7898, 7898, 7946], [7949, 7949, 7972, 7972, 8090], [8092, 8092, 8123, 8123, 8952], [8955, 8955, 9012, 9012, 9496]]}
{"id": "fstSRs", "name": "noise playground2", "author": "gunzes", "description": "jak wyzej cwiczonko kurwa po co mi to kazecie pisac", "tags": ["lalalala"], "likes": 3, "viewed": 238, "published": 3, "date": "1644020749", "time_retrieved": "2024-07-30T17:05:15.067013", "image_code": "//rand(vec2 coord)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y)-vec2(0.888888,0.5);\n    //vec2 uv = (fragCoord/iResolution.y);\n    vec2 uv2 = uv;\n    //zmienne\n    //uv.x += iTime;\n    float czasSin = sin(iTime*.5)*1.;\n    float time = iTime;\n    float rotTime = iTime;\n    time *= .1;\n    rotTime *= .06;\n    \n    vec3 col = vec3(.0);\n    float gridScale = 6.;\n    float noiseStrength =.45;\n    float borderSize = 0.;\n    float color = 1.;\n    float blurStep = 1.;\n    \n    vec2 offset = vec2(.25,.0);\n    \n    //vec2 uv2 = (vec2(uv.x+czas,uv.y))*gridScale;\n    vec2 uvTime1 = (vec2(uv.x+time,uv.y+time)) * gridScale;\n    vec2 uvTime2 = (vec2(uv.x-time,uv.y+time)) * gridScale;\n    vec2 uvTime3 = (vec2(uv.x-time,uv.y-time)) * gridScale;\n    vec2 uvTime4 = (vec2(uv.x+time,uv.y-time)) * gridScale;\n   \n    float noise2d =  noise2D(uvTime1) * noiseStrength *\n                     noise2D(uvTime2) * noiseStrength *\n                     noise2D(uvTime3) * noiseStrength *\n                     noise2D(uvTime4) * noiseStrength ;\n    //noise2d *= time*5.;\n    \n    //czas *= noise2d*.5;\n    float angle = fract(rotTime*.5)*PI*2.;\n    \n    //move square position\n    //uv -= offset*czasSin;\n    //rotation\n    \n    uv *= rotate(angle);\n    uv2 *= rotate(-angle);\n    //move rotation center\n    //uv += 0.2;\n    //col += drawSquare(uv, noise2d * 5. + .036 + borderSize+.02, noise2d * 5.+.01);\n    \n    for (int i = 0; i < 35; i++){\n    \n        uv *= rotate(angle)*.9;\n        uv2 *= rotate(-angle);\n        \n        float square = drawSquare(uv, noise2d * 5. + .05 + borderSize, noise2d * 25.) -\n                       drawSquare(uv, noise2d * 5. + .047 + borderSize, noise2d * blurStep);  \n                       \n        borderSize += .003*((sin(iTime)*.5)+.5);\n        blurStep += .3;\n        \n        col += vec3(square*color);\n        color -= (1./25.)*((sin(iTime)*.5)+.5);\n        //col -= (1./30.*.5);\n        //col -= 1./20.;\n    }\n    \n    //col = 1.-col;\n    col = vec3(pow(col.x,1.5));\n    col *= vec3(2.,1.,1.);\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "/*vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}*/\n#define PI 3.14159265359\n\n//random\n\nfloat rand(vec2 coord){\n    return fract(sin(dot(coord,vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//rotation\n\nmat2 rotate(float angle){\n    \n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n\n}\n\n//noise 1d\n\nfloat noise1D(float cellId, float cellFraction){\n    return clamp(mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),smoothstep(0.,1.,cellFraction)),0.,1.);\n    //return mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),cellFraction);\n    //return rand(vec2(cellId));\n}\n\n//noise2d\n\nfloat noise2D(vec2 coord){\n    vec2 id = floor(coord);\n    vec2 fraction = fract(coord);\n    //4 punkty kwadratu\n    float a = rand(id);\n    float b = rand(id + vec2(1.,0.));\n    float c = rand(id + vec2(0.,1.));\n    float d = rand(id + vec2(1.,1.));\n    \n    //interpolacja\n    vec2 smoothCorners = smoothstep(0.,1.,fraction);\n    //vec2 smoothCorners = fraction*fraction*(3.0-2.0*fraction)\n    \n    //mix kornerow\n    return mix(a,b,smoothCorners.x) +\n           (c - a) * smoothCorners.y * (1.- smoothCorners.x) +\n           (d - b) * smoothCorners.x * smoothCorners.y;\n}\n\n//okrag smooth\n\nfloat drawCircleSmooth(vec2 coord, float borderThickness, float radius, float color){\n\n    return (1.-smoothstep(0.,borderThickness,abs(radius-sqrt(dot(coord,coord)))))*color;\n}\n//dysk\nfloat drawDisc(vec2 coord,float radiusOut){\n    return smoothstep(radiusOut,radiusOut*1.015,length(coord));\n}\n\n//kwadrat smooth\nfloat drawSquare (vec2 coord, float a, float blur){\n    float band1 = smoothstep(a+blur,a-blur,coord.x);\n    float band2 = smoothstep(-a-blur,-a+blur,coord.x);\n    float band3 = smoothstep(a+blur,a-blur,coord.y);\n    float band4 = smoothstep(-a-blur,-a+blur,coord.y);\n    return band1*band2*band3*band4;\n}\n\n\n\n\n\n//float randomNumber      = 43758.5453123;\n//vec2 randomVecNumber    = vec2(12.9898,78.233);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 128, 2194]]}
{"id": "NdjyWy", "name": "Byzantine Biology", "author": "paniq", "description": "A fluidly subdividing reaction/diffusion field. Use the mouse to control the zoom.", "tags": ["scaling", "cellularautomaton"], "likes": 18, "viewed": 477, "published": 3, "date": "1644014833", "time_retrieved": "2024-07-30T17:05:15.872859", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float m = float(iFrame % R) / float(R);  \n    uv -= C;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv / (1.0 + 0.01*dot(uv,uv));\n    uv.x /= iResolution.x / iResolution.y;\n    uv *= exp(mix(log(1.0),log(0.5),m));\n    vec2 uv3 = uv + C;\n    vec2 uv2 = uv + C;\n    vec2 uv1 = uv + C;\n    float r = texture(iChannel0, uv1).r*0.5+0.5;\n    float g = texture(iChannel0, uv2).g*0.5+0.5;\n    float b = texture(iChannel0, uv3).b*0.5+0.5; \n    vec3 col = vec3(r,g,b);\n    float t = iTime / 500.0;\n    col =\n          col.r * pastelizer(t)\n        + col.g * pastelizer(t + 1./3.)\n        + col.b * pastelizer(t + 2./3.);\n    col = col / 1.5;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 rez;\nvec2 fc;\n\nvec3 fetch(int x, int y) {\n    vec2 p = fc + vec2(x,y);\n    return texture(iChannel0, p / rez).rgb;\n}\n\nfloat combine(vec2 p) {\n    p = clamp(p, vec2(-1.0), vec2(1.0))*0.5+0.5;\n    return 1.0 - max(p.x, p.y);\n}\n\nvec4 process(vec2 c) {\n   rez = iChannelResolution[0].xy;\n   fc = c;\n\n    //vec3 p00 = fetch(-2,-2);\n    vec3 p10 = fetch(-1,-2);\n    vec3 p20 = fetch( 0,-2);\n    vec3 p30 = fetch( 1,-2);\n    //vec3 p40 = fetch( 2,-2);\n\n    vec3 p01 = fetch(-2,-1);\n    vec3 p11 = fetch(-1,-1);\n    vec3 p21 = fetch( 0,-1);\n    vec3 p31 = fetch( 1,-1);\n    vec3 p41 = fetch( 2,-1);\n\n    vec3 p02 = fetch(-2, 0);\n    vec3 p12 = fetch(-1, 0);\n    vec3 p22 = fetch( 0, 0);\n    vec3 p32 = fetch( 1, 0);\n    vec3 p42 = fetch( 2, 0);\n\n    vec3 p03 = fetch(-2, 1);\n    vec3 p13 = fetch(-1, 1);\n    vec3 p23 = fetch( 0, 1);\n    vec3 p33 = fetch( 1, 1);\n    vec3 p43 = fetch( 2, 1);\n\n    //vec3 p04 = fetch(-2, 2);\n    vec3 p14 = fetch(-1, 2);\n    vec3 p24 = fetch( 0, 2);\n    vec3 p34 = fetch( 1, 2);\n    //vec3 p44 = fetch( 2, 2);\n\n\n    vec3 corners = p11 + p31 + p13 + p33;\n    vec3 edges = p12 + p32 + p21 + p23;\n\n    vec3 lp = corners + 4. * edges - 20.0 * p22;\n\n    vec3 bilp = p01 + p02 + p03 + p14 + p24 + p34 + p43 + p42 + p41 + p30 + p20 + p10\n        - 2. * corners - 10. * edges + 36.0 * p22;\n\n    float D = 0.0;\n    float dx = 1.0;\n    vec2 d = sin(((fc/rez)*2.0-1.0)*radians(360.0)*1.0)*0.5+0.5;\n    float dt = 0.16 / (max(0.0,2.0 - length(d))*float(R)/60.0);\n    //bilp = bilp / (3.0 * dx * dx * dx * dx);\n    //lp = lp / (6.0 * dx * dx);\n    bilp = bilp / (3.0 * dx);\n    lp = lp / (6.0 * dx);\n\n    vec3 u = p22;        \n\n    float H = 2.0;\n    vec3 mu = mix(vec3(0.5), vec3(2.0), sin((iTime/120.0 + vec3(0,1,2)/3.)*radians(360.0))*0.5+0.5);\n    vec3 beta = (vec3(combine(u.yz),combine(u.xz),combine(u.xy))*2.0-1.0)*0.5;\n\n    vec3 du = mu*u - bilp - 2.*lp - u + beta*u*u - u*u*u;\n\n    vec3 res = u + du*dt;\n    \n    // combined average\n    float k = (res.x + res.y + res.z) / 3.0;\n\n    return vec4(mix(res, vec3(k), vec3(0.01)),0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = iMouse.xy / iResolution.xy;\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;        \n        uv.x *= iResolution.x / iResolution.y;\n        float c0 = length(uv) - 0.5;\n        float c1 = length(uv - vec2(0.0,0.25));\n        float c2 = length(uv - vec2(0.0,-0.25));\n        float d = max(min(max(c0, -uv.x),c1-0.25),-c2+0.25);        \n        d = max(d, -c1+0.07);\n        d = min(d, c2-0.07);\n        d = min(d, abs(c0)-0.01);\n        float w = sign(d) * sin(c0*80.0);\n        vec3 h = pastelizer(atan(uv.y, uv.x)/radians(360.0))*2.0-1.0;\n        fragColor = vec4(h*w,0.0);\n    } else if ((iFrame % R) == 0) {\n        vec2 c = vec2(fragCoord / iResolution.xy);\n        fragColor = texture(iChannel0, (c - C) / 2.0 + C);\n    } else {\n        vec4 s = process(fragCoord);\n        fragColor = clamp(s, -1.0, 1.0);\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int R = 60 * 4;\n\nvec3 pastelizer(float h) {\n    h = fract(h + 0.92620819117478) * 6.2831853071796;\n    vec2 cocg = 0.25 * vec2(cos(h), sin(h));\n    vec2 br = vec2(-cocg.x,cocg.x) - cocg.y;\n    vec3 c = 0.729 + vec3(br.y, cocg.y, br.x);\n    return c * c;\n}\n\n//const vec2 C = vec2(0.5, 0.0);\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 828]]}
{"id": "fd2yDG", "name": "twisty twirl", "author": "codebender", "description": "some weird thing I made (the name is kinda stupid yeah)\n\nno interaction - just watch", "tags": ["distortion", "weird", "twirl"], "likes": 17, "viewed": 336, "published": 3, "date": "1644011842", "time_retrieved": "2024-07-30T17:05:16.707627", "image_code": "\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** RANDOM **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n// ***********************************************************************************\n// ***********************************************************************************\n// *********************************** PERLIN NOISE **********************************\n// ***********************************************************************************\n// ***********************************************************************************\n\n\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\n\n\n\n\n\n#define noiseTwistingIntensity 1.\n#define noiseTwistingDistanceFactor 60.\n#define noiseTwistingSpeedFactor .4\n\n#define twistingSpeedFactor .3\n\n#define movementSpeedFactor 3.\n\n#define numSegments 5\n\n\nconst float M_PI = 3.1415;\nconst float M_PI_DOUBLE = 6.2831;\n\n\nvec2 applyRotation(vec2 base, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(base.x*c-base.y*s, base.x*s+base.y*c);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = fragCoord.xy/iResolution.y;\n    uv = iResolution.xy/iResolution.y/2. + applyRotation(uv.xy - iResolution.xy/iResolution.y/2., distance(uv.xy, iResolution.xy/iResolution.y/2.)*2.+cnoise(vec3(distance(uv.xy, iResolution.xy/iResolution.y/2.)*noiseTwistingDistanceFactor-iTime*movementSpeedFactor, 0., iTime*noiseTwistingSpeedFactor))*noiseTwistingIntensity+iTime*twistingSpeedFactor);\n    \n    float opacity = 0.;\n    \n    float vignette;\n    for (int i = 0; i < numSegments; i += 1) {\n        if (atan(uv.y - 1./2., uv.x - iResolution.x/iResolution.y/2.)/M_PI*180. > float(i*(360/numSegments)-180) && atan(uv.y - 1./2., uv.x - iResolution.x/iResolution.y/2.)/M_PI*180. < float((i+1)*(360/numSegments)-180)) {\n            vignette = (fragCoord.x/iResolution.x)*(fragCoord.y/iResolution.y)*(1.-fragCoord.x/iResolution.x)*(1.-fragCoord.y/iResolution.y)*15.;\n            opacity = float(i)/float(numSegments-1)*vignette+random(fragCoord.xy/2.)*.2;\n        }\n    }\n    \n    vec4 color;\n    color = vec4(opacity);\n   \n    fragColor = color;\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2yDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 457, 457, 564], [1006, 1006, 1027, 1027, 1064], [1065, 1065, 1092, 1092, 1140], [1141, 1141, 1160, 1160, 1196], [1197, 1197, 1218, 1218, 3490], [3760, 3760, 3804, 3804, 3913], [3916, 3916, 3971, 3971, 5025]]}
{"id": "sdSyDG", "name": "Architecture", "author": "FabriceNeyret2", "description": "trying to reproduce https://twitter.com/lefredj/status/1480190630647287811", "tags": ["simulation", "particles", "short", "reproduction"], "likes": 23, "viewed": 448, "published": 3, "date": "1644000052", "time_retrieved": "2024-07-30T17:05:17.522448", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 U = ( 2.*u - R ) / R.y;\n    O-=O;\n#if 1                                                   // 3D view\n    U.y ++;\n    U *= 25. * mat2(1,1.3,-1,1.3)/2.7 ; // = inverse(mat2(2,-2,1,1))\n#else                                                   // top view\n    U = 15.*U + 10.;\n#endif\n    for( float d = .125, z= .5; z < 7.; z+=d, U-=d ) if( T(U).w >= z ) // optional stacks\n      {\n        if ( min(U.x,U.y)> 0. && max(U.x,U.y) < 20. ) { // === draw terrain\n            O = hue( T(U).w/8. ); \n#if 0                                                   // look = plain + shadowed\n            if ( fract(z-.5) > 0. ) O *= .5;\n#else                                                   // look = block cells\n            vec2 A = .5+.5*smoothstep(0.,-60./R.y,abs(fract(U)*2.-1.)-1.); \n            O *= min(A.x,A.y);                          // cells borders\n#endif\n        }\n        if ( fract(z-.5) < .1 && floor(z) == floor(T(U).w) ) // ( if stacks )\n          for( int i=0; i<7; i++)                       // === draw partics\n            O -= smoothstep(45./R.y,0., length(U-T(vec2(i,20)).xy) - .2);\n      }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === manage particles and terrain ==========================\n//  terrain (20x20) : O.w  = height ( i.e. id of partic field )\n//  partics ( 7x1 ) : O.xy = P, O.zw = V  \n\n#define hash(p)  fract(sin((p)* vec2(12.9898, 78.233) -iDate.w) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                          // previous state\n // if ( iFrame%4 > 0 ) return;                        // to slow down\n    if (u.y==20.5 && u.x<7.) {                         // === particles\n       vec2 P = O.xy;                                  // prev location\n       O.xy = P + O.zw;                                // particle move\n       if ( T(O.xy).w != u.x || min(O.x,O.y)<0. || max(O.x,O.y)>20. ) // goes out of level:\n           O.xy -= .5*O.zw,\n           floor(P.x+O.z)-floor(P.x) == 0. ? O.w = - O.w : O.z = -O.z,// bounce\n           O.xy += .5*O.zw;\n         \n       if (iFrame < 1) {                               // init partics\n           vec2 D = sign(hash(u.x)-.5); \n           O = vec4(u.xx-.25*D.yx,.125*D);             // normal speed = .5*D\n       }\n    } \n    if( max(u.x,u.y) > 20.) return;                    // === terrain\n    for( float i=.5; i<7.; i++ ) {                     // if we are where partic gone out of field\n        vec4 P = T(vec2(i,20));\n        if ( O.w != i && floor(u) == floor(P.xy+P.zw) ) O.w = i; // then extend field\n    }   \n    if (iFrame < 1) u = abs(u-10.),                    // init terrain\n                    O.w = min(6.5, 10. - max(u.x,u.y));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 1212]]}
{"id": "sdSyWG", "name": "AM Sin waves - Sound ", "author": "gfy_9001", "description": "AM Sin waves", "tags": ["amsinwaves"], "likes": 3, "viewed": 248, "published": 3, "date": "1643987865", "time_retrieved": "2024-07-30T17:05:18.268454", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord / (iResolution.xy * 0.25);\n    \n    float p = bpm2ms(128.);\n    float b0 = p * 0.002;\n    float b1 = p * 0.00005;\n    float b2 = p * 0.55 * zero2one(sin(iTime));\n    \n    float a0 = SinMod(iTime, b0, 0., 1.);\n    float a1 = SinMod(iTime, b1, 0., 1.);\n    float a2 = SinMod(iTime, b2, 0., 1.);\n    \n    float a = a0 * a1 * a2;\n    float s = SinMod(iTime, a, 0., 1.);\n    \n    // visualise a2, the most prominent sin you can hear\n    vec3 col = cos(a2 + uv.xyx + vec3(0,2,4));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "float Amp(float a)\n{\n    return a * 0.1;\n}\n\nfloat SinWave(float f, float a, float t)\n{\n    return Amp(a) * sin(2. * PI * f * t);\n}\n\nvec2 mainSound(in int samp, float t)\n{\n    float p = bpm2ms(128.);\n    float f = 440.;\n    \n    float b0 = p * 0.002;\n    float b1 = p * 0.00005;\n    float b2 = p * 0.55 * zero2one(sin(t));\n    \n    float a0 = SinMod(t, b0, 0., 1.);\n    float a1 = SinMod(t, b1, 0., 1.);\n    float a2 = SinMod(t, b2, 0., 1.);\n    \n    float vol = 0.3;\n    float s = (a0 * a1 * a2) * SinWave(f, vol, t);\n    \n    return vec2(s);\n}", "sound_inputs": [], "common_code": "#define PI 3.1415926536\n\nfloat zero2one(float x)\n{\n    return (x - -1.) / (1. - -1.);\n}\n\nfloat bpm2ms(float bpm)\n{\n    float min_in_ms = 60000.0;\n    float beat_ms = (min_in_ms / bpm) / 1000.0;\n    return beat_ms;\n}\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = (2. * PI) / b;\n    return sin(p * (x + c)) + d;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 599]]}
{"id": "NsSyDy", "name": "distgrad test", "author": "yasuo", "description": "Experimented with the following gradient distance functions.\nhttps://iquilezles.org/articles/distgradfunctions2d/distgradfunctions2d.htm", "tags": ["gradient", "reproduction"], "likes": 15, "viewed": 274, "published": 3, "date": "1643986527", "time_retrieved": "2024-07-30T17:05:19.071307", "image_code": "// thx iq! https://iquilezles.org/articles/distgradfunctions2d\n\n#define R(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define a(n) n/min(iResolution.y,iResolution.x)\n#define S(p,d,b)smoothstep(a(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define BASE_COLOR vec3(0.7,0.3,0.3)\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    p*=0.3;\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x)?a:b;\n}\n\nvec3 sdgSmoothMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    return vec3( min(a.x,  b.x) - m, \n                 mix(a.yz, b.yz, (a.x<b.x)?n:1.0-n) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvec3 monogramShape1(vec2 p){\n    p.y*=0.8;\n    vec3 d = sdgCircle(p-vec2(0.025,0.0),0.05);\n    vec3 d2 = sdgCircle(p+vec2(0.025,0.0),0.05);\n    d.x = max(d2.x,d.x);\n    return vec3(d.x,d.yz+d2.yz);\n}\n\nfloat monogramShapeMask(vec2 p){\n    p.y*=0.8;\n    float d = length(p-vec2(0.025,0.0))-0.05;\n    float d2 = length(p+vec2(0.025,0.0))-0.05;\n    return max(d2,d);\n}\n\nvec3 monogramIcon1(vec2 p, vec3 col){\n    p*=R(radians(-iTime*12.0));\n    vec2 prevP = p;\n    p*=R(radians(45.0));\n    p = abs(p)-0.037;\n    float d = length(p)-0.04;\n    d = max(-(length(prevP)-0.025),d);\n    p = prevP;\n    vec3 mask = sdgCircle(p,0.11);\n    mask.x = max(-d,mask.x);\n    \n    col = mix(col,vec3(mask.yz,1.)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,mask.x,0.0));\n    return col;\n}\n\nvec3 monogramIcon2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y = abs(p.y)-0.05;\n    vec3 d = monogramShape1(p);\n    d.x = max(-(length(prevP)-0.015),d.x);\n    col = mix(col,vec3(d.yz,1.)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,d.x,0.0));\n    p = prevP;\n    \n    p.x = abs(p.x)-0.05;\n    p*=R(radians(90.0));\n    d = monogramShape1(p);\n    \n    d.x = max(-(length(prevP)-0.015),d.x);\n    \n    col = mix(col,vec3(d.yz,1.)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,d.x,0.0));\n    return col;\n}\n\nvec3 monogramIcon3(vec2 p, vec3 col){\n    p*=R(radians(iTime*10.0));\n    vec2 prevP = p;\n    \n    p.y = abs(p.y)-0.05;\n    float maskD = monogramShapeMask(p);\n    \n    p = prevP;\n    \n    p.x = abs(p.x)-0.05;\n    p*=R(radians(90.0));\n    float d2 = monogramShapeMask(p);\n    \n    maskD = min(d2,maskD);\n    \n    p = prevP;\n    p*=R(radians(45.0));\n    vec3 d = sdgBox(p,vec2(0.1));\n    p.y=abs(p.y)-0.38;\n    float maskD2 = length(p)-0.3;\n    d.x = max(-maskD2,d.x);\n    p = prevP;\n    p*=R(radians(45.0));\n    p.x=abs(p.x)-0.38;\n    maskD2 = length(p)-0.3;\n    d.x = max(-maskD2,d.x);\n    \n    d.x = max(-maskD,d.x);\n    \n    col = mix(col,vec3(d.yz,0.5)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,d.x,0.0));\n    \n    p = prevP;\n    \n    d = sdgCircle(p,0.015);\n    col = mix(col,vec3(d.yz,0.5)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,d.x,0.0));\n    \n    return col;\n}\n\nvec3 lvlogo(vec2 p, vec3 col){\n    vec2 prevP = p;\n    vec3 d = sdgBox(p-vec2(0.0,0.18),vec2(0.06,0.02));\n    p*=R(radians(25.0));\n    vec3 d2 = sdgBox(p-vec2(-0.065,0.0),vec2(0.025,0.15));\n    \n    d = sdgSmoothMin(d,d2,0.03);\n    p = prevP;\n    \n    d2 = sdgBox(p-vec2(-0.02,-0.12),vec2(0.16,0.025));\n    d = sdgSmoothMin(d,d2,0.03);\n    \n    p*=R(radians(25.0));\n    d2 = sdgBox(p-vec2(0.16,-0.02),vec2(0.015,0.05));\n    d = sdgSmoothMin(d,d2,0.03);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.135;\n    d2 = sdgBox(p-vec2(0.0,0.23),vec2(0.05,0.02));\n    d = sdgMin(d,d2);\n    p = prevP;\n    \n    p*=R(radians(-25.0));\n    d2 = sdgBox(p-vec2(-0.03,0.1),vec2(0.025,0.16));\n    p = prevP;\n    d = sdgSmoothMin(d,d2,0.015);\n    \n    p*=R(radians(25.0));\n    d2 = sdgBox(p-vec2(0.03,0.1),vec2(0.015,0.16));\n    d = sdgSmoothMin(d,d2,0.02);\n    p = prevP;\n    d.x = max(-B(p-vec2(0.0,-0.08),vec2(0.05,0.01)),d.x);\n    \n    col = mix(col,vec3(d.yz,0.5)*BASE_COLOR*noise3d(vec3(p,1.0)*300.0)*1.25,S(prevP,d.x,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    p.y+=iTime*0.1;\n    \n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.5,0.2,0.1)*noise3d(vec3(p,p.x)*1000.0)*2.5;\n    p.y-=0.4;\n    p = mod(p,0.8)-0.4;\n    col = monogramIcon1(p,col);\n    p = prevP;\n    p = mod(p,0.4)-0.2;\n    col = monogramIcon2(p,col);\n    p = prevP;\n    p = mod(p,0.8)-0.4;\n    col = monogramIcon3(p,col);\n    p = prevP;\n    p-=0.4;\n    p = mod(p,0.8)-0.4;\n    col = monogramIcon3(p,col);\n    p = prevP;\n    \n    p-=0.8;\n    p.x-=0.4;\n    p.y+=0.04;\n    p = mod(p,0.8)-0.4;\n    p*=1.3;\n    col = lvlogo(p,col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 398, 423, 423, 725], [727, 727, 764, 764, 792], [794, 794, 849, 849, 1035], [1037, 1037, 1079, 1079, 1135], [1137, 1137, 1174, 1174, 1435], [1437, 1437, 1465, 1465, 1636], [1638, 1638, 1670, 1670, 1801], [1803, 1803, 1840, 1840, 2210], [2212, 2212, 2249, 2249, 2725], [2727, 2727, 2764, 2764, 3615], [3617, 3617, 3647, 3647, 4642], [4644, 4644, 4701, 4701, 5327]]}
{"id": "NdSyDy", "name": "FM Sin waves - Sound", "author": "gfy_9001", "description": "FM Sin waves", "tags": ["sound"], "likes": 3, "viewed": 230, "published": 3, "date": "1643986415", "time_retrieved": "2024-07-30T17:05:19.813323", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = 40. * 0.05;\n    float cf = 1. / f;\n    \n    float p = SinMod(iTime, cf, 0., 1.);\n    float s = SinMod(iTime, p, 0., 1.);\n    \n    vec3 modCol = sin(s) * vec3(0,2,4);\n    \n    vec2 uv = fragCoord / (iResolution.xy * 0.1);\n    vec3 col = cos(s+uv.xyx + modCol);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "float Amp(float a)\n{\n    return a * 0.1;\n}\n\nfloat SinWave(float f, float a, float t)\n{\n    return Amp(a) * sin(2. * PI * f * t);\n}\n\nvec2 mainSound(in int samp, float t)\n{\n    float f = 40.;\n    float cf = 1. / f;\n    \n    float p = SinMod(t, cf, 0., 1.);\n    float s = SinWave(p, 0.3, t);\n    \n    return vec2(s);\n}", "sound_inputs": [], "common_code": "#define PI 3.1415926536\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = (2. * PI) / b;\n    return sin(p * (x + c)) + d;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 369]]}
{"id": "fsBcDG", "name": "Spherical Spiral Net 1 b", "author": "FabriceNeyret2", "description": "mouse controls camera\nreproducing https://twitter.com/smjtyazdi/status/1464690994411151360\n( but I didn't deform the right base shape. stay tuned :-D ).", "tags": ["raymarching", "short", "reproduction"], "likes": 34, "viewed": 400, "published": 3, "date": "1643985177", "time_retrieved": "2024-07-30T17:05:20.620167", "image_code": "// variant of https://shadertoy.com/view/NdByzd\n\n#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )// rotation 3D\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))            // rotation 2D\n\n#define cone(A) atan( length(q-dot(q,A)*A) , dot(q,A) )       // angle between q and axe A\n#define T(A)    7.*sin(iTime) *sign(dot(q,A))                 // amplitude of torsion\n#define S(A)  rot3(q, A, T(A)* smoothstep(.14,1.,exp(-3.*cone(A) ) )) // distortion\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., s,c; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n        a = abs(q);\n        q = S(sign(q)/sqrt(3.));                              // distortion along corner axis\n        a = abs(q); \n#define K(x,y,z) if ( min(a.y,a.z) > a.x ) s = min( abs(q.y-q.z),abs(q.y+q.z))\n        K(x,y,z); \n        K(y,z,x);\n        K(z,x,y);\n        t = min( min(t ,c=length(q)-.3),                      // small sphere\n                 s = max( length(q)-1.2, s ) ),               // 3 planes inter big sphere\n   \n       p += .2*t*D;                                           // step forward = dist to obj          \n   }                                                          // --- color scheme\n   if (t==s) O.rgb *= 1.3* step(a, min(a.xxx,min(a.y,a.z)));  // planes color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[476, 476, 512, 512, 1724]]}
{"id": "sd2czd", "name": "Glowing Hyperboloid", "author": "mla", "description": "From a concept by @oneshade: [url]https://www.shadertoy.com/view/fdjczd[/url] - and using the line calculations from that shader.", "tags": ["star", "festive", "pentagram"], "likes": 11, "viewed": 429, "published": 3, "date": "1643968394", "time_retrieved": "2024-07-30T17:05:21.384123", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Glowing Hyperboloid, Matthew Arcus, mla, 2022\n// Inspired by, and uses code from https://www.shadertoy.com/view/fdjczd\n// by @oneshade\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 50; // Number of lines\nconst float scale = 1.0;\nconst float CAMERA = 6.0;\nconst float A = 0.1; // Light amplitude\nconst float K = 6.0; // Exponental falloff\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\n#define sin(x) sin(mod((x),TWOPI))\n#define cos(x) cos(mod((x),TWOPI))\n\nfloat det(vec2 c0, vec2 c1) {\n  return determinant(mat2(c0,c1));\n}\n\n// Given lines p+kq and r+js, points\n// u = p+kq, v = r+js are closest if\n// q.(u-v) = 0 = s.(u-v) (ie. the line\n// between them is orthogonal to both lines).\n// Expanding out gives a linear system to\n// solve for k and j.\nvec2 closest0(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Use Cramer's rule to solve linear system\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  // No cross products, 4 dot products, 3 2x2 determinants\n  vec2 c0 = vec2(1.0,dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-1.0);\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  return vec2(det(a,c1),det(c0,a))/det(c0,c1);\n}\n\n// return vec2(k,j) such that p + kq and\n// r + js are closest points on lines\n// Assumes q and s are normalized\nvec2 closest1(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  mat2 m = mat2(1.0,dot(q,s),-dot(q,s),-1.0);\n  return inverse(m)*vec2(dot(r-p,q),dot(r-p,s));\n}\n\n// Nice \"geometric\" solution from Wikipedia.\n// Probably not as fast as Cramer's rule,\n// 3 cross products, 4 dot products & a normalize\nvec2 closest2(vec3 p,vec3 q,vec3 r,vec3 s) {\n   vec3 n = normalize(cross(q,s));\n   vec3 n1 = cross(q,n); \n   vec3 n2 = cross(s,n);\n   return vec2(dot(r-p,n2)/dot(q,n2),\n               dot(p-r,n1)/dot(s,n1));\n}\n\nvec2 closest3(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  float k = dot(q,s);\n  mat2 m = mat2(-1.0,-k,k,1.0);\n  return m*vec2(dot(r-p,q),dot(r-p,s))/(k*k-1.0);\n}\n\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  return closest3(p,q,r,s);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\n// Quaternion to rotation matrix, assumes normalized\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z;\n  float xy = x*y, xz = x*z, xw = x*w;\n  float yz = y*z, yw = y*w, zw = z*w;\n  return 2.0*mat3(0.5-y2-z2, xy+zw, xz-yw,\n                  xy-zw, 0.5-x2-z2, yz+xw,\n                  xz+yw, yz-xw, 0.5-x2-y2);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  vec3 p = vec3(0,0,-CAMERA);\n  vec3 q = vec3(xy,2);\n  p = transform(p);\n  q = transform(q);\n  q = normalize(q);\n  \n  // r+js is polygon line, to be rotated in loop\n  vec3 r = vec3(0,1,0);\n  vec3 s = vec3(1,0,0);\n  // Rotation axis\n  vec3 axis = normalize(vec3(1,1,cos(0.1*iTime)));\n  float phi = iTime*0.15;\n  mat3 n = qrot(vec4(sin(phi)*axis,cos(phi)));\n  p = n*p; q = n*q;\n  float mindist = 1e10;\n  vec3 color = vec3(0); // Accumulate color here\n  float len = 2.0;\n  float twist = sin(0.25 * iTime) * PI / 2.0;\n\n  // Convert twist angle to a rotation matrix\n  float co = cos(twist), si = sin(twist);\n  mat2 rot = mat2(co, -si, si, co);\n\n  // Calculate height to keep line length constant\n  float chord = 2.0 * sin(twist);\n  float halfHeight = sqrt(len * len - chord * chord) / 2.0;\n  for (int i = 0; i < N; i++) {\n    float a = TWOPI*float(i)/float(N);\n    vec3 p1 = vec3(cos(a), -halfHeight, sin(a));\n    vec3 p2 = vec3(p1.x, halfHeight, p1.z);\n\n    p1.xz *= transpose(rot); // Rotate in opposite direction\n    p2.xz *= rot;\n    vec3 r = 0.5*(p1+p2), s = normalize(p1-p2);    \n    vec2 k = closest(p,q,r,s);\n    if (k.x > 0.0) {\n      vec3 p0 = p+k.x*q;\n      vec3 r0 = r+k.y*s;\n      float d = distance(p0,r0);\n      float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n      vec3 basecolor = h2rgb(h);\n      color += A*exp(-K*d)*basecolor;\n    }\n  }\n  color = pow(color,vec3(0.4545));\n  outColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2czd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 600, 629, 629, 666], [668, 891, 935, 1109, 1264], [1266, 1379, 1423, 1492, 1589], [1591, 1728, 1772, 1772, 1937], [1939, 1939, 1983, 2052, 2158], [2160, 2160, 2203, 2203, 2233], [2235, 2330, 2351, 2351, 2497], [2499, 2552, 2571, 2571, 2861], [2863, 2863, 2893, 2893, 2943], [2945, 2945, 2972, 2972, 3203], [3205, 3205, 3256, 3256, 4768]]}
{"id": "sd2cRd", "name": "odos | spiral", "author": "ErinZ", "description": "today’s shader--learn to draw a spiral.\nrefers to https://www.shadertoy.com/view/4tBXRy \n         & https://www.shadertoy.com/view/MtSXW1", "tags": ["spiral"], "likes": 3, "viewed": 316, "published": 3, "date": "1643967496", "time_retrieved": "2024-07-30T17:05:22.125142", "image_code": "#define PI 3.1415926\n//original version:https://www.shadertoy.com/view/MtSXW1\n//with aa: https://www.shadertoy.com/view/4tBXRy\n\n\nfloat logo(vec2);\n\n//https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float a =atan(uv.y,uv.x);//angle -Pi~Pi\n    float w = 1.5;//width \n    float r = length(uv/w);    \n    \n    vec4 m = vec4(fract(vec3(0,1,2)/3.+ a/2./PI + r - iTime/8. ),0);\n    m.w = m.x; //w records min(x,y,z)\n    m.x=0.;//x records which pieces does this pix belong to\n    if(m.y < m.w){m.w = m.y; m.x = .33;}\n    if(m.z < m.w){m.w = m.z; m.x = .67;}\n    m.w = min(m.w, m.w*(1. - m.w)*iResolution.y*w/(1. + .16/r));//AA\n\n    \n    \n    vec3 col = m.w*\n          pal( r/3.+ m.x +iTime/12., \n                  vec3(0.9,0.7,0.4),\n                  vec3(0.8,0.2,0.9),\n                  vec3(1.0,1.0,1.0),\n                  vec3(0.0,0.3,0.6) );\n          \n    col = clamp(col,0.,1.);\n    col += logo(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2cRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 191, 259, 259, 302], [304, 304, 361, 361, 1184], [1241, 1241, 1261, 1261, 1650]]}
{"id": "7djczd", "name": "My First Pathtraced Scene", "author": "oneshade", "description": "Following @demofox's first tutorial: [url=https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/]https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/[/url]", "tags": ["globalillumination", "pathtracer", "stochastic"], "likes": 41, "viewed": 722, "published": 3, "date": "1643966767", "time_retrieved": "2024-07-30T17:05:22.879126", "image_code": "// Based on https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\n// https://64.github.io/tonemapping/#uncharted-2\nvec3 Uncharted2(in vec3 color) {\n    color *= 2.0;\n\n    float A = 0.15, B = 0.50, C = 0.10;\n    float D = 0.20, E = 0.02, F = 0.30;\n    color = (((A * color + C * B) * color + D * E) / ((A * color + B) * color + D * F)) - E / F;\n\n    //float whiteMax = 4.0;\n    //color /= (((A * whiteMax + C * B) * whiteMax + D * E) / ((A * whiteMax + B) * whiteMax + D * F)) - E / F;\n    color *= 1.9335;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb /= fragColor.a; // Average\n    fragColor.rgb = Uncharted2(fragColor.rgb); // Tonemap\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545)); // Gamma correct\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings\n#define MAX_BOUNCES 16\n#define EPSILON 0.001\n\n// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    float hitDist;\n    vec3 hitPos;\n    vec3 surfNor;\n    vec2 surfUv;\n    int objId;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n};\n\n// RNG utilities\nuint wangHash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n \nvec3 randUnitVec(inout uint state) {\n    float z = rand01(state) * 2.0 - 1.0;\n    float a = rand01(state) * TAU;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Camera basis matrix\nmat3 getCameraBasis(in vec2 an) {\n    vec2 c = cos(an), s = sin(an);\n    return mat3(       c.x, 0.0,        s.x,  // Right\n                s.x * -s.y, c.y,  c.x * s.y,  // Up\n                 s.x * c.y, s.y, -c.x * c.y); // Forward\n}\n\n// Update with closest intersection\nvoid addRayHit(inout HitInfo curHit, in HitInfo newHit) {\n    if (newHit.hitDist > 0.0) {\n        if (curHit.hitDist < 0.0) curHit = newHit;\n        else if (newHit.hitDist < curHit.hitDist) curHit = newHit;\n    }\n}\n\n// Transformations\nmat4 Translate(in vec3 t) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\nmat4 Scale(in vec3 s) {\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateX(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0,  co,  si, 0.0,\n                0.0, -si,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateY(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co, 0.0,  si, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -si, 0.0,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateZ(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co,  si, 0.0, 0.0,\n                -si,  co, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// Primitive intersectors\n// Ray vs. Plane intersection\nHitInfo planeIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float hitDist = -ray.pos.y / ray.dir.y;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = transpose(matInv)[1].xyz; // To worldspace\n    vec2 surfUv = hitPos.xz;\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // To worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}\n\n// Ray vs. Cube intersection\n// TODO: account for inside intersections\n// https://www.shadertoy.com/view/ld23DV\nHitInfo cubeIsect(in Ray ray, in mat4 mat, in int objId)  {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    vec3 n = ray.pos / ray.dir, k = 1.0 / abs(ray.dir);\n    vec3 t1 = -k - n, t2 =  k - n;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\t\n    if (tN > tF || tF < 0.0) return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    vec3 hitPos = ray.pos + ray.dir * tN;\n    vec3 surfNor = -sign(ray.dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    vec2 surfUv = abs(surfNor.z) > 0.5 ? hitPos.xy : abs(surfNor.y) > 0.5 ? hitPos.xz : hitPos.yz;\n    surfNor = (transpose(matInv) * vec4(surfNor, 0.0)).xyz; // Convert normal to worldspace\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // Convert position to worldspace\n\n    return HitInfo(tN, hitPos, surfNor, surfUv, objId);\n}\n\n// Ray vs. Sphere intersection\nHitInfo sphereIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - 1.0;\n\n    float dis = b * b - a * c;\n    if (dis < 0.0) return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    float hitDist = (-b - sign(c) * sqrt(dis)) / a;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = (transpose(matInv) * vec4(hitPos, 0.0)).xyz; // Convert normal to worldspace\n    vec2 surfUv = vec2(atan(hitPos.z, hitPos.x), atan(hitPos.y, length(hitPos.xz)));\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // Convert position to worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}\n\n// Ray vs. Bilinear Patch intersection\nbool bound01(in float x) { return x > 0.0 && x < 1.0; }\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nHitInfo patchIsect(in Ray ray, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in int objId) {\n    vec2 m = ray.dir.yz / ray.dir.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 ip = p.yz - p.x * m, iq = q.yz - q.x * m, ir = r.yz - r.x * m;\n    vec2 ia = (a.yz - ray.pos.yz) - (a.x - ray.pos.x) * m;\n\n    // Reversed coefficients (solving for 1/x seems most stable)\n    float qa = cross2D(ia, iq);\n    float qb = cross2D(ia, ip) + cross2D(ir, iq);\n    float qc = cross2D(ir, ip);\n\n    float dis = qb * qb - 4.0 * qa * qc;\n    if (dis > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(dis) - qb);\n        vec2 u = -(ia.x + ir.x * v) / (ip.x * v + iq.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ray.pos.x) / ray.dir.x;\n\n        // Choose closest intersection in the patch\n        vec3 near = vec3(u.x, v.x, t.x);\n        if (t.y > 0.0 && bound01(u.y) && bound01(v.y)) {\n            if (t.x > 0.0 && bound01(u.x) && bound01(v.x)) { if (t.y < t.x) near = vec3(u.y, v.y, t.y); }\n            else near = vec3(u.y, v.y, t.y);\n        }\n\n        if (near.z > 0.0 && bound01(near.x) && bound01(near.y)) {\n            vec3 hitPos = ray.pos + ray.dir * near.z;\n            vec3 surfNor = cross(p * near.y + q, p * near.x + r); // cross(dp/du, dp/dv)\n            return HitInfo(near.z, hitPos, surfNor, near.xy, objId);\n        }\n\n        else return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1); // Blank\n    }\n\n    return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1); // Blank\n}", "buffer_a_code": "HitInfo traceRay(in Ray ray) {\n    HitInfo hit = HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    // Ground and wall planes\n    addRayHit(hit, planeIsect(ray, mat4(1.0), 1));\n    addRayHit(hit, planeIsect(ray, Translate(vec3(0.0, 0.0, -10.0)) * RotateX(RHO), 1));\n\n    // Big sphere light\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 1.0, -5.0)), 2));\n\n    // Cubes\n    addRayHit(hit, cubeIsect(ray, Translate(vec3(-3.0, 1.0, -8.0)) * RotateY(1.8), 3));\n    addRayHit(hit, cubeIsect(ray, Translate(vec3(3.0, 1.0, -6.0)) * RotateY(-1.5) * RotateX(-0.5) * RotateZ(2.0), 4));\n\n    // Small spheres and medium sphere\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.0, 0.2, -5.0)) * Scale(vec3(0.2)), 5));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.0, 0.5, -4.0)) * Scale(vec3(0.5)), 6));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 0.2, -5.0)) * Scale(vec3(0.2)), 7));\n\n    // Bilinear patch\n    addRayHit(hit, patchIsect(ray,\n        vec3(0.8, 0.0, -4.25),\n        vec3(2.8, 0.0, -3.25),\n        vec3(0.75, 0.0, -2.75),\n        vec3(0.8, 1.0, -2.25), \n    8));\n\n    // Small sphere lights\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.25, 2.25, -8.0)) * Scale(vec3(0.25)), 9));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.5, 0.2, -2.8)) * Scale(vec3(0.2)), 10));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.25, 0.1, -2.25)) * Scale(vec3(0.1)), 11));\n\n    return hit;\n}\n\nMaterial getMaterial(in vec2 surfUv, in int objId) {\n    Material mtl = Material(vec3(0.0), vec3(0.0));\n\n    // Ground and wall planes\n    if (objId == 1) mtl = Material(vec3(1.0, 0.8, 0.5), vec3(0.0));\n\n    // Big sphere light\n    if (objId == 2) mtl = Material(vec3(0.0), vec3(2.0));\n\n    // Boxes\n    if (objId == 3) mtl = Material(vec3(1.0, 0.0, 0.0), vec3(0.0));\n    if (objId == 4) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0));\n\n    // Small spheres and medium sphere\n    if (objId == 5) mtl = Material(vec3(1.0, 0.0, 0.0), vec3(0.0));\n    if (objId == 6) mtl = Material(vec3(1.0, 1.0, 0.0), vec3(0.0));\n    if (objId == 7) mtl = Material(vec3(0.0, 0.0, 1.0), vec3(0.0));\n\n    // Bilinear patch\n    if (objId == 8) mtl = Material(vec3(0.0, 0.8, 0.6), vec3(0.0));\n\n    // Small sphere lights\n    if (objId == 9) mtl = Material(vec3(0.0), vec3(0.0, 10.0, 0.0));\n    if (objId == 10) mtl = Material(vec3(0.0), vec3(3.0, 0.6, 2.4));\n    if (objId == 11) mtl = Material(vec3(0.0), vec3(5.0, 4.0, 1.0));\n\n    return mtl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Load last frame\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Jitter UVs for antialiasing\n    fragCoord += vec2(rand01(rngState), rand01(rngState));\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera ray\n    mat3 cam = getCameraBasis(vec2(0.0));\n    Ray ray = Ray(vec3(0.0, 1.0, 0.0), normalize(cam * vec3(uv, 1.0)));\n\n    // Pathtrace!\n    vec3 acc = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    for (int bounce=0; bounce < MAX_BOUNCES; bounce++) {\n        HitInfo hit = traceRay(ray);\n        if (hit.hitDist < 0.0) break;\n\n        hit.surfNor = normalize(hit.surfNor); // Normalize the surface normal as a final step\n        hit.surfNor *= sign(dot(hit.surfNor, -ray.dir)); // Flip towards the camera\n\n        // Step to the surface and reflect randomly\n        ray.pos = hit.hitPos + hit.surfNor * EPSILON;\n        ray.dir = normalize(hit.surfNor + randUnitVec(rngState));        \n\n        Material mtl = getMaterial(hit.surfUv, hit.objId);\n        acc += mtl.emissive * throughput;\n        throughput *= mtl.albedo;\n    }\n\n    // Accumulate\n    fragColor.rgb += acc;\n    fragColor.a += 1.0;\n\n    // Restart on mouse down\n    if (iMouse.z > 0.0) {\n        fragColor = vec4(0.0);    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 161, 193, 193, 572], [574, 574, 629, 629, 869]]}
{"id": "fsScWz", "name": "box sdf try-out", "author": "magnias", "description": "art", "tags": ["lines"], "likes": 1, "viewed": 42, "published": 3, "date": "1643966728", "time_retrieved": "2024-07-30T17:05:23.621142", "image_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define hash2x3(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n\n#define SHOW_EDGES false\n#define SHOW_SHADOWS true\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf( in vec3 p )\n{\n    vec3 c = vec3(3);\n    vec3 modPos = mod(p + .5 * c, c) - .5 * c;\n    vec3 pos = vec3(modPos.x, p.y, modPos.z);\n    pos = p;\n    //return max(length(p - vec3(0, 0, 0)) - 1., length(p - vec3(1., 0., 1.3 * sin(iTime))) - 1.1);\n    //p = mod(p + vec3(5), 10.) - vec3(5);\n    //return sdBox(vec3(modPos.x, p.y, modPos.z), vec3(1));\n    \n    // Sphere moving through cube\n    float d = min(\n        sdBox(pos, vec3(1)),\n        sdBox(pos - vec3(0, -2, 0), vec3(15, 1, 15))\n    );\n    \n    d = max( d, -(length(vec3(pos.x, pos.y + sin(iTime / 2.), pos.z)) - 1.2) );\n    for(int x=-1; x<=1; x++) for(int z=-1; z<=1; z++)\n    {\n        if ( x == 0 && z == 0) continue;\n        d = max( d, -(length(vec3(pos.x + 3.4 * float(x), pos.y - sin(iTime / 2.), pos.z + 3.4 * float(z))) - 1.2) );\n    }\n    \n    return d;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*h ) + \n                      k.yyx*sdf( p + k.yyx*h ) + \n                      k.yxy*sdf( p + k.yxy*h ) + \n                      k.xxx*sdf( p + k.xxx*h ) );\n}\n\nfloat ray_march( in vec3 origin, in vec3 direction )\n{\n\n    vec3 pos = origin;\n    \n    // early escape if origin is inside sdf\n    if ( sdf(pos) < 0. )\n    {\n        return -1.;\n    }\n\n    float dist = 0.;\n    for (int i=0; i<100; i++)\n    {\n        float step_dist = sdf(pos);\n        dist += step_dist;\n        pos = origin + dist * direction;\n        \n        if ( step_dist < 0.0001)\n        {\n            return dist;\n        }\n        \n    }\n\n    return -1.;\n}\n\nbool is_edge( in vec3 position )\n{\n    vec3 p = vec3(0);\n    \n    float totalSdf = 0.;\n    float possible_max = 0.;\n    \n    float scale = 0.015;\n    float minVal = -1. * scale;\n    float maxVal = 1. * scale;\n    float stepSize = .5 * scale;\n    for(p.x = minVal; p.x <= maxVal; p.x += stepSize)\n    for(p.y = minVal; p.y <= maxVal; p.y += stepSize)\n    for(p.z = minVal; p.z <= maxVal; p.z += stepSize)\n    {\n        if ( p == vec3(0.) ) continue;\n        \n        float weight = (abs(p.x) * abs(p.y) * abs(p.z));\n        if ( sdf(position + p) > 0. ) totalSdf += weight;\n        else totalSdf -= weight;\n        \n        possible_max += weight;\n        \n        //totalSdf += sdf(p);\n    }\n    \n    totalSdf /= possible_max;\n    if ( totalSdf > 0.5 ) return true;\n    \n    return false;\n}\n\nvec3 march_scene( in vec3 origin, in vec3 direction )\n{\n    float dist = ray_march(origin, direction);\n    \n    // No hit\n    if ( dist == -1. )\n    {\n        // Calculate sky color\n        //return vec3(0.5, 0.85, 0.9) + vec3(dot(direction, vec3(0, 1, 0) * 0.6));\n        return vec3(.1);\n    }\n   \n    vec3 pos = origin + direction * dist;\n    \n    vec3 lightdir = normalize(vec3(1, -.6, 1));\n    vec3 lightcolor = vec3(1, .3, .8);\n    vec3 color = vec3(1, 0, 0) * lightcolor * max(dot(-lightdir, calcNormal(pos)), 0.1);\n    \n    if ( SHOW_SHADOWS )\n    {\n        float dist_to_light = ray_march(pos + -vec3(20) * lightdir , lightdir);\n        if ( dist_to_light < 20. - 0.001 ) \n        {\n            color = vec3(.05);\n        }\n    }\n    \n    if (SHOW_EDGES && is_edge(pos) )\n    {\n        return vec3(0.34);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera setup\n    vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y) * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv *= vec2(6, 6. / aspect);\n\n    vec3 worldpos = vec3(uv.x, uv.y, 0.);\n    worldpos -= vec3(0, 0, 20); // camera position\n    vec3 worlddir = normalize(vec3(0, 0, 1));\n    mat3 rot = rotateX(-0.4) * rotateY(0.4) * rotateZ(0.0);\n    worldpos = rot * worldpos;\n    worlddir = rot * worlddir;\n\n    vec3 color = vec3(0);\n    color = march_scene(worldpos, worlddir);\n\t\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsScWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 412, 439, 439, 586], [588, 588, 615, 615, 762], [764, 764, 791, 791, 938], [940, 940, 977, 977, 1064], [1066, 1066, 1090, 1090, 1899], [1901, 1901, 1952, 1952, 2213], [2215, 2215, 2269, 2269, 2682], [2684, 2684, 2718, 2718, 3474], [3476, 3476, 3531, 3531, 4320], [4322, 4322, 4379, 4399, 4931]]}
{"id": "sdByzV", "name": "Sutured Satin", "author": "davidar", "description": "A variation on [url=https://www.shadertoy.com/view/ld3cWN]Satin Flow[/url] and [url=https://www.shadertoy.com/view/XddSRX]Suture Fluid[/url] by [url=https://www.shadertoy.com/user/cornusammonis]cornusammonis[/url]", "tags": ["poisson", "diffusion", "curvature", "reaction"], "likes": 21, "viewed": 485, "published": 3, "date": "1643953171", "time_retrieved": "2024-07-30T17:05:24.545670", "image_code": "#define BUMP 0.3\n\n// dispersion amount\n#define DISP_SCALE 0.3\n\n// minimum IOR\n#define MIN_IOR 1.1\n\n// chromatic dispersion samples, higher values decrease banding\n#define SAMPLES 9\n\n// time scale\n#define TIME 0.1*iTime\n\n// sharpness of the sample weight distributions, higher values increase separation of colors\n#define SHARP 15.0\n\n#define FILMIC\n#ifdef FILMIC\n// tweaked version of a filmic curve from paniq with a softer left knee\nvec3 contrast(vec3 x) {\n    x=log(1.0+exp(x*10.0-7.2));\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n#else\n#define SIGMOID_CONTRAST 8.0\nvec3 contrast(vec3 x) {\n\treturn (1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5))));    \n}\n#endif\n\nvec3 sampleWeights(float i) {\n\treturn vec3(exp(-SHARP*pow(i-0.25,2.0)), exp(-SHARP*pow(i-0.5,2.0)), exp(-SHARP*pow(i-0.75,2.0)));\n}\n\nmat3 cameraMatrix() {\n    vec3 ro = vec3(sin(TIME),0.0,cos(TIME));\n    vec3 ta = vec3(0,1.5,0);  \n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\n// same as the normal refract() but returns the coefficient\nvec3 refractK(vec3 I, vec3 N, float eta, out float k) {\n    k = max(0.0,1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I)));\n    if (k <= 0.0)\n        return vec3(0.0);\n    else\n        return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec3 sampleDisp(vec2 uv, vec3 disp) {\n\tvec2 p = uv - 0.5;\n\n    // camera movement\n    mat3 camMat = cameraMatrix();\n\n    vec3 rd = normz(camMat * vec3(p.xy, 1.0));\n    vec3 norm = normz(camMat * disp);\n    \n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        float k;\n        vec3 refr = refractK(rd, norm, MIN_IOR + wl * DISP_SCALE, k);\n        vec3 refl = reflect(rd, norm);\n        col += sw * mix(texture(iChannel1, refl).xyz, texture(iChannel1, refr).xyz, k);\n        wl  += SD;\n    }\n    \n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    float d   = texture(iChannel0, uv).x;\n    // uncomment to just render the heightmap\n    //#define SIMPLE\n    #ifdef SIMPLE\n    fragColor = 0.5+0.02*vec4(d);\n    #else\n    float d_n  = texture(iChannel0, (uv+n)  ).x;\n    float d_e  = texture(iChannel0, (uv+e)  ).x;\n    float d_s  = texture(iChannel0, (uv+s)  ).x;\n    float d_w  = texture(iChannel0, (uv+w)  ).x; \n    float d_ne = texture(iChannel0, (uv+n+e)).x;\n    float d_se = texture(iChannel0, (uv+s+e)).x;\n    float d_sw = texture(iChannel0, (uv+s+w)).x;\n    float d_nw = texture(iChannel0, (uv+n+w)).x; \n\n    float dxn[3];\n    float dyn[3];\n    float dcn[3];\n    \n    dcn[0] = 0.5;\n    dcn[1] = 1.0; \n    dcn[2] = 0.5;\n\n    dyn[0] = d_nw - d_sw;\n    dyn[1] = d_n  - d_s; \n    dyn[2] = d_ne - d_se;\n\n    dxn[0] = d_ne - d_nw; \n    dxn[1] = d_e  - d_w; \n    dxn[2] = d_se - d_sw; \n\n    // The section below is an antialiased version of \n    // Shane's Bumped Sinusoidal Warp shadertoy here:\n    // https://www.shadertoy.com/view/4l2XWK\n\t#define SRC_DIST 8.0\n    vec3 sp = vec3(uv-0.5, 0);\n    vec3 light = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -SRC_DIST);\n    vec3 ld = light - sp;\n    float lDist = max(length(ld), 0.001);\n    ld /= lDist;\n    float aDist = max(distance(vec3(light.xy,0),sp) , 0.001);\n    float atten = min(0.07/(0.25 + aDist*0.5 + aDist*aDist*0.05), 1.);\n    vec3 rd = normalize(vec3(uv - 0.5, 1.));\n\n    float spec = 0.0;\n\tfloat den = 0.0;\n    \n    vec3 dispCol = vec3(0);\n    \n    // compute dispersion and specular with antialiasing\n    vec3 avd = vec3(0);\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            vec2 dxy = vec2(dxn[i], dyn[j]);\n            float w = dcn[i] * dcn[j];\n            vec3 bn = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));\n            avd += w * bn;\n            den += w;\n            dispCol += w * sampleDisp(uv, bn);\n            spec += w * ggx(bn, vec3(0,1,0), ld, 0.3, 1.0);\n        }\n    }\n\n    avd /= den;\n    spec /= den;\n    dispCol /= den;\n    \n    // end bumpmapping section\n\n    fragColor =  vec4(contrast(.75*dispCol),1) + 1.0*vec4(0.9, 0.85, 0.8, 1)*spec;\n\n    #endif\n\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIMESTEP 0.7\n\n#define PI 3.14159265359\n\n#define A iChannel0\n#define B iChannel2\n\nfloat sigmoid(float x) {\n    return .5 + .5 * tanh(-5. * (x - 1.));\n}\n\nvoid mainImage( out vec4 r, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 stepSize = 1. / iResolution.xy;\n    \n    // initialize with noise\n    if(iFrame < 10) {\n        vec3 rnd = vec3(noise(8.0 * p + 1.1), noise(8.0 * p + 2.2), noise(8.0 * p + 3.3));\n        r = vec4(rnd,0);\n        return;\n    }\n    \n    vec3 ma = vec3(0);\n    float gcurve = 0.;\n    for (int i = 0; i < 12; i++) {\n        float angle = float(i) * PI/6.;\n        vec2 offset = vec2(cos(angle), sin(angle));\n        vec3 spring = vec3(offset, 0) + texture(B, p + offset / iResolution.xy).xyz - texture(B,p).xyz;\n        ma += sigmoid(length(spring)) * spring;\n        \n        float angle1 = float(i+1) * PI/6.;\n        vec2 offset1 = vec2(cos(angle1), sin(angle1));\n        vec3 spring1 = vec3(offset1, 0) + texture(B, p + offset1 / iResolution.xy).xyz - texture(B,p).xyz;\n        gcurve += PI/6. - acos(dot(normz(spring), normz(spring1)));\n    }\n    \n    vec3 dv = texBlur(A, p - stepSize * texture(A,p).xy).xyz;\n    dv += texLapl(A, p - stepSize * texture(A,p).xy).xyz;\n    dv = texBlur(A, p - stepSize * 48. * (2.87 + 1e4 * gcurve) * (texture(B,p).xy - dv.xy)).xyz;\n    dv += TIMESTEP * ma;\n\n    float t = 0.05 * iTime;\n    vec2 m = fract(vec2(noise(vec2(t,0)), noise(vec2(0,t)))) * iResolution.xy;\n    if (iMouse.z > 0.0) m = iMouse.xy;\n    vec2 d = fragCoord - m;\n    dv += 5. * exp(-length(d) / 50.0) * normz(vec3(d, 0.0));\n    \n    // hard clamping\n    //dv = length(dv) > 1.0 ? normz(dv) : dv;\n    // soft clamping\n    dv -= 0.005 * pow(length(dv), 3.) * normz(dv);\n    r.xyz = mix(texture(A,p).xyz, dv, 0.5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define TIMESTEP 0.1\n\n#define A iChannel0\n#define B iChannel1\n\nvoid mainImage( out vec4 r, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    // initialize with noise\n    if(iFrame < 10) {\n        vec3 rnd = vec3(noise(16.0 * p + 1.1), noise(16.0 * p + 2.2), noise(16.0 * p + 3.3));\n        r = vec4(rnd,0);\n        return;\n    }\n    \n    vec3 du = texBlur(B,p).xyz + TIMESTEP * texBlur(A,p).xyz;\n    // hard clamping\n    //du = length(du) > 1.0 ?  normz(du) : du;\n    // soft clamping\n    du -= 0.005 * pow(length(du), 3.) * normz(du);\n    r.xyz = mix(texture(B,p).xyz, du, 1.);\n    //r.w = texBlur(A,p).w;\n    r.w = texGradX(A,p).x + texGradY(A,p).y;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// based on Suture Fluid\n\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame < 10) {\n        fragColor = vec4(noise(16.0 * uv + 1.1), noise(16.0 * uv + 2.2), noise(16.0 * uv + 3.3), 0);\n        return;\n    }\n\n    float divergence = mix(texture(iChannel0, uv).w, texLapl(iChannel0, uv).w, .25); // divergence smoothing\n    divergence = mix(divergence, texGradX(iChannel0, uv).x + texGradY(iChannel0, uv).y, 1.); // divergence update\n\n    vec2 stepSize = 6. / iResolution.xy;\n    vec3 velocity = texture(iChannel0, uv).xyz;\n    vec3 advected = texBlur(iChannel0, uv - stepSize * velocity.xy).xyz;\n    advected += 2. * texLapl(iChannel0, uv - stepSize * velocity.xy).xyz;\n    advected += .5 * texLapl(iChannel0, uv).xyz;\n    advected -= .5 * texture(iChannel0, uv).xyz * divergence;\n    advected -= .8 * texLapl(iChannel0, uv).z * normz(velocity);\n    advected -= clamp(iTime - 5., 0., 9.) * texBlur(iChannel0, uv).w * normz(velocity);\n\n    vec3 curl = vec3(\n        texGradY(iChannel0, uv).z - 0.,\n        0. - texGradX(iChannel0, uv).z,\n        texGradX(iChannel0, uv).y - texGradY(iChannel0, uv).x);\n    if (length(curl) > 0.)\n        advected = rotateAxis(advected, normalize(curl), 10. * length(curl));\n        \n    advected += 1.5 * curl;\n\n    if (length(advected) > 1.) advected = normalize(advected);\n    divergence = clamp(divergence, -1., 1.);\n    fragColor = mix(texture(iChannel0, uv), vec4(advected, divergence), .2); // update smoothing\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This convolves the Laplacian values with a specially-designed Poisson solver kernel.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = 20.0/6.0; // center weight\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    /* \n\t\tPoisson solver kernel, computed using a custom tool. The curve ended up being very close\n    \tto exp(-x) times a constant (0.43757*exp(-1.0072*x), R^2 = 0.9997).\n    \tThe size of the kernel is truncated such that 99% of the summed kernel weight is accounted for. \n\t*/\n    float a[121] = float[](\n        1.2882849374994847E-4, 3.9883638750009155E-4, 9.515166750018973E-4, 0.0017727328875003466, 0.0025830133546736567, 0.002936729756271805, 0.00258301335467621, 0.0017727328875031007, 9.515166750027364E-4, 3.988363875000509E-4, 1.2882849374998886E-4,\n        3.988363875000656E-4, 0.00122005053750234, 0.0029276701875229076, 0.005558204850002636, 0.008287002243739282, 0.009488002668845403, 0.008287002243717386, 0.005558204850002533, 0.002927670187515983, 0.0012200505375028058, 3.988363875001047E-4,\n        9.515166750033415E-4, 0.0029276701875211478, 0.007226947743770152, 0.014378101312275642, 0.02243013709214819, 0.026345595431380788, 0.02243013709216395, 0.014378101312311218, 0.007226947743759695, 0.0029276701875111384, 9.515166750008558E-4,\n        0.0017727328875040689, 0.005558204850002899, 0.014378101312235814, 0.030803252137257802, 0.052905271651623786, 0.06562027788638072, 0.052905271651324026, 0.03080325213733769, 0.014378101312364885, 0.005558204849979354, 0.0017727328874979902,\n        0.0025830133546704635, 0.008287002243679713, 0.02243013709210261, 0.052905271651950365, 0.10825670746239457, 0.15882720544362505, 0.10825670746187367, 0.05290527165080182, 0.02243013709242713, 0.008287002243769156, 0.0025830133546869602,\n        0.00293672975627608, 0.009488002668872716, 0.026345595431503218, 0.06562027788603421, 0.15882720544151602, 0.44102631192030745, 0.15882720544590473, 0.06562027788637015, 0.026345595431065568, 0.009488002668778417, 0.0029367297562566848,\n        0.0025830133546700966, 0.008287002243704267, 0.022430137092024266, 0.05290527165218751, 0.10825670746234733, 0.1588272054402839, 0.1082567074615041, 0.052905271651381314, 0.022430137092484193, 0.00828700224375486, 0.002583013354686416,\n        0.0017727328875014527, 0.005558204850013428, 0.01437810131221156, 0.03080325213737849, 0.05290527165234342, 0.06562027788535467, 0.05290527165227899, 0.03080325213731504, 0.01437810131229074, 0.005558204849973625, 0.0017727328874977803,\n        9.515166750022218E-4, 0.002927670187526038, 0.0072269477437592895, 0.014378101312185454, 0.02243013709218059, 0.02634559543148722, 0.0224301370922164, 0.014378101312200022, 0.007226947743773282, 0.0029276701875125123, 9.515166750016471E-4,\n        3.988363875000695E-4, 0.0012200505375021846, 0.002927670187525898, 0.005558204849999022, 0.008287002243689638, 0.009488002668901728, 0.008287002243695645, 0.0055582048500028335, 0.002927670187519828, 0.0012200505375025872, 3.988363874999818E-4,\n        1.2882849374993535E-4, 3.9883638750004726E-4, 9.515166750034058E-4, 0.0017727328875029819, 0.0025830133546718525, 0.002936729756279661, 0.002583013354672541, 0.0017727328875033709, 9.515166750023861E-4, 3.988363874999023E-4, 1.2882849374998856E-4\n    );\n    \n    float b[121] = float[](\n        8673174.0, 1.5982146E7, 2.5312806E7, 3.4957296E7, 4.2280236E7, 4.5059652E7, 4.2280236E7, 3.4957296E7, 2.5312806E7, 1.5982146E7, 8673174.0,\n        1.5982146E7, 2.9347785E7, 4.6341531E7, 6.3895356E7, 7.7184405E7, 8.2245411E7, 7.7184405E7, 6.3895356E7, 4.6341531E7, 2.9347785E7, 1.5982146E7,\n        2.5312806E7, 4.6341531E7, 7.2970173E7, 1.00453608E8, 1.21193181E8, 1.29118131E8, 1.21193181E8, 1.00453608E8, 7.2970173E7, 4.6341531E7, 2.5312806E7,\n        3.4957296E7, 6.3895356E7, 1.00453608E8, 1.38192768E8, 1.66613346E8, 1.77507756E8, 1.66613346E8, 1.38192768E8, 1.00453608E8, 6.3895356E7, 3.4957296E7,\n        4.2280236E7, 7.7184405E7, 1.21193181E8, 1.66613346E8, 2.00759625E8, 2.13875721E8, 2.00759625E8, 1.66613346E8, 1.21193181E8, 7.7184405E7, 4.2280236E7,\n        4.5059652E7, 8.2245411E7, 1.29118131E8, 1.77507756E8, 2.13875721E8, 2.27856753E8, 2.13875721E8, 1.77507756E8, 1.29118131E8, 8.2245411E7, 4.5059652E7,\n        4.2280236E7, 7.7184405E7, 1.21193181E8, 1.66613346E8, 2.00759625E8, 2.13875721E8, 2.00759625E8, 1.66613346E8, 1.21193181E8, 7.7184405E7, 4.2280236E7,\n        3.4957296E7, 6.3895356E7, 1.00453608E8, 1.38192768E8, 1.66613346E8, 1.77507756E8, 1.66613346E8, 1.38192768E8, 1.00453608E8, 6.3895356E7, 3.4957296E7,\n        2.5312806E7, 4.6341531E7, 7.2970173E7, 1.00453608E8, 1.21193181E8, 1.29118131E8, 1.21193181E8, 1.00453608E8, 7.2970173E7, 4.6341531E7, 2.5312806E7,\n        1.5982146E7, 2.9347785E7, 4.6341531E7, 6.3895356E7, 7.7184405E7, 8.2245411E7, 7.7184405E7, 6.3895356E7, 4.6341531E7, 2.9347785E7, 1.5982146E7,\n        8673174.0, 1.5982146E7, 2.5312806E7, 3.4957296E7, 4.2280236E7, 4.5059652E7, 4.2280236E7, 3.4957296E7, 2.5312806E7, 1.5982146E7, 8673174.0\n \t);\n    \n    vec4 ac = vec4(0);\n    vec4 bc = vec4(0);\n    vec4 bcw = vec4(0);\n    for (int i = -5; i <= 5; i++) {\n        for (int j = -5; j <= 5; j++) {\n            int index = (j + 5) * 11 + (i + 5);\n            vec4 tx0 = vec4(texture(iChannel1, uv + texel * vec2(i,j)).w);\n            vec4 tx1 = texture(iChannel3, (uv + texel * vec2(i,j)));\n            ac  += -a[index] * tx0;\n            bcw +=  b[index];\n            bc  +=  b[index] * tx1;\n        }\n    }\n    \n    bc /= bcw;\n    fragColor = vec4(ac + bc);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 normz(vec2 x) { return x == vec2(0) ? vec2(0) : normalize(x); }\nvec3 normz(vec3 x) { return x == vec3(0) ? vec3(0) : normalize(x); }\n\n\n/* Texture Stencil Library https://www.shadertoy.com/view/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https://davidar.io/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. / vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n// Gaussian/binomial blur\n// https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n// Laplacian, optimal 9-point stencil\n// https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) / 6.;\n}\n\n// horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) / 8.;\n}\n\n// vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) / 8.;\n}\n\n\n\n\n\n// IQ's simplex noise:\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdByzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 703, 703, 805], [807, 807, 828, 828, 1045], [1047, 1107, 1162, 1162, 1341], [1343, 1343, 1380, 1380, 2029], [2031, 2031, 2087, 2087, 4447]]}
{"id": "fdjczd", "name": "Hyperboloid Twister", "author": "oneshade", "description": ".", "tags": ["lines", "hyperbola", "twisting"], "likes": 10, "viewed": 209, "published": 3, "date": "1643949743", "time_retrieved": "2024-07-30T17:05:25.343537", "image_code": "#define FX\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    #ifdef FX\n    // Layering mipmaps to create a bloom effect\n    fragColor = texture(iChannel0, uv, 5.0);\n    fragColor += texture(iChannel0, uv, 4.0);\n    fragColor += texture(iChannel0, uv, 3.0);\n    fragColor += texture(iChannel0, uv, 2.0);\n    fragColor /= 4.0;\n\n    // Chromatic aberration 'cause why not\n    fragColor.r += texture(iChannel0, uv - vec2(0.01, 0.01)).r;\n    fragColor.g += texture(iChannel0, uv - vec2(-0.01, 0.02)).g;\n    fragColor.b += texture(iChannel0, uv - vec2(0.0, -0.005)).b;\n\n    #else\n    fragColor = texture(iChannel0, uv);\n\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926536\n#define TAU 6.2831853072\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = max(color, col * smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 0.6;\n    float unit = 1.2 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float len = 2.0;\n    float twist = sin(0.25 * iTime) * PI / 2.0;\n\n    // Convert twist angle to a rotation matrix\n    float co = cos(twist), si = sin(twist);\n    mat2 rot = mat2(co, -si, si, co);\n\n    // Calculate height to keep line length constant\n    float chord = 2.0 * sin(twist);\n    float halfHeight = sqrt(len * len - chord * chord) / 2.0;\n\n    for (float a=0.0; a < TAU; a += TAU / 50.0) {\n        vec3 p1 = vec3(cos(a), -halfHeight, sin(a));\n        vec3 p2 = vec3(p1.x, halfHeight, p1.z);\n\n        p1.xz *= transpose(rot); // Rotate in opposite direction\n        p2.xz *= rot;\n\n        // Project\n        p1.xy /= p1.z + 5.0;\n        p2.xy /= p2.z + 5.0;\n\n        drawSDF(sdLine(uv, p1.xy, p2.xy), vec3(1.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 67, 67, 681]]}
{"id": "Nd2cRd", "name": "Rainbow layers", "author": "ErinZ", "description": "psrdnoise test", "tags": ["simplexnoise", "pattern"], "likes": 11, "viewed": 456, "published": 3, "date": "1643945570", "time_retrieved": "2024-07-30T17:05:26.090540", "image_code": "// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n  vec2 uv = vec2(x.x+x.y*0.5, x.y);\n  vec2 i0 = floor(uv), f0 = fract(uv);\n  float cmp = step(f0.y, f0.x);\n  vec2 o1 = vec2(cmp, 1.0-cmp);\n  vec2 i1 = i0 + o1, i2 = i0 + 1.0;\n  vec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n  vec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n  vec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n  vec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n  vec3 iu, iv, xw, yw;\n  if(any(greaterThan(period, vec2(0.0)))) {\n    xw = vec3(v0.x, v1.x, v2.x);\n    yw = vec3(v0.y, v1.y, v2.y);\n    if(period.x > 0.0)\n    xw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n    if(period.y > 0.0)\n      yw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n    iu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n  } else {\n    iu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n  }\n  vec3 hash = mod(iu, 289.0);\n  hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n  hash = mod((hash*34.0 + 10.0)*hash, 289.0);\n  vec3 psi = hash*0.07482 + alpha;\n  vec3 gx = cos(psi); vec3 gy = sin(psi);\n  vec2 g0 = vec2(gx.x, gy.x);\n  vec2 g1 = vec2(gx.y, gy.y);\n  vec2 g2 = vec2(gx.z, gy.z);\n  vec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n  w = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n  vec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n  float n = dot(w4, gdotx);\n  vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n  vec2 dn0 = w4.x*g0 + dw.x*x0;\n  vec2 dn1 = w4.y*g1 + dw.y*x1;\n  vec2 dn2 = w4.z*g2 + dw.z*x2;\n  gradient = 10.9*(dn0 + dn1 + dn2);\n  return 10.9*n;\n}\n\nfloat fbm(vec2 x,float n,out vec2 g){\nvec2 p = vec2(0.);\nfloat alpha = iTime*.05;\nfloat scale = .5;\nfloat noise = 0.;\nfor (float i = 0.;i<n;i++){\nnoise += psrdnoise(x , p, alpha, g)*scale;\nx *=2.;scale/=2.;alpha *=1.3;\n}\nreturn noise;\n}\n\nvec3 pattern2(vec2 uv){\n    float alpha = iTime*0.1;\n    vec2 g;vec2 p = vec2(6);\n    vec3 col = mix(vec3(0.,0.35,1.),vec3(1.,.15,.1),psrdnoise(uv*.5+vec2(.23,.67), p, alpha, g)*0.5+0.5);\n    col += vec3(0.,.6,0.2)*(psrdnoise(uv*.4+vec2(.092,.137), p, alpha+2., g)*0.5+.2);\n    col *= clamp(length(g)*.3,0.,.6)+.4;\n    \n    float n = fbm(uv*.5,2.,g);\n    // Normalizing the noise.\n    n = clamp(n*.5 + .5, .2, 1.);\n    // Aliased fractional contour pattern.\n    n = fract(n*10.);\n    // Smooth fract with the gradient taken into account.\n    // Smoothing factor. Set to 1 for a comparisson.\n    float sf = iResolution.y/300./max(length(g), .001);\n    n = min(n, n*(1. - n)*48.*sf);\n    col *= n;\n    col.x = pow(col.x,0.7);\n    return col;\n}\n\n\nfloat logo(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 uv1 = uv*1.5;\n    const vec2 p = vec2(8.0, 8.0);\n    float alpha = iTime*.1;\n    vec2 g;\n    float n = psrdnoise(uv1, p, alpha, g);\n        \n    vec3 col;\n    //basic noise\n    col = sqrt(vec3(n*0.5+0.5));\n    \n    //pattern2\n    col = pattern2(uv)*0.9;//colorful layer\n    col = mix(col,vec3(0,.9,.6)*pattern2(uv+vec2(0.876,0.1873)).y*n,n-.2);//cyan layer\n    col += logo(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v ) \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2cRd.jpg", "access": "api", "license": "mit", "functions": [[143, 143, 213, 213, 1672], [1674, 1674, 1711, 1711, 1910], [1912, 1912, 1935, 1935, 2653], [2678, 2678, 2735, 2735, 3242], [3301, 3301, 3321, 3321, 3710]]}
{"id": "7sSyzd", "name": "Magnets", "author": "wyatt", "description": "Electromagnetic Potential from charges, magnets, and current loops. \nThe radial component of the field appears from the probability of a random ray hitting the source...", "tags": ["physics", "magnet"], "likes": 27, "viewed": 512, "published": 3, "date": "1643934344", "time_retrieved": "2024-07-30T17:05:26.883420", "image_code": "Main\n    Q = vec4(1);\n    vec3 p = vec3(0,0,-2);\n    vec3 d = normalize(vec3((U-.5*R)/R.y,1));\n    p.xz *= ei(.2*sin(iTime));\n    d.xz *= ei(.2*sin(iTime));\n    \n    for (float i = 0.; i < 30.; i++) {\n    \n        p += d*map(p);\n    \n    }\n    vec3 no = normal(p);\n    \n    float C; vec3 P,J;\n    info(p,C,P,J,Q);\n    if (Q.w < 0.) {\n        Q = A(p.xy*.5*R.y+.5*R);\n        Q /= float(I);\n        if (length(Q.xyz)>0.)\n        Q.xyz = length(Q.xyz)*(.5-.5*sin(3.*atan(Q.x,Q.y)+vec3(1,2,3)));\n        else Q.xyz = vec3(1);\n        Q += vec4(-Q.w,abs(Q.w),Q.w,0);\n        Q = 1.-.8*atan(.4*Q);\n        Q *= 1.3*exp(-.7*dot(p.xy,p.xy));\n        vec2 w = fwidth(p.xy);\n        Q *= 1.-.25*smoothstep(1.-.5*w.x,1.,cos(10.*p.x));\n        Q *= 1.-.25*smoothstep(1.-.5*w.y,1.,cos(10.*p.y));\n        Q *= 1.-.25*smoothstep(1.-10.*w.x,1.,cos(100.*p.x));\n        Q *= 1.-.25*smoothstep(1.-10.*w.y,1.,cos(100.*p.y));\n    \n        \n        vec3 q = p;\n        for (float i = 0.; i < 10.; i++) {\n            q += d*map2(q);\n\n        }\n        \n        vec4 color = vec4(0);\n        info(q,C,P,J,color);\n        vec3 li = normalize(light_pos-q);\n        vec3 nor= normal(q);\n        if (length(color)>.1&&color.w>0.) Q += Q*color*(dot(nor,li));\n    \n    }\n    d = normalize(light_pos-p);\n    Q *= .5+.5*dot(no,d);\n    p += 1e-3*d;\n    for (float i = 0.; i < 15.; i++) {\n        p += d*map(p);\n    }\n    //Q *= exp(-.1*length(p-light_pos));\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main\n\n    Q = A(U);\n    vec3 p = vec3(2.*(U-.5*R)/R.y,0);\n    float C; vec3 P,J; vec4 q;\n    \n    vec3 d = rand(vec4(U,I,T));\n    vec4 h = hash44(vec4(U,I,T));\n    p += .1/60.*d*h.w;\n    for (float i = 1.; i < 80.; i++) {\n        p += 1./60.*(d);\n        info (p,C,P,J,q);\n        Q.w += C;\n        Q.xyz += cross(P,d)+J;\n    }\n    \n    \n    if (iFrame < 0) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R=iResolution.xy; T=iTime; I=iFrame;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define light_pos vec3(1,1,-3)\n#define tri_pos vec3(.3,.1,.03)\n#define tri_mat mat3( \\\n   0.9174312, -0.2873479,  0.2752294,\\\n   0.2873479,  0.0000000, -0.9578263,\\\n   0.2752294,  0.9578263,  0.0825688 )\n#define rec_pos vec3(-.5,.2,-.1)\n#define rec_mat mat3(\\\n   0.0253286,  0.9891455,  0.1447403,\\\n   0.9408970,  0.0253286, -0.3377445,\\\n  -0.3377445,  0.1447403, -0.9300424 \\\n)\n#define sph_pos vec3(-.5,-.5,-.1)\n#define sph_mat mat3(1)\n#define bal_pos vec3(-.9,-.3,-.05)\n#define bal_mat mat3(1)\n#define tor_pos vec3(.9,-.2,-.04)\n#define tor_mat mat3(\\\n   0.9523810, -0.0999419,  0.2880662,\\\n   0.2904181,  0.0095238, -0.9568524,\\\n   0.0928862,  0.9949477,  0.0380952 \\\n)\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return abs(dot(p,n))-h;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat map (vec3 p) {\n    float tri = sdTriPrism((p-tri_pos)*tri_mat,vec2(.2,.7));\n    float rec = sdBox((p-rec_pos)*rec_mat,vec3(.1,.2,.3));\n    float plane = sdPlane(p,vec3(0,0,1),0.001);\n    float sphere = sdSphere((p-sph_pos)*sph_mat,.2);\n    float ball = sdSphere((p-bal_pos)*bal_mat,.1);\n    float torus = sdTorus((p-tor_pos)*tor_mat,vec2(.5,.05));\n    float light = sdSphere(p-light_pos,.1);\n    return min(tri,min(plane,min(rec,min(sphere,min(torus,min(light,ball))))));\n}\nfloat map2 (vec3 p) {\n    float tri = sdTriPrism((p-tri_pos)*tri_mat,vec2(.2,.7));\n    float rec = sdBox((p-rec_pos)*rec_mat,vec3(.1,.2,.3));\n    float plane = sdPlane(p,vec3(0,0,1),0.001);\n    float sphere = sdSphere((p-sph_pos)*sph_mat,.2);\n    float ball = sdSphere((p-bal_pos)*bal_mat,.1);\n    float torus = sdTorus((p-tor_pos)*tor_mat,vec2(.5,.05));\n    float light = sdSphere(p-light_pos,.1);\n    return min(tri,min(rec,min(sphere,min(torus,min(light,ball)))));\n}\nvoid info (vec3 p, out float C, out vec3 P, out vec3 J, out vec4 color) {\n    C = 0.; J = vec3(0); color = vec4(0);\n    vec3 tri = (p-tri_pos)*tri_mat;\n    vec3 rec = (p-rec_pos)*rec_mat;\n    vec3 sph = (p-sph_pos)*sph_mat;\n    vec3 tor = (p-tor_pos)*tor_mat;\n    vec3 bal = (p-bal_pos)*bal_mat;\n    float dtri = sdTriPrism(tri,vec2(.2,.7));\n    float drec = sdBox(rec,vec3(.1,.2,.3));\n    float dplane = sdPlane(p,vec3(0,0,1),0.001);\n    float dsphere = sdSphere(sph,.2);\n    float dlight = sdSphere(p-light_pos,.1);\n    float dtorus = sdTorus(tor,vec2(.5,.05));\n    float dball = sdSphere(bal,.1);\n    float d = 1e9;\n    if (dtri < d) {\n        d = dtri;\n        float t = dot(p-tri_pos,tri_mat[2]);\n        if (t > 0.) color = vec4(1,0,0,1);\n        else color = vec4(.2);\n        P = tri_mat[2];\n        C = 0.;\n        J = vec3(0);\n    }\n    if (dplane < d) {\n        d = dplane;\n        color = vec4(1,1,1,-1);\n        J = vec3(0);\n        C = 0.;\n        P = vec3(0);\n    }\n    if (drec < d) {\n        d = drec;\n        float t = dot(p-rec_pos,rec_mat[2]);\n        if (t > 0.) color = vec4(1,.25,0,1);\n        else color = vec4(.1,.1,.7,1);\n        P = rec_mat[2];\n        C = .3;\n        J = vec3(0);\n    }\n    if (dsphere < d) {\n        d = dsphere;\n        color = vec4(0,.6,.8,1);\n        C = -.5;\n        J = vec3(0);\n        P = vec3(0);\n    }\n    if (dlight < d) {\n        d = dlight;\n    }\n    if (dtorus < d) {\n        d = dtorus;\n        color = vec4(1,.6,.0,1);\n        J = 10.*cross(tor_mat[2],p-tor_pos);\n        C = 0.;\n        P = vec3(0);\n    }\n    if (dball < d) {\n        d = dball;\n        color = vec4(1,.2,.3,1);\n        C = 2.;\n        J = vec3(0);\n        P = vec3(0);\n    }\n    if (d>1e-3) {\n        color = vec4(0);\n        P = vec3(0);\n        C = 0.;\n        J = vec3(0);\n    }\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-3,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec3 rand(vec4 p) {\n    vec4 h = hash44(p);\n    float theta = 2. * pi * h.x;\n    float phi = acos(1. - 2. * h.y);\n    return vec3(sin(phi) * cos(theta),\n                sin(phi) * sin(theta),\n                cos(phi) );\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "fdjcRt", "name": "Sierpinski Stream", "author": "Ebanflo", "description": "Playing with interacting cellular automata on 3 channels.\n\nWarning: messing with rrule, grule, brule in Buf A can lead to very high frequency patterns.", "tags": ["2d", "fractal", "automata", "cellular"], "likes": 5, "viewed": 218, "published": 3, "date": "1643931717", "time_retrieved": "2024-07-30T17:05:27.625436", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool update(uint rule, int pix, int pixu, int pixr, int pixd, int pixl) {\n    uint i = uint(pix + 2*pixu + 4*pixr + 8*pixd + 16*pixl);\n    return int((rule >> i))%2 == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    uint rrule = uint(666);\n    uint grule = uint(420);\n    uint brule = uint(24);\n\n    if(iFrame < 15) {\n        float d = distance(fragCoord, iResolution.xy/2.0);\n        fragColor = vec4(d < 100.0 && d > 99.0);\n    }\n    else {\n        ivec3 pix = ivec3(texture(iChannel1, fragCoord/iResolution.xy).rgb);\n        ivec3 pixu = ivec3(texture(iChannel1, (fragCoord + vec2(0,1))/iResolution.xy).rgb);\n        ivec3 pixr = ivec3(texture(iChannel1, (fragCoord + vec2(1,0))/iResolution.xy).rgb);\n        ivec3 pixd = ivec3(texture(iChannel1, (fragCoord + vec2(0,-1))/iResolution.xy).rgb);\n        ivec3 pixl = ivec3(texture(iChannel1, (fragCoord + vec2(-1,0))/iResolution.xy).rgb);\n        \n        fragColor.r = float(update(rrule, pix.g, pixu.r, pixr.r, pixd.r, pixl.r));\n        fragColor.g = float(update(grule, pix.b, pixu.g, pixr.g, pixd.g, pixl.g));\n        fragColor.b = float(update(brule, pix.r, pixu.b, pixr.b, pixd.b, pixl.b));\n   }\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 190]]}
{"id": "fdjyzy", "name": "Beside The Seaside (Sound)", "author": "mla", "description": "A Music Hall classic: [url]https://www.youtube.com/watch?v=ZglHbYtP7WA[/url]\n\nThanks to @athibaul: [url]https://www.shadertoy.com/view/ssjyDD[/url] & @incription: [url]https://www.shadertoy.com/view/NslyRf[/url]\n\nSee Sound tab for info,", "tags": ["music", "midi", "idoliketobebesidetheseaside"], "likes": 21, "viewed": 533, "published": 3, "date": "1643927272", "time_retrieved": "2024-07-30T17:05:30.177612", "image_code": "// See Sound tab for info\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 dim = vec2(240,303);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0-uv.y;\n    uv.x -= 0.5;\n    uv *= 303.0/iResolution.y;\n    uv.x += 0.5*(240.0/iResolution.x);\n    vec3 col = vec3(1,1,0.8);\n    col *= texture(iChannel0,uv).xyz;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// I Do Like To Be Beside The Seaside\n//\n// Matthew Arcus, mla, 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// MIDI data converted to a static array, then played with some simple\n// sound synthesis. Binary search in array to find the notes to play keeps\n// generation time reasonable.\n//\n// Many thanks to athibaul for his tutorial https://www.youtube.com/watch?v=3mteFftC7fE\n// and https://www.shadertoy.com/view/ssjyDD (and other shaders). I have used his\n// fmPluck function from the tutorial and also epiano from his FM Electric Piano\n// shader: https://www.shadertoy.com/view/3scfD2.\n//\n// Original MIDI file from: https://www.mfiles.co.uk/midi-traditional.htm\n//\n// Other tunes are available (set TUNE to 0-7). Have a banana if you\n// can identify them all (I should add credits for the original files too -\n// mostly also from https://www.mfiles.co.uk/).\n//\n// It seems that Shadertoy generates up to 180s of sound, and my Nvidia compiler\n// on Linux won't accept more than 2047 items in a static array. Also my phone\n// can't cope with this amount of static data, so I've used HW_PERFORMANCE == 0\n// to limit the array size (I've only done this for TUNE 0 though).\n//\n// The MIDI data for each note would easily encode as a uvec2, but this didn't\n// seem necessary.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define SOUND 0 // 0-4\n#define TUNE 0  // 0-9\n#if TUNE == 9\nfloat speed = 0.85;\nconst ivec4 data[] = ivec4[] (\nivec4(0,240,41,64),\nivec4(0,240,41,64),\nivec4(0,240,53,64),\nivec4(240,240,48,64),\nivec4(480,240,53,64),\nivec4(480,240,53,64),\nivec4(480,240,57,64),\nivec4(720,240,53,64),\nivec4(960,240,52,64),\nivec4(960,240,52,64),\nivec4(960,240,55,64),\nivec4(1200,240,48,64),\nivec4(1200,240,55,64),\nivec4(1200,240,55,64),\nivec4(1440,240,52,64),\nivec4(1440,240,52,64),\nivec4(1440,480,58,64),\nivec4(1680,240,48,64),\nivec4(1680,240,48,64),\nivec4(1920,120,57,64),\nivec4(1920,240,41,64),\nivec4(1920,240,41,64),\nivec4(2040,120,53,64),\nivec4(2160,120,48,64),\nivec4(2280,120,53,64),\nivec4(2400,240,53,64),\nivec4(2400,240,53,64),\nivec4(2400,240,57,64),\nivec4(2640,240,53,64),\nivec4(2880,240,52,64),\nivec4(2880,240,52,64),\nivec4(2880,240,55,64),\nivec4(3120,240,48,64),\nivec4(3120,240,55,64),\nivec4(3120,240,55,64),\nivec4(3360,240,52,64),\nivec4(3360,240,52,64),\nivec4(3360,480,58,64),\nivec4(3600,240,48,64),\nivec4(3600,240,48,64),\nivec4(3840,120,57,64),\nivec4(3840,240,45,64),\nivec4(3840,240,45,64),\nivec4(3960,120,60,64),\nivec4(4080,120,65,64),\nivec4(4200,120,64,64),\nivec4(4320,120,65,64),\nivec4(4320,240,57,64),\nivec4(4320,240,57,64),\nivec4(4440,120,60,64),\nivec4(4560,120,57,64),\nivec4(4680,120,60,64),\nivec4(4800,120,58,64),\nivec4(4800,240,46,64),\nivec4(4800,240,46,64),\nivec4(4920,120,62,64),\nivec4(5040,120,65,64),\nivec4(5160,120,64,64),\nivec4(5280,120,65,64),\nivec4(5280,240,58,64),\nivec4(5280,240,58,64),\nivec4(5400,120,62,64),\nivec4(5520,120,58,64),\nivec4(5640,120,62,64),\nivec4(5760,120,60,64),\nivec4(5760,240,48,64),\nivec4(5760,240,48,64),\nivec4(5880,120,65,64),\nivec4(6000,120,64,64),\nivec4(6120,120,62,64),\nivec4(6240,120,60,64),\nivec4(6240,240,60,64),\nivec4(6240,240,60,64),\nivec4(6360,120,58,64),\nivec4(6480,120,57,64),\nivec4(6600,120,55,64),\nivec4(6720,120,53,64),\nivec4(6720,240,53,64),\nivec4(6720,240,53,64),\nivec4(6840,120,60,64),\nivec4(6960,120,57,64),\nivec4(6960,240,48,64),\nivec4(6960,240,48,64),\nivec4(7080,120,60,64),\nivec4(7200,240,45,64),\nivec4(7200,240,45,64),\nivec4(7200,240,53,64),\nivec4(7440,240,48,64),\nivec4(7440,240,48,64),\nivec4(7440,240,72,90),\nivec4(7680,240,45,64),\nivec4(7680,240,45,64),\nivec4(7680,240,53,64),\nivec4(7680,240,72,90),\nivec4(7920,120,69,90),\nivec4(7920,240,48,64),\nivec4(8040,120,70,90),\nivec4(8160,240,57,64),\nivec4(8160,240,57,64),\nivec4(8160,240,57,64),\nivec4(8160,240,72,90),\nivec4(8400,240,53,64),\nivec4(8400,240,77,90),\nivec4(8640,240,48,64),\nivec4(8640,240,48,64),\nivec4(8640,240,55,64),\nivec4(8640,240,76,90),\nivec4(8880,240,48,64),\nivec4(8880,240,74,90),\nivec4(9120,240,52,64),\nivec4(9120,240,52,64),\nivec4(9120,450,72,90),\nivec4(9120,480,58,64),\nivec4(9600,120,57,64),\nivec4(9600,240,41,64),\nivec4(9600,240,41,64),\nivec4(9600,240,72,88),\nivec4(9720,120,53,64),\nivec4(9840,120,48,64),\nivec4(9840,120,69,87),\nivec4(9960,120,53,64),\nivec4(9960,120,70,87),\nivec4(10080,240,53,64),\nivec4(10080,240,53,64),\nivec4(10080,240,57,64),\nivec4(10080,240,72,87),\nivec4(10320,240,53,64),\nivec4(10320,240,77,85),\nivec4(10560,240,52,64),\nivec4(10560,240,52,64),\nivec4(10560,240,55,64),\nivec4(10560,240,76,84),\nivec4(10800,240,48,64),\nivec4(10800,240,55,64),\nivec4(10800,240,55,64),\nivec4(10800,240,74,83),\nivec4(11040,240,52,64),\nivec4(11040,240,52,64),\nivec4(11040,450,72,82),\nivec4(11040,480,58,64),\nivec4(11280,240,48,64),\nivec4(11280,240,48,64),\nivec4(11520,120,57,64),\nivec4(11520,240,45,64),\nivec4(11520,240,45,64),\nivec4(11640,120,60,64),\nivec4(11760,120,65,64),\nivec4(11880,120,64,64),\nivec4(12000,120,65,64),\nivec4(12000,240,57,64),\nivec4(12000,240,57,64),\nivec4(12120,120,60,64),\nivec4(12240,120,57,64),\nivec4(12360,120,60,64),\nivec4(12480,120,58,64),\nivec4(12480,240,46,64),\nivec4(12480,240,46,64),\nivec4(12600,120,62,64),\nivec4(12720,120,65,64),\nivec4(12840,120,64,64),\nivec4(12960,120,65,64),\nivec4(12960,240,58,64),\nivec4(12960,240,58,64),\nivec4(13080,120,62,64),\nivec4(13200,120,58,64),\nivec4(13320,120,62,64),\nivec4(13440,120,60,64),\nivec4(13440,240,48,64),\nivec4(13440,240,48,64),\nivec4(13560,120,65,64),\nivec4(13680,120,64,64),\nivec4(13800,120,62,64),\nivec4(13920,120,60,64),\nivec4(13920,240,60,64),\nivec4(13920,240,60,64),\nivec4(14040,120,58,64),\nivec4(14160,120,57,64),\nivec4(14280,120,55,64),\nivec4(14400,120,53,64),\nivec4(14400,240,53,64),\nivec4(14400,240,53,64),\nivec4(14520,120,60,64),\nivec4(14640,120,57,64),\nivec4(14640,240,48,64),\nivec4(14640,240,48,64),\nivec4(14760,120,60,64),\nivec4(14880,240,45,64),\nivec4(14880,240,45,64),\nivec4(14880,240,53,64),\nivec4(15120,240,48,64),\nivec4(15120,240,48,64),\nivec4(15120,240,72,89),\nivec4(15360,240,45,64),\nivec4(15360,240,45,64),\nivec4(15360,240,53,64),\nivec4(15360,240,72,88),\nivec4(15600,120,69,88),\nivec4(15600,240,48,64),\nivec4(15720,120,70,88),\nivec4(15840,240,57,64),\nivec4(15840,240,57,64),\nivec4(15840,240,57,64),\nivec4(15840,240,72,88),\nivec4(16080,240,53,64),\nivec4(16080,240,77,88),\nivec4(16320,240,48,64),\nivec4(16320,240,48,64),\nivec4(16320,240,55,64),\nivec4(16320,240,76,88),\nivec4(16560,240,48,64),\nivec4(16560,240,74,88),\nivec4(16800,240,52,64),\nivec4(16800,240,52,64),\nivec4(16800,450,72,88),\nivec4(16800,480,58,64),\nivec4(17280,120,57,64),\nivec4(17280,240,41,64),\nivec4(17280,240,41,64),\nivec4(17280,240,72,88),\nivec4(17400,120,53,64),\nivec4(17520,120,48,64),\nivec4(17520,120,69,88),\nivec4(17640,120,53,64),\nivec4(17640,120,70,88),\nivec4(17760,240,53,64),\nivec4(17760,240,53,64),\nivec4(17760,240,57,64),\nivec4(17760,240,72,88),\nivec4(18000,240,53,64),\nivec4(18000,240,77,87),\nivec4(18240,240,52,64),\nivec4(18240,240,52,64),\nivec4(18240,240,55,64),\nivec4(18240,240,76,87),\nivec4(18480,240,48,64),\nivec4(18480,240,55,64),\nivec4(18480,240,55,64),\nivec4(18480,240,74,87),\nivec4(18720,240,52,64),\nivec4(18720,240,52,64),\nivec4(18720,450,72,87),\nivec4(18720,480,58,64),\nivec4(18960,240,48,64),\nivec4(18960,240,48,64),\nivec4(19200,120,57,64),\nivec4(19200,240,45,64),\nivec4(19200,240,45,64),\nivec4(19200,240,77,87),\nivec4(19320,120,60,64),\nivec4(19440,120,65,64),\nivec4(19440,120,81,87),\nivec4(19560,120,64,64),\nivec4(19560,120,79,87),\nivec4(19680,120,65,64),\nivec4(19680,240,57,64),\nivec4(19680,240,57,64),\nivec4(19680,240,77,87),\nivec4(19800,120,60,64),\nivec4(19920,120,57,64),\nivec4(19920,240,72,87),\nivec4(20040,120,60,64),\nivec4(20160,120,58,64),\nivec4(20160,240,46,64),\nivec4(20160,240,46,64),\nivec4(20160,240,74,87),\nivec4(20280,120,62,64),\nivec4(20400,120,65,64),\nivec4(20400,120,74,87),\nivec4(20520,120,64,64),\nivec4(20520,120,72,87),\nivec4(20640,120,65,64),\nivec4(20640,240,58,64),\nivec4(20640,240,58,64),\nivec4(20640,240,74,87),\nivec4(20760,120,62,64),\nivec4(20880,120,58,64),\nivec4(20880,240,67,87),\nivec4(21000,120,62,64),\nivec4(21120,120,60,64),\nivec4(21120,240,48,64),\nivec4(21120,240,48,64),\nivec4(21120,240,67,87),\nivec4(21240,120,65,64),\nivec4(21360,120,64,64),\nivec4(21360,240,69,87),\nivec4(21480,120,62,64),\nivec4(21600,120,60,64),\nivec4(21600,240,60,64),\nivec4(21600,240,60,64),\nivec4(21600,240,70,86),\nivec4(21720,120,58,64),\nivec4(21840,120,57,64),\nivec4(21840,240,72,86),\nivec4(21960,120,55,64),\nivec4(22080,120,53,64),\nivec4(22080,216,53,80),\nivec4(22080,216,53,80),\nivec4(22080,450,69,86),\nivec4(22200,120,60,64),\nivec4(22320,120,57,64),\nivec4(22320,216,48,80),\nivec4(22320,216,48,80),\nivec4(22440,120,60,64),\nivec4(22560,216,45,80),\nivec4(22560,216,45,80),\nivec4(22560,240,53,64),\nivec4(22800,216,48,80),\nivec4(22800,216,48,80),\nivec4(22800,240,72,85),\nivec4(23040,240,41,64),\nivec4(23040,240,41,64),\nivec4(23040,240,53,64),\nivec4(23040,240,72,85),\nivec4(23280,120,69,85),\nivec4(23280,240,48,64),\nivec4(23400,120,70,85),\nivec4(23520,240,53,64),\nivec4(23520,240,53,64),\nivec4(23520,240,57,64),\nivec4(23520,240,72,85),\nivec4(23760,240,53,64),\nivec4(23760,240,77,85),\nivec4(24000,240,55,64),\nivec4(24000,240,70,85),\nivec4(24240,108,52,80),\nivec4(24240,108,52,80),\nivec4(24240,240,48,64),\nivec4(24240,240,69,85),\nivec4(24360,114,50,64),\nivec4(24360,114,50,64),\nivec4(24480,240,52,64),\nivec4(24480,240,52,64),\nivec4(24480,240,67,85),\nivec4(24480,480,58,64),\nivec4(24720,240,48,64),\nivec4(24720,240,48,64),\nivec4(24720,240,72,85),\nivec4(24960,120,57,64),\nivec4(24960,240,41,64),\nivec4(24960,240,41,64),\nivec4(24960,240,72,85),\nivec4(25080,120,53,64),\nivec4(25200,120,48,64),\nivec4(25200,120,69,85),\nivec4(25320,120,53,64),\nivec4(25320,120,70,85),\nivec4(25440,240,53,64),\nivec4(25440,240,53,64),\nivec4(25440,240,57,64),\nivec4(25440,240,72,85),\nivec4(25680,240,53,64),\nivec4(25680,240,77,85),\nivec4(25920,240,55,64),\nivec4(25920,240,70,85),\nivec4(26160,108,52,80),\nivec4(26160,108,52,80),\nivec4(26160,240,48,64),\nivec4(26160,240,69,85),\nivec4(26280,114,50,64),\nivec4(26280,114,50,64),\nivec4(26400,240,52,64),\nivec4(26400,240,52,64),\nivec4(26400,240,67,85),\nivec4(26400,480,58,64),\nivec4(26640,240,48,64),\nivec4(26640,240,48,64),\nivec4(26640,240,76,85),\nivec4(26880,120,57,64),\nivec4(26880,240,45,64),\nivec4(26880,240,45,64),\nivec4(26880,240,77,85),\nivec4(27000,120,60,64),\nivec4(27120,120,65,64),\nivec4(27120,120,74,85),\nivec4(27240,120,64,64),\nivec4(27240,120,72,85),\nivec4(27360,120,65,64),\nivec4(27360,240,53,64),\nivec4(27360,240,53,64),\nivec4(27360,240,74,85),\nivec4(27480,120,60,64),\nivec4(27600,120,57,64),\nivec4(27600,240,77,85),\nivec4(27720,120,60,64),\nivec4(27840,120,59,64),\nivec4(27840,240,47,64),\nivec4(27840,240,47,64),\nivec4(27840,240,79,85),\nivec4(27960,120,62,64),\nivec4(28080,120,65,64),\nivec4(28080,240,74,85),\nivec4(28200,120,64,64),\nivec4(28320,120,65,64),\nivec4(28320,240,55,64),\nivec4(28320,240,55,64),\nivec4(28320,240,71,86),\nivec4(28440,120,62,64),\nivec4(28560,120,59,64),\nivec4(28560,240,77,86),\nivec4(28680,120,62,64),\nivec4(28800,240,48,64),\nivec4(28800,240,48,64),\nivec4(28800,240,60,64),\nivec4(28800,240,76,86),\nivec4(29040,120,59,64),\nivec4(29040,120,74,87),\nivec4(29040,240,52,64),\nivec4(29040,240,52,64),\nivec4(29160,120,57,64),\nivec4(29160,120,72,87),\nivec4(29280,120,55,64),\nivec4(29280,240,55,64),\nivec4(29280,240,55,64),\nivec4(29280,240,74,87),\nivec4(29400,120,53,64),\nivec4(29520,120,52,64),\nivec4(29520,240,53,64),\nivec4(29520,240,53,64),\nivec4(29520,240,67,87),\nivec4(29640,120,50,64),\nivec4(29760,120,48,64),\nivec4(29760,240,52,64),\nivec4(29760,240,52,64),\nivec4(29760,450,72,92),\nivec4(29880,120,55,64),\nivec4(30000,120,52,64),\nivec4(30000,120,55,64),\nivec4(30000,120,55,64),\nivec4(30120,120,53,64),\nivec4(30120,120,53,64),\nivec4(30120,120,55,64),\nivec4(30240,240,48,64),\nivec4(30240,240,52,64),\nivec4(30240,240,52,64),\nivec4(30480,240,50,64),\nivec4(30480,240,50,64),\nivec4(30720,240,48,64),\nivec4(30720,240,48,64),\nivec4(30720,240,60,64),\nivec4(30960,240,55,64),\nivec4(31200,240,48,64),\nivec4(31200,240,48,64),\nivec4(31200,240,64,64),\nivec4(31440,240,60,64),\nivec4(31680,240,43,64),\nivec4(31680,240,43,64),\nivec4(31680,240,62,64),\nivec4(31920,240,50,64),\nivec4(31920,240,50,64),\nivec4(31920,240,55,64),\nivec4(32160,240,47,64),\nivec4(32160,240,47,64),\nivec4(32160,480,65,64),\nivec4(32400,240,43,64),\nivec4(32400,240,43,64),\nivec4(32640,120,64,64),\nivec4(32640,240,48,64),\nivec4(32640,240,48,64),\nivec4(32760,120,60,64),\nivec4(32880,120,55,64),\nivec4(33000,120,60,64),\nivec4(33120,240,48,64),\nivec4(33120,240,48,64),\nivec4(33120,240,64,64),\nivec4(33360,240,60,64),\nivec4(33600,240,43,64),\nivec4(33600,240,43,64),\nivec4(33600,240,62,64),\nivec4(33840,240,50,64),\nivec4(33840,240,50,64),\nivec4(33840,240,55,64),\nivec4(34080,240,47,64),\nivec4(34080,240,47,64),\nivec4(34080,480,65,64),\nivec4(34320,240,43,64),\nivec4(34320,240,43,64),\nivec4(34560,120,52,64),\nivec4(34560,240,52,64),\nivec4(34560,240,52,64),\nivec4(34680,120,55,64),\nivec4(34800,120,60,64),\nivec4(34920,120,59,64),\nivec4(35040,120,60,64),\nivec4(35040,240,52,64),\nivec4(35040,240,52,64),\nivec4(35160,120,55,64),\nivec4(35280,120,52,64),\nivec4(35400,120,55,64),\nivec4(35520,120,53,64),\nivec4(35520,240,41,64),\nivec4(35520,240,41,64),\nivec4(35640,120,57,64),\nivec4(35760,120,60,64),\nivec4(35880,120,59,64),\nivec4(36000,120,60,64),\nivec4(36000,240,53,64),\nivec4(36000,240,53,64),\nivec4(36120,120,57,64),\nivec4(36240,120,53,64),\nivec4(36360,120,57,64),\nivec4(36480,120,55,64),\nivec4(36480,240,43,64),\nivec4(36480,240,43,64),\nivec4(36600,120,60,64),\nivec4(36720,120,59,64),\nivec4(36840,120,57,64),\nivec4(36960,120,55,64),\nivec4(36960,240,55,64),\nivec4(36960,240,55,64),\nivec4(37080,120,53,64),\nivec4(37200,120,52,64),\nivec4(37320,120,50,64),\nivec4(37440,120,48,64),\nivec4(37440,240,48,64),\nivec4(37440,240,48,64),\nivec4(37560,120,55,64),\nivec4(37680,120,52,64),\nivec4(37680,240,55,64),\nivec4(37680,240,55,64),\nivec4(37800,120,55,64),\nivec4(37920,240,48,64),\nivec4(37920,240,52,64),\nivec4(37920,240,52,64),\nivec4(38160,240,55,64),\nivec4(38160,240,55,64),\nivec4(38160,240,79,93),\nivec4(38400,120,52,64),\nivec4(38400,240,48,64),\nivec4(38400,240,48,64),\nivec4(38400,240,70,90),\nivec4(38520,120,55,64),\nivec4(38640,120,60,64),\nivec4(38640,240,69,88),\nivec4(38760,120,59,64),\nivec4(38880,120,60,64),\nivec4(38880,240,52,64),\nivec4(38880,240,52,64),\nivec4(38880,240,70,87),\nivec4(39000,120,55,64),\nivec4(39120,120,52,64),\nivec4(39120,240,79,85),\nivec4(39240,120,55,64),\nivec4(39360,120,53,64),\nivec4(39360,240,41,64),\nivec4(39360,240,41,64),\nivec4(39360,240,70,83),\nivec4(39480,120,57,64),\nivec4(39600,120,60,64),\nivec4(39600,120,69,81),\nivec4(39600,240,53,64),\nivec4(39600,240,53,64),\nivec4(39720,120,59,64),\nivec4(39720,120,67,81),\nivec4(39840,120,60,64),\nivec4(39840,240,48,64),\nivec4(39840,240,48,64),\nivec4(39840,240,69,80),\nivec4(39960,120,57,64),\nivec4(40080,120,53,64),\nivec4(40080,240,45,64),\nivec4(40080,240,45,64),\nivec4(40080,240,72,78),\nivec4(40200,120,57,64),\nivec4(40320,120,57,64),\nivec4(40320,240,41,64),\nivec4(40320,240,41,64),\nivec4(40320,240,75,77),\nivec4(40440,120,60,64),\nivec4(40560,120,65,64),\nivec4(40560,240,72,76),\nivec4(40680,120,64,64),\nivec4(40800,120,65,64),\nivec4(40800,240,45,64),\nivec4(40800,240,45,64),\nivec4(40800,240,69,74),\nivec4(40920,120,60,64),\nivec4(41040,120,57,64),\nivec4(41040,240,75,74),\nivec4(41160,120,60,64),\nivec4(41280,120,58,64),\nivec4(41280,240,46,64),\nivec4(41280,240,46,64),\nivec4(41280,240,75,76),\nivec4(41400,120,62,64),\nivec4(41520,120,65,64),\nivec4(41520,240,58,64),\nivec4(41520,240,58,64),\nivec4(41520,240,74,77),\nivec4(41640,120,64,64),\nivec4(41760,120,65,64),\nivec4(41760,240,53,64),\nivec4(41760,240,53,64),\nivec4(41760,240,74,81),\nivec4(41880,120,62,64),\nivec4(42000,120,58,64),\nivec4(42000,240,50,64),\nivec4(42000,240,50,64),\nivec4(42000,240,74,83),\nivec4(42120,120,62,64),\nivec4(42240,120,50,64),\nivec4(42240,240,46,64),\nivec4(42240,240,46,64),\nivec4(42240,240,67,86),\nivec4(42360,120,53,64),\nivec4(42480,120,58,64),\nivec4(42480,240,77,87),\nivec4(42600,120,57,64),\nivec4(42720,120,58,64),\nivec4(42720,240,55,64),\nivec4(42720,240,55,64),\nivec4(42720,240,76,89),\nivec4(42840,120,53,64),\nivec4(42960,120,50,64),\nivec4(42960,240,74,90),\nivec4(43080,120,53,64),\nivec4(43200,120,52,64),\nivec4(43200,240,49,64),\nivec4(43200,240,49,64),\nivec4(43200,240,69,92),\nivec4(43320,120,55,64),\nivec4(43440,120,58,64),\nivec4(43440,240,79,94),\nivec4(43560,120,57,64),\nivec4(43680,120,58,64),\nivec4(43680,240,55,64),\nivec4(43680,240,55,64),\nivec4(43680,240,77,95),\nivec4(43800,120,55,64),\nivec4(43920,120,52,64),\nivec4(43920,240,76,97),\nivec4(44040,120,55,64),\nivec4(44160,120,49,64),\nivec4(44160,240,81,98),\nivec4(44280,120,52,64),\nivec4(44400,120,53,64),\nivec4(44400,120,53,64),\nivec4(44400,120,57,64),\nivec4(44400,240,73,99),\nivec4(44520,120,52,64),\nivec4(44520,120,52,64),\nivec4(44520,120,55,64),\nivec4(44640,120,57,64),\nivec4(44640,240,53,64),\nivec4(44640,240,53,64),\nivec4(44640,240,74,99),\nivec4(44760,120,53,64),\nivec4(44880,120,50,64),\nivec4(44880,240,50,64),\nivec4(44880,240,50,64),\nivec4(44880,240,77,101),\nivec4(45000,120,53,64),\nivec4(45120,120,57,64),\nivec4(45120,240,57,64),\nivec4(45120,240,57,64),\nivec4(45120,450,76,104),\nivec4(45240,120,62,64),\nivec4(45360,120,61,64),\nivec4(45360,240,45,64),\nivec4(45360,240,45,64),\nivec4(45480,120,58,64),\nivec4(45600,120,57,64),\nivec4(45600,240,47,64),\nivec4(45600,240,47,64),\nivec4(45720,120,55,64),\nivec4(45840,120,53,64),\nivec4(45840,240,49,64),\nivec4(45840,240,49,64),\nivec4(45840,240,69,70),\nivec4(45960,120,52,64),\nivec4(46080,240,50,64),\nivec4(46080,240,50,64),\nivec4(46080,240,50,64),\nivec4(46080,240,70,73),\nivec4(46320,240,57,64),\nivec4(46320,240,69,75),\nivec4(46560,240,50,64),\nivec4(46560,240,50,64),\nivec4(46560,240,65,64),\nivec4(46560,240,68,77),\nivec4(46800,240,62,64),\nivec4(46800,240,69,78),\nivec4(47040,240,45,64),\nivec4(47040,240,45,64),\nivec4(47040,240,64,64),\nivec4(47040,240,79,81),\nivec4(47280,240,57,64),\nivec4(47280,240,76,83),\nivec4(47520,240,57,64),\nivec4(47520,240,57,64),\nivec4(47520,240,73,82),\nivec4(47520,480,67,64),\nivec4(47760,240,69,80),\nivec4(48000,120,65,64),\nivec4(48000,240,50,64),\nivec4(48000,240,50,64),\nivec4(48000,240,70,76),\nivec4(48120,120,62,64),\nivec4(48240,120,57,64),\nivec4(48240,240,69,74),\nivec4(48360,120,62,64),\nivec4(48480,240,50,64),\nivec4(48480,240,50,64),\nivec4(48480,240,65,64),\nivec4(48480,240,68,76),\nivec4(48720,240,62,64),\nivec4(48720,240,69,79),\nivec4(48960,240,45,64),\nivec4(48960,240,45,64),\nivec4(48960,240,64,64),\nivec4(48960,240,79,82),\nivec4(49200,240,57,64),\nivec4(49200,240,76,84),\nivec4(49440,240,57,64),\nivec4(49440,240,57,64),\nivec4(49440,240,73,77),\nivec4(49440,480,67,64),\nivec4(49680,240,69,76),\nivec4(49920,120,53,64),\nivec4(49920,240,53,64),\nivec4(49920,240,53,64),\nivec4(49920,240,74,75),\nivec4(50040,120,57,64),\nivec4(50160,120,62,64),\nivec4(50160,120,77,73),\nivec4(50280,120,61,64),\nivec4(50280,120,76,73),\nivec4(50400,120,62,64),\nivec4(50400,240,50,64),\nivec4(50400,240,50,64),\nivec4(50400,240,74,72),\nivec4(50520,120,57,64),\nivec4(50640,120,53,64),\nivec4(50640,240,74,71),\nivec4(50760,120,57,64),\nivec4(50880,120,55,64),\nivec4(50880,240,46,64),\nivec4(50880,240,46,64),\nivec4(50880,480,67,71),\nivec4(51000,120,58,64),\nivec4(51120,120,62,64),\nivec4(51240,120,61,64),\nivec4(51360,120,62,64),\nivec4(51360,240,43,64),\nivec4(51360,240,43,64),\nivec4(51360,360,76,71),\nivec4(51480,120,58,64),\nivec4(51600,120,55,64),\nivec4(51720,60,77,71),\nivec4(51720,120,58,64),\nivec4(51840,120,57,64),\nivec4(51840,240,45,64),\nivec4(51840,240,45,64),\nivec4(51840,240,77,71),\nivec4(51960,120,62,64),\nivec4(52080,120,61,64),\nivec4(52080,120,76,72),\nivec4(52200,120,58,64),\nivec4(52200,120,74,72),\nivec4(52320,120,57,64),\nivec4(52320,240,45,64),\nivec4(52320,240,45,64),\nivec4(52320,240,76,73),\nivec4(52440,120,55,64),\nivec4(52560,120,53,64),\nivec4(52560,240,73,77),\nivec4(52680,120,52,64),\nivec4(52800,120,50,64),\nivec4(52800,240,50,64),\nivec4(52800,240,50,64),\nivec4(52800,480,74,79),\nivec4(52920,120,57,64),\nivec4(53040,120,53,64),\nivec4(53040,240,45,64),\nivec4(53040,240,45,64),\nivec4(53160,120,57,64),\nivec4(53280,240,41,64),\nivec4(53280,240,41,64),\nivec4(53280,240,50,64),\nivec4(53520,240,45,64),\nivec4(53520,240,45,64),\nivec4(53760,240,50,64),\nivec4(53760,240,50,64),\nivec4(53760,240,62,64),\nivec4(54000,240,57,64),\nivec4(54240,240,50,64),\nivec4(54240,240,50,64),\nivec4(54240,240,65,64),\nivec4(54480,240,62,64),\nivec4(54720,240,49,64),\nivec4(54720,240,49,64),\nivec4(54720,240,64,64),\nivec4(54960,240,52,64),\nivec4(54960,240,52,64),\nivec4(54960,240,57,64),\nivec4(55200,240,49,64),\nivec4(55200,240,49,64),\nivec4(55200,480,67,64),\nivec4(55440,240,45,64),\nivec4(55440,240,45,64),\nivec4(55680,120,65,64),\nivec4(55680,240,50,64),\nivec4(55680,240,50,64),\nivec4(55800,120,62,64),\nivec4(55920,120,57,64),\nivec4(56040,120,62,64),\nivec4(56160,240,50,64),\nivec4(56160,240,50,64),\nivec4(56160,240,65,64),\nivec4(56400,240,62,64),\nivec4(56640,240,49,64),\nivec4(56640,240,49,64),\nivec4(56640,240,64,64),\nivec4(56880,240,52,64),\nivec4(56880,240,52,64),\nivec4(56880,240,57,64),\nivec4(57120,240,49,64),\nivec4(57120,240,49,64),\nivec4(57120,480,67,64),\nivec4(57360,240,45,64),\nivec4(57360,240,45,64),\nivec4(57600,120,53,64),\nivec4(57600,240,41,64),\nivec4(57600,240,41,64),\nivec4(57720,120,57,64),\nivec4(57840,120,62,64),\nivec4(57960,120,61,64),\nivec4(58080,120,62,64),\nivec4(58080,240,53,64),\nivec4(58080,240,53,64),\nivec4(58200,120,57,64),\nivec4(58320,120,53,64),\nivec4(58440,120,57,64),\nivec4(58560,120,55,64),\nivec4(58560,240,43,64),\nivec4(58560,240,43,64),\nivec4(58680,120,58,64),\nivec4(58800,120,62,64),\nivec4(58920,120,61,64),\nivec4(59040,120,62,64),\nivec4(59040,240,55,64),\nivec4(59040,240,55,64),\nivec4(59160,120,58,64),\nivec4(59280,120,55,64),\nivec4(59400,120,58,64),\nivec4(59520,120,57,64),\nivec4(59520,240,45,64),\nivec4(59520,240,45,64),\nivec4(59640,120,62,64),\nivec4(59760,120,61,64),\nivec4(59880,120,58,64),\nivec4(60000,120,57,64),\nivec4(60000,240,57,64),\nivec4(60000,240,57,64),\nivec4(60120,120,55,64),\nivec4(60240,120,53,64),\nivec4(60360,120,52,64),\nivec4(60480,120,50,64),\nivec4(60480,240,50,64),\nivec4(60480,240,50,64),\nivec4(60600,120,57,64),\nivec4(60720,120,53,64),\nivec4(60720,240,45,64),\nivec4(60720,240,45,64),\nivec4(60840,120,57,64),\nivec4(60960,240,41,64),\nivec4(60960,240,41,64),\nivec4(60960,240,50,64),\nivec4(61200,240,45,64),\nivec4(61200,240,45,64),\nivec4(61200,240,69,89),\nivec4(61440,120,62,64),\nivec4(61440,240,50,64),\nivec4(61440,240,50,64),\nivec4(61440,240,77,88),\nivec4(61560,120,65,64),\nivec4(61680,120,69,64),\nivec4(61680,240,76,88),\nivec4(61800,120,67,64),\nivec4(61920,120,69,64),\nivec4(61920,240,41,64),\nivec4(61920,240,41,64),\nivec4(61920,240,74,85),\nivec4(62040,120,65,64),\nivec4(62160,120,62,64),\nivec4(62160,240,77,85),\nivec4(62280,120,65,64),\nivec4(62400,120,59,64),\nivec4(62400,240,43,64),\nivec4(62400,240,43,64),\nivec4(62400,240,68,85),\nivec4(62520,120,62,64),\nivec4(62640,120,67,64),\nivec4(62640,240,67,84),\nivec4(62760,120,65,64),\nivec4(62880,120,67,64),\nivec4(62880,240,47,64),\nivec4(62880,240,47,64),\nivec4(62880,240,67,84),\nivec4(63000,120,62,64),\nivec4(63120,120,59,64),\nivec4(63120,240,79,85),\nivec4(63240,120,62,64),\nivec4(63360,120,60,64),\nivec4(63360,240,48,64),\nivec4(63360,240,48,64),\nivec4(63360,240,75,85),\nivec4(63480,120,63,64),\nivec4(63600,120,67,64),\nivec4(63600,240,74,86),\nivec4(63720,120,65,64),\nivec4(63840,120,67,64),\nivec4(63840,240,51,64),\nivec4(63840,240,51,64),\nivec4(63840,240,72,86),\nivec4(63960,120,63,64),\nivec4(64080,120,60,64),\nivec4(64080,240,74,86),\nivec4(64200,120,63,64),\nivec4(64320,120,57,64),\nivec4(64320,240,41,64),\nivec4(64320,240,41,64),\nivec4(64320,240,75,86),\nivec4(64440,120,60,64),\nivec4(64560,120,65,64),\nivec4(64560,120,77,86),\nivec4(64680,120,63,64),\nivec4(64680,120,79,86),\nivec4(64800,120,65,64),\nivec4(64800,240,45,64),\nivec4(64800,240,45,64),\nivec4(64800,240,77,85),\nivec4(64920,120,60,64),\nivec4(65040,120,57,64),\nivec4(65040,240,75,85),\nivec4(65160,120,60,64),\nivec4(65280,120,58,64),\nivec4(65280,240,46,64),\nivec4(65280,240,46,64),\nivec4(65280,240,74,85),\nivec4(65400,120,62,64),\nivec4(65520,120,65,64),\nivec4(65520,240,72,84),\nivec4(65640,120,63,64),\nivec4(65760,120,65,64),\nivec4(65760,240,58,64),\nivec4(65760,240,58,64),\nivec4(65760,240,70,84),\nivec4(65880,120,62,64),\nivec4(66000,120,58,64),\nivec4(66000,240,79,83),\nivec4(66120,120,62,64),\nivec4(66240,120,58,64),\nivec4(66240,240,52,64),\nivec4(66240,240,52,64),\nivec4(66240,240,72,83),\nivec4(66360,120,64,64),\nivec4(66480,120,67,64),\nivec4(66480,120,70,82),\nivec4(66600,120,65,64),\nivec4(66600,120,69,82),\nivec4(66720,120,67,64),\nivec4(66720,240,48,64),\nivec4(66720,240,48,64),\nivec4(66720,240,70,82),\nivec4(66840,120,64,64),\nivec4(66960,120,58,64),\nivec4(66960,240,67,82),\nivec4(67080,120,64,64),\nivec4(67200,120,57,64),\nivec4(67200,240,45,64),\nivec4(67200,240,45,64),\nivec4(67200,240,72,81),\nivec4(67320,120,60,64),\nivec4(67440,120,65,64),\nivec4(67440,120,74,81),\nivec4(67440,240,41,64),\nivec4(67440,240,41,64),\nivec4(67560,120,63,64),\nivec4(67560,120,75,81),\nivec4(67680,120,65,64),\nivec4(67680,240,46,64),\nivec4(67680,240,46,64),\nivec4(67680,240,74,81),\nivec4(67800,120,62,64),\nivec4(67920,120,67,64),\nivec4(67920,240,43,64),\nivec4(67920,240,43,64),\nivec4(67920,240,70,81),\nivec4(68040,120,62,64),\nivec4(68160,120,64,64),\nivec4(68160,240,48,64),\nivec4(68160,240,48,64),\nivec4(68160,450,67,81),\nivec4(68280,120,65,64),\nivec4(68400,120,64,64),\nivec4(68400,240,43,64),\nivec4(68400,240,43,64),\nivec4(68520,120,62,64),\nivec4(68640,120,60,64),\nivec4(68640,240,52,64),\nivec4(68640,240,52,64),\nivec4(68760,120,58,64),\nivec4(68880,120,57,64),\nivec4(68880,240,48,64),\nivec4(68880,240,48,64),\nivec4(68880,240,72,78),\nivec4(69000,120,55,64),\nivec4(69120,240,41,64),\nivec4(69120,240,41,64),\nivec4(69120,240,53,64),\nivec4(69120,240,72,81),\nivec4(69360,120,69,83),\nivec4(69360,240,48,64),\nivec4(69480,120,70,84),\nivec4(69600,240,53,64),\nivec4(69600,240,53,64),\nivec4(69600,240,57,64),\nivec4(69600,240,72,85),\nivec4(69840,240,53,64),\nivec4(69840,240,77,87),\nivec4(70080,240,52,64),\nivec4(70080,240,52,64),\nivec4(70080,240,55,64),\nivec4(70080,240,76,87),\nivec4(70320,240,48,64),\nivec4(70320,240,55,64),\nivec4(70320,240,55,64),\nivec4(70320,240,74,87),\nivec4(70560,240,52,64),\nivec4(70560,240,52,64),\nivec4(70560,240,72,86),\nivec4(70560,480,58,64),\nivec4(70800,240,48,64),\nivec4(70800,240,48,64),\nivec4(70800,240,72,85),\nivec4(71040,120,57,64),\nivec4(71040,240,41,64),\nivec4(71040,240,41,64),\nivec4(71040,240,72,84),\nivec4(71160,120,53,64),\nivec4(71280,120,48,64),\nivec4(71280,120,69,83),\nivec4(71400,120,53,64),\nivec4(71400,120,70,82),\nivec4(71520,240,53,64),\nivec4(71520,240,53,64),\nivec4(71520,240,57,64),\nivec4(71520,240,72,81),\nivec4(71760,240,53,64),\nivec4(71760,240,77,80),\nivec4(72000,240,52,64),\nivec4(72000,240,52,64),\nivec4(72000,240,55,64),\nivec4(72000,240,76,80),\nivec4(72240,240,48,64),\nivec4(72240,240,55,64),\nivec4(72240,240,55,64),\nivec4(72240,240,74,78),\nivec4(72480,240,52,64),\nivec4(72480,240,52,64),\nivec4(72480,240,72,78),\nivec4(72480,480,58,64),\nivec4(72720,240,48,64),\nivec4(72720,240,48,64),\nivec4(72960,120,57,64),\nivec4(72960,240,45,64),\nivec4(72960,240,45,64),\nivec4(73080,120,60,64),\nivec4(73200,120,65,64),\nivec4(73320,120,64,64),\nivec4(73440,120,65,64),\nivec4(73440,240,57,64),\nivec4(73440,240,57,64),\nivec4(73560,120,60,64),\nivec4(73680,120,57,64),\nivec4(73800,120,60,64),\nivec4(73920,120,58,64),\nivec4(73920,240,46,64),\nivec4(73920,240,46,64),\nivec4(74040,120,62,64),\nivec4(74160,120,65,64),\nivec4(74280,120,64,64),\nivec4(74400,120,65,64),\nivec4(74400,240,58,64),\nivec4(74400,240,58,64),\nivec4(74520,120,62,64),\nivec4(74640,120,58,64),\nivec4(74760,120,62,64),\nivec4(74880,120,60,64),\nivec4(74880,240,48,64),\nivec4(74880,240,48,64),\nivec4(75000,120,65,64),\nivec4(75120,120,64,64),\nivec4(75240,120,62,64),\nivec4(75360,120,60,64),\nivec4(75360,240,60,64),\nivec4(75360,240,60,64),\nivec4(75480,120,58,64),\nivec4(75600,120,57,64),\nivec4(75720,120,55,64),\nivec4(75840,120,53,64),\nivec4(75840,240,53,64),\nivec4(75840,240,53,64),\nivec4(75960,120,60,64),\nivec4(76080,120,57,64),\nivec4(76080,240,48,64),\nivec4(76080,240,48,64),\nivec4(76200,120,60,64),\nivec4(76320,240,45,64),\nivec4(76320,240,45,64),\nivec4(76320,240,53,64),\nivec4(76560,240,48,64),\nivec4(76560,240,48,64),\nivec4(76560,240,72,85),\nivec4(76800,240,41,64),\nivec4(76800,240,41,64),\nivec4(76800,240,53,64),\nivec4(76800,240,72,87),\nivec4(77040,120,69,90),\nivec4(77040,240,48,64),\nivec4(77160,120,70,92),\nivec4(77280,240,53,64),\nivec4(77280,240,53,64),\nivec4(77280,240,57,64),\nivec4(77280,240,72,93),\nivec4(77520,240,53,64),\nivec4(77520,240,77,93),\nivec4(77760,240,48,64),\nivec4(77760,240,48,64),\nivec4(77760,240,55,64),\nivec4(77760,240,76,93),\nivec4(78000,240,48,64),\nivec4(78000,240,74,93),\nivec4(78240,240,52,64),\nivec4(78240,240,52,64),\nivec4(78240,240,72,92),\nivec4(78240,480,58,64),\nivec4(78480,240,72,90),\nivec4(78720,120,57,64),\nivec4(78720,240,41,64),\nivec4(78720,240,41,64),\nivec4(78720,240,72,88),\nivec4(78840,120,53,64),\nivec4(78960,120,48,64),\nivec4(78960,120,69,87),\nivec4(79080,120,53,64),\nivec4(79080,120,70,89),\nivec4(79200,240,53,64),\nivec4(79200,240,53,64),\nivec4(79200,240,57,64),\nivec4(79200,240,72,90),\nivec4(79440,240,53,64),\nivec4(79440,240,77,93),\nivec4(79680,240,52,64),\nivec4(79680,240,52,64),\nivec4(79680,240,55,64),\nivec4(79680,240,76,93),\nivec4(79920,240,48,64),\nivec4(79920,240,55,64),\nivec4(79920,240,55,64),\nivec4(79920,240,74,92),\nivec4(80160,240,52,64),\nivec4(80160,240,52,64),\nivec4(80160,240,72,91),\nivec4(80160,480,58,64),\nivec4(80400,240,48,64),\nivec4(80400,240,48,64),\nivec4(80400,240,72,93),\nivec4(80640,120,57,64),\nivec4(80640,240,45,64),\nivec4(80640,240,45,64),\nivec4(80640,240,77,94),\nivec4(80760,120,60,64),\nivec4(80880,120,65,64),\nivec4(80880,120,81,93),\nivec4(81000,120,64,64),\nivec4(81000,120,79,92),\nivec4(81120,120,65,64),\nivec4(81120,240,57,64),\nivec4(81120,240,57,64),\nivec4(81120,240,77,90),\nivec4(81240,120,60,64),\nivec4(81360,120,57,64),\nivec4(81360,240,72,87),\nivec4(81480,120,60,64),\nivec4(81600,120,58,64),\nivec4(81600,240,46,64),\nivec4(81600,240,46,64),\nivec4(81600,240,74,85),\nivec4(81720,120,62,64),\nivec4(81840,120,65,64),\nivec4(81840,120,74,81),\nivec4(81960,120,64,64),\nivec4(81960,120,72,80),\nivec4(82080,120,65,64),\nivec4(82080,240,58,64),\nivec4(82080,240,58,64),\nivec4(82080,240,74,79),\nivec4(82200,120,62,64),\nivec4(82320,120,58,64),\nivec4(82320,240,67,80),\nivec4(82440,120,62,64),\nivec4(82560,120,60,64),\nivec4(82560,240,48,64),\nivec4(82560,240,48,64),\nivec4(82560,240,67,83),\nivec4(82680,120,65,64),\nivec4(82800,120,64,64),\nivec4(82800,240,69,85),\nivec4(82920,120,62,64),\nivec4(83040,120,60,64),\nivec4(83040,240,60,64),\nivec4(83040,240,60,64),\nivec4(83040,240,70,86),\nivec4(83160,120,58,64),\nivec4(83280,120,57,64),\nivec4(83280,240,72,87),\nivec4(83400,120,55,64),\nivec4(83520,120,53,64),\nivec4(83520,240,53,64),\nivec4(83520,240,53,64),\nivec4(83520,450,69,88),\nivec4(83640,120,70,64),\nivec4(83760,120,69,64),\nivec4(83760,240,48,64),\nivec4(83760,240,48,64),\nivec4(83880,120,67,64),\nivec4(84000,120,65,64),\nivec4(84000,240,45,64),\nivec4(84000,240,45,64),\nivec4(84120,120,64,64),\nivec4(84240,120,62,64),\nivec4(84240,240,41,64),\nivec4(84240,240,41,64),\nivec4(84240,240,77,88),\nivec4(84360,120,60,64),\nivec4(84480,120,58,64),\nivec4(84480,240,46,64),\nivec4(84480,240,46,64),\nivec4(84480,240,74,88),\nivec4(84600,120,62,64),\nivec4(84720,120,65,64),\nivec4(84720,450,70,87),\nivec4(84840,120,64,64),\nivec4(84960,120,65,64),\nivec4(84960,240,50,64),\nivec4(84960,240,50,64),\nivec4(85080,120,62,64),\nivec4(85200,120,58,64),\nivec4(85320,120,62,64),\nivec4(85440,120,59,64),\nivec4(85440,240,47,64),\nivec4(85440,240,47,64),\nivec4(85440,450,79,88),\nivec4(85560,120,62,64),\nivec4(85680,120,67,64),\nivec4(85800,120,65,64),\nivec4(85920,120,67,64),\nivec4(85920,240,43,64),\nivec4(85920,240,43,64),\nivec4(86040,120,62,64),\nivec4(86160,120,59,64),\nivec4(86280,120,62,64),\nivec4(86400,120,60,64),\nivec4(86400,240,48,64),\nivec4(86400,240,48,64),\nivec4(86400,240,76,91),\nivec4(86520,120,64,64),\nivec4(86640,120,67,64),\nivec4(86640,240,72,92),\nivec4(86760,120,65,64),\nivec4(86880,120,67,64),\nivec4(86880,240,52,64),\nivec4(86880,240,52,64),\nivec4(87000,120,64,64),\nivec4(87120,120,60,64),\nivec4(87120,240,76,93),\nivec4(87240,120,64,64),\nivec4(87360,120,61,64),\nivec4(87360,240,49,64),\nivec4(87360,240,49,64),\nivec4(87360,240,81,95),\nivec4(87480,120,64,64),\nivec4(87600,120,69,64),\nivec4(87600,120,73,96),\nivec4(87720,120,67,64),\nivec4(87720,120,71,96),\nivec4(87840,120,69,64),\nivec4(87840,240,45,64),\nivec4(87840,240,45,64),\nivec4(87840,240,73,97),\nivec4(87960,120,64,64),\nivec4(88080,120,61,64),\nivec4(88080,240,76,99),\nivec4(88200,120,64,64),\nivec4(88320,120,62,64),\nivec4(88320,240,50,64),\nivec4(88320,240,50,64),\nivec4(88320,240,77,99),\nivec4(88440,120,53,64),\nivec4(88560,120,58,64),\nivec4(88560,120,74,101),\nivec4(88680,120,57,64),\nivec4(88680,120,73,101),\nivec4(88800,120,58,64),\nivec4(88800,240,50,64),\nivec4(88800,240,50,64),\nivec4(88800,240,74,102),\nivec4(88920,120,53,64),\nivec4(89040,120,50,64),\nivec4(89040,240,77,80),\nivec4(89160,120,53,64),\nivec4(89280,120,52,64),\nivec4(89280,120,67,79),\nivec4(89280,240,52,64),\nivec4(89280,240,52,64),\nivec4(89400,120,55,64),\nivec4(89400,120,69,79),\nivec4(89520,120,60,64),\nivec4(89520,480,70,78),\nivec4(89640,120,58,64),\nivec4(89760,120,60,64),\nivec4(89760,240,52,64),\nivec4(89760,240,52,64),\nivec4(89880,120,55,64),\nivec4(90000,120,52,64),\nivec4(90000,120,69,76),\nivec4(90120,120,55,64),\nivec4(90120,120,67,76),\nivec4(90240,120,53,64),\nivec4(90240,120,69,76),\nivec4(90240,240,53,64),\nivec4(90240,240,53,64),\nivec4(90360,120,60,64),\nivec4(90360,120,65,76),\nivec4(90480,120,58,64),\nivec4(90480,120,74,76),\nivec4(90600,120,57,64),\nivec4(90600,120,72,76),\nivec4(90720,120,55,64),\nivec4(90720,120,70,76),\nivec4(90720,240,46,64),\nivec4(90720,240,46,64),\nivec4(90840,120,53,64),\nivec4(90840,120,69,77),\nivec4(90960,120,52,64),\nivec4(90960,120,67,78),\nivec4(91080,120,50,64),\nivec4(91080,120,65,78),\nivec4(91200,120,48,64),\nivec4(91200,120,69,79),\nivec4(91200,240,48,64),\nivec4(91200,240,48,64),\nivec4(91320,120,65,64),\nivec4(91320,120,65,79),\nivec4(91440,120,64,64),\nivec4(91440,240,50,64),\nivec4(91440,240,50,64),\nivec4(91440,240,67,79),\nivec4(91560,120,62,64),\nivec4(91680,120,60,64),\nivec4(91680,240,52,64),\nivec4(91680,240,52,64),\nivec4(91800,120,58,64),\nivec4(91920,120,57,64),\nivec4(91920,240,48,64),\nivec4(91920,240,48,64),\nivec4(91920,240,72,79),\nivec4(92040,120,55,64),\nivec4(92160,240,41,64),\nivec4(92160,240,41,64),\nivec4(92160,240,53,64),\nivec4(92160,240,72,79),\nivec4(92400,120,69,79),\nivec4(92400,240,48,64),\nivec4(92520,120,70,80),\nivec4(92640,240,41,64),\nivec4(92640,240,41,64),\nivec4(92640,240,57,64),\nivec4(92640,240,72,80),\nivec4(92880,240,53,64),\nivec4(92880,240,77,80),\nivec4(93120,240,55,64),\nivec4(93120,240,70,80),\nivec4(93360,120,52,64),\nivec4(93360,120,52,64),\nivec4(93360,240,48,64),\nivec4(93360,240,69,79),\nivec4(93480,120,50,64),\nivec4(93480,120,50,64),\nivec4(93600,240,52,64),\nivec4(93600,240,52,64),\nivec4(93600,240,67,79),\nivec4(93600,480,58,64),\nivec4(93840,240,48,64),\nivec4(93840,240,48,64),\nivec4(93840,240,72,78),\nivec4(94080,120,57,64),\nivec4(94080,240,41,64),\nivec4(94080,240,41,64),\nivec4(94080,240,72,78),\nivec4(94200,120,53,64),\nivec4(94320,120,48,64),\nivec4(94320,120,69,79),\nivec4(94440,120,53,64),\nivec4(94440,120,70,79),\nivec4(94560,240,53,64),\nivec4(94560,240,53,64),\nivec4(94560,240,57,64),\nivec4(94560,240,72,79),\nivec4(94800,240,53,64),\nivec4(94800,240,77,80),\nivec4(95040,240,55,64),\nivec4(95040,240,70,81),\nivec4(95280,120,52,64),\nivec4(95280,120,52,64),\nivec4(95280,240,48,64),\nivec4(95280,240,69,82),\nivec4(95400,120,50,64),\nivec4(95400,120,50,64),\nivec4(95520,240,52,64),\nivec4(95520,240,52,64),\nivec4(95520,240,67,83),\nivec4(95520,480,58,64),\nivec4(95760,240,48,64),\nivec4(95760,240,48,64),\nivec4(95760,240,72,84),\nivec4(96000,120,57,64),\nivec4(96000,240,45,64),\nivec4(96000,240,45,64),\nivec4(96000,240,77,86),\nivec4(96120,120,60,64),\nivec4(96240,120,65,64),\nivec4(96240,120,81,87),\nivec4(96360,120,64,64),\nivec4(96360,120,79,88),\nivec4(96480,120,65,64),\nivec4(96480,240,57,64),\nivec4(96480,240,57,64),\nivec4(96480,240,77,88),\nivec4(96600,120,60,64),\nivec4(96720,120,57,64),\nivec4(96720,240,72,90),\nivec4(96840,120,60,64),\nivec4(96960,120,58,64),\nivec4(96960,120,74,91),\nivec4(96960,240,46,64),\nivec4(96960,240,46,64),\nivec4(97080,120,62,64),\nivec4(97080,120,72,92),\nivec4(97200,120,65,64),\nivec4(97200,480,74,92),\nivec4(97320,120,64,64),\nivec4(97440,120,65,64),\nivec4(97440,240,58,64),\nivec4(97440,240,58,64),\nivec4(97560,120,62,64),\nivec4(97680,120,58,64),\nivec4(97680,120,76,91),\nivec4(97800,120,62,64),\nivec4(97800,120,77,91),\nivec4(97920,120,60,64),\nivec4(97920,240,48,64),\nivec4(97920,240,48,64),\nivec4(97920,240,69,91),\nivec4(98040,120,65,64),\nivec4(98160,120,64,65),\nivec4(98160,120,67,90),\nivec4(98160,240,45,64),\nivec4(98160,240,45,64),\nivec4(98280,120,62,65),\nivec4(98280,120,65,90),\nivec4(98400,120,60,65),\nivec4(98400,240,46,64),\nivec4(98400,240,46,64),\nivec4(98400,240,67,90),\nivec4(98520,120,58,65),\nivec4(98640,120,57,65),\nivec4(98640,240,48,64),\nivec4(98640,240,48,64),\nivec4(98640,240,76,88),\nivec4(98760,120,55,65),\nivec4(98880,240,41,64),\nivec4(98880,240,41,64),\nivec4(98880,240,53,65),\nivec4(98880,450,65,86),\nivec4(99120,120,64,65),\nivec4(99120,240,53,64),\nivec4(99120,240,53,64),\nivec4(99240,120,62,65),\nivec4(99360,120,60,65),\nivec4(99360,240,48,64),\nivec4(99360,240,48,64),\nivec4(99480,120,58,65),\nivec4(99600,120,57,65),\nivec4(99600,240,45,64),\nivec4(99600,240,45,64),\nivec4(99720,120,55,65),\nivec4(99840,240,77,76),\nivec4(99840,432,53,65),\nivec4(99840,480,41,64),\nivec4(99840,480,41,64),\nivec4(100080,240,72,76),\nivec4(100320,240,81,77),\nivec4(100320,960,53,64),\nivec4(100320,960,53,64),\nivec4(100560,240,77,79),\nivec4(100800,240,79,81),\nivec4(101040,240,72,82),\nivec4(101280,480,52,64),\nivec4(101280,480,52,64),\nivec4(101280,480,82,83),\nivec4(101760,120,69,84),\nivec4(101760,240,53,64),\nivec4(101760,240,53,64),\nivec4(101760,240,77,86),\nivec4(101760,480,53,78),\nivec4(101880,120,72,84),\nivec4(102000,120,77,85),\nivec4(102000,240,52,64),\nivec4(102000,240,52,64),\nivec4(102000,240,72,86),\nivec4(102120,120,76,85),\nivec4(102240,120,77,85),\nivec4(102240,240,50,64),\nivec4(102240,240,50,64),\nivec4(102240,240,81,84),\nivec4(102240,960,65,73),\nivec4(102360,120,72,85),\nivec4(102480,120,69,85),\nivec4(102480,240,53,64),\nivec4(102480,240,53,64),\nivec4(102480,240,77,84),\nivec4(102600,120,72,84),\nivec4(102720,120,70,84),\nivec4(102720,240,46,64),\nivec4(102720,240,46,64),\nivec4(102720,240,79,83),\nivec4(102840,120,74,84),\nivec4(102960,120,79,83),\nivec4(102960,240,50,64),\nivec4(102960,240,50,64),\nivec4(102960,240,72,82),\nivec4(103080,120,77,83),\nivec4(103200,120,79,83),\nivec4(103200,240,43,64),\nivec4(103200,240,43,64),\nivec4(103200,480,64,78),\nivec4(103200,480,82,82),\nivec4(103320,120,76,83),\nivec4(103440,120,72,83),\nivec4(103440,240,48,64),\nivec4(103440,240,48,64),\nivec4(103560,120,76,82),\nivec4(103680,120,69,82),\nivec4(103680,240,41,64),\nivec4(103680,240,41,64),\nivec4(103680,240,53,79),\nivec4(103680,480,77,82),\nivec4(103800,120,72,82),\nivec4(103920,120,77,82),\nivec4(103920,240,48,78),\nivec4(104040,120,76,82),\nivec4(104160,120,77,81),\nivec4(104160,240,45,64),\nivec4(104160,240,45,64),\nivec4(104160,240,57,79),\nivec4(104160,900,77,81),\nivec4(104280,120,72,81),\nivec4(104400,120,69,81),\nivec4(104400,240,53,80),\nivec4(104520,120,72,80),\nivec4(104640,120,70,80),\nivec4(104640,240,48,64),\nivec4(104640,240,48,64),\nivec4(104640,240,55,81),\nivec4(104760,120,74,79),\nivec4(104880,120,79,79),\nivec4(104880,240,48,81),\nivec4(105000,120,77,79),\nivec4(105120,120,79,78),\nivec4(105120,240,46,64),\nivec4(105120,240,46,64),\nivec4(105120,240,76,78),\nivec4(105120,480,58,82),\nivec4(105240,120,76,78),\nivec4(105360,120,72,77),\nivec4(105360,240,72,77),\nivec4(105480,120,76,77),\nivec4(105600,120,57,81),\nivec4(105600,226,65,77),\nivec4(105600,240,45,64),\nivec4(105600,240,45,64),\nivec4(105600,240,77,76),\nivec4(105720,120,60,81),\nivec4(105840,120,65,81),\nivec4(105840,226,72,75),\nivec4(105960,120,64,81),\nivec4(106080,120,65,81),\nivec4(106080,216,65,74),\nivec4(106080,240,57,64),\nivec4(106080,240,57,64),\nivec4(106200,120,60,81),\nivec4(106320,120,57,81),\nivec4(106320,216,77,76),\nivec4(106440,120,60,81),\nivec4(106560,120,58,81),\nivec4(106560,226,67,75),\nivec4(106560,240,58,64),\nivec4(106560,240,58,64),\nivec4(106680,120,62,81),\nivec4(106800,120,65,80),\nivec4(106800,216,77,80),\nivec4(106920,120,64,80),\nivec4(107040,120,65,80),\nivec4(107040,216,67,80),\nivec4(107040,240,55,64),\nivec4(107040,240,55,64),\nivec4(107160,120,62,80),\nivec4(107280,120,58,81),\nivec4(107280,480,77,73),\nivec4(107400,120,62,81),\nivec4(107520,240,60,64),\nivec4(107520,240,60,64),\nivec4(107520,240,60,81),\nivec4(107760,120,76,72),\nivec4(107760,240,58,64),\nivec4(107760,240,58,64),\nivec4(107760,240,58,81),\nivec4(107880,120,74,72),\nivec4(108000,120,72,72),\nivec4(108000,240,60,64),\nivec4(108000,240,60,64),\nivec4(108000,240,60,81),\nivec4(108120,120,70,72),\nivec4(108240,120,69,72),\nivec4(108240,240,48,64),\nivec4(108240,240,48,64),\nivec4(108240,240,48,82),\nivec4(108240,480,79,89),\nivec4(108360,120,67,72),\nivec4(108480,240,53,64),\nivec4(108480,240,53,64),\nivec4(108480,240,53,65),\nivec4(108480,240,69,71),\nivec4(108720,120,77,90),\nivec4(108720,240,52,64),\nivec4(108720,240,52,64),\nivec4(108720,240,52,64),\nivec4(108720,240,72,71),\nivec4(108840,120,76,90),\nivec4(108960,120,74,90),\nivec4(108960,240,53,64),\nivec4(108960,240,53,64),\nivec4(108960,240,53,64),\nivec4(109080,120,72,90),\nivec4(109200,120,71,89),\nivec4(109200,240,50,64),\nivec4(109200,240,50,64),\nivec4(109200,240,50,66),\nivec4(109200,480,81,72),\nivec4(109320,120,69,89),\nivec4(109440,240,55,64),\nivec4(109440,240,55,64),\nivec4(109440,240,55,67),\nivec4(109440,240,71,89),\nivec4(109680,120,79,72),\nivec4(109680,226,74,89),\nivec4(109680,240,53,64),\nivec4(109680,240,53,64),\nivec4(109680,240,53,68),\nivec4(109800,120,77,72),\nivec4(109920,120,76,72),\nivec4(109920,240,55,64),\nivec4(109920,240,55,64),\nivec4(109920,240,55,69),\nivec4(110040,120,74,73),\nivec4(110160,120,72,73),\nivec4(110160,240,52,64),\nivec4(110160,240,52,64),\nivec4(110160,240,52,70),\nivec4(110160,240,79,89),\nivec4(110280,120,71,73),\nivec4(110400,240,57,64),\nivec4(110400,240,57,64),\nivec4(110400,240,57,70),\nivec4(110400,240,76,89),\nivec4(110400,360,72,73),\nivec4(110640,120,81,90),\nivec4(110640,240,53,64),\nivec4(110640,240,53,64),\nivec4(110640,240,53,71),\nivec4(110760,120,74,74),\nivec4(110760,120,79,91),\nivec4(110880,120,77,91),\nivec4(110880,240,55,64),\nivec4(110880,240,55,64),\nivec4(110880,240,55,72),\nivec4(110880,360,71,74),\nivec4(111000,120,76,92),\nivec4(111120,120,74,92),\nivec4(111120,240,43,64),\nivec4(111120,240,43,64),\nivec4(111120,240,55,72),\nivec4(111240,120,72,75),\nivec4(111240,120,72,92),\nivec4(111360,120,52,89),\nivec4(111360,240,72,93),\nivec4(111360,450,48,64),\nivec4(111360,450,48,64),\nivec4(111360,480,72,76),\nivec4(111480,120,55,89),\nivec4(111600,120,60,89),\nivec4(111600,240,67,93),\nivec4(111720,120,59,89),\nivec4(111840,120,60,89),\nivec4(111840,240,76,94),\nivec4(111840,960,72,78),\nivec4(111960,120,55,89),\nivec4(112080,120,52,89),\nivec4(112080,240,52,64),\nivec4(112080,240,52,64),\nivec4(112080,240,72,94),\nivec4(112200,120,55,89),\nivec4(112320,120,53,89),\nivec4(112320,240,74,95),\nivec4(112320,450,53,64),\nivec4(112320,450,53,64),\nivec4(112440,120,57,89),\nivec4(112560,120,62,89),\nivec4(112560,240,67,95),\nivec4(112680,120,60,89),\nivec4(112800,120,62,88),\nivec4(112800,480,71,83),\nivec4(112800,480,77,95),\nivec4(112920,120,59,88),\nivec4(113040,120,55,88),\nivec4(113040,240,55,64),\nivec4(113040,240,55,64),\nivec4(113160,120,59,87),\nivec4(113280,120,64,95),\nivec4(113280,240,60,64),\nivec4(113280,240,60,64),\nivec4(113280,240,60,87),\nivec4(113280,240,72,84),\nivec4(113400,120,67,95),\nivec4(113520,120,72,95),\nivec4(113520,240,48,66),\nivec4(113520,240,59,64),\nivec4(113520,240,59,64),\nivec4(113520,240,67,84),\nivec4(113640,120,71,95),\nivec4(113760,120,72,94),\nivec4(113760,240,57,64),\nivec4(113760,240,57,64),\nivec4(113760,240,76,84),\nivec4(113760,900,60,67),\nivec4(113880,120,67,94),\nivec4(114000,120,64,94),\nivec4(114000,240,60,64),\nivec4(114000,240,60,64),\nivec4(114000,240,72,84),\nivec4(114120,120,67,94),\nivec4(114240,120,65,94),\nivec4(114240,240,53,64),\nivec4(114240,240,53,64),\nivec4(114240,240,74,84),\nivec4(114360,120,69,93),\nivec4(114480,120,74,93),\nivec4(114480,240,57,64),\nivec4(114480,240,57,64),\nivec4(114480,240,67,84),\nivec4(114600,120,72,92),\nivec4(114720,120,74,92),\nivec4(114720,240,50,64),\nivec4(114720,240,50,64),\nivec4(114720,480,59,64),\nivec4(114720,480,77,78),\nivec4(114840,120,71,91),\nivec4(114960,120,67,91),\nivec4(114960,240,55,64),\nivec4(114960,240,55,64),\nivec4(115080,120,71,90),\nivec4(115200,120,76,71),\nivec4(115200,240,48,64),\nivec4(115200,240,48,64),\nivec4(115200,240,60,64),\nivec4(115200,240,72,89),\nivec4(115320,120,79,70),\nivec4(115440,120,84,69),\nivec4(115440,240,55,64),\nivec4(115440,240,60,88),\nivec4(115560,120,83,69),\nivec4(115680,120,84,67),\nivec4(115680,240,52,64),\nivec4(115680,240,52,64),\nivec4(115680,240,64,64),\nivec4(115680,900,72,86),\nivec4(115800,120,79,67),\nivec4(115920,120,76,65),\nivec4(115920,240,60,64),\nivec4(116040,120,79,64),\nivec4(116160,120,77,63),\nivec4(116160,240,50,64),\nivec4(116160,240,50,64),\nivec4(116160,240,62,64),\nivec4(116280,120,81,62),\nivec4(116400,120,86,61),\nivec4(116400,240,55,64),\nivec4(116520,120,84,61),\nivec4(116640,120,86,59),\nivec4(116640,226,71,84),\nivec4(116640,240,43,64),\nivec4(116640,240,43,64),\nivec4(116640,480,65,64),\nivec4(116760,120,83,59),\nivec4(116880,120,79,58),\nivec4(116880,216,79,83),\nivec4(117000,120,83,57),\nivec4(117120,120,52,73),\nivec4(117120,240,52,66),\nivec4(117120,240,52,66),\nivec4(117120,240,72,83),\nivec4(117120,240,84,57),\nivec4(117240,120,55,74),\nivec4(117360,120,60,75),\nivec4(117360,240,79,55),\nivec4(117480,120,59,76),\nivec4(117600,120,60,77),\nivec4(117600,240,48,68),\nivec4(117600,240,48,68),\nivec4(117600,240,70,55),\nivec4(117720,120,55,78),\nivec4(117840,120,52,79),\nivec4(117840,240,79,82),\nivec4(117960,120,55,81),\nivec4(118080,120,53,81),\nivec4(118080,240,53,69),\nivec4(118080,240,53,69),\nivec4(118080,240,69,82),\nivec4(118200,120,57,82),\nivec4(118320,120,60,84),\nivec4(118320,240,77,57),\nivec4(118440,120,59,85),\nivec4(118560,120,60,86),\nivec4(118560,240,45,70),\nivec4(118560,240,45,70),\nivec4(118560,240,65,58),\nivec4(118680,120,57,87),\nivec4(118800,120,53,87),\nivec4(118800,240,81,81),\nivec4(118920,120,57,88),\nivec4(119040,120,54,89),\nivec4(119040,240,54,72),\nivec4(119040,240,54,72),\nivec4(119040,240,74,59),\nivec4(119040,240,74,81),\nivec4(119160,120,57,90),\nivec4(119280,120,62,91),\nivec4(119280,240,81,60),\nivec4(119400,120,60,92),\nivec4(119520,120,62,92),\nivec4(119520,240,50,74),\nivec4(119520,240,50,74),\nivec4(119520,240,72,62),\nivec4(119640,120,57,92),\nivec4(119760,120,54,92),\nivec4(119760,240,81,82),\nivec4(119880,120,57,92),\nivec4(120000,120,55,92),\nivec4(120000,240,55,74),\nivec4(120000,240,55,74),\nivec4(120000,240,71,83),\nivec4(120120,120,59,92),\nivec4(120240,120,62,92),\nivec4(120240,240,79,65),\nivec4(120360,120,60,92),\nivec4(120480,120,62,92),\nivec4(120480,240,47,77),\nivec4(120480,240,47,77),\nivec4(120480,240,67,66),\nivec4(120600,120,59,93),\nivec4(120720,120,55,93),\nivec4(120720,240,83,84),\nivec4(120840,120,59,93),\nivec4(120960,120,56,93),\nivec4(120960,240,56,81),\nivec4(120960,240,56,81),\nivec4(120960,240,76,67),\nivec4(120960,240,76,85),\nivec4(121080,120,59,93),\nivec4(121200,120,64,94),\nivec4(121200,240,83,68),\nivec4(121320,120,62,94),\nivec4(121440,120,64,95),\nivec4(121440,240,52,84),\nivec4(121440,240,52,84),\nivec4(121440,240,74,69),\nivec4(121560,120,59,95),\nivec4(121680,120,56,95),\nivec4(121680,240,83,88),\nivec4(121800,120,59,95),\nivec4(121920,120,57,95),\nivec4(121920,240,57,86),\nivec4(121920,240,57,86),\nivec4(121920,240,72,89),\nivec4(122040,120,60,95),\nivec4(122160,120,64,96),\nivec4(122160,240,81,70),\nivec4(122280,120,62,96),\nivec4(122400,120,64,96),\nivec4(122400,240,48,87),\nivec4(122400,240,48,87),\nivec4(122400,240,69,70),\nivec4(122520,120,60,96),\nivec4(122640,120,57,93),\nivec4(122640,240,76,71),\nivec4(122640,456,72,92),\nivec4(122760,120,60,92),\nivec4(122880,120,77,71),\nivec4(122880,240,62,88),\nivec4(122880,480,50,90),\nivec4(122880,480,50,90),\nivec4(123000,120,81,72),\nivec4(123120,120,86,72),\nivec4(123120,216,77,94),\nivec4(123120,240,59,83),\nivec4(123240,120,84,73),\nivec4(123360,120,86,74),\nivec4(123360,240,55,75),\nivec4(123360,696,71,94),\nivec4(123480,120,83,75),\nivec4(123600,120,81,75),\nivec4(123600,240,47,64),\nivec4(123600,240,47,64),\nivec4(123600,240,59,65),\nivec4(123720,120,83,75),\nivec4(123840,120,76,75),\nivec4(123840,240,60,66),\nivec4(123840,480,48,64),\nivec4(123840,480,48,64),\nivec4(123960,120,79,75),\nivec4(124080,120,84,75),\nivec4(124080,216,64,96),\nivec4(124080,240,57,67),\nivec4(124200,120,83,76),\nivec4(124320,120,84,76),\nivec4(124320,240,53,67),\nivec4(124320,696,69,96),\nivec4(124440,120,81,77),\nivec4(124560,120,77,78),\nivec4(124560,240,45,64),\nivec4(124560,240,45,64),\nivec4(124560,240,57,68),\nivec4(124680,120,81,78),\nivec4(124800,108,74,79),\nivec4(124800,240,59,69),\nivec4(124800,480,47,64),\nivec4(124800,480,47,64),\nivec4(124920,108,78,79),\nivec4(125040,108,83,79),\nivec4(125040,216,74,92),\nivec4(125040,240,56,70),\nivec4(125160,108,81,79),\nivec4(125280,108,83,80),\nivec4(125280,240,52,70),\nivec4(125280,432,68,80),\nivec4(125400,108,80,80),\nivec4(125520,108,76,80),\nivec4(125520,240,52,64),\nivec4(125520,240,52,64),\nivec4(125520,240,62,70),\nivec4(125640,108,80,80),\nivec4(125760,108,72,80),\nivec4(125760,240,60,70),\nivec4(125760,240,69,89),\nivec4(125760,480,45,64),\nivec4(125760,480,45,64),\nivec4(125880,108,76,80),\nivec4(126000,108,81,80),\nivec4(126000,240,59,70),\nivec4(126000,240,64,89),\nivec4(126120,108,80,79),\nivec4(126240,108,81,79),\nivec4(126240,240,57,70),\nivec4(126240,240,72,89),\nivec4(126360,108,76,79),\nivec4(126480,108,72,79),\nivec4(126480,240,48,64),\nivec4(126480,240,48,64),\nivec4(126480,240,60,71),\nivec4(126480,240,69,89),\nivec4(126600,108,76,79),\nivec4(126720,120,71,79),\nivec4(126720,216,62,72),\nivec4(126720,240,71,89),\nivec4(126720,480,50,64),\nivec4(126720,480,50,64),\nivec4(126840,120,74,79),\nivec4(126960,120,80,79),\nivec4(126960,216,59,72),\nivec4(126960,240,64,89),\nivec4(127080,120,78,79),\nivec4(127200,120,80,78),\nivec4(127200,216,64,72),\nivec4(127200,480,74,88),\nivec4(127320,120,83,78),\nivec4(127440,120,76,78),\nivec4(127440,216,52,71),\nivec4(127440,240,52,64),\nivec4(127440,240,52,64),\nivec4(127560,120,80,78),\nivec4(127680,108,72,78),\nivec4(127680,216,57,71),\nivec4(127680,240,45,64),\nivec4(127680,240,45,64),\nivec4(127680,240,69,87),\nivec4(127800,108,76,77),\nivec4(127920,108,81,77),\nivec4(127920,216,60,71),\nivec4(127920,240,48,64),\nivec4(127920,240,48,64),\nivec4(127920,240,64,87),\nivec4(128040,108,80,77),\nivec4(128160,108,81,77),\nivec4(128160,216,65,71),\nivec4(128160,240,53,64),\nivec4(128160,240,53,64),\nivec4(128160,240,72,87),\nivec4(128280,108,76,76),\nivec4(128400,108,72,76),\nivec4(128400,216,64,70),\nivec4(128400,240,52,64),\nivec4(128400,240,52,64),\nivec4(128400,240,69,86),\nivec4(128520,108,76,76),\nivec4(128640,120,71,76),\nivec4(128640,216,62,70),\nivec4(128640,240,71,86),\nivec4(128640,432,50,80),\nivec4(128640,432,50,80),\nivec4(128760,120,74,76),\nivec4(128880,120,80,75),\nivec4(128880,216,59,69),\nivec4(128880,240,64,86),\nivec4(129000,120,78,75),\nivec4(129120,120,80,75),\nivec4(129120,216,64,68),\nivec4(129120,432,52,80),\nivec4(129120,432,52,80),\nivec4(129120,480,74,85),\nivec4(129240,120,83,75),\nivec4(129360,120,76,75),\nivec4(129360,216,52,68),\nivec4(129480,120,80,74),\nivec4(129600,108,57,70),\nivec4(129600,216,72,84),\nivec4(129600,240,57,83),\nivec4(129600,240,57,83),\nivec4(129600,432,81,74),\nivec4(129720,108,60,75),\nivec4(129840,108,64,79),\nivec4(129840,216,69,83),\nivec4(129840,240,52,83),\nivec4(129840,240,52,83),\nivec4(129960,108,62,81),\nivec4(130080,108,64,82),\nivec4(130080,226,72,83),\nivec4(130080,240,57,84),\nivec4(130080,240,57,84),\nivec4(130200,108,60,83),\nivec4(130320,108,57,85),\nivec4(130320,216,69,84),\nivec4(130320,238,55,84),\nivec4(130320,238,55,84),\nivec4(130440,108,60,86),\nivec4(130560,120,54,87),\nivec4(130560,240,54,84),\nivec4(130560,240,54,84),\nivec4(130560,864,74,85),\nivec4(130680,120,57,87),\nivec4(130680,120,74,72),\nivec4(130800,120,62,87),\nivec4(130800,120,78,72),\nivec4(130800,240,57,84),\nivec4(130800,240,57,84),\nivec4(130920,120,60,88),\nivec4(130920,120,81,72),\nivec4(131040,120,62,88),\nivec4(131040,240,54,84),\nivec4(131040,240,54,84),\nivec4(131040,240,84,71),\nivec4(131160,120,57,88),\nivec4(131280,120,54,89),\nivec4(131280,120,82,71),\nivec4(131280,240,50,83),\nivec4(131280,240,50,83),\nivec4(131400,120,57,89),\nivec4(131400,120,81,71),\nivec4(131520,120,55,89),\nivec4(131520,216,74,90),\nivec4(131520,240,55,82),\nivec4(131520,240,55,82),\nivec4(131520,480,82,70),\nivec4(131640,120,58,89),\nivec4(131760,120,62,90),\nivec4(131760,216,67,91),\nivec4(131760,240,50,80),\nivec4(131760,240,50,80),\nivec4(131880,120,60,90),\nivec4(132000,120,62,91),\nivec4(132000,240,55,79),\nivec4(132000,240,55,79),\nivec4(132000,432,70,92),\nivec4(132120,120,58,91),\nivec4(132240,120,55,91),\nivec4(132240,226,79,69),\nivec4(132240,240,53,78),\nivec4(132240,240,53,78),\nivec4(132360,120,58,91),\nivec4(132480,120,52,91),\nivec4(132480,240,52,76),\nivec4(132480,240,52,76),\nivec4(132480,1080,72,68),\nivec4(132600,120,55,91),\nivec4(132600,120,72,94),\nivec4(132720,120,60,90),\nivec4(132720,120,76,95),\nivec4(132720,240,55,75),\nivec4(132720,240,55,75),\nivec4(132840,120,58,90),\nivec4(132840,120,79,95),\nivec4(132960,120,60,90),\nivec4(132960,240,52,74),\nivec4(132960,240,52,74),\nivec4(132960,240,82,95),\nivec4(133080,120,55,90),\nivec4(133200,120,53,89),\nivec4(133200,120,81,95),\nivec4(133200,240,48,72),\nivec4(133200,240,48,72),\nivec4(133320,120,55,89),\nivec4(133320,120,79,95),\nivec4(133440,240,53,89),\nivec4(133440,480,53,71),\nivec4(133440,480,53,71),\nivec4(133440,480,81,95),\nivec4(133560,120,72,77),\nivec4(133680,120,77,77),\nivec4(133680,240,48,76),\nivec4(133800,120,76,78),\nivec4(133920,120,77,78),\nivec4(133920,240,57,77),\nivec4(133920,960,77,94),\nivec4(134040,120,72,78),\nivec4(134160,120,69,78),\nivec4(134160,240,50,64),\nivec4(134160,240,50,64),\nivec4(134160,240,53,77),\nivec4(134280,120,72,79),\nivec4(134400,120,70,79),\nivec4(134400,240,55,77),\nivec4(134400,480,55,64),\nivec4(134400,480,55,64),\nivec4(134520,120,74,79),\nivec4(134640,120,79,80),\nivec4(134640,226,48,77),\nivec4(134760,120,77,80),\nivec4(134880,120,79,80),\nivec4(134880,432,58,76),\nivec4(134880,480,76,93),\nivec4(135000,120,76,80),\nivec4(135120,120,72,80),\nivec4(135120,216,48,81),\nivec4(135120,216,48,81),\nivec4(135240,120,76,80),\nivec4(135360,120,57,64),\nivec4(135360,120,69,92),\nivec4(135360,240,53,81),\nivec4(135360,240,53,81),\nivec4(135360,480,77,80),\nivec4(135480,120,53,68),\nivec4(135480,120,72,92),\nivec4(135600,120,48,69),\nivec4(135600,120,77,92),\nivec4(135600,240,45,80),\nivec4(135600,240,45,80),\nivec4(135720,120,53,69),\nivec4(135720,120,76,92),\nivec4(135840,120,77,91),\nivec4(135840,240,50,80),\nivec4(135840,240,50,80),\nivec4(135840,240,57,70),\nivec4(135840,480,65,79),\nivec4(135960,120,72,91),\nivec4(136080,120,69,91),\nivec4(136080,240,52,79),\nivec4(136080,240,52,79),\nivec4(136080,240,53,70),\nivec4(136200,120,72,91),\nivec4(136320,120,70,91),\nivec4(136320,240,46,78),\nivec4(136320,240,46,78),\nivec4(136320,240,55,70),\nivec4(136440,120,74,91),\nivec4(136560,120,79,90),\nivec4(136560,226,48,72),\nivec4(136680,120,77,90),\nivec4(136800,120,79,90),\nivec4(136800,240,76,79),\nivec4(136800,432,58,73),\nivec4(136920,120,76,90),\nivec4(137040,120,72,90),\nivec4(137040,240,48,76),\nivec4(137040,240,48,76),\nivec4(137040,240,72,79),\nivec4(137160,120,76,90),\nivec4(137280,120,57,85),\nivec4(137280,240,41,76),\nivec4(137280,240,41,76),\nivec4(137280,240,65,78),\nivec4(137280,240,77,89),\nivec4(137400,120,60,96),\nivec4(137520,120,65,96),\nivec4(137520,240,72,89),\nivec4(137640,120,64,95),\nivec4(137760,120,65,95),\nivec4(137760,240,65,92),\nivec4(137760,450,45,76),\nivec4(137760,450,45,76),\nivec4(137880,120,60,95),\nivec4(138000,120,57,95),\nivec4(138000,240,77,77),\nivec4(138120,120,60,95),\nivec4(138240,120,58,96),\nivec4(138240,240,46,76),\nivec4(138240,240,46,76),\nivec4(138240,240,67,76),\nivec4(138360,120,60,96),\nivec4(138480,120,65,96),\nivec4(138480,240,77,94),\nivec4(138600,120,64,96),\nivec4(138720,120,65,95),\nivec4(138720,240,43,75),\nivec4(138720,240,43,75),\nivec4(138720,240,67,95),\nivec4(138840,120,62,95),\nivec4(138960,120,58,94),\nivec4(138960,360,77,74),\nivec4(139080,120,62,94),\nivec4(139200,120,60,93),\nivec4(139200,240,48,74),\nivec4(139200,240,48,74),\nivec4(139320,120,65,93),\nivec4(139320,120,81,64),\nivec4(139440,120,64,93),\nivec4(139440,120,79,64),\nivec4(139440,240,50,74),\nivec4(139440,240,50,74),\nivec4(139440,360,70,96),\nivec4(139560,120,62,93),\nivec4(139560,120,77,64),\nivec4(139680,120,60,92),\nivec4(139680,240,52,73),\nivec4(139680,240,52,73),\nivec4(139680,600,76,64),\nivec4(139800,120,58,92),\nivec4(139800,120,74,96),\nivec4(139920,120,57,91),\nivec4(139920,120,72,96),\nivec4(139920,240,48,73),\nivec4(139920,240,48,73),\nivec4(140040,120,55,90),\nivec4(140040,120,70,96),\nivec4(140160,240,53,72),\nivec4(140160,240,53,72),\nivec4(140160,240,53,90),\nivec4(140160,588,69,96),\nivec4(140280,120,81,64),\nivec4(140400,120,79,64),\nivec4(140400,240,57,89),\nivec4(140520,120,81,64),\nivec4(140640,240,46,72),\nivec4(140640,240,46,72),\nivec4(140640,240,58,88),\nivec4(140640,600,74,64),\nivec4(140760,108,74,94),\nivec4(140880,108,72,93),\nivec4(140880,240,50,85),\nivec4(141000,108,74,93),\nivec4(141120,240,52,70),\nivec4(141120,240,52,70),\nivec4(141120,240,52,83),\nivec4(141120,588,67,92),\nivec4(141240,120,70,64),\nivec4(141360,120,67,64),\nivec4(141360,240,55,80),\nivec4(141480,120,70,64),\nivec4(141600,240,45,70),\nivec4(141600,240,45,70),\nivec4(141600,240,57,64),\nivec4(141600,600,72,64),\nivec4(141720,108,64,89),\nivec4(141840,108,60,88),\nivec4(141840,240,48,64),\nivec4(141960,108,64,87),\nivec4(142080,240,50,64),\nivec4(142080,240,50,69),\nivec4(142080,240,50,69),\nivec4(142080,600,65,87),\nivec4(142200,120,77,66),\nivec4(142320,120,74,66),\nivec4(142320,240,53,64),\nivec4(142440,120,69,66),\nivec4(142560,240,43,68),\nivec4(142560,240,43,68),\nivec4(142560,240,55,64),\nivec4(142560,600,70,66),\nivec4(142680,120,70,85),\nivec4(142800,120,67,85),\nivec4(142800,240,58,64),\nivec4(142920,120,62,85),\nivec4(143040,120,60,64),\nivec4(143040,240,48,68),\nivec4(143040,240,48,68),\nivec4(143040,600,64,84),\nivec4(143160,120,58,64),\nivec4(143160,120,74,66),\nivec4(143280,120,57,64),\nivec4(143280,120,72,67),\nivec4(143400,120,55,64),\nivec4(143400,120,70,67),\nivec4(143520,120,65,64),\nivec4(143520,240,41,67),\nivec4(143520,240,41,67),\nivec4(143520,600,69,67),\nivec4(143640,120,63,64),\nivec4(143640,120,67,83),\nivec4(143760,120,62,64),\nivec4(143760,120,65,83),\nivec4(143880,120,60,64),\nivec4(143880,120,63,83),\nivec4(144000,240,46,68),\nivec4(144000,240,46,68),\nivec4(144000,240,58,64),\nivec4(144000,240,62,83),\nivec4(144120,120,72,69),\nivec4(144240,120,70,69),\nivec4(144240,240,62,64),\nivec4(144240,240,65,82),\nivec4(144360,120,69,70),\nivec4(144480,120,67,81),\nivec4(144480,240,55,64),\nivec4(144480,600,70,70),\nivec4(144600,120,65,81),\nivec4(144720,120,64,80),\nivec4(144720,240,43,70),\nivec4(144720,240,43,70),\nivec4(144720,240,58,64),\nivec4(144840,120,62,79),\nivec4(144960,114,64,79),\nivec4(144960,240,48,70),\nivec4(144960,240,48,70),\nivec4(144960,240,60,64),\nivec4(145080,108,74,79),\nivec4(145080,120,74,72),\nivec4(145200,108,72,78),\nivec4(145200,120,72,72),\nivec4(145200,240,64,64),\nivec4(145320,108,70,78),\nivec4(145320,120,70,73),\nivec4(145440,108,69,78),\nivec4(145440,226,69,73),\nivec4(145440,240,65,64),\nivec4(145560,108,67,77),\nivec4(145680,108,65,77),\nivec4(145680,240,53,70),\nivec4(145680,240,53,70),\nivec4(145680,240,57,64),\nivec4(145680,360,81,73),\nivec4(145800,108,64,77),\nivec4(145920,120,62,77),\nivec4(145920,240,46,70),\nivec4(145920,240,46,70),\nivec4(145920,240,58,64),\nivec4(146040,120,70,77),\nivec4(146040,120,79,74),\nivec4(146160,120,69,77),\nivec4(146160,120,76,74),\nivec4(146160,240,43,70),\nivec4(146160,240,43,70),\nivec4(146160,240,55,64),\nivec4(146280,120,67,77),\nivec4(146280,120,77,74),\nivec4(146400,240,48,70),\nivec4(146400,240,48,70),\nivec4(146400,240,60,64),\nivec4(146400,360,67,76),\nivec4(146400,360,76,74),\nivec4(146640,240,46,70),\nivec4(146640,240,46,70),\nivec4(146640,240,58,64),\nivec4(146760,120,65,76),\nivec4(146760,120,77,75),\nivec4(146880,120,57,70),\nivec4(146880,240,45,70),\nivec4(146880,240,45,70),\nivec4(146880,240,77,75),\nivec4(146880,480,65,76),\nivec4(147000,120,60,74),\nivec4(147120,120,65,77),\nivec4(147120,240,72,76),\nivec4(147240,120,64,79),\nivec4(147360,120,65,81),\nivec4(147360,240,50,72),\nivec4(147360,240,50,72),\nivec4(147360,240,81,76),\nivec4(147360,960,77,75),\nivec4(147480,120,60,83),\nivec4(147600,120,57,86),\nivec4(147600,240,77,77),\nivec4(147720,120,60,87),\nivec4(147840,120,58,88),\nivec4(147840,240,46,73),\nivec4(147840,240,46,73),\nivec4(147840,240,79,77),\nivec4(147960,120,62,89),\nivec4(148080,120,67,90),\nivec4(148080,240,76,78),\nivec4(148200,120,65,91),\nivec4(148320,120,67,91),\nivec4(148320,240,48,76),\nivec4(148320,240,48,76),\nivec4(148320,480,76,74),\nivec4(148320,480,82,78),\nivec4(148440,120,64,92),\nivec4(148560,120,60,92),\nivec4(148680,120,64,92),\nivec4(148800,120,62,92),\nivec4(148800,240,50,78),\nivec4(148800,240,50,78),\nivec4(148800,240,77,75),\nivec4(148800,480,81,78),\nivec4(148920,120,64,92),\nivec4(149040,120,65,92),\nivec4(149040,240,72,76),\nivec4(149160,120,64,92),\nivec4(149280,120,65,91),\nivec4(149280,240,48,78),\nivec4(149280,240,48,78),\nivec4(149280,240,81,76),\nivec4(149280,912,77,78),\nivec4(149400,120,60,91),\nivec4(149520,120,57,90),\nivec4(149520,238,77,77),\nivec4(149640,120,60,90),\nivec4(149760,120,58,90),\nivec4(149760,240,46,76),\nivec4(149760,240,46,76),\nivec4(149760,240,79,78),\nivec4(149880,120,62,90),\nivec4(150000,120,67,90),\nivec4(150000,240,72,78),\nivec4(150120,120,65,89),\nivec4(150240,120,67,86),\nivec4(150240,240,48,73),\nivec4(150240,240,48,73),\nivec4(150240,432,76,76),\nivec4(150240,480,70,78),\nivec4(150360,120,64,84),\nivec4(150480,120,60,81),\nivec4(150600,120,64,81),\nivec4(150720,864,77,75),\nivec4(150720,960,41,73),\nivec4(150720,960,41,73),\nivec4(150720,960,53,64),\nivec4(150720,960,69,77)\n);\n#elif TUNE == 8\nfloat speed = 0.6;\nconst ivec4 data[] = ivec4[] (\nivec4(113,112,70,127), \nivec4(226,112,74,127),\nivec4(339,112,72,127),\nivec4(452,112,75,127),\nivec4(565,112,74,127),\nivec4(678,112,77,127),\nivec4(791,112,75,127),\nivec4(904,112,79,127),\nivec4(1017,112,77,127),\nivec4(1130,112,82,127),\nivec4(1243,112,74,127),\nivec4(1356,112,77,127),\nivec4(1469,112,75,127),\nivec4(1582,112,79,127),\nivec4(1695,112,69,127),\nivec4(1808,112,72,127),\nivec4(1921,112,70,127),\nivec4(2034,112,74,127),\nivec4(2147,112,62,127),\nivec4(2260,112,70,127),\nivec4(2373,112,63,127),\nivec4(2486,112,72,127),\nivec4(2599,112,65,127),\nivec4(2712,112,69,127),\nivec4(2825,112,58,127),\nivec4(2825,903,70,127),\nivec4(2938,112,62,127),\nivec4(3051,112,60,127),\nivec4(3164,112,63,127),\nivec4(3277,112,62,127),\nivec4(3390,112,65,127),\nivec4(3503,112,63,127),\nivec4(3616,112,67,127),\nivec4(3729,112,65,127),\nivec4(3842,112,70,127),\nivec4(3955,112,62,127),\nivec4(4068,112,65,127),\nivec4(4181,112,63,127),\nivec4(4294,112,67,127),\nivec4(4407,112,57,127),\nivec4(4520,112,60,127),\nivec4(4633,112,58,127),\nivec4(4746,112,62,127),\nivec4(4859,112,50,127),\nivec4(4972,112,58,127),\nivec4(5085,112,51,127),\nivec4(5198,112,60,127),\nivec4(5311,112,53,127),\nivec4(5424,112,57,127),\nivec4(5537,518,58,127),\nivec4(5650,112,65,127),\nivec4(5763,112,67,127),\nivec4(5876,112,65,127),\nivec4(5989,564,77,127),\nivec4(6102,112,53,127),\nivec4(6215,112,55,127),\nivec4(6328,112,53,127),\nivec4(6441,451,63,127),\nivec4(6554,112,79,127),\nivec4(6667,112,75,127),\nivec4(6780,112,69,127),\nivec4(6893,112,70,127),\nivec4(6893,225,62,127),\nivec4(7006,112,65,127),\nivec4(7119,112,72,127),\nivec4(7119,225,60,127),\nivec4(7232,112,65,127),\nivec4(7345,112,74,127),\nivec4(7345,518,58,127),\nivec4(7458,112,65,127),\nivec4(7571,112,67,127),\nivec4(7684,112,65,127),\nivec4(7797,564,77,127),\nivec4(7910,112,53,127),\nivec4(8023,112,55,127),\nivec4(8136,112,53,127),\nivec4(8249,451,63,127),\nivec4(8362,112,79,127),\nivec4(8475,112,77,127),\nivec4(8588,112,69,127),\nivec4(8701,112,70,127),\nivec4(8701,225,62,127),\nivec4(8814,112,65,127),\nivec4(8927,112,72,127),\nivec4(8927,224,60,127),\nivec4(9040,112,65,127),\nivec4(9153,564,74,127),\nivec4(9266,790,58,127),\nivec4(9379,112,62,127),\nivec4(9492,112,65,127),\nivec4(9605,225,68,127),\nivec4(9718,225,77,127),\nivec4(9831,337,67,127),\nivec4(9944,112,75,127),\nivec4(10057,37,77,127),\nivec4(10085,37,75,127),\nivec4(10113,37,77,127),\nivec4(10141,37,75,127),\nivec4(10169,339,74,127),\nivec4(10169,790,58,127),\nivec4(10282,112,62,127),\nivec4(10395,112,65,127),\nivec4(10508,225,68,127),\nivec4(10621,225,77,127),\nivec4(10734,337,67,127),\nivec4(10847,112,75,127),\nivec4(10960,37,77,127),\nivec4(10988,37,75,127),\nivec4(11016,37,77,127),\nivec4(11044,37,75,127),\nivec4(11072,339,74,127),\nivec4(11072,790,56,127),\nivec4(11185,112,62,127),\nivec4(11298,112,65,127),\nivec4(11411,225,68,127),\nivec4(11524,225,77,127),\nivec4(11637,337,67,127),\nivec4(11750,112,75,127),\nivec4(11863,37,77,127),\nivec4(11891,37,75,127),\nivec4(11919,37,77,127),\nivec4(11947,37,75,127),\nivec4(11975,339,74,127),\nivec4(11975,790,56,127),\nivec4(12088,112,62,127),\nivec4(12201,112,65,127),\nivec4(12314,225,68,127),\nivec4(12427,225,77,127),\nivec4(12540,337,67,127),\nivec4(12653,112,75,127),\nivec4(12766,37,77,127),\nivec4(12794,37,75,127),\nivec4(12822,37,77,127),\nivec4(12850,37,75,127),\nivec4(12878,339,74,127),\nivec4(12878,790,56,127),\nivec4(12991,112,60,127),\nivec4(13104,112,62,127),\nivec4(13217,225,65,127),\nivec4(13330,225,74,127),\nivec4(13443,337,63,127),\nivec4(13556,112,72,127),\nivec4(13669,37,74,127),\nivec4(13697,37,72,127),\nivec4(13725,37,74,127),\nivec4(13753,37,72,127),\nivec4(13781,339,71,127),\nivec4(13781,790,55,127),\nivec4(13894,112,59,127),\nivec4(14007,112,62,127),\nivec4(14120,225,67,127),\nivec4(14233,225,75,127),\nivec4(14346,337,65,127),\nivec4(14459,112,74,127),\nivec4(14572,37,75,127),\nivec4(14600,37,74,127),\nivec4(14628,37,75,127),\nivec4(14656,37,74,127),\nivec4(14684,339,72,127),\nivec4(14684,790,56,127),\nivec4(14797,112,60,127),\nivec4(14910,112,62,127),\nivec4(15023,225,65,127),\nivec4(15136,225,74,127),\nivec4(15249,337,63,127),\nivec4(15362,112,72,127),\nivec4(15475,37,74,127),\nivec4(15503,37,72,127),\nivec4(15531,37,74,127),\nivec4(15559,37,72,127),\nivec4(15587,339,71,127),\nivec4(15587,790,55,127),\nivec4(15700,112,59,127),\nivec4(15813,112,62,127),\nivec4(15926,225,67,127),\nivec4(16039,225,75,127),\nivec4(16152,337,65,127),\nivec4(16265,112,74,127),\nivec4(16378,37,75,127),\nivec4(16406,37,74,127),\nivec4(16434,37,75,127),\nivec4(16462,37,74,127),\nivec4(16490,111,57,127),\nivec4(16490,338,72,127),\nivec4(16602,112,60,127),\nivec4(16715,112,66,127),\nivec4(16828,225,69,127),\nivec4(16941,112,72,127),\nivec4(17054,112,78,127),\nivec4(17054,338,57,127),\nivec4(17167,112,81,127),\nivec4(17280,225,81,127),\nivec4(17393,112,58,127),\nivec4(17506,112,62,127),\nivec4(17506,338,74,127),\nivec4(17619,112,67,127),\nivec4(17732,225,70,127),\nivec4(17845,112,74,127),\nivec4(17958,112,79,127),\nivec4(17958,338,58,127),\nivec4(18071,112,82,127),\nivec4(18184,225,82,127),\nivec4(18297,112,60,127),\nivec4(18410,112,63,127),\nivec4(18410,338,75,127),\nivec4(18523,112,69,127),\nivec4(18636,225,72,127),\nivec4(18749,112,75,127),\nivec4(18862,112,81,127),\nivec4(18862,225,60,127),\nivec4(18975,112,84,127),\nivec4(19088,112,78,127),\nivec4(19088,225,72,127),\nivec4(19201,112,81,127),\nivec4(19314,112,74,127),\nivec4(19314,225,70,127),\nivec4(19427,225,86,127),\nivec4(19540,225,69,127),\nivec4(19540,225,76,127),\nivec4(19653,112,84,127),\nivec4(19766,112,82,127),\nivec4(19766,225,62,127),\nivec4(19766,225,78,127),\nivec4(19879,93,81,127),\nivec4(19992,112,58,127),\nivec4(19992,451,79,127),\nivec4(20105,112,62,127),\nivec4(20218,112,67,127),\nivec4(20218,451,82,127),\nivec4(20331,112,70,127),\nivec4(20444,112,60,127),\nivec4(20444,451,75,127),\nivec4(20557,112,72,127),\nivec4(20670,112,69,127),\nivec4(20670,424,81,127),\nivec4(20783,112,66,127),\nivec4(20896,112,58,127),\nivec4(20896,451,74,127),\nivec4(21009,112,62,127),\nivec4(21122,112,67,127),\nivec4(21122,451,82,127),\nivec4(21235,112,70,127),\nivec4(21348,112,60,127),\nivec4(21348,451,75,127),\nivec4(21461,112,72,127),\nivec4(21574,112,69,127),\nivec4(21574,225,81,127),\nivec4(21687,112,66,127),\nivec4(21800,112,58,127),\nivec4(21800,225,74,127),\nivec4(21913,112,62,127),\nivec4(22026,112,67,127),\nivec4(22026,451,86,127),\nivec4(22139,112,70,127),\nivec4(22252,112,57,127),\nivec4(22365,112,60,127),\nivec4(22478,112,66,127),\nivec4(22478,451,84,127),\nivec4(22591,112,69,127),\nivec4(22704,112,55,127),\nivec4(22817,112,67,127),\nivec4(22930,112,63,127),\nivec4(22930,451,82,127),\nivec4(23043,112,60,127),\nivec4(23156,112,54,127),\nivec4(23269,112,57,127),\nivec4(23382,112,62,127),\nivec4(23382,451,81,127),\nivec4(23495,112,50,127),\nivec4(23608,112,51,127),\nivec4(23721,112,55,127),\nivec4(23834,112,60,127),\nivec4(23834,338,79,127),\nivec4(23947,112,48,127),\nivec4(24060,225,50,127),\nivec4(24173,112,78,127),\nivec4(24286,225,48,127),\nivec4(24286,451,79,127),\nivec4(24399,112,75,127),\nivec4(24512,112,74,127),\nivec4(24512,225,50,127),\nivec4(24625,112,72,127),\nivec4(24738,112,70,127),\nivec4(24738,225,38,127),\nivec4(24738,225,78,127),\nivec4(24851,112,69,127),\nivec4(24964,112,58,127),\nivec4(24964,188,79,127),\nivec4(24964,224,67,127),\nivec4(25077,111,62,127),\nivec4(25189,112,67,127),\nivec4(25189,451,82,127),\nivec4(25302,112,70,127),\nivec4(25415,112,60,127),\nivec4(25415,451,75,127),\nivec4(25528,112,72,127),\nivec4(25641,112,69,127),\nivec4(25641,451,81,127),\nivec4(25754,112,66,127),\nivec4(25867,112,58,127),\nivec4(25867,451,74,127),\nivec4(25980,112,62,127),\nivec4(26093,112,67,127),\nivec4(26093,451,82,127),\nivec4(26206,112,70,127),\nivec4(26319,112,60,127),\nivec4(26319,451,75,127),\nivec4(26432,112,72,127),\nivec4(26545,112,69,127),\nivec4(26545,451,81,127),\nivec4(26658,112,66,127),\nivec4(26771,112,58,127),\nivec4(26771,225,74,127),\nivec4(26884,112,62,127),\nivec4(26997,112,67,127),\nivec4(26997,451,86,127),\nivec4(27110,112,70,127),\nivec4(27223,112,57,127),\nivec4(27336,112,60,127),\nivec4(27449,112,66,127),\nivec4(27449,451,84,127),\nivec4(27562,112,69,127),\nivec4(27675,112,55,127),\nivec4(27788,112,67,127),\nivec4(27901,112,63,127),\nivec4(27901,451,82,127),\nivec4(28014,112,60,127),\nivec4(28127,112,54,127),\nivec4(28240,112,57,127),\nivec4(28353,112,62,127),\nivec4(28353,451,81,127),\nivec4(28466,112,50,127),\nivec4(28579,112,51,127),\nivec4(28692,112,55,127),\nivec4(28805,112,60,127),\nivec4(28805,338,79,127),\nivec4(28918,112,48,127),\nivec4(29031,225,50,127),\nivec4(29144,112,78,127),\nivec4(29257,225,48,127),\nivec4(29257,451,79,127),\nivec4(29370,112,75,127),\nivec4(29483,112,74,127),\nivec4(29483,450,50,127),\nivec4(29596,112,72,127),\nivec4(29709,112,70,127),\nivec4(29709,169,78,127),\nivec4(29709,224,38,127),\nivec4(29822,111,69,127),\nivec4(29934,112,67,127),\nivec4(29934,338,43,127),\nivec4(30047,112,62,127),\nivec4(30160,338,70,127),\nivec4(30273,112,34,127),\nivec4(30273,112,46,127),\nivec4(30386,112,63,127),\nivec4(30386,225,36,127),\nivec4(30386,225,48,127),\nivec4(30499,112,69,127),\nivec4(30612,112,60,127),\nivec4(30612,225,39,127),\nivec4(30612,225,51,127),\nivec4(30725,112,67,127),\nivec4(30838,112,69,127),\nivec4(30838,338,38,127),\nivec4(30838,338,50,127),\nivec4(30951,112,62,127),\nivec4(31064,338,70,127),\nivec4(31177,112,34,127),\nivec4(31177,112,46,127),\nivec4(31290,225,36,127),\nivec4(31290,225,48,127),\nivec4(31290,225,63,127),\nivec4(31403,225,69,127),\nivec4(31516,225,39,127),\nivec4(31516,225,51,127),\nivec4(31516,225,60,127),\nivec4(31629,112,67,127),\nivec4(31742,112,69,127),\nivec4(31742,338,38,127),\nivec4(31742,338,50,127),\nivec4(31855,112,62,127),\nivec4(31968,338,70,127),\nivec4(32081,112,34,127),\nivec4(32081,112,46,127),\nivec4(32194,225,36,127),\nivec4(32194,225,48,127),\nivec4(32194,225,63,127),\nivec4(32307,225,69,127),\nivec4(32420,225,39,127),\nivec4(32420,225,51,127),\nivec4(32420,225,60,127),\nivec4(32533,112,67,127),\nivec4(32646,112,69,127),\nivec4(32646,225,42,127),\nivec4(32646,225,50,127),\nivec4(32759,112,62,127),\nivec4(32872,112,72,127),\nivec4(32872,225,43,127),\nivec4(32985,112,70,127),\nivec4(33098,112,74,127),\nivec4(33098,451,50,127),\nivec4(33211,112,67,127),\nivec4(33324,112,69,127),\nivec4(33324,225,38,127),\nivec4(33437,112,66,127),\nivec4(33550,112,67,127),\nivec4(33550,338,43,127),\nivec4(33663,112,62,127),\nivec4(33776,338,70,127),\nivec4(33889,112,34,127),\nivec4(33889,112,46,127),\nivec4(34002,225,36,127),\nivec4(34002,225,48,127),\nivec4(34002,225,63,127),\nivec4(34115,225,69,127),\nivec4(34228,225,39,127),\nivec4(34228,225,51,127),\nivec4(34228,225,60,127),\nivec4(34341,112,67,127),\nivec4(34454,112,69,127),\nivec4(34454,294,38,127),\nivec4(34454,294,50,127),\nivec4(34567,112,62,127),\nivec4(34680,338,70,127),\nivec4(34793,112,34,127),\nivec4(34793,112,46,127),\nivec4(34906,225,36,127),\nivec4(34906,225,48,127),\nivec4(34906,225,63,127),\nivec4(35019,225,69,127),\nivec4(35132,225,39,127),\nivec4(35132,225,51,127),\nivec4(35132,225,60,127),\nivec4(35245,112,67,127),\nivec4(35358,112,69,127),\nivec4(35358,294,38,127),\nivec4(35358,294,50,127),\nivec4(35471,112,62,127),\nivec4(35584,338,70,127),\nivec4(35697,112,34,127),\nivec4(35697,112,46,127),\nivec4(35810,225,36,127),\nivec4(35810,225,48,127),\nivec4(35810,225,63,127),\nivec4(35923,225,69,127),\nivec4(36036,225,39,127),\nivec4(36036,225,51,127),\nivec4(36036,225,60,127),\nivec4(36149,112,67,127),\nivec4(36262,112,69,127),\nivec4(36262,225,42,127),\nivec4(36262,225,50,127),\nivec4(36375,112,62,127),\nivec4(36488,112,72,127),\nivec4(36488,225,43,127),\nivec4(36601,112,70,127),\nivec4(36714,112,74,127),\nivec4(36714,451,50,127),\nivec4(36827,112,67,127),\nivec4(36940,112,69,127),\nivec4(36940,225,38,127),\nivec4(37053,112,66,127),\nivec4(37166,112,62,127),\nivec4(37279,112,67,127),\nivec4(37392,112,70,127),\nivec4(37392,451,43,127),\nivec4(37505,112,74,127),\nivec4(37618,112,69,127),\nivec4(37731,112,72,127),\nivec4(37844,112,78,127),\nivec4(37844,451,45,127),\nivec4(37957,112,81,127),\nivec4(38070,112,74,127),\nivec4(38183,112,79,127),\nivec4(38296,112,82,127),\nivec4(38296,225,46,127),\nivec4(38409,112,86,127),\nivec4(38522,112,75,127),\nivec4(38522,225,48,127),\nivec4(38635,112,84,127),\nivec4(38748,112,72,127),\nivec4(38748,225,45,127),\nivec4(38861,112,78,127),\nivec4(38974,112,79,127),\nivec4(38974,225,46,127),\nivec4(39087,112,74,127),\nivec4(39200,112,75,127),\nivec4(39200,225,48,127),\nivec4(39313,211,67,127),\nivec4(39426,451,50,127),\nivec4(39539,112,69,127),\nivec4(39652,112,62,127),\nivec4(39652,225,38,127),\nivec4(39765,112,66,127),\nivec4(39878,112,62,127),\nivec4(39991,112,67,127),\nivec4(40104,112,70,127),\nivec4(40104,451,31,127),\nivec4(40104,451,43,127),\nivec4(40217,112,74,127),\nivec4(40330,112,69,127),\nivec4(40443,112,72,127),\nivec4(40556,112,78,127),\nivec4(40556,451,33,127),\nivec4(40556,451,45,127),\nivec4(40669,112,81,127),\nivec4(40782,112,74,127),\nivec4(40895,112,79,127),\nivec4(41008,112,82,127),\nivec4(41008,225,34,127),\nivec4(41008,225,46,127),\nivec4(41121,112,86,127),\nivec4(41234,112,75,127),\nivec4(41234,225,36,127),\nivec4(41234,225,48,127),\nivec4(41347,112,84,127),\nivec4(41460,112,72,127),\nivec4(41460,225,33,127),\nivec4(41460,225,45,127),\nivec4(41573,112,78,127),\nivec4(41686,112,79,127),\nivec4(41686,225,34,127),\nivec4(41686,225,46,127),\nivec4(41799,112,74,127),\nivec4(41912,112,75,127),\nivec4(41912,225,36,127),\nivec4(41912,225,48,127),\nivec4(42025,200,67,127),\nivec4(42138,225,38,127),\nivec4(42138,225,50,127),\nivec4(42251,112,69,127),\nivec4(42364,112,62,127),\nivec4(42364,225,36,127),\nivec4(42364,225,48,127),\nivec4(42477,112,66,127),\nivec4(42590,112,67,127),\nivec4(42590,225,34,127),\nivec4(42590,225,46,127),\nivec4(42703,112,62,127),\nivec4(42816,112,63,127),\nivec4(42816,225,36,127),\nivec4(42816,225,48,127),\nivec4(42929,112,60,127),\nivec4(43042,112,58,127),\nivec4(43042,451,50,127),\nivec4(43155,112,67,127),\nivec4(43268,112,57,127),\nivec4(43268,225,38,127),\nivec4(43381,112,66,127),\nivec4(43494,676,67,127),\nivec4(43494,902,43,127),\nivec4(44397,112,67,127),\nivec4(44397,1807,43,127),\nivec4(44510,112,71,127),\nivec4(44623,112,74,127),\nivec4(44736,112,79,127),\nivec4(44849,112,68,127),\nivec4(44962,112,77,127),\nivec4(45075,112,67,127),\nivec4(45188,112,75,127),\nivec4(45301,112,65,127),\nivec4(45414,112,74,127),\nivec4(45527,112,63,127),\nivec4(45640,112,72,127),\nivec4(45753,112,62,127),\nivec4(45866,112,71,127),\nivec4(45979,112,63,127),\nivec4(46092,112,72,127),\nivec4(46205,112,55,127),\nivec4(46205,659,74,127),\nivec4(46318,112,59,127),\nivec4(46431,112,62,127),\nivec4(46544,112,67,127),\nivec4(46657,112,56,127),\nivec4(46770,112,65,127),\nivec4(46883,112,55,127),\nivec4(46883,225,72,127),\nivec4(46996,112,63,127),\nivec4(47109,38,72,127),\nivec4(47109,113,53,127),\nivec4(47140,38,71,127),\nivec4(47171,38,72,127),\nivec4(47202,140,71,127),\nivec4(47223,112,62,127),\nivec4(47336,112,51,127),\nivec4(47336,225,72,127),\nivec4(47449,112,60,127),\nivec4(47562,112,50,127),\nivec4(47562,225,74,127),\nivec4(47675,112,59,127),\nivec4(47788,112,48,127),\nivec4(47788,225,75,127),\nivec4(47901,112,60,127),\nivec4(48014,112,74,127),\nivec4(48014,338,43,127),\nivec4(48127,112,71,127),\nivec4(48240,112,67,127),\nivec4(48353,112,36,127),\nivec4(48353,112,48,127),\nivec4(48353,225,75,127),\nivec4(48466,225,41,127),\nivec4(48466,225,53,127),\nivec4(48466,225,68,127),\nivec4(48579,225,74,127),\nivec4(48692,225,44,127),\nivec4(48692,225,56,127),\nivec4(48692,225,65,127),\nivec4(48805,112,72,127),\nivec4(48918,112,74,127),\nivec4(48918,338,43,127),\nivec4(48918,338,55,127),\nivec4(49031,112,71,127),\nivec4(49144,105,67,127),\nivec4(49257,112,36,127),\nivec4(49257,112,48,127),\nivec4(49257,225,75,127),\nivec4(49370,225,41,127),\nivec4(49370,225,53,127),\nivec4(49370,225,68,127),\nivec4(49483,225,74,127),\nivec4(49596,225,44,127),\nivec4(49596,225,56,127),\nivec4(49596,225,65,127),\nivec4(49709,112,72,127),\nivec4(49822,112,74,127),\nivec4(49822,338,43,127),\nivec4(49822,338,55,127),\nivec4(49935,112,71,127),\nivec4(50048,105,67,127),\nivec4(50161,112,55,127),\nivec4(50161,112,58,127),\nivec4(50161,112,76,127),\nivec4(50274,112,72,127),\nivec4(50274,225,56,127),\nivec4(50274,225,60,127),\nivec4(50387,112,77,127),\nivec4(50500,112,70,127),\nivec4(50500,225,55,127),\nivec4(50500,225,58,127),\nivec4(50613,112,76,127),\nivec4(50726,112,77,127),\nivec4(50726,338,53,127),\nivec4(50839,112,72,127),\nivec4(50952,105,65,127),\nivec4(51065,112,34,127),\nivec4(51065,112,46,127),\nivec4(51065,225,73,127),\nivec4(51178,225,39,127),\nivec4(51178,225,51,127),\nivec4(51178,225,66,127),\nivec4(51291,225,72,127),\nivec4(51404,225,42,127),\nivec4(51404,225,54,127),\nivec4(51404,225,63,127),\nivec4(51517,112,70,127),\nivec4(51630,112,72,127),\nivec4(51630,338,41,127),\nivec4(51630,338,53,127),\nivec4(51743,112,69,127),\nivec4(51856,105,65,127),\nivec4(51969,112,34,127),\nivec4(51969,112,46,127),\nivec4(51969,225,73,127),\nivec4(52082,225,39,127),\nivec4(52082,225,51,127),\nivec4(52082,225,66,127),\nivec4(52195,225,72,127),\nivec4(52308,225,42,127),\nivec4(52308,225,54,127),\nivec4(52308,225,63,127),\nivec4(52421,112,70,127),\nivec4(52534,112,72,127),\nivec4(52534,338,41,127),\nivec4(52534,338,53,127),\nivec4(52647,112,69,127),\nivec4(52760,105,65,127),\nivec4(52873,112,53,127),\nivec4(52873,112,56,127),\nivec4(52873,112,74,127),\nivec4(52986,112,70,127),\nivec4(52986,225,54,127),\nivec4(52986,225,58,127),\nivec4(53099,112,75,127),\nivec4(53212,112,68,127),\nivec4(53212,225,53,127),\nivec4(53212,225,56,127),\nivec4(53325,112,77,127),\nivec4(53438,112,78,127),\nivec4(53438,338,51,127),\nivec4(53551,112,75,127),\nivec4(53664,105,70,127),\nivec4(53777,112,39,127),\nivec4(53777,112,51,127),\nivec4(53777,225,78,127),\nivec4(53890,225,44,127),\nivec4(53890,225,56,127),\nivec4(53890,225,71,127),\nivec4(54003,225,77,127),\nivec4(54116,225,47,127),\nivec4(54116,225,59,127),\nivec4(54116,225,68,127),\nivec4(54229,112,75,127),\nivec4(54342,112,77,127),\nivec4(54342,338,46,127),\nivec4(54342,338,58,127),\nivec4(54455,112,74,127),\nivec4(54568,105,70,127),\nivec4(54681,112,39,127),\nivec4(54681,112,51,127),\nivec4(54681,225,78,127),\nivec4(54794,225,44,127),\nivec4(54794,225,56,127),\nivec4(54794,225,71,127),\nivec4(54907,225,77,127),\nivec4(55020,225,47,127),\nivec4(55020,225,59,127),\nivec4(55020,225,68,127),\nivec4(55133,112,75,127),\nivec4(55246,112,77,127),\nivec4(55246,225,46,127),\nivec4(55246,225,58,127),\nivec4(55359,112,74,127),\nivec4(55472,112,70,127),\nivec4(55472,225,56,127),\nivec4(55585,112,74,127),\nivec4(55698,112,75,127),\nivec4(55698,225,55,127),\nivec4(55811,112,79,127),\nivec4(55924,112,77,127),\nivec4(55924,225,53,127),\nivec4(56037,112,80,127),\nivec4(56150,112,79,127),\nivec4(56150,225,51,127),\nivec4(56150,225,63,127),\nivec4(56263,112,75,127),\nivec4(56376,112,77,127),\nivec4(56376,225,62,127),\nivec4(56489,112,74,127),\nivec4(56602,112,75,127),\nivec4(56602,225,60,127),\nivec4(56715,112,72,127),\nivec4(56828,112,74,127),\nivec4(56828,225,58,127),\nivec4(56941,112,70,127),\nivec4(57054,112,72,127),\nivec4(57054,225,57,127),\nivec4(57167,112,69,127),\nivec4(57280,112,70,127),\nivec4(57280,225,55,127),\nivec4(57393,112,67,127),\nivec4(57506,112,69,127),\nivec4(57506,225,53,127),\nivec4(57619,112,65,127),\nivec4(57732,112,67,127),\nivec4(57732,225,51,127),\nivec4(57845,112,63,127),\nivec4(57958,112,50,127),\nivec4(57958,188,65,127),\nivec4(58071,111,53,127),\nivec4(58183,112,58,127),\nivec4(58183,451,77,127),\nivec4(58296,112,62,127),\nivec4(58409,112,51,127),\nivec4(58522,112,63,127),\nivec4(58635,112,60,127),\nivec4(58635,112,79,127),\nivec4(58748,112,57,127),\nivec4(58748,112,69,127),\nivec4(58861,112,50,127),\nivec4(58861,225,69,127),\nivec4(58974,112,53,127),\nivec4(59087,112,58,127),\nivec4(59087,435,70,127),\nivec4(59200,112,62,127),\nivec4(59313,112,51,127),\nivec4(59426,111,63,127),\nivec4(59538,112,60,127),\nivec4(59538,112,79,127),\nivec4(59651,112,57,127),\nivec4(59651,112,69,127),\nivec4(59764,112,50,127),\nivec4(59764,112,69,127),\nivec4(59877,112,53,127),\nivec4(59877,112,70,127),\nivec4(59990,112,58,127),\nivec4(59990,451,77,127),\nivec4(60103,112,62,127),\nivec4(60216,112,60,127),\nivec4(60329,112,57,127),\nivec4(60442,112,51,127),\nivec4(60442,451,75,127),\nivec4(60555,112,48,127),\nivec4(60668,112,46,127),\nivec4(60781,112,50,127),\nivec4(60894,112,53,127),\nivec4(60894,451,74,127),\nivec4(61007,112,58,127),\nivec4(61120,112,48,127),\nivec4(61233,112,51,127),\nivec4(61346,112,57,127),\nivec4(61346,225,72,127),\nivec4(61459,112,60,127),\nivec4(61572,112,50,127),\nivec4(61572,200,70,127),\nivec4(61685,112,53,127),\nivec4(61798,112,58,127),\nivec4(61798,451,77,127),\nivec4(61911,112,62,127),\nivec4(62024,112,51,127),\nivec4(62137,112,63,127),\nivec4(62250,112,60,127),\nivec4(62250,112,79,127),\nivec4(62363,112,57,127),\nivec4(62363,112,69,127),\nivec4(62476,112,50,127),\nivec4(62476,225,69,127),\nivec4(62589,112,53,127),\nivec4(62702,112,58,127),\nivec4(62702,400,70,127),\nivec4(62815,112,62,127),\nivec4(62928,112,51,127),\nivec4(63041,112,63,127),\nivec4(63154,112,60,127),\nivec4(63154,112,79,127),\nivec4(63267,112,57,127),\nivec4(63267,112,69,127),\nivec4(63380,112,50,127),\nivec4(63380,112,69,127),\nivec4(63493,112,53,127),\nivec4(63493,112,70,127),\nivec4(63606,112,58,127),\nivec4(63606,451,77,127),\nivec4(63719,112,62,127),\nivec4(63832,112,60,127),\nivec4(63945,112,57,127),\nivec4(64058,112,51,127),\nivec4(64058,451,75,127),\nivec4(64171,112,48,127),\nivec4(64284,112,46,127),\nivec4(64397,112,50,127),\nivec4(64510,112,53,127),\nivec4(64510,451,74,127),\nivec4(64623,112,58,127),\nivec4(64736,112,48,127),\nivec4(64849,112,51,127),\nivec4(64962,112,57,127),\nivec4(64962,202,72,127),\nivec4(65075,111,60,127),\nivec4(65187,112,70,127),\nivec4(65187,225,50,127),\nivec4(65300,112,77,127),\nivec4(65413,112,79,127),\nivec4(65413,225,51,127),\nivec4(65526,225,70,127),\nivec4(65639,451,53,127),\nivec4(65752,112,72,127),\nivec4(65865,112,65,127),\nivec4(65865,225,41,127),\nivec4(65978,112,69,127),\nivec4(66091,224,70,127),\nivec4(66091,338,46,127),\nivec4(66204,112,65,127),\nivec4(66317,338,74,127),\nivec4(66430,112,34,127),\nivec4(66430,112,46,127),\nivec4(66543,225,39,127),\nivec4(66543,225,51,127),\nivec4(66543,225,67,127),\nivec4(66656,225,72,127),\nivec4(66769,225,43,127),\nivec4(66769,225,55,127),\nivec4(66769,225,63,127),\nivec4(66882,112,70,127),\nivec4(66995,224,72,127),\nivec4(66995,338,41,127),\nivec4(66995,338,53,127),\nivec4(67108,112,65,127),\nivec4(67221,338,74,127),\nivec4(67334,112,34,127),\nivec4(67334,112,46,127),\nivec4(67447,225,39,127),\nivec4(67447,225,51,127),\nivec4(67447,225,67,127),\nivec4(67560,225,72,127),\nivec4(67673,225,43,127),\nivec4(67673,225,55,127),\nivec4(67673,225,63,127),\nivec4(67786,112,70,127),\nivec4(67899,224,72,127),\nivec4(67899,338,41,127),\nivec4(67899,338,53,127),\nivec4(68012,112,65,127),\nivec4(68125,338,74,127),\nivec4(68238,112,34,127),\nivec4(68238,112,46,127),\nivec4(68351,225,39,127),\nivec4(68351,225,51,127),\nivec4(68351,225,67,127),\nivec4(68464,225,72,127),\nivec4(68577,225,43,127),\nivec4(68577,225,55,127),\nivec4(68577,225,63,127),\nivec4(68690,112,70,127),\nivec4(68803,112,72,127),\nivec4(68803,225,45,127),\nivec4(68803,225,53,127),\nivec4(68916,112,65,127),\nivec4(69029,112,74,127),\nivec4(69029,225,46,127),\nivec4(69142,112,70,127),\nivec4(69255,112,72,127),\nivec4(69255,225,39,127),\nivec4(69255,225,51,127),\nivec4(69368,112,67,127),\nivec4(69481,112,70,127),\nivec4(69481,225,41,127),\nivec4(69481,225,53,127),\nivec4(69594,112,69,127),\nivec4(69707,112,70,127),\nivec4(69707,338,46,127),\nivec4(69707,338,58,127),\nivec4(69820,112,77,127),\nivec4(69933,112,74,127),\nivec4(70046,112,46,127),\nivec4(70046,112,58,127),\nivec4(70046,225,70,127),\nivec4(70159,225,51,127),\nivec4(70159,225,63,127),\nivec4(70272,225,79,127),\nivec4(70385,225,55,127),\nivec4(70385,225,67,127),\nivec4(70498,112,75,127),\nivec4(70611,112,81,127),\nivec4(70611,330,53,127),\nivec4(70611,330,65,127),\nivec4(70724,112,77,127),\nivec4(70837,259,82,127),\nivec4(70950,112,46,127),\nivec4(70950,112,58,127),\nivec4(71063,225,51,127),\nivec4(71063,225,63,127),\nivec4(71176,225,79,127),\nivec4(71289,225,55,127),\nivec4(71289,225,67,127),\nivec4(71402,112,75,127),\nivec4(71515,112,81,127),\nivec4(71515,330,53,127),\nivec4(71515,330,65,127),\nivec4(71628,112,77,127),\nivec4(71741,259,82,127),\nivec4(71854,112,46,127),\nivec4(71854,112,58,127),\nivec4(71967,225,51,127),\nivec4(71967,225,63,127),\nivec4(72080,225,79,127),\nivec4(72193,225,55,127),\nivec4(72193,225,67,127),\nivec4(72306,112,75,127),\nivec4(72419,112,77,127),\nivec4(72419,225,57,127),\nivec4(72419,451,65,127),\nivec4(72532,112,72,127),\nivec4(72645,112,74,127),\nivec4(72645,225,58,127),\nivec4(72758,112,70,127),\nivec4(72871,112,72,127),\nivec4(72871,225,51,127),\nivec4(72984,112,67,127),\nivec4(73097,112,70,127),\nivec4(73097,224,53,127),\nivec4(73210,75,69,127),\nivec4(73322,112,62,127),\nivec4(73435,112,65,127),\nivec4(73548,112,70,127),\nivec4(73548,451,46,127),\nivec4(73661,112,74,127),\nivec4(73774,112,69,127),\nivec4(73887,112,72,127),\nivec4(74000,112,75,127),\nivec4(74000,451,48,127),\nivec4(74113,112,81,127),\nivec4(74226,112,74,127),\nivec4(74339,112,77,127),\nivec4(74452,112,82,127),\nivec4(74452,225,50,127),\nivec4(74565,112,86,127),\nivec4(74678,112,79,127),\nivec4(74678,225,51,127),\nivec4(74791,112,84,127),\nivec4(74904,112,75,127),\nivec4(74904,225,48,127),\nivec4(75017,112,81,127),\nivec4(75130,112,82,127),\nivec4(75130,225,50,127),\nivec4(75243,112,77,127),\nivec4(75356,112,79,127),\nivec4(75356,225,51,127),\nivec4(75469,225,70,127),\nivec4(75582,451,53,127),\nivec4(75695,112,72,127),\nivec4(75808,112,65,127),\nivec4(75808,225,41,127),\nivec4(75921,104,69,127),\nivec4(76034,112,62,127),\nivec4(76147,112,65,127),\nivec4(76260,112,70,127),\nivec4(76260,451,34,127),\nivec4(76260,451,46,127),\nivec4(76373,112,74,127),\nivec4(76486,112,69,127),\nivec4(76599,112,72,127),\nivec4(76712,112,75,127),\nivec4(76712,451,36,127),\nivec4(76712,451,48,127),\nivec4(76825,112,81,127),\nivec4(76938,112,74,127),\nivec4(77051,112,77,127),\nivec4(77164,112,82,127),\nivec4(77164,225,38,127),\nivec4(77164,225,50,127),\nivec4(77277,112,86,127),\nivec4(77390,112,79,127),\nivec4(77390,225,39,127),\nivec4(77390,225,51,127),\nivec4(77503,112,84,127),\nivec4(77616,112,75,127),\nivec4(77616,225,36,127),\nivec4(77616,225,48,127),\nivec4(77729,112,81,127),\nivec4(77842,112,82,127),\nivec4(77842,225,38,127),\nivec4(77842,225,50,127),\nivec4(77955,112,77,127),\nivec4(78068,112,79,127),\nivec4(78068,225,39,127),\nivec4(78068,225,51,127),\nivec4(78181,200,70,127),\nivec4(78294,225,41,127),\nivec4(78294,225,53,127),\nivec4(78407,112,72,127),\nivec4(78520,112,65,127),\nivec4(78520,225,39,127),\nivec4(78520,225,51,127),\nivec4(78633,112,69,127),\nivec4(78746,112,70,127),\nivec4(78746,225,38,127),\nivec4(78746,225,50,127),\nivec4(78866,121,65,127),\nivec4(78991,121,67,127),\nivec4(78991,246,39,127),\nivec4(78991,246,51,127),\nivec4(79114,121,63,127),\nivec4(79238,136,62,127),\nivec4(79238,498,53,127),\nivec4(79363,136,70,127),\nivec4(79488,136,60,127),\nivec4(79488,248,41,127),\nivec4(79613,141,69,127),\nivec4(79761,1867,34,127),\nivec4(79761,1867,46,127),\nivec4(79761,1867,70,127));\n#elif TUNE == 7\nfloat speed = 0.5;\nconst ivec4 data[] = ivec4[] (\nivec4(0,96,63,100),\nivec4(0,384,51,100),\nivec4(120,96,75,100),\nivec4(240,96,65,100),\nivec4(360,96,75,100),\nivec4(480,96,67,100),\nivec4(600,96,75,100),\nivec4(720,96,68,100),\nivec4(720,384,48,100),\nivec4(840,96,75,100),\nivec4(960,96,70,100),\nivec4(1080,96,75,100),\nivec4(1200,96,72,100),\nivec4(1320,96,75,100),\nivec4(1440,48,70,100),\nivec4(1440,288,43,100),\nivec4(1500,48,75,100),\nivec4(1560,48,74,100),\nivec4(1620,48,72,100),\nivec4(1680,48,70,100),\nivec4(1740,48,79,100),\nivec4(1800,48,77,100),\nivec4(1800,96,44,100),\nivec4(1860,48,75,100),\nivec4(1920,48,74,100),\nivec4(1920,192,46,100),\nivec4(1980,48,72,100),\nivec4(2040,48,70,100),\nivec4(2100,48,68,100),\nivec4(2160,48,67,100),\nivec4(2160,192,39,100),\nivec4(2220,48,68,100),\nivec4(2280,48,70,100),\nivec4(2340,48,67,100),\nivec4(2400,48,63,100),\nivec4(2400,192,43,100),\nivec4(2460,48,67,100),\nivec4(2520,48,70,100),\nivec4(2580,48,75,100),\nivec4(2640,48,65,100),\nivec4(2640,192,45,100),\nivec4(2700,48,69,100),\nivec4(2760,48,72,100),\nivec4(2820,48,75,100),\nivec4(2880,48,74,100),\nivec4(2880,96,58,100),\nivec4(2880,450,46,100),\nivec4(2940,48,72,100),\nivec4(3000,48,74,100),\nivec4(3000,96,70,100),\nivec4(3060,48,77,100),\nivec4(3120,48,75,100),\nivec4(3120,96,60,100),\nivec4(3180,48,74,100),\nivec4(3240,48,75,100),\nivec4(3240,96,70,100),\nivec4(3300,48,79,100),\nivec4(3360,48,77,100),\nivec4(3360,96,62,100),\nivec4(3420,48,75,100),\nivec4(3480,48,77,100),\nivec4(3480,96,70,100),\nivec4(3540,48,80,100),\nivec4(3600,48,79,100),\nivec4(3600,96,63,100),\nivec4(3600,384,46,100),\nivec4(3660,48,77,100),\nivec4(3720,48,79,100),\nivec4(3720,96,70,100),\nivec4(3780,48,82,100),\nivec4(3840,48,74,100),\nivec4(3840,96,65,100),\nivec4(3900,48,72,100),\nivec4(3960,48,74,100),\nivec4(3960,96,70,100),\nivec4(4020,48,82,100),\nivec4(4080,48,75,100),\nivec4(4080,96,67,100),\nivec4(4140,48,74,100),\nivec4(4200,48,75,100),\nivec4(4200,96,70,100),\nivec4(4260,48,82,100),\nivec4(4320,48,65,100),\nivec4(4320,96,74,100),\nivec4(4320,240,46,100),\nivec4(4380,48,70,100),\nivec4(4440,48,69,100),\nivec4(4440,96,77,100),\nivec4(4500,48,67,100),\nivec4(4560,48,65,100),\nivec4(4560,96,82,100),\nivec4(4560,240,50,100),\nivec4(4620,48,74,100),\nivec4(4680,48,72,100),\nivec4(4680,96,74,100),\nivec4(4740,48,70,100),\nivec4(4800,48,69,100),\nivec4(4800,96,72,100),\nivec4(4800,240,53,100),\nivec4(4860,48,67,100),\nivec4(4920,48,65,100),\nivec4(4920,96,81,100),\nivec4(4980,48,63,100),\nivec4(5040,48,62,100),\nivec4(5040,96,82,100),\nivec4(5040,480,58,100),\nivec4(5100,48,63,100),\nivec4(5160,48,65,100),\nivec4(5160,96,74,100),\nivec4(5220,48,62,100),\nivec4(5280,48,58,100),\nivec4(5280,96,77,100),\nivec4(5340,48,62,100),\nivec4(5400,48,65,100),\nivec4(5400,96,74,100),\nivec4(5460,48,70,100),\nivec4(5520,48,62,100),\nivec4(5520,96,70,100),\nivec4(5580,48,65,100),\nivec4(5640,48,68,100),\nivec4(5640,96,74,100),\nivec4(5700,48,70,100),\nivec4(5760,48,67,100),\nivec4(5760,96,39,100),\nivec4(5760,96,75,100),\nivec4(5820,48,65,100),\nivec4(5880,48,67,100),\nivec4(5880,96,51,100),\nivec4(5940,48,70,100),\nivec4(6000,48,68,100),\nivec4(6000,96,41,100),\nivec4(6000,96,75,100),\nivec4(6060,48,67,100),\nivec4(6120,48,68,100),\nivec4(6120,96,51,100),\nivec4(6180,48,72,100),\nivec4(6240,48,70,100),\nivec4(6240,96,43,100),\nivec4(6240,96,75,100),\nivec4(6300,48,68,100),\nivec4(6360,48,70,100),\nivec4(6360,96,51,100),\nivec4(6420,48,73,100),\nivec4(6480,48,72,100),\nivec4(6480,96,44,100),\nivec4(6480,96,75,100),\nivec4(6540,48,70,100),\nivec4(6600,48,72,100),\nivec4(6600,96,51,100),\nivec4(6660,48,75,100),\nivec4(6720,48,67,100),\nivec4(6720,96,46,100),\nivec4(6720,96,75,100),\nivec4(6780,48,65,100),\nivec4(6840,48,67,100),\nivec4(6840,96,51,100),\nivec4(6900,48,75,100),\nivec4(6960,48,68,100),\nivec4(6960,96,48,100),\nivec4(6960,96,75,100),\nivec4(7020,48,67,100),\nivec4(7080,48,68,100),\nivec4(7080,96,51,100),\nivec4(7140,48,75,100),\nivec4(7200,96,46,100),\nivec4(7200,96,67,100),\nivec4(7260,48,75,100),\nivec4(7320,48,77,100),\nivec4(7320,96,70,100),\nivec4(7380,48,79,100),\nivec4(7440,48,80,100),\nivec4(7440,96,48,100),\nivec4(7440,96,75,100),\nivec4(7500,48,82,100),\nivec4(7560,48,84,100),\nivec4(7560,96,67,100),\nivec4(7620,48,82,100),\nivec4(7680,48,80,100),\nivec4(7680,96,50,100),\nivec4(7680,96,65,100),\nivec4(7740,48,79,100),\nivec4(7800,48,77,100),\nivec4(7800,96,70,100),\nivec4(7860,48,80,100),\nivec4(7920,96,79,100),\nivec4(7920,384,51,100),\nivec4(7980,48,63,100),\nivec4(8040,48,65,100),\nivec4(8040,96,70,100),\nivec4(8100,48,67,100),\nivec4(8160,48,68,100),\nivec4(8160,96,72,100),\nivec4(8220,48,70,100),\nivec4(8280,48,72,100),\nivec4(8280,96,68,100),\nivec4(8340,48,70,100),\nivec4(8400,48,68,100),\nivec4(8400,192,50,100),\nivec4(8400,288,77,100),\nivec4(8460,48,67,100),\nivec4(8520,48,65,100),\nivec4(8580,48,68,100),\nivec4(8640,96,67,100),\nivec4(8640,192,51,100),\nivec4(8700,48,80,100),\nivec4(8760,48,79,100),\nivec4(8760,96,70,100),\nivec4(8820,48,77,100),\nivec4(8880,48,75,100),\nivec4(8880,96,72,100),\nivec4(8880,192,56,100),\nivec4(8940,48,74,100),\nivec4(9000,48,72,100),\nivec4(9000,96,68,100),\nivec4(9060,48,70,100),\nivec4(9120,48,68,100),\nivec4(9120,288,77,100),\nivec4(9180,48,67,100),\nivec4(9240,48,68,100),\nivec4(9300,48,77,100),\nivec4(9360,48,67,100),\nivec4(9360,192,47,100),\nivec4(9420,48,77,100),\nivec4(9420,48,80,100),\nivec4(9480,48,75,100),\nivec4(9480,48,79,100),\nivec4(9540,48,74,100),\nivec4(9540,48,77,100),\nivec4(9600,48,72,100),\nivec4(9600,48,75,100),\nivec4(9600,192,48,100),\nivec4(9660,48,70,100),\nivec4(9660,48,74,100),\nivec4(9720,48,68,100),\nivec4(9720,48,72,100),\nivec4(9780,48,67,100),\nivec4(9780,48,70,100),\nivec4(9840,48,68,100),\nivec4(9840,192,50,100),\nivec4(9840,288,65,100),\nivec4(9900,48,67,100),\nivec4(9960,48,68,100),\nivec4(10020,48,77,100),\nivec4(10080,48,67,100),\nivec4(10080,192,39,100),\nivec4(10140,48,68,100),\nivec4(10140,48,77,100),\nivec4(10200,48,67,100),\nivec4(10200,48,75,100),\nivec4(10260,48,65,100),\nivec4(10260,48,74,100),\nivec4(10320,48,72,100),\nivec4(10320,288,63,100),\nivec4(10320,384,44,100),\nivec4(10380,48,70,100),\nivec4(10440,48,68,100),\nivec4(10500,48,67,100),\nivec4(10560,288,65,100),\nivec4(10620,48,62,100),\nivec4(10680,48,63,100),\nivec4(10740,48,65,100),\nivec4(10800,96,59,100),\nivec4(10800,192,43,100),\nivec4(10860,48,68,100),\nivec4(10920,48,67,100),\nivec4(10920,96,62,100),\nivec4(10980,48,65,100),\nivec4(11040,96,63,100),\nivec4(11040,96,67,100),\nivec4(11100,48,55,100),\nivec4(11160,48,53,100),\nivec4(11160,96,67,100),\nivec4(11160,96,71,100),\nivec4(11220,48,55,100),\nivec4(11280,48,51,100),\nivec4(11280,96,69,100),\nivec4(11280,96,72,100),\nivec4(11340,48,53,100),\nivec4(11400,48,50,100),\nivec4(11400,96,71,100),\nivec4(11400,96,74,100),\nivec4(11460,48,51,100),\nivec4(11520,48,75,100),\nivec4(11520,96,48,100),\nivec4(11520,96,72,100),\nivec4(11580,48,72,100),\nivec4(11640,48,71,100),\nivec4(11640,96,51,100),\nivec4(11700,48,72,100),\nivec4(11760,48,67,100),\nivec4(11760,96,48,100),\nivec4(11820,48,72,100),\nivec4(11880,48,71,100),\nivec4(11880,96,51,100),\nivec4(11940,48,72,100),\nivec4(12000,48,75,100),\nivec4(12000,96,48,100),\nivec4(12060,48,72,100),\nivec4(12120,48,71,100),\nivec4(12120,96,51,100),\nivec4(12180,48,72,100),\nivec4(12240,96,41,100),\nivec4(12240,96,68,100),\nivec4(12300,48,65,100),\nivec4(12360,48,63,100),\nivec4(12360,96,56,100),\nivec4(12420,48,65,100),\nivec4(12480,48,60,100),\nivec4(12480,96,41,100),\nivec4(12480,96,75,100),\nivec4(12540,48,65,100),\nivec4(12600,48,63,100),\nivec4(12600,96,56,100),\nivec4(12660,48,65,100),\nivec4(12720,48,68,100),\nivec4(12720,96,41,100),\nivec4(12720,96,75,100),\nivec4(12780,48,65,100),\nivec4(12840,48,63,100),\nivec4(12840,96,56,100),\nivec4(12900,48,65,100),\nivec4(12960,96,46,100),\nivec4(12960,96,62,100),\nivec4(13020,48,70,100),\nivec4(13080,48,68,100),\nivec4(13080,96,50,100),\nivec4(13140,48,70,100),\nivec4(13200,48,65,100),\nivec4(13200,96,46,100),\nivec4(13200,96,68,100),\nivec4(13260,48,70,100),\nivec4(13320,48,68,100),\nivec4(13320,96,50,100),\nivec4(13380,48,70,100),\nivec4(13440,48,74,100),\nivec4(13440,96,46,100),\nivec4(13440,96,68,100),\nivec4(13500,48,70,100),\nivec4(13560,48,68,100),\nivec4(13560,96,50,100),\nivec4(13620,48,70,100),\nivec4(13680,96,39,100),\nivec4(13680,96,67,100),\nivec4(13740,48,63,100),\nivec4(13800,48,61,100),\nivec4(13800,96,55,100),\nivec4(13860,48,63,100),\nivec4(13920,48,58,100),\nivec4(13920,96,39,100),\nivec4(13920,96,73,100),\nivec4(13980,48,63,100),\nivec4(14040,48,61,100),\nivec4(14040,96,55,100),\nivec4(14100,48,63,100),\nivec4(14160,48,67,100),\nivec4(14160,96,39,100),\nivec4(14160,96,73,100),\nivec4(14220,48,63,100),\nivec4(14280,48,61,100),\nivec4(14280,96,55,100),\nivec4(14340,48,63,100),\nivec4(14400,48,60,100),\nivec4(14400,96,44,100),\nivec4(14460,48,65,100),\nivec4(14460,48,68,100),\nivec4(14520,48,64,100),\nivec4(14520,48,67,100),\nivec4(14520,96,48,100),\nivec4(14580,48,65,100),\nivec4(14580,48,68,100),\nivec4(14640,48,60,100),\nivec4(14640,48,65,100),\nivec4(14640,96,44,100),\nivec4(14700,48,65,100),\nivec4(14700,48,68,100),\nivec4(14760,48,64,100),\nivec4(14760,48,67,100),\nivec4(14760,96,48,100),\nivec4(14820,48,65,100),\nivec4(14820,48,68,100),\nivec4(14880,48,68,100),\nivec4(14880,48,72,100),\nivec4(14880,96,44,100),\nivec4(14940,48,65,100),\nivec4(14940,48,68,100),\nivec4(15000,48,64,100),\nivec4(15000,48,67,100),\nivec4(15000,96,48,100),\nivec4(15060,48,65,100),\nivec4(15060,48,68,100),\nivec4(15120,48,65,100),\nivec4(15120,96,44,100),\nivec4(15120,96,62,100),\nivec4(15180,48,70,100),\nivec4(15240,48,68,100),\nivec4(15240,96,50,100),\nivec4(15240,96,65,100),\nivec4(15300,48,70,100),\nivec4(15360,48,74,100),\nivec4(15360,96,44,100),\nivec4(15360,528,70,100),\nivec4(15420,48,70,100),\nivec4(15480,48,68,100),\nivec4(15480,96,50,100),\nivec4(15540,48,70,100),\nivec4(15600,48,77,100),\nivec4(15600,96,44,100),\nivec4(15660,48,74,100),\nivec4(15720,48,72,100),\nivec4(15720,96,50,100),\nivec4(15780,48,74,100),\nivec4(15840,96,43,100),\nivec4(15840,96,82,100),\nivec4(15900,48,70,100),\nivec4(15960,48,68,100),\nivec4(15960,96,51,100),\nivec4(15960,96,79,100),\nivec4(16020,48,70,100),\nivec4(16080,48,75,100),\nivec4(16080,96,43,100),\nivec4(16080,528,75,100),\nivec4(16140,48,70,100),\nivec4(16200,48,68,100),\nivec4(16200,96,51,100),\nivec4(16260,48,70,100),\nivec4(16320,48,67,100),\nivec4(16320,96,43,100),\nivec4(16380,48,63,100),\nivec4(16440,48,62,100),\nivec4(16440,96,51,100),\nivec4(16500,48,63,100),\nivec4(16560,48,69,100),\nivec4(16560,192,41,100),\nivec4(16620,48,70,100),\nivec4(16620,48,74,100),\nivec4(16680,48,69,100),\nivec4(16680,48,72,100),\nivec4(16740,48,67,100),\nivec4(16740,48,70,100),\nivec4(16800,48,65,100),\nivec4(16800,48,69,100),\nivec4(16860,48,70,100),\nivec4(16860,48,74,100),\nivec4(16920,48,69,100),\nivec4(16920,48,72,100),\nivec4(16980,48,67,100),\nivec4(16980,48,70,100),\nivec4(17040,48,65,100),\nivec4(17040,48,69,100),\nivec4(17100,48,67,100),\nivec4(17100,48,75,100),\nivec4(17160,48,65,100),\nivec4(17160,48,74,100),\nivec4(17220,48,63,100),\nivec4(17220,48,72,100),\nivec4(17280,48,62,100),\nivec4(17280,96,46,100),\nivec4(17280,768,70,100),\nivec4(17340,48,60,100),\nivec4(17400,48,62,100),\nivec4(17400,96,58,100),\nivec4(17460,48,65,100),\nivec4(17520,48,63,100),\nivec4(17520,96,48,100),\nivec4(17580,48,62,100),\nivec4(17640,48,63,100),\nivec4(17640,96,58,100),\nivec4(17700,48,67,100),\nivec4(17760,48,65,100),\nivec4(17760,96,50,100),\nivec4(17820,48,63,100),\nivec4(17880,48,65,100),\nivec4(17880,96,58,100),\nivec4(17940,48,68,100),\nivec4(18000,48,67,100),\nivec4(18000,96,51,100),\nivec4(18060,48,65,100),\nivec4(18060,48,69,100),\nivec4(18120,48,67,100),\nivec4(18120,48,70,100),\nivec4(18120,96,58,100),\nivec4(18180,48,70,100),\nivec4(18180,48,75,100),\nivec4(18240,48,62,100),\nivec4(18240,48,70,100),\nivec4(18240,96,53,100),\nivec4(18300,48,60,100),\nivec4(18300,48,69,100),\nivec4(18360,48,62,100),\nivec4(18360,48,70,100),\nivec4(18360,96,58,100),\nivec4(18420,48,70,100),\nivec4(18420,48,74,100),\nivec4(18480,48,63,100),\nivec4(18480,96,55,100),\nivec4(18480,288,72,100),\nivec4(18540,48,62,100),\nivec4(18600,48,63,100),\nivec4(18600,96,58,100),\nivec4(18660,48,70,100),\nivec4(18720,96,53,100),\nivec4(18720,192,62,100),\nivec4(18780,48,79,100),\nivec4(18840,48,77,100),\nivec4(18840,96,58,100),\nivec4(18900,48,75,100),\nivec4(18960,48,74,100),\nivec4(18960,96,51,100),\nivec4(19020,48,74,100),\nivec4(19020,48,82,100),\nivec4(19080,48,72,100),\nivec4(19080,48,81,100),\nivec4(19080,96,58,100),\nivec4(19140,48,70,100),\nivec4(19140,48,79,100),\nivec4(19200,48,69,100),\nivec4(19200,48,77,100),\nivec4(19200,96,53,100),\nivec4(19260,48,67,100),\nivec4(19260,48,75,100),\nivec4(19320,48,65,100),\nivec4(19320,48,74,100),\nivec4(19320,96,57,100),\nivec4(19380,48,63,100),\nivec4(19380,48,72,100),\nivec4(19440,48,62,100),\nivec4(19440,96,70,100),\nivec4(19440,192,46,100),\nivec4(19500,48,70,100),\nivec4(19560,48,69,100),\nivec4(19560,96,77,100),\nivec4(19620,48,70,100),\nivec4(19680,48,63,100),\nivec4(19680,96,79,100),\nivec4(19740,48,70,100),\nivec4(19800,48,62,100),\nivec4(19800,96,77,100),\nivec4(19860,48,70,100),\nivec4(19920,48,63,100),\nivec4(19920,96,79,100),\nivec4(19980,48,70,100),\nivec4(20040,48,60,100),\nivec4(20040,96,75,100),\nivec4(20100,48,70,100),\nivec4(20160,48,77,100),\nivec4(20160,96,62,100),\nivec4(20160,192,46,100),\nivec4(20220,48,82,100),\nivec4(20280,48,81,100),\nivec4(20280,96,65,100),\nivec4(20340,48,82,100),\nivec4(20400,48,75,100),\nivec4(20400,96,67,100),\nivec4(20460,48,82,100),\nivec4(20520,48,74,100),\nivec4(20520,96,65,100),\nivec4(20580,48,82,100),\nivec4(20640,48,75,100),\nivec4(20640,96,67,100),\nivec4(20700,48,82,100),\nivec4(20760,48,72,100),\nivec4(20760,96,63,100),\nivec4(20820,48,82,100),\nivec4(20880,48,65,100),\nivec4(20880,288,74,100),\nivec4(20940,48,58,100),\nivec4(21000,48,60,100),\nivec4(21000,96,53,100),\nivec4(21060,48,62,100),\nivec4(21120,96,55,100),\nivec4(21120,288,63,100),\nivec4(21180,48,70,100),\nivec4(21240,48,72,100),\nivec4(21240,96,53,100),\nivec4(21300,48,74,100),\nivec4(21360,48,75,100),\nivec4(21360,96,55,100),\nivec4(21420,48,62,100),\nivec4(21420,48,77,100),\nivec4(21480,48,63,100),\nivec4(21480,48,79,100),\nivec4(21480,96,51,100),\nivec4(21540,48,60,100),\nivec4(21540,48,81,100),\nivec4(21600,96,50,100),\nivec4(21600,96,65,100),\nivec4(21600,96,82,100),\nivec4(21720,96,55,100),\nivec4(21720,96,62,100),\nivec4(21720,96,70,100),\nivec4(21840,90,51,100),\nivec4(21840,90,63,100),\nivec4(21840,90,72,100),\nivec4(22080,192,53,100),\nivec4(22080,192,69,100),\nivec4(22080,240,60,100),\nivec4(22320,576,46,100),\nivec4(22320,576,62,100),\nivec4(22320,576,70,100),\nivec4(23040,96,63,100),\nivec4(23040,384,51,100),\nivec4(23160,96,75,100),\nivec4(23280,96,65,100),\nivec4(23400,96,75,100),\nivec4(23520,96,67,100),\nivec4(23640,96,75,100),\nivec4(23760,96,68,100),\nivec4(23760,384,48,100),\nivec4(23880,96,75,100),\nivec4(24000,96,70,100),\nivec4(24120,96,75,100),\nivec4(24240,96,72,100),\nivec4(24360,96,75,100),\nivec4(24480,48,70,100),\nivec4(24480,288,43,100),\nivec4(24540,48,75,100),\nivec4(24600,48,74,100),\nivec4(24660,48,72,100),\nivec4(24720,48,70,100),\nivec4(24780,48,79,100),\nivec4(24840,48,77,100),\nivec4(24840,96,44,100),\nivec4(24900,48,75,100),\nivec4(24960,48,74,100),\nivec4(24960,192,46,100),\nivec4(25020,48,72,100),\nivec4(25080,48,70,100),\nivec4(25140,48,68,100),\nivec4(25200,48,67,100),\nivec4(25200,192,39,100),\nivec4(25260,48,68,100),\nivec4(25320,48,70,100),\nivec4(25380,48,67,100),\nivec4(25440,48,63,100),\nivec4(25440,192,43,100),\nivec4(25500,48,67,100),\nivec4(25560,48,70,100),\nivec4(25620,48,75,100),\nivec4(25680,48,65,100),\nivec4(25680,192,45,100),\nivec4(25740,48,69,100),\nivec4(25800,48,72,100),\nivec4(25860,48,75,100),\nivec4(25920,48,74,100),\nivec4(25920,96,58,100),\nivec4(25920,450,46,100),\nivec4(25980,48,72,100),\nivec4(26040,48,74,100),\nivec4(26040,96,70,100),\nivec4(26100,48,77,100),\nivec4(26160,48,75,100),\nivec4(26160,96,60,100),\nivec4(26220,48,74,100),\nivec4(26280,48,75,100),\nivec4(26280,96,70,100),\nivec4(26340,48,79,100),\nivec4(26400,48,77,100),\nivec4(26400,96,62,100),\nivec4(26460,48,75,100),\nivec4(26520,48,77,100),\nivec4(26520,96,70,100),\nivec4(26580,48,80,100),\nivec4(26640,48,79,100),\nivec4(26640,96,63,100),\nivec4(26640,384,46,100),\nivec4(26700,48,77,100),\nivec4(26760,48,79,100),\nivec4(26760,96,70,100),\nivec4(26820,48,82,100),\nivec4(26880,48,74,100),\nivec4(26880,96,65,100),\nivec4(26940,48,72,100),\nivec4(27000,48,74,100),\nivec4(27000,96,70,100),\nivec4(27060,48,82,100),\nivec4(27120,48,75,100),\nivec4(27120,96,67,100),\nivec4(27180,48,74,100),\nivec4(27240,48,75,100),\nivec4(27240,96,70,100),\nivec4(27300,48,82,100),\nivec4(27360,48,65,100),\nivec4(27360,96,74,100),\nivec4(27360,240,46,100),\nivec4(27420,48,70,100),\nivec4(27480,48,69,100),\nivec4(27480,96,77,100),\nivec4(27540,48,67,100),\nivec4(27600,48,65,100),\nivec4(27600,96,82,100),\nivec4(27600,240,50,100),\nivec4(27660,48,74,100),\nivec4(27720,48,72,100),\nivec4(27720,96,74,100),\nivec4(27780,48,70,100),\nivec4(27840,48,69,100),\nivec4(27840,96,72,100),\nivec4(27840,240,53,100),\nivec4(27900,48,67,100),\nivec4(27960,48,65,100),\nivec4(27960,96,81,100),\nivec4(28020,48,63,100),\nivec4(28080,48,62,100),\nivec4(28080,96,82,100),\nivec4(28080,480,58,100),\nivec4(28140,48,63,100),\nivec4(28200,48,65,100),\nivec4(28200,96,74,100),\nivec4(28260,48,62,100),\nivec4(28320,48,58,100),\nivec4(28320,96,77,100),\nivec4(28380,48,62,100),\nivec4(28440,48,65,100),\nivec4(28440,96,74,100),\nivec4(28500,48,70,100),\nivec4(28560,48,62,100),\nivec4(28560,96,70,100),\nivec4(28620,48,65,100),\nivec4(28680,48,68,100),\nivec4(28680,96,74,100),\nivec4(28740,48,70,100),\nivec4(28800,48,67,100),\nivec4(28800,96,39,100),\nivec4(28800,96,75,100),\nivec4(28860,48,65,100),\nivec4(28920,48,67,100),\nivec4(28920,96,51,100),\nivec4(28980,48,70,100),\nivec4(29040,48,68,100),\nivec4(29040,96,41,100),\nivec4(29040,96,75,100),\nivec4(29100,48,67,100),\nivec4(29160,48,68,100),\nivec4(29160,96,51,100),\nivec4(29220,48,72,100),\nivec4(29280,48,70,100),\nivec4(29280,96,43,100),\nivec4(29280,96,75,100),\nivec4(29340,48,68,100),\nivec4(29400,48,70,100),\nivec4(29400,96,51,100),\nivec4(29460,48,73,100),\nivec4(29520,48,72,100),\nivec4(29520,96,44,100),\nivec4(29520,96,75,100),\nivec4(29580,48,70,100),\nivec4(29640,48,72,100),\nivec4(29640,96,51,100),\nivec4(29700,48,75,100),\nivec4(29760,48,67,100),\nivec4(29760,96,46,100),\nivec4(29760,96,75,100),\nivec4(29820,48,65,100),\nivec4(29880,48,67,100),\nivec4(29880,96,51,100),\nivec4(29940,48,75,100),\nivec4(30000,48,68,100),\nivec4(30000,96,48,100),\nivec4(30000,96,75,100),\nivec4(30060,48,67,100),\nivec4(30120,48,68,100),\nivec4(30120,96,51,100),\nivec4(30180,48,75,100),\nivec4(30240,96,46,100),\nivec4(30240,96,67,100),\nivec4(30300,48,75,100),\nivec4(30360,48,77,100),\nivec4(30360,96,70,100),\nivec4(30420,48,79,100),\nivec4(30480,48,80,100),\nivec4(30480,96,48,100),\nivec4(30480,96,75,100),\nivec4(30540,48,82,100),\nivec4(30600,48,84,100),\nivec4(30600,96,67,100),\nivec4(30660,48,82,100),\nivec4(30720,48,80,100),\nivec4(30720,96,50,100),\nivec4(30720,96,65,100),\nivec4(30780,48,79,100),\nivec4(30840,48,77,100),\nivec4(30840,96,70,100),\nivec4(30900,48,80,100),\nivec4(30960,96,79,100),\nivec4(30960,384,51,100),\nivec4(31020,48,63,100),\nivec4(31080,48,65,100),\nivec4(31080,96,70,100),\nivec4(31140,48,67,100),\nivec4(31200,48,68,100),\nivec4(31200,96,72,100),\nivec4(31260,48,70,100),\nivec4(31320,48,72,100),\nivec4(31320,96,68,100),\nivec4(31380,48,70,100),\nivec4(31440,48,68,100),\nivec4(31440,192,50,100),\nivec4(31440,288,77,100),\nivec4(31500,48,67,100),\nivec4(31560,48,65,100),\nivec4(31620,48,68,100),\nivec4(31680,96,67,100),\nivec4(31680,192,51,100),\nivec4(31740,48,80,100),\nivec4(31800,48,79,100),\nivec4(31800,96,70,100),\nivec4(31860,48,77,100),\nivec4(31920,48,75,100),\nivec4(31920,96,72,100),\nivec4(31920,192,56,100),\nivec4(31980,48,74,100),\nivec4(32040,48,72,100),\nivec4(32040,96,68,100),\nivec4(32100,48,70,100),\nivec4(32160,48,68,100),\nivec4(32160,288,77,100),\nivec4(32220,48,67,100),\nivec4(32280,48,68,100),\nivec4(32340,48,77,100),\nivec4(32400,48,67,100),\nivec4(32400,192,47,100),\nivec4(32460,48,77,100),\nivec4(32460,48,80,100),\nivec4(32520,48,75,100),\nivec4(32520,48,79,100),\nivec4(32580,48,74,100),\nivec4(32580,48,77,100),\nivec4(32640,48,72,100),\nivec4(32640,48,75,100),\nivec4(32640,192,48,100),\nivec4(32700,48,70,100),\nivec4(32700,48,74,100),\nivec4(32760,48,68,100),\nivec4(32760,48,72,100),\nivec4(32820,48,67,100),\nivec4(32820,48,70,100),\nivec4(32880,48,68,100),\nivec4(32880,192,50,100),\nivec4(32880,288,65,100),\nivec4(32940,48,67,100),\nivec4(33000,48,68,100),\nivec4(33060,48,77,100),\nivec4(33120,48,67,100),\nivec4(33120,192,39,100),\nivec4(33180,48,68,100),\nivec4(33180,48,77,100),\nivec4(33240,48,67,100),\nivec4(33240,48,75,100),\nivec4(33300,48,65,100),\nivec4(33300,48,74,100),\nivec4(33360,48,72,100),\nivec4(33360,288,63,100),\nivec4(33360,384,44,100),\nivec4(33420,48,70,100),\nivec4(33480,48,68,100),\nivec4(33540,48,67,100),\nivec4(33600,288,65,100),\nivec4(33660,48,62,100),\nivec4(33720,48,63,100),\nivec4(33780,48,65,100),\nivec4(33840,96,59,100),\nivec4(33840,192,43,100),\nivec4(33900,48,68,100),\nivec4(33960,48,67,100),\nivec4(33960,96,62,100),\nivec4(34020,48,65,100),\nivec4(34080,96,63,100),\nivec4(34080,96,67,100),\nivec4(34140,48,55,100),\nivec4(34200,48,53,100),\nivec4(34200,96,67,100),\nivec4(34200,96,71,100),\nivec4(34260,48,55,100),\nivec4(34320,48,51,100),\nivec4(34320,96,69,100),\nivec4(34320,96,72,100),\nivec4(34380,48,53,100),\nivec4(34440,48,50,100),\nivec4(34440,96,71,100),\nivec4(34440,96,74,100),\nivec4(34500,48,51,100),\nivec4(34560,48,75,100),\nivec4(34560,96,48,100),\nivec4(34560,96,72,100),\nivec4(34620,48,72,100),\nivec4(34680,48,71,100),\nivec4(34680,96,51,100),\nivec4(34740,48,72,100),\nivec4(34800,48,67,100),\nivec4(34800,96,48,100),\nivec4(34860,48,72,100),\nivec4(34920,48,71,100),\nivec4(34920,96,51,100),\nivec4(34980,48,72,100),\nivec4(35040,48,75,100),\nivec4(35040,96,48,100),\nivec4(35100,48,72,100),\nivec4(35160,48,71,100),\nivec4(35160,96,51,100),\nivec4(35220,48,72,100),\nivec4(35280,96,41,100),\nivec4(35280,96,68,100),\nivec4(35340,48,65,100),\nivec4(35400,48,63,100),\nivec4(35400,96,56,100),\nivec4(35460,48,65,100),\nivec4(35520,48,60,100),\nivec4(35520,96,41,100),\nivec4(35520,96,75,100),\nivec4(35580,48,65,100),\nivec4(35640,48,63,100),\nivec4(35640,96,56,100),\nivec4(35700,48,65,100),\nivec4(35760,48,68,100),\nivec4(35760,96,41,100),\nivec4(35760,96,75,100),\nivec4(35820,48,65,100),\nivec4(35880,48,63,100),\nivec4(35880,96,56,100),\nivec4(35940,48,65,100),\nivec4(36000,96,46,100),\nivec4(36000,96,62,100),\nivec4(36060,48,70,100),\nivec4(36120,48,68,100),\nivec4(36120,96,50,100),\nivec4(36180,48,70,100),\nivec4(36240,48,65,100),\nivec4(36240,96,46,100),\nivec4(36240,96,68,100),\nivec4(36300,48,70,100),\nivec4(36360,48,68,100),\nivec4(36360,96,50,100),\nivec4(36420,48,70,100),\nivec4(36480,48,74,100),\nivec4(36480,96,46,100),\nivec4(36480,96,68,100),\nivec4(36540,48,70,100),\nivec4(36600,48,68,100),\nivec4(36600,96,50,100),\nivec4(36660,48,70,100),\nivec4(36720,96,39,100),\nivec4(36720,96,67,100),\nivec4(36780,48,63,100),\nivec4(36840,48,61,100),\nivec4(36840,96,55,100),\nivec4(36900,48,63,100),\nivec4(36960,48,58,100),\nivec4(36960,96,39,100),\nivec4(36960,96,73,100),\nivec4(37020,48,63,100),\nivec4(37080,48,61,100),\nivec4(37080,96,55,100),\nivec4(37140,48,63,100),\nivec4(37200,48,67,100),\nivec4(37200,96,39,100),\nivec4(37200,96,73,100),\nivec4(37260,48,63,100),\nivec4(37320,48,61,100),\nivec4(37320,96,55,100),\nivec4(37380,48,63,100),\nivec4(37440,48,60,100),\nivec4(37440,96,44,100),\nivec4(37500,48,65,100),\nivec4(37500,48,68,100),\nivec4(37560,48,64,100),\nivec4(37560,48,67,100),\nivec4(37560,96,48,100),\nivec4(37620,48,65,100),\nivec4(37620,48,68,100),\nivec4(37680,48,60,100),\nivec4(37680,48,65,100),\nivec4(37680,96,44,100),\nivec4(37740,48,65,100),\nivec4(37740,48,68,100),\nivec4(37800,48,64,100),\nivec4(37800,48,67,100),\nivec4(37800,96,48,100),\nivec4(37860,48,65,100),\nivec4(37860,48,68,100),\nivec4(37920,48,68,100),\nivec4(37920,48,72,100),\nivec4(37920,96,44,100),\nivec4(37980,48,65,100),\nivec4(37980,48,68,100),\nivec4(38040,48,64,100),\nivec4(38040,48,67,100),\nivec4(38040,96,48,100),\nivec4(38100,48,65,100),\nivec4(38100,48,68,100),\nivec4(38160,48,65,100),\nivec4(38160,96,44,100),\nivec4(38160,96,62,100),\nivec4(38220,48,70,100),\nivec4(38280,48,68,100),\nivec4(38280,96,50,100),\nivec4(38280,96,65,100),\nivec4(38340,48,70,100),\nivec4(38400,48,74,100),\nivec4(38400,96,44,100),\nivec4(38400,528,70,100),\nivec4(38460,48,70,100),\nivec4(38520,48,68,100),\nivec4(38520,96,50,100),\nivec4(38580,48,70,100),\nivec4(38640,48,77,100),\nivec4(38640,96,44,100),\nivec4(38700,48,74,100),\nivec4(38760,48,72,100),\nivec4(38760,96,50,100),\nivec4(38820,48,74,100),\nivec4(38880,96,43,100),\nivec4(38880,96,82,100),\nivec4(38940,48,70,100),\nivec4(39000,48,68,100),\nivec4(39000,96,51,100),\nivec4(39000,96,79,100),\nivec4(39060,48,70,100),\nivec4(39120,48,75,100),\nivec4(39120,96,43,100),\nivec4(39120,528,75,100),\nivec4(39180,48,70,100),\nivec4(39240,48,68,100),\nivec4(39240,96,51,100),\nivec4(39300,48,70,100),\nivec4(39360,48,67,100),\nivec4(39360,96,43,100),\nivec4(39420,48,63,100),\nivec4(39480,48,62,100),\nivec4(39480,96,51,100),\nivec4(39540,48,63,100),\nivec4(39600,48,69,100),\nivec4(39600,192,41,100),\nivec4(39660,48,70,100),\nivec4(39660,48,74,100),\nivec4(39720,48,69,100),\nivec4(39720,48,72,100),\nivec4(39780,48,67,100),\nivec4(39780,48,70,100),\nivec4(39840,48,65,100),\nivec4(39840,48,69,100),\nivec4(39900,48,70,100),\nivec4(39900,48,74,100),\nivec4(39960,48,69,100),\nivec4(39960,48,72,100),\nivec4(40020,48,67,100),\nivec4(40020,48,70,100),\nivec4(40080,48,65,100),\nivec4(40080,48,69,100),\nivec4(40140,48,67,100),\nivec4(40140,48,75,100),\nivec4(40200,48,65,100),\nivec4(40200,48,74,100),\nivec4(40260,48,63,100),\nivec4(40260,48,72,100),\nivec4(40320,48,62,100),\nivec4(40320,96,46,100),\nivec4(40320,768,70,100),\nivec4(40380,48,60,100),\nivec4(40440,48,62,100),\nivec4(40440,96,58,100),\nivec4(40500,48,65,100),\nivec4(40560,48,63,100),\nivec4(40560,96,48,100),\nivec4(40620,48,62,100),\nivec4(40680,48,63,100),\nivec4(40680,96,58,100),\nivec4(40740,48,67,100),\nivec4(40800,48,65,100),\nivec4(40800,96,50,100),\nivec4(40860,48,63,100),\nivec4(40920,48,65,100),\nivec4(40920,96,58,100),\nivec4(40980,48,68,100),\nivec4(41040,48,67,100),\nivec4(41040,96,51,100),\nivec4(41100,48,65,100),\nivec4(41100,48,69,100),\nivec4(41160,48,67,100),\nivec4(41160,48,70,100),\nivec4(41160,96,58,100),\nivec4(41220,48,70,100),\nivec4(41220,48,75,100),\nivec4(41280,48,62,100),\nivec4(41280,48,70,100),\nivec4(41280,96,53,100),\nivec4(41340,48,60,100),\nivec4(41340,48,69,100),\nivec4(41400,48,62,100),\nivec4(41400,48,70,100),\nivec4(41400,96,58,100),\nivec4(41460,48,70,100),\nivec4(41460,48,74,100),\nivec4(41520,48,63,100),\nivec4(41520,96,55,100),\nivec4(41520,288,72,100),\nivec4(41580,48,62,100),\nivec4(41640,48,63,100),\nivec4(41640,96,58,100),\nivec4(41700,48,70,100),\nivec4(41760,96,53,100),\nivec4(41760,192,62,100),\nivec4(41820,48,79,100),\nivec4(41880,48,77,100),\nivec4(41880,96,58,100),\nivec4(41940,48,75,100),\nivec4(42000,48,74,100),\nivec4(42000,96,51,100),\nivec4(42060,48,74,100),\nivec4(42060,48,82,100),\nivec4(42120,48,72,100),\nivec4(42120,48,81,100),\nivec4(42120,96,58,100),\nivec4(42180,48,70,100),\nivec4(42180,48,79,100),\nivec4(42240,48,69,100),\nivec4(42240,48,77,100),\nivec4(42240,96,53,100),\nivec4(42300,48,67,100),\nivec4(42300,48,75,100),\nivec4(42360,48,65,100),\nivec4(42360,48,74,100),\nivec4(42360,96,57,100),\nivec4(42420,48,63,100),\nivec4(42420,48,72,100),\nivec4(42480,48,62,100),\nivec4(42480,96,70,100),\nivec4(42480,192,46,100),\nivec4(42540,48,70,100),\nivec4(42600,48,69,100),\nivec4(42600,96,77,100),\nivec4(42660,48,70,100),\nivec4(42720,48,63,100),\nivec4(42720,96,79,100),\nivec4(42780,48,70,100),\nivec4(42840,48,62,100),\nivec4(42840,96,77,100),\nivec4(42900,48,70,100),\nivec4(42960,48,63,100),\nivec4(42960,96,79,100),\nivec4(43020,48,70,100),\nivec4(43080,48,60,100),\nivec4(43080,96,75,100),\nivec4(43140,48,70,100),\nivec4(43200,48,77,100),\nivec4(43200,96,62,100),\nivec4(43200,192,46,100),\nivec4(43260,48,82,100),\nivec4(43320,48,81,100),\nivec4(43320,96,65,100),\nivec4(43380,48,82,100),\nivec4(43440,48,75,100),\nivec4(43440,96,67,100),\nivec4(43500,48,82,100),\nivec4(43560,48,74,100),\nivec4(43560,96,65,100),\nivec4(43620,48,82,100),\nivec4(43680,48,75,100),\nivec4(43680,96,67,100),\nivec4(43740,48,82,100),\nivec4(43800,48,72,100),\nivec4(43800,96,63,100),\nivec4(43860,48,82,100),\nivec4(43920,48,65,100),\nivec4(43920,288,74,100),\nivec4(43980,48,58,100),\nivec4(44040,48,60,100),\nivec4(44040,96,53,100),\nivec4(44100,48,62,100),\nivec4(44160,96,55,100),\nivec4(44160,288,63,100),\nivec4(44220,48,70,100),\nivec4(44280,48,72,100),\nivec4(44280,96,53,100),\nivec4(44340,48,74,100),\nivec4(44400,48,75,100),\nivec4(44400,96,55,100),\nivec4(44460,48,62,100),\nivec4(44460,48,77,100),\nivec4(44520,48,63,100),\nivec4(44520,48,79,100),\nivec4(44520,96,51,100),\nivec4(44580,48,60,100),\nivec4(44580,48,81,100),\nivec4(44640,96,50,100),\nivec4(44640,96,65,100),\nivec4(44640,96,82,100),\nivec4(44760,96,55,100),\nivec4(44760,96,62,100),\nivec4(44760,96,70,100),\nivec4(44880,90,51,100),\nivec4(44880,90,63,100),\nivec4(44880,90,72,100),\nivec4(45120,192,53,100),\nivec4(45120,192,69,100),\nivec4(45120,240,60,100),\nivec4(45360,576,46,100),\nivec4(45360,576,62,100),\nivec4(45360,576,70,100));\n#if 0\nivec4(46080,96,77,127),\nivec4(46080,384,46,127),\nivec4(46200,96,65,127),\nivec4(46320,96,75,127),\nivec4(46440,96,65,127),\nivec4(46560,96,74,127),\nivec4(46680,96,65,127),\nivec4(46800,96,72,127),\nivec4(46800,384,51,127),\nivec4(46920,96,65,127),\nivec4(47040,96,70,127),\nivec4(47160,96,65,127),\nivec4(47280,96,69,127),\nivec4(47400,96,65,127),\nivec4(47520,48,70,127),\nivec4(47520,192,50,127),\nivec4(47580,48,65,127),\nivec4(47640,48,67,127),\nivec4(47700,48,69,127),\nivec4(47760,48,70,127),\nivec4(47760,192,55,127),\nivec4(47820,48,62,127),\nivec4(47880,48,63,127),\nivec4(47940,48,65,127),\nivec4(48000,48,67,127),\nivec4(48000,192,53,127),\nivec4(48060,48,69,127),\nivec4(48120,48,70,127),\nivec4(48180,48,72,127),\nivec4(48240,48,74,127),\nivec4(48240,192,58,127),\nivec4(48300,48,72,127),\nivec4(48360,48,70,127),\nivec4(48420,48,74,127),\nivec4(48480,48,77,127),\nivec4(48480,192,50,127),\nivec4(48540,48,74,127),\nivec4(48600,48,70,127),\nivec4(48660,48,65,127),\nivec4(48720,48,74,127),\nivec4(48720,192,46,127),\nivec4(48780,48,70,127),\nivec4(48840,48,68,127),\nivec4(48900,48,65,127),\nivec4(48960,48,67,127),\nivec4(48960,96,82,127),\nivec4(48960,384,51,127),\nivec4(49020,48,68,127),\nivec4(49080,48,67,127),\nivec4(49080,96,70,127),\nivec4(49140,48,63,127),\nivec4(49200,48,65,127),\nivec4(49200,96,80,127),\nivec4(49260,48,67,127),\nivec4(49320,48,65,127),\nivec4(49320,96,70,127),\nivec4(49380,48,62,127),\nivec4(49440,48,63,127),\nivec4(49440,96,79,127),\nivec4(49500,48,65,127),\nivec4(49560,48,63,127),\nivec4(49560,96,70,127),\nivec4(49620,48,60,127),\nivec4(49680,48,62,127),\nivec4(49680,96,77,127),\nivec4(49680,384,58,127),\nivec4(49740,48,63,127),\nivec4(49800,48,62,127),\nivec4(49800,96,70,127),\nivec4(49860,48,58,127),\nivec4(49920,48,67,127),\nivec4(49920,96,75,127),\nivec4(49980,48,68,127),\nivec4(50040,48,67,127),\nivec4(50040,96,70,127),\nivec4(50100,48,58,127),\nivec4(50160,48,65,127),\nivec4(50160,96,74,127),\nivec4(50160,192,56,127),\nivec4(50220,48,67,127),\nivec4(50280,48,65,127),\nivec4(50280,96,70,127),\nivec4(50340,48,58,127),\nivec4(50400,48,75,127),\nivec4(50400,96,67,127),\nivec4(50400,192,55,127),\nivec4(50460,48,70,127),\nivec4(50520,48,72,127),\nivec4(50520,96,63,127),\nivec4(50580,48,74,127),\nivec4(50640,48,75,127),\nivec4(50640,96,58,127),\nivec4(50640,192,43,127),\nivec4(50700,48,67,127),\nivec4(50760,48,68,127),\nivec4(50760,96,67,127),\nivec4(50820,48,70,127),\nivec4(50880,48,72,127),\nivec4(50880,96,65,127),\nivec4(50880,192,46,127),\nivec4(50940,48,74,127),\nivec4(51000,48,75,127),\nivec4(51000,96,62,127),\nivec4(51060,48,77,127),\nivec4(51120,48,79,127),\nivec4(51120,96,63,127),\nivec4(51120,384,39,127),\nivec4(51180,48,77,127),\nivec4(51240,48,75,127),\nivec4(51240,96,70,127),\nivec4(51300,48,79,127),\nivec4(51360,48,82,127),\nivec4(51360,96,67,127),\nivec4(51420,48,79,127),\nivec4(51480,48,75,127),\nivec4(51480,96,70,127),\nivec4(51540,48,70,127),\nivec4(51600,48,79,127),\nivec4(51600,96,73,127),\nivec4(51660,48,75,127),\nivec4(51720,48,73,127),\nivec4(51720,96,67,127),\nivec4(51780,48,70,127),\nivec4(51840,48,72,127),\nivec4(51840,96,68,127),\nivec4(51900,48,73,127),\nivec4(51960,48,72,127),\nivec4(51960,96,51,127),\nivec4(52020,48,68,127),\nivec4(52080,48,70,127),\nivec4(52080,96,61,127),\nivec4(52080,96,67,127),\nivec4(52140,48,72,127),\nivec4(52200,48,70,127),\nivec4(52200,96,51,127),\nivec4(52260,48,67,127),\nivec4(52320,48,68,127),\nivec4(52320,96,60,127),\nivec4(52320,96,63,127),\nivec4(52380,48,70,127),\nivec4(52440,48,68,127),\nivec4(52440,96,51,127),\nivec4(52500,48,65,127),\nivec4(52560,48,67,127),\nivec4(52560,96,58,127),\nivec4(52560,96,63,127),\nivec4(52620,48,68,127),\nivec4(52680,48,67,127),\nivec4(52680,96,51,127),\nivec4(52740,48,63,127),\nivec4(52800,48,72,127),\nivec4(52800,96,56,127),\nivec4(52800,96,63,127),\nivec4(52860,48,73,127),\nivec4(52920,48,72,127),\nivec4(52920,96,51,127),\nivec4(52980,48,63,127),\nivec4(53040,48,70,127),\nivec4(53040,96,55,127),\nivec4(53040,96,63,127),\nivec4(53100,48,72,127),\nivec4(53160,48,70,127),\nivec4(53160,96,51,127),\nivec4(53220,48,63,127),\nivec4(53280,96,56,127),\nivec4(53280,96,72,127),\nivec4(53340,48,63,127),\nivec4(53400,48,65,127),\nivec4(53400,96,68,127),\nivec4(53460,48,67,127),\nivec4(53520,48,68,127),\nivec4(53520,96,55,127),\nivec4(53520,96,72,127),\nivec4(53580,48,70,127),\nivec4(53640,48,72,127),\nivec4(53640,96,63,127),\nivec4(53700,48,70,127),\nivec4(53760,48,68,127),\nivec4(53760,96,53,127),\nivec4(53760,96,65,127),\nivec4(53820,48,67,127),\nivec4(53880,48,65,127),\nivec4(53880,96,74,127),\nivec4(53940,48,68,127),\nivec4(54000,96,67,127),\nivec4(54000,384,51,127),\nivec4(54060,48,75,127),\nivec4(54120,48,77,127),\nivec4(54120,96,70,127),\nivec4(54180,48,79,127),\nivec4(54240,48,80,127),\nivec4(54240,96,72,127),\nivec4(54300,48,82,127),\nivec4(54360,48,84,127),\nivec4(54360,96,68,127),\nivec4(54420,48,82,127),\nivec4(54480,48,80,127),\nivec4(54480,192,50,127),\nivec4(54480,288,65,127),\nivec4(54540,48,79,127),\nivec4(54600,48,77,127),\nivec4(54660,48,80,127),\nivec4(54720,96,79,127),\nivec4(54720,192,51,127),\nivec4(54780,48,63,127),\nivec4(54840,48,65,127),\nivec4(54840,96,72,127),\nivec4(54900,48,67,127),\nivec4(54960,48,69,127),\nivec4(54960,96,77,127),\nivec4(54960,192,50,127),\nivec4(55020,48,71,127),\nivec4(55080,48,72,127),\nivec4(55080,192,68,127),\nivec4(55140,48,74,127),\nivec4(55200,48,75,127),\nivec4(55200,192,48,127),\nivec4(55260,48,77,127),\nivec4(55320,48,75,127),\nivec4(55320,96,77,127),\nivec4(55380,48,68,127),\nivec4(55440,48,67,127),\nivec4(55440,48,77,127),\nivec4(55440,96,47,127),\nivec4(55500,48,67,127),\nivec4(55500,48,71,127),\nivec4(55560,48,69,127),\nivec4(55560,48,72,127),\nivec4(55560,96,53,127),\nivec4(55620,48,71,127),\nivec4(55620,48,74,127),\nivec4(55680,48,72,127),\nivec4(55680,48,75,127),\nivec4(55680,96,51,127),\nivec4(55740,48,74,127),\nivec4(55740,48,77,127),\nivec4(55800,48,75,127),\nivec4(55800,48,79,127),\nivec4(55800,96,50,127),\nivec4(55860,48,77,127),\nivec4(55860,48,80,127),\nivec4(55920,48,82,127),\nivec4(55920,96,48,127),\nivec4(55920,288,79,127),\nivec4(55980,48,84,127),\nivec4(56040,48,82,127),\nivec4(56040,96,52,127),\nivec4(56100,48,72,127),\nivec4(56160,48,80,127),\nivec4(56160,192,41,127),\nivec4(56220,48,70,127),\nivec4(56220,48,79,127),\nivec4(56280,48,68,127),\nivec4(56280,48,77,127),\nivec4(56340,48,67,127),\nivec4(56340,48,76,127),\nivec4(56400,48,77,127),\nivec4(56400,288,68,127),\nivec4(56400,384,49,127),\nivec4(56460,48,75,127),\nivec4(56520,48,73,127),\nivec4(56580,48,72,127),\nivec4(56640,288,70,127),\nivec4(56700,48,68,127),\nivec4(56760,48,67,127),\nivec4(56820,48,65,127),\nivec4(56880,48,64,127),\nivec4(56880,192,48,127),\nivec4(56940,48,65,127),\nivec4(56940,48,68,127),\nivec4(57000,48,64,127),\nivec4(57000,48,67,127),\nivec4(57060,48,62,127),\nivec4(57060,48,65,127),\nivec4(57120,96,60,127),\nivec4(57120,96,64,127),\nivec4(57180,48,60,127),\nivec4(57240,48,58,127),\nivec4(57240,96,64,127),\nivec4(57240,96,72,127),\nivec4(57300,48,60,127),\nivec4(57360,48,56,127),\nivec4(57360,96,65,127),\nivec4(57360,96,74,127),\nivec4(57420,48,58,127),\nivec4(57480,48,55,127),\nivec4(57480,96,67,127),\nivec4(57480,96,76,127),\nivec4(57540,48,56,127),\nivec4(57600,48,68,127),\nivec4(57600,96,53,127),\nivec4(57600,96,77,127),\nivec4(57660,48,65,127),\nivec4(57720,48,64,127),\nivec4(57720,96,56,127),\nivec4(57780,48,65,127),\nivec4(57840,48,60,127),\nivec4(57840,96,53,127),\nivec4(57900,48,65,127),\nivec4(57960,48,64,127),\nivec4(57960,96,56,127),\nivec4(58020,48,65,127),\nivec4(58080,48,68,127),\nivec4(58080,96,53,127),\nivec4(58140,48,65,127),\nivec4(58200,48,63,127),\nivec4(58200,96,56,127),\nivec4(58260,48,65,127),\nivec4(58320,96,46,127),\nivec4(58320,96,61,127),\nivec4(58380,48,70,127),\nivec4(58440,48,68,127),\nivec4(58440,96,61,127),\nivec4(58500,48,70,127),\nivec4(58560,48,65,127),\nivec4(58560,96,46,127),\nivec4(58560,96,68,127),\nivec4(58620,48,70,127),\nivec4(58680,48,68,127),\nivec4(58680,96,61,127),\nivec4(58740,48,70,127),\nivec4(58800,48,73,127),\nivec4(58800,96,46,127),\nivec4(58800,96,68,127),\nivec4(58860,48,70,127),\nivec4(58920,48,68,127),\nivec4(58920,96,61,127),\nivec4(58980,48,70,127),\nivec4(59040,96,51,127),\nivec4(59040,96,67,127),\nivec4(59100,48,63,127),\nivec4(59160,48,61,127),\nivec4(59160,96,55,127),\nivec4(59220,48,63,127),\nivec4(59280,48,58,127),\nivec4(59280,96,51,127),\nivec4(59280,96,73,127),\nivec4(59340,48,63,127),\nivec4(59400,48,61,127),\nivec4(59400,96,55,127),\nivec4(59460,48,63,127),\nivec4(59520,48,67,127),\nivec4(59520,96,51,127),\nivec4(59520,96,73,127),\nivec4(59580,48,63,127),\nivec4(59640,48,61,127),\nivec4(59640,96,55,127),\nivec4(59700,48,63,127),\nivec4(59760,96,44,127),\nivec4(59760,96,60,127),\nivec4(59820,48,68,127),\nivec4(59880,48,66,127),\nivec4(59880,96,60,127),\nivec4(59940,48,68,127),\nivec4(60000,48,63,127),\nivec4(60000,96,44,127),\nivec4(60000,96,66,127),\nivec4(60060,48,68,127),\nivec4(60120,48,66,127),\nivec4(60120,96,60,127),\nivec4(60180,48,68,127),\nivec4(60240,48,72,127),\nivec4(60240,96,44,127),\nivec4(60240,96,66,127),\nivec4(60300,48,68,127),\nivec4(60360,48,66,127),\nivec4(60360,96,60,127),\nivec4(60420,48,68,127),\nivec4(60480,48,65,127),\nivec4(60480,96,49,127),\nivec4(60540,48,61,127),\nivec4(60540,48,70,127),\nivec4(60600,48,60,127),\nivec4(60600,48,69,127),\nivec4(60600,96,53,127),\nivec4(60660,48,61,127),\nivec4(60660,48,70,127),\nivec4(60720,48,58,127),\nivec4(60720,48,65,127),\nivec4(60720,96,49,127),\nivec4(60780,48,61,127),\nivec4(60780,48,70,127),\nivec4(60840,48,60,127),\nivec4(60840,48,69,127),\nivec4(60840,96,53,127),\nivec4(60900,48,61,127),\nivec4(60900,48,70,127),\nivec4(60960,48,65,127),\nivec4(60960,48,73,127),\nivec4(60960,96,49,127),\nivec4(61020,48,61,127),\nivec4(61020,48,70,127),\nivec4(61080,48,60,127),\nivec4(61080,48,68,127),\nivec4(61080,96,53,127),\nivec4(61140,48,61,127),\nivec4(61140,48,70,127),\nivec4(61200,48,58,127),\nivec4(61200,96,49,127),\nivec4(61200,96,67,127),\nivec4(61260,48,63,127),\nivec4(61320,48,61,127),\nivec4(61320,96,55,127),\nivec4(61320,96,70,127),\nivec4(61380,48,63,127),\nivec4(61440,48,67,127),\nivec4(61440,96,49,127),\nivec4(61440,528,75,127),\nivec4(61500,48,63,127),\nivec4(61560,48,61,127),\nivec4(61560,96,55,127),\nivec4(61620,48,63,127),\nivec4(61680,48,70,127),\nivec4(61680,96,49,127),\nivec4(61740,48,67,127),\nivec4(61800,48,65,127),\nivec4(61800,96,55,127),\nivec4(61860,48,67,127),\nivec4(61920,96,48,127),\nivec4(61920,96,75,127),\nivec4(61980,48,63,127),\nivec4(62040,48,61,127),\nivec4(62040,96,56,127),\nivec4(62040,96,72,127),\nivec4(62100,48,63,127),\nivec4(62160,48,68,127),\nivec4(62160,96,48,127),\nivec4(62160,528,68,127),\nivec4(62220,48,63,127),\nivec4(62280,48,61,127),\nivec4(62280,96,56,127),\nivec4(62340,48,63,127),\nivec4(62400,48,72,127),\nivec4(62400,96,48,127),\nivec4(62460,48,68,127),\nivec4(62520,48,67,127),\nivec4(62520,96,56,127),\nivec4(62580,48,68,127),\nivec4(62640,48,74,127),\nivec4(62640,192,46,127),\nivec4(62700,48,67,127),\nivec4(62700,48,75,127),\nivec4(62760,48,65,127),\nivec4(62760,48,74,127),\nivec4(62820,48,63,127),\nivec4(62820,48,72,127),\nivec4(62880,48,62,127),\nivec4(62880,48,70,127),\nivec4(62940,48,63,127),\nivec4(62940,48,79,127),\nivec4(63000,48,62,127),\nivec4(63000,48,77,127),\nivec4(63060,48,60,127),\nivec4(63060,48,75,127),\nivec4(63120,48,58,127),\nivec4(63120,48,74,127),\nivec4(63180,48,68,127),\nivec4(63180,48,72,127),\nivec4(63240,48,67,127),\nivec4(63240,48,70,127),\nivec4(63300,48,65,127),\nivec4(63300,48,68,127),\nivec4(63360,48,67,127),\nivec4(63360,96,39,127),\nivec4(63360,768,63,127),\nivec4(63420,48,65,127),\nivec4(63480,48,67,127),\nivec4(63480,96,51,127),\nivec4(63540,48,70,127),\nivec4(63600,48,68,127),\nivec4(63600,96,41,127),\nivec4(63660,48,67,127),\nivec4(63720,48,68,127),\nivec4(63720,96,51,127),\nivec4(63780,48,72,127),\nivec4(63840,48,70,127),\nivec4(63840,96,43,127),\nivec4(63900,48,68,127),\nivec4(63960,48,70,127),\nivec4(63960,96,51,127),\nivec4(64020,48,73,127),\nivec4(64080,48,72,127),\nivec4(64080,96,44,127),\nivec4(64140,48,62,127),\nivec4(64140,48,70,127),\nivec4(64200,48,63,127),\nivec4(64200,48,72,127),\nivec4(64200,96,51,127),\nivec4(64260,48,68,127),\nivec4(64260,48,75,127),\nivec4(64320,48,63,127),\nivec4(64320,48,67,127),\nivec4(64320,96,46,127),\nivec4(64380,48,62,127),\nivec4(64380,48,65,127),\nivec4(64440,48,63,127),\nivec4(64440,48,67,127),\nivec4(64440,96,51,127),\nivec4(64500,48,67,127),\nivec4(64500,48,75,127),\nivec4(64560,48,68,127),\nivec4(64560,96,48,127),\nivec4(64560,288,65,127),\nivec4(64620,48,67,127),\nivec4(64680,48,68,127),\nivec4(64680,96,51,127),\nivec4(64740,48,75,127),\nivec4(64800,96,46,127),\nivec4(64800,192,67,127),\nivec4(64860,48,72,127),\nivec4(64920,48,70,127),\nivec4(64920,96,51,127),\nivec4(64980,48,68,127),\nivec4(65040,48,67,127),\nivec4(65040,96,44,127),\nivec4(65100,48,75,127),\nivec4(65100,48,79,127),\nivec4(65160,48,74,127),\nivec4(65160,48,77,127),\nivec4(65160,96,51,127),\nivec4(65220,48,72,127),\nivec4(65220,48,75,127),\nivec4(65280,48,70,127),\nivec4(65280,48,74,127),\nivec4(65280,96,46,127),\nivec4(65340,48,68,127),\nivec4(65340,48,72,127),\nivec4(65400,48,67,127),\nivec4(65400,48,70,127),\nivec4(65400,96,50,127),\nivec4(65460,48,65,127),\nivec4(65460,48,68,127),\nivec4(65520,48,67,127),\nivec4(65520,96,63,127),\nivec4(65520,192,39,127),\nivec4(65580,48,75,127),\nivec4(65640,48,74,127),\nivec4(65640,96,70,127),\nivec4(65700,48,75,127),\nivec4(65760,48,68,127),\nivec4(65760,96,72,127),\nivec4(65820,48,75,127),\nivec4(65880,48,67,127),\nivec4(65880,96,70,127),\nivec4(65940,48,75,127),\nivec4(66000,48,68,127),\nivec4(66000,96,72,127),\nivec4(66060,48,75,127),\nivec4(66120,48,65,127),\nivec4(66120,96,68,127),\nivec4(66180,48,75,127),\nivec4(66240,48,70,127),\nivec4(66240,96,67,127),\nivec4(66240,192,39,127),\nivec4(66300,48,75,127),\nivec4(66360,48,74,127),\nivec4(66360,96,82,127),\nivec4(66420,48,75,127),\nivec4(66480,48,68,127),\nivec4(66480,96,84,127),\nivec4(66540,48,75,127),\nivec4(66600,48,67,80),\nivec4(66600,96,82,127),\nivec4(66660,48,75,127),\nivec4(66720,48,68,127),\nivec4(66720,96,84,127),\nivec4(66780,48,75,127),\nivec4(66840,48,65,127),\nivec4(66840,96,80,127),\nivec4(66900,48,75,127),\nivec4(66960,48,82,127),\nivec4(66960,288,67,80),\nivec4(67020,48,75,127),\nivec4(67080,48,77,127),\nivec4(67080,96,58,127),\nivec4(67140,48,79,127),\nivec4(67200,96,60,127),\nivec4(67200,288,80,127),\nivec4(67260,48,63,127),\nivec4(67320,48,65,127),\nivec4(67320,96,58,127),\nivec4(67380,48,67,127),\nivec4(67440,48,68,127),\nivec4(67440,96,60,127),\nivec4(67500,48,70,127),\nivec4(67500,48,79,127),\nivec4(67560,48,72,127),\nivec4(67560,48,80,127),\nivec4(67560,96,56,127),\nivec4(67620,48,74,127),\nivec4(67620,48,77,127),\nivec4(67680,96,55,127),\nivec4(67680,96,75,127),\nivec4(67680,96,82,127),\nivec4(67800,96,60,127),\nivec4(67800,96,67,127),\nivec4(67800,96,75,127),\nivec4(67920,90,56,127),\nivec4(67920,90,68,127),\nivec4(67920,90,77,127),\nivec4(68160,24,67,80),\nivec4(68160,24,75,80),\nivec4(68160,192,58,127),\nivec4(68190,24,65,80),\nivec4(68190,24,74,80),\nivec4(68220,24,67,80),\nivec4(68220,24,75,80),\nivec4(68250,24,65,80),\nivec4(68250,24,74,80),\nivec4(68280,24,67,80),\nivec4(68280,24,75,80),\nivec4(68310,24,65,80),\nivec4(68310,24,74,80),\nivec4(68340,24,67,80),\nivec4(68340,24,75,80),\nivec4(68370,24,65,80),\nivec4(68370,24,74,80),\nivec4(68400,576,51,80),\nivec4(68400,576,67,127),\nivec4(68400,576,75,127),\nivec4(69120,96,77,127),\nivec4(69120,384,46,127),\nivec4(69240,96,65,127),\nivec4(69360,96,75,127),\nivec4(69480,96,65,127),\nivec4(69600,96,74,127),\nivec4(69720,96,65,127),\nivec4(69840,96,72,127),\nivec4(69840,384,51,127),\nivec4(69960,96,65,127),\nivec4(70080,96,70,127),\nivec4(70200,96,65,127),\nivec4(70320,96,69,127),\nivec4(70440,96,65,127),\nivec4(70560,48,70,127),\nivec4(70560,192,50,127),\nivec4(70620,48,65,127),\nivec4(70680,48,67,127),\nivec4(70740,48,69,127),\nivec4(70800,48,70,127),\nivec4(70800,192,55,127),\nivec4(70860,48,62,127),\nivec4(70920,48,63,127),\nivec4(70980,48,65,127),\nivec4(71040,48,67,127),\nivec4(71040,192,53,127),\nivec4(71100,48,69,127),\nivec4(71160,48,70,127),\nivec4(71220,48,72,127),\nivec4(71280,48,74,127),\nivec4(71280,192,58,127),\nivec4(71340,48,72,127),\nivec4(71400,48,70,127),\nivec4(71460,48,74,127),\nivec4(71520,48,77,127),\nivec4(71520,192,50,127),\nivec4(71580,48,74,127),\nivec4(71640,48,70,127),\nivec4(71700,48,65,127),\nivec4(71760,48,74,127),\nivec4(71760,192,46,127),\nivec4(71820,48,70,127),\nivec4(71880,48,68,127),\nivec4(71940,48,65,127),\nivec4(72000,48,67,127),\nivec4(72000,96,82,127),\nivec4(72000,384,51,127),\nivec4(72060,48,68,127),\nivec4(72120,48,67,127),\nivec4(72120,96,70,127),\nivec4(72180,48,63,127),\nivec4(72240,48,65,127),\nivec4(72240,96,80,127),\nivec4(72300,48,67,127),\nivec4(72360,48,65,127),\nivec4(72360,96,70,127),\nivec4(72420,48,62,127),\nivec4(72480,48,63,127),\nivec4(72480,96,79,127),\nivec4(72540,48,65,127),\nivec4(72600,48,63,127),\nivec4(72600,96,70,127),\nivec4(72660,48,60,127),\nivec4(72720,48,62,127),\nivec4(72720,96,77,127),\nivec4(72720,384,58,127),\nivec4(72780,48,63,127),\nivec4(72840,48,62,127),\nivec4(72840,96,70,127),\nivec4(72900,48,58,127),\nivec4(72960,48,67,127),\nivec4(72960,96,75,127),\nivec4(73020,48,68,127),\nivec4(73080,48,67,127),\nivec4(73080,96,70,127),\nivec4(73140,48,58,127),\nivec4(73200,48,65,127),\nivec4(73200,96,74,127),\nivec4(73200,192,56,127),\nivec4(73260,48,67,127),\nivec4(73320,48,65,127),\nivec4(73320,96,70,127),\nivec4(73380,48,58,127),\nivec4(73440,48,75,127),\nivec4(73440,96,67,127),\nivec4(73440,192,55,127),\nivec4(73500,48,70,127),\nivec4(73560,48,72,127),\nivec4(73560,96,63,127),\nivec4(73620,48,74,127),\nivec4(73680,48,75,127),\nivec4(73680,96,58,127),\nivec4(73680,192,43,127),\nivec4(73740,48,67,127),\nivec4(73800,48,68,127),\nivec4(73800,96,67,127),\nivec4(73860,48,70,127),\nivec4(73920,48,72,127),\nivec4(73920,96,65,127),\nivec4(73920,192,46,127),\nivec4(73980,48,74,127),\nivec4(74040,48,75,127),\nivec4(74040,96,62,127),\nivec4(74100,48,77,127),\nivec4(74160,48,79,127),\nivec4(74160,96,63,127),\nivec4(74160,384,39,127),\nivec4(74220,48,77,127),\nivec4(74280,48,75,127),\nivec4(74280,96,70,127),\nivec4(74340,48,79,127),\nivec4(74400,48,82,127),\nivec4(74400,96,67,127),\nivec4(74460,48,79,127),\nivec4(74520,48,75,127),\nivec4(74520,96,70,127),\nivec4(74580,48,70,127),\nivec4(74640,48,79,127),\nivec4(74640,96,73,127),\nivec4(74700,48,75,127),\nivec4(74760,48,73,127),\nivec4(74760,96,67,127),\nivec4(74820,48,70,127),\nivec4(74880,48,72,127),\nivec4(74880,96,68,127),\nivec4(74940,48,73,127),\nivec4(75000,48,72,127),\nivec4(75000,96,51,127),\nivec4(75060,48,68,127),\nivec4(75120,48,70,127),\nivec4(75120,96,61,127),\nivec4(75120,96,67,127),\nivec4(75180,48,72,127),\nivec4(75240,48,70,127),\nivec4(75240,96,51,127),\nivec4(75300,48,67,127),\nivec4(75360,48,68,127),\nivec4(75360,96,60,127),\nivec4(75360,96,63,127),\nivec4(75420,48,70,127),\nivec4(75480,48,68,127),\nivec4(75480,96,51,127),\nivec4(75540,48,65,127),\nivec4(75600,48,67,127),\nivec4(75600,96,58,127),\nivec4(75600,96,63,127),\nivec4(75660,48,68,127),\nivec4(75720,48,67,127),\nivec4(75720,96,51,127),\nivec4(75780,48,63,127),\nivec4(75840,48,72,127),\nivec4(75840,96,56,127),\nivec4(75840,96,63,127),\nivec4(75900,48,73,127),\nivec4(75960,48,72,127),\nivec4(75960,96,51,127),\nivec4(76020,48,63,127),\nivec4(76080,48,70,127),\nivec4(76080,96,55,127),\nivec4(76080,96,63,127),\nivec4(76140,48,72,127),\nivec4(76200,48,70,127),\nivec4(76200,96,51,127),\nivec4(76260,48,63,127),\nivec4(76320,96,56,127),\nivec4(76320,96,72,127),\nivec4(76380,48,63,127),\nivec4(76440,48,65,127),\nivec4(76440,96,68,127),\nivec4(76500,48,67,127),\nivec4(76560,48,68,127),\nivec4(76560,96,55,127),\nivec4(76560,96,72,127),\nivec4(76620,48,70,127),\nivec4(76680,48,72,127),\nivec4(76680,96,63,127),\nivec4(76740,48,70,127),\nivec4(76800,48,68,127),\nivec4(76800,96,53,127),\nivec4(76800,96,65,127),\nivec4(76860,48,67,127),\nivec4(76920,48,65,127),\nivec4(76920,96,74,127),\nivec4(76980,48,68,127),\nivec4(77040,96,67,127),\nivec4(77040,384,51,127),\nivec4(77100,48,75,127),\nivec4(77160,48,77,127),\nivec4(77160,96,70,127),\nivec4(77220,48,79,127),\nivec4(77280,48,80,127),\nivec4(77280,96,72,127),\nivec4(77340,48,82,127),\nivec4(77400,48,84,127),\nivec4(77400,96,68,127),\nivec4(77460,48,82,127),\nivec4(77520,48,80,127),\nivec4(77520,192,50,127),\nivec4(77520,288,65,127),\nivec4(77580,48,79,127),\nivec4(77640,48,77,127),\nivec4(77700,48,80,127),\nivec4(77760,96,79,127),\nivec4(77760,192,51,127),\nivec4(77820,48,63,127),\nivec4(77880,48,65,127),\nivec4(77880,96,72,127),\nivec4(77940,48,67,127),\nivec4(78000,48,69,127),\nivec4(78000,96,77,127),\nivec4(78000,192,50,127),\nivec4(78060,48,71,127),\nivec4(78120,48,72,127),\nivec4(78120,192,68,127),\nivec4(78180,48,74,127),\nivec4(78240,48,75,127),\nivec4(78240,192,48,127),\nivec4(78300,48,77,127),\nivec4(78360,48,75,127),\nivec4(78360,96,77,127),\nivec4(78420,48,68,127),\nivec4(78480,48,67,127),\nivec4(78480,48,77,127),\nivec4(78480,96,47,127),\nivec4(78540,48,67,127),\nivec4(78540,48,71,127),\nivec4(78600,48,69,127),\nivec4(78600,48,72,127),\nivec4(78600,96,53,127),\nivec4(78660,48,71,127),\nivec4(78660,48,74,127),\nivec4(78720,48,72,127),\nivec4(78720,48,75,127),\nivec4(78720,96,51,127),\nivec4(78780,48,74,127),\nivec4(78780,48,77,127),\nivec4(78840,48,75,127),\nivec4(78840,48,79,127),\nivec4(78840,96,50,127),\nivec4(78900,48,77,127),\nivec4(78900,48,80,127),\nivec4(78960,48,82,127),\nivec4(78960,96,48,127),\nivec4(78960,288,79,127),\nivec4(79020,48,84,127),\nivec4(79080,48,82,127),\nivec4(79080,96,52,127),\nivec4(79140,48,72,127),\nivec4(79200,48,80,127),\nivec4(79200,192,41,127),\nivec4(79260,48,70,127),\nivec4(79260,48,79,127),\nivec4(79320,48,68,127),\nivec4(79320,48,77,127),\nivec4(79380,48,67,127),\nivec4(79380,48,76,127),\nivec4(79440,48,77,127),\nivec4(79440,288,68,127),\nivec4(79440,384,49,127),\nivec4(79500,48,75,127),\nivec4(79560,48,73,127),\nivec4(79620,48,72,127),\nivec4(79680,288,70,127),\nivec4(79740,48,68,127),\nivec4(79800,48,67,127),\nivec4(79860,48,65,127),\nivec4(79920,48,64,127),\nivec4(79920,192,48,127),\nivec4(79980,48,65,127),\nivec4(79980,48,68,127),\nivec4(80040,48,64,127),\nivec4(80040,48,67,127),\nivec4(80100,48,62,127),\nivec4(80100,48,65,127),\nivec4(80160,96,60,127),\nivec4(80160,96,64,127),\nivec4(80220,48,60,127),\nivec4(80280,48,58,127),\nivec4(80280,96,64,127),\nivec4(80280,96,72,127),\nivec4(80340,48,60,127),\nivec4(80400,48,56,127),\nivec4(80400,96,65,127),\nivec4(80400,96,74,127),\nivec4(80460,48,58,127),\nivec4(80520,48,55,127),\nivec4(80520,96,67,127),\nivec4(80520,96,76,127),\nivec4(80580,48,56,127),\nivec4(80640,48,68,127),\nivec4(80640,96,53,127),\nivec4(80640,96,77,127),\nivec4(80700,48,65,127),\nivec4(80760,48,64,127),\nivec4(80760,96,56,127),\nivec4(80820,48,65,127),\nivec4(80880,48,60,127),\nivec4(80880,96,53,127),\nivec4(80940,48,65,127),\nivec4(81000,48,64,127),\nivec4(81000,96,56,127),\nivec4(81060,48,65,127),\nivec4(81120,48,68,127),\nivec4(81120,96,53,127),\nivec4(81180,48,65,127),\nivec4(81240,48,63,127),\nivec4(81240,96,56,127),\nivec4(81300,48,65,127),\nivec4(81360,96,46,127),\nivec4(81360,96,61,127),\nivec4(81420,48,70,127),\nivec4(81480,48,68,127),\nivec4(81480,96,61,127),\nivec4(81540,48,70,127),\nivec4(81600,48,65,127),\nivec4(81600,96,46,127),\nivec4(81600,96,68,127),\nivec4(81660,48,70,127),\nivec4(81720,48,68,127),\nivec4(81720,96,61,127),\nivec4(81780,48,70,127),\nivec4(81840,48,73,127),\nivec4(81840,96,46,127),\nivec4(81840,96,68,127),\nivec4(81900,48,70,127),\nivec4(81960,48,68,127),\nivec4(81960,96,61,127),\nivec4(82020,48,70,127),\nivec4(82080,96,51,127),\nivec4(82080,96,67,127),\nivec4(82140,48,63,127),\nivec4(82200,48,61,127),\nivec4(82200,96,55,127),\nivec4(82260,48,63,127),\nivec4(82320,48,58,127),\nivec4(82320,96,51,127),\nivec4(82320,96,73,127),\nivec4(82380,48,63,127),\nivec4(82440,48,61,127),\nivec4(82440,96,55,127),\nivec4(82500,48,63,127),\nivec4(82560,48,67,127),\nivec4(82560,96,51,127),\nivec4(82560,96,73,127),\nivec4(82620,48,63,127),\nivec4(82680,48,61,127),\nivec4(82680,96,55,127),\nivec4(82740,48,63,127),\nivec4(82800,96,44,127),\nivec4(82800,96,60,127),\nivec4(82860,48,68,127),\nivec4(82920,48,66,127),\nivec4(82920,96,60,127),\nivec4(82980,48,68,127),\nivec4(83040,48,63,127),\nivec4(83040,96,44,127),\nivec4(83040,96,66,127),\nivec4(83100,48,68,127),\nivec4(83160,48,66,127),\nivec4(83160,96,60,127),\nivec4(83220,48,68,127),\nivec4(83280,48,72,127),\nivec4(83280,96,44,127),\nivec4(83280,96,66,127),\nivec4(83340,48,68,127),\nivec4(83400,48,66,127),\nivec4(83400,96,60,127),\nivec4(83460,48,68,127),\nivec4(83520,48,65,127),\nivec4(83520,96,49,127),\nivec4(83580,48,61,127),\nivec4(83580,48,70,127),\nivec4(83640,48,60,127),\nivec4(83640,48,69,127),\nivec4(83640,96,53,127),\nivec4(83700,48,61,127),\nivec4(83700,48,70,127),\nivec4(83760,48,58,127),\nivec4(83760,48,65,127),\nivec4(83760,96,49,127),\nivec4(83820,48,61,127),\nivec4(83820,48,70,127),\nivec4(83880,48,60,127),\nivec4(83880,48,69,127),\nivec4(83880,96,53,127),\nivec4(83940,48,61,127),\nivec4(83940,48,70,127),\nivec4(84000,48,65,127),\nivec4(84000,48,73,127),\nivec4(84000,96,49,127),\nivec4(84060,48,61,127),\nivec4(84060,48,70,127),\nivec4(84120,48,60,127),\nivec4(84120,48,68,127),\nivec4(84120,96,53,127),\nivec4(84180,48,61,127),\nivec4(84180,48,70,127),\nivec4(84240,48,58,127),\nivec4(84240,96,49,127),\nivec4(84240,96,67,127),\nivec4(84300,48,63,127),\nivec4(84360,48,61,127),\nivec4(84360,96,55,127),\nivec4(84360,96,70,127),\nivec4(84420,48,63,127),\nivec4(84480,48,67,127),\nivec4(84480,96,49,127),\nivec4(84480,528,75,127),\nivec4(84540,48,63,127),\nivec4(84600,48,61,127),\nivec4(84600,96,55,127),\nivec4(84660,48,63,127),\nivec4(84720,48,70,127),\nivec4(84720,96,49,127),\nivec4(84780,48,67,127),\nivec4(84840,48,65,127),\nivec4(84840,96,55,127),\nivec4(84900,48,67,127),\nivec4(84960,96,48,127),\nivec4(84960,96,75,127),\nivec4(85020,48,63,127),\nivec4(85080,48,61,127),\nivec4(85080,96,56,127),\nivec4(85080,96,72,127),\nivec4(85140,48,63,127),\nivec4(85200,48,68,127),\nivec4(85200,96,48,127),\nivec4(85200,528,68,127),\nivec4(85260,48,63,127),\nivec4(85320,48,61,127),\nivec4(85320,96,56,127),\nivec4(85380,48,63,127),\nivec4(85440,48,72,127),\nivec4(85440,96,48,127),\nivec4(85500,48,68,127),\nivec4(85560,48,67,127),\nivec4(85560,96,56,127),\nivec4(85620,48,68,127),\nivec4(85680,48,74,127),\nivec4(85680,192,46,127),\nivec4(85740,48,67,127),\nivec4(85740,48,75,127),\nivec4(85800,48,65,127),\nivec4(85800,48,74,127),\nivec4(85860,48,63,127),\nivec4(85860,48,72,127),\nivec4(85920,48,62,127),\nivec4(85920,48,70,127),\nivec4(85980,48,63,127),\nivec4(85980,48,79,127),\nivec4(86040,48,62,127),\nivec4(86040,48,77,127),\nivec4(86100,48,60,127),\nivec4(86100,48,75,127),\nivec4(86160,48,58,127),\nivec4(86160,48,74,127),\nivec4(86220,48,68,127),\nivec4(86220,48,72,127),\nivec4(86280,48,67,127),\nivec4(86280,48,70,127),\nivec4(86340,48,65,127),\nivec4(86340,48,68,127),\nivec4(86400,48,67,127),\nivec4(86400,96,39,127),\nivec4(86400,768,63,127),\nivec4(86460,48,65,127),\nivec4(86520,48,67,127),\nivec4(86520,96,51,127),\nivec4(86580,48,70,127),\nivec4(86640,48,68,127),\nivec4(86640,96,41,127),\nivec4(86700,48,67,127),\nivec4(86760,48,68,127),\nivec4(86760,96,51,127),\nivec4(86820,48,72,127),\nivec4(86880,48,70,127),\nivec4(86880,96,43,127),\nivec4(86940,48,68,127),\nivec4(87000,48,70,127),\nivec4(87000,96,51,127),\nivec4(87060,48,73,127),\nivec4(87120,48,72,127),\nivec4(87120,96,44,127),\nivec4(87180,48,62,127),\nivec4(87180,48,70,127),\nivec4(87240,48,63,127),\nivec4(87240,48,72,127),\nivec4(87240,96,51,127),\nivec4(87300,48,68,127),\nivec4(87300,48,75,127),\nivec4(87360,48,63,127),\nivec4(87360,48,67,127),\nivec4(87360,96,46,127),\nivec4(87420,48,62,127),\nivec4(87420,48,65,127),\nivec4(87480,48,63,127),\nivec4(87480,48,67,127),\nivec4(87480,96,51,127),\nivec4(87540,48,67,127),\nivec4(87540,48,75,127),\nivec4(87600,48,68,127),\nivec4(87600,96,48,127),\nivec4(87600,288,65,127),\nivec4(87660,48,67,127),\nivec4(87720,48,68,127),\nivec4(87720,96,51,127),\nivec4(87780,48,75,127),\nivec4(87840,96,46,127),\nivec4(87840,192,67,127),\nivec4(87900,48,72,127),\nivec4(87960,48,70,127),\nivec4(87960,96,51,127),\nivec4(88020,48,68,127),\nivec4(88080,48,67,127),\nivec4(88080,96,44,127),\nivec4(88140,48,75,127),\nivec4(88140,48,79,127),\nivec4(88200,48,74,127),\nivec4(88200,48,77,127),\nivec4(88200,96,51,127),\nivec4(88260,48,72,127),\nivec4(88260,48,75,127),\nivec4(88320,48,70,127),\nivec4(88320,48,74,127),\nivec4(88320,96,46,127),\nivec4(88380,48,68,127),\nivec4(88380,48,72,127),\nivec4(88440,48,67,127),\nivec4(88440,48,70,127),\nivec4(88440,96,50,127),\nivec4(88500,48,65,127),\nivec4(88500,48,68,127),\nivec4(88560,48,67,127),\nivec4(88560,96,63,127),\nivec4(88560,192,39,127),\nivec4(88620,48,75,127),\nivec4(88680,48,74,127),\nivec4(88680,96,70,127),\nivec4(88740,48,75,127),\nivec4(88800,48,68,127),\nivec4(88800,96,72,127),\nivec4(88860,48,75,127),\nivec4(88920,48,67,127),\nivec4(88920,96,70,127),\nivec4(88980,48,75,127),\nivec4(89040,48,68,127),\nivec4(89040,96,72,127),\nivec4(89100,48,75,127),\nivec4(89160,48,65,127),\nivec4(89160,96,68,127),\nivec4(89220,48,75,127),\nivec4(89280,48,70,127),\nivec4(89280,96,67,127),\nivec4(89280,192,39,127),\nivec4(89340,48,75,127),\nivec4(89400,48,74,127),\nivec4(89400,96,82,127),\nivec4(89460,48,75,127),\nivec4(89520,48,68,127),\nivec4(89520,96,84,127),\nivec4(89580,48,75,127),\nivec4(89640,48,67,80),\nivec4(89640,96,82,127),\nivec4(89700,48,75,127),\nivec4(89760,48,68,127),\nivec4(89760,96,84,127),\nivec4(89820,48,75,127),\nivec4(89880,48,65,127),\nivec4(89880,96,80,127),\nivec4(89940,48,75,127),\nivec4(90000,48,82,127),\nivec4(90000,288,67,80),\nivec4(90060,48,75,127),\nivec4(90120,48,77,127),\nivec4(90120,96,58,127),\nivec4(90180,48,79,127),\nivec4(90240,96,60,127),\nivec4(90240,288,80,127),\nivec4(90300,48,63,127),\nivec4(90360,48,65,127),\nivec4(90360,96,58,127),\nivec4(90420,48,67,127),\nivec4(90480,48,68,127),\nivec4(90480,96,60,127),\nivec4(90540,48,70,127),\nivec4(90540,48,79,127),\nivec4(90600,48,72,127),\nivec4(90600,48,80,127),\nivec4(90600,96,56,127),\nivec4(90660,48,74,127),\nivec4(90660,48,77,127),\nivec4(90720,96,55,127),\nivec4(90720,96,75,127),\nivec4(90720,96,82,127),\nivec4(90840,96,60,127),\nivec4(90840,96,67,127),\nivec4(90840,96,75,127),\nivec4(90960,90,56,127),\nivec4(90960,90,68,127),\nivec4(90960,90,77,127),\nivec4(91200,24,67,80),\nivec4(91200,24,75,80),\nivec4(91200,192,58,127),\nivec4(91230,24,65,80),\nivec4(91230,24,74,80),\nivec4(91260,24,67,80),\nivec4(91260,24,75,80),\nivec4(91290,24,65,80),\nivec4(91290,24,74,80),\nivec4(91320,24,67,80),\nivec4(91320,24,75,80),\nivec4(91350,24,65,80),\nivec4(91350,24,74,80),\nivec4(91380,24,67,80),\nivec4(91380,24,75,80),\nivec4(91410,24,65,80),\nivec4(91410,24,74,80),\nivec4(91440,576,51,80),\nivec4(91440,576,67,127),\nivec4(91440,576,75,127)\n);\n#endif\n#elif TUNE == 6\nfloat speed = 0.4;\nconst ivec4 data[] = ivec4[] (\nivec4(0,61,72,64),\nivec4(0,61,84,64),\nivec4(64,61,69,64),\nivec4(64,61,81,64),\nivec4(128,61,67,64),\nivec4(128,61,79,64),\nivec4(192,125,65,64),\nivec4(192,125,77,64),\nivec4(320,61,69,64),\nivec4(320,61,81,64),\nivec4(384,61,67,64),\nivec4(384,61,79,64),\nivec4(448,61,65,64),\nivec4(448,61,77,64),\nivec4(512,61,67,64),\nivec4(512,61,79,64),\nivec4(576,61,65,64),\nivec4(576,61,77,64),\nivec4(640,61,62,64),\nivec4(640,61,74,64),\nivec4(704,125,60,64),\nivec4(704,125,72,64),\nivec4(832,61,53,64),\nivec4(832,61,65,64),\nivec4(896,61,55,64),\nivec4(896,61,67,64),\nivec4(960,61,57,64),\nivec4(960,61,69,64),\nivec4(1024,61,48,64),\nivec4(1024,61,60,64),\nivec4(1088,120,55,64),\nivec4(1088,120,67,64),\nivec4(1216,61,53,64),\nivec4(1216,61,65,64),\nivec4(1280,120,52,64),\nivec4(1280,120,64,64),\nivec4(1408,120,55,64),\nivec4(1408,120,67,64),\nivec4(1536,120,60,64),\nivec4(1536,128,64,64),\nivec4(1536,128,67,64),\nivec4(1536,128,72,64),\nivec4(1664,120,36,64),\nivec4(1664,120,48,64),\nivec4(1728,61,60,64),\nivec4(1792,120,38,64),\nivec4(1792,120,50,64),\nivec4(1856,61,62,64),\nivec4(1920,120,40,64),\nivec4(1920,120,52,64),\nivec4(1984,61,64,64),\nivec4(2048,355,41,64),\nivec4(2048,355,53,64),\nivec4(2112,61,65,64),\nivec4(2176,61,74,64),\nivec4(2240,125,65,64),\nivec4(2240,125,69,64),\nivec4(2240,125,72,64),\nivec4(2368,61,74,64),\nivec4(2432,120,42,64),\nivec4(2432,120,54,64),\nivec4(2432,120,63,64),\nivec4(2432,120,69,64),\nivec4(2432,120,72,64),\nivec4(2560,355,43,64),\nivec4(2560,355,55,64),\nivec4(2624,61,64,64),\nivec4(2688,61,74,64),\nivec4(2752,125,64,64),\nivec4(2752,125,70,64),\nivec4(2752,125,72,64),\nivec4(2880,61,74,64),\nivec4(2944,120,44,64),\nivec4(2944,120,56,64),\nivec4(2944,120,64,64),\nivec4(2944,120,70,64),\nivec4(2944,120,72,64),\nivec4(3072,120,45,64),\nivec4(3072,120,57,64),\nivec4(3136,61,65,64),\nivec4(3136,61,69,64),\nivec4(3136,61,72,64),\nivec4(3200,120,51,64),\nivec4(3200,120,63,64),\nivec4(3264,61,69,64),\nivec4(3264,61,72,64),\nivec4(3328,120,50,64),\nivec4(3328,120,62,64),\nivec4(3392,61,68,64),\nivec4(3392,61,71,64),\nivec4(3456,120,49,64),\nivec4(3456,120,61,64),\nivec4(3520,61,67,64),\nivec4(3520,61,70,64),\nivec4(3584,61,69,64),\nivec4(3584,120,48,64),\nivec4(3584,120,60,64),\nivec4(3584,120,65,64),\nivec4(3648,61,72,64),\nivec4(3712,61,74,64),\nivec4(3712,120,47,64),\nivec4(3712,120,59,64),\nivec4(3712,120,68,64),\nivec4(3776,61,77,64),\nivec4(3840,120,46,64),\nivec4(3840,120,58,64),\nivec4(3840,120,67,64),\nivec4(3840,120,72,64),\nivec4(3840,120,76,64),\nivec4(3968,120,36,64),\nivec4(3968,120,48,64),\nivec4(3968,120,70,64),\nivec4(3968,120,76,64),\nivec4(3968,120,79,64),\nivec4(4096,61,69,64),\nivec4(4096,61,77,64),\nivec4(4096,61,81,64),\nivec4(4096,120,41,64),\nivec4(4160,61,80,64),\nivec4(4224,61,81,64),\nivec4(4224,120,57,64),\nivec4(4224,120,60,64),\nivec4(4224,120,65,64),\nivec4(4288,125,84,64),\nivec4(4352,120,45,64),\nivec4(4416,61,81,64),\nivec4(4480,61,79,64),\nivec4(4480,120,57,64),\nivec4(4480,120,60,64),\nivec4(4480,120,65,64),\nivec4(4544,61,77,64),\nivec4(4608,61,79,64),\nivec4(4608,120,46,64),\nivec4(4672,61,77,64),\nivec4(4736,61,74,64),\nivec4(4736,120,58,64),\nivec4(4736,120,62,64),\nivec4(4736,120,65,64),\nivec4(4800,125,77,64),\nivec4(4864,120,45,64),\nivec4(4928,61,74,64),\nivec4(4992,61,72,64),\nivec4(4992,120,57,64),\nivec4(4992,120,60,64),\nivec4(4992,120,65,64),\nivec4(5056,61,69,64),\nivec4(5120,61,67,64),\nivec4(5120,120,47,64),\nivec4(5184,61,79,64),\nivec4(5248,61,77,64),\nivec4(5248,120,55,64),\nivec4(5248,120,59,64),\nivec4(5248,120,65,64),\nivec4(5312,61,76,64),\nivec4(5376,61,74,64),\nivec4(5376,120,43,64),\nivec4(5440,120,69,64),\nivec4(5504,120,55,64),\nivec4(5504,120,59,64),\nivec4(5504,120,65,64),\nivec4(5568,61,71,64),\nivec4(5632,120,60,64),\nivec4(5632,120,64,64),\nivec4(5632,120,72,64),\nivec4(5888,120,48,64),\nivec4(5888,120,60,64),\nivec4(5888,120,72,64),\nivec4(5888,120,76,64),\nivec4(5888,120,84,64),\nivec4(6016,120,36,64),\nivec4(6016,120,48,64),\nivec4(6144,355,41,64),\nivec4(6144,355,53,64),\nivec4(6208,61,65,64),\nivec4(6272,61,74,64),\nivec4(6336,125,65,64),\nivec4(6336,125,69,64),\nivec4(6336,125,72,64),\nivec4(6464,61,74,64),\nivec4(6528,120,42,64),\nivec4(6528,120,54,64),\nivec4(6528,120,63,64),\nivec4(6528,120,69,64),\nivec4(6528,120,72,64),\nivec4(6656,355,43,64),\nivec4(6656,355,55,64),\nivec4(6720,61,64,64),\nivec4(6784,61,74,64),\nivec4(6848,125,64,64),\nivec4(6848,125,70,64),\nivec4(6848,125,72,64),\nivec4(6976,61,74,64),\nivec4(7040,120,44,64),\nivec4(7040,120,56,64),\nivec4(7040,120,64,64),\nivec4(7040,120,70,64),\nivec4(7040,120,72,64),\nivec4(7168,120,45,64),\nivec4(7168,120,57,64),\nivec4(7232,61,65,64),\nivec4(7232,61,69,64),\nivec4(7232,61,72,64),\nivec4(7296,120,51,64),\nivec4(7296,120,63,64),\nivec4(7360,61,69,64),\nivec4(7360,61,72,64),\nivec4(7424,120,50,64),\nivec4(7424,120,62,64),\nivec4(7488,61,68,64),\nivec4(7488,61,71,64),\nivec4(7552,120,49,64),\nivec4(7552,120,61,64),\nivec4(7616,61,67,64),\nivec4(7616,61,70,64),\nivec4(7680,61,69,64),\nivec4(7680,120,48,64),\nivec4(7680,120,60,64),\nivec4(7680,120,65,64),\nivec4(7744,61,72,64),\nivec4(7808,61,74,64),\nivec4(7808,120,47,64),\nivec4(7808,120,59,64),\nivec4(7808,120,68,64),\nivec4(7872,61,77,64),\nivec4(7936,120,46,64),\nivec4(7936,120,58,64),\nivec4(7936,120,67,64),\nivec4(7936,120,72,64),\nivec4(7936,120,76,64),\nivec4(8064,120,36,64),\nivec4(8064,120,48,64),\nivec4(8064,120,70,64),\nivec4(8064,120,76,64),\nivec4(8064,120,79,64),\nivec4(8192,61,69,64),\nivec4(8192,61,77,64),\nivec4(8192,61,81,64),\nivec4(8192,120,41,64),\nivec4(8256,61,80,64),\nivec4(8320,61,81,64),\nivec4(8320,120,57,64),\nivec4(8320,120,60,64),\nivec4(8320,120,65,64),\nivec4(8384,125,84,64),\nivec4(8448,120,45,64),\nivec4(8512,61,81,64),\nivec4(8576,61,79,64),\nivec4(8576,120,57,64),\nivec4(8576,120,60,64),\nivec4(8576,120,65,64),\nivec4(8640,61,77,64),\nivec4(8704,61,79,64),\nivec4(8704,120,46,64),\nivec4(8768,61,77,64),\nivec4(8832,61,74,64),\nivec4(8832,120,58,64),\nivec4(8832,120,62,64),\nivec4(8832,120,65,64),\nivec4(8896,125,72,64),\nivec4(8960,120,45,64),\nivec4(9024,61,74,64),\nivec4(9088,61,69,64),\nivec4(9088,120,57,64),\nivec4(9088,120,60,64),\nivec4(9088,120,65,64),\nivec4(9152,61,67,64),\nivec4(9216,61,59,64),\nivec4(9216,61,65,64),\nivec4(9216,120,38,64),\nivec4(9216,120,50,64),\nivec4(9280,61,67,64),\nivec4(9344,120,38,64),\nivec4(9344,120,50,64),\nivec4(9344,120,59,64),\nivec4(9344,120,65,64),\nivec4(9344,120,69,64),\nivec4(9472,61,58,64),\nivec4(9472,61,64,64),\nivec4(9472,61,67,64),\nivec4(9472,120,36,64),\nivec4(9472,120,48,64),\nivec4(9536,120,58,64),\nivec4(9536,120,64,64),\nivec4(9536,120,67,64),\nivec4(9600,120,40,64),\nivec4(9600,120,52,64),\nivec4(9664,61,58,64),\nivec4(9664,61,60,64),\nivec4(9728,120,41,64),\nivec4(9728,120,53,64),\nivec4(9728,128,57,64),\nivec4(9728,128,65,64),\nivec4(9856,120,36,64),\nivec4(9856,120,48,64),\nivec4(9920,61,60,64),\nivec4(9984,120,38,64),\nivec4(9984,120,50,64),\nivec4(10048,61,62,64),\nivec4(10112,120,40,64),\nivec4(10112,120,52,64),\nivec4(10176,61,64,64),\nivec4(10240,355,41,64),\nivec4(10240,355,53,64),\nivec4(10304,61,65,64),\nivec4(10368,61,74,64),\nivec4(10432,125,65,64),\nivec4(10432,125,69,64),\nivec4(10432,125,72,64),\nivec4(10560,61,74,64),\nivec4(10624,120,42,64),\nivec4(10624,120,54,64),\nivec4(10624,120,63,64),\nivec4(10624,120,69,64),\nivec4(10624,120,72,64),\nivec4(10752,355,43,64),\nivec4(10752,355,55,64),\nivec4(10816,61,64,64),\nivec4(10880,61,74,64),\nivec4(10944,125,64,64),\nivec4(10944,125,70,64),\nivec4(10944,125,72,64),\nivec4(11072,61,74,64),\nivec4(11136,120,44,64),\nivec4(11136,120,56,64),\nivec4(11136,120,64,64),\nivec4(11136,120,70,64),\nivec4(11136,120,72,64),\nivec4(11264,120,45,64),\nivec4(11264,120,57,64),\nivec4(11328,61,65,64),\nivec4(11328,61,69,64),\nivec4(11328,61,72,64),\nivec4(11392,120,51,64),\nivec4(11392,120,63,64),\nivec4(11456,61,69,64),\nivec4(11456,61,72,64),\nivec4(11520,120,50,64),\nivec4(11520,120,62,64),\nivec4(11584,61,68,64),\nivec4(11584,61,71,64),\nivec4(11648,120,49,64),\nivec4(11648,120,61,64),\nivec4(11712,61,67,64),\nivec4(11712,61,70,64),\nivec4(11776,61,69,64),\nivec4(11776,120,48,64),\nivec4(11776,120,60,64),\nivec4(11776,120,65,64),\nivec4(11840,61,72,64),\nivec4(11904,61,74,64),\nivec4(11904,120,47,64),\nivec4(11904,120,59,64),\nivec4(11904,120,68,64),\nivec4(11968,61,77,64),\nivec4(12032,120,46,64),\nivec4(12032,120,58,64),\nivec4(12032,120,67,64),\nivec4(12032,120,72,64),\nivec4(12032,120,76,64),\nivec4(12160,120,36,64),\nivec4(12160,120,48,64),\nivec4(12160,120,70,64),\nivec4(12160,120,76,64),\nivec4(12160,120,79,64),\nivec4(12288,61,69,64),\nivec4(12288,61,77,64),\nivec4(12288,61,81,64),\nivec4(12288,120,41,64),\nivec4(12352,61,80,64),\nivec4(12416,61,81,64),\nivec4(12416,120,57,64),\nivec4(12416,120,60,64),\nivec4(12416,120,65,64),\nivec4(12480,125,84,64),\nivec4(12544,120,45,64),\nivec4(12608,61,81,64),\nivec4(12672,61,79,64),\nivec4(12672,120,57,64),\nivec4(12672,120,60,64),\nivec4(12672,120,65,64),\nivec4(12736,61,77,64),\nivec4(12800,61,79,64),\nivec4(12800,120,46,64),\nivec4(12864,61,77,64),\nivec4(12928,61,74,64),\nivec4(12928,120,58,64),\nivec4(12928,120,62,64),\nivec4(12928,120,65,64),\nivec4(12992,125,77,64),\nivec4(13056,120,45,64),\nivec4(13120,61,74,64),\nivec4(13184,61,72,64),\nivec4(13184,120,57,64),\nivec4(13184,120,60,64),\nivec4(13184,120,65,64),\nivec4(13248,61,69,64),\nivec4(13312,61,67,64),\nivec4(13312,120,47,64),\nivec4(13376,61,79,64),\nivec4(13440,61,77,64),\nivec4(13440,120,55,64),\nivec4(13440,120,59,64),\nivec4(13440,120,65,64),\nivec4(13504,61,76,64),\nivec4(13568,61,74,64),\nivec4(13568,120,43,64),\nivec4(13632,120,69,64),\nivec4(13696,120,55,64),\nivec4(13696,120,59,64),\nivec4(13696,120,65,64),\nivec4(13760,61,71,64),\nivec4(13824,120,60,64),\nivec4(13824,120,64,64),\nivec4(13824,120,72,64),\nivec4(14080,120,48,64),\nivec4(14080,120,60,64),\nivec4(14080,120,72,64),\nivec4(14080,120,76,64),\nivec4(14080,120,84,64),\nivec4(14208,120,36,64),\nivec4(14208,120,48,64),\nivec4(14336,355,41,64),\nivec4(14336,355,53,64),\nivec4(14400,61,65,64),\nivec4(14464,61,74,64),\nivec4(14528,125,65,64),\nivec4(14528,125,69,64),\nivec4(14528,125,72,64),\nivec4(14656,61,74,64),\nivec4(14720,120,42,64),\nivec4(14720,120,54,64),\nivec4(14720,120,63,64),\nivec4(14720,120,69,64),\nivec4(14720,120,72,64),\nivec4(14848,355,43,64),\nivec4(14848,355,55,64),\nivec4(14912,61,64,64),\nivec4(14976,61,74,64),\nivec4(15040,125,64,64),\nivec4(15040,125,70,64),\nivec4(15040,125,72,64),\nivec4(15168,61,74,64),\nivec4(15232,120,44,64),\nivec4(15232,120,56,64),\nivec4(15232,120,64,64),\nivec4(15232,120,70,64),\nivec4(15232,120,72,64),\nivec4(15360,120,45,64),\nivec4(15360,120,57,64),\nivec4(15424,61,65,64),\nivec4(15424,61,69,64),\nivec4(15424,61,72,64),\nivec4(15488,120,51,64),\nivec4(15488,120,63,64),\nivec4(15552,61,69,64),\nivec4(15552,61,72,64),\nivec4(15616,120,50,64),\nivec4(15616,120,62,64),\nivec4(15680,61,68,64),\nivec4(15680,61,71,64),\nivec4(15744,120,49,64),\nivec4(15744,120,61,64),\nivec4(15808,61,67,64),\nivec4(15808,61,70,64),\nivec4(15872,61,69,64),\nivec4(15872,120,48,64),\nivec4(15872,120,60,64),\nivec4(15872,120,65,64),\nivec4(15936,61,72,64),\nivec4(16000,61,74,64),\nivec4(16000,120,47,64),\nivec4(16000,120,59,64),\nivec4(16000,120,68,64),\nivec4(16064,61,77,64),\nivec4(16128,120,46,64),\nivec4(16128,120,58,64),\nivec4(16128,120,67,64),\nivec4(16128,120,72,64),\nivec4(16128,120,76,64),\nivec4(16256,120,36,64),\nivec4(16256,120,48,64),\nivec4(16256,120,70,64),\nivec4(16256,120,76,64),\nivec4(16256,120,79,64),\nivec4(16384,61,69,64),\nivec4(16384,61,77,64),\nivec4(16384,61,81,64),\nivec4(16384,120,41,64),\nivec4(16448,61,80,64),\nivec4(16512,61,81,64),\nivec4(16512,120,57,64),\nivec4(16512,120,60,64),\nivec4(16512,120,65,64),\nivec4(16576,125,84,64),\nivec4(16640,120,45,64),\nivec4(16704,61,81,64),\nivec4(16768,61,79,64),\nivec4(16768,120,57,64),\nivec4(16768,120,60,64),\nivec4(16768,120,65,64),\nivec4(16832,61,77,64),\nivec4(16896,61,79,64),\nivec4(16896,120,46,64),\nivec4(16960,61,77,64),\nivec4(17024,61,74,64),\nivec4(17024,120,58,64),\nivec4(17024,120,62,64),\nivec4(17024,120,65,64),\nivec4(17088,125,72,64),\nivec4(17152,120,45,64),\nivec4(17216,61,74,64),\nivec4(17280,61,69,64),\nivec4(17280,120,57,64),\nivec4(17280,120,60,64),\nivec4(17280,120,65,64),\nivec4(17344,61,67,64),\nivec4(17408,61,59,64),\nivec4(17408,61,65,64),\nivec4(17408,120,38,64),\nivec4(17408,120,50,64),\nivec4(17472,61,67,64),\nivec4(17536,120,38,64),\nivec4(17536,120,50,64),\nivec4(17536,120,59,64),\nivec4(17536,120,65,64),\nivec4(17536,120,69,64),\nivec4(17664,61,58,64),\nivec4(17664,61,64,64),\nivec4(17664,61,67,64),\nivec4(17664,120,36,64),\nivec4(17664,120,48,64),\nivec4(17728,120,58,64),\nivec4(17728,120,64,64),\nivec4(17728,120,67,64),\nivec4(17792,120,40,64),\nivec4(17792,120,52,64),\nivec4(17856,61,58,64),\nivec4(17856,61,60,64),\nivec4(17920,120,41,64),\nivec4(17920,120,53,64),\nivec4(17920,120,57,64),\nivec4(17920,120,65,64),\nivec4(18048,61,72,64),\nivec4(18112,61,72,64),\nivec4(18176,120,72,64),\nivec4(18304,120,72,64),\nivec4(18432,61,76,54),\nivec4(18432,120,55,48),\nivec4(18496,61,74,54),\nivec4(18560,61,72,54),\nivec4(18560,120,58,48),\nivec4(18560,120,60,48),\nivec4(18560,120,64,48),\nivec4(18624,61,70,54),\nivec4(18688,61,69,54),\nivec4(18688,120,48,48),\nivec4(18752,120,70,54),\nivec4(18816,120,58,48),\nivec4(18816,120,60,48),\nivec4(18816,120,64,48),\nivec4(18880,61,67,54),\nivec4(18944,61,65,54),\nivec4(18944,120,53,48),\nivec4(19008,61,67,54),\nivec4(19072,61,69,54),\nivec4(19072,120,57,48),\nivec4(19136,56,60,54),\nivec4(19200,120,48,48),\nivec4(19264,61,69,54),\nivec4(19328,61,67,54),\nivec4(19328,120,57,48),\nivec4(19328,120,60,48),\nivec4(19392,61,65,54),\nivec4(19456,61,64,54),\nivec4(19456,120,55,48),\nivec4(19520,61,65,54),\nivec4(19584,61,67,54),\nivec4(19584,120,58,48),\nivec4(19648,56,60,54),\nivec4(19712,120,48,48),\nivec4(19776,61,70,54),\nivec4(19840,61,69,54),\nivec4(19840,120,58,48),\nivec4(19840,120,60,48),\nivec4(19904,61,67,54),\nivec4(19968,61,65,54),\nivec4(19968,120,53,48),\nivec4(20032,61,69,54),\nivec4(20096,61,74,54),\nivec4(20096,120,57,48),\nivec4(20096,120,60,48),\nivec4(20160,184,72,54),\nivec4(20224,120,57,48),\nivec4(20352,120,60,48),\nivec4(20352,120,65,48),\nivec4(20352,120,72,54),\nivec4(20480,61,76,54),\nivec4(20480,120,55,48),\nivec4(20544,61,74,54),\nivec4(20608,61,72,54),\nivec4(20608,120,58,48),\nivec4(20608,120,60,48),\nivec4(20608,120,64,48),\nivec4(20672,61,70,54),\nivec4(20736,61,69,54),\nivec4(20736,120,48,48),\nivec4(20800,120,70,54),\nivec4(20864,120,55,48),\nivec4(20864,120,58,48),\nivec4(20864,120,61,48),\nivec4(20928,61,64,54),\nivec4(20992,61,65,54),\nivec4(20992,120,50,48),\nivec4(21056,61,64,54),\nivec4(21120,61,65,54),\nivec4(21120,120,53,48),\nivec4(21120,120,57,48),\nivec4(21120,120,62,48),\nivec4(21184,125,69,54),\nivec4(21248,120,50,48),\nivec4(21312,61,69,54),\nivec4(21376,61,67,54),\nivec4(21376,120,53,48),\nivec4(21376,120,57,48),\nivec4(21376,120,62,48),\nivec4(21440,61,65,54),\nivec4(21504,61,64,54),\nivec4(21504,120,52,48),\nivec4(21568,61,72,54),\nivec4(21632,61,71,54),\nivec4(21632,120,57,48),\nivec4(21632,120,60,48),\nivec4(21696,61,69,54),\nivec4(21760,61,68,54),\nivec4(21760,120,52,48),\nivec4(21824,120,71,54),\nivec4(21888,120,56,48),\nivec4(21888,120,62,48),\nivec4(21952,61,64,54),\nivec4(22016,120,57,48),\nivec4(22016,120,60,48),\nivec4(22016,120,69,54),\nivec4(22272,237,48,48),\nivec4(22272,237,60,48),\nivec4(22272,237,64,54),\nivec4(22272,237,70,54),\nivec4(22272,237,72,54),\nivec4(22528,61,76,54),\nivec4(22528,120,55,48),\nivec4(22592,61,74,54),\nivec4(22656,61,72,54),\nivec4(22656,120,58,48),\nivec4(22656,120,60,48),\nivec4(22656,120,64,48),\nivec4(22720,61,70,54),\nivec4(22784,61,69,54),\nivec4(22784,120,48,48),\nivec4(22848,120,70,54),\nivec4(22912,120,58,48),\nivec4(22912,120,60,48),\nivec4(22912,120,64,48),\nivec4(22976,61,67,54),\nivec4(23040,61,65,54),\nivec4(23040,120,53,48),\nivec4(23104,61,67,54),\nivec4(23168,61,69,54),\nivec4(23168,120,57,48),\nivec4(23232,56,60,54),\nivec4(23296,120,48,48),\nivec4(23360,61,69,54),\nivec4(23424,61,67,54),\nivec4(23424,120,57,48),\nivec4(23424,120,60,48),\nivec4(23488,61,65,54),\nivec4(23552,61,64,54),\nivec4(23552,120,55,48),\nivec4(23616,61,65,54),\nivec4(23680,61,67,54),\nivec4(23680,120,58,48),\nivec4(23744,56,60,54),\nivec4(23808,120,48,48),\nivec4(23872,61,70,54),\nivec4(23936,61,69,54),\nivec4(23936,120,58,48),\nivec4(23936,120,60,48),\nivec4(24000,61,67,54),\nivec4(24064,61,65,54),\nivec4(24064,120,53,48),\nivec4(24128,61,69,54),\nivec4(24192,61,74,54),\nivec4(24192,120,57,48),\nivec4(24192,120,60,48),\nivec4(24256,184,72,54),\nivec4(24320,120,48,48),\nivec4(24448,120,57,48),\nivec4(24448,120,60,48),\nivec4(24448,120,72,54),\nivec4(24576,61,70,54),\nivec4(24576,61,74,54),\nivec4(24576,120,46,48),\nivec4(24640,120,79,54),\nivec4(24704,120,55,48),\nivec4(24704,120,58,48),\nivec4(24704,120,62,48),\nivec4(24768,125,70,54),\nivec4(24768,125,74,54),\nivec4(24832,120,46,48),\nivec4(24896,61,79,54),\nivec4(24960,120,55,48),\nivec4(24960,120,58,48),\nivec4(24960,120,62,48),\nivec4(24960,120,70,54),\nivec4(24960,120,74,54),\nivec4(25088,61,69,54),\nivec4(25088,61,72,54),\nivec4(25088,120,48,48),\nivec4(25152,120,77,54),\nivec4(25216,120,57,48),\nivec4(25216,120,60,48),\nivec4(25280,125,69,54),\nivec4(25280,125,72,54),\nivec4(25344,120,48,48),\nivec4(25408,61,77,54),\nivec4(25472,120,57,48),\nivec4(25472,120,60,48),\nivec4(25472,120,69,54),\nivec4(25472,120,72,54),\nivec4(25600,61,70,54),\nivec4(25600,120,48,48),\nivec4(25664,61,67,54),\nivec4(25728,61,74,54),\nivec4(25728,120,58,48),\nivec4(25728,120,60,48),\nivec4(25728,120,64,48),\nivec4(25792,125,72,54),\nivec4(25856,120,48,48),\nivec4(25920,61,70,54),\nivec4(25984,120,55,48),\nivec4(25984,120,58,48),\nivec4(25984,120,60,48),\nivec4(25984,120,64,54),\nivec4(26112,120,53,48),\nivec4(26112,120,57,48),\nivec4(26112,120,60,48),\nivec4(26112,120,65,54),\nivec4(26240,61,72,54),\nivec4(26304,61,72,54),\nivec4(26368,120,72,54),\nivec4(26496,120,72,54),\nivec4(26624,61,88,54),\nivec4(26624,120,55,48),\nivec4(26688,61,86,54),\nivec4(26752,61,84,54),\nivec4(26752,120,58,48),\nivec4(26752,120,60,48),\nivec4(26752,120,64,48),\nivec4(26816,61,82,54),\nivec4(26880,61,81,54),\nivec4(26880,120,48,48),\nivec4(26944,120,82,54),\nivec4(27008,120,58,48),\nivec4(27008,120,60,48),\nivec4(27008,120,64,48),\nivec4(27072,61,79,54),\nivec4(27136,61,77,54),\nivec4(27136,120,53,48),\nivec4(27200,61,79,54),\nivec4(27264,61,81,54),\nivec4(27264,120,57,48),\nivec4(27264,120,60,48),\nivec4(27328,125,72,54),\nivec4(27392,120,48,48),\nivec4(27456,61,81,54),\nivec4(27520,61,79,54),\nivec4(27520,120,57,48),\nivec4(27520,120,60,48),\nivec4(27584,61,77,54),\nivec4(27648,61,76,54),\nivec4(27648,120,55,48),\nivec4(27712,61,77,54),\nivec4(27776,61,79,54),\nivec4(27776,120,58,48),\nivec4(27776,120,60,48),\nivec4(27840,125,72,54),\nivec4(27904,120,48,48),\nivec4(27968,61,82,54),\nivec4(28032,61,81,54),\nivec4(28032,120,58,48),\nivec4(28032,120,60,48),\nivec4(28096,61,79,54),\nivec4(28160,61,77,54),\nivec4(28160,120,53,48),\nivec4(28224,61,81,54),\nivec4(28288,61,86,54),\nivec4(28288,120,57,48),\nivec4(28288,120,60,48),\nivec4(28352,184,84,54),\nivec4(28416,120,57,48),\nivec4(28544,120,60,48),\nivec4(28544,120,65,48),\nivec4(28544,120,84,54),\nivec4(28672,61,88,54),\nivec4(28672,120,55,48),\nivec4(28736,61,86,54),\nivec4(28800,61,84,54),\nivec4(28800,120,58,48),\nivec4(28800,120,60,48),\nivec4(28800,120,64,48),\nivec4(28864,61,82,54),\nivec4(28928,61,81,54),\nivec4(28928,120,48,48),\nivec4(28992,120,82,54),\nivec4(29056,120,55,48),\nivec4(29056,120,58,48),\nivec4(29056,120,61,48),\nivec4(29120,61,76,54),\nivec4(29184,61,77,54),\nivec4(29184,120,50,48),\nivec4(29248,61,76,54),\nivec4(29312,61,77,54),\nivec4(29312,120,53,48),\nivec4(29312,120,57,48),\nivec4(29312,120,62,48),\nivec4(29376,125,81,54),\nivec4(29440,120,50,48),\nivec4(29504,61,81,54),\nivec4(29568,61,79,54),\nivec4(29568,120,53,48),\nivec4(29568,120,57,48),\nivec4(29568,120,62,48),\nivec4(29632,61,77,54),\nivec4(29696,61,76,54),\nivec4(29696,120,52,48),\nivec4(29760,61,84,54),\nivec4(29824,61,83,54),\nivec4(29824,120,57,48),\nivec4(29824,120,60,48),\nivec4(29888,61,81,54),\nivec4(29952,61,80,54),\nivec4(29952,120,52,48),\nivec4(30016,120,83,54),\nivec4(30080,120,56,48),\nivec4(30080,120,62,48),\nivec4(30144,61,76,54),\nivec4(30208,120,57,48),\nivec4(30208,120,60,48),\nivec4(30208,120,81,54),\nivec4(30464,237,48,48),\nivec4(30464,237,60,48),\nivec4(30464,237,76,54),\nivec4(30464,237,82,54),\nivec4(30464,237,84,54),\nivec4(30720,61,88,54),\nivec4(30720,120,55,48),\nivec4(30784,61,86,54),\nivec4(30848,61,84,54),\nivec4(30848,120,58,48),\nivec4(30848,120,60,48),\nivec4(30848,120,64,48),\nivec4(30912,61,82,54),\nivec4(30976,61,81,54),\nivec4(30976,120,48,48),\nivec4(31040,120,82,54),\nivec4(31104,120,58,48),\nivec4(31104,120,60,48),\nivec4(31104,120,64,48),\nivec4(31168,61,79,54),\nivec4(31232,61,77,54),\nivec4(31232,120,53,48),\nivec4(31296,61,79,54),\nivec4(31360,61,81,54),\nivec4(31360,120,57,48),\nivec4(31360,120,60,48),\nivec4(31424,125,72,54),\nivec4(31488,120,48,48),\nivec4(31552,61,81,54),\nivec4(31616,61,79,54),\nivec4(31616,120,57,48),\nivec4(31616,120,60,48),\nivec4(31680,61,77,54),\nivec4(31744,61,76,54),\nivec4(31744,120,55,48),\nivec4(31808,61,77,54),\nivec4(31872,61,79,54),\nivec4(31872,120,58,48),\nivec4(31872,120,60,48),\nivec4(31936,125,72,54),\nivec4(32000,120,48,48),\nivec4(32064,61,82,54),\nivec4(32128,61,81,54),\nivec4(32128,120,58,48),\nivec4(32128,120,60,48),\nivec4(32192,61,79,54),\nivec4(32256,61,77,54),\nivec4(32256,120,53,48),\nivec4(32320,61,81,54),\nivec4(32384,61,86,54),\nivec4(32384,120,57,48),\nivec4(32384,120,60,48),\nivec4(32448,184,84,54),\nivec4(32512,120,48,48),\nivec4(32640,120,57,48),\nivec4(32640,120,60,48),\nivec4(32640,120,84,54),\nivec4(32768,61,82,54),\nivec4(32768,61,86,54),\nivec4(32768,120,46,48),\nivec4(32832,120,91,54),\nivec4(32896,120,55,48),\nivec4(32896,120,58,48),\nivec4(32896,120,62,48),\nivec4(32960,125,82,54),\nivec4(32960,125,86,54),\nivec4(33024,120,46,48),\nivec4(33088,61,91,54),\nivec4(33152,120,55,48),\nivec4(33152,120,58,48),\nivec4(33152,120,62,48),\nivec4(33152,120,82,54),\nivec4(33152,120,86,54),\nivec4(33280,61,81,54),\nivec4(33280,61,84,54),\nivec4(33280,120,48,48),\nivec4(33344,120,89,54),\nivec4(33408,120,57,48),\nivec4(33408,120,60,48),\nivec4(33472,125,81,54),\nivec4(33472,125,84,54),\nivec4(33536,120,48,48),\nivec4(33600,61,89,54),\nivec4(33664,120,57,48),\nivec4(33664,120,60,48),\nivec4(33664,120,81,54),\nivec4(33664,120,84,54),\nivec4(33792,61,82,54),\nivec4(33792,120,48,48),\nivec4(33856,61,79,54),\nivec4(33920,61,86,54),\nivec4(33920,120,58,48),\nivec4(33920,120,60,48),\nivec4(33920,120,64,48),\nivec4(33984,125,84,54),\nivec4(34048,120,48,48),\nivec4(34112,61,82,54),\nivec4(34176,120,55,48),\nivec4(34176,120,58,48),\nivec4(34176,120,60,48),\nivec4(34176,120,76,54),\nivec4(34304,120,53,48),\nivec4(34304,120,57,48),\nivec4(34304,120,60,48),\nivec4(34304,128,77,54),\nivec4(34432,120,36,64),\nivec4(34432,120,48,64),\nivec4(34496,61,60,64),\nivec4(34560,120,38,64),\nivec4(34560,120,50,64),\nivec4(34624,61,62,64),\nivec4(34688,120,40,64),\nivec4(34688,120,52,64),\nivec4(34752,61,64,64),\nivec4(34816,355,41,64),\nivec4(34816,355,53,64),\nivec4(34880,61,65,64),\nivec4(34944,61,74,64),\nivec4(35008,125,65,64),\nivec4(35008,125,69,64),\nivec4(35008,125,72,64),\nivec4(35136,61,74,64),\nivec4(35200,120,42,64),\nivec4(35200,120,54,64),\nivec4(35200,120,63,64),\nivec4(35200,120,69,64),\nivec4(35200,120,72,64),\nivec4(35328,355,43,64),\nivec4(35328,355,55,64),\nivec4(35392,61,64,64),\nivec4(35456,61,74,64),\nivec4(35520,125,64,64),\nivec4(35520,125,70,64),\nivec4(35520,125,72,64),\nivec4(35648,61,74,64),\nivec4(35712,120,44,64),\nivec4(35712,120,56,64),\nivec4(35712,120,64,64),\nivec4(35712,120,70,64),\nivec4(35712,120,72,64),\nivec4(35840,120,45,64),\nivec4(35840,120,57,64),\nivec4(35904,61,65,64),\nivec4(35904,61,69,64),\nivec4(35904,61,72,64),\nivec4(35968,120,51,64),\nivec4(35968,120,63,64),\nivec4(36032,61,69,64),\nivec4(36032,61,72,64),\nivec4(36096,120,50,64),\nivec4(36096,120,62,64),\nivec4(36160,61,68,64),\nivec4(36160,61,71,64),\nivec4(36224,120,49,64),\nivec4(36224,120,61,64),\nivec4(36288,61,67,64),\nivec4(36288,61,70,64),\nivec4(36352,61,69,64),\nivec4(36352,120,48,64),\nivec4(36352,120,60,64),\nivec4(36352,120,65,64),\nivec4(36416,61,72,64),\nivec4(36480,61,74,64),\nivec4(36480,120,47,64),\nivec4(36480,120,59,64),\nivec4(36480,120,68,64),\nivec4(36544,61,77,64),\nivec4(36608,120,46,64),\nivec4(36608,120,58,64),\nivec4(36608,120,67,64),\nivec4(36608,120,72,64),\nivec4(36608,120,76,64),\nivec4(36736,120,36,64),\nivec4(36736,120,48,64),\nivec4(36736,120,70,64),\nivec4(36736,120,76,64),\nivec4(36736,120,79,64),\nivec4(36864,61,69,64),\nivec4(36864,61,77,64),\nivec4(36864,61,81,64),\nivec4(36864,120,41,64),\nivec4(36928,61,80,64),\nivec4(36992,61,81,64),\nivec4(36992,120,57,64),\nivec4(36992,120,60,64),\nivec4(36992,120,65,64),\nivec4(37056,125,84,64),\nivec4(37120,120,45,64),\nivec4(37184,61,81,64),\nivec4(37248,61,79,64),\nivec4(37248,120,57,64),\nivec4(37248,120,60,64),\nivec4(37248,120,65,64),\nivec4(37312,61,77,64),\nivec4(37376,61,79,64),\nivec4(37376,120,46,64),\nivec4(37440,61,77,64),\nivec4(37504,61,74,64),\nivec4(37504,120,58,64),\nivec4(37504,120,62,64),\nivec4(37504,120,65,64),\nivec4(37568,125,77,64),\nivec4(37632,120,45,64),\nivec4(37696,61,74,64),\nivec4(37760,61,72,64),\nivec4(37760,120,57,64),\nivec4(37760,120,60,64),\nivec4(37760,120,65,64),\nivec4(37824,61,69,64),\nivec4(37888,61,67,64),\nivec4(37888,120,47,64),\nivec4(37952,61,79,64),\nivec4(38016,61,77,64),\nivec4(38016,120,55,64),\nivec4(38016,120,59,64),\nivec4(38016,120,65,64),\nivec4(38080,61,76,64),\nivec4(38144,61,74,64),\nivec4(38144,120,43,64),\nivec4(38208,120,69,64),\nivec4(38272,120,55,64),\nivec4(38272,120,59,64),\nivec4(38272,120,65,64),\nivec4(38336,61,71,64),\nivec4(38400,120,60,64),\nivec4(38400,120,64,64),\nivec4(38400,120,72,64),\nivec4(38656,120,48,64),\nivec4(38656,120,60,64),\nivec4(38656,120,72,64),\nivec4(38656,120,76,64),\nivec4(38656,120,84,64),\nivec4(38784,120,36,64),\nivec4(38784,120,48,64),\nivec4(38912,355,41,64),\nivec4(38912,355,53,64),\nivec4(38976,61,65,64),\nivec4(39040,61,74,64),\nivec4(39104,125,65,64),\nivec4(39104,125,69,64),\nivec4(39104,125,72,64),\nivec4(39232,61,74,64),\nivec4(39296,120,42,64),\nivec4(39296,120,54,64),\nivec4(39296,120,63,64),\nivec4(39296,120,69,64),\nivec4(39296,120,72,64),\nivec4(39424,355,43,64),\nivec4(39424,355,55,64),\nivec4(39488,61,64,64),\nivec4(39552,61,74,64),\nivec4(39616,125,64,64),\nivec4(39616,125,70,64),\nivec4(39616,125,72,64),\nivec4(39744,61,74,64),\nivec4(39808,120,44,64),\nivec4(39808,120,56,64),\nivec4(39808,120,64,64),\nivec4(39808,120,70,64),\nivec4(39808,120,72,64),\nivec4(39936,120,45,64),\nivec4(39936,120,57,64),\nivec4(40000,61,65,64),\nivec4(40000,61,69,64),\nivec4(40000,61,72,64),\nivec4(40064,120,51,64),\nivec4(40064,120,63,64),\nivec4(40128,61,69,64),\nivec4(40128,61,72,64),\nivec4(40192,120,50,64),\nivec4(40192,120,62,64),\nivec4(40256,61,68,64),\nivec4(40256,61,71,64),\nivec4(40320,120,49,64),\nivec4(40320,120,61,64),\nivec4(40384,61,67,64),\nivec4(40384,61,70,64),\nivec4(40448,61,69,64),\nivec4(40448,120,48,64),\nivec4(40448,120,60,64),\nivec4(40448,120,65,64),\nivec4(40512,61,72,64),\nivec4(40576,61,74,64),\nivec4(40576,120,47,64),\nivec4(40576,120,59,64),\nivec4(40576,120,68,64),\nivec4(40640,61,77,64),\nivec4(40704,120,46,64),\nivec4(40704,120,58,64),\nivec4(40704,120,67,64),\nivec4(40704,120,72,64),\nivec4(40704,120,76,64),\nivec4(40832,120,36,64),\nivec4(40832,120,48,64),\nivec4(40832,120,70,64),\nivec4(40832,120,76,64),\nivec4(40832,120,79,64),\nivec4(40960,61,69,64),\nivec4(40960,61,77,64),\nivec4(40960,61,81,64),\nivec4(40960,120,41,64),\nivec4(41024,61,80,64),\nivec4(41088,61,81,64),\nivec4(41088,120,57,64),\nivec4(41088,120,60,64),\nivec4(41088,120,65,64),\nivec4(41152,125,84,64),\nivec4(41216,120,45,64),\nivec4(41280,61,81,64),\nivec4(41344,61,79,64),\nivec4(41344,120,57,64),\nivec4(41344,120,60,64),\nivec4(41344,120,65,64),\nivec4(41408,61,77,64),\nivec4(41472,61,79,64),\nivec4(41472,120,46,64),\nivec4(41536,61,77,64),\nivec4(41600,61,74,64),\nivec4(41600,120,58,64),\nivec4(41600,120,62,64),\nivec4(41600,120,65,64),\nivec4(41664,125,72,64),\nivec4(41728,120,45,64),\nivec4(41792,61,74,64),\nivec4(41856,61,69,64),\nivec4(41856,120,57,64),\nivec4(41856,120,60,64),\nivec4(41856,120,65,64),\nivec4(41920,61,67,64),\nivec4(41984,61,59,64),\nivec4(41984,61,65,64),\nivec4(41984,120,38,64),\nivec4(41984,120,50,64),\nivec4(42048,61,67,64),\nivec4(42112,120,38,64),\nivec4(42112,120,50,64),\nivec4(42112,120,59,64),\nivec4(42112,120,65,64),\nivec4(42112,120,69,64),\nivec4(42240,61,58,64),\nivec4(42240,61,64,64),\nivec4(42240,61,67,64),\nivec4(42240,120,36,64),\nivec4(42240,120,48,64),\nivec4(42304,120,58,64),\nivec4(42304,120,64,64),\nivec4(42304,120,67,64),\nivec4(42368,120,40,64),\nivec4(42368,120,52,64),\nivec4(42432,61,58,64),\nivec4(42432,61,60,64),\nivec4(42496,120,41,64),\nivec4(42496,120,53,64),\nivec4(42496,120,57,64),\nivec4(42496,120,65,64),\nivec4(42752,237,41,64),\nivec4(42752,237,53,64),\nivec4(42752,237,69,64),\nivec4(42752,237,75,64),\nivec4(42752,237,77,64),\nivec4(43008,61,70,60),\nivec4(43008,61,74,60),\nivec4(43008,120,46,54),\nivec4(43072,61,79,60),\nivec4(43136,61,77,60),\nivec4(43136,120,53,54),\nivec4(43136,120,58,54),\nivec4(43136,120,62,54),\nivec4(43200,61,75,60),\nivec4(43264,61,74,60),\nivec4(43264,120,50,54),\nivec4(43328,61,72,60),\nivec4(43392,61,70,60),\nivec4(43392,120,53,54),\nivec4(43392,120,58,54),\nivec4(43392,120,62,54),\nivec4(43456,61,74,60),\nivec4(43520,61,72,60),\nivec4(43520,120,51,54),\nivec4(43584,61,70,60),\nivec4(43648,61,67,60),\nivec4(43648,120,55,54),\nivec4(43648,120,58,54),\nivec4(43648,120,63,54),\nivec4(43712,125,65,60),\nivec4(43776,120,50,54),\nivec4(43840,120,82,60),\nivec4(43904,120,53,54),\nivec4(43904,120,58,54),\nivec4(43904,120,62,54),\nivec4(43968,61,79,60),\nivec4(44032,61,77,60),\nivec4(44032,120,46,54),\nivec4(44096,61,79,60),\nivec4(44160,61,77,60),\nivec4(44160,120,53,54),\nivec4(44160,120,58,54),\nivec4(44160,120,62,54),\nivec4(44224,61,74,60),\nivec4(44288,61,70,60),\nivec4(44288,120,48,54),\nivec4(44352,61,72,60),\nivec4(44416,61,74,60),\nivec4(44416,120,58,54),\nivec4(44416,120,60,54),\nivec4(44416,120,64,54),\nivec4(44480,419,69,60),\nivec4(44480,419,72,60),\nivec4(44544,120,53,54),\nivec4(44544,120,57,54),\nivec4(44544,120,63,54),\nivec4(44672,120,41,54),\nivec4(44672,120,53,54),\nivec4(44800,120,43,54),\nivec4(44800,120,55,54),\nivec4(44928,120,45,54),\nivec4(44928,120,57,54),\nivec4(44928,120,65,60),\nivec4(45056,61,74,60),\nivec4(45056,120,46,54),\nivec4(45120,61,79,60),\nivec4(45184,61,77,60),\nivec4(45184,120,53,54),\nivec4(45184,120,58,54),\nivec4(45184,120,62,54),\nivec4(45248,61,75,60),\nivec4(45312,61,74,60),\nivec4(45312,120,50,54),\nivec4(45376,61,75,60),\nivec4(45440,61,74,60),\nivec4(45440,120,54,54),\nivec4(45440,120,60,54),\nivec4(45440,120,62,54),\nivec4(45504,61,72,60),\nivec4(45568,61,70,60),\nivec4(45568,120,55,54),\nivec4(45632,61,69,60),\nivec4(45696,61,67,60),\nivec4(45696,120,58,54),\nivec4(45696,120,62,54),\nivec4(45760,125,70,60),\nivec4(45824,120,55,54),\nivec4(45888,61,74,60),\nivec4(45952,61,72,60),\nivec4(45952,120,58,54),\nivec4(45952,120,62,54),\nivec4(46016,61,70,60),\nivec4(46080,61,69,60),\nivec4(46080,120,57,54),\nivec4(46144,61,74,60),\nivec4(46208,61,77,60),\nivec4(46208,120,62,54),\nivec4(46208,120,65,54),\nivec4(46272,61,81,60),\nivec4(46336,61,79,60),\nivec4(46336,120,57,54),\nivec4(46400,120,77,60),\nivec4(46464,120,61,54),\nivec4(46464,120,67,54),\nivec4(46528,61,76,60),\nivec4(46592,120,62,54),\nivec4(46592,120,65,54),\nivec4(46592,120,74,60),\nivec4(46848,237,41,54),\nivec4(46848,237,53,54),\nivec4(46848,237,69,60),\nivec4(46848,237,75,60),\nivec4(46848,237,77,60),\nivec4(47104,61,70,60),\nivec4(47104,61,74,60),\nivec4(47104,120,34,54),\nivec4(47104,120,46,54),\nivec4(47168,61,79,60),\nivec4(47232,61,77,60),\nivec4(47232,120,53,54),\nivec4(47232,120,58,54),\nivec4(47232,120,62,54),\nivec4(47296,61,75,60),\nivec4(47360,61,74,60),\nivec4(47360,120,50,54),\nivec4(47424,61,72,60),\nivec4(47488,61,70,60),\nivec4(47488,120,53,54),\nivec4(47488,120,58,54),\nivec4(47488,120,62,54),\nivec4(47552,61,74,60),\nivec4(47616,61,72,60),\nivec4(47616,120,51,54),\nivec4(47680,61,70,60),\nivec4(47744,61,67,60),\nivec4(47744,120,55,54),\nivec4(47744,120,58,54),\nivec4(47744,120,63,54),\nivec4(47808,125,65,60),\nivec4(47872,120,50,54),\nivec4(47936,120,82,60),\nivec4(48000,120,53,54),\nivec4(48000,120,58,54),\nivec4(48000,120,62,54),\nivec4(48064,61,79,60),\nivec4(48128,61,77,60),\nivec4(48128,120,46,54),\nivec4(48192,61,79,60),\nivec4(48256,61,77,60),\nivec4(48256,120,53,54),\nivec4(48256,120,58,54),\nivec4(48256,120,62,54),\nivec4(48320,61,74,60),\nivec4(48384,61,70,60),\nivec4(48384,120,48,54),\nivec4(48448,61,72,60),\nivec4(48512,61,74,60),\nivec4(48512,120,58,54),\nivec4(48512,120,60,54),\nivec4(48512,120,64,54),\nivec4(48576,419,69,60),\nivec4(48576,419,72,60),\nivec4(48640,120,53,54),\nivec4(48640,120,57,54),\nivec4(48640,120,63,54),\nivec4(48768,120,41,54),\nivec4(48768,120,53,54),\nivec4(48896,120,43,54),\nivec4(48896,120,55,54),\nivec4(49024,120,45,54),\nivec4(49024,120,57,54),\nivec4(49024,120,65,60),\nivec4(49152,61,74,60),\nivec4(49152,120,46,54),\nivec4(49152,120,58,54),\nivec4(49216,61,73,60),\nivec4(49280,61,74,60),\nivec4(49280,120,53,54),\nivec4(49280,120,58,54),\nivec4(49280,120,62,54),\nivec4(49344,61,75,60),\nivec4(49408,61,77,60),\nivec4(49408,120,50,54),\nivec4(49472,61,76,60),\nivec4(49536,61,77,60),\nivec4(49536,120,53,54),\nivec4(49536,120,58,54),\nivec4(49536,120,62,54),\nivec4(49600,61,78,60),\nivec4(49664,61,79,60),\nivec4(49664,120,51,54),\nivec4(49728,61,78,60),\nivec4(49792,61,79,60),\nivec4(49792,120,55,54),\nivec4(49792,120,58,54),\nivec4(49792,120,63,54),\nivec4(49856,125,82,60),\nivec4(49920,120,52,54),\nivec4(49984,61,82,60),\nivec4(50048,61,81,60),\nivec4(50048,120,55,54),\nivec4(50048,120,58,54),\nivec4(50048,120,61,54),\nivec4(50112,61,79,60),\nivec4(50176,61,77,60),\nivec4(50176,120,53,54),\nivec4(50240,61,86,60),\nivec4(50304,61,82,60),\nivec4(50304,120,58,54),\nivec4(50304,120,62,54),\nivec4(50368,61,77,60),\nivec4(50432,61,79,60),\nivec4(50432,120,41,54),\nivec4(50496,61,75,60),\nivec4(50560,61,72,60),\nivec4(50560,120,53,54),\nivec4(50560,120,57,54),\nivec4(50560,120,63,54),\nivec4(50624,61,69,60),\nivec4(50688,120,58,54),\nivec4(50688,120,62,54),\nivec4(50688,120,70,60),\nivec4(50816,61,64,60),\nivec4(50880,61,65,60),\nivec4(50944,61,67,60),\nivec4(51008,61,69,60),\nivec4(51072,61,70,60),\nivec4(51136,61,72,60),\nivec4(51200,61,70,60),\nivec4(51200,61,74,60),\nivec4(51200,120,46,54),\nivec4(51264,61,79,60),\nivec4(51328,61,77,60),\nivec4(51328,120,53,54),\nivec4(51328,120,58,54),\nivec4(51328,120,62,54),\nivec4(51392,61,75,60),\nivec4(51456,61,74,60),\nivec4(51456,120,50,54),\nivec4(51520,61,72,60),\nivec4(51584,61,70,60),\nivec4(51584,120,53,54),\nivec4(51584,120,58,54),\nivec4(51584,120,62,54),\nivec4(51648,61,74,60),\nivec4(51712,61,72,60),\nivec4(51712,120,51,54),\nivec4(51776,61,70,60),\nivec4(51840,61,67,60),\nivec4(51840,120,55,54),\nivec4(51840,120,58,54),\nivec4(51840,120,63,54),\nivec4(51904,125,65,60),\nivec4(51968,120,50,54),\nivec4(52032,120,82,60),\nivec4(52096,120,53,54),\nivec4(52096,120,58,54),\nivec4(52096,120,62,54),\nivec4(52160,61,79,60),\nivec4(52224,61,77,60),\nivec4(52224,120,46,54),\nivec4(52288,61,79,60),\nivec4(52352,61,77,60),\nivec4(52352,120,53,54),\nivec4(52352,120,58,54),\nivec4(52352,120,62,54),\nivec4(52416,61,74,60),\nivec4(52480,61,70,60),\nivec4(52480,120,48,54),\nivec4(52544,61,72,60),\nivec4(52608,61,74,60),\nivec4(52608,120,58,54),\nivec4(52608,120,60,54),\nivec4(52608,120,64,54),\nivec4(52672,419,69,60),\nivec4(52672,419,72,60),\nivec4(52736,120,53,54),\nivec4(52736,120,57,54),\nivec4(52736,120,63,54),\nivec4(52864,120,41,54),\nivec4(52864,120,53,54),\nivec4(52992,120,43,54),\nivec4(52992,120,55,54),\nivec4(53120,120,45,54),\nivec4(53120,120,57,54),\nivec4(53120,120,65,60),\nivec4(53248,61,74,60),\nivec4(53248,120,46,54),\nivec4(53312,61,79,60),\nivec4(53376,61,77,60),\nivec4(53376,120,53,54),\nivec4(53376,120,58,54),\nivec4(53376,120,62,54),\nivec4(53440,61,75,60),\nivec4(53504,61,74,60),\nivec4(53504,120,50,54),\nivec4(53568,61,75,60),\nivec4(53632,61,74,60),\nivec4(53632,120,54,54),\nivec4(53632,120,60,54),\nivec4(53632,120,62,54),\nivec4(53696,61,72,60),\nivec4(53760,61,70,60),\nivec4(53760,120,55,54),\nivec4(53824,61,69,60),\nivec4(53888,61,67,60),\nivec4(53888,120,58,54),\nivec4(53888,120,62,54),\nivec4(53952,125,70,60),\nivec4(54016,120,55,54),\nivec4(54080,61,74,60),\nivec4(54144,61,72,60),\nivec4(54144,120,58,54),\nivec4(54144,120,62,54),\nivec4(54208,61,70,60),\nivec4(54272,61,69,60),\nivec4(54272,120,57,54),\nivec4(54336,61,74,60),\nivec4(54400,61,77,60),\nivec4(54400,120,62,54),\nivec4(54400,120,65,54),\nivec4(54464,61,81,60),\nivec4(54528,61,79,60),\nivec4(54528,120,57,54),\nivec4(54592,120,77,60),\nivec4(54656,120,61,54),\nivec4(54656,120,67,54),\nivec4(54720,61,76,60),\nivec4(54784,120,62,54),\nivec4(54784,120,65,54),\nivec4(54784,120,74,60),\nivec4(55040,237,41,54),\nivec4(55040,237,53,54),\nivec4(55040,237,69,60),\nivec4(55040,237,75,60),\nivec4(55040,237,77,60),\nivec4(55296,61,70,60),\nivec4(55296,61,74,60),\nivec4(55296,120,34,54),\nivec4(55296,120,46,54),\nivec4(55360,61,79,60),\nivec4(55424,61,77,60),\nivec4(55424,120,53,54),\nivec4(55424,120,58,54),\nivec4(55424,120,62,54),\nivec4(55488,61,75,60),\nivec4(55552,61,74,60),\nivec4(55552,120,50,54),\nivec4(55616,61,72,60),\nivec4(55680,61,70,60),\nivec4(55680,120,53,54),\nivec4(55680,120,58,54),\nivec4(55680,120,62,54),\nivec4(55744,61,74,60),\nivec4(55808,61,72,60),\nivec4(55808,120,51,54),\nivec4(55872,61,70,60),\nivec4(55936,61,67,60),\nivec4(55936,120,55,54),\nivec4(55936,120,58,54),\nivec4(55936,120,63,54),\nivec4(56000,125,65,60),\nivec4(56064,120,50,54),\nivec4(56128,120,82,60),\nivec4(56192,120,53,54),\nivec4(56192,120,58,54),\nivec4(56192,120,62,54),\nivec4(56256,61,79,60),\nivec4(56320,61,77,60),\nivec4(56320,120,46,54),\nivec4(56384,61,79,60),\nivec4(56448,61,77,60),\nivec4(56448,120,53,54),\nivec4(56448,120,58,54),\nivec4(56448,120,62,54),\nivec4(56512,61,74,60),\nivec4(56576,61,70,60),\nivec4(56576,120,48,54),\nivec4(56640,61,72,60),\nivec4(56704,61,74,60),\nivec4(56704,120,58,54),\nivec4(56704,120,60,54),\nivec4(56704,120,64,54),\nivec4(56768,419,69,60),\nivec4(56768,419,72,60),\nivec4(56832,120,53,54),\nivec4(56832,120,57,54),\nivec4(56832,120,63,54),\nivec4(56960,120,41,54),\nivec4(56960,120,53,54),\nivec4(57088,120,43,54),\nivec4(57088,120,55,54),\nivec4(57216,120,45,54),\nivec4(57216,120,57,54),\nivec4(57216,120,65,60),\nivec4(57344,61,74,60),\nivec4(57344,120,46,54),\nivec4(57344,120,58,54),\nivec4(57408,61,73,60),\nivec4(57472,61,74,60),\nivec4(57472,120,53,54),\nivec4(57472,120,58,54),\nivec4(57472,120,62,54),\nivec4(57536,61,75,60),\nivec4(57600,61,77,60),\nivec4(57600,120,50,54),\nivec4(57664,61,76,60),\nivec4(57728,61,77,60),\nivec4(57728,120,53,54),\nivec4(57728,120,58,54),\nivec4(57728,120,62,54),\nivec4(57792,61,78,60),\nivec4(57856,61,79,60),\nivec4(57856,120,51,54),\nivec4(57920,61,78,60),\nivec4(57984,61,79,60),\nivec4(57984,120,55,54),\nivec4(57984,120,58,54),\nivec4(57984,120,63,54),\nivec4(58048,125,82,60),\nivec4(58112,120,52,54),\nivec4(58176,61,82,60),\nivec4(58240,61,81,60),\nivec4(58240,120,55,54),\nivec4(58240,120,58,54),\nivec4(58240,120,61,54),\nivec4(58304,61,79,60),\nivec4(58368,61,77,60),\nivec4(58368,120,53,54),\nivec4(58432,61,86,60),\nivec4(58496,61,82,60),\nivec4(58496,120,58,54),\nivec4(58496,120,62,54),\nivec4(58560,61,77,60),\nivec4(58624,61,79,60),\nivec4(58624,120,41,54),\nivec4(58688,61,75,60),\nivec4(58752,61,72,60),\nivec4(58752,120,53,54),\nivec4(58752,120,57,54),\nivec4(58752,120,63,54),\nivec4(58816,61,69,60),\nivec4(58880,120,58,54),\nivec4(58880,120,62,54),\nivec4(58880,355,70,60),\nivec4(59008,120,34,68),\nivec4(59008,120,46,68),\nivec4(59136,120,36,68),\nivec4(59136,120,48,68),\nivec4(59264,120,38,68),\nivec4(59264,120,50,68),\nivec4(59328,125,70,85),\nivec4(59328,125,82,85),\nivec4(59392,120,39,68),\nivec4(59392,120,51,68),\nivec4(59456,61,75,85),\nivec4(59520,61,72,85),\nivec4(59520,61,84,85),\nivec4(59520,120,55,68),\nivec4(59520,120,58,68),\nivec4(59520,120,63,68),\nivec4(59584,61,75,85),\nivec4(59648,61,79,85),\nivec4(59648,120,55,68),\nivec4(59648,120,58,68),\nivec4(59648,120,63,68),\nivec4(59712,120,70,85),\nivec4(59712,120,82,85),\nivec4(59776,120,38,68),\nivec4(59776,120,50,68),\nivec4(59840,61,75,85),\nivec4(59904,61,72,85),\nivec4(59904,61,84,85),\nivec4(59904,120,39,68),\nivec4(59904,120,51,68),\nivec4(59968,61,75,85),\nivec4(60032,61,79,85),\nivec4(60032,120,41,68),\nivec4(60032,120,53,68),\nivec4(60096,125,70,85),\nivec4(60096,125,82,85),\nivec4(60160,120,43,68),\nivec4(60160,120,55,68),\nivec4(60224,120,72,85),\nivec4(60224,120,84,85),\nivec4(60288,120,45,68),\nivec4(60288,120,57,68),\nivec4(60352,61,70,85),\nivec4(60352,61,82,85),\nivec4(60416,61,65,85),\nivec4(60416,61,77,85),\nivec4(60416,120,46,68),\nivec4(60416,120,58,68),\nivec4(60480,61,70,85),\nivec4(60544,61,67,85),\nivec4(60544,61,79,85),\nivec4(60544,120,53,68),\nivec4(60544,120,58,68),\nivec4(60544,120,62,68),\nivec4(60608,61,70,85),\nivec4(60672,61,74,85),\nivec4(60672,120,53,68),\nivec4(60672,120,58,68),\nivec4(60672,120,62,68),\nivec4(60736,120,65,85),\nivec4(60736,120,77,85),\nivec4(60800,120,49,68),\nivec4(60800,120,61,68),\nivec4(60864,61,70,85),\nivec4(60928,61,67,85),\nivec4(60928,61,79,85),\nivec4(60928,120,50,68),\nivec4(60928,120,62,68),\nivec4(60992,61,70,85),\nivec4(61056,61,74,85),\nivec4(61056,120,53,68),\nivec4(61056,120,58,68),\nivec4(61056,120,62,68),\nivec4(61120,125,65,85),\nivec4(61120,125,77,85),\nivec4(61184,120,53,68),\nivec4(61184,120,58,68),\nivec4(61184,120,62,68),\nivec4(61248,120,67,85),\nivec4(61248,120,79,85),\nivec4(61312,120,41,68),\nivec4(61312,120,53,68),\nivec4(61376,61,70,85),\nivec4(61440,61,65,85),\nivec4(61440,61,77,85),\nivec4(61440,120,48,68),\nivec4(61440,120,60,68),\nivec4(61504,61,69,85),\nivec4(61568,61,67,85),\nivec4(61568,61,79,85),\nivec4(61568,120,53,68),\nivec4(61568,120,57,68),\nivec4(61568,120,63,68),\nivec4(61632,61,69,85),\nivec4(61696,61,72,85),\nivec4(61696,120,53,68),\nivec4(61696,120,57,68),\nivec4(61696,120,63,68),\nivec4(61760,120,65,85),\nivec4(61760,120,77,85),\nivec4(61824,120,41,68),\nivec4(61824,120,53,68),\nivec4(61888,61,69,85),\nivec4(61952,61,67,85),\nivec4(61952,61,79,85),\nivec4(61952,120,48,68),\nivec4(61952,120,60,68),\nivec4(62016,61,69,85),\nivec4(62080,61,72,85),\nivec4(62080,120,53,68),\nivec4(62080,120,57,68),\nivec4(62080,120,63,68),\nivec4(62144,125,65,85),\nivec4(62144,125,77,85),\nivec4(62208,120,48,68),\nivec4(62208,120,60,68),\nivec4(62272,120,67,85),\nivec4(62272,120,79,85),\nivec4(62336,120,49,68),\nivec4(62336,120,61,68),\nivec4(62400,61,69,85),\nivec4(62464,61,65,85),\nivec4(62464,61,77,85),\nivec4(62464,120,50,68),\nivec4(62464,120,62,68),\nivec4(62528,61,70,85),\nivec4(62592,61,67,85),\nivec4(62592,61,79,85),\nivec4(62592,120,53,68),\nivec4(62592,120,58,68),\nivec4(62592,120,62,68),\nivec4(62656,61,70,85),\nivec4(62720,61,74,85),\nivec4(62720,120,53,68),\nivec4(62720,120,58,68),\nivec4(62720,120,62,68),\nivec4(62784,120,65,85),\nivec4(62784,120,77,85),\nivec4(62848,120,41,68),\nivec4(62848,120,53,68),\nivec4(62912,61,70,85),\nivec4(62976,61,67,85),\nivec4(62976,61,79,85),\nivec4(62976,120,46,68),\nivec4(62976,120,62,68),\nivec4(63040,61,70,85),\nivec4(63104,61,74,85),\nivec4(63104,120,53,68),\nivec4(63104,120,58,68),\nivec4(63104,120,62,68),\nivec4(63168,125,65,85),\nivec4(63168,125,77,85),\nivec4(63232,120,53,68),\nivec4(63232,120,58,68),\nivec4(63232,120,62,68),\nivec4(63296,120,65,85),\nivec4(63296,120,77,85),\nivec4(63360,120,38,68),\nivec4(63360,120,50,68),\nivec4(63424,125,70,85),\nivec4(63424,125,82,85),\nivec4(63488,120,39,68),\nivec4(63488,120,51,68),\nivec4(63552,61,75,85),\nivec4(63616,61,72,85),\nivec4(63616,61,84,85),\nivec4(63616,120,55,68),\nivec4(63616,120,58,68),\nivec4(63616,120,63,68),\nivec4(63680,61,75,85),\nivec4(63744,61,79,85),\nivec4(63744,120,55,68),\nivec4(63744,120,58,68),\nivec4(63744,120,63,68),\nivec4(63808,120,70,85),\nivec4(63808,120,82,85),\nivec4(63872,120,38,68),\nivec4(63872,120,50,68),\nivec4(63936,61,75,85),\nivec4(64000,61,72,85),\nivec4(64000,61,84,85),\nivec4(64000,120,39,68),\nivec4(64000,120,51,68),\nivec4(64064,61,75,85),\nivec4(64128,61,79,85),\nivec4(64128,120,41,68),\nivec4(64128,120,53,68),\nivec4(64192,125,70,85),\nivec4(64192,125,82,85),\nivec4(64256,120,43,68),\nivec4(64256,120,55,68),\nivec4(64320,120,72,85),\nivec4(64320,120,84,85),\nivec4(64384,120,45,68),\nivec4(64384,120,57,68),\nivec4(64448,61,70,85),\nivec4(64448,61,82,85),\nivec4(64512,61,65,85),\nivec4(64512,61,77,85),\nivec4(64512,120,46,68),\nivec4(64512,120,58,68),\nivec4(64576,61,70,85),\nivec4(64640,61,67,85),\nivec4(64640,61,79,85),\nivec4(64640,120,53,68),\nivec4(64640,120,58,68),\nivec4(64640,120,62,68),\nivec4(64704,61,70,85),\nivec4(64768,61,74,85),\nivec4(64768,120,41,68),\nivec4(64832,120,65,85),\nivec4(64832,120,77,85),\nivec4(64896,120,53,68),\nivec4(64896,120,58,68),\nivec4(64896,120,62,68),\nivec4(64960,61,70,85),\nivec4(65024,61,67,85),\nivec4(65024,61,79,85),\nivec4(65024,120,46,68),\nivec4(65088,61,70,85),\nivec4(65152,61,74,85),\nivec4(65152,120,53,68),\nivec4(65152,120,58,68),\nivec4(65152,120,62,68),\nivec4(65216,125,65,85),\nivec4(65216,125,77,85),\nivec4(65280,120,41,68),\nivec4(65344,120,65,85),\nivec4(65344,120,77,85),\nivec4(65408,120,53,68),\nivec4(65408,120,58,68),\nivec4(65408,120,62,68),\nivec4(65472,125,64,85),\nivec4(65472,125,73,85),\nivec4(65536,120,42,68),\nivec4(65536,120,54,68),\nivec4(65600,61,70,85),\nivec4(65664,61,64,85),\nivec4(65664,61,73,85),\nivec4(65664,120,49,68),\nivec4(65664,120,61,68),\nivec4(65728,61,70,85),\nivec4(65792,61,72,85),\nivec4(65792,120,46,68),\nivec4(65792,120,58,68),\nivec4(65856,120,64,85),\nivec4(65856,120,73,85),\nivec4(65920,120,42,68),\nivec4(65920,120,54,68),\nivec4(65984,61,70,85),\nivec4(66048,61,65,85),\nivec4(66048,61,74,85),\nivec4(66048,120,41,68),\nivec4(66048,120,53,68),\nivec4(66112,61,70,85),\nivec4(66176,61,72,85),\nivec4(66176,120,50,68),\nivec4(66176,120,62,68),\nivec4(66240,125,65,85),\nivec4(66240,125,74,85),\nivec4(66304,64,77,99),\nivec4(66304,64,82,99),\nivec4(66304,128,44,84),\nivec4(66304,128,49,84),\nivec4(66304,128,53,84),\nivec4(66304,128,46,85),\nivec4(66304,128,58,85));\n#elif TUNE == 0\nfloat speed = 1.0;\nconst ivec4 data[] = ivec4[](\nivec4(0,246,65,88),\nivec4(0,369,53,75),\nivec4(256,123,57,65),\nivec4(256,123,60,65),\nivec4(256,123,65,65),\nivec4(256,123,67,101),\nivec4(384,246,69,100),\nivec4(384,369,48,79),\nivec4(640,123,57,63),\nivec4(640,123,60,63),\nivec4(640,123,65,63),\nivec4(640,123,70,101),\nivec4(768,246,72,99),\nivec4(768,369,53,85),\nivec4(1024,123,57,62),\nivec4(1024,123,60,62),\nivec4(1024,123,65,62),\nivec4(1024,123,69,95),\nivec4(1152,246,72,104),\nivec4(1152,369,48,82),\nivec4(1408,123,57,64),\nivec4(1408,123,60,64),\nivec4(1408,123,65,64),\nivec4(1408,123,69,94),\nivec4(1536,246,74,104),\nivec4(1536,369,50,86),\nivec4(1792,123,57,62),\nivec4(1792,123,62,62),\nivec4(1792,123,65,62),\nivec4(1792,123,69,92),\nivec4(1920,246,74,105),\nivec4(1920,369,45,79),\nivec4(2176,123,57,66),\nivec4(2176,123,62,66),\nivec4(2176,123,65,66),\nivec4(2176,123,69,91),\nivec4(2304,369,50,86),\nivec4(2304,753,74,105),\nivec4(2560,123,57,62),\nivec4(2560,123,62,62),\nivec4(2560,123,65,62),\nivec4(2688,369,45,79),\nivec4(2944,123,57,64),\nivec4(2944,123,62,64),\nivec4(2944,123,65,64),\nivec4(3072,246,72,95),\nivec4(3072,369,48,86),\nivec4(3328,123,57,64),\nivec4(3328,123,60,64),\nivec4(3328,123,65,64),\nivec4(3328,123,69,92),\nivec4(3456,246,72,103),\nivec4(3456,369,45,82),\nivec4(3712,123,57,64),\nivec4(3712,123,60,64),\nivec4(3712,123,66,64),\nivec4(3712,123,69,91),\nivec4(3840,123,72,102),\nivec4(3840,369,43,86),\nivec4(3968,123,70,95),\nivec4(4096,123,58,65),\nivec4(4096,123,60,65),\nivec4(4096,123,67,65),\nivec4(4096,123,69,96),\nivec4(4224,123,67,96),\nivec4(4224,369,48,87),\nivec4(4352,123,69,100),\nivec4(4480,123,58,65),\nivec4(4480,123,60,65),\nivec4(4480,123,64,65),\nivec4(4480,123,67,95),\nivec4(4608,369,53,86),\nivec4(4608,1014,65,95),\nivec4(4864,123,57,64),\nivec4(4864,123,60,64),\nivec4(4864,123,65,64),\nivec4(4992,369,53,82),\nivec4(5248,123,58,63),\nivec4(5248,123,62,63),\nivec4(5248,123,65,63),\n#if HW_PERFORMANCE == 0\nivec4(5376,369,53,85));\n#else\nivec4(5376,369,53,85),\nivec4(5632,123,57,63),\nivec4(5632,123,60,63),\nivec4(5632,123,65,63),\nivec4(5760,369,48,82),\nivec4(6016,123,58,64),\nivec4(6016,123,60,64),\nivec4(6016,123,64,64),\nivec4(6144,123,65,88),\nivec4(6144,369,53,88),\nivec4(6272,123,65,94),\nivec4(6400,123,57,66),\nivec4(6400,123,60,66),\nivec4(6400,123,65,66),\nivec4(6400,123,67,101),\nivec4(6528,246,69,100),\nivec4(6528,369,48,80),\nivec4(6784,123,57,64),\nivec4(6784,123,60,64),\nivec4(6784,123,65,64),\nivec4(6784,123,70,99),\nivec4(6912,246,72,100),\nivec4(6912,369,53,85),\nivec4(7168,123,57,65),\nivec4(7168,123,60,65),\nivec4(7168,123,65,65),\nivec4(7168,123,69,94),\nivec4(7296,246,72,103),\nivec4(7296,369,48,83),\nivec4(7552,123,57,62),\nivec4(7552,123,60,62),\nivec4(7552,123,65,62),\nivec4(7552,123,69,95),\nivec4(7680,246,74,103),\nivec4(7680,369,50,86),\nivec4(7936,123,57,65),\nivec4(7936,123,62,65),\nivec4(7936,123,65,65),\nivec4(7936,123,69,92),\nivec4(8064,246,74,103),\nivec4(8064,369,45,81),\nivec4(8320,123,57,65),\nivec4(8320,123,62,65),\nivec4(8320,123,65,65),\nivec4(8320,123,69,90),\nivec4(8448,369,50,85),\nivec4(8448,507,74,106),\nivec4(8704,123,57,62),\nivec4(8704,123,62,62),\nivec4(8704,123,65,62),\nivec4(8832,369,45,82),\nivec4(8960,123,69,91),\nivec4(9088,123,57,65),\nivec4(9088,123,62,65),\nivec4(9088,123,65,65),\nivec4(9088,123,69,98),\nivec4(9216,246,72,101),\nivec4(9216,369,48,84),\nivec4(9472,123,57,64),\nivec4(9472,123,60,64),\nivec4(9472,123,65,64),\nivec4(9472,123,69,95),\nivec4(9600,246,72,100),\nivec4(9600,369,45,83),\nivec4(9856,123,57,65),\nivec4(9856,123,60,65),\nivec4(9856,123,66,65),\nivec4(9856,123,69,96),\nivec4(9984,123,72,102),\nivec4(9984,369,43,85),\nivec4(10112,123,70,93),\nivec4(10240,123,58,64),\nivec4(10240,123,60,64),\nivec4(10240,123,67,64),\nivec4(10240,123,69,95),\nivec4(10368,123,67,95),\nivec4(10368,369,48,85),\nivec4(10496,123,69,101),\nivec4(10624,123,58,64),\nivec4(10624,123,60,64),\nivec4(10624,123,64,64),\nivec4(10624,123,67,96),\nivec4(10752,369,53,85),\nivec4(10752,1014,65,96),\nivec4(11008,123,57,64),\nivec4(11008,123,60,64),\nivec4(11008,123,65,64),\nivec4(11136,369,53,84),\nivec4(11392,123,58,64),\nivec4(11392,123,62,64),\nivec4(11392,123,65,64),\nivec4(11520,738,53,84),\nivec4(11776,497,57,62),\nivec4(11776,497,60,62),\nivec4(11776,497,65,62),\nivec4(12160,123,72,87),\nivec4(12288,246,72,99),\nivec4(12288,369,43,82),\nivec4(12544,123,58,64),\nivec4(12544,123,60,64),\nivec4(12544,123,64,64),\nivec4(12544,123,71,95),\nivec4(12672,246,70,96),\nivec4(12672,369,48,86),\nivec4(12928,123,58,64),\nivec4(12928,123,60,64),\nivec4(12928,123,64,64),\nivec4(12928,123,67,95),\nivec4(13056,123,62,91),\nivec4(13056,369,43,80),\nivec4(13184,123,64,102),\nivec4(13312,123,58,64),\nivec4(13312,123,60,64),\nivec4(13312,123,64,64),\nivec4(13312,123,65,101),\nivec4(13440,246,64,94),\nivec4(13440,369,48,87),\nivec4(13696,123,58,66),\nivec4(13696,123,60,66),\nivec4(13696,123,64,66),\nivec4(13696,123,69,103),\nivec4(13824,246,67,96),\nivec4(13824,369,41,82),\nivec4(14080,123,57,61),\nivec4(14080,123,60,61),\nivec4(14080,123,65,61),\nivec4(14080,123,65,94),\nivec4(14208,246,64,97),\nivec4(14208,369,48,88),\nivec4(14464,123,57,64),\nivec4(14464,123,60,64),\nivec4(14464,123,65,64),\nivec4(14464,123,65,100),\nivec4(14592,369,41,82),\nivec4(14592,630,72,107),\nivec4(14848,123,57,65),\nivec4(14848,123,60,65),\nivec4(14848,123,65,65),\nivec4(14976,369,48,87),\nivec4(15232,123,57,65),\nivec4(15232,123,60,65),\nivec4(15232,123,65,65),\nivec4(15232,123,65,91),\nivec4(15360,246,65,99),\nivec4(15360,369,43,79),\nivec4(15616,123,58,65),\nivec4(15616,123,60,65),\nivec4(15616,123,64,65),\nivec4(15616,123,64,94),\nivec4(15744,246,63,96),\nivec4(15744,369,48,86),\nivec4(16000,123,58,66),\nivec4(16000,123,60,66),\nivec4(16000,123,64,66),\nivec4(16000,123,64,101),\nivec4(16128,369,43,81),\nivec4(16128,630,72,107),\nivec4(16384,123,58,63),\nivec4(16384,123,60,63),\nivec4(16384,123,64,63),\nivec4(16512,369,48,87),\nivec4(16768,123,58,63),\nivec4(16768,123,60,63),\nivec4(16768,123,64,63),\nivec4(16768,123,67,91),\nivec4(16896,246,67,96),\nivec4(16896,369,41,80),\nivec4(17152,123,57,65),\nivec4(17152,123,60,65),\nivec4(17152,123,65,65),\nivec4(17152,123,65,92),\nivec4(17280,246,64,95),\nivec4(17280,369,48,87),\nivec4(17536,123,57,64),\nivec4(17536,123,60,64),\nivec4(17536,123,65,64),\nivec4(17536,123,65,101),\nivec4(17664,369,41,80),\nivec4(17664,630,72,105),\nivec4(17920,123,57,63),\nivec4(17920,123,60,63),\nivec4(17920,123,65,63),\nivec4(18048,369,48,88),\nivec4(18304,123,57,63),\nivec4(18304,123,60,63),\nivec4(18304,123,65,63),\nivec4(18304,123,72,98),\nivec4(18432,246,72,97),\nivec4(18432,369,43,82),\nivec4(18688,123,58,63),\nivec4(18688,123,60,63),\nivec4(18688,123,64,63),\nivec4(18688,123,71,95),\nivec4(18816,246,70,97),\nivec4(18816,369,48,83),\nivec4(19072,123,58,64),\nivec4(19072,123,60,64),\nivec4(19072,123,64,64),\nivec4(19072,123,67,96),\nivec4(19200,123,62,90),\nivec4(19200,369,43,82),\nivec4(19328,123,64,99),\nivec4(19456,123,58,64),\nivec4(19456,123,60,64),\nivec4(19456,123,64,64),\nivec4(19456,123,65,100),\nivec4(19584,246,64,95),\nivec4(19584,369,48,88),\nivec4(19840,123,58,62),\nivec4(19840,123,60,62),\nivec4(19840,123,64,62),\nivec4(19840,123,69,103),\nivec4(19968,246,67,95),\nivec4(19968,369,41,81),\nivec4(20224,123,57,61),\nivec4(20224,123,60,61),\nivec4(20224,123,65,61),\nivec4(20224,123,65,94),\nivec4(20352,246,64,96),\nivec4(20352,369,48,87),\nivec4(20608,123,57,63),\nivec4(20608,123,60,63),\nivec4(20608,123,65,63),\nivec4(20608,123,65,99),\nivec4(20736,369,41,83),\nivec4(20736,630,72,105),\nivec4(20992,497,57,65),\nivec4(20992,497,60,65),\nivec4(20992,497,65,65),\nivec4(21120,369,53,92),\nivec4(21376,62,69,94),\nivec4(21440,62,71,101),\nivec4(21504,246,50,82),\nivec4(21504,246,57,73),\nivec4(21504,246,60,73),\nivec4(21504,246,66,73),\nivec4(21504,246,72,100),\nivec4(21760,123,50,83),\nivec4(21760,123,57,72),\nivec4(21760,123,60,72),\nivec4(21760,123,66,72),\nivec4(21760,123,69,93),\nivec4(21888,246,72,101),\nivec4(21888,369,50,84),\nivec4(21888,369,57,69),\nivec4(21888,369,60,69),\nivec4(21888,369,66,69),\nivec4(22144,62,69,93),\nivec4(22208,62,71,101),\nivec4(22272,246,50,83),\nivec4(22272,246,57,71),\nivec4(22272,246,60,71),\nivec4(22272,246,66,71),\nivec4(22272,246,72,101),\nivec4(22528,123,50,84),\nivec4(22528,123,57,71),\nivec4(22528,123,60,71),\nivec4(22528,123,66,71),\nivec4(22528,123,69,94),\nivec4(22656,246,72,102),\nivec4(22656,369,50,85),\nivec4(22656,369,57,71),\nivec4(22656,369,60,71),\nivec4(22656,369,66,71),\nivec4(22912,62,71,98),\nivec4(22976,62,69,97),\nivec4(23040,246,43,80),\nivec4(23040,246,59,73),\nivec4(23040,246,65,73),\nivec4(23040,246,67,73),\nivec4(23040,246,67,95),\nivec4(23296,123,43,86),\nivec4(23296,123,59,73),\nivec4(23296,123,65,73),\nivec4(23296,123,67,73),\nivec4(23296,123,67,98),\nivec4(23424,246,69,100),\nivec4(23424,369,43,83),\nivec4(23424,369,59,70),\nivec4(23424,369,65,70),\nivec4(23424,369,67,70),\nivec4(23680,123,67,93),\nivec4(23808,369,48,89),\nivec4(23808,369,64,75),\nivec4(23808,369,67,75),\nivec4(23808,369,72,75),\nivec4(23808,369,72,103),\nivec4(24192,246,48,85),\nivec4(24192,246,64,73),\nivec4(24192,246,70,73),\nivec4(24192,246,72,73),\nivec4(24192,246,72,99),\nivec4(24448,123,48,83),\nivec4(24448,123,64,72),\nivec4(24448,123,70,72),\nivec4(24448,123,73,72),\nivec4(24448,123,73,101),\nivec4(24576,246,62,69),\nivec4(24576,369,53,86),\nivec4(24576,369,74,75),\nivec4(24576,369,74,98),\nivec4(24832,123,65,82),\nivec4(24832,123,69,82),\nivec4(24960,246,60,70),\nivec4(24960,246,72,68),\nivec4(24960,246,72,94),\nivec4(24960,369,48,80),\nivec4(25216,123,65,81),\nivec4(25216,123,69,70),\nivec4(25216,123,69,96),\nivec4(25344,246,60,72),\nivec4(25344,246,67,69),\nivec4(25344,246,67,96),\nivec4(25344,369,45,81),\nivec4(25600,123,62,78),\nivec4(25600,123,65,68),\nivec4(25600,123,65,95),\nivec4(25728,246,60,74),\nivec4(25728,246,64,69),\nivec4(25728,246,64,94),\nivec4(25728,369,44,84),\nivec4(25984,123,62,78),\nivec4(25984,123,65,72),\nivec4(25984,123,65,100),\nivec4(26112,246,60,76),\nivec4(26112,369,43,84),\nivec4(26112,369,72,78),\nivec4(26112,369,72,107),\nivec4(26368,123,64,86),\nivec4(26368,123,70,86),\nivec4(26496,246,60,67),\nivec4(26496,369,42,83),\nivec4(26496,630,72,101),\nivec4(26496,753,72,71),\nivec4(26752,123,66,83),\nivec4(26752,123,69,83),\nivec4(26880,246,60,70),\nivec4(26880,369,43,86),\nivec4(27136,123,67,86),\nivec4(27136,123,70,86),\nivec4(27264,246,60,66),\nivec4(27264,369,48,87),\nivec4(27264,369,72,71),\nivec4(27264,369,72,87),\nivec4(27520,123,64,84),\nivec4(27520,123,70,84),\nivec4(27648,246,62,70),\nivec4(27648,369,53,87),\nivec4(27648,369,74,74),\nivec4(27648,369,74,99),\nivec4(27904,123,65,80),\nivec4(27904,123,69,80),\nivec4(28032,246,60,69),\nivec4(28032,246,72,68),\nivec4(28032,246,72,96),\nivec4(28032,369,48,79),\nivec4(28288,123,65,81),\nivec4(28288,123,69,71),\nivec4(28288,123,69,91),\nivec4(28416,246,57,72),\nivec4(28416,246,67,69),\nivec4(28416,246,67,95),\nivec4(28416,369,53,85),\nivec4(28672,123,62,80),\nivec4(28672,123,65,68),\nivec4(28672,123,65,95),\nivec4(28800,246,56,75),\nivec4(28800,246,64,70),\nivec4(28800,246,64,94),\nivec4(28800,369,45,81),\nivec4(29056,123,62,82),\nivec4(29056,123,65,72),\nivec4(29056,123,65,103),\nivec4(29184,246,62,78),\nivec4(29184,369,46,86),\nivec4(29184,1014,74,107),\nivec4(29184,1137,74,79),\nivec4(29440,123,65,82),\nivec4(29440,123,70,82),\nivec4(29568,246,62,69),\nivec4(29568,369,45,85),\nivec4(29824,123,66,83),\nivec4(29824,123,69,83),\nivec4(29952,246,62,69),\nivec4(29952,369,43,82),\nivec4(30208,123,67,82),\nivec4(30208,123,70,82),\nivec4(30336,246,62,71),\nivec4(30336,369,55,88),\nivec4(30336,369,74,71),\nivec4(30336,369,74,89),\nivec4(30592,123,67,82),\nivec4(30592,123,70,82),\nivec4(30720,246,64,71),\nivec4(30720,369,52,83),\nivec4(30720,369,76,71),\nivec4(30720,369,76,100),\nivec4(30976,123,67,82),\nivec4(30976,123,72,82),\nivec4(31104,246,64,71),\nivec4(31104,246,74,71),\nivec4(31104,246,74,97),\nivec4(31104,369,48,82),\nivec4(31360,123,67,78),\nivec4(31360,123,70,67),\nivec4(31360,123,70,93),\nivec4(31488,246,60,69),\nivec4(31488,246,69,70),\nivec4(31488,246,69,95),\nivec4(31488,369,52,88),\nivec4(31744,123,64,79),\nivec4(31744,123,67,70),\nivec4(31744,123,67,95),\nivec4(31872,246,60,73),\nivec4(31872,246,66,71),\nivec4(31872,246,66,94),\nivec4(31872,369,48,83),\nivec4(32128,123,64,82),\nivec4(32128,123,67,72),\nivec4(32128,123,67,101),\nivec4(32256,246,62,73),\nivec4(32256,369,53,85),\nivec4(32256,369,74,75),\nivec4(32256,369,74,105),\nivec4(32512,123,65,87),\nivec4(32512,123,69,87),\nivec4(32640,246,60,70),\nivec4(32640,369,45,80),\nivec4(32640,369,72,68),\nivec4(32640,369,72,98),\nivec4(32896,123,65,85),\nivec4(32896,123,69,85),\nivec4(33024,246,58,71),\nivec4(33024,369,50,88),\nivec4(33024,369,70,71),\nivec4(33024,369,70,91),\nivec4(33280,123,62,84),\nivec4(33280,123,66,84),\nivec4(33408,246,57,72),\nivec4(33408,246,69,72),\nivec4(33408,246,69,97),\nivec4(33408,369,48,81),\nivec4(33664,123,62,79),\nivec4(33664,123,66,68),\nivec4(33664,123,66,94),\nivec4(33792,246,59,73),\nivec4(33792,369,47,84),\nivec4(33792,369,69,74),\nivec4(33792,369,69,101),\nivec4(34048,123,62,84),\nivec4(34048,123,65,84),\nivec4(34176,246,59,75),\nivec4(34176,369,43,82),\nivec4(34176,369,67,71),\nivec4(34176,369,67,97),\nivec4(34432,123,62,80),\nivec4(34432,123,65,80),\nivec4(34560,246,59,73),\nivec4(34560,369,50,85),\nivec4(34560,369,69,75),\nivec4(34560,369,69,102),\nivec4(34816,123,62,84),\nivec4(34816,123,65,84),\nivec4(34944,123,67,69),\nivec4(34944,123,67,97),\nivec4(34944,246,59,72),\nivec4(34944,369,43,80),\nivec4(35072,123,66,71),\nivec4(35072,123,66,97),\nivec4(35200,123,62,77),\nivec4(35200,123,67,72),\nivec4(35200,123,67,100),\nivec4(35328,246,57,73),\nivec4(35328,369,48,86),\nivec4(35328,369,69,75),\nivec4(35328,369,69,101),\nivec4(35584,123,60,84),\nivec4(35584,123,64,84),\nivec4(35712,246,55,73),\nivec4(35712,369,46,84),\nivec4(35712,369,67,69),\nivec4(35712,369,67,96),\nivec4(35968,123,60,85),\nivec4(35968,123,64,85),\nivec4(36096,246,58,76),\nivec4(36096,369,43,82),\nivec4(36096,369,64,69),\nivec4(36096,369,64,93),\nivec4(36352,123,60,79),\nivec4(36480,246,60,77),\nivec4(36480,369,48,87),\nivec4(36480,369,72,80),\nivec4(36480,369,72,109),\nivec4(36736,123,67,84),\nivec4(36736,123,70,84),\nivec4(36864,246,62,70),\nivec4(36864,369,53,87),\nivec4(36864,369,74,76),\nivec4(36864,369,74,102),\nivec4(37120,123,65,81),\nivec4(37120,123,69,81),\nivec4(37248,246,60,71),\nivec4(37248,246,72,68),\nivec4(37248,246,72,95),\nivec4(37248,369,48,83),\nivec4(37504,123,65,80),\nivec4(37504,123,69,68),\nivec4(37504,123,69,93),\nivec4(37632,246,60,72),\nivec4(37632,246,67,68),\nivec4(37632,246,67,95),\nivec4(37632,369,45,80),\nivec4(37888,123,62,78),\nivec4(37888,123,65,69),\nivec4(37888,123,65,95),\nivec4(38016,246,60,73),\nivec4(38016,246,64,68),\nivec4(38016,246,64,95),\nivec4(38016,369,44,83),\nivec4(38272,123,62,79),\nivec4(38272,123,65,72),\nivec4(38272,123,65,100),\nivec4(38400,246,60,73),\nivec4(38400,369,43,83),\nivec4(38400,369,72,77),\nivec4(38400,369,72,103),\nivec4(38656,123,64,87),\nivec4(38656,123,70,87),\nivec4(38784,246,60,69),\nivec4(38784,369,42,81),\nivec4(38784,630,72,100),\nivec4(38784,1122,72,69),\nivec4(39040,123,66,84),\nivec4(39040,123,69,84),\nivec4(39168,246,60,68),\nivec4(39168,369,43,81),\nivec4(39424,123,67,84),\nivec4(39424,123,70,84),\nivec4(39552,246,60,68),\nivec4(39552,369,48,86),\nivec4(39808,123,64,87),\nivec4(39808,123,70,87),\nivec4(39936,246,62,71),\nivec4(39936,369,53,87),\nivec4(39936,369,74,73),\nivec4(39936,369,74,89),\nivec4(40192,123,65,83),\nivec4(40192,123,69,83),\nivec4(40320,246,60,68),\nivec4(40320,246,72,67),\nivec4(40320,246,72,94),\nivec4(40320,369,48,79),\nivec4(40576,123,65,79),\nivec4(40576,123,69,68),\nivec4(40576,123,69,96),\nivec4(40704,246,57,72),\nivec4(40704,246,67,69),\nivec4(40704,246,67,94),\nivec4(40704,369,53,89),\nivec4(40960,123,62,80),\nivec4(40960,123,65,69),\nivec4(40960,123,65,96),\nivec4(41088,246,56,73),\nivec4(41088,246,64,71),\nivec4(41088,246,64,95),\nivec4(41088,369,45,80),\nivec4(41344,123,62,82),\nivec4(41344,123,65,72),\nivec4(41344,123,65,100),\nivec4(41472,246,62,75),\nivec4(41472,369,46,85),\nivec4(41472,1014,74,109),\nivec4(41472,1137,74,78),\nivec4(41728,123,67,85),\nivec4(41728,123,70,85),\nivec4(41856,246,62,67),\nivec4(41856,369,45,84),\nivec4(42112,123,66,83),\nivec4(42112,123,69,83),\nivec4(42240,246,62,71),\nivec4(42240,369,43,82),\nivec4(42496,123,67,84),\nivec4(42496,123,70,84),\nivec4(42624,246,65,72),\nivec4(42624,246,73,71),\nivec4(42624,246,73,87),\nivec4(42624,369,53,89),\nivec4(42880,123,69,78),\nivec4(42880,123,74,73),\nivec4(42880,123,74,99),\nivec4(43008,246,68,75),\nivec4(43008,246,76,73),\nivec4(43008,246,76,101),\nivec4(43008,369,52,82),\nivec4(43264,123,71,78),\nivec4(43264,123,75,69),\nivec4(43264,123,75,97),\nivec4(43392,246,64,66),\nivec4(43392,246,76,73),\nivec4(43392,246,76,97),\nivec4(43392,369,50,81),\nivec4(43648,123,71,82),\nivec4(43648,123,75,68),\nivec4(43648,123,75,96),\nivec4(43776,246,64,70),\nivec4(43776,369,48,79),\nivec4(43776,369,76,73),\nivec4(43776,369,76,100),\nivec4(44032,123,68,83),\nivec4(44032,123,71,83),\nivec4(44160,246,64,73),\nivec4(44160,246,74,68),\nivec4(44160,246,74,95),\nivec4(44160,369,47,85),\nivec4(44416,123,68,81),\nivec4(44416,123,71,66),\nivec4(44416,123,71,94),\nivec4(44544,246,65,72),\nivec4(44544,246,74,73),\nivec4(44544,246,74,102),\nivec4(44544,369,45,82),\nivec4(44800,123,69,81),\nivec4(44800,123,72,69),\nivec4(44800,123,72,96),\nivec4(44928,246,65,73),\nivec4(44928,246,74,72),\nivec4(44928,246,74,102),\nivec4(44928,369,43,82),\nivec4(45184,123,69,80),\nivec4(45184,123,72,71),\nivec4(45184,123,72,96),\nivec4(45312,246,66,76),\nivec4(45312,246,74,74),\nivec4(45312,246,74,101),\nivec4(45312,369,42,83),\nivec4(45568,123,69,79),\nivec4(45568,123,72,67),\nivec4(45568,123,72,94),\nivec4(45696,246,62,71),\nivec4(45696,246,70,69),\nivec4(45696,246,70,96),\nivec4(45696,369,50,88),\nivec4(45952,123,66,80),\nivec4(45952,123,69,69),\nivec4(45952,123,69,97),\nivec4(46080,369,46,83),\nivec4(46080,369,62,74),\nivec4(46080,369,67,70),\nivec4(46080,369,67,93),\nivec4(46464,369,55,88),\nivec4(46464,369,70,87),\nivec4(46464,369,74,78),\nivec4(46464,369,74,108),\nivec4(46848,246,60,69),\nivec4(46848,369,48,81),\nivec4(47104,123,64,79),\nivec4(47104,123,69,64),\nivec4(47104,123,69,87),\nivec4(47232,246,60,72),\nivec4(47232,246,67,67),\nivec4(47232,246,67,93),\nivec4(47232,369,48,83),\nivec4(47488,123,64,80),\nivec4(47488,123,69,74),\nivec4(47488,123,69,100),\nivec4(47616,369,53,88),\nivec4(47616,1014,65,91),\nivec4(47616,1137,57,73),\nivec4(47616,1137,65,66),\nivec4(48000,369,48,80),\nivec4(48384,369,41,80),\nivec4(48768,246,48,88),\nivec4(48768,246,64,80),\nivec4(48768,246,70,80),\nivec4(48768,246,72,80),\nivec4(48768,246,72,88),\nivec4(49024,123,48,86),\nivec4(49024,123,64,73),\nivec4(49024,123,70,73),\nivec4(49024,123,73,73),\nivec4(49024,123,73,100),\nivec4(49152,246,62,82),\nivec4(49152,369,53,86),\nivec4(49152,369,74,73),\nivec4(49152,369,74,99),\nivec4(49408,123,65,83),\nivec4(49408,123,69,83),\nivec4(49536,246,60,67),\nivec4(49536,246,72,67),\nivec4(49536,246,72,94),\nivec4(49536,369,48,82),\nivec4(49792,123,65,82),\nivec4(49792,123,69,66),\nivec4(49792,123,69,95),\nivec4(49920,246,60,73),\nivec4(49920,246,67,71),\nivec4(49920,246,67,96),\nivec4(49920,369,45,85),\nivec4(50176,123,62,78),\nivec4(50176,123,65,69),\nivec4(50176,123,65,94),\nivec4(50304,246,60,75),\nivec4(50304,246,64,69),\nivec4(50304,246,64,95),\nivec4(50304,369,44,83),\nivec4(50560,123,62,76),\nivec4(50560,123,65,71),\nivec4(50560,123,65,100),\nivec4(50688,246,60,75),\nivec4(50688,369,43,83),\nivec4(50688,369,72,78),\nivec4(50688,369,72,105),\nivec4(50944,123,64,83),\nivec4(50944,123,70,83),\nivec4(51072,246,60,67),\nivec4(51072,369,42,83),\nivec4(51072,630,72,98),\nivec4(51072,753,72,73),\nivec4(51328,123,66,85),\nivec4(51328,123,69,85),\nivec4(51456,246,60,67),\nivec4(51456,369,43,84),\nivec4(51712,123,67,85),\nivec4(51712,123,70,85),\nivec4(51840,246,60,69),\nivec4(51840,369,48,85),\nivec4(51840,369,72,71),\nivec4(51840,369,72,88),\nivec4(52096,123,64,87),\nivec4(52096,123,70,87),\nivec4(52224,246,62,68),\nivec4(52224,369,53,88),\nivec4(52224,369,74,73),\nivec4(52224,369,74,100),\nivec4(52480,123,65,84),\nivec4(52480,123,69,84),\nivec4(52608,246,60,68),\nivec4(52608,246,72,68),\nivec4(52608,246,72,94),\nivec4(52608,369,48,80),\nivec4(52864,123,65,80),\nivec4(52864,123,69,66),\nivec4(52864,123,69,92),\nivec4(52992,246,57,72),\nivec4(52992,246,67,71),\nivec4(52992,246,67,96),\nivec4(52992,369,53,86),\nivec4(53248,123,62,82),\nivec4(53248,123,65,69),\nivec4(53248,123,65,97),\nivec4(53376,246,56,74),\nivec4(53376,246,64,69),\nivec4(53376,246,64,95),\nivec4(53376,369,45,81),\nivec4(53632,123,62,82),\nivec4(53632,123,65,74),\nivec4(53632,123,65,99),\nivec4(53760,246,62,76),\nivec4(53760,369,46,85),\nivec4(53760,1014,74,107),\nivec4(53760,1137,74,79),\nivec4(54016,123,65,82),\nivec4(54016,123,70,82),\nivec4(54144,246,62,72),\nivec4(54144,369,45,83),\nivec4(54400,123,66,82),\nivec4(54400,123,69,82),\nivec4(54528,246,62,69),\nivec4(54528,369,43,83),\nivec4(54784,123,67,83),\nivec4(54784,123,70,83),\nivec4(54912,246,62,68),\nivec4(54912,369,55,88),\nivec4(54912,369,74,71),\nivec4(54912,369,74,89),\nivec4(55168,123,67,82),\nivec4(55168,123,70,82),\nivec4(55296,246,64,71),\nivec4(55296,369,52,85),\nivec4(55296,369,76,74),\nivec4(55296,369,76,100),\nivec4(55552,123,67,82),\nivec4(55552,123,72,82),\nivec4(55680,246,64,71),\nivec4(55680,246,74,69),\nivec4(55680,246,74,95),\nivec4(55680,369,48,82),\nivec4(55936,123,67,79),\nivec4(55936,123,70,65),\nivec4(55936,123,70,94),\nivec4(56064,246,60,71),\nivec4(56064,246,69,69),\nivec4(56064,246,69,94),\nivec4(56064,369,52,87),\nivec4(56320,123,64,81),\nivec4(56320,123,67,70),\nivec4(56320,123,67,94),\nivec4(56448,246,60,73),\nivec4(56448,246,66,71),\nivec4(56448,246,66,96),\nivec4(56448,369,48,81),\nivec4(56704,123,64,80),\nivec4(56704,123,67,74),\nivec4(56704,123,67,104),\nivec4(56832,246,62,73),\nivec4(56832,369,53,87),\nivec4(56832,369,74,78),\nivec4(56832,369,74,108),\nivec4(57088,123,65,83),\nivec4(57088,123,69,83),\nivec4(57216,246,60,69),\nivec4(57216,369,45,83),\nivec4(57216,369,72,70),\nivec4(57216,369,72,97),\nivec4(57472,123,65,84),\nivec4(57472,123,69,84),\nivec4(57600,246,58,72),\nivec4(57600,369,50,88),\nivec4(57600,369,70,67),\nivec4(57600,369,70,95),\nivec4(57856,123,62,84),\nivec4(57856,123,66,84),\nivec4(57984,246,57,72),\nivec4(57984,246,69,70),\nivec4(57984,246,69,95),\nivec4(57984,369,48,81),\nivec4(58240,123,62,84),\nivec4(58240,123,66,69),\nivec4(58240,123,66,95),\nivec4(58368,246,59,75),\nivec4(58368,369,47,84),\nivec4(58368,369,69,70),\nivec4(58368,369,69,104),\nivec4(58624,123,62,82),\nivec4(58624,123,65,82),\nivec4(58752,246,59,74),\nivec4(58752,369,43,82),\nivec4(58752,369,67,70),\nivec4(58752,369,67,94),\nivec4(59008,123,62,82),\nivec4(59008,123,65,82),\nivec4(59136,246,59,73),\nivec4(59136,369,50,87),\nivec4(59136,369,69,72),\nivec4(59136,369,69,100),\nivec4(59392,123,62,84),\nivec4(59392,123,65,84),\nivec4(59520,123,67,69),\nivec4(59520,123,67,96),\nivec4(59520,246,59,73),\nivec4(59520,369,43,79),\nivec4(59648,123,66,69),\nivec4(59648,123,66,97),\nivec4(59776,123,62,80),\nivec4(59776,123,67,75),\nivec4(59776,123,67,100),\nivec4(59904,246,57,74),\nivec4(59904,369,48,89),\nivec4(59904,369,69,74),\nivec4(59904,369,69,101),\nivec4(60160,123,60,85),\nivec4(60160,123,64,85),\nivec4(60288,246,55,73),\nivec4(60288,369,46,83),\nivec4(60288,369,67,71),\nivec4(60288,369,67,98),\nivec4(60544,123,60,85),\nivec4(60544,123,64,85),\nivec4(60672,246,58,73),\nivec4(60672,369,43,84),\nivec4(60672,369,64,67),\nivec4(60672,369,64,93),\nivec4(60928,123,60,79),\nivec4(61056,246,60,79),\nivec4(61056,369,48,85),\nivec4(61056,369,72,80),\nivec4(61056,369,72,107),\nivec4(61312,123,67,84),\nivec4(61312,123,70,84),\nivec4(61440,246,62,70),\nivec4(61440,369,53,86),\nivec4(61440,369,74,73),\nivec4(61440,369,74,101),\nivec4(61696,123,65,83),\nivec4(61696,123,69,83),\nivec4(61824,246,60,69),\nivec4(61824,246,72,70),\nivec4(61824,246,72,96),\nivec4(61824,369,48,80),\nivec4(62080,123,65,78),\nivec4(62080,123,69,67),\nivec4(62080,123,69,93),\nivec4(62208,246,60,71),\nivec4(62208,246,67,69),\nivec4(62208,246,67,95),\nivec4(62208,369,45,83),\nivec4(62464,123,62,79),\nivec4(62464,123,65,66),\nivec4(62464,123,65,95),\nivec4(62592,246,60,73),\nivec4(62592,246,64,68),\nivec4(62592,246,64,95),\nivec4(62592,369,44,82),\nivec4(62848,123,62,79),\nivec4(62848,123,65,72),\nivec4(62848,123,65,101),\nivec4(62976,246,60,73),\nivec4(62976,369,43,84),\nivec4(62976,369,72,80),\nivec4(62976,369,72,106),\nivec4(63232,123,64,84),\nivec4(63232,123,70,84),\nivec4(63360,246,60,68),\nivec4(63360,369,42,83),\nivec4(63360,630,72,97),\nivec4(63360,1122,72,72),\nivec4(63616,123,66,83),\nivec4(63616,123,69,83),\nivec4(63744,246,60,68),\nivec4(63744,369,43,87),\nivec4(64000,123,67,87),\nivec4(64000,123,70,87),\nivec4(64128,246,60,70),\nivec4(64128,369,48,87),\nivec4(64384,123,64,85),\nivec4(64384,123,70,85),\nivec4(64512,246,62,68),\nivec4(64512,369,53,87),\nivec4(64512,369,74,70),\nivec4(64512,369,74,86),\nivec4(64768,123,65,83),\nivec4(64768,123,69,83),\nivec4(64896,246,60,66),\nivec4(64896,246,72,67),\nivec4(64896,246,72,95),\nivec4(64896,369,48,81),\nivec4(65152,123,65,80),\nivec4(65152,123,69,68),\nivec4(65152,123,69,94),\nivec4(65280,246,57,73),\nivec4(65280,246,67,67),\nivec4(65280,246,67,94),\nivec4(65280,369,53,86),\nivec4(65536,123,62,83),\nivec4(65536,123,65,69),\nivec4(65536,123,65,95),\nivec4(65664,246,56,76),\nivec4(65664,246,64,70),\nivec4(65664,246,64,95),\nivec4(65664,369,45,82),\nivec4(65920,123,62,83),\nivec4(65920,123,65,72),\nivec4(65920,123,65,101),\nivec4(66048,246,62,75),\nivec4(66048,369,46,85),\nivec4(66048,1014,74,110),\nivec4(66048,1137,74,79),\nivec4(66304,123,67,82),\nivec4(66304,123,70,82),\nivec4(66432,246,62,70),\nivec4(66432,369,45,84),\nivec4(66688,123,66,82),\nivec4(66688,123,69,82),\nivec4(66816,246,62,71),\nivec4(66816,369,43,82),\nivec4(67072,123,67,85),\nivec4(67072,123,70,85),\nivec4(67200,246,65,71),\nivec4(67200,246,73,71),\nivec4(67200,246,73,89),\nivec4(67200,369,53,89),\nivec4(67456,123,69,80),\nivec4(67456,123,74,74),\nivec4(67456,123,74,99),\nivec4(67584,246,68,76),\nivec4(67584,246,76,73),\nivec4(67584,246,76,100),\nivec4(67584,369,52,83),\nivec4(67840,123,71,81),\nivec4(67840,123,75,67),\nivec4(67840,123,75,96),\nivec4(67968,246,64,70),\nivec4(67968,246,76,72),\nivec4(67968,246,76,99),\nivec4(67968,369,50,81),\nivec4(68224,123,71,80),\nivec4(68224,123,75,71),\nivec4(68224,123,75,96),\nivec4(68352,246,64,72),\nivec4(68352,369,48,81),\nivec4(68352,369,76,72),\nivec4(68352,369,76,100),\nivec4(68608,123,68,80),\nivec4(68608,123,71,80),\nivec4(68736,246,64,69),\nivec4(68736,246,74,70),\nivec4(68736,246,74,96),\nivec4(68736,369,47,84),\nivec4(68992,123,68,83),\nivec4(68992,123,71,67),\nivec4(68992,123,71,95),\nivec4(69120,246,65,73),\nivec4(69120,246,74,75),\nivec4(69120,246,74,101),\nivec4(69120,369,45,83),\nivec4(69376,123,69,81),\nivec4(69376,123,72,69),\nivec4(69376,123,72,95),\nivec4(69504,246,65,73),\nivec4(69504,246,74,74),\nivec4(69504,246,74,101),\nivec4(69504,369,43,84),\nivec4(69760,123,69,80),\nivec4(69760,123,72,69),\nivec4(69760,123,72,94),\nivec4(69888,246,66,72),\nivec4(69888,246,74,72),\nivec4(69888,246,74,99),\nivec4(69888,369,42,82),\nivec4(70144,123,69,80),\nivec4(70144,123,72,66),\nivec4(70144,123,72,94),\nivec4(70272,246,62,68),\nivec4(70272,246,70,70),\nivec4(70272,246,70,95),\nivec4(70272,369,50,88),\nivec4(70528,123,66,80),\nivec4(70528,123,69,68),\nivec4(70528,123,69,95),\nivec4(70656,369,46,80),\nivec4(70656,369,62,71),\nivec4(70656,369,67,71),\nivec4(70656,369,67,94),\nivec4(71040,369,55,88),\nivec4(71040,369,70,83),\nivec4(71040,369,74,79),\nivec4(71040,369,74,106),\nivec4(71424,246,60,69),\nivec4(71424,369,48,80),\nivec4(71680,123,64,81),\nivec4(71680,123,69,63),\nivec4(71680,123,69,87),\nivec4(71808,246,60,69),\nivec4(71808,246,67,67),\nivec4(71808,246,67,93),\nivec4(71808,369,48,84),\nivec4(72064,123,64,82),\nivec4(72064,123,69,72),\nivec4(72064,123,69,99),\nivec4(72192,369,53,86),\nivec4(72192,1014,65,91),\nivec4(72192,1506,57,73),\nivec4(72192,1506,65,69),\nivec4(72576,369,48,82),\nivec4(72960,738,41,78));\n#endif\n#elif TUNE == 5\nfloat speed = 0.9;\nconst ivec4 data[] = ivec4[](\nivec4(1680,239,47,49),\nivec4(1680,239,47,96),\nivec4(1680,239,71,49),\nivec4(1680,239,75,49),\nivec4(1680,239,78,49),\nivec4(1920,119,52,96),\nivec4(1920,479,52,49),\nivec4(1920,479,71,49),\nivec4(1920,479,76,49),\nivec4(1920,479,79,49),\nivec4(2040,119,55,96),\nivec4(2160,119,54,96),\nivec4(2280,119,52,96),\nivec4(2400,119,59,96),\nivec4(2400,479,40,49),\nivec4(2400,479,71,49),\nivec4(2400,479,76,49),\nivec4(2400,479,79,49),\nivec4(2520,119,55,96),\nivec4(2640,119,54,96),\nivec4(2760,119,52,96),\nivec4(2880,239,47,96),\nivec4(2880,479,47,49),\nivec4(2880,479,71,49),\nivec4(2880,479,75,49),\nivec4(2880,479,78,49),\nivec4(3120,239,60,96),\nivec4(3360,119,59,96),\nivec4(3360,479,51,49),\nivec4(3360,479,66,49),\nivec4(3360,479,71,49),\nivec4(3360,479,78,49),\nivec4(3480,119,57,96),\nivec4(3600,119,55,96),\nivec4(3720,119,54,96),\nivec4(3840,119,52,96),\nivec4(3840,479,52,49),\nivec4(3840,479,67,49),\nivec4(3840,479,71,49),\nivec4(3840,479,76,49),\nivec4(3960,119,55,96),\nivec4(4080,119,54,96),\nivec4(4200,119,52,96),\nivec4(4320,119,59,96),\nivec4(4320,479,40,49),\nivec4(4320,479,67,49),\nivec4(4320,479,71,49),\nivec4(4320,479,76,49),\nivec4(4440,119,55,96),\nivec4(4560,119,54,96),\nivec4(4680,119,52,96),\nivec4(4800,239,47,96),\nivec4(4800,479,47,49),\nivec4(4800,479,66,49),\nivec4(4800,479,71,49),\nivec4(4800,479,75,49),\nivec4(5040,239,60,96),\nivec4(5280,119,59,96),\nivec4(5280,479,51,49),\nivec4(5280,479,66,49),\nivec4(5280,479,71,49),\nivec4(5400,119,57,96),\nivec4(5520,119,55,96),\nivec4(5640,119,54,96),\nivec4(5760,119,55,96),\nivec4(5760,239,52,49),\nivec4(5760,479,67,49),\nivec4(5760,479,71,49),\nivec4(5880,119,54,96),\nivec4(6000,239,52,96),\nivec4(6000,239,54,49),\nivec4(6240,239,55,49),\nivec4(6240,479,71,49),\nivec4(6480,239,52,49),\nivec4(6480,239,59,96),\nivec4(6720,239,44,96),\nivec4(6720,239,76,49),\nivec4(6720,479,44,49),\nivec4(6960,239,62,96),\nivec4(6960,239,71,49),\nivec4(7200,239,52,96),\nivec4(7200,239,68,49),\nivec4(7200,479,52,49),\nivec4(7440,239,62,96),\nivec4(7440,239,71,49),\nivec4(7680,239,60,96),\nivec4(7680,479,57,49),\nivec4(7680,479,69,49),\nivec4(7920,239,52,96),\nivec4(8160,239,45,96),\nivec4(8160,479,45,49),\nivec4(8160,479,72,49),\nivec4(8400,239,60,96),\nivec4(8640,239,42,96),\nivec4(8640,239,74,49),\nivec4(8640,479,42,49),\nivec4(8880,239,60,96),\nivec4(8880,239,69,49),\nivec4(9120,239,50,96),\nivec4(9120,239,66,49),\nivec4(9120,479,50,49),\nivec4(9360,239,60,96),\nivec4(9360,239,69,49),\nivec4(9600,239,59,96),\nivec4(9600,479,55,49),\nivec4(9600,479,67,49),\nivec4(9840,239,50,96),\nivec4(10080,239,43,96),\nivec4(10080,479,43,49),\nivec4(10080,479,71,49),\nivec4(10320,239,59,96),\nivec4(10560,239,42,96),\nivec4(10560,479,47,49),\nivec4(10560,479,63,49),\nivec4(10800,239,57,96),\nivec4(11040,239,51,96),\nivec4(11040,479,51,49),\nivec4(11040,479,66,49),\nivec4(11280,239,57,96),\nivec4(11520,239,55,96),\nivec4(11520,479,52,49),\nivec4(11520,959,67,49),\nivec4(11760,239,47,96),\nivec4(12000,239,40,96),\nivec4(12000,479,40,49),\nivec4(12240,239,55,96),\nivec4(12480,239,36,80),\nivec4(12480,479,45,33),\nivec4(12480,719,65,33),\nivec4(12720,239,53,80),\nivec4(12960,239,45,80),\nivec4(12960,479,45,33),\nivec4(13200,239,53,80),\nivec4(13200,239,72,33),\nivec4(13440,119,51,80),\nivec4(13440,239,47,33),\nivec4(13440,239,71,33),\nivec4(13560,119,60,80),\nivec4(13680,239,52,33),\nivec4(13680,239,67,33),\nivec4(13680,359,59,80),\nivec4(13920,239,55,33),\nivec4(13920,239,71,33),\nivec4(14040,119,60,80),\nivec4(14160,239,59,33),\nivec4(14160,239,76,33),\nivec4(14160,359,59,80),\nivec4(14400,239,51,33),\nivec4(14400,239,78,33),\nivec4(14520,119,57,80),\nivec4(14640,119,55,80),\nivec4(14640,239,47,33),\nivec4(14640,239,75,33),\nivec4(14760,119,54,80),\nivec4(14880,119,59,80),\nivec4(14880,239,51,33),\nivec4(14880,479,71,33),\nivec4(15000,119,57,80),\nivec4(15120,119,55,80),\nivec4(15120,239,47,33),\nivec4(15240,119,54,80),\nivec4(15360,239,52,49),\nivec4(15360,239,55,80),\nivec4(15360,239,67,49),\nivec4(15360,479,76,49),\nivec4(15600,119,43,49),\nivec4(15600,119,71,49),\nivec4(15600,239,52,80),\nivec4(15720,119,45,49),\nivec4(15720,119,72,49),\nivec4(15840,239,47,49),\nivec4(15840,239,47,80),\nivec4(15840,239,66,49),\nivec4(15840,239,71,49),\nivec4(15840,239,76,49),\nivec4(16080,239,47,49),\nivec4(16080,239,51,80),\nivec4(16080,239,66,49),\nivec4(16080,239,71,49),\nivec4(16080,239,75,49),\nivec4(16320,479,40,49),\nivec4(16320,479,40,80),\nivec4(16320,479,67,49),\nivec4(16320,479,71,49),\nivec4(16320,479,76,49),\nivec4(17040,239,47,49),\nivec4(17040,239,47,96),\nivec4(17040,239,71,49),\nivec4(17040,239,75,49),\nivec4(17040,239,78,49),\nivec4(17280,119,52,96),\nivec4(17280,479,52,49),\nivec4(17280,479,71,49),\nivec4(17280,479,76,49),\nivec4(17280,479,79,49),\nivec4(17400,119,55,96),\nivec4(17520,119,54,96),\nivec4(17640,119,52,96),\nivec4(17760,119,59,96),\nivec4(17760,479,40,49),\nivec4(17760,479,71,49),\nivec4(17760,479,76,49),\nivec4(17760,479,79,49),\nivec4(17880,119,55,96),\nivec4(18000,119,54,96),\nivec4(18120,119,52,96),\nivec4(18240,239,47,96),\nivec4(18240,479,47,49),\nivec4(18240,479,71,49),\nivec4(18240,479,75,49),\nivec4(18240,479,78,49),\nivec4(18480,239,60,96),\nivec4(18720,119,59,96),\nivec4(18720,479,51,49),\nivec4(18720,479,66,49),\nivec4(18720,479,71,49),\nivec4(18720,479,78,49),\nivec4(18840,119,57,96),\nivec4(18960,119,55,96),\nivec4(19080,119,54,96),\nivec4(19200,119,52,96),\nivec4(19200,479,52,49),\nivec4(19200,479,67,49),\nivec4(19200,479,71,49),\nivec4(19200,479,76,49),\nivec4(19320,119,55,96),\nivec4(19440,119,54,96),\nivec4(19560,119,52,96),\nivec4(19680,119,59,96),\nivec4(19680,479,40,49),\nivec4(19680,479,67,49),\nivec4(19680,479,71,49),\nivec4(19680,479,76,49),\nivec4(19800,119,55,96),\nivec4(19920,119,54,96),\nivec4(20040,119,52,96),\nivec4(20160,239,47,96),\nivec4(20160,479,47,49),\nivec4(20160,479,66,49),\nivec4(20160,479,71,49),\nivec4(20160,479,75,49),\nivec4(20400,239,60,96),\nivec4(20640,119,59,96),\nivec4(20640,479,51,49),\nivec4(20640,479,66,49),\nivec4(20640,479,71,49),\nivec4(20760,119,57,96),\nivec4(20880,119,55,96),\nivec4(21000,119,54,96),\nivec4(21120,239,52,49),\nivec4(21120,239,55,96),\nivec4(21120,719,67,49),\nivec4(21120,719,71,49),\nivec4(21360,239,52,96),\nivec4(21360,239,54,49),\nivec4(21600,239,55,49),\nivec4(21840,239,52,49),\nivec4(21840,239,55,96),\nivec4(21840,239,67,49),\nivec4(21840,239,73,49),\nivec4(22080,119,57,96),\nivec4(22080,239,66,49),\nivec4(22080,239,74,49),\nivec4(22080,479,50,49),\nivec4(22200,119,54,96),\nivec4(22320,119,50,96),\nivec4(22320,239,69,49),\nivec4(22440,119,54,96),\nivec4(22560,119,57,96),\nivec4(22560,239,74,49),\nivec4(22560,479,54,49),\nivec4(22680,119,60,96),\nivec4(22800,119,59,96),\nivec4(22800,239,72,49),\nivec4(22920,119,57,96),\nivec4(23040,119,59,96),\nivec4(23040,479,55,49),\nivec4(23040,479,71,49),\nivec4(23160,119,55,96),\nivec4(23280,119,43,96),\nivec4(23400,119,55,96),\nivec4(23520,119,59,96),\nivec4(23520,239,74,49),\nivec4(23520,479,43,49),\nivec4(23640,119,62,96),\nivec4(23760,119,60,96),\nivec4(23760,239,71,49),\nivec4(23880,119,59,96),\nivec4(24000,119,57,96),\nivec4(24000,479,54,49),\nivec4(24000,479,62,49),\nivec4(24120,119,54,96),\nivec4(24240,119,50,96),\nivec4(24360,119,54,96),\nivec4(24480,119,57,96),\nivec4(24480,239,66,49),\nivec4(24480,479,50,49),\nivec4(24600,119,60,96),\nivec4(24720,119,59,96),\nivec4(24720,239,69,49),\nivec4(24840,119,57,96),\nivec4(24960,119,59,96),\nivec4(24960,479,55,49),\nivec4(24960,719,71,49),\nivec4(25080,119,55,96),\nivec4(25200,119,43,96),\nivec4(25320,119,55,96),\nivec4(25440,119,59,96),\nivec4(25440,479,43,49),\nivec4(25560,119,62,96),\nivec4(25680,119,60,96),\nivec4(25680,479,67,49),\nivec4(25800,119,59,96),\nivec4(25920,59,59,96),\nivec4(25920,239,50,49),\nivec4(25980,59,60,96),\nivec4(26040,59,59,96),\nivec4(26100,59,60,96),\nivec4(26160,239,48,49),\nivec4(26160,239,57,96),\nivec4(26160,239,66,49),\nivec4(26400,239,47,49),\nivec4(26400,239,67,49),\nivec4(26640,239,43,49),\nivec4(26640,239,50,96),\nivec4(26640,239,71,49),\nivec4(26880,239,52,96),\nivec4(26880,479,48,49),\nivec4(26880,719,67,49),\nivec4(27120,479,60,96),\nivec4(27360,239,52,49),\nivec4(27600,239,48,49),\nivec4(27600,239,57,96),\nivec4(27600,239,64,49),\nivec4(27840,239,54,96),\nivec4(27840,479,50,49),\nivec4(27840,479,66,49),\nivec4(28080,479,62,96),\nivec4(28320,239,54,49),\nivec4(28320,239,69,49),\nivec4(28560,239,50,49),\nivec4(28560,239,59,96),\nivec4(28560,239,66,49),\nivec4(28800,239,55,96),\nivec4(28800,479,52,49),\nivec4(28800,479,67,49),\nivec4(29040,479,64,96),\nivec4(29280,239,55,49),\nivec4(29280,239,71,49),\nivec4(29520,239,52,49),\nivec4(29520,239,60,96),\nivec4(29520,239,67,49),\nivec4(29760,239,57,96),\nivec4(29760,479,50,49),\nivec4(29760,719,66,49),\nivec4(29760,719,72,49),\nivec4(30000,479,54,96),\nivec4(30240,479,50,49),\nivec4(30480,239,55,96),\nivec4(30480,239,67,49),\nivec4(30480,239,71,49),\nivec4(30720,239,62,96),\nivec4(30720,479,50,49),\nivec4(30960,479,54,96),\nivec4(30960,479,69,49),\nivec4(30960,479,72,49),\nivec4(31200,479,50,49),\nivec4(31440,239,55,96),\nivec4(31440,239,67,49),\nivec4(31440,239,71,49),\nivec4(31680,239,64,96),\nivec4(31680,479,50,49),\nivec4(31920,479,54,96),\nivec4(31920,479,66,49),\nivec4(31920,479,72,49),\nivec4(32160,479,50,49),\nivec4(32400,239,55,96),\nivec4(32400,239,67,49),\nivec4(32400,239,71,49),\nivec4(32640,239,60,96),\nivec4(32640,479,50,49),\nivec4(32640,479,66,49),\nivec4(32640,479,69,49),\nivec4(32880,119,59,96),\nivec4(33000,119,57,96),\nivec4(33120,239,59,96),\nivec4(33120,479,50,49),\nivec4(33120,479,67,49),\nivec4(33120,479,71,49),\nivec4(33360,119,57,96),\nivec4(33480,119,55,96),\nivec4(33600,239,62,96),\nivec4(33600,479,50,49),\nivec4(33600,479,69,49),\nivec4(33600,479,72,49),\nivec4(33840,239,54,96),\nivec4(34080,239,52,49),\nivec4(34080,239,55,96),\nivec4(34080,239,71,49),\nivec4(34080,479,62,49),\nivec4(34320,239,54,49),\nivec4(34320,239,60,96),\nivec4(34320,239,69,49),\nivec4(34560,239,55,49),\nivec4(34560,239,59,96),\nivec4(34560,479,62,49),\nivec4(34560,479,67,49),\nivec4(34560,479,71,49),\nivec4(34800,119,57,96),\nivec4(34800,239,47,49),\nivec4(34920,119,55,96),\nivec4(35040,239,48,49),\nivec4(35040,239,48,96),\nivec4(35040,239,64,49),\nivec4(35040,479,69,49),\nivec4(35280,239,50,49),\nivec4(35280,239,50,96),\nivec4(35280,239,60,49),\nivec4(35280,239,66,49),\nivec4(35520,719,43,49),\nivec4(35520,719,43,96),\nivec4(35520,719,59,49),\nivec4(35520,719,62,49),\nivec4(35520,719,67,49),\nivec4(38160,239,47,49),\nivec4(38160,239,47,96),\nivec4(38160,239,71,49),\nivec4(38160,239,75,49),\nivec4(38160,239,78,49),\nivec4(38400,119,52,96),\nivec4(38400,479,52,49),\nivec4(38400,479,71,49),\nivec4(38400,479,76,49),\nivec4(38400,479,79,49),\nivec4(38520,119,55,96),\nivec4(38640,119,54,96),\nivec4(38760,119,52,96),\nivec4(38880,119,59,96),\nivec4(38880,479,40,49),\nivec4(38880,479,71,49),\nivec4(38880,479,76,49),\nivec4(38880,479,79,49),\nivec4(39000,119,55,96),\nivec4(39120,119,54,96),\nivec4(39240,119,52,96),\nivec4(39360,239,47,96),\nivec4(39360,479,47,49),\nivec4(39360,479,71,49),\nivec4(39360,479,75,49),\nivec4(39360,479,78,49),\nivec4(39600,239,60,96),\nivec4(39840,119,59,96),\nivec4(39840,479,51,49),\nivec4(39840,479,66,49),\nivec4(39840,479,71,49),\nivec4(39840,479,78,49),\nivec4(39960,119,57,96),\nivec4(40080,119,55,96),\nivec4(40200,119,54,96),\nivec4(40320,119,52,96),\nivec4(40320,479,52,49),\nivec4(40320,479,67,49),\nivec4(40320,479,71,49),\nivec4(40320,479,76,49),\nivec4(40440,119,55,96),\nivec4(40560,119,54,96),\nivec4(40680,119,52,96),\nivec4(40800,119,59,96),\nivec4(40800,479,40,49),\nivec4(40800,479,67,49),\nivec4(40800,479,71,49),\nivec4(40800,479,76,49),\nivec4(40920,119,55,96),\nivec4(41040,119,54,96),\nivec4(41160,119,52,96),\nivec4(41280,239,47,96),\nivec4(41280,479,47,49),\nivec4(41280,479,66,49),\nivec4(41280,479,71,49),\nivec4(41280,479,75,49),\nivec4(41520,239,60,96),\nivec4(41760,119,59,96),\nivec4(41760,479,51,49),\nivec4(41760,479,66,49),\nivec4(41760,479,71,49),\nivec4(41880,119,57,96),\nivec4(42000,119,55,96),\nivec4(42120,119,54,96),\nivec4(42240,119,55,96),\nivec4(42240,239,52,49),\nivec4(42240,479,67,49),\nivec4(42240,479,71,49),\nivec4(42360,119,54,96),\nivec4(42480,239,52,96),\nivec4(42480,239,54,49),\nivec4(42720,239,55,49),\nivec4(42720,479,71,49),\nivec4(42960,239,52,49),\nivec4(42960,239,59,96),\nivec4(43200,239,44,96),\nivec4(43200,239,76,49),\nivec4(43200,479,44,49),\nivec4(43440,239,62,96),\nivec4(43440,239,71,49),\nivec4(43680,239,52,96),\nivec4(43680,239,68,49),\nivec4(43680,479,52,49),\nivec4(43920,239,62,96),\nivec4(43920,239,71,49),\nivec4(44160,239,60,96),\nivec4(44160,479,57,49),\nivec4(44160,479,69,49),\nivec4(44400,239,52,96),\nivec4(44640,239,45,96),\nivec4(44640,479,45,49),\nivec4(44640,479,72,49),\nivec4(44880,239,60,96),\nivec4(45120,239,42,96),\nivec4(45120,239,74,49),\nivec4(45120,479,42,49),\nivec4(45360,239,60,96),\nivec4(45360,239,69,49),\nivec4(45600,239,50,96),\nivec4(45600,239,66,49),\nivec4(45600,479,50,49),\nivec4(45840,239,60,96),\nivec4(45840,239,69,49),\nivec4(46080,239,59,96),\nivec4(46080,479,55,49),\nivec4(46080,479,67,49),\nivec4(46320,239,50,96),\nivec4(46560,239,43,96),\nivec4(46560,479,43,49),\nivec4(46560,479,71,49),\nivec4(46800,239,59,96),\nivec4(47040,239,42,96),\nivec4(47040,479,47,49),\nivec4(47040,479,63,49),\nivec4(47280,239,57,96),\nivec4(47520,239,51,96),\nivec4(47520,479,51,49),\nivec4(47520,479,66,49),\nivec4(47760,239,57,96),\nivec4(48000,239,55,96),\nivec4(48000,479,52,49),\nivec4(48000,959,67,49),\nivec4(48240,239,47,96),\nivec4(48480,239,40,96),\nivec4(48480,479,40,49),\nivec4(48720,239,55,96),\nivec4(48960,239,36,80),\nivec4(48960,479,45,33),\nivec4(48960,719,65,33),\nivec4(49200,239,53,80),\nivec4(49440,239,45,80),\nivec4(49440,479,45,33),\nivec4(49680,239,53,80),\nivec4(49680,239,72,33),\nivec4(49920,119,51,80),\nivec4(49920,239,47,33),\nivec4(49920,239,71,33),\nivec4(50040,119,60,80),\nivec4(50160,239,52,33),\nivec4(50160,239,67,33),\nivec4(50160,359,59,80),\nivec4(50400,239,55,33),\nivec4(50400,239,71,33),\nivec4(50520,119,60,80),\nivec4(50640,239,59,33),\nivec4(50640,239,76,33),\nivec4(50640,359,59,80),\nivec4(50880,239,51,33),\nivec4(50880,239,78,33),\nivec4(51000,119,57,80),\nivec4(51120,119,55,80),\nivec4(51120,239,47,33),\nivec4(51120,239,75,33),\nivec4(51240,119,54,80),\nivec4(51360,119,59,80),\nivec4(51360,239,51,33),\nivec4(51360,479,71,33),\nivec4(51480,119,57,80),\nivec4(51600,119,55,80),\nivec4(51600,239,47,33),\nivec4(51720,119,54,80),\nivec4(51840,239,52,49),\nivec4(51840,239,55,80),\nivec4(51840,239,67,49),\nivec4(51840,479,76,49),\nivec4(52080,119,43,49),\nivec4(52080,119,71,49),\nivec4(52080,239,52,80),\nivec4(52200,119,45,49),\nivec4(52200,119,72,49),\nivec4(52320,239,47,49),\nivec4(52320,239,47,80),\nivec4(52320,239,66,49),\nivec4(52320,239,71,49),\nivec4(52320,239,76,49),\nivec4(52560,239,47,49),\nivec4(52560,239,51,80),\nivec4(52560,239,66,49),\nivec4(52560,239,71,49),\nivec4(52560,239,75,49),\nivec4(52800,479,40,49),\nivec4(52800,479,40,80),\nivec4(52800,479,67,49),\nivec4(52800,479,71,49),\nivec4(52800,479,76,49),\nivec4(53520,239,47,49),\nivec4(53520,239,47,96),\nivec4(53520,239,71,49),\nivec4(53520,239,75,49),\nivec4(53520,239,78,49),\nivec4(53760,119,52,96),\nivec4(53760,479,52,49),\nivec4(53760,479,71,49),\nivec4(53760,479,76,49),\nivec4(53760,479,79,49),\nivec4(53880,119,55,96),\nivec4(54000,119,54,96),\nivec4(54120,119,52,96),\nivec4(54240,119,59,96),\nivec4(54240,479,40,49),\nivec4(54240,479,71,49),\nivec4(54240,479,76,49),\nivec4(54240,479,79,49),\nivec4(54360,119,55,96),\nivec4(54480,119,54,96),\nivec4(54600,119,52,96),\nivec4(54720,239,47,96),\nivec4(54720,479,47,49),\nivec4(54720,479,71,49),\nivec4(54720,479,75,49),\nivec4(54720,479,78,49),\nivec4(54960,239,60,96),\nivec4(55200,119,59,96),\nivec4(55200,479,51,49),\nivec4(55200,479,66,49),\nivec4(55200,479,71,49),\nivec4(55200,479,78,49),\nivec4(55320,119,57,96),\nivec4(55440,119,55,96),\nivec4(55560,119,54,96),\nivec4(55680,119,52,96),\nivec4(55680,479,52,49),\nivec4(55680,479,67,49),\nivec4(55680,479,71,49),\nivec4(55680,479,76,49),\nivec4(55800,119,55,96),\nivec4(55920,119,54,96),\nivec4(56040,119,52,96),\nivec4(56160,119,59,96),\nivec4(56160,479,40,49),\nivec4(56160,479,67,49),\nivec4(56160,479,71,49),\nivec4(56160,479,76,49),\nivec4(56280,119,55,96),\nivec4(56400,119,54,96),\nivec4(56520,119,52,96),\nivec4(56640,239,47,96),\nivec4(56640,479,47,49),\nivec4(56640,479,66,49),\nivec4(56640,479,71,49),\nivec4(56640,479,75,49),\nivec4(56880,239,60,96),\nivec4(57120,119,59,96),\nivec4(57120,479,51,49),\nivec4(57120,479,66,49),\nivec4(57120,479,71,49),\nivec4(57240,119,57,96),\nivec4(57360,119,55,96),\nivec4(57480,119,54,96),\nivec4(57600,239,52,49),\nivec4(57600,239,55,96),\nivec4(57600,719,67,49),\nivec4(57600,719,71,49),\nivec4(57840,239,52,96),\nivec4(57840,239,54,49),\nivec4(58080,239,55,49),\nivec4(58320,239,52,49),\nivec4(58320,239,55,96),\nivec4(58320,239,67,49),\nivec4(58320,239,73,49),\nivec4(58560,119,57,96),\nivec4(58560,239,66,49),\nivec4(58560,239,74,49),\nivec4(58560,479,50,49),\nivec4(58680,119,54,96),\nivec4(58800,119,50,96),\nivec4(58800,239,69,49),\nivec4(58920,119,54,96),\nivec4(59040,119,57,96),\nivec4(59040,239,74,49),\nivec4(59040,479,54,49),\nivec4(59160,119,60,96),\nivec4(59280,119,59,96),\nivec4(59280,239,72,49),\nivec4(59400,119,57,96),\nivec4(59520,119,59,96),\nivec4(59520,479,55,49),\nivec4(59520,479,71,49),\nivec4(59640,119,55,96),\nivec4(59760,119,43,96),\nivec4(59880,119,55,96),\nivec4(60000,119,59,96),\nivec4(60000,239,74,49),\nivec4(60000,479,43,49),\nivec4(60120,119,62,96),\nivec4(60240,119,60,96),\nivec4(60240,239,71,49),\nivec4(60360,119,59,96),\nivec4(60480,119,57,96),\nivec4(60480,479,54,49),\nivec4(60480,479,62,49),\nivec4(60600,119,54,96),\nivec4(60720,119,50,96),\nivec4(60840,119,54,96),\nivec4(60960,119,57,96),\nivec4(60960,239,66,49),\nivec4(60960,479,50,49),\nivec4(61080,119,60,96),\nivec4(61200,119,59,96),\nivec4(61200,239,69,49),\nivec4(61320,119,57,96),\nivec4(61440,119,59,96),\nivec4(61440,479,55,49),\nivec4(61440,719,71,49),\nivec4(61560,119,55,96),\nivec4(61680,119,43,96),\nivec4(61800,119,55,96),\nivec4(61920,119,59,96),\nivec4(61920,479,43,49),\nivec4(62040,119,62,96),\nivec4(62160,119,60,96),\nivec4(62160,479,67,49),\nivec4(62280,119,59,96),\nivec4(62400,59,59,96),\nivec4(62400,239,50,49),\nivec4(62460,59,60,96),\nivec4(62520,59,59,96),\nivec4(62580,59,60,96),\nivec4(62640,239,48,49),\nivec4(62640,239,57,96),\nivec4(62640,239,66,49),\nivec4(62880,239,47,49),\nivec4(62880,239,67,49),\nivec4(63120,239,43,49),\nivec4(63120,239,50,96),\nivec4(63120,239,71,49),\nivec4(63360,239,52,96),\nivec4(63360,479,48,49),\nivec4(63360,719,67,49),\nivec4(63600,479,60,96),\nivec4(63840,239,52,49),\nivec4(64080,239,48,49),\nivec4(64080,239,57,96),\nivec4(64080,239,64,49),\nivec4(64320,239,54,96),\nivec4(64320,479,50,49),\nivec4(64320,479,66,49),\nivec4(64560,479,62,96),\nivec4(64800,239,54,49),\nivec4(64800,239,69,49),\nivec4(65040,239,50,49),\nivec4(65040,239,59,96),\nivec4(65040,239,66,49),\nivec4(65280,239,55,96),\nivec4(65280,479,52,49),\nivec4(65280,479,67,49),\nivec4(65520,479,64,96),\nivec4(65760,239,55,49),\nivec4(65760,239,71,49),\nivec4(66000,239,52,49),\nivec4(66000,239,60,96),\nivec4(66000,239,67,49),\nivec4(66240,239,57,96),\nivec4(66240,479,50,49),\nivec4(66240,719,66,49),\nivec4(66240,719,72,49),\nivec4(66480,479,54,96),\nivec4(66720,479,50,49),\nivec4(66960,239,55,96),\nivec4(66960,239,67,49),\nivec4(66960,239,71,49),\nivec4(67200,239,62,96),\nivec4(67200,479,50,49),\nivec4(67440,479,54,96),\nivec4(67440,479,69,49),\nivec4(67440,479,72,49),\nivec4(67680,479,50,49),\nivec4(67920,239,55,96),\nivec4(67920,239,67,49),\nivec4(67920,239,71,49),\nivec4(68160,239,64,96),\nivec4(68160,479,50,49),\nivec4(68400,479,54,96),\nivec4(68400,479,66,49),\nivec4(68400,479,72,49),\nivec4(68640,479,50,49),\nivec4(68880,239,55,96),\nivec4(68880,239,67,49),\nivec4(68880,239,71,49),\nivec4(69120,239,60,96),\nivec4(69120,479,50,49),\nivec4(69120,479,66,49),\nivec4(69120,479,69,49),\nivec4(69360,119,59,96),\nivec4(69480,119,57,96),\nivec4(69600,239,59,96),\nivec4(69600,479,50,49),\nivec4(69600,479,67,49),\nivec4(69600,479,71,49),\nivec4(69840,119,57,96),\nivec4(69960,119,55,96),\nivec4(70080,239,62,96),\nivec4(70080,479,50,49),\nivec4(70080,479,69,49),\nivec4(70080,479,72,49),\nivec4(70320,239,54,96),\nivec4(70560,239,52,49),\nivec4(70560,239,55,96),\nivec4(70560,239,71,49),\nivec4(70560,479,62,49),\nivec4(70800,239,54,49),\nivec4(70800,239,60,96),\nivec4(70800,239,69,49),\nivec4(71040,239,55,49),\nivec4(71040,239,59,96),\nivec4(71040,479,62,49),\nivec4(71040,479,67,49),\nivec4(71040,479,71,49),\nivec4(71280,119,57,96),\nivec4(71280,239,47,49),\nivec4(71400,119,55,96),\nivec4(71520,239,48,49),\nivec4(71520,239,48,96),\nivec4(71520,239,64,49),\nivec4(71520,479,69,49),\nivec4(71760,239,50,49),\nivec4(71760,239,50,96),\nivec4(71760,239,60,49),\nivec4(71760,239,66,49),\nivec4(72000,719,43,49),\nivec4(72000,719,43,96),\nivec4(72000,719,59,49),\nivec4(72000,719,62,49),\nivec4(72000,719,67,49),\nivec4(74640,239,50,49),\nivec4(74640,239,50,96),\nivec4(74640,239,66,49),\nivec4(74880,119,55,96),\nivec4(74880,239,67,49),\nivec4(74880,479,55,49),\nivec4(75000,119,59,96),\nivec4(75120,119,57,96),\nivec4(75120,239,71,49),\nivec4(75240,119,55,96),\nivec4(75360,119,62,96),\nivec4(75360,239,74,49),\nivec4(75360,479,43,49),\nivec4(75480,119,59,96),\nivec4(75600,119,57,96),\nivec4(75600,359,71,49),\nivec4(75720,119,55,96),\nivec4(75840,119,50,96),\nivec4(75840,479,50,49),\nivec4(75960,119,59,96),\nivec4(75960,119,67,49),\nivec4(76080,119,57,96),\nivec4(76080,119,69,49),\nivec4(76200,119,55,96),\nivec4(76200,119,71,49),\nivec4(76320,119,62,96),\nivec4(76320,239,47,49),\nivec4(76320,239,67,49),\nivec4(76440,119,59,96),\nivec4(76560,119,57,96),\nivec4(76560,239,48,49),\nivec4(76560,239,69,49),\nivec4(76680,119,55,96),\nivec4(76800,239,50,49),\nivec4(76800,239,54,96),\nivec4(76800,479,66,49),\nivec4(77040,239,50,96),\nivec4(77040,239,62,49),\nivec4(77280,239,56,49),\nivec4(77280,239,64,49),\nivec4(77520,239,52,49),\nivec4(77520,239,52,96),\nivec4(77520,239,68,49),\nivec4(77760,119,57,96),\nivec4(77760,239,69,49),\nivec4(77760,479,57,49),\nivec4(77880,119,60,96),\nivec4(78000,119,59,96),\nivec4(78000,239,72,49),\nivec4(78120,119,57,96),\nivec4(78240,119,64,96),\nivec4(78240,239,76,49),\nivec4(78240,479,45,49),\nivec4(78360,119,60,96),\nivec4(78480,119,59,96),\nivec4(78480,239,72,49),\nivec4(78600,119,57,96),\nivec4(78720,119,52,96),\nivec4(78720,119,71,49),\nivec4(78720,479,52,49),\nivec4(78840,119,60,96),\nivec4(78840,119,69,49),\nivec4(78960,119,59,96),\nivec4(78960,239,68,49),\nivec4(79080,119,57,96),\nivec4(79200,119,64,96),\nivec4(79200,239,48,49),\nivec4(79200,239,69,49),\nivec4(79320,119,60,96),\nivec4(79440,119,59,96),\nivec4(79440,239,50,49),\nivec4(79440,239,66,49),\nivec4(79560,119,57,96),\nivec4(79680,239,52,49),\nivec4(79680,239,56,96),\nivec4(79680,239,64,49),\nivec4(79920,239,50,49),\nivec4(79920,239,52,96),\nivec4(79920,239,68,49),\nivec4(80160,239,48,49),\nivec4(80160,239,69,49),\nivec4(80400,239,45,49),\nivec4(80400,239,52,96),\nivec4(80400,239,72,49),\nivec4(80640,119,53,96),\nivec4(80640,479,50,49),\nivec4(80640,719,71,49),\nivec4(80760,119,50,96),\nivec4(80880,239,54,96),\nivec4(81120,119,56,96),\nivec4(81120,479,52,49),\nivec4(81240,119,52,96),\nivec4(81360,239,59,96),\nivec4(81360,239,68,49),\nivec4(81600,119,60,96),\nivec4(81600,479,45,49),\nivec4(81600,479,64,49),\nivec4(81720,119,57,96),\nivec4(81840,239,60,96),\nivec4(82080,119,62,96),\nivec4(82080,479,47,49),\nivec4(82080,479,68,49),\nivec4(82200,119,59,96),\nivec4(82320,239,62,96),\nivec4(82560,239,64,96),\nivec4(82560,479,48,49),\nivec4(82560,479,69,49),\nivec4(82800,119,62,96),\nivec4(82920,119,60,96),\nivec4(83040,119,59,96),\nivec4(83160,119,57,96),\nivec4(83280,119,56,96),\nivec4(83400,119,54,96),\nivec4(83520,239,52,96),\nivec4(83520,479,52,49),\nivec4(83520,479,59,49),\nivec4(83520,479,64,49),\nivec4(83520,479,68,49),\nivec4(83760,119,50,96),\nivec4(83880,119,48,96),\nivec4(84000,119,47,96),\nivec4(84120,119,45,96),\nivec4(84240,119,44,96),\nivec4(84360,119,42,96),\nivec4(84480,239,40,49),\nivec4(84480,239,40,96),\nivec4(84480,239,68,49),\nivec4(84480,239,71,49),\nivec4(84480,479,64,49),\nivec4(84720,239,57,49),\nivec4(84720,239,57,96),\nivec4(84720,239,69,49),\nivec4(84720,239,72,49),\nivec4(84960,239,50,49),\nivec4(84960,239,50,96),\nivec4(84960,239,65,49),\nivec4(84960,479,71,49),\nivec4(85200,239,52,49),\nivec4(85200,239,52,96),\nivec4(85200,239,62,49),\nivec4(85200,239,68,49),\nivec4(85440,239,45,49),\nivec4(85440,479,45,96),\nivec4(85440,479,60,49),\nivec4(85440,479,64,49),\nivec4(85440,479,69,49),\nivec4(85680,239,57,49),\nivec4(85920,239,51,49),\nivec4(85920,239,71,49),\nivec4(85920,479,66,49),\nivec4(85920,479,69,49),\nivec4(86160,239,47,49),\nivec4(86160,239,47,96),\nivec4(86160,239,75,49),\nivec4(86400,119,52,96),\nivec4(86400,479,52,49),\nivec4(86400,479,67,49),\nivec4(86400,479,71,49),\nivec4(86400,479,76,49),\nivec4(86520,119,55,96),\nivec4(86640,119,54,96),\nivec4(86760,119,52,96),\nivec4(86880,119,59,96),\nivec4(86880,479,40,49),\nivec4(86880,479,71,49),\nivec4(86880,479,76,49),\nivec4(86880,479,79,49),\nivec4(87000,119,55,96),\nivec4(87120,119,54,96),\nivec4(87240,119,52,96),\nivec4(87360,239,47,96),\nivec4(87360,479,47,49),\nivec4(87360,479,71,49),\nivec4(87360,479,75,49),\nivec4(87360,479,78,49),\nivec4(87600,239,60,96),\nivec4(87840,119,59,96),\nivec4(87840,479,51,49),\nivec4(87840,479,66,49),\nivec4(87840,479,71,49),\nivec4(87840,479,78,49),\nivec4(87960,119,57,96),\nivec4(88080,119,55,96),\nivec4(88200,119,54,96),\nivec4(88320,119,52,96),\nivec4(88320,479,52,49),\nivec4(88320,479,67,49),\nivec4(88320,479,71,49),\nivec4(88320,479,76,49),\nivec4(88440,119,55,96),\nivec4(88560,119,54,96),\nivec4(88680,119,52,96),\nivec4(88800,119,59,96),\nivec4(88800,479,40,49),\nivec4(88800,479,67,49),\nivec4(88800,479,71,49),\nivec4(88800,479,76,49),\nivec4(88920,119,55,96),\nivec4(89040,119,54,96),\nivec4(89160,119,52,96),\nivec4(89280,239,47,96),\nivec4(89280,479,47,49),\nivec4(89280,479,66,49),\nivec4(89280,479,71,49),\nivec4(89280,479,75,49),\nivec4(89520,239,60,96),\nivec4(89760,119,59,96),\nivec4(89760,479,51,49),\nivec4(89760,479,66,49),\nivec4(89760,479,71,49),\nivec4(89880,119,57,96),\nivec4(90000,119,55,96),\nivec4(90120,119,54,96),\nivec4(90240,239,52,49),\nivec4(90240,239,55,96),\nivec4(90240,479,67,49),\nivec4(90240,479,71,49),\nivec4(90480,239,52,96),\nivec4(90480,239,54,49),\nivec4(90720,239,55,49),\nivec4(90720,479,64,49),\nivec4(90960,119,59,96),\nivec4(90960,239,54,49),\nivec4(91080,119,60,96),\nivec4(91200,119,62,96),\nivec4(91200,239,68,49),\nivec4(91200,479,52,49),\nivec4(91320,119,59,96),\nivec4(91440,119,56,96),\nivec4(91440,239,71,49),\nivec4(91560,119,54,96),\nivec4(91680,119,52,96),\nivec4(91680,239,71,49),\nivec4(91680,479,44,49),\nivec4(91800,119,62,96),\nivec4(91920,119,60,96),\nivec4(91920,239,74,49),\nivec4(92040,119,59,96),\nivec4(92160,119,60,96),\nivec4(92160,479,45,49),\nivec4(92160,479,72,49),\nivec4(92280,119,57,96),\nivec4(92400,119,52,96),\nivec4(92520,119,48,96),\nivec4(92640,239,45,96),\nivec4(92880,119,57,96),\nivec4(93000,119,59,96),\nivec4(93120,119,60,96),\nivec4(93120,239,66,49),\nivec4(93120,479,50,49),\nivec4(93240,119,57,96),\nivec4(93360,119,54,96),\nivec4(93360,239,69,49),\nivec4(93480,119,52,96),\nivec4(93600,119,50,96),\nivec4(93600,239,69,49),\nivec4(93600,479,42,49),\nivec4(93720,119,60,96),\nivec4(93840,119,59,96),\nivec4(93840,239,72,49),\nivec4(93960,119,57,96),\nivec4(94080,119,59,96),\nivec4(94080,479,43,49),\nivec4(94080,479,71,49),\nivec4(94200,119,55,96),\nivec4(94320,119,50,96),\nivec4(94440,119,47,96),\nivec4(94560,239,43,49),\nivec4(94800,359,59,49),\nivec4(95040,239,55,33),\nivec4(95040,479,76,33),\nivec4(95160,119,64,49),\nivec4(95280,119,59,49),\nivec4(95280,239,55,33),\nivec4(95400,119,60,49),\nivec4(95520,119,59,49),\nivec4(95520,239,55,33),\nivec4(95520,479,71,33),\nivec4(95640,119,64,49),\nivec4(95760,119,59,49),\nivec4(95760,239,55,33),\nivec4(95880,119,60,49),\nivec4(96000,119,57,49),\nivec4(96000,239,54,33),\nivec4(96000,479,69,33),\nivec4(96120,119,62,49),\nivec4(96240,119,57,49),\nivec4(96240,239,54,33),\nivec4(96360,119,59,49),\nivec4(96480,119,57,49),\nivec4(96480,239,54,33),\nivec4(96480,479,74,33),\nivec4(96600,119,62,49),\nivec4(96720,119,57,49),\nivec4(96720,239,54,33),\nivec4(96840,119,59,49),\nivec4(96960,119,55,49),\nivec4(96960,239,52,33),\nivec4(96960,479,72,33),\nivec4(97080,119,60,49),\nivec4(97200,119,55,49),\nivec4(97200,239,52,33),\nivec4(97320,119,57,49),\nivec4(97440,119,55,49),\nivec4(97440,239,52,33),\nivec4(97440,479,67,33),\nivec4(97560,119,60,49),\nivec4(97680,119,55,49),\nivec4(97680,239,52,33),\nivec4(97800,119,57,49),\nivec4(97920,119,54,49),\nivec4(97920,239,50,33),\nivec4(97920,479,66,33),\nivec4(98040,119,59,49),\nivec4(98160,119,54,49),\nivec4(98160,239,50,33),\nivec4(98280,119,55,49),\nivec4(98400,119,54,49),\nivec4(98400,239,50,33),\nivec4(98400,479,71,33),\nivec4(98520,119,59,49),\nivec4(98640,119,54,49),\nivec4(98640,239,50,33),\nivec4(98760,119,55,49),\nivec4(98880,119,52,49),\nivec4(98880,239,48,33),\nivec4(98880,479,69,33),\nivec4(99000,119,57,49),\nivec4(99120,119,52,49),\nivec4(99120,239,48,33),\nivec4(99240,119,54,49),\nivec4(99360,119,52,49),\nivec4(99360,239,48,33),\nivec4(99360,479,64,33),\nivec4(99480,119,57,49),\nivec4(99600,119,52,49),\nivec4(99600,239,48,33),\nivec4(99720,119,54,49),\nivec4(99840,119,51,49),\nivec4(99840,239,47,33),\nivec4(99840,239,66,33),\nivec4(99960,119,47,49),\nivec4(100080,119,52,49),\nivec4(100080,239,47,33),\nivec4(100080,239,67,33),\nivec4(100200,119,47,49),\nivec4(100320,119,54,49),\nivec4(100320,239,47,33),\nivec4(100320,239,63,33),\nivec4(100440,119,47,49),\nivec4(100560,119,55,49),\nivec4(100560,239,47,33),\nivec4(100560,239,64,33),\nivec4(100680,119,47,49),\nivec4(100800,239,47,33),\nivec4(100800,719,57,49),\nivec4(100800,719,66,33),\nivec4(101040,239,49,33),\nivec4(101280,239,51,33),\nivec4(101520,119,55,49),\nivec4(101520,239,47,33),\nivec4(101520,239,63,33),\nivec4(101640,119,54,49),\nivec4(101760,239,52,33),\nivec4(101760,239,55,49),\nivec4(101760,239,64,33),\nivec4(102000,239,43,33),\nivec4(102000,239,52,49),\nivec4(102000,239,71,33),\nivec4(102240,239,45,33),\nivec4(102240,239,54,49),\nivec4(102240,239,72,33),\nivec4(102480,239,47,33),\nivec4(102480,239,51,49),\nivec4(102480,239,71,33),\nivec4(102720,239,52,33),\nivec4(102720,479,52,49),\nivec4(102720,479,67,33),\nivec4(102960,239,54,33),\nivec4(103200,239,55,33),\nivec4(103440,239,52,33),\nivec4(103440,239,59,49),\nivec4(103680,239,44,49),\nivec4(103680,239,76,33),\nivec4(103680,479,44,33),\nivec4(103920,239,62,49),\nivec4(103920,239,71,33),\nivec4(104160,239,52,49),\nivec4(104160,239,68,33),\nivec4(104160,479,52,33),\nivec4(104400,239,62,49),\nivec4(104400,239,71,33),\nivec4(104640,239,60,49),\nivec4(104640,479,57,33),\nivec4(104640,479,69,33),\nivec4(104880,239,52,49),\nivec4(105120,239,45,49),\nivec4(105120,479,45,33),\nivec4(105120,479,72,33),\nivec4(105360,239,60,49),\nivec4(105600,239,42,49),\nivec4(105600,239,74,33),\nivec4(105600,479,42,33),\nivec4(105840,239,60,49),\nivec4(105840,239,69,33),\nivec4(106080,239,50,49),\nivec4(106080,239,66,33),\nivec4(106080,479,50,33),\nivec4(106320,239,60,49),\nivec4(106320,239,69,33),\nivec4(106560,239,59,49),\nivec4(106560,479,55,33),\nivec4(106560,479,67,33),\nivec4(106800,239,50,49),\nivec4(107040,239,43,49),\nivec4(107040,479,43,33),\nivec4(107040,479,71,33),\nivec4(107280,239,59,49),\nivec4(107520,239,42,49),\nivec4(107520,479,47,33),\nivec4(107520,479,63,33),\nivec4(107760,239,57,49),\nivec4(108000,239,51,49),\nivec4(108000,479,51,33),\nivec4(108000,479,66,33),\nivec4(108240,239,57,49),\nivec4(108480,239,55,49),\nivec4(108480,479,52,33),\nivec4(108480,959,67,33),\nivec4(108720,239,47,49),\nivec4(108960,239,40,49),\nivec4(108960,479,40,33),\nivec4(109200,239,55,49),\nivec4(109440,239,36,49),\nivec4(109440,479,45,33),\nivec4(109440,719,65,33),\nivec4(109680,239,53,49),\nivec4(109920,239,45,49),\nivec4(109920,479,45,33),\nivec4(110160,239,53,49),\nivec4(110160,239,72,33),\nivec4(110400,119,51,49),\nivec4(110400,239,47,33),\nivec4(110400,239,71,33),\nivec4(110520,119,60,49),\nivec4(110640,239,52,33),\nivec4(110640,239,67,33),\nivec4(110640,359,59,49),\nivec4(110880,239,55,33),\nivec4(110880,239,71,33),\nivec4(111000,119,60,49),\nivec4(111120,239,52,33),\nivec4(111120,239,76,33),\nivec4(111120,359,59,49),\nivec4(111360,239,51,33),\nivec4(111360,239,78,33),\nivec4(111480,119,60,49),\nivec4(111600,239,47,33),\nivec4(111600,239,75,33),\nivec4(111600,359,59,49),\nivec4(111840,239,51,33),\nivec4(111840,239,71,33),\nivec4(111960,119,57,49),\nivec4(112080,119,55,49),\nivec4(112080,239,47,33),\nivec4(112080,239,69,33),\nivec4(112080,239,75,33),\nivec4(112200,119,54,49),\nivec4(112320,239,52,33),\nivec4(112320,239,55,49),\nivec4(112320,239,67,33),\nivec4(112320,479,76,33),\nivec4(112560,119,43,33),\nivec4(112560,119,71,33),\nivec4(112560,239,52,49),\nivec4(112680,119,45,33),\nivec4(112680,119,72,33),\nivec4(112800,239,47,33),\nivec4(112800,239,47,49),\nivec4(112800,239,66,33),\nivec4(112800,239,71,33),\nivec4(112800,239,76,33),\nivec4(113040,239,47,33),\nivec4(113040,239,51,49),\nivec4(113040,239,66,33),\nivec4(113040,239,71,33),\nivec4(113040,239,75,33),\nivec4(113280,959,40,33),\nivec4(113280,959,40,49),\nivec4(113280,959,67,33),\nivec4(113280,959,71,33),\nivec4(113280,959,76,33),\nivec4(116880,239,50,49),\nivec4(116880,239,50,96),\nivec4(116880,239,66,49),\nivec4(117120,119,55,96),\nivec4(117120,239,67,49),\nivec4(117120,479,55,49),\nivec4(117240,119,59,96),\nivec4(117360,119,57,96),\nivec4(117360,239,71,49),\nivec4(117480,119,55,96),\nivec4(117600,119,62,96),\nivec4(117600,239,74,49),\nivec4(117600,479,43,49),\nivec4(117720,119,59,96),\nivec4(117840,119,57,96),\nivec4(117840,359,71,49),\nivec4(117960,119,55,96),\nivec4(118080,119,50,96),\nivec4(118080,479,50,49),\nivec4(118200,119,59,96),\nivec4(118200,119,67,49),\nivec4(118320,119,57,96),\nivec4(118320,119,69,49),\nivec4(118440,119,55,96),\nivec4(118440,119,71,49),\nivec4(118560,119,62,96),\nivec4(118560,239,47,49),\nivec4(118560,239,67,49),\nivec4(118680,119,59,96),\nivec4(118800,119,57,96),\nivec4(118800,239,48,49),\nivec4(118800,239,69,49),\nivec4(118920,119,55,96),\nivec4(119040,239,50,49),\nivec4(119040,239,54,96),\nivec4(119040,479,66,49),\nivec4(119280,239,50,96),\nivec4(119280,239,62,49),\nivec4(119520,239,56,49),\nivec4(119520,239,64,49),\nivec4(119760,239,52,49),\nivec4(119760,239,52,96),\nivec4(119760,239,68,49),\nivec4(120000,119,57,96),\nivec4(120000,239,69,49),\nivec4(120000,479,57,49),\nivec4(120120,119,60,96),\nivec4(120240,119,59,96),\nivec4(120240,239,72,49),\nivec4(120360,119,57,96),\nivec4(120480,119,64,96),\nivec4(120480,239,76,49),\nivec4(120480,479,45,49),\nivec4(120600,119,60,96),\nivec4(120720,119,59,96),\nivec4(120720,239,72,49),\nivec4(120840,119,57,96),\nivec4(120960,119,52,96),\nivec4(120960,119,71,49),\nivec4(120960,479,52,49),\nivec4(121080,119,60,96),\nivec4(121080,119,69,49),\nivec4(121200,119,59,96),\nivec4(121200,239,68,49),\nivec4(121320,119,57,96),\nivec4(121440,119,64,96),\nivec4(121440,239,48,49),\nivec4(121440,239,69,49),\nivec4(121560,119,60,96),\nivec4(121680,119,59,96),\nivec4(121680,239,50,49),\nivec4(121680,239,66,49),\nivec4(121800,119,57,96),\nivec4(121920,239,52,49),\nivec4(121920,239,56,96),\nivec4(121920,239,64,49),\nivec4(122160,239,50,49),\nivec4(122160,239,52,96),\nivec4(122160,239,68,49),\nivec4(122400,239,48,49),\nivec4(122400,239,69,49),\nivec4(122640,239,45,49),\nivec4(122640,239,52,96),\nivec4(122640,239,72,49),\nivec4(122880,119,53,96),\nivec4(122880,479,50,49),\nivec4(122880,719,71,49),\nivec4(123000,119,50,96),\nivec4(123120,239,54,96),\nivec4(123360,119,56,96),\nivec4(123360,479,52,49),\nivec4(123480,119,52,96),\nivec4(123600,239,59,96),\nivec4(123600,239,68,49),\nivec4(123840,119,60,96),\nivec4(123840,479,45,49),\nivec4(123840,479,64,49),\nivec4(123960,119,57,96),\nivec4(124080,239,60,96),\nivec4(124320,119,62,96),\nivec4(124320,479,47,49),\nivec4(124320,479,68,49),\nivec4(124440,119,59,96),\nivec4(124560,239,62,96),\nivec4(124800,239,64,96),\nivec4(124800,479,48,49),\nivec4(124800,479,69,49),\nivec4(125040,119,62,96),\nivec4(125160,119,60,96),\nivec4(125280,119,59,96),\nivec4(125400,119,57,96),\nivec4(125520,119,56,96),\nivec4(125640,119,54,96),\nivec4(125760,239,52,96),\nivec4(125760,479,52,49),\nivec4(125760,479,59,49),\nivec4(125760,479,64,49),\nivec4(125760,479,68,49),\nivec4(126000,119,50,96),\nivec4(126120,119,48,96),\nivec4(126240,119,47,96),\nivec4(126360,119,45,96),\nivec4(126480,119,44,96),\nivec4(126600,119,42,96),\nivec4(126720,239,40,49),\nivec4(126720,239,40,96),\nivec4(126720,239,68,49),\nivec4(126720,239,71,49),\nivec4(126720,479,64,49),\nivec4(126960,239,57,49),\nivec4(126960,239,57,96),\nivec4(126960,239,69,49),\nivec4(126960,239,72,49),\nivec4(127200,239,50,49),\nivec4(127200,239,50,96),\nivec4(127200,239,65,49),\nivec4(127200,479,71,49),\nivec4(127440,239,52,49),\nivec4(127440,239,52,96),\nivec4(127440,239,62,49),\nivec4(127440,239,68,49),\nivec4(127680,239,45,49),\nivec4(127680,479,45,96),\nivec4(127680,479,60,49),\nivec4(127680,479,64,49),\nivec4(127680,479,69,49),\nivec4(127920,239,57,49),\nivec4(128160,239,51,49),\nivec4(128160,239,71,49),\nivec4(128160,479,66,49),\nivec4(128160,479,69,49),\nivec4(128400,239,47,49),\nivec4(128400,239,47,96),\nivec4(128400,239,75,49),\nivec4(128640,119,52,96),\nivec4(128640,479,52,49),\nivec4(128640,479,67,49),\nivec4(128640,479,71,49),\nivec4(128640,479,76,49),\nivec4(128760,119,55,96),\nivec4(128880,119,54,96),\nivec4(129000,119,52,96),\nivec4(129120,119,59,96),\nivec4(129120,479,40,49),\nivec4(129120,479,71,49),\nivec4(129120,479,76,49),\nivec4(129120,479,79,49),\nivec4(129240,119,55,96),\nivec4(129360,119,54,96),\nivec4(129480,119,52,96),\nivec4(129600,239,47,96),\nivec4(129600,479,47,49),\nivec4(129600,479,71,49),\nivec4(129600,479,75,49),\nivec4(129600,479,78,49),\nivec4(129840,239,60,96),\nivec4(130080,119,59,96),\nivec4(130080,479,51,49),\nivec4(130080,479,66,49),\nivec4(130080,479,71,49),\nivec4(130080,479,78,49),\nivec4(130200,119,57,96),\nivec4(130320,119,55,96),\nivec4(130440,119,54,96),\nivec4(130560,119,52,96),\nivec4(130560,479,52,49),\nivec4(130560,479,67,49),\nivec4(130560,479,71,49),\nivec4(130560,479,76,49),\nivec4(130680,119,55,96),\nivec4(130800,119,54,96),\nivec4(130920,119,52,96),\nivec4(131040,119,59,96),\nivec4(131040,479,40,49),\nivec4(131040,479,67,49),\nivec4(131040,479,71,49),\nivec4(131040,479,76,49),\nivec4(131160,119,55,96),\nivec4(131280,119,54,96),\nivec4(131400,119,52,96),\nivec4(131520,239,47,96),\nivec4(131520,479,47,49),\nivec4(131520,479,66,49),\nivec4(131520,479,71,49),\nivec4(131520,479,75,49),\nivec4(131760,239,60,96),\nivec4(132000,119,59,96),\nivec4(132000,479,51,49),\nivec4(132000,479,66,49),\nivec4(132000,479,71,49),\nivec4(132120,119,57,96),\nivec4(132240,119,55,96),\nivec4(132360,119,54,96),\nivec4(132480,239,52,49),\nivec4(132480,239,55,96),\nivec4(132480,479,67,49),\nivec4(132480,479,71,49),\nivec4(132720,239,52,96),\nivec4(132720,239,54,49),\nivec4(132960,239,55,49),\nivec4(132960,479,64,49),\nivec4(133200,119,59,96),\nivec4(133200,239,54,49),\nivec4(133320,119,60,96),\nivec4(133440,119,62,96),\nivec4(133440,239,68,49),\nivec4(133440,479,52,49),\nivec4(133560,119,59,96),\nivec4(133680,119,56,96),\nivec4(133680,239,71,49),\nivec4(133800,119,54,96),\nivec4(133920,119,52,96),\nivec4(133920,239,71,49),\nivec4(133920,479,44,49),\nivec4(134040,119,62,96),\nivec4(134160,119,60,96),\nivec4(134160,239,74,49),\nivec4(134280,119,59,96),\nivec4(134400,119,60,96),\nivec4(134400,479,45,49),\nivec4(134400,479,72,49),\nivec4(134520,119,57,96),\nivec4(134640,119,52,96),\nivec4(134760,119,48,96),\nivec4(134880,239,45,96),\nivec4(135120,119,57,96),\nivec4(135240,119,59,96),\nivec4(135360,119,60,96),\nivec4(135360,239,66,49),\nivec4(135360,479,50,49),\nivec4(135480,119,57,96),\nivec4(135600,119,54,96),\nivec4(135600,239,69,49),\nivec4(135720,119,52,96),\nivec4(135840,119,50,96),\nivec4(135840,239,69,49),\nivec4(135840,479,42,49),\nivec4(135960,119,60,96),\nivec4(136080,119,59,96),\nivec4(136080,239,72,49),\nivec4(136200,119,57,96),\nivec4(136320,119,59,96),\nivec4(136320,479,43,49),\nivec4(136320,479,71,49),\nivec4(136440,119,55,96),\nivec4(136560,119,50,96),\nivec4(136680,119,47,96),\nivec4(136800,239,43,49),\nivec4(137040,359,59,49),\nivec4(137280,239,55,33),\nivec4(137280,479,76,33),\nivec4(137400,119,64,49),\nivec4(137520,119,59,49),\nivec4(137520,239,55,33),\nivec4(137640,119,60,49),\nivec4(137760,119,59,49),\nivec4(137760,239,55,33),\nivec4(137760,479,71,33),\nivec4(137880,119,64,49),\nivec4(138000,119,59,49),\nivec4(138000,239,55,33),\nivec4(138120,119,60,49),\nivec4(138240,119,57,49),\nivec4(138240,239,54,33),\nivec4(138240,479,69,33),\nivec4(138360,119,62,49),\nivec4(138480,119,57,49),\nivec4(138480,239,54,33),\nivec4(138600,119,59,49),\nivec4(138720,119,57,49),\nivec4(138720,239,54,33),\nivec4(138720,479,74,33),\nivec4(138840,119,62,49),\nivec4(138960,119,57,49),\nivec4(138960,239,54,33),\nivec4(139080,119,59,49),\nivec4(139200,119,55,49),\nivec4(139200,239,52,33),\nivec4(139200,479,72,33),\nivec4(139320,119,60,49),\nivec4(139440,119,55,49),\nivec4(139440,239,52,33),\nivec4(139560,119,57,49),\nivec4(139680,119,55,49),\nivec4(139680,239,52,33),\nivec4(139680,479,67,33),\nivec4(139800,119,60,49),\nivec4(139920,119,55,49),\nivec4(139920,239,52,33),\nivec4(140040,119,57,49),\nivec4(140160,119,54,49),\nivec4(140160,239,50,33),\nivec4(140160,479,66,33),\nivec4(140280,119,59,49),\nivec4(140400,119,54,49),\nivec4(140400,239,50,33),\nivec4(140520,119,55,49),\nivec4(140640,119,54,49),\nivec4(140640,239,50,33),\nivec4(140640,479,71,33),\nivec4(140760,119,59,49),\nivec4(140880,119,54,49),\nivec4(140880,239,50,33),\nivec4(141000,119,55,49),\nivec4(141120,119,52,49),\nivec4(141120,239,48,33),\nivec4(141120,479,69,33),\nivec4(141240,119,57,49),\nivec4(141360,119,52,49),\nivec4(141360,239,48,33),\nivec4(141480,119,54,49),\nivec4(141600,119,52,49),\nivec4(141600,239,48,33),\nivec4(141600,479,64,33),\nivec4(141720,119,57,49),\nivec4(141840,119,52,49),\nivec4(141840,239,48,33),\nivec4(141960,119,54,49),\nivec4(142080,119,51,49),\nivec4(142080,239,47,33),\nivec4(142080,239,66,33),\nivec4(142200,119,47,49),\nivec4(142320,119,52,49),\nivec4(142320,239,47,33),\nivec4(142320,239,67,33),\nivec4(142440,119,47,49),\nivec4(142560,119,54,49),\nivec4(142560,239,47,33),\nivec4(142560,239,63,33),\nivec4(142680,119,47,49),\nivec4(142800,119,55,49),\nivec4(142800,239,47,33),\nivec4(142800,239,64,33),\nivec4(142920,119,47,49),\nivec4(143040,239,47,33),\nivec4(143040,719,57,49),\nivec4(143040,719,66,33),\nivec4(143280,239,49,33),\nivec4(143520,239,51,33),\nivec4(143760,119,55,49),\nivec4(143760,239,47,33),\nivec4(143760,239,63,33),\nivec4(143880,119,54,49),\nivec4(144000,239,52,33),\nivec4(144000,239,55,49),\nivec4(144000,239,64,33),\nivec4(144240,239,43,33),\nivec4(144240,239,52,49),\nivec4(144240,239,71,33),\nivec4(144480,239,45,33),\nivec4(144480,239,54,49),\nivec4(144480,239,72,33),\nivec4(144720,239,47,33),\nivec4(144720,239,51,49),\nivec4(144720,239,71,33),\nivec4(144960,239,52,33),\nivec4(144960,479,52,49),\nivec4(144960,479,67,33),\nivec4(145200,239,54,33),\nivec4(145440,239,55,33),\nivec4(145680,239,52,33),\nivec4(145680,239,59,49),\nivec4(145920,239,44,49),\nivec4(145920,239,76,33),\nivec4(145920,479,44,33),\nivec4(146160,239,62,49),\nivec4(146160,239,71,33),\nivec4(146400,239,52,49),\nivec4(146400,239,68,33),\nivec4(146400,479,52,33),\nivec4(146640,239,62,49),\nivec4(146640,239,71,33),\nivec4(146880,239,60,49),\nivec4(146880,479,57,33),\nivec4(146880,479,69,33),\nivec4(147120,239,52,49),\nivec4(147360,239,45,49),\nivec4(147360,479,45,33),\nivec4(147360,479,72,33),\nivec4(147600,239,60,49),\nivec4(147840,239,42,49),\nivec4(147840,239,74,33),\nivec4(147840,479,42,33),\nivec4(148080,239,60,49),\nivec4(148080,239,69,33),\nivec4(148320,239,50,49),\nivec4(148320,239,66,33),\nivec4(148320,479,50,33),\nivec4(148560,239,60,49),\nivec4(148560,239,69,33),\nivec4(148800,239,59,49),\nivec4(148800,479,55,33),\nivec4(148800,479,67,33),\nivec4(149040,239,50,49),\nivec4(149280,239,43,49),\nivec4(149280,479,43,33),\nivec4(149280,479,71,33),\nivec4(149520,239,59,49),\nivec4(149760,239,42,49),\nivec4(149760,479,47,33),\nivec4(149760,479,63,33),\nivec4(150000,239,57,49),\nivec4(150240,239,51,49),\nivec4(150240,479,51,33),\nivec4(150240,479,66,33),\nivec4(150480,239,57,49),\nivec4(150720,239,55,49),\nivec4(150720,479,52,33),\nivec4(150720,959,67,33),\nivec4(150960,239,47,49),\nivec4(151200,239,40,49),\nivec4(151200,479,40,33),\nivec4(151440,239,55,49),\nivec4(151680,239,36,49),\nivec4(151680,479,45,33),\nivec4(151680,719,65,33),\nivec4(151920,239,53,49),\nivec4(152160,239,45,49),\nivec4(152160,479,45,33),\nivec4(152400,239,53,49),\nivec4(152400,239,72,33),\nivec4(152640,119,51,49),\nivec4(152640,239,47,33),\nivec4(152640,239,71,33),\nivec4(152760,119,60,49),\nivec4(152880,239,52,33),\nivec4(152880,239,67,33),\nivec4(152880,359,59,49),\nivec4(153120,239,55,33),\nivec4(153120,239,71,33),\nivec4(153240,119,60,49),\nivec4(153360,239,52,33),\nivec4(153360,239,76,33),\nivec4(153360,359,59,49),\nivec4(153600,239,51,33),\nivec4(153600,239,78,33),\nivec4(153720,119,60,49),\nivec4(153840,239,47,33),\nivec4(153840,239,75,33),\nivec4(153840,359,59,49),\nivec4(154080,239,51,33),\nivec4(154080,239,71,33),\nivec4(154200,119,57,49),\nivec4(154320,119,55,49),\nivec4(154320,239,47,33),\nivec4(154320,239,69,33),\nivec4(154320,239,75,33),\nivec4(154440,119,54,49),\nivec4(154560,239,52,33),\nivec4(154560,239,55,49),\nivec4(154560,239,67,33),\nivec4(154560,479,76,33),\nivec4(154800,119,43,33),\nivec4(154800,119,71,33),\nivec4(154800,239,52,49),\nivec4(154920,119,45,33),\nivec4(154920,119,72,33),\nivec4(155040,239,47,33),\nivec4(155040,239,47,49),\nivec4(155040,239,66,33),\nivec4(155040,239,71,33),\nivec4(155040,239,76,33),\nivec4(155280,239,47,33),\nivec4(155280,239,51,49),\nivec4(155280,239,66,33),\nivec4(155280,239,71,33),\nivec4(155280,239,75,33),\nivec4(155520,959,40,33),\nivec4(155520,959,40,49),\nivec4(155520,959,67,33),\nivec4(155520,959,71,33),\nivec4(155520,959,76,33));\n#elif TUNE == 2\nfloat speed = 1.0;\nconst ivec4 data[] = ivec4[](\nivec4(481,78,35,40),\nivec4(646,57,46,31),\nivec4(785,44,36,46),\nivec4(930,40,42,41),\nivec4(1077,109,37,58),\nivec4(1229,153,46,48),\nivec4(1370,48,42,54),\nivec4(1517,48,38,59),\nivec4(1647,58,46,43),\nivec4(1794,60,39,57),\nivec4(1932,67,48,47),\nivec4(2082,54,40,62),\nivec4(2218,40,46,40),\nivec4(2362,122,41,66),\nivec4(2517,121,48,44),\nivec4(2646,50,46,46),\nivec4(2791,64,42,59),\nivec4(2939,46,48,29),\nivec4(3053,68,43,60),\nivec4(3180,88,52,45),\nivec4(3327,164,44,68),\nivec4(3467,141,52,48),\nivec4(3603,46,48,52),\nivec4(3752,83,45,64),\nivec4(3901,35,54,44),\nivec4(4043,49,46,67),\nivec4(4155,57,52,53),\nivec4(4311,93,35,55),\nivec4(4315,126,47,58),\nivec4(4450,51,54,53),\nivec4(4455,45,42,53),\nivec4(4594,190,48,68),\nivec4(4596,76,36,64),\nivec4(4744,111,46,51),\nivec4(4749,99,58,53),\nivec4(4859,54,42,57),\nivec4(4868,59,54,56),\nivec4(5017,69,37,59),\nivec4(5020,86,49,66),\nivec4(5161,46,46,46),\nivec4(5173,42,58,49),\nivec4(5305,94,50,68),\nivec4(5322,50,38,57),\nivec4(5433,50,48,47),\nivec4(5457,68,60,49),\nivec4(5578,84,39,60),\nivec4(5585,56,51,58),\nivec4(5725,54,46,51),\nivec4(5725,59,58,52),\nivec4(5859,64,52,60),\nivec4(5886,94,40,55),\nivec4(5988,62,60,57),\nivec4(6016,38,48,41),\nivec4(6136,84,41,69),\nivec4(6138,206,53,75),\nivec4(6268,111,52,48),\nivec4(6283,104,64,60),\nivec4(6370,72,48,51),\nivec4(6410,66,60,59),\nivec4(6538,81,42,61),\nivec4(6545,101,54,72),\nivec4(6678,57,52,53),\nivec4(6694,62,64,50),\nivec4(6819,103,55,68),\nivec4(6832,82,43,50),\nivec4(6942,57,48,60),\nivec4(6954,66,60,59),\nivec4(7086,101,56,72),\nivec4(7097,65,44,61),\nivec4(7213,51,52,55),\nivec4(7222,69,64,63),\nivec4(7363,176,57,78),\nivec4(7367,122,45,73),\nivec4(7491,106,52,60),\nivec4(7501,110,64,57),\nivec4(7593,76,48,64),\nivec4(7625,50,60,71),\nivec4(7756,51,46,56),\nivec4(7760,81,58,75),\nivec4(7898,47,54,57),\nivec4(7902,88,66,64),\nivec4(8040,68,59,67),\nivec4(8043,55,47,54),\nivec4(8154,43,52,59),\nivec4(8160,57,64,63),\nivec4(8290,84,48,72),\nivec4(8293,111,58,83),\nivec4(8434,61,54,59),\nivec4(8441,94,66,70),\nivec4(8566,50,52,56),\nivec4(8572,70,64,68),\nivec4(8697,71,49,69),\nivec4(8698,88,57,69),\nivec4(8821,73,66,59),\nivec4(8832,40,58,58),\nivec4(8983,36,56,63),\nivec4(8984,39,50,56),\nivec4(9093,77,58,70),\nivec4(9111,55,64,60),\nivec4(9231,44,51,66),\nivec4(9240,33,55,68),\nivec4(9370,95,66,67),\nivec4(9371,58,60,65),\nivec4(9506,63,52,82),\nivec4(9508,64,54,85),\nivec4(9648,142,70,71),\nivec4(9650,186,60,71),\nivec4(9795,48,66,68),\nivec4(9922,63,53,74),\nivec4(10061,74,64,64),\nivec4(10197,47,54,68),\nivec4(10204,46,47,59),\nivec4(10314,120,60,61),\nivec4(10483,45,48,59),\nivec4(10483,50,55,63),\nivec4(10599,70,64,58),\nivec4(10606,44,58,52),\nivec4(10765,46,56,65),\nivec4(10770,43,49,59),\nivec4(10868,97,66,63),\nivec4(10870,64,60,59),\nivec4(11038,134,57,63),\nivec4(11048,62,50,49),\nivec4(11133,124,70,67),\nivec4(11145,105,64,62),\nivec4(11265,46,54,58),\nivec4(11270,52,60,71),\nivec4(11395,49,51,63),\nivec4(11402,32,58,77),\nivec4(11534,35,66,74),\nivec4(11542,42,60,64),\nivec4(11693,45,59,72),\nivec4(11696,44,52,53),\nivec4(11796,65,70,69),\nivec4(11801,68,64,66),\nivec4(11915,43,53,73),\nivec4(11927,109,60,74),\nivec4(12055,45,72,70),\nivec4(12055,57,66,76),\nivec4(12184,75,47,84),\nivec4(12185,73,54,91),\nivec4(12320,115,76,81),\nivec4(12332,142,70,74),\nivec4(12461,62,72,77),\nivec4(12470,36,64,72),\nivec4(12600,44,55,75),\nivec4(12602,44,48,68),\nivec4(12733,40,70,80),\nivec4(12733,42,60,75),\nivec4(12883,45,56,84),\nivec4(12890,42,49,76),\nivec4(13015,85,66,77),\nivec4(13026,41,64,62),\nivec4(13138,63,50,91),\nivec4(13272,60,66,68),\nivec4(13290,49,60,67),\nivec4(13401,61,64,80),\nivec4(13413,38,58,70),\nivec4(13547,111,35,76),\nivec4(13557,126,63,93),\nivec4(13685,77,58,70),\nivec4(13702,52,42,62),\nivec4(13839,67,52,68),\nivec4(13853,66,36,66),\nivec4(13970,52,54,66),\nivec4(13977,40,46,61),\nivec4(14111,51,37,51),\nivec4(14121,48,53,59),\nivec4(14240,44,42,53),\nivec4(14249,45,58,57),\nivec4(14374,71,38,69),\nivec4(14389,97,54,72),\nivec4(14524,82,46,50),\nivec4(14528,99,64,59),\nivec4(14633,53,42,58),\nivec4(14651,76,60,59),\nivec4(14792,64,39,64),\nivec4(14805,97,55,63),\nivec4(14914,63,64,59),\nivec4(14933,50,48,36),\nivec4(15070,58,56,66),\nivec4(15078,75,40,42),\nivec4(15197,90,66,58),\nivec4(15205,50,46,50),\nivec4(15341,67,57,64),\nivec4(15361,64,41,55),\nivec4(15474,51,48,50),\nivec4(15483,52,64,61),\nivec4(15612,51,58,63),\nivec4(15617,64,42,62),\nivec4(15750,49,52,49),\nivec4(15756,55,66,56),\nivec4(15880,63,43,57),\nivec4(15881,116,59,70),\nivec4(15993,77,52,45),\nivec4(16027,94,66,46),\nivec4(16123,62,48,40),\nivec4(16134,57,64,58),\nivec4(16244,86,44,61),\nivec4(16260,89,60,70),\nivec4(16378,46,52,51),\nivec4(16385,56,70,66),\nivec4(16521,80,61,76),\nivec4(16535,64,45,60),\nivec4(16648,103,69,69),\nivec4(16654,52,54,63),\nivec4(16791,71,46,63),\nivec4(16801,76,62,69),\nivec4(16928,47,52,62),\nivec4(16928,91,68,72),\nivec4(17064,81,63,76),\nivec4(17067,66,47,64),\nivec4(17194,82,52,58),\nivec4(17195,120,67,67),\nivec4(17316,80,66,73),\nivec4(17323,58,48,57),\nivec4(17456,63,49,65),\nivec4(17457,62,44,58),\nivec4(17459,79,65,69),\nivec4(17580,57,71,74),\nivec4(17605,50,55,50),\nivec4(17729,55,66,70),\nivec4(17729,63,50,63),\nivec4(17732,45,45,54),\nivec4(17857,44,70,67),\nivec4(17872,32,54,55),\nivec4(17987,73,67,75),\nivec4(17991,68,46,62),\nivec4(18008,41,51,57),\nivec4(18127,82,69,73),\nivec4(18130,74,54,56),\nivec4(18259,76,68,73),\nivec4(18264,53,53,59),\nivec4(18389,96,67,62),\nivec4(18415,58,47,64),\nivec4(18526,81,73,65),\nivec4(18551,36,57,49),\nivec4(18669,80,68,74),\nivec4(18679,102,53,66),\nivec4(18682,65,48,60),\nivec4(18800,77,75,71),\nivec4(18808,37,55,61),\nivec4(18925,63,54,68),\nivec4(18928,82,69,73),\nivec4(18932,72,49,64),\nivec4(19055,47,57,61),\nivec4(19067,45,73,66),\nivec4(19071,47,67,60),\nivec4(19190,67,50,65),\nivec4(19204,72,55,63),\nivec4(19208,67,70,83),\nivec4(19331,96,69,81),\nivec4(19334,180,75,84),\nivec4(19342,118,61,68),\nivec4(19467,85,73,77),\nivec4(19472,106,57,67),\nivec4(19603,74,71,84),\nivec4(19608,61,56,58),\nivec4(19610,60,51,54),\nivec4(19740,48,63,57),\nivec4(19740,66,79,79),\nivec4(19874,87,72,79),\nivec4(19875,82,52,62),\nivec4(19889,62,57,58),\nivec4(20008,79,81,83),\nivec4(20014,45,61,57),\nivec4(20143,86,73,82),\nivec4(20149,73,58,65),\nivec4(20152,51,53,62),\nivec4(20261,97,79,85),\nivec4(20281,47,63,59),\nivec4(20393,92,74,73),\nivec4(20402,59,54,56),\nivec4(20407,101,59,61),\nivec4(20518,37,57,58),\nivec4(20521,47,75,75),\nivec4(20522,48,67,67),\nivec4(20659,51,48,76),\nivec4(20659,109,70,85),\nivec4(20660,118,76,80),\nivec4(20664,161,55,74),\nivec4(20789,100,69,82),\nivec4(20806,110,51,57),\nivec4(20916,35,61,58),\nivec4(20930,42,79,86),\nivec4(21049,53,49,74),\nivec4(21064,53,77,86),\nivec4(21067,47,71,84),\nivec4(21070,32,56,51),\nivec4(21193,79,73,74),\nivec4(21196,54,55,62),\nivec4(21324,70,72,71),\nivec4(21348,68,54,49),\nivec4(21367,36,50,27),\nivec4(21454,37,51,48),\nivec4(21455,57,67,62),\nivec4(21597,50,52,60),\nivec4(21597,56,73,69),\nivec4(21610,35,44,51),\nivec4(21705,47,49,63),\nivec4(21724,76,69,69),\nivec4(21851,74,45,69),\nivec4(21853,87,53,71),\nivec4(21860,80,74,74),\nivec4(21993,114,69,59),\nivec4(21994,76,67,57),\nivec4(22004,120,51,56),\nivec4(22113,70,49,58),\nivec4(22114,59,79,66),\nivec4(22119,42,75,60),\nivec4(22233,64,54,76),\nivec4(22234,69,46,72),\nivec4(22239,99,76,68),\nivec4(22243,53,73,67),\nivec4(22367,53,51,54),\nivec4(22378,62,69,70),\nivec4(22503,58,47,56),\nivec4(22511,55,55,52),\nivec4(22515,69,77,68),\nivec4(22519,53,74,58),\nivec4(22606,63,49,59),\nivec4(22643,50,67,61),\nivec4(22771,72,44,67),\nivec4(22771,93,78,81),\nivec4(22776,102,75,78),\nivec4(22784,108,48,62),\nivec4(22896,110,69,67),\nivec4(22905,113,51,63),\nivec4(23021,58,73,75),\nivec4(23049,38,57,49),\nivec4(23056,37,55,41),\nivec4(23149,61,45,64),\nivec4(23155,79,76,78),\nivec4(23157,118,79,85),\nivec4(23160,95,49,72),\nivec4(23285,49,54,62),\nivec4(23287,63,72,78),\nivec4(23417,106,80,84),\nivec4(23418,83,46,58),\nivec4(23418,87,50,60),\nivec4(23424,63,77,70),\nivec4(23552,62,52,56),\nivec4(23563,68,70,77),\nivec4(23697,163,81,85),\nivec4(23701,119,51,65),\nivec4(23704,72,78,76),\nivec4(23705,89,47,65),\nivec4(23828,53,54,70),\nivec4(23830,86,72,71),\nivec4(23958,123,82,79),\nivec4(23962,154,52,79),\nivec4(23962,172,79,80),\nivec4(23973,132,48,71),\nivec4(24103,100,70,78),\nivec4(24114,119,54,67),\nivec4(24215,67,58,65),\nivec4(24222,47,76,71),\nivec4(24345,99,53,73),\nivec4(24352,89,80,85),\nivec4(24353,154,83,87),\nivec4(24355,96,49,71),\nivec4(24480,56,72,80),\nivec4(24488,49,58,72),\nivec4(24618,86,79,91),\nivec4(24620,98,84,86),\nivec4(24627,142,48,69),\nivec4(24630,119,54,70),\nivec4(24742,51,76,77),\nivec4(24750,40,58,68),\nivec4(24872,98,85,86),\nivec4(24881,100,78,83),\nivec4(24890,79,47,76),\nivec4(24897,73,55,73),\nivec4(25003,72,52,68),\nivec4(25004,42,72,72),\nivec4(25148,83,56,78),\nivec4(25148,94,86,89),\nivec4(25152,57,46,71),\nivec4(25154,85,77,85),\nivec4(25272,54,48,65),\nivec4(25274,60,82,83),\nivec4(25425,71,87,97),\nivec4(25427,133,57,88),\nivec4(25428,127,76,97),\nivec4(25429,116,45,81),\nivec4(25559,153,53,69),\nivec4(25568,138,84,69),\nivec4(25687,56,80,73),\nivec4(25694,45,49,66),\nivec4(25826,71,58,89),\nivec4(25830,131,77,93),\nivec4(25831,132,88,94),\nivec4(25837,70,46,84),\nivec4(25955,50,82,80),\nivec4(25967,48,48,65),\nivec4(26091,97,78,95),\nivec4(26092,139,89,92),\nivec4(26102,123,59,84),\nivec4(26108,63,47,77),\nivec4(26222,57,49,74),\nivec4(26230,54,84,76),\nivec4(26357,138,90,91),\nivec4(26364,148,79,91),\nivec4(26372,103,48,83),\nivec4(26372,122,60,90),\nivec4(26483,70,53,68),\nivec4(26491,68,85,79),\nivec4(26640,60,80,97),\nivec4(26641,63,91,96),\nivec4(26644,115,61,90),\nivec4(26654,113,49,83),\nivec4(26699,45,51,23),\nivec4(26704,0,89,19),\nivec4(26770,123,84,81),\nivec4(26773,150,56,75),\nivec4(26876,62,89,85),\nivec4(26885,66,53,71),\nivec4(27021,67,92,96),\nivec4(27025,66,81,94),\nivec4(27031,69,60,83),\nivec4(27032,105,87,89),\nivec4(27034,71,50,81),\nivec4(27148,87,89,75),\nivec4(27153,58,56,77),\nivec4(27284,121,91,81),\nivec4(27290,144,59,85),\nivec4(27291,83,51,81),\nivec4(27293,51,86,75),\nivec4(27298,39,82,72),\nivec4(27392,69,88,77),\nivec4(27401,79,53,73),\nivec4(27540,53,90,85),\nivec4(27547,36,83,74),\nivec4(27552,42,85,66),\nivec4(27556,43,52,68),\nivec4(27567,30,58,60),\nivec4(27682,134,93,99),\nivec4(27686,105,56,78),\nivec4(27796,45,53,71),\nivec4(27803,67,87,82),\nivec4(27926,52,57,70),\nivec4(27942,68,89,94),\nivec4(27945,71,84,82),\nivec4(27948,47,54,68),\nivec4(28058,149,94,110),\nivec4(28060,104,46,81),\nivec4(28191,44,85,61),\nivec4(28192,52,88,66),\nivec4(28200,48,58,67),\nivec4(28228,70,53,52),\nivec4(28308,127,47,77),\nivec4(28328,142,95,105),\nivec4(28437,53,86,71),\nivec4(28461,50,52,62),\nivec4(28465,43,87,65),\nivec4(28474,53,59,68),\nivec4(28584,102,48,78),\nivec4(28593,142,96,111),\nivec4(28703,62,87,84),\nivec4(28717,99,51,62),\nivec4(28739,82,60,70),\nivec4(28850,172,97,103),\nivec4(28854,194,49,75),\nivec4(28869,33,98,82),\nivec4(28948,95,89,78),\nivec4(28967,93,50,74),\nivec4(29124,63,44,95),\nivec4(29126,18,98,102),\nivec4(29128,38,88,103),\nivec4(29128,46,92,100),\nivec4(29128,58,51,91),\nivec4(29280,74,55,82),\nivec4(29400,48,52,76),\nivec4(29417,47,45,64),\nivec4(29526,37,59,77),\nivec4(29666,40,53,66),\nivec4(29675,35,46,61),\nivec4(29798,43,61,60),\nivec4(29806,39,55,62),\nivec4(29939,37,47,62),\nivec4(29941,35,54,63),\nivec4(30060,92,65,55),\nivec4(30072,52,59,60),\nivec4(30211,36,48,76),\nivec4(30218,33,55,67),\nivec4(30332,111,67,61),\nivec4(30361,114,61,48),\nivec4(30473,47,57,58),\nivec4(30474,42,59,53),\nivec4(30618,71,49,71),\nivec4(30625,56,56,79),\nivec4(30744,41,59,73),\nivec4(30895,52,57,70),\nivec4(30895,54,50,69),\nivec4(31025,90,65,59),\nivec4(31038,50,59,52),\nivec4(31145,140,51,67),\nivec4(31151,35,58,72),\nivec4(31288,37,53,52),\nivec4(31290,35,55,61),\nivec4(31429,57,59,89),\nivec4(31430,70,52,76),\nivec4(31556,54,55,81),\nivec4(31556,195,49,76),\nivec4(31698,91,47,68),\nivec4(31709,33,41,59),\nivec4(31838,89,45,68),\nivec4(31848,47,53,78),\nivec4(31859,40,60,75),\nivec4(31968,89,49,63),\nivec4(32125,96,46,60),\nivec4(32134,26,61,77),\nivec4(32148,38,54,64),\nivec4(32240,97,43,68),\nivec4(32263,50,59,76),\nivec4(32385,67,39,82),\nivec4(32395,81,59,74),\nivec4(32398,80,55,66),\nivec4(32520,89,47,70),\nivec4(32540,83,61,74),\nivec4(32667,82,67,72),\nivec4(32682,139,59,66),\nivec4(32826,79,40,74),\nivec4(32828,67,63,71),\nivec4(32835,74,56,62),\nivec4(32949,47,49,63),\nivec4(32954,44,65,69),\nivec4(33106,59,57,67),\nivec4(33107,87,64,71),\nivec4(33109,47,41,76),\nivec4(33112,37,36,78),\nivec4(33235,74,67,60),\nivec4(33384,67,58,51),\nivec4(33389,73,65,62),\nivec4(33394,61,37,71),\nivec4(33401,69,42,71),\nivec4(33515,48,71,67),\nivec4(33655,54,43,68),\nivec4(33657,36,38,74),\nivec4(33658,218,66,77),\nivec4(33659,37,59,63),\nivec4(33782,176,65,70),\nivec4(33789,182,71,71),\nivec4(33937,40,61,56),\nivec4(34077,95,60,76),\nivec4(34081,57,70,78),\nivec4(34082,41,39,64),\nivec4(34098,70,44,50),\nivec4(34199,37,64,69),\nivec4(34218,89,36,70),\nivec4(34329,69,71,82),\nivec4(34340,52,61,69),\nivec4(34351,67,40,49),\nivec4(34355,90,45,54),\nivec4(34454,65,65,71),\nivec4(34463,60,37,81),\nivec4(34586,78,72,80),\nivec4(34589,81,62,75),\nivec4(34605,93,41,62),\nivec4(34615,111,46,61),\nivec4(34704,82,66,74),\nivec4(34718,53,38,75),\nivec4(34861,82,42,66),\nivec4(34861,146,47,66),\nivec4(34862,60,73,74),\nivec4(34868,59,63,68),\nivec4(34946,78,67,68),\nivec4(34998,94,39,78),\nivec4(35088,98,74,75),\nivec4(35134,49,64,38),\nivec4(35155,114,43,53),\nivec4(35183,71,48,30),\nivec4(35189,59,47,36),\nivec4(35211,121,68,80),\nivec4(35272,37,40,70),\nivec4(35337,117,70,79),\nivec4(35481,86,73,81),\nivec4(35498,71,65,65),\nivec4(35510,134,49,68),\nivec4(35512,119,44,64),\nivec4(35571,72,68,67),\nivec4(35632,52,41,72),\nivec4(35711,70,72,87),\nivec4(35714,87,66,87),\nivec4(35756,106,50,66),\nivec4(35764,68,45,56),\nivec4(35861,57,70,83),\nivec4(35866,35,42,78),\nivec4(35971,0,43,6),\nivec4(35990,104,67,77),\nivec4(35994,141,71,84),\nivec4(36008,126,53,66),\nivec4(36045,113,47,48),\nivec4(36095,56,69,79),\nivec4(36139,43,51,56),\nivec4(36239,39,52,81),\nivec4(36244,37,47,75),\nivec4(36256,34,70,77),\nivec4(36385,146,74,87),\nivec4(36388,121,64,82),\nivec4(36499,57,67,58),\nivec4(36505,93,73,81),\nivec4(36637,132,68,13),\nivec4(36657,146,76,88),\nivec4(36673,104,65,67),\nivec4(36770,86,73,76),\nivec4(36917,94,69,75),\nivec4(36923,79,77,90),\nivec4(36930,98,66,79),\nivec4(37038,167,85,70),\nivec4(37039,182,81,73),\nivec4(37049,123,75,76),\nivec4(37049,173,71,73),\nivec4(37178,58,78,74),\nivec4(37178,78,70,73),\nivec4(37191,34,67,51),\nivec4(37207,37,68,37),\nivec4(37310,165,76,96),\nivec4(37314,145,86,87),\nivec4(37314,212,82,93),\nivec4(37319,137,73,80),\nivec4(37441,67,70,77),\nivec4(37590,85,79,91),\nivec4(37590,113,87,94),\nivec4(37592,124,77,84),\nivec4(37596,104,68,82),\nivec4(37597,227,83,85),\nivec4(37606,117,71,73),\nivec4(37731,114,73,74),\nivec4(37832,59,80,87),\nivec4(37860,86,69,73),\nivec4(37866,77,72,71),\nivec4(37959,86,78,87),\nivec4(37962,136,88,80),\nivec4(37964,166,84,79),\nivec4(37967,91,77,67),\nivec4(38090,132,73,69),\nivec4(38092,109,70,69),\nivec4(38093,52,81,70),\nivec4(38226,154,79,86),\nivec4(38226,188,85,83),\nivec4(38230,126,89,82),\nivec4(38233,140,76,74),\nivec4(38346,71,82,75),\nivec4(38364,150,74,67),\nivec4(38375,109,71,66),\nivec4(38487,48,83,96),\nivec4(38488,75,90,99),\nivec4(38491,91,86,86),\nivec4(38495,81,80,86),\nivec4(38652,171,77,68),\nivec4(38781,66,72,63),\nivec4(38789,106,83,93),\nivec4(38792,100,84,89),\nivec4(38793,127,75,66),\nivec4(38907,54,79,68),\nivec4(38917,58,81,85),\nivec4(38919,35,85,71),\nivec4(38921,64,89,79),\nivec4(39036,98,73,77),\nivec4(39044,89,84,96),\nivec4(39048,139,76,73),\nivec4(39187,50,82,79),\nivec4(39320,101,83,95),\nivec4(39321,171,88,97),\nivec4(39324,115,85,86),\nivec4(39328,109,74,70),\nivec4(39328,109,77,77),\nivec4(39442,73,79,78),\nivec4(39594,93,86,98),\nivec4(39595,93,75,69),\nivec4(39598,160,78,77),\nivec4(39718,56,85,88),\nivec4(39722,34,83,70),\nivec4(39740,30,77,51),\nivec4(39740,30,84,47),\nivec4(39759,37,76,37),\nivec4(39846,57,87,95),\nivec4(39846,99,76,79),\nivec4(39851,206,79,82),\nivec4(39979,200,90,82),\nivec4(39982,155,85,99),\nivec4(39982,203,92,94),\nivec4(39994,163,77,60),\nivec4(40104,42,80,80),\nivec4(40229,107,77,81),\nivec4(40237,142,83,96),\nivec4(40242,172,91,104),\nivec4(40243,123,86,101),\nivec4(40244,73,72,82),\nivec4(40247,120,93,95),\nivec4(40393,102,82,76),\nivec4(40495,78,84,99),\nivec4(40501,93,73,73),\nivec4(40506,76,78,69),\nivec4(40611,165,94,99),\nivec4(40618,45,80,85),\nivec4(40658,55,92,23),\nivec4(40740,74,85,84),\nivec4(40747,95,79,81),\nivec4(40758,79,74,65),\nivec4(40863,120,93,70),\nivec4(40865,17,75,39),\nivec4(40867,151,95,71),\nivec4(40883,62,82,82),\nivec4(40886,38,76,64),\nivec4(40988,38,86,71),\nivec4(40998,85,75,71),\nivec4(41020,59,80,79),\nivec4(41111,130,96,98),\nivec4(41112,85,89,101),\nivec4(41118,185,94,94),\nivec4(41121,113,82,98),\nivec4(41244,85,80,75),\nivec4(41369,143,90,94),\nivec4(41369,151,97,92),\nivec4(41370,119,76,77),\nivec4(41370,251,95,77),\nivec4(41381,110,81,81),\nivec4(41383,105,87,94),\nivec4(41505,103,80,74),\nivec4(41614,77,88,83),\nivec4(41627,68,77,72),\nivec4(41632,125,82,85),\nivec4(41735,94,98,83),\nivec4(41738,93,96,80),\nivec4(41744,88,80,78),\nivec4(41853,144,78,84),\nivec4(41869,45,89,81),\nivec4(41870,172,83,77),\nivec4(41987,150,82,84),\nivec4(41996,135,99,87),\nivec4(42000,177,92,98),\nivec4(42001,178,97,96),\nivec4(42016,116,100,82),\nivec4(42045,105,98,56),\nivec4(42121,72,86,83),\nivec4(42258,91,79,86),\nivec4(42259,122,84,90),\nivec4(42260,112,93,42),\nivec4(42261,123,90,102),\nivec4(42261,143,98,81),\nivec4(42261,178,100,86),\nivec4(42386,74,86,80),\nivec4(42513,123,80,79),\nivec4(42516,129,85,78),\nivec4(42519,101,91,84),\nivec4(42632,74,88,85),\nivec4(42634,106,101,85),\nivec4(42775,110,92,90),\nivec4(42776,90,81,77),\nivec4(42777,124,86,80),\nivec4(42877,146,100,63),\nivec4(42893,152,88,87),\nivec4(42899,123,102,77),\nivec4(43019,69,82,84),\nivec4(43033,37,91,68),\nivec4(43033,64,87,80),\nivec4(43151,133,86,100),\nivec4(43159,103,101,110),\nivec4(43159,137,96,110),\nivec4(43163,56,103,102),\nivec4(43201,32,98,46),\nivec4(43284,74,88,88),\nivec4(43403,140,85,78),\nivec4(43408,147,83,78),\nivec4(43423,59,90,95),\nivec4(43538,45,88,78),\nivec4(43540,81,104,101),\nivec4(43543,81,102,88),\nivec4(43549,66,97,85),\nivec4(43670,110,89,97),\nivec4(43681,95,84,84),\nivec4(43728,18,85,11),\nivec4(43781,60,88,81),\nivec4(43812,67,92,104),\nivec4(43911,159,103,98),\nivec4(43913,61,85,99),\nivec4(43914,29,93,103),\nivec4(43915,71,98,89),\nivec4(43926,136,105,91),\nivec4(43958,28,91,48),\nivec4(43964,0,87,38),\nivec4(44013,53,84,11),\nivec4(44046,137,96,96),\nivec4(44167,65,102,100),\nivec4(44202,42,103,64),\nivec4(44218,37,104,41),\nivec4(44337,139,22,109),\nivec4(44341,53,99,117),\nivec4(44341,114,106,114),\nivec4(44343,104,104,107),\nivec4(44344,125,107,106),\nivec4(44350,46,21,83),\nivec4(44353,63,100,99),\nivec4(44358,27,108,83),\nivec4(44387,33,105,43),\nivec4(44400,70,108,49),\nivec4(44490,83,33,71),\nivec4(44653,79,23,64),\nivec4(44728,48,29,53),\nivec4(44870,67,24,60),\nivec4(45001,90,33,48),\nivec4(45124,60,29,55),\nivec4(45264,70,25,60),\nivec4(45412,52,33,43),\nivec4(45538,75,26,58),\nivec4(45688,61,35,40),\nivec4(45798,102,27,52),\nivec4(45941,57,33,48),\nivec4(46075,122,28,65),\nivec4(46221,121,35,47),\nivec4(46357,52,33,50),\nivec4(46473,117,29,58),\nivec4(46619,67,35,44),\nivec4(46755,78,30,66),\nivec4(46885,56,39,54),\nivec4(47033,69,31,66),\nivec4(47159,97,39,51),\nivec4(47292,56,35,49),\nivec4(47421,69,32,58),\nivec4(47570,54,39,44),\nivec4(47722,59,33,46),\nivec4(47861,54,41,45),\nivec4(47990,68,34,61),\nivec4(48120,72,41,43),\nivec4(48250,81,39,59),\nivec4(48258,521,60,65),\nivec4(48272,367,59,60),\nivec4(48415,82,35,48),\nivec4(48551,60,41,46),\nivec4(48677,76,39,57),\nivec4(48789,98,36,59),\nivec4(48922,56,45,45),\nivec4(49030,100,39,52),\nivec4(49074,92,61,54),\nivec4(49178,108,37,46),\nivec4(49195,68,62,61),\nivec4(49291,39,41,60),\nivec4(49302,148,63,69),\nivec4(49307,126,64,64),\nivec4(49436,97,31,69),\nivec4(49438,93,38,70),\nivec4(49441,99,65,76),\nivec4(49549,46,41,67),\nivec4(49556,52,66,76),\nivec4(49700,361,60,70),\nivec4(49700,422,67,66),\nivec4(49701,81,39,64),\nivec4(49706,66,32,55),\nivec4(49707,390,62,63),\nivec4(49852,135,42,50),\nivec4(49964,47,41,52),\nivec4(50101,106,40,69),\nivec4(50108,74,33,51),\nivec4(50238,49,42,63),\nivec4(50356,96,41,61),\nivec4(50366,128,34,57),\nivec4(50481,55,42,60),\nivec4(50497,93,66,52),\nivec4(50503,108,68,54),\nivec4(50615,101,67,68),\nivec4(50622,87,35,65),\nivec4(50625,67,43,68),\nivec4(50741,65,40,64),\nivec4(50744,106,68,72),\nivec4(50863,120,69,72),\nivec4(50872,91,44,63),\nivec4(50885,68,36,51),\nivec4(50972,63,42,65),\nivec4(50993,101,70,74),\nivec4(51096,66,46,56),\nivec4(51111,57,71,69),\nivec4(51224,65,45,60),\nivec4(51227,30,72,73),\nivec4(51256,83,37,50),\nivec4(51346,144,73,76),\nivec4(51352,129,75,86),\nivec4(51358,61,48,54),\nivec4(51477,161,74,83),\nivec4(51481,155,81,80),\nivec4(51503,97,46,53),\nivec4(51507,91,38,62),\nivec4(51598,65,80,85),\nivec4(51612,51,48,63),\nivec4(51735,360,76,89),\nivec4(51735,423,79,93),\nivec4(51742,92,47,71),\nivec4(51756,91,39,62),\nivec4(51854,79,48,60),\nivec4(51980,86,46,59),\nivec4(52125,105,49,71),\nivec4(52128,73,40,60),\nivec4(52234,71,46,57),\nivec4(52236,137,78,79),\nivec4(52240,39,77,75),\nivec4(52348,113,79,86),\nivec4(52353,56,41,62),\nivec4(52362,63,50,57),\nivec4(52434,112,42,61),\nivec4(52468,57,76,73),\nivec4(52470,156,84,79),\nivec4(52590,103,43,60),\nivec4(52594,53,83,79),\nivec4(52599,90,39,60),\nivec4(52728,361,77,98),\nivec4(52729,441,82,97),\nivec4(52734,79,49,68),\nivec4(52858,113,45,57),\nivec4(52967,62,40,59),\nivec4(52973,63,44,62),\nivec4(53109,90,49,64),\nivec4(53210,95,43,54),\nivec4(53322,77,41,55),\nivec4(53338,82,44,68),\nivec4(53346,85,86,91),\nivec4(53360,85,85,81),\nivec4(53471,497,81,88),\nivec4(53472,535,78,90),\nivec4(53473,61,45,68),\nivec4(53624,39,43,64),\nivec4(53764,52,45,64),\nivec4(53766,49,42,79),\nivec4(53891,68,37,86),\nivec4(54023,57,47,78),\nivec4(54024,65,41,79),\nivec4(54152,69,38,85),\nivec4(54284,49,48,70),\nivec4(54286,182,40,79),\nivec4(54454,93,39,59),\nivec4(54530,162,77,81),\nivec4(54532,91,83,74),\nivec4(54532,133,86,85),\nivec4(54537,103,41,69),\nivec4(54664,119,85,81),\nivec4(54675,50,49,69),\nivec4(54685,64,40,61),\nivec4(54785,56,43,72),\nivec4(54796,35,84,68),\nivec4(54801,124,76,75),\nivec4(54915,150,75,81),\nivec4(54937,60,41,54),\nivec4(54943,55,50,52),\nivec4(55029,33,74,76),\nivec4(55029,45,45,60),\nivec4(55044,34,76,78),\nivec4(55161,97,51,68),\nivec4(55166,58,42,65),\nivec4(55170,138,80,86),\nivec4(55171,64,73,81),\nivec4(55289,42,43,68),\nivec4(55299,36,79,71),\nivec4(55416,440,72,91),\nivec4(55419,461,77,88),\nivec4(55420,487,81,88),\nivec4(55444,47,44,79),\nivec4(55446,45,52,75),\nivec4(55570,166,45,65),\nivec4(55676,96,43,64),\nivec4(55798,50,41,49),\nivec4(55815,77,53,83),\nivec4(55820,109,46,76),\nivec4(55931,131,42,72),\nivec4(56047,163,43,65),\nivec4(56185,43,47,73),\nivec4(56318,1201,75,95),\nivec4(56318,1241,83,93),\nivec4(56318,1319,87,92),\nivec4(56330,56,51,83),\nivec4(56343,39,39,68),\nivec4(56350,32,44,59),\nivec4(56442,131,45,64),\nivec4(56575,60,41,66),\nivec4(56705,72,52,84),\nivec4(56716,55,40,75),\nivec4(56828,44,46,63),\nivec4(56963,94,41,79),\nivec4(56966,83,53,77),\nivec4(57072,59,48,66),\nivec4(57108,418,84,72),\nivec4(57108,431,78,74),\nivec4(57226,106,42,78),\nivec4(57226,143,54,87),\nivec4(57266,53,44,46),\nivec4(57380,150,46,68),\nivec4(57498,93,48,74),\nivec4(57634,116,43,74),\nivec4(57635,41,55,78),\nivec4(57748,544,79,98),\nivec4(57748,558,82,99),\nivec4(57749,549,76,93),\nivec4(57750,567,88,95),\nivec4(57767,142,46,69),\nivec4(57831,64,52,66),\nivec4(57915,56,48,58),\nivec4(58022,53,56,84),\nivec4(58033,44,44,52),\nivec4(58051,39,54,47),\nivec4(58153,141,46,59),\nivec4(58247,60,54,55),\nivec4(58264,52,48,72),\nivec4(58406,80,45,75),\nivec4(58409,87,55,83),\nivec4(58512,51,49,76),\nivec4(58662,83,54,85),\nivec4(58662,535,77,94),\nivec4(58664,91,46,82),\nivec4(58664,554,80,93),\nivec4(58666,545,85,88),\nivec4(58667,494,89,91),\nivec4(58784,59,51,72),\nivec4(58925,119,53,93),\nivec4(58936,118,47,84),\nivec4(59055,89,51,66),\nivec4(59056,89,49,73),\nivec4(59170,62,55,73),\nivec4(59306,96,45,74),\nivec4(59312,83,52,73),\nivec4(59315,62,48,67),\nivec4(59444,38,55,57),\nivec4(59562,56,51,60),\nivec4(59566,67,46,58),\nivec4(59680,61,66,67),\nivec4(59693,36,61,50),\nivec4(59698,39,57,50),\nivec4(59810,100,52,55),\nivec4(59819,91,67,64),\nivec4(59823,69,47,53),\nivec4(59941,40,55,57),\nivec4(59946,40,63,67),\nivec4(60073,62,68,83),\nivec4(60075,71,48,57),\nivec4(60077,39,62,67),\nivec4(60079,54,53,55),\nivec4(60176,58,57,53),\nivec4(60211,35,73,74),\nivec4(60326,51,55,48),\nivec4(60338,103,69,64),\nivec4(60340,34,63,58),\nivec4(60441,55,54,59),\nivec4(60465,36,65,56),\nivec4(60485,40,49,38),\nivec4(60588,47,60,52),\nivec4(60594,39,64,65),\nivec4(60596,40,70,71),\nivec4(60717,91,50,56),\nivec4(60720,123,71,82),\nivec4(60736,47,55,42),\nivec4(60846,48,58,56),\nivec4(60850,52,69,65),\nivec4(60860,33,65,49),\nivec4(60984,56,56,67),\nivec4(60991,88,71,78),\nivec4(60996,80,51,59),\nivec4(61003,48,66,68),\nivec4(61105,41,60,50),\nivec4(61115,53,63,76),\nivec4(61231,90,72,76),\nivec4(61239,64,67,64),\nivec4(61242,57,50,55),\nivec4(61249,52,56,65),\nivec4(61358,57,71,68),\nivec4(61367,50,63,68),\nivec4(61379,63,57,57),\nivec4(61392,55,52,52),\nivec4(61485,40,54,60),\nivec4(61493,97,73,72),\nivec4(61498,49,68,67),\nivec4(61617,65,63,70),\nivec4(61629,48,53,62),\nivec4(61636,77,58,66),\nivec4(61739,96,69,68),\nivec4(61741,97,74,62),\nivec4(61779,35,60,44),\nivec4(61884,57,59,59),\nivec4(61885,114,65,65),\nivec4(61890,64,54,55),\nivec4(61999,46,75,68),\nivec4(62000,59,60,53),\nivec4(62138,72,54,62),\nivec4(62142,64,50,56),\nivec4(62144,49,70,71),\nivec4(62150,104,76,77),\nivec4(62273,48,60,52),\nivec4(62281,37,71,68),\nivec4(62382,71,56,64),\nivec4(62386,78,77,74),\nivec4(62388,52,72,71),\nivec4(62502,55,69,74),\nivec4(62527,93,51,62),\nivec4(62528,51,55,52),\nivec4(62626,62,78,78),\nivec4(62630,83,73,71),\nivec4(62638,55,60,55),\nivec4(62751,64,54,68),\nivec4(62765,42,75,64),\nivec4(62770,37,71,60),\nivec4(62868,68,74,70),\nivec4(62882,89,79,70),\nivec4(62901,52,56,59),\nivec4(62909,49,52,51),\nivec4(63014,49,69,64),\nivec4(63014,53,63,62),\nivec4(63137,45,80,78),\nivec4(63146,40,75,69),\nivec4(63146,89,57,59),\nivec4(63153,62,53,57),\nivec4(63270,41,78,79),\nivec4(63274,151,71,78),\nivec4(63282,54,63,63),\nivec4(63306,115,77,71),\nivec4(63405,41,72,76),\nivec4(63428,57,58,56),\nivec4(63428,90,54,64),\nivec4(63534,73,81,83),\nivec4(63540,64,71,78),\nivec4(63541,50,65,66),\nivec4(63556,84,76,70),\nivec4(63684,56,78,78),\nivec4(63684,62,55,60),\nivec4(63696,69,60,57),\nivec4(63806,79,72,87),\nivec4(63807,85,82,91),\nivec4(63814,58,63,60),\nivec4(63937,85,76,73),\nivec4(63942,98,60,53),\nivec4(63960,42,78,60),\nivec4(63977,49,56,48),\nivec4(64070,56,73,80),\nivec4(64073,46,65,62),\nivec4(64077,72,83,82),\nivec4(64206,87,57,66),\nivec4(64207,47,78,69),\nivec4(64217,37,76,47),\nivec4(64217,95,61,66),\nivec4(64325,94,63,68),\nivec4(64327,73,74,79),\nivec4(64333,43,84,77),\nivec4(64463,118,76,81),\nivec4(64467,109,62,61),\nivec4(64481,84,58,55),\nivec4(64578,34,78,76),\nivec4(64605,61,69,71),\nivec4(64706,95,75,92),\nivec4(64709,99,80,84),\nivec4(64711,110,85,81),\nivec4(64730,102,63,69),\nivec4(64733,94,59,68),\nivec4(64817,192,78,72),\nivec4(64847,63,69,70),\nivec4(64952,70,86,70),\nivec4(64952,86,76,73),\nivec4(64965,91,65,70),\nivec4(65091,52,82,82),\nivec4(65091,83,64,74),\nivec4(65095,71,60,66),\nivec4(65211,79,71,74),\nivec4(65212,67,77,81),\nivec4(65217,38,87,79),\nivec4(65338,102,65,70),\nivec4(65346,117,84,84),\nivec4(65352,87,61,66),\nivec4(65356,162,82,75),\nivec4(65468,62,72,79),\nivec4(65471,40,76,71),\nivec4(65588,42,62,72),\nivec4(65591,163,83,84),\nivec4(65593,146,88,82),\nivec4(65596,83,66,76),\nivec4(65597,151,78,87),\nivec4(65713,73,82,79),\nivec4(65727,95,73,80),\nivec4(65840,57,70,84),\nivec4(65857,111,89,93),\nivec4(65860,126,79,95),\nivec4(65911,0,88,31),\nivec4(65969,65,84,82),\nivec4(65971,65,67,84),\nivec4(65982,62,61,78),\nivec4(66086,58,71,84),\nivec4(66104,84,80,99),\nivec4(66108,64,85,87),\nivec4(66109,116,90,95),\nivec4(66223,65,82,80),\nivec4(66232,114,68,89),\nivec4(66235,119,60,77),\nivec4(66339,158,86,81),\nivec4(66345,119,81,86),\nivec4(66347,46,64,69),\nivec4(66347,56,91,78),\nivec4(66473,67,88,78),\nivec4(66480,156,69,93),\nivec4(66491,104,59,85),\nivec4(66596,79,82,91),\nivec4(66621,120,66,80),\nivec4(66629,107,62,65),\nivec4(66729,114,87,75),\nivec4(66730,65,64,72),\nivec4(66740,115,83,72),\nivec4(66741,130,92,64),\nivec4(66821,44,70,90),\nivec4(66823,72,90,78),\nivec4(66852,28,58,57),\nivec4(66945,214,89,100),\nivec4(66946,185,83,107),\nivec4(66947,165,84,100),\nivec4(66950,168,68,90),\nivec4(66951,158,93,96),\nivec4(66955,152,62,73),\nivec4(67077,116,64,83),\nivec4(67218,54,71,88),\nivec4(67222,90,59,79),\nivec4(67345,126,65,77),\nivec4(67463,35,67,68),\nivec4(67463,56,61,76),\nivec4(67471,259,53,99),\nivec4(67476,113,55,89),\nivec4(67514,0,52,33),\nivec4(67622,96,72,89),\nivec4(67629,136,60,76),\nivec4(67686,44,62,27),\nivec4(67736,64,65,69),\nivec4(67743,61,61,72),\nivec4(67898,95,73,83),\nivec4(67909,109,62,62),\nivec4(68009,44,67,63),\nivec4(68113,135,54,71),\nivec4(68120,64,74,88),\nivec4(68124,58,63,85),\nivec4(68150,38,56,45),\nivec4(68252,116,55,72),\nivec4(68263,137,65,40),\nivec4(68277,90,67,62),\nivec4(68351,62,71,74),\nivec4(68367,99,56,78),\nivec4(68494,70,57,94),\nivec4(68514,50,65,68),\nivec4(68537,35,73,47),\nivec4(68539,100,71,68),\nivec4(68552,38,70,22),\nivec4(68621,150,58,68),\nivec4(68623,98,56,68),\nivec4(68730,104,66,76),\nivec4(68735,94,57,87),\nivec4(68739,69,76,80),\nivec4(68849,132,58,62),\nivec4(68858,84,73,79),\nivec4(68859,106,59,59),\nivec4(68890,52,60,42),\nivec4(68978,75,60,68),\nivec4(68980,100,67,76),\nivec4(68983,133,77,87),\nivec4(69077,67,71,73),\nivec4(69097,86,61,81),\nivec4(69229,467,59,81),\nivec4(69233,394,55,89),\nivec4(69233,469,62,91),\nivec4(69245,89,78,85),\nivec4(69260,68,68,70),\nivec4(69362,146,73,72),\nivec4(69482,62,77,73),\nivec4(69501,47,71,59),\nivec4(69604,139,69,83),\nivec4(69611,155,79,90),\nivec4(69741,75,73,78),\nivec4(69903,124,80,84),\nivec4(69906,79,70,83),\nivec4(69992,75,73,70),\nivec4(69999,42,77,74),\nivec4(70130,153,63,83),\nivec4(70137,151,81,95),\nivec4(70144,110,61,69),\nivec4(70160,50,69,60),\nivec4(70160,94,71,74),\nivec4(70210,48,79,8),\nivec4(70258,146,79,32),\nivec4(70267,130,62,79),\nivec4(70378,95,73,73),\nivec4(70387,101,63,85),\nivec4(70517,63,64,84),\nivec4(70517,96,82,91),\nivec4(70522,61,72,83),\nivec4(70633,125,66,75),\nivec4(70637,70,65,49),\nivec4(70641,85,77,73),\nivec4(70769,87,73,79),\nivec4(70774,103,83,89),\nivec4(70775,49,67,70),\nivec4(70801,26,69,62),\nivec4(70889,100,70,78),\nivec4(70905,38,69,67),\nivec4(70905,78,79,79),\nivec4(71017,73,71,73),\nivec4(71028,152,74,78),\nivec4(71029,93,84,93),\nivec4(71134,114,72,72),\nivec4(71161,142,79,75),\nivec4(71262,49,77,77),\nivec4(71263,141,66,103),\nivec4(71267,340,73,80),\nivec4(71401,85,85,98),\nivec4(71408,109,75,86),\nivec4(71510,156,82,84),\nivec4(71532,143,72,74),\nivec4(71642,76,79,73),\nivec4(71654,84,77,68),\nivec4(71749,152,76,80),\nivec4(71754,159,86,96),\nivec4(71760,994,68,92),\nivec4(71760,1083,71,81),\nivec4(71761,947,65,99),\nivec4(71888,175,82,79),\nivec4(72019,66,78,73),\nivec4(72024,78,80,70),\nivec4(72149,112,87,100),\nivec4(72152,108,77,89),\nivec4(72258,71,84,68),\nivec4(72259,83,80,72),\nivec4(72405,147,88,102),\nivec4(72407,119,78,85),\nivec4(72524,102,86,57),\nivec4(72546,102,84,72),\nivec4(72673,127,89,104),\nivec4(72673,132,79,82),\nivec4(72770,196,86,76),\nivec4(72907,90,80,73),\nivec4(72921,83,82,67),\nivec4(73045,122,90,100),\nivec4(73064,51,79,79),\nivec4(73079,94,80,61),\nivec4(73160,69,85,84),\nivec4(73293,127,91,97),\nivec4(73296,131,80,91),\nivec4(73413,73,87,80),\nivec4(73415,123,74,92),\nivec4(73532,115,73,78),\nivec4(73539,120,75,74),\nivec4(73546,116,92,91),\nivec4(73556,81,81,79),\nivec4(73647,49,72,88),\nivec4(73647,140,76,82),\nivec4(73652,71,87,78),\nivec4(73776,127,91,94),\nivec4(73777,93,82,94),\nivec4(73785,129,77,82),\nivec4(73798,120,71,83),\nivec4(73892,125,87,88),\nivec4(73902,82,70,85),\nivec4(74019,106,85,62),\nivec4(74030,101,69,106),\nivec4(74031,66,91,93),\nivec4(74037,122,76,101),\nivec4(74073,54,70,30),\nivec4(74165,106,83,77),\nivec4(74166,122,90,100),\nivec4(74301,43,88,67),\nivec4(74306,37,89,65),\nivec4(74408,160,89,92),\nivec4(74410,98,84,74),\nivec4(74517,71,88,89),\nivec4(74676,33,85,76),\nivec4(74680,61,79,98),\nivec4(74685,212,73,89),\nivec4(74701,60,88,79),\nivec4(74715,78,87,39),\nivec4(74802,65,90,93),\nivec4(74922,134,68,103),\nivec4(74926,205,84,86),\nivec4(74928,221,74,62),\nivec4(74933,228,76,72),\nivec4(74983,0,75,29),\nivec4(75060,125,91,79),\nivec4(75067,117,86,76),\nivec4(75183,45,88,78),\nivec4(75314,115,87,84),\nivec4(75314,140,92,89),\nivec4(75421,64,90,85),\nivec4(75556,82,93,96),\nivec4(75557,144,88,92),\nivec4(75680,152,94,93),\nivec4(75796,69,92,81),\nivec4(75798,158,82,97),\nivec4(75799,88,90,82),\nivec4(75914,79,81,89),\nivec4(75917,66,95,93),\nivec4(75922,50,89,74),\nivec4(76021,138,80,94),\nivec4(76039,37,78,76),\nivec4(76058,46,94,79),\nivec4(76146,105,84,88),\nivec4(76154,33,77,71),\nivec4(76225,104,88,81),\nivec4(76241,88,97,91),\nivec4(76245,106,93,82),\nivec4(76379,165,83,93),\nivec4(76384,156,78,96),\nivec4(76499,85,82,86),\nivec4(76513,143,84,84),\nivec4(76625,85,79,89),\nivec4(76626,97,85,90),\nivec4(76791,144,35,86),\nivec4(76792,905,78,108),\nivec4(76793,786,81,97),\nivec4(76796,804,86,100),\nivec4(76847,164,85,24),\nivec4(76938,78,45,66),\nivec4(77096,54,41,52),\nivec4(77215,54,36,57),\nivec4(77355,79,45,25),\nivec4(77473,50,41,46),\nivec4(77609,57,47,54),\nivec4(77718,99,37,73),\nivec4(77819,90,47,72),\nivec4(77888,818,77,97),\nivec4(77891,702,87,100),\nivec4(77892,621,82,102),\nivec4(77920,82,45,67),\nivec4(78082,105,39,61),\nivec4(78247,39,41,46),\nivec4(78390,56,38,63),\nivec4(78518,70,47,54),\nivec4(78662,44,45,56),\nivec4(78784,86,39,77),\nivec4(78893,469,79,102),\nivec4(78894,512,85,96),\nivec4(78895,457,81,96),\nivec4(78897,447,88,96),\nivec4(78905,72,47,71),\nivec4(79039,88,41,68),\nivec4(79176,44,45,65),\nivec4(79322,50,40,68),\nivec4(79458,108,51,59),\nivec4(79542,101,45,69),\nivec4(79677,95,41,74),\nivec4(79723,374,80,102),\nivec4(79728,322,84,93),\nivec4(79729,343,89,91),\nivec4(79731,367,86,91),\nivec4(79791,112,51,69),\nivec4(79897,91,45,60),\nivec4(80028,48,47,56),\nivec4(80137,104,42,75),\nivec4(80266,62,51,66),\nivec4(80342,645,78,102),\nivec4(80343,562,90,102),\nivec4(80343,623,83,95),\nivec4(80343,623,87,98),\nivec4(80356,97,45,80),\nivec4(80493,82,43,70),\nivec4(80626,73,51,61),\nivec4(80751,52,47,63),\nivec4(80879,68,44,64),\nivec4(81006,53,51,65),\nivec4(81155,77,45,66),\nivec4(81413,71,46,67),\nivec4(81510,32,61,62),\nivec4(81519,47,64,56),\nivec4(81548,43,53,41),\nivec4(81574,40,57,21),\nivec4(81631,98,71,64),\nivec4(81672,34,51,42),\nivec4(81765,51,65,63),\nivec4(81768,36,62,51),\nivec4(81795,56,47,60),\nivec4(81899,41,73,74),\nivec4(81938,46,57,38),\nivec4(82023,63,51,51),\nivec4(82038,63,69,68),\nivec4(82163,51,53,59),\nivec4(82166,53,67,63),\nivec4(82298,45,63,71),\nivec4(82302,63,48,63),\nivec4(82421,29,66,71),\nivec4(82422,38,62,63),\nivec4(82427,49,59,65),\nivec4(82552,36,57,56),\nivec4(82553,58,75,73),\nivec4(82686,74,69,73),\nivec4(82693,47,53,50),\nivec4(82803,46,73,60),\nivec4(82844,40,51,30),\nivec4(82923,54,67,69),\nivec4(82930,35,63,60),\nivec4(82933,80,49,78),\nivec4(83060,64,75,78),\nivec4(83083,41,59,58),\nivec4(83193,34,73,67),\nivec4(83199,73,53,64),\nivec4(83309,57,67,70),\nivec4(83320,38,51,56),\nivec4(83343,36,57,60),\nivec4(83435,99,69,71),\nivec4(83457,47,50,71),\nivec4(83573,34,64,41),\nivec4(83582,39,68,64),\nivec4(83587,44,61,64),\nivec4(83614,69,57,48),\nivec4(83702,35,73,70),\nivec4(83709,54,55,62),\nivec4(83810,55,75,80),\nivec4(83818,91,51,72),\nivec4(83823,44,67,65),\nivec4(83950,37,61,55),\nivec4(83953,68,69,74),\nivec4(84065,54,55,61),\nivec4(84078,74,73,68),\nivec4(84185,46,69,61),\nivec4(84194,29,65,52),\nivec4(84197,35,57,69),\nivec4(84324,39,50,69),\nivec4(84325,59,52,73),\nivec4(84330,61,78,81),\nivec4(84453,25,68,62),\nivec4(84465,45,61,63),\nivec4(84576,84,72,77),\nivec4(84578,78,51,69),\nivec4(84585,50,57,68),\nivec4(84699,85,70,74),\nivec4(84704,43,67,59),\nivec4(84718,33,55,46),\nivec4(84835,89,78,75),\nivec4(84841,67,51,65),\nivec4(84945,84,72,75),\nivec4(84956,45,49,66),\nivec4(84957,101,53,70),\nivec4(85078,65,68,86),\nivec4(85085,72,71,79),\nivec4(85085,84,60,87),\nivec4(85217,87,78,76),\nivec4(85230,89,56,73),\nivec4(85348,69,72,73),\nivec4(85371,46,50,54),\nivec4(85479,56,73,87),\nivec4(85479,90,48,74),\nivec4(85496,27,69,57),\nivec4(85496,83,54,78),\nivec4(85612,129,80,85),\nivec4(85620,97,60,66),\nivec4(85730,115,78,75),\nivec4(85739,79,56,73),\nivec4(85854,72,74,75),\nivec4(85863,31,54,68),\nivec4(85868,42,71,64),\nivec4(85977,87,55,87),\nivec4(85979,131,47,82),\nivec4(85986,114,75,76),\nivec4(86119,77,81,76),\nivec4(86121,114,54,68),\nivec4(86238,61,73,78),\nivec4(86241,38,50,60),\nivec4(86342,108,56,95),\nivec4(86349,101,46,85),\nivec4(86354,57,75,85),\nivec4(86356,48,72,75),\nivec4(86483,105,54,66),\nivec4(86513,48,83,68),\nivec4(86517,30,84,60),\nivec4(86617,112,50,58),\nivec4(86620,55,81,76),\nivec4(86726,69,78,82),\nivec4(86728,41,48,56),\nivec4(86839,61,57,89),\nivec4(86849,41,45,79),\nivec4(86856,61,75,87),\nivec4(86886,40,47,53),\nivec4(86970,64,73,74),\nivec4(86983,105,55,77),\nivec4(86995,100,76,65),\nivec4(87092,124,51,67),\nivec4(87095,104,83,79),\nivec4(87210,57,49,74),\nivec4(87219,53,81,77),\nivec4(87348,61,75,83),\nivec4(87364,38,45,65),\nivec4(87365,30,43,61),\nivec4(87468,57,77,89),\nivec4(87471,99,58,89),\nivec4(87476,34,74,68),\nivec4(87596,68,84,87),\nivec4(87602,129,54,71),\nivec4(87716,167,80,82),\nivec4(87746,116,52,44),\nivec4(87824,71,78,77),\nivec4(87827,50,50,66),\nivec4(87830,33,75,70),\nivec4(87950,127,86,87),\nivec4(87954,81,59,89),\nivec4(87977,46,49,52),\nivec4(87995,36,48,49),\nivec4(88070,67,84,74),\nivec4(88103,93,55,72),\nivec4(88188,67,80,76),\nivec4(88206,40,53,63),\nivec4(88295,90,79,80),\nivec4(88299,74,76,76),\nivec4(88306,79,60,85),\nivec4(88312,60,48,74),\nivec4(88319,115,54,77),\nivec4(88427,138,87,84),\nivec4(88443,44,50,75),\nivec4(88550,77,85,80),\nivec4(88565,97,61,100),\nivec4(88573,110,49,89),\nivec4(88579,76,53,77),\nivec4(88683,108,80,82),\nivec4(88687,68,77,71),\nivec4(88747,120,57,70),\nivec4(88814,160,87,91),\nivec4(88855,100,55,68),\nivec4(88933,70,51,59),\nivec4(88933,89,85,79),\nivec4(89058,105,62,89),\nivec4(89058,108,50,83),\nivec4(89061,102,60,88),\nivec4(89066,119,81,90),\nivec4(89186,80,82,72),\nivec4(89188,79,78,73),\nivec4(89189,133,56,73),\nivec4(89294,80,54,77),\nivec4(89308,132,88,81),\nivec4(89427,109,63,101),\nivec4(89433,78,86,80),\nivec4(89435,112,51,83),\nivec4(89442,36,55,61),\nivec4(89550,146,53,68),\nivec4(89555,121,82,86),\nivec4(89670,78,79,76),\nivec4(89677,94,83,71),\nivec4(89701,116,62,59),\nivec4(89803,68,58,74),\nivec4(89809,127,89,87),\nivec4(89932,123,87,85),\nivec4(89947,154,62,90),\nivec4(89949,57,52,93),\nivec4(89949,147,64,91),\nivec4(90073,235,83,68),\nivec4(90074,71,84,66),\nivec4(90098,113,63,76),\nivec4(90187,104,84,60),\nivec4(90194,77,80,71),\nivec4(90222,118,59,73),\nivec4(90305,86,89,83),\nivec4(90321,53,57,74),\nivec4(90443,101,87,87),\nivec4(90448,72,65,89),\nivec4(90452,77,53,82),\nivec4(90458,96,61,86),\nivec4(90563,108,83,81),\nivec4(90626,113,59,76),\nivec4(90680,78,81,78),\nivec4(90702,65,55,76),\nivec4(90807,63,85,86),\nivec4(90811,59,82,81),\nivec4(90832,94,66,101),\nivec4(90845,59,61,49),\nivec4(90846,84,60,80),\nivec4(90846,86,54,82),\nivec4(90961,73,90,89),\nivec4(90972,116,57,73),\nivec4(91073,118,59,75),\nivec4(91075,166,88,81),\nivec4(91175,56,63,81),\nivec4(91189,88,86,80),\nivec4(91203,49,83,71),\nivec4(91310,131,65,93),\nivec4(91316,115,67,93),\nivec4(91317,114,55,89),\nivec4(91321,124,58,80),\nivec4(91323,151,94,93),\nivec4(91424,157,90,83),\nivec4(91443,55,60,75),\nivec4(91546,37,88,75),\nivec4(91575,0,61,71),\nivec4(91578,98,68,87),\nivec4(91585,83,56,74),\nivec4(91593,85,62,76),\nivec4(91613,38,66,46),\nivec4(91685,66,83,74),\nivec4(91690,116,87,79),\nivec4(91693,85,90,85),\nivec4(91714,149,59,78),\nivec4(91818,76,94,95),\nivec4(91823,91,61,77),\nivec4(91944,31,92,77),\nivec4(91945,98,69,97),\nivec4(91946,117,57,81),\nivec4(91952,119,63,88),\nivec4(92074,65,88,91),\nivec4(92075,120,59,80),\nivec4(92179,79,61,77),\nivec4(92191,34,86,77),\nivec4(92304,78,65,70),\nivec4(92308,94,84,75),\nivec4(92311,128,87,80),\nivec4(92313,128,91,80),\nivec4(92435,175,95,98),\nivec4(92442,114,68,102),\nivec4(92446,81,56,75),\nivec4(92448,124,62,82),\nivec4(92462,23,58,75),\nivec4(92567,137,93,86),\nivec4(92611,120,61,73),\nivec4(92680,81,89,86),\nivec4(92716,32,65,73),\nivec4(92828,130,92,100),\nivec4(92829,74,85,99),\nivec4(92835,132,69,95),\nivec4(92836,94,57,84),\nivec4(92847,135,63,83),\nivec4(92958,159,96,90),\nivec4(92995,110,61,71),\nivec4(93071,172,94,81),\nivec4(93121,98,65,59),\nivec4(93135,29,64,58),\nivec4(93203,116,93,75),\nivec4(93204,88,86,78),\nivec4(93205,31,67,74),\nivec4(93219,81,91,63),\nivec4(93333,192,97,102),\nivec4(93334,66,68,108),\nivec4(93344,69,58,86),\nivec4(93464,106,95,76),\nivec4(93465,132,62,75),\nivec4(93584,137,64,71),\nivec4(93593,153,91,84),\nivec4(93702,157,94,86),\nivec4(93716,94,66,80),\nivec4(93718,86,87,79),\nivec4(93840,54,70,100),\nivec4(93844,164,98,89),\nivec4(93971,136,96,96),\nivec4(93976,145,67,104),\nivec4(93984,101,59,92),\nivec4(94021,0,60,52),\nivec4(94100,85,88,82),\nivec4(94102,111,92,83),\nivec4(94102,148,62,72),\nivec4(94107,103,95,74),\nivec4(94225,128,64,70),\nivec4(94233,172,99,94),\nivec4(94341,89,97,80),\nivec4(94342,59,68,83),\nivec4(94471,137,69,106),\nivec4(94477,106,96,97),\nivec4(94478,169,60,99),\nivec4(94479,65,89,92),\nivec4(94480,104,93,89),\nivec4(94612,121,62,59),\nivec4(94618,174,99,90),\nivec4(94716,106,64,67),\nivec4(94728,155,97,82),\nivec4(94822,54,68,85),\nivec4(94830,82,96,74),\nivec4(94848,39,90,60),\nivec4(94862,49,94,64),\nivec4(94955,149,70,110),\nivec4(94963,105,61,92),\nivec4(94965,167,100,97),\nivec4(95087,162,98,85),\nivec4(95092,136,63,70),\nivec4(95202,64,67,76),\nivec4(95210,69,96,87),\nivec4(95331,100,91,96),\nivec4(95334,141,71,107),\nivec4(95334,150,95,100),\nivec4(95345,123,62,87),\nivec4(95361,0,60,69),\nivec4(95468,137,100,91),\nivec4(95469,135,63,76),\nivec4(95585,146,98,81),\nivec4(95596,129,67,75),\nivec4(95707,50,69,90),\nivec4(95718,58,96,87),\nivec4(95719,53,92,84),\nivec4(95836,247,72,101),\nivec4(95838,166,101,106),\nivec4(95840,135,64,96),\nivec4(95963,169,99,88),\nivec4(95984,133,66,70),\nivec4(96068,87,68,79),\nivec4(96080,54,97,85),\nivec4(96207,125,72,95),\nivec4(96209,130,98,96),\nivec4(96211,122,96,100),\nivec4(96214,73,93,87),\nivec4(96313,54,74,82),\nivec4(96333,68,101,89),\nivec4(96452,113,73,107),\nivec4(96463,45,94,105),\nivec4(96463,104,99,95),\nivec4(96464,124,97,97),\nivec4(96467,178,65,75),\nivec4(96486,36,66,56),\nivec4(96488,0,64,58),\nivec4(96509,50,98,56),\nivec4(96511,0,95,39),\nivec4(96595,145,67,68),\nivec4(96610,150,103,85),\nivec4(96704,146,69,74),\nivec4(96713,137,101,76),\nivec4(96831,60,95,87),\nivec4(96832,61,100,83),\nivec4(96834,54,73,86),\nivec4(96835,78,98,89),\nivec4(96949,99,103,109),\nivec4(96959,122,74,98),\nivec4(96960,114,66,99),\nivec4(96961,124,72,101),\nivec4(97105,118,67,66),\nivec4(97109,129,101,83),\nivec4(97190,94,69,79),\nivec4(97219,55,99,87),\nivec4(97319,92,96,114),\nivec4(97319,135,75,105),\nivec4(97322,151,100,105),\nivec4(97326,107,73,88),\nivec4(97328,117,65,85),\nivec4(97465,135,67,69),\nivec4(97473,83,103,91),\nivec4(97565,142,69,66),\nivec4(97603,105,101,89),\nivec4(97671,69,73,88),\nivec4(97703,38,97,85),\nivec4(97711,62,100,82),\nivec4(97734,29,99,54),\nivec4(97820,122,66,99),\nivec4(97820,169,76,100),\nivec4(97821,171,74,100),\nivec4(97826,143,104,103),\nivec4(97952,146,102,91),\nivec4(97956,145,68,80),\nivec4(98055,89,70,78),\nivec4(98069,55,100,85),\nivec4(98183,97,74,87),\nivec4(98184,130,101,106),\nivec4(98193,67,98,88),\nivec4(98306,87,104,93),\nivec4(98307,39,76,86),\nivec4(98321,35,73,45),\nivec4(98424,111,75,117),\nivec4(98430,74,102,106),\nivec4(98434,180,67,91),\nivec4(98544,110,102,88),\nivec4(98562,147,69,78),\nivec4(98571,69,99,83),\nivec4(98586,104,101,84),\nivec4(98662,136,71,74),\nivec4(98686,136,105,88),\nivec4(98784,51,75,88),\nivec4(98808,32,103,80),\nivec4(98910,58,100,106),\nivec4(98914,75,102,102),\nivec4(98916,106,76,103),\nivec4(98918,110,66,98),\nivec4(98932,30,72,76),\nivec4(99039,67,106,100),\nivec4(99047,53,68,49),\nivec4(99079,50,67,51),\nivec4(99100,45,68,7),\nivec4(99130,156,72,41),\nivec4(99159,67,104,92),\nivec4(99246,39,74,81),\nivec4(99256,64,103,85),\nivec4(99270,83,107,92),\nivec4(99286,58,99,83),\nivec4(99385,168,77,103),\nivec4(99387,134,67,97),\nivec4(99398,79,106,98),\nivec4(99407,127,71,70),\nivec4(99415,34,72,71),\nivec4(99519,115,104,96),\nivec4(99551,106,69,69),\nivec4(99607,79,73,76),\nivec4(99631,37,102,86),\nivec4(99753,102,68,95),\nivec4(99753,116,78,105),\nivec4(99757,107,72,86),\nivec4(99759,104,100,116),\nivec4(99762,152,104,100),\nivec4(99787,24,102,72),\nivec4(99895,159,70,58),\nivec4(99897,141,108,92),\nivec4(100009,121,72,71),\nivec4(100011,151,106,86),\nivec4(100107,65,74,82),\nivec4(100121,73,104,91),\nivec4(100133,52,101,86),\nivec4(100248,134,77,95),\nivec4(100250,125,69,92),\nivec4(100252,92,108,103),\nivec4(100258,135,73,84),\nivec4(100366,66,76,34),\nivec4(100380,69,106,96),\nivec4(100499,150,78,98),\nivec4(100502,111,70,87),\nivec4(100509,209,75,88),\nivec4(100511,67,104,102),\nivec4(100616,143,104,95),\nivec4(100637,81,102,86),\nivec4(100663,121,73,74),\nivec4(100749,53,108,75),\nivec4(100767,21,107,71),\nivec4(100806,51,77,40),\nivec4(100855,61,103,99),\nivec4(100855,91,106,106),\nivec4(100857,102,71,83),\nivec4(100858,143,79,100),\nivec4(100859,52,105,93),\nivec4(100876,31,77,39),\nivec4(100882,36,75,67),\nivec4(100909,0,72,36),\nivec4(100970,99,73,68),\nivec4(100983,129,108,94),\nivec4(101085,112,106,67),\nivec4(101088,96,107,82),\nivec4(101089,109,77,67),\nivec4(101170,67,79,84),\nivec4(101179,116,108,68),\nivec4(101181,137,104,80),\nivec4(101275,46,106,74),\nivec4(101283,68,76,53),\nivec4(101297,112,80,101),\nivec4(101309,198,70,92),\nivec4(101350,43,79,21),\nivec4(101388,151,101,101),\nivec4(101396,91,108,93),\nivec4(101407,154,105,79),\nivec4(101435,108,73,68),\nivec4(101519,62,106,79),\nivec4(101526,62,77,85),\nivec4(101641,105,108,98),\nivec4(101642,56,107,98),\nivec4(101643,92,78,93),\nivec4(101643,114,75,92),\nivec4(101648,105,71,83),\nivec4(101766,57,79,89),\nivec4(101776,139,106,98),\nivec4(101881,140,80,94),\nivec4(101886,106,76,84),\nivec4(101887,89,72,84),\nivec4(101895,31,104,76),\nivec4(101996,119,105,103),\nivec4(102002,123,103,102),\nivec4(102002,129,108,100),\nivec4(102008,49,81,93),\nivec4(102104,42,106,82),\nivec4(102118,131,82,91),\nivec4(102129,74,78,77),\nivec4(102130,108,73,80),\nivec4(102234,50,83,91),\nivec4(102241,177,108,110),\nivec4(102243,139,100,110),\nivec4(102245,168,104,100),\nivec4(102367,44,106,55),\nivec4(102368,78,75,78),\nivec4(102377,96,80,88),\nivec4(102383,159,84,99),\nivec4(102497,131,78,87),\nivec4(102505,180,105,106),\nivec4(102508,126,101,104),\nivec4(102508,156,108,101),\nivec4(102515,140,103,98),\nivec4(102517,16,104,86),\nivec4(102530,27,107,79),\nivec4(102625,78,82,84),\nivec4(102626,83,106,70),\nivec4(102741,152,86,95),\nivec4(102742,102,76,83),\nivec4(102757,45,81,76),\nivec4(102784,99,108,84),\nivec4(102839,88,107,97),\nivec4(102841,91,103,97),\nivec4(102848,118,105,88),\nivec4(102856,147,79,80),\nivec4(102985,124,108,76),\nivec4(102987,132,83,79),\nivec4(102992,31,107,11),\nivec4(103091,59,106,93),\nivec4(103097,31,85,84),\nivec4(103206,115,86,98),\nivec4(103206,122,84,102),\nivec4(103206,139,107,116),\nivec4(103209,113,108,104),\nivec4(103209,126,77,95),\nivec4(103336,150,79,69),\nivec4(103343,87,106,90),\nivec4(103434,137,81,70),\nivec4(103451,163,108,80),\nivec4(103560,59,85,85),\nivec4(103560,64,107,95),\nivec4(103563,49,105,86),\nivec4(103679,86,108,106),\nivec4(103683,130,87,107),\nivec4(103691,70,78,95),\nivec4(103804,147,107,94),\nivec4(103816,116,80,74),\nivec4(103895,85,85,86),\nivec4(103925,102,108,88),\nivec4(103951,35,84,59),\nivec4(104023,66,105,105),\nivec4(104036,115,79,90),\nivec4(104036,141,88,93),\nivec4(104061,0,86,61),\nivec4(104146,137,107,95),\nivec4(104166,54,85,73),\nivec4(104255,63,106,102),\nivec4(104269,113,89,114),\nivec4(104274,139,78,93),\nivec4(104295,23,80,72),\nivec4(104321,46,85,22),\nivec4(104378,63,104,106),\nivec4(104391,147,80,85),\nivec4(104503,109,105,89),\nivec4(104520,35,85,37),\nivec4(104524,99,84,87),\nivec4(104591,143,108,78),\nivec4(104595,52,86,89),\nivec4(104713,39,106,81),\nivec4(104727,104,90,107),\nivec4(104742,57,79,95),\nivec4(104745,78,80,59),\nivec4(104865,109,108,95),\nivec4(104867,118,81,71),\nivec4(104871,60,104,92),\nivec4(104880,29,103,87),\nivec4(104958,60,85,82),\nivec4(104961,55,105,80),\nivec4(105090,177,108,107),\nivec4(105093,122,106,109),\nivec4(105095,126,91,111),\nivec4(105102,128,80,103),\nivec4(105208,77,89,10),\nivec4(105208,84,104,94),\nivec4(105217,124,82,81),\nivec4(105334,117,86,78),\nivec4(105334,138,105,84),\nivec4(105428,46,88,87),\nivec4(105440,61,107,86),\nivec4(105556,81,92,110),\nivec4(105556,84,104,110),\nivec4(105556,133,108,107),\nivec4(105573,38,81,85),\nivec4(105575,34,82,75));\n#elif TUNE == 3\nfloat speed = 2.0;\nconst ivec4 data[] = ivec4[](\nivec4(4096,205,50,20),\nivec4(4096,205,57,20),\nivec4(4096,205,62,20),\nivec4(4096,205,66,20),\nivec4(4608,205,54,20),\nivec4(4608,205,57,20),\nivec4(4608,205,62,20),\nivec4(4608,205,69,20),\nivec4(5120,205,52,20),\nivec4(5120,205,59,20),\nivec4(5120,205,62,20),\nivec4(5120,205,67,20),\nivec4(5632,205,55,20),\nivec4(5632,205,57,20),\nivec4(5632,205,61,20),\nivec4(5632,205,64,20),\nivec4(6144,205,50,20),\nivec4(6144,205,57,20),\nivec4(6144,205,62,20),\nivec4(6144,205,66,20),\nivec4(6656,205,54,20),\nivec4(6656,205,57,20),\nivec4(6656,205,62,20),\nivec4(6656,205,69,20),\nivec4(7168,205,52,20),\nivec4(7168,205,59,20),\nivec4(7168,205,62,20),\nivec4(7168,205,67,20),\nivec4(7680,205,55,20),\nivec4(7680,205,57,20),\nivec4(7680,205,61,20),\nivec4(7680,205,64,20),\nivec4(8192,205,50,20),\nivec4(8192,205,57,20),\nivec4(8192,205,62,20),\nivec4(8192,205,66,20),\nivec4(8704,205,54,20),\nivec4(8704,205,59,20),\nivec4(8704,205,62,20),\nivec4(8704,205,69,20),\nivec4(9216,205,49,20),\nivec4(9216,205,56,20),\nivec4(9216,205,57,20),\nivec4(9216,205,64,20),\nivec4(9728,205,52,20),\nivec4(9728,205,57,20),\nivec4(9728,205,61,20),\nivec4(9728,205,69,20),\nivec4(10240,205,47,20),\nivec4(10240,205,54,20),\nivec4(10240,205,57,20),\nivec4(10240,205,62,20),\nivec4(10752,205,52,20),\nivec4(10752,205,59,20),\nivec4(10752,205,62,20),\nivec4(10752,205,68,20),\nivec4(11264,205,45,20),\nivec4(11264,205,52,20),\nivec4(11264,205,61,20),\nivec4(11264,205,69,20),\nivec4(11776,205,49,20),\nivec4(11776,205,57,20),\nivec4(11776,205,64,20),\nivec4(11776,205,67,20),\nivec4(12288,205,50,20),\nivec4(12288,205,57,20),\nivec4(12288,205,62,20),\nivec4(12288,205,66,20),\nivec4(12800,205,54,20),\nivec4(12800,205,57,20),\nivec4(12800,205,62,20),\nivec4(12800,205,69,20),\nivec4(13312,205,52,20),\nivec4(13312,205,59,20),\nivec4(13312,205,62,20),\nivec4(13312,205,67,20),\nivec4(13824,205,55,20),\nivec4(13824,205,57,20),\nivec4(13824,205,61,20),\nivec4(13824,205,64,20),\nivec4(14336,205,50,20),\nivec4(14336,205,57,20),\nivec4(14336,205,62,20),\nivec4(14336,205,66,20),\nivec4(14848,205,54,20),\nivec4(14848,205,57,20),\nivec4(14848,205,62,20),\nivec4(14848,205,69,20),\nivec4(15360,205,52,20),\nivec4(15360,205,59,20),\nivec4(15360,205,62,20),\nivec4(15360,205,67,20),\nivec4(15872,205,55,20),\nivec4(15872,205,57,20),\nivec4(15872,205,61,20),\nivec4(15872,205,64,20),\nivec4(16384,205,50,20),\nivec4(16384,205,57,20),\nivec4(16384,205,62,20),\nivec4(16384,205,66,20),\nivec4(16896,205,54,20),\nivec4(16896,205,59,20),\nivec4(16896,205,62,20),\nivec4(16896,205,69,20),\nivec4(17408,205,49,20),\nivec4(17408,205,56,20),\nivec4(17408,205,57,20),\nivec4(17408,205,64,20),\nivec4(17920,205,52,20),\nivec4(17920,205,57,20),\nivec4(17920,205,61,20),\nivec4(17920,205,69,20),\nivec4(18432,205,47,20),\nivec4(18432,205,54,20),\nivec4(18432,205,57,20),\nivec4(18432,205,62,20),\nivec4(18944,205,52,20),\nivec4(18944,205,59,20),\nivec4(18944,205,62,20),\nivec4(18944,205,68,20),\nivec4(19456,205,45,20),\nivec4(19456,205,52,20),\nivec4(19456,205,61,20),\nivec4(19456,205,69,20),\nivec4(19968,205,49,20),\nivec4(19968,205,57,20),\nivec4(19968,205,64,20),\nivec4(19968,205,67,20),\nivec4(20480,205,50,20),\nivec4(20480,205,57,20),\nivec4(20480,205,66,20),\nivec4(20480,2560,62,50),\nivec4(20992,205,54,20),\nivec4(20992,205,57,20),\nivec4(20992,205,69,20),\nivec4(21504,205,55,20),\nivec4(21504,205,59,20),\nivec4(21504,205,71,20),\nivec4(22016,205,57,20),\nivec4(22016,205,61,20),\nivec4(22016,205,67,20),\nivec4(22528,205,50,20),\nivec4(22528,205,57,20),\nivec4(22528,205,69,20),\nivec4(23040,205,50,20),\nivec4(23040,205,57,20),\nivec4(23040,512,62,20),\nivec4(23552,512,57,20),\nivec4(23552,512,61,50),\nivec4(23552,512,66,20),\nivec4(24064,512,55,20),\nivec4(24064,512,59,50),\nivec4(24064,512,67,20),\nivec4(24576,512,54,20),\nivec4(24576,512,57,50),\nivec4(24576,512,66,20),\nivec4(24576,512,69,20),\nivec4(25088,512,50,20),\nivec4(25088,512,57,20),\nivec4(25088,512,66,20),\nivec4(25088,512,74,50),\nivec4(25600,512,52,20),\nivec4(25600,512,59,20),\nivec4(25600,512,67,20),\nivec4(25600,512,73,50),\nivec4(26112,512,55,20),\nivec4(26112,512,61,20),\nivec4(26112,512,64,20),\nivec4(26112,512,71,50),\nivec4(26624,512,54,20),\nivec4(26624,512,59,20),\nivec4(26624,512,62,20),\nivec4(26624,512,69,50),\nivec4(27136,512,42,20),\nivec4(27136,512,49,20),\nivec4(27136,512,57,20),\nivec4(27136,512,66,50),\nivec4(27648,512,43,20),\nivec4(27648,512,50,20),\nivec4(27648,512,59,20),\nivec4(27648,1024,64,50),\nivec4(28160,512,45,20),\nivec4(28160,512,52,20),\nivec4(28160,512,57,20),\nivec4(28160,512,61,20),\nivec4(28672,205,50,20),\nivec4(28672,205,54,20),\nivec4(28672,205,59,20),\nivec4(28672,1024,66,50),\nivec4(29184,205,54,23),\nivec4(29184,205,57,23),\nivec4(29184,205,62,23),\nivec4(29696,205,52,25),\nivec4(29696,205,55,25),\nivec4(29696,205,61,25),\nivec4(29696,1024,67,55),\nivec4(30208,205,55,28),\nivec4(30208,205,59,28),\nivec4(30208,205,64,28),\nivec4(30720,205,54,30),\nivec4(30720,205,57,30),\nivec4(30720,205,62,30),\nivec4(30720,1024,69,60),\nivec4(31232,205,57,33),\nivec4(31232,205,61,33),\nivec4(31232,205,66,33),\nivec4(31744,205,55,35),\nivec4(31744,205,59,35),\nivec4(31744,205,64,35),\nivec4(31744,1024,71,65),\nivec4(32256,205,59,38),\nivec4(32256,205,62,38),\nivec4(32256,205,67,38),\nivec4(32768,205,57,40),\nivec4(32768,205,61,40),\nivec4(32768,205,66,40),\nivec4(32768,1024,73,64),\nivec4(33280,205,45,30),\nivec4(33280,205,55,30),\nivec4(33280,205,64,30),\nivec4(33792,205,47,20),\nivec4(33792,205,54,20),\nivec4(33792,205,62,20),\nivec4(33792,205,66,20),\nivec4(33792,512,74,50),\nivec4(34304,205,52,30),\nivec4(34304,205,59,30),\nivec4(34304,205,62,30),\nivec4(34304,512,67,64),\nivec4(34816,205,57,40),\nivec4(34816,205,61,40),\nivec4(34816,205,66,40),\nivec4(34816,1024,45,64),\nivec4(34816,1024,69,64),\nivec4(35328,205,55,30),\nivec4(35328,205,59,30),\nivec4(35328,205,61,30),\nivec4(35328,205,64,30),\nivec4(35840,1024,50,20),\nivec4(35840,1024,54,20),\nivec4(35840,1024,57,20),\nivec4(35840,1024,62,50),\nivec4(36864,205,50,15),\nivec4(36864,205,57,15),\nivec4(36864,205,66,15),\nivec4(36864,1536,78,40),\nivec4(37376,205,54,15),\nivec4(37376,205,62,15),\nivec4(37376,205,69,15),\nivec4(37888,205,55,15),\nivec4(37888,205,62,15),\nivec4(37888,205,71,15),\nivec4(38400,205,57,15),\nivec4(38400,205,67,15),\nivec4(38400,205,73,15),\nivec4(38400,512,76,40),\nivec4(38912,205,50,15),\nivec4(38912,205,57,15),\nivec4(38912,205,66,15),\nivec4(38912,1024,74,40),\nivec4(39424,205,54,15),\nivec4(39424,205,57,15),\nivec4(39424,205,62,15),\nivec4(39424,205,69,15),\nivec4(39936,205,55,15),\nivec4(39936,205,59,15),\nivec4(39936,205,62,15),\nivec4(39936,205,67,15),\nivec4(39936,1536,69,40),\nivec4(40448,205,57,15),\nivec4(40448,205,61,15),\nivec4(40448,205,64,15),\nivec4(40960,205,50,15),\nivec4(40960,205,57,15),\nivec4(40960,205,62,15),\nivec4(40960,205,66,15),\nivec4(41472,205,66,15),\nivec4(41472,205,69,15),\nivec4(41472,205,74,15),\nivec4(41472,512,81,40),\nivec4(41984,205,67,15),\nivec4(41984,205,71,15),\nivec4(41984,512,81,15),\nivec4(41984,512,83,40),\nivec4(42496,205,69,15),\nivec4(42496,205,73,15),\nivec4(42496,512,79,15),\nivec4(42496,512,85,40),\nivec4(43008,205,62,15),\nivec4(43008,205,69,15),\nivec4(43008,256,86,40),\nivec4(43008,512,78,15),\nivec4(43264,256,85,40),\nivec4(43520,205,64,15),\nivec4(43520,205,68,15),\nivec4(43520,256,76,15),\nivec4(43520,512,83,40),\nivec4(43776,256,74,15),\nivec4(44032,205,57,15),\nivec4(44032,205,64,15),\nivec4(44032,205,73,15),\nivec4(44032,1536,81,40),\nivec4(44544,205,55,15),\nivec4(44544,205,61,15),\nivec4(44544,205,71,15),\nivec4(45056,205,54,15),\nivec4(45056,205,62,15),\nivec4(45056,205,69,15),\nivec4(45568,205,50,15),\nivec4(45568,205,57,15),\nivec4(45568,205,66,15),\nivec4(45568,512,74,40),\nivec4(46080,205,55,15),\nivec4(46080,205,59,15),\nivec4(46080,512,62,15),\nivec4(46080,512,69,15),\nivec4(46080,768,71,40),\nivec4(46592,205,52,15),\nivec4(46592,205,55,15),\nivec4(46592,512,67,15),\nivec4(46848,256,73,40),\nivec4(47104,205,54,15),\nivec4(47104,205,57,15),\nivec4(47104,512,62,15),\nivec4(47104,512,67,15),\nivec4(47104,512,69,40),\nivec4(47616,205,50,15),\nivec4(47616,205,54,15),\nivec4(47616,512,66,15),\nivec4(47616,512,74,40),\nivec4(48128,512,47,15),\nivec4(48128,512,54,15),\nivec4(48128,512,62,15),\nivec4(48128,768,67,40),\nivec4(48640,512,49,15),\nivec4(48640,512,55,15),\nivec4(48640,512,64,15),\nivec4(48896,256,69,40),\nivec4(49152,205,50,20),\nivec4(49152,205,57,20),\nivec4(49152,205,62,20),\nivec4(49152,512,66,40),\nivec4(49664,205,49,20),\nivec4(49664,205,57,20),\nivec4(49664,205,64,25),\nivec4(49664,512,69,50),\nivec4(50176,205,47,20),\nivec4(50176,205,66,30),\nivec4(50176,256,57,20),\nivec4(50176,512,74,50),\nivec4(50432,256,56,20),\nivec4(50688,205,49,20),\nivec4(50688,205,64,30),\nivec4(50688,512,57,20),\nivec4(50688,512,73,50),\nivec4(51200,205,50,20),\nivec4(51200,512,64,27),\nivec4(51200,768,73,50),\nivec4(51200,1024,57,20),\nivec4(51200,1024,66,27),\nivec4(51712,205,47,20),\nivec4(51712,512,62,24),\nivec4(51968,256,71,42),\nivec4(52224,205,52,20),\nivec4(52224,256,73,40),\nivec4(52224,512,56,20),\nivec4(52224,512,64,21),\nivec4(52480,256,71,37),\nivec4(52736,205,57,20),\nivec4(52736,256,62,20),\nivec4(52736,512,64,18),\nivec4(52736,512,69,35),\nivec4(52992,256,61,20),\nivec4(53248,205,62,20),\nivec4(53248,205,66,20),\nivec4(53248,1024,60,55),\nivec4(53760,205,50,20),\nivec4(53760,205,57,20),\nivec4(53760,205,66,20),\nivec4(53760,205,72,20),\nivec4(54272,205,55,20),\nivec4(54272,205,62,20),\nivec4(54272,205,71,20),\nivec4(54272,1024,59,55),\nivec4(54784,205,53,20),\nivec4(54784,205,57,20),\nivec4(54784,205,62,20),\nivec4(54784,205,69,20),\nivec4(55296,205,64,20),\nivec4(55296,205,68,20),\nivec4(55296,1024,62,55),\nivec4(55808,205,52,20),\nivec4(55808,205,59,20),\nivec4(55808,205,68,20),\nivec4(55808,205,74,20),\nivec4(56320,205,57,20),\nivec4(56320,205,64,20),\nivec4(56320,205,73,20),\nivec4(56320,1024,61,55),\nivec4(56832,205,58,20),\nivec4(56832,205,67,20),\nivec4(56832,205,76,20),\nivec4(57344,205,59,20),\nivec4(57344,205,66,20),\nivec4(57344,205,74,20),\nivec4(57344,512,62,50),\nivec4(57856,512,47,19),\nivec4(57856,512,52,19),\nivec4(57856,512,66,49),\nivec4(57856,512,68,19),\nivec4(58368,512,49,18),\nivec4(58368,512,57,18),\nivec4(58368,512,64,47),\nivec4(58368,512,69,18),\nivec4(58880,512,50,18),\nivec4(58880,512,61,46),\nivec4(58880,512,66,18),\nivec4(59392,512,66,17),\nivec4(59392,512,69,17),\nivec4(59392,1024,59,45),\nivec4(59392,1024,62,17),\nivec4(59904,512,52,16),\nivec4(59904,512,64,16),\nivec4(59904,512,68,16),\nivec4(60416,512,62,15),\nivec4(60416,1024,57,42),\nivec4(60416,1024,64,15),\nivec4(60416,1536,69,42),\nivec4(60928,512,45,15),\nivec4(60928,512,52,15),\nivec4(60928,512,61,15),\nivec4(61440,512,55,30),\nivec4(61440,1024,50,30),\nivec4(61440,1024,60,30),\nivec4(61952,512,54,32),\nivec4(61952,1536,62,43),\nivec4(62464,205,55,34),\nivec4(62464,205,59,34),\nivec4(62464,1536,71,46),\nivec4(62976,205,53,36),\nivec4(62976,205,57,36),\nivec4(63488,512,57,38),\nivec4(63488,1024,52,38),\nivec4(63488,1024,62,38),\nivec4(64000,512,56,39),\nivec4(64000,512,64,55),\nivec4(64512,205,57,41),\nivec4(64512,205,61,41),\nivec4(64512,256,73,55),\nivec4(64768,256,71,56),\nivec4(65024,205,58,43),\nivec4(65024,205,61,43),\nivec4(65024,205,64,43),\nivec4(65024,256,69,56),\nivec4(65280,256,67,57),\nivec4(65536,512,59,45),\nivec4(65536,512,62,45),\nivec4(65536,768,66,57),\nivec4(65536,768,74,64),\nivec4(66048,1024,50,47),\nivec4(66048,1024,57,47),\nivec4(66304,256,62,58),\nivec4(66304,256,66,58),\nivec4(66560,512,64,59),\nivec4(66560,512,67,59),\nivec4(66560,1024,60,49),\nivec4(67072,512,50,51),\nivec4(67072,512,62,60),\nivec4(67072,512,66,60),\nivec4(67072,512,69,60),\nivec4(67584,0,57,61),\nivec4(67584,307,47,53),\nivec4(67584,512,63,61),\nivec4(67584,512,67,61),\nivec4(68096,307,40,54),\nivec4(68096,307,52,54),\nivec4(68096,512,56,61),\nivec4(68096,512,62,61),\nivec4(68096,512,66,61),\nivec4(68608,307,45,56),\nivec4(68608,307,52,56),\nivec4(68608,512,55,62),\nivec4(68608,512,57,62),\nivec4(68608,512,62,62),\nivec4(68608,1024,64,62),\nivec4(69120,307,33,58),\nivec4(69120,307,45,58),\nivec4(69120,512,55,63),\nivec4(69120,512,57,63),\nivec4(69120,512,61,63),\nivec4(69632,307,38,20),\nivec4(69632,307,45,20),\nivec4(69632,307,50,20),\nivec4(69632,512,54,55),\nivec4(69632,512,57,55),\nivec4(69632,512,62,55),\nivec4(70144,512,78,55),\nivec4(70144,512,81,55),\nivec4(70656,205,42,20),\nivec4(70656,205,54,20),\nivec4(70656,768,76,55),\nivec4(70656,768,79,55),\nivec4(71168,205,54,20),\nivec4(71168,205,57,20),\nivec4(71168,205,62,20),\nivec4(71424,256,74,55),\nivec4(71424,256,78,55),\nivec4(71680,205,45,20),\nivec4(71680,205,57,20),\nivec4(71680,1536,78,55),\nivec4(71680,1536,81,55),\nivec4(72192,256,57,40),\nivec4(72448,256,69,40),\nivec4(72704,307,59,40),\nivec4(73216,307,61,40),\nivec4(73216,512,76,55),\nivec4(73216,512,79,55),\nivec4(73728,205,38,20),\nivec4(73728,205,50,20),\nivec4(73728,1024,76,55),\nivec4(73728,1024,78,55),\nivec4(74240,205,54,20),\nivec4(74240,205,57,20),\nivec4(74240,205,62,20),\nivec4(74752,205,42,20),\nivec4(74752,205,54,20),\nivec4(74752,768,74,45),\nivec4(74752,1024,81,55),\nivec4(75264,205,54,20),\nivec4(75264,205,57,20),\nivec4(75264,205,62,20),\nivec4(75520,256,73,45),\nivec4(75776,205,33,20),\nivec4(75776,205,45,20),\nivec4(75776,1536,69,45),\nivec4(75776,1536,71,45),\nivec4(75776,1536,78,55),\nivec4(76288,256,45,40),\nivec4(76544,256,57,40),\nivec4(76800,307,47,40),\nivec4(77312,307,49,40),\nivec4(77312,512,67,45),\nivec4(77312,512,69,45),\nivec4(77312,512,76,55),\nivec4(77824,205,38,50),\nivec4(77824,205,50,50),\nivec4(77824,512,66,50),\nivec4(77824,1024,74,55),\nivec4(78336,205,50,53),\nivec4(78336,205,57,53),\nivec4(78848,0,69,60),\nivec4(78848,205,54,55),\nivec4(78848,205,62,55),\nivec4(78848,768,67,55),\nivec4(79360,205,42,58),\nivec4(79360,205,54,58),\nivec4(79616,256,66,59),\nivec4(79872,205,43,60),\nivec4(79872,205,55,60),\nivec4(79872,205,69,60),\nivec4(79872,205,71,65),\nivec4(80384,205,55,63),\nivec4(80384,205,59,63),\nivec4(80384,205,62,63),\nivec4(80384,205,67,63),\nivec4(80384,205,71,63),\nivec4(80384,205,74,68),\nivec4(80896,205,57,65),\nivec4(80896,205,61,65),\nivec4(80896,205,64,65),\nivec4(80896,512,69,65),\nivec4(80896,512,73,65),\nivec4(80896,1024,76,70),\nivec4(81408,205,45,68),\nivec4(81408,205,57,68),\nivec4(81408,512,67,68),\nivec4(81408,512,71,68),\nivec4(81920,205,50,75),\nivec4(81920,205,62,75),\nivec4(81920,205,74,75),\nivec4(81920,205,78,75),\nivec4(82432,205,62,76),\nivec4(82432,205,66,76),\nivec4(82432,205,69,76),\nivec4(82432,205,74,75),\nivec4(82432,205,78,75),\nivec4(82432,205,81,78),\nivec4(82944,205,64,78),\nivec4(82944,205,68,78),\nivec4(82944,205,71,78),\nivec4(82944,512,76,75),\nivec4(82944,512,80,75),\nivec4(82944,1024,83,80),\nivec4(83456,205,52,79),\nivec4(83456,205,64,79),\nivec4(83456,512,74,75),\nivec4(83456,512,78,75),\nivec4(83968,128,85,80),\nivec4(83968,512,45,80),\nivec4(83968,512,57,80),\nivec4(84096,128,86,78),\nivec4(84224,128,85,76),\nivec4(84352,128,86,74),\nivec4(84480,128,85,72),\nivec4(84480,205,59,75),\nivec4(84480,205,61,75),\nivec4(84480,205,67,75),\nivec4(84608,128,86,70),\nivec4(84736,128,85,68),\nivec4(84864,128,86,66),\nivec4(84992,128,85,64),\nivec4(84992,768,57,67),\nivec4(84992,768,61,67),\nivec4(84992,768,66,67),\nivec4(85120,128,86,62),\nivec4(85248,128,85,60),\nivec4(85376,128,86,58),\nivec4(85504,102,85,56),\nivec4(85606,103,86,55),\nivec4(85709,102,85,53),\nivec4(85760,256,55,55),\nivec4(85760,256,59,55),\nivec4(85760,256,64,55),\nivec4(85811,103,83,52),\nivec4(85914,102,85,50),\nivec4(86016,512,54,40),\nivec4(86016,512,62,40),\nivec4(86016,512,86,50),\nivec4(86528,512,74,50),\nivec4(87040,768,73,50),\nivec4(87040,1024,42,40),\nivec4(87040,1024,50,40),\nivec4(87552,512,57,40),\nivec4(87552,512,66,40),\nivec4(87808,256,74,50),\nivec4(88064,512,69,40),\nivec4(88064,1024,43,40),\nivec4(88064,1024,71,50),\nivec4(88576,512,59,40),\nivec4(88576,512,67,40),\nivec4(89088,512,57,40),\nivec4(89088,512,66,40),\nivec4(89088,512,73,50),\nivec4(89088,1024,45,40),\nivec4(89600,512,55,40),\nivec4(89600,512,64,40),\nivec4(89600,512,69,50),\nivec4(90112,307,47,40),\nivec4(90112,307,54,40),\nivec4(90112,307,62,40),\nivec4(90112,307,66,50),\nivec4(90624,1024,66,50),\nivec4(90624,1024,71,50),\nivec4(90880,256,62,40),\nivec4(90880,1280,50,40),\nivec4(90880,1280,54,40),\nivec4(91136,512,60,40),\nivec4(91648,512,69,50),\nivec4(92160,0,62,50),\nivec4(92160,512,43,40),\nivec4(92160,512,50,40),\nivec4(92672,512,67,50),\nivec4(92672,1024,59,40),\nivec4(93184,512,61,40),\nivec4(93184,1024,47,40),\nivec4(93184,1024,66,50),\nivec4(93696,512,57,40),\nivec4(93696,512,63,40),\nivec4(94208,205,40,40),\nivec4(94208,205,47,40),\nivec4(94208,512,59,40),\nivec4(94720,205,55,42),\nivec4(94720,512,61,53),\nivec4(95232,205,42,44),\nivec4(95232,205,50,44),\nivec4(95232,256,62,55),\nivec4(95232,1024,57,44),\nivec4(95488,512,66,56),\nivec4(95744,205,54,46),\nivec4(96256,512,64,60),\nivec4(96256,1024,62,48),\nivec4(96256,2048,47,48),\nivec4(96256,2048,50,48),\nivec4(96256,2048,52,48),\nivec4(96768,512,57,49),\nivec4(96768,512,66,63),\nivec4(97280,256,68,65),\nivec4(97280,512,56,51),\nivec4(97280,1024,62,51),\nivec4(97280,1024,64,51),\nivec4(97536,512,71,66),\nivec4(97792,512,59,53),\nivec4(98304,1024,74,70),\nivec4(98304,1229,45,55),\nivec4(98304,1229,50,55),\nivec4(98304,1229,54,55),\nivec4(98304,1229,57,55),\nivec4(98304,1229,62,55),\nivec4(98304,1229,66,55),\nivec4(99072,128,69,64),\nivec4(99200,128,71,64),\nivec4(99328,205,69,64),\nivec4(99840,205,57,49),\nivec4(99840,205,59,49),\nivec4(99840,205,62,49),\nivec4(99840,205,66,61),\nivec4(100352,1024,45,47),\nivec4(100352,1024,52,47),\nivec4(100352,1024,55,47),\nivec4(100352,1024,57,47),\nivec4(100352,1024,61,47),\nivec4(100352,1024,64,57),\nivec4(101376,1024,38,44),\nivec4(101376,1024,45,44),\nivec4(101376,1024,50,44),\nivec4(101376,1024,54,44),\nivec4(101376,1024,57,44),\nivec4(101376,1024,62,51),\nivec4(102400,307,26,75),\nivec4(102400,307,38,75),\nivec4(102912,205,54,50),\nivec4(102912,205,57,50),\nivec4(102912,205,62,50),\nivec4(102912,512,69,80),\nivec4(102912,512,78,80),\nivec4(102912,512,81,80),\nivec4(103424,205,42,50),\nivec4(103424,205,54,50),\nivec4(103424,768,67,80),\nivec4(103424,768,76,80),\nivec4(103424,768,79,80),\nivec4(103936,205,54,50),\nivec4(103936,205,57,50),\nivec4(103936,205,62,50),\nivec4(104192,256,66,80),\nivec4(104192,256,74,80),\nivec4(104192,256,78,80),\nivec4(104448,205,45,50),\nivec4(104448,205,57,50),\nivec4(104448,1536,78,80),\nivec4(104448,1536,81,80),\nivec4(104960,256,57,75),\nivec4(104960,256,69,75),\nivec4(105216,256,59,75),\nivec4(105216,256,71,75),\nivec4(105472,307,60,75),\nivec4(105472,307,72,75),\nivec4(105984,307,61,75),\nivec4(105984,307,73,75),\nivec4(105984,512,76,80),\nivec4(105984,512,79,80),\nivec4(106496,205,38,55),\nivec4(106496,205,50,55),\nivec4(106496,1024,76,75),\nivec4(106496,1024,78,75),\nivec4(107008,205,54,55),\nivec4(107008,205,57,55),\nivec4(107008,205,62,55),\nivec4(107008,512,69,70),\nivec4(107520,205,42,55),\nivec4(107520,205,54,55),\nivec4(107520,768,67,70),\nivec4(107520,1024,81,75),\nivec4(108032,205,54,55),\nivec4(108032,205,57,55),\nivec4(108032,205,62,55),\nivec4(108288,256,66,70),\nivec4(108544,205,33,55),\nivec4(108544,205,45,55),\nivec4(108544,1536,71,75),\nivec4(108544,1536,78,75),\nivec4(109056,256,45,80),\nivec4(109056,256,57,80),\nivec4(109312,256,47,80),\nivec4(109312,256,59,80),\nivec4(109568,307,48,80),\nivec4(109568,307,60,80),\nivec4(110080,0,69,75),\nivec4(110080,307,49,80),\nivec4(110080,307,61,80),\nivec4(110080,512,67,70),\nivec4(110080,512,76,75),\nivec4(110592,205,38,50),\nivec4(110592,205,50,50),\nivec4(110592,512,66,50),\nivec4(110592,1024,74,64),\nivec4(111104,205,50,52),\nivec4(111104,205,57,52),\nivec4(111616,0,69,68),\nivec4(111616,205,54,54),\nivec4(111616,205,62,54),\nivec4(111616,768,67,54),\nivec4(112128,205,42,56),\nivec4(112128,205,54,56),\nivec4(112384,256,66,57),\nivec4(112640,205,43,58),\nivec4(112640,205,55,58),\nivec4(112640,205,69,58),\nivec4(112640,205,71,72),\nivec4(113152,205,55,59),\nivec4(113152,205,59,59),\nivec4(113152,205,62,59),\nivec4(113152,205,67,59),\nivec4(113152,205,71,59),\nivec4(113152,205,74,74),\nivec4(113664,205,57,61),\nivec4(113664,205,61,61),\nivec4(113664,205,64,61),\nivec4(113664,512,69,61),\nivec4(113664,512,73,61),\nivec4(113664,1024,76,76),\nivec4(114176,205,45,63),\nivec4(114176,205,57,63),\nivec4(114176,512,67,63),\nivec4(114176,512,71,63),\nivec4(114688,205,50,65),\nivec4(114688,205,62,65),\nivec4(114688,205,74,65),\nivec4(114688,205,78,80),\nivec4(115200,205,62,67),\nivec4(115200,205,66,67),\nivec4(115200,205,69,67),\nivec4(115200,205,74,67),\nivec4(115200,205,78,67),\nivec4(115200,205,81,81),\nivec4(115712,205,64,69),\nivec4(115712,205,68,69),\nivec4(115712,205,71,69),\nivec4(115712,512,76,69),\nivec4(115712,512,80,69),\nivec4(115712,1024,83,83),\nivec4(116224,205,52,71),\nivec4(116224,205,64,71),\nivec4(116224,512,74,71),\nivec4(116224,512,78,71),\nivec4(116736,128,73,87),\nivec4(116736,512,45,73),\nivec4(116736,512,57,73),\nivec4(116864,128,85,88),\nivec4(116992,128,73,88),\nivec4(117120,128,85,89),\nivec4(117248,128,73,89),\nivec4(117248,205,59,74),\nivec4(117248,205,61,74),\nivec4(117248,205,67,74),\nivec4(117376,128,85,90),\nivec4(117504,128,73,90),\nivec4(117632,128,85,91),\nivec4(117760,128,73,91),\nivec4(117760,768,57,76),\nivec4(117760,768,61,76),\nivec4(117760,768,66,76),\nivec4(117888,128,85,92),\nivec4(118016,128,73,92),\nivec4(118144,128,85,93),\nivec4(118272,128,73,93),\nivec4(118400,128,85,94),\nivec4(118528,128,73,94),\nivec4(118528,256,55,79),\nivec4(118528,256,59,79),\nivec4(118528,256,64,79),\nivec4(118656,128,85,95),\nivec4(118784,205,54,90),\nivec4(118784,205,62,90),\nivec4(119296,512,74,90),\nivec4(119296,512,78,90),\nivec4(119296,512,86,90),\nivec4(119808,205,42,90),\nivec4(119808,205,54,90),\nivec4(119808,768,73,90),\nivec4(119808,768,78,90),\nivec4(119808,768,85,90),\nivec4(120320,205,54,90),\nivec4(120320,205,57,90),\nivec4(120320,205,62,90),\nivec4(120576,256,74,90),\nivec4(120576,256,86,90),\nivec4(120832,205,55,90),\nivec4(120832,205,59,90),\nivec4(120832,205,62,90),\nivec4(120832,512,71,90),\nivec4(120832,1024,83,90),\nivec4(121344,205,43,90),\nivec4(121344,205,55,90),\nivec4(121344,512,79,90),\nivec4(121856,205,45,90),\nivec4(121856,205,57,90),\nivec4(121856,512,73,90),\nivec4(121856,512,78,90),\nivec4(121856,512,85,90),\nivec4(122368,205,57,90),\nivec4(122368,205,61,90),\nivec4(122368,205,67,90),\nivec4(122368,512,69,90),\nivec4(122368,512,76,90),\nivec4(122368,512,81,90),\nivec4(122880,205,59,90),\nivec4(122880,205,62,90),\nivec4(122880,307,66,90),\nivec4(122880,307,74,90),\nivec4(122880,307,78,90),\nivec4(123392,1024,71,90),\nivec4(123392,1024,74,90),\nivec4(123392,1024,83,90),\nivec4(123648,102,38,90),\nivec4(123648,102,50,90),\nivec4(123904,205,40,90),\nivec4(123904,205,52,90),\nivec4(124416,205,42,90),\nivec4(124416,205,54,90),\nivec4(124416,512,69,90),\nivec4(124416,512,72,90),\nivec4(124416,512,81,90),\nivec4(124928,205,43,90),\nivec4(124928,205,55,90),\nivec4(124928,512,67,90),\nivec4(124928,512,72,90),\nivec4(124928,512,74,90),\nivec4(125440,205,55,55),\nivec4(125440,205,59,55),\nivec4(125440,205,62,55),\nivec4(125440,512,71,90),\nivec4(125440,512,79,90),\nivec4(125952,205,59,55),\nivec4(125952,205,63,55),\nivec4(125952,1024,69,90),\nivec4(125952,1024,71,90),\nivec4(125952,1024,78,90),\nivec4(126464,205,47,55),\nivec4(126464,205,59,55),\nivec4(126976,205,40,64),\nivec4(126976,205,52,64),\nivec4(126976,512,71,64),\nivec4(126976,1024,68,64),\nivec4(127488,205,52,68),\nivec4(127488,205,56,68),\nivec4(127488,205,62,68),\nivec4(127488,512,73,68),\nivec4(128000,205,54,72),\nivec4(128000,205,57,72),\nivec4(128000,205,62,72),\nivec4(128000,256,74,72),\nivec4(128000,1024,69,72),\nivec4(128256,768,78,74),\nivec4(128512,205,42,76),\nivec4(128512,205,54,76),\nivec4(129024,205,47,80),\nivec4(129024,205,59,80),\nivec4(129024,512,76,80),\nivec4(129024,1024,69,80),\nivec4(129024,1024,74,80),\nivec4(129536,205,59,83),\nivec4(129536,205,62,83),\nivec4(129536,205,66,83),\nivec4(129536,512,78,83),\nivec4(130048,256,80,87),\nivec4(130048,512,68,87),\nivec4(130048,1024,59,87),\nivec4(130048,1024,62,87),\nivec4(130048,1024,64,87),\nivec4(130048,1024,73,87),\nivec4(130048,1024,76,87),\nivec4(130304,768,83,89),\nivec4(130560,512,71,91),\nivec4(131072,512,45,95),\nivec4(131072,512,57,95),\nivec4(131072,1024,74,95),\nivec4(131072,1024,78,95),\nivec4(131072,1024,86,95),\nivec4(131584,256,62,95),\nivec4(131840,256,64,95),\nivec4(132096,205,57,95),\nivec4(132096,205,66,95),\nivec4(132096,205,74,95),\nivec4(132096,205,81,95),\nivec4(132608,205,59,95),\nivec4(132608,205,67,95),\nivec4(132608,205,74,95),\nivec4(132608,205,78,95),\nivec4(133120,1024,57,95),\nivec4(133120,1024,61,95),\nivec4(133120,1024,64,95),\nivec4(133120,1024,67,95),\nivec4(133120,1024,69,95),\nivec4(133120,1024,73,95),\nivec4(133120,1024,76,95),\nivec4(134144,1024,50,95),\nivec4(134144,1024,57,95),\nivec4(134144,1024,62,95),\nivec4(134144,1024,66,95),\nivec4(134144,1024,69,95),\nivec4(134144,1024,74,95),\nivec4(135168,1024,38,110),\nivec4(135168,1024,45,110),\nivec4(135168,1024,50,110),\nivec4(135168,1024,53,110),\nivec4(135168,1024,57,110),\nivec4(135168,1024,62,110),\nivec4(135168,1024,65,110),\nivec4(136192,1024,45,110),\nivec4(136192,1024,53,110),\nivec4(136192,1024,57,110),\nivec4(136192,1024,60,110),\nivec4(136192,1024,65,110),\nivec4(136192,1024,69,110),\nivec4(136192,1024,72,110),\nivec4(137216,1024,46,110),\nivec4(137216,1024,53,110),\nivec4(137216,1024,58,110),\nivec4(137216,1024,62,110),\nivec4(137216,1024,65,110),\nivec4(137216,1024,69,110),\nivec4(137216,1024,74,110),\nivec4(138240,1024,48,110),\nivec4(138240,1024,55,110),\nivec4(138240,1024,60,110),\nivec4(138240,1024,64,110),\nivec4(138240,1024,67,110),\nivec4(138240,1024,70,110),\nivec4(138240,1024,76,110),\nivec4(139264,256,77,60),\nivec4(139264,512,50,50),\nivec4(139264,512,62,50),\nivec4(139264,512,65,50),\nivec4(139520,256,76,63),\nivec4(139776,512,52,56),\nivec4(139776,512,64,56),\nivec4(139776,512,67,56),\nivec4(139776,512,77,66),\nivec4(140288,256,76,72),\nivec4(140288,512,53,62),\nivec4(140288,512,65,62),\nivec4(140288,512,69,62),\nivec4(140544,256,74,75),\nivec4(140800,512,55,68),\nivec4(140800,512,70,68),\nivec4(140800,512,76,78),\nivec4(141312,0,67,74),\nivec4(141312,512,57,74),\nivec4(141312,512,60,74),\nivec4(141312,512,64,74),\nivec4(141312,512,69,84),\nivec4(141824,1024,50,80),\nivec4(141824,1024,57,80),\nivec4(141824,1024,62,80),\nivec4(141824,1024,65,80),\nivec4(141824,1024,69,80),\nivec4(141824,1024,74,80),\nivec4(142592,128,29,80),\nivec4(142720,128,41,80),\nivec4(142848,1024,58,80),\nivec4(142848,1024,60,80),\nivec4(142848,1024,63,80),\nivec4(142848,1024,67,80),\nivec4(142848,1024,72,80),\nivec4(143872,1024,53,80),\nivec4(143872,1024,57,80),\nivec4(143872,1024,60,80),\nivec4(143872,1024,63,80),\nivec4(143872,1024,65,80),\nivec4(144896,512,34,80),\nivec4(144896,512,46,80),\nivec4(144896,512,62,80),\nivec4(144896,512,70,80),\nivec4(145408,256,69,80),\nivec4(145408,512,36,80),\nivec4(145408,512,48,80),\nivec4(145408,512,63,80),\nivec4(145664,256,67,80),\nivec4(145920,512,37,80),\nivec4(145920,512,49,80),\nivec4(145920,512,64,80),\nivec4(145920,512,69,80),\nivec4(146432,512,38,80),\nivec4(146432,512,50,80),\nivec4(146432,512,54,80),\nivec4(146432,512,57,80),\nivec4(146432,512,60,80),\nivec4(146432,512,62,80),\nivec4(146944,512,43,80),\nivec4(146944,512,50,80),\nivec4(146944,512,55,80),\nivec4(146944,512,58,80),\nivec4(146944,512,62,80),\nivec4(146944,512,67,80),\nivec4(147456,256,74,50),\nivec4(147712,256,76,50),\nivec4(147968,256,77,45),\nivec4(147968,512,56,50),\nivec4(147968,512,62,50),\nivec4(147968,512,70,50),\nivec4(148224,256,76,46),\nivec4(148480,512,57,52),\nivec4(148480,512,62,52),\nivec4(148480,512,69,52),\nivec4(148480,512,77,48),\nivec4(148992,512,58,54),\nivec4(148992,512,62,54),\nivec4(148992,512,68,54),\nivec4(148992,768,74,50),\nivec4(149504,512,57,55),\nivec4(149504,512,62,55),\nivec4(149504,512,69,55),\nivec4(149760,256,76,55),\nivec4(150016,256,77,56),\nivec4(150016,512,56,57),\nivec4(150016,512,62,57),\nivec4(150016,512,70,57),\nivec4(150272,256,76,57),\nivec4(150528,512,55,59),\nivec4(150528,512,62,59),\nivec4(150528,512,71,59),\nivec4(150528,512,77,59),\nivec4(151040,512,54,61),\nivec4(151040,512,62,61),\nivec4(151040,512,70,61),\nivec4(151040,512,74,61),\nivec4(151552,1024,53,63),\nivec4(151552,1024,59,63),\nivec4(151552,1024,62,63),\nivec4(151552,1024,71,63),\nivec4(151552,1024,79,64),\nivec4(152576,1024,52,66),\nivec4(152576,1024,56,66),\nivec4(152576,1024,62,66),\nivec4(152576,1024,68,70),\nivec4(152576,1024,72,66),\nivec4(152576,1024,80,70),\nivec4(153600,512,57,60),\nivec4(153600,512,61,60),\nivec4(153600,512,64,60),\nivec4(153600,512,69,60),\nivec4(153600,512,73,80),\nivec4(153600,512,81,80),\nivec4(154112,512,69,60),\nivec4(154112,512,73,60),\nivec4(154112,512,76,60),\nivec4(154112,512,81,80),\nivec4(154112,512,88,80),\nivec4(154624,512,71,60),\nivec4(154624,512,74,60),\nivec4(154624,512,78,60),\nivec4(154624,512,83,80),\nivec4(154624,512,90,80),\nivec4(155136,256,88,80),\nivec4(155136,512,64,60),\nivec4(155136,512,71,60),\nivec4(155136,512,74,60),\nivec4(155136,512,79,60),\nivec4(155392,256,86,80),\nivec4(155648,512,57,60),\nivec4(155648,512,64,60),\nivec4(155648,512,69,60),\nivec4(155648,512,81,80),\nivec4(155648,512,88,80),\nivec4(156160,512,69,60),\nivec4(156160,512,73,60),\nivec4(156160,512,76,60),\nivec4(156160,512,81,80),\nivec4(156160,512,85,80),\nivec4(156672,171,86,80),\nivec4(156672,512,71,60),\nivec4(156672,512,74,60),\nivec4(156672,512,78,60),\nivec4(156672,1024,79,60),\nivec4(156843,170,88,80),\nivec4(157013,171,86,80),\nivec4(157184,256,85,80),\nivec4(157184,512,64,60),\nivec4(157184,512,71,60),\nivec4(157184,512,74,60),\nivec4(157440,256,83,80),\nivec4(157696,512,57,60),\nivec4(157696,512,64,60),\nivec4(157696,512,69,60),\nivec4(157696,512,81,80),\nivec4(157696,512,85,80),\nivec4(158208,512,69,60),\nivec4(158208,512,73,60),\nivec4(158208,512,76,60),\nivec4(158208,512,81,80),\nivec4(158720,256,83,80),\nivec4(158720,512,71,60),\nivec4(158720,512,74,60),\nivec4(158976,256,78,80),\nivec4(159232,0,78,80),\nivec4(159232,512,64,60),\nivec4(159232,512,71,60),\nivec4(159232,512,74,60),\nivec4(159488,256,79,80),\nivec4(159744,512,57,60),\nivec4(159744,512,64,60),\nivec4(159744,512,69,60),\nivec4(159744,512,81,80),\nivec4(160256,512,52,60),\nivec4(160256,512,59,60),\nivec4(160256,512,64,60),\nivec4(160256,512,67,80),\nivec4(160256,512,71,80),\nivec4(160256,512,74,80),\nivec4(160256,512,78,80),\nivec4(160768,512,57,60),\nivec4(160768,512,61,60),\nivec4(160768,512,64,60),\nivec4(160768,512,69,80),\nivec4(160768,512,73,80),\nivec4(160768,512,76,80),\nivec4(161280,512,45,60),\nivec4(161280,512,57,60),\nivec4(161280,512,69,80),\nivec4(161792,205,38,75),\nivec4(161792,205,50,75),\nivec4(161792,307,62,75),\nivec4(162304,512,74,75),\nivec4(162304,512,78,75),\nivec4(162304,512,86,75),\nivec4(162816,205,42,55),\nivec4(162816,205,54,55),\nivec4(162816,768,73,75),\nivec4(162816,768,78,75),\nivec4(162816,768,85,75),\nivec4(163328,205,54,55),\nivec4(163328,205,57,55),\nivec4(163328,205,62,55),\nivec4(163584,256,74,75),\nivec4(163584,256,86,75),\nivec4(163840,205,55,55),\nivec4(163840,205,59,55),\nivec4(163840,205,62,55),\nivec4(163840,512,71,75),\nivec4(163840,1024,83,75),\nivec4(164352,205,43,55),\nivec4(164352,205,55,55),\nivec4(164352,512,79,75),\nivec4(164864,205,45,55),\nivec4(164864,205,57,55),\nivec4(164864,512,73,75),\nivec4(164864,512,78,75),\nivec4(164864,512,85,75),\nivec4(165376,205,57,55),\nivec4(165376,205,61,55),\nivec4(165376,205,67,55),\nivec4(165376,512,69,75),\nivec4(165376,512,76,75),\nivec4(165376,512,81,75),\nivec4(165888,205,59,55),\nivec4(165888,205,62,55),\nivec4(165888,307,66,75),\nivec4(165888,307,74,75),\nivec4(165888,307,78,75),\nivec4(166400,1024,71,75),\nivec4(166400,1024,74,75),\nivec4(166400,1024,83,75),\nivec4(166656,102,38,75),\nivec4(166656,102,50,75),\nivec4(166912,205,40,75),\nivec4(166912,205,52,75),\nivec4(167424,205,42,75),\nivec4(167424,205,54,75),\nivec4(167424,512,69,75),\nivec4(167424,512,72,75),\nivec4(167424,512,81,75),\nivec4(167936,205,43,75),\nivec4(167936,205,55,75),\nivec4(167936,512,67,75),\nivec4(167936,512,72,75),\nivec4(167936,512,74,75),\nivec4(168448,205,55,50),\nivec4(168448,205,59,50),\nivec4(168448,205,62,50),\nivec4(168448,512,71,75),\nivec4(168448,512,79,75),\nivec4(168960,205,59,50),\nivec4(168960,205,63,50),\nivec4(168960,1024,69,75),\nivec4(168960,1024,71,75),\nivec4(168960,1024,78,75),\nivec4(169472,205,47,50),\nivec4(169472,205,59,50),\nivec4(169984,205,40,40),\nivec4(169984,205,52,40),\nivec4(169984,512,71,40),\nivec4(169984,1024,68,40),\nivec4(170496,205,52,44),\nivec4(170496,205,56,44),\nivec4(170496,205,62,44),\nivec4(170496,512,73,46),\nivec4(171008,205,54,49),\nivec4(171008,205,57,49),\nivec4(171008,205,62,49),\nivec4(171008,256,74,51),\nivec4(171008,1024,69,49),\nivec4(171264,768,78,54),\nivec4(171520,205,42,53),\nivec4(171520,205,54,53),\nivec4(172032,205,47,58),\nivec4(172032,205,59,58),\nivec4(172032,512,76,63),\nivec4(172032,1024,69,58),\nivec4(172032,1024,74,58),\nivec4(172544,205,59,62),\nivec4(172544,205,62,62),\nivec4(172544,205,66,62),\nivec4(172544,512,78,68),\nivec4(173056,256,80,74),\nivec4(173056,512,68,66),\nivec4(173056,1024,59,66),\nivec4(173056,1024,62,66),\nivec4(173056,1024,64,66),\nivec4(173056,1024,73,66),\nivec4(173056,1024,76,66),\nivec4(173312,768,83,77),\nivec4(173568,512,71,71),\nivec4(174080,512,45,127),\nivec4(174080,512,57,127),\nivec4(174080,1024,74,110),\nivec4(174080,1024,78,110),\nivec4(174080,1024,86,127),\nivec4(174592,256,62,110),\nivec4(174848,256,64,110),\nivec4(175104,205,57,110),\nivec4(175104,205,66,110),\nivec4(175104,205,74,110),\nivec4(175104,205,81,110),\nivec4(175616,205,59,110),\nivec4(175616,205,67,110),\nivec4(175616,205,74,110),\nivec4(175616,205,78,110),\nivec4(176128,512,45,127),\nivec4(176128,512,57,127),\nivec4(176128,1024,74,110),\nivec4(176128,1024,78,110),\nivec4(176128,1024,86,127),\nivec4(176640,256,62,110),\nivec4(176896,256,64,110),\nivec4(177152,205,57,110),\nivec4(177152,205,66,110),\nivec4(177152,205,74,110),\nivec4(177152,205,81,110),\nivec4(177664,205,59,110),\nivec4(177664,205,67,110),\nivec4(177664,205,74,110),\nivec4(177664,205,78,110),\nivec4(178176,512,45,127),\nivec4(178176,512,57,127),\nivec4(178176,1024,74,110),\nivec4(178176,1024,78,110),\nivec4(178176,1024,86,127),\nivec4(178688,256,62,110),\nivec4(178944,256,64,110),\nivec4(179200,205,57,110),\nivec4(179200,205,66,110),\nivec4(179200,205,74,110),\nivec4(179200,205,81,110),\nivec4(179712,205,59,110),\nivec4(179712,205,67,110),\nivec4(179712,205,74,110),\nivec4(179712,205,78,110),\nivec4(180224,1024,62,110),\nivec4(180224,1024,67,110),\nivec4(180224,1024,69,110),\nivec4(180224,1024,71,110),\nivec4(180224,1024,74,110),\nivec4(180224,1024,76,110),\nivec4(181248,0,57,127),\nivec4(181248,0,64,127),\nivec4(181248,1024,45,127),\nivec4(181248,1024,52,127),\nivec4(181248,1024,55,127),\nivec4(181248,1024,61,127),\nivec4(182272,205,38,110),\nivec4(182272,205,45,110),\nivec4(182272,205,50,110),\nivec4(182272,205,54,110),\nivec4(182272,205,57,110),\nivec4(182272,205,62,110),\nivec4(182784,205,54,20),\nivec4(182784,205,57,20),\nivec4(182784,205,62,20),\nivec4(182784,205,69,20),\nivec4(183296,205,52,20),\nivec4(183296,205,59,20),\nivec4(183296,205,62,20),\nivec4(183296,205,67,20),\nivec4(183808,205,55,20),\nivec4(183808,205,57,20),\nivec4(183808,205,61,20),\nivec4(183808,205,64,20),\nivec4(184320,205,50,20),\nivec4(184320,205,57,20),\nivec4(184320,205,62,20),\nivec4(184320,205,66,20),\nivec4(184832,205,54,20),\nivec4(184832,205,57,20),\nivec4(184832,205,62,20),\nivec4(184832,205,69,20),\nivec4(185344,205,52,20),\nivec4(185344,205,59,20),\nivec4(185344,205,62,20),\nivec4(185344,205,67,20),\nivec4(185856,205,55,20),\nivec4(185856,205,57,20),\nivec4(185856,205,61,20),\nivec4(185856,205,64,20),\nivec4(186368,205,50,20),\nivec4(186368,205,57,20),\nivec4(186368,205,62,20),\nivec4(186368,205,66,20),\nivec4(186880,205,54,20),\nivec4(186880,205,59,20),\nivec4(186880,205,62,20),\nivec4(186880,205,69,20),\nivec4(187392,205,49,20),\nivec4(187392,205,56,20),\nivec4(187392,205,57,20),\nivec4(187392,205,64,20),\nivec4(187904,205,52,20),\nivec4(187904,205,57,20),\nivec4(187904,205,61,20),\nivec4(187904,205,69,20),\nivec4(188416,205,47,20),\nivec4(188416,205,54,20),\nivec4(188416,205,57,20),\nivec4(188416,205,62,20),\nivec4(188928,205,52,20),\nivec4(188928,205,59,20),\nivec4(188928,205,62,20),\nivec4(188928,205,68,20),\nivec4(189440,205,45,20),\nivec4(189440,205,52,20),\nivec4(189440,205,61,20),\nivec4(189440,205,69,20),\nivec4(189952,205,49,20),\nivec4(189952,205,57,20),\nivec4(189952,205,64,20),\nivec4(189952,205,67,20),\nivec4(190464,205,50,20),\nivec4(190464,205,57,20),\nivec4(190464,205,62,20),\nivec4(190464,205,66,20),\nivec4(190976,205,54,20),\nivec4(190976,205,57,20),\nivec4(190976,205,62,20),\nivec4(190976,205,69,20),\nivec4(191488,205,52,20),\nivec4(191488,205,59,20),\nivec4(191488,205,62,20),\nivec4(191488,205,67,20),\nivec4(192000,205,55,20),\nivec4(192000,205,57,20),\nivec4(192000,205,61,20),\nivec4(192000,205,64,20),\nivec4(192512,205,50,20),\nivec4(192512,205,57,20),\nivec4(192512,205,62,20),\nivec4(192512,205,66,20),\nivec4(193024,205,54,20),\nivec4(193024,205,57,20),\nivec4(193024,205,62,20),\nivec4(193024,205,69,20),\nivec4(193536,205,52,20),\nivec4(193536,205,59,20),\nivec4(193536,205,62,20),\nivec4(193536,205,67,20),\nivec4(194048,205,55,20),\nivec4(194048,205,57,20),\nivec4(194048,205,61,20),\nivec4(194048,205,64,20),\nivec4(194560,205,50,20),\nivec4(194560,205,57,20),\nivec4(194560,205,62,20),\nivec4(194560,205,66,20),\nivec4(195072,205,54,20),\nivec4(195072,205,59,20),\nivec4(195072,205,62,20),\nivec4(195072,205,69,20),\nivec4(195584,205,49,20),\nivec4(195584,205,56,20),\nivec4(195584,205,57,20),\nivec4(195584,205,64,20),\nivec4(196096,205,52,20),\nivec4(196096,205,57,20),\nivec4(196096,205,61,20),\nivec4(196096,205,69,20),\nivec4(196608,205,47,20),\nivec4(196608,205,54,20),\nivec4(196608,205,57,20),\nivec4(196608,205,62,20),\nivec4(197120,205,52,20),\nivec4(197120,205,59,20),\nivec4(197120,205,62,20),\nivec4(197120,205,68,20),\nivec4(197632,205,45,20),\nivec4(197632,205,52,20),\nivec4(197632,205,61,20),\nivec4(197632,205,69,20),\nivec4(198144,205,49,20),\nivec4(198144,205,57,20),\nivec4(198144,205,64,20),\nivec4(198144,205,67,20),\nivec4(198656,205,50,20),\nivec4(198656,205,57,20),\nivec4(198656,205,66,20),\nivec4(198656,2560,62,50),\nivec4(199168,205,54,20),\nivec4(199168,205,57,20),\nivec4(199168,205,69,20),\nivec4(199680,205,55,20),\nivec4(199680,205,59,20),\nivec4(199680,205,71,20),\nivec4(200192,205,57,20),\nivec4(200192,205,61,20),\nivec4(200192,205,67,20),\nivec4(200704,205,50,20),\nivec4(200704,205,57,20),\nivec4(200704,205,69,20),\nivec4(201216,205,50,20),\nivec4(201216,205,57,20),\nivec4(201216,512,62,20),\nivec4(201728,512,57,20),\nivec4(201728,512,61,50),\nivec4(201728,512,66,20),\nivec4(202240,512,55,20),\nivec4(202240,512,59,50),\nivec4(202240,512,67,20),\nivec4(202752,512,54,20),\nivec4(202752,512,57,50),\nivec4(202752,512,66,20),\nivec4(202752,512,69,20),\nivec4(203264,512,50,20),\nivec4(203264,512,57,20),\nivec4(203264,512,66,20),\nivec4(203264,512,74,50),\nivec4(203776,512,52,20),\nivec4(203776,512,59,20),\nivec4(203776,512,67,20),\nivec4(203776,512,73,50),\nivec4(204288,512,55,20),\nivec4(204288,512,61,20),\nivec4(204288,512,64,20),\nivec4(204288,512,71,50),\nivec4(204800,512,54,20),\nivec4(204800,512,59,20),\nivec4(204800,512,62,20),\nivec4(204800,512,69,50),\nivec4(205312,512,42,20),\nivec4(205312,512,49,20),\nivec4(205312,512,57,20),\nivec4(205312,512,66,50),\nivec4(205824,512,43,20),\nivec4(205824,512,50,20),\nivec4(205824,512,59,20),\nivec4(205824,1024,64,50),\nivec4(206336,512,45,20),\nivec4(206336,512,52,20),\nivec4(206336,512,57,20),\nivec4(206336,512,61,20),\nivec4(206848,205,50,20),\nivec4(206848,205,54,20),\nivec4(206848,205,59,20),\nivec4(206848,1024,66,50),\nivec4(207360,205,54,23),\nivec4(207360,205,57,23),\nivec4(207360,205,62,23),\nivec4(207872,205,52,25),\nivec4(207872,205,55,25),\nivec4(207872,205,61,25),\nivec4(207872,1024,67,55),\nivec4(208384,205,55,28),\nivec4(208384,205,59,28),\nivec4(208384,205,64,28),\nivec4(208896,205,54,30),\nivec4(208896,205,57,30),\nivec4(208896,205,62,30),\nivec4(208896,1024,69,60),\nivec4(209408,205,57,33),\nivec4(209408,205,61,33),\nivec4(209408,205,66,33),\nivec4(209920,205,55,35),\nivec4(209920,205,59,35),\nivec4(209920,205,64,35),\nivec4(209920,1024,71,65),\nivec4(210432,205,59,38),\nivec4(210432,205,62,38),\nivec4(210432,205,67,38),\nivec4(210944,205,57,40),\nivec4(210944,205,61,40),\nivec4(210944,205,66,40),\nivec4(210944,1024,73,64),\nivec4(211456,205,45,30),\nivec4(211456,205,55,30),\nivec4(211456,205,64,30),\nivec4(211968,205,47,20),\nivec4(211968,205,54,20),\nivec4(211968,205,62,20),\nivec4(211968,205,66,20),\nivec4(211968,512,74,50),\nivec4(212480,205,52,30),\nivec4(212480,205,59,30),\nivec4(212480,205,62,30),\nivec4(212480,512,67,64),\nivec4(212992,205,57,40),\nivec4(212992,205,61,40),\nivec4(212992,205,66,40),\nivec4(212992,1024,45,64),\nivec4(212992,1024,69,64),\nivec4(213504,205,55,30),\nivec4(213504,205,59,30),\nivec4(213504,205,61,30),\nivec4(213504,205,64,30),\nivec4(214016,1024,50,20),\nivec4(214016,1024,54,20),\nivec4(214016,1024,57,20),\nivec4(214016,1024,62,50),\nivec4(215040,205,50,15),\nivec4(215040,205,57,15),\nivec4(215040,205,66,15),\nivec4(215040,1536,78,40),\nivec4(215552,205,54,15),\nivec4(215552,205,62,15),\nivec4(215552,205,69,15),\nivec4(216064,205,55,15),\nivec4(216064,205,62,15),\nivec4(216064,205,71,15),\nivec4(216576,205,57,15),\nivec4(216576,205,67,15),\nivec4(216576,205,73,15),\nivec4(216576,512,76,40),\nivec4(217088,205,50,15),\nivec4(217088,205,57,15),\nivec4(217088,205,66,15),\nivec4(217088,1024,74,40),\nivec4(217600,205,54,15),\nivec4(217600,205,57,15),\nivec4(217600,205,62,15),\nivec4(217600,205,69,15),\nivec4(218112,205,55,15),\nivec4(218112,205,59,15),\nivec4(218112,205,62,15),\nivec4(218112,205,67,15),\nivec4(218112,1536,69,40),\nivec4(218624,205,57,15),\nivec4(218624,205,61,15),\nivec4(218624,205,64,15),\nivec4(219136,205,50,15),\nivec4(219136,205,57,15),\nivec4(219136,205,62,15),\nivec4(219136,205,66,15),\nivec4(219648,205,66,15),\nivec4(219648,205,69,15),\nivec4(219648,205,74,15),\nivec4(219648,512,81,40),\nivec4(220160,205,67,15),\nivec4(220160,205,71,15),\nivec4(220160,512,81,15),\nivec4(220160,512,83,40),\nivec4(220672,205,69,15),\nivec4(220672,205,73,15),\nivec4(220672,512,79,15),\nivec4(220672,512,85,40),\nivec4(221184,205,62,15),\nivec4(221184,205,69,15),\nivec4(221184,256,86,40),\nivec4(221184,512,78,15),\nivec4(221440,256,85,40),\nivec4(221696,205,64,15),\nivec4(221696,205,68,15),\nivec4(221696,256,76,15),\nivec4(221696,512,83,40),\nivec4(221952,256,74,15),\nivec4(222208,205,57,15),\nivec4(222208,205,64,15),\nivec4(222208,205,73,15),\nivec4(222208,1536,81,40),\nivec4(222720,205,55,15),\nivec4(222720,205,61,15),\nivec4(222720,205,71,15),\nivec4(223232,205,54,15),\nivec4(223232,205,62,15),\nivec4(223232,205,69,15),\nivec4(223744,205,50,15),\nivec4(223744,205,57,15),\nivec4(223744,205,66,15),\nivec4(223744,512,74,40),\nivec4(224256,205,55,15),\nivec4(224256,205,59,15),\nivec4(224256,512,62,15),\nivec4(224256,512,69,15),\nivec4(224256,768,71,40),\nivec4(224768,205,52,15),\nivec4(224768,205,55,15),\nivec4(224768,512,67,15),\nivec4(225024,256,73,40),\nivec4(225280,205,54,15),\nivec4(225280,205,57,15),\nivec4(225280,512,62,15),\nivec4(225280,512,67,15),\nivec4(225280,512,69,40),\nivec4(225792,205,50,15),\nivec4(225792,205,54,15),\nivec4(225792,512,66,15),\nivec4(225792,512,74,40),\nivec4(226304,512,47,15),\nivec4(226304,512,54,15),\nivec4(226304,512,62,15),\nivec4(226304,768,67,40),\nivec4(226816,512,49,15),\nivec4(226816,512,55,15),\nivec4(226816,512,64,15),\nivec4(227072,256,69,40),\nivec4(227328,205,50,20),\nivec4(227328,205,57,20),\nivec4(227328,205,62,20),\nivec4(227328,512,66,40),\nivec4(227840,205,49,20),\nivec4(227840,205,57,20),\nivec4(227840,205,64,25),\nivec4(227840,512,69,50),\nivec4(228352,205,47,20),\nivec4(228352,205,66,30),\nivec4(228352,256,57,20),\nivec4(228352,512,74,50),\nivec4(228608,256,56,20),\nivec4(228864,205,49,20),\nivec4(228864,205,64,30),\nivec4(228864,512,57,20),\nivec4(228864,512,73,50),\nivec4(229376,205,50,20),\nivec4(229376,512,64,27),\nivec4(229376,768,73,50),\nivec4(229376,1024,57,20),\nivec4(229376,1024,66,27),\nivec4(229888,205,47,20),\nivec4(229888,512,62,24),\nivec4(230144,256,71,42),\nivec4(230400,205,52,20),\nivec4(230400,256,73,40),\nivec4(230400,512,56,20),\nivec4(230400,512,64,21),\nivec4(230656,256,71,37),\nivec4(230912,205,57,20),\nivec4(230912,256,62,20),\nivec4(230912,512,64,18),\nivec4(230912,512,69,35),\nivec4(231168,256,61,20),\nivec4(231424,205,50,20),\nivec4(231424,205,57,20),\nivec4(231424,205,62,20),\nivec4(231424,205,66,20),\nivec4(231424,1024,72,40),\nivec4(231936,205,57,23),\nivec4(231936,205,60,23),\nivec4(231936,205,62,23),\nivec4(231936,205,66,23),\nivec4(231936,205,69,23),\nivec4(232448,205,55,26),\nivec4(232448,205,59,26),\nivec4(232448,205,62,26),\nivec4(232448,205,67,26),\nivec4(232448,1024,71,44),\nivec4(232960,205,53,29),\nivec4(232960,205,59,29),\nivec4(232960,205,62,29),\nivec4(232960,205,69,29),\nivec4(233472,205,52,33),\nivec4(233472,205,59,33),\nivec4(233472,205,64,33),\nivec4(233472,205,68,33),\nivec4(233472,1024,74,49),\nivec4(233984,205,59,36),\nivec4(233984,205,62,36),\nivec4(233984,205,64,36),\nivec4(233984,205,68,36),\nivec4(233984,205,71,36),\nivec4(234496,205,57,39),\nivec4(234496,205,61,39),\nivec4(234496,205,64,39),\nivec4(234496,205,69,39),\nivec4(234496,1024,73,53),\nivec4(235008,205,58,42),\nivec4(235008,205,61,42),\nivec4(235008,205,64,42),\nivec4(235008,205,67,42),\nivec4(235520,1024,59,45),\nivec4(235520,1024,62,45),\nivec4(235520,1024,66,45),\nivec4(235520,1024,74,58),\nivec4(236544,1024,47,70),\nivec4(236544,1024,56,70),\nivec4(236544,1024,62,70),\nivec4(236544,1024,66,70),\nivec4(236544,1024,68,70),\nivec4(236544,1024,78,81),\nivec4(237568,307,49,58),\nivec4(237568,307,56,58),\nivec4(237568,307,61,58),\nivec4(237568,307,64,58),\nivec4(237568,307,68,58),\nivec4(237568,307,76,66),\nivec4(238080,307,50,61),\nivec4(238080,307,57,61),\nivec4(238080,307,62,61),\nivec4(238080,307,64,61),\nivec4(238080,307,66,61),\nivec4(238080,307,73,68),\nivec4(238592,512,57,64),\nivec4(238592,1024,52,64),\nivec4(238592,1024,59,64),\nivec4(238592,1024,62,64),\nivec4(238592,1024,64,64),\nivec4(238592,1024,66,64),\nivec4(238592,1024,71,71),\nivec4(239104,512,56,67),\nivec4(239616,512,57,40),\nivec4(239616,512,61,40),\nivec4(239616,512,64,40),\nivec4(239616,512,69,40),\nivec4(240128,512,69,42),\nivec4(240128,512,73,42),\nivec4(240128,512,76,42),\nivec4(240128,512,81,56),\nivec4(240128,512,88,56),\nivec4(240640,512,71,44),\nivec4(240640,512,74,44),\nivec4(240640,512,78,44),\nivec4(240640,512,83,58),\nivec4(240640,512,90,58),\nivec4(241152,256,88,59),\nivec4(241152,512,64,45),\nivec4(241152,512,71,45),\nivec4(241152,512,74,45),\nivec4(241152,512,79,45),\nivec4(241408,256,86,59),\nivec4(241664,512,57,47),\nivec4(241664,512,64,47),\nivec4(241664,512,69,47),\nivec4(241664,512,81,60),\nivec4(241664,512,88,60),\nivec4(242176,512,69,49),\nivec4(242176,512,73,49),\nivec4(242176,512,76,49),\nivec4(242176,512,81,61),\nivec4(242176,512,85,61),\nivec4(242688,171,86,63),\nivec4(242688,512,71,51),\nivec4(242688,512,74,51),\nivec4(242688,512,78,51),\nivec4(242688,1024,79,51),\nivec4(242859,170,88,63),\nivec4(243029,171,86,63),\nivec4(243200,256,85,64),\nivec4(243200,512,64,52),\nivec4(243200,512,71,52),\nivec4(243200,512,74,52),\nivec4(243456,256,83,64),\nivec4(243712,512,57,54),\nivec4(243712,512,64,54),\nivec4(243712,512,69,54),\nivec4(243712,512,81,65),\nivec4(243712,512,85,65),\nivec4(244224,512,69,56),\nivec4(244224,512,73,56),\nivec4(244224,512,76,56),\nivec4(244224,512,81,66),\nivec4(244736,256,83,68),\nivec4(244736,512,71,58),\nivec4(244736,512,74,58),\nivec4(244992,256,78,68),\nivec4(245248,0,78,69),\nivec4(245248,512,64,59),\nivec4(245248,512,71,59),\nivec4(245248,512,74,59),\nivec4(245504,256,79,69),\nivec4(245760,512,57,61),\nivec4(245760,512,64,61),\nivec4(245760,512,69,61),\nivec4(245760,512,81,70),\nivec4(246272,171,78,71),\nivec4(246272,512,52,63),\nivec4(246272,512,59,63),\nivec4(246272,512,62,63),\nivec4(246272,512,74,63),\nivec4(246443,170,79,72),\nivec4(246613,171,78,72),\nivec4(246784,512,57,65),\nivec4(246784,512,61,65),\nivec4(246784,512,64,65),\nivec4(246784,512,73,65),\nivec4(246784,512,76,73),\nivec4(247296,512,52,66),\nivec4(247296,512,59,66),\nivec4(247296,512,62,66),\nivec4(247296,512,67,66),\nivec4(247296,512,71,66),\nivec4(247296,512,74,74),\nivec4(247808,512,45,68),\nivec4(247808,512,52,68),\nivec4(247808,512,57,68),\nivec4(247808,512,64,68),\nivec4(247808,512,67,68),\nivec4(247808,512,69,68),\nivec4(247808,512,73,75),\nivec4(248320,512,40,70),\nivec4(248320,512,47,70),\nivec4(248320,512,52,70),\nivec4(248320,512,62,70),\nivec4(248320,512,66,70),\nivec4(248320,512,67,70),\nivec4(248320,512,71,76),\nivec4(248832,512,45,72),\nivec4(248832,512,57,72),\nivec4(248832,1024,61,72),\nivec4(248832,1024,64,72),\nivec4(248832,1024,69,78),\nivec4(249344,512,43,92),\nivec4(249344,512,55,92),\nivec4(249856,512,42,109),\nivec4(249856,512,54,109),\nivec4(249856,1024,72,109),\nivec4(249856,1024,74,85),\nivec4(249856,1024,81,85),\nivec4(249856,1024,84,109),\nivec4(250368,512,54,90),\nivec4(250368,512,57,90),\nivec4(250368,512,62,90),\nivec4(250880,512,55,90),\nivec4(250880,512,59,90),\nivec4(250880,512,62,90),\nivec4(250880,1024,71,90),\nivec4(250880,1024,79,85),\nivec4(250880,1024,83,90),\nivec4(251392,512,41,109),\nivec4(251392,512,53,109),\nivec4(251904,0,74,109),\nivec4(251904,512,40,109),\nivec4(251904,512,52,109),\nivec4(251904,1024,76,85),\nivec4(251904,1024,80,85),\nivec4(251904,1024,86,109),\nivec4(252416,512,52,90),\nivec4(252416,512,56,90),\nivec4(252416,512,62,90),\nivec4(252928,512,57,90),\nivec4(252928,512,61,90),\nivec4(252928,512,64,90),\nivec4(252928,512,73,85),\nivec4(252928,512,81,85),\nivec4(252928,1024,85,90),\nivec4(253440,512,46,109),\nivec4(253440,512,58,109),\nivec4(253440,512,76,85),\nivec4(253440,512,79,85),\nivec4(253952,512,47,109),\nivec4(253952,512,74,109),\nivec4(253952,512,78,109),\nivec4(253952,512,83,109),\nivec4(253952,512,86,109),\nivec4(254464,0,59,85),\nivec4(254464,512,62,85),\nivec4(254464,512,68,85),\nivec4(254464,512,80,90),\nivec4(254464,512,90,90),\nivec4(254976,512,61,85),\nivec4(254976,512,64,85),\nivec4(254976,512,69,85),\nivec4(254976,512,81,90),\nivec4(254976,512,88,90),\nivec4(255488,512,62,85),\nivec4(255488,512,66,85),\nivec4(255488,512,69,85),\nivec4(255488,512,76,90),\nivec4(255488,512,78,90),\nivec4(255488,512,85,90),\nivec4(256000,1024,64,85),\nivec4(256000,1024,66,85),\nivec4(256000,1024,69,85),\nivec4(256000,1024,71,85),\nivec4(256000,1024,74,109),\nivec4(256000,1024,76,109),\nivec4(256000,1024,78,109),\nivec4(256000,1024,83,109),\nivec4(257024,1024,52,109),\nivec4(257024,1024,56,109),\nivec4(257024,1024,59,109),\nivec4(257024,1024,62,109),\nivec4(257024,1024,64,109),\nivec4(257024,1024,76,109),\nivec4(257024,1024,80,109),\nivec4(257024,1024,83,109),\nivec4(257024,1024,86,109),\nivec4(257024,1024,88,109),\nivec4(258048,3*512,57,89),\nivec4(258048,3*512,61,89),\nivec4(258048,3*512,64,89),\nivec4(258048,3*512,69,89),\nivec4(258048,3*512,81,89),\nivec4(258048,3*512,85,89),\nivec4(258048,3*512,88,89),\nivec4(258048,3*512,93,89));\n#elif TUNE == 4\nfloat speed = 1.0;\nconst ivec4 data[] = ivec4[](\nivec4(0,512,48,53),\nivec4(0,512,51,57),\nivec4(0,512,55,73),\nivec4(0,512,60,89),\nivec4(512,512,51,63),\nivec4(512,512,55,66),\nivec4(512,512,60,86),\nivec4(512,512,63,100),\nivec4(1024,512,55,67),\nivec4(1024,512,58,65),\nivec4(1024,512,62,86),\nivec4(1024,512,67,109),\nivec4(1536,256,72,111),\nivec4(1536,512,56,64),\nivec4(1536,512,60,66),\nivec4(1536,512,63,80),\nivec4(1792,128,74,101),\nivec4(1920,128,75,101),\nivec4(2048,128,77,103),\nivec4(2048,512,53,64),\nivec4(2048,512,60,63),\nivec4(2048,512,68,93),\nivec4(2176,128,75,88),\nivec4(2304,128,74,92),\nivec4(2432,128,72,89),\nivec4(2560,512,55,70),\nivec4(2560,512,59,64),\nivec4(2560,512,62,69),\nivec4(2560,512,71,88),\nivec4(3072,256,79,118),\nivec4(3072,1024,51,60),\nivec4(3072,1024,60,67),\nivec4(3072,1024,67,91),\nivec4(3328,128,72,84),\nivec4(3456,128,75,102),\nivec4(3584,128,79,109),\nivec4(3712,128,75,90),\nivec4(3840,256,72,82),\nivec4(4096,512,53,68),\nivec4(4096,512,60,65),\nivec4(4096,512,68,85),\nivec4(4096,512,80,116),\nivec4(4608,256,77,93),\nivec4(4608,1024,50,62),\nivec4(4608,1024,58,58),\nivec4(4608,1024,65,68),\nivec4(4864,128,70,77),\nivec4(4992,128,74,102),\nivec4(5120,128,77,106),\nivec4(5248,128,74,90),\nivec4(5376,256,70,85),\nivec4(5632,512,51,67),\nivec4(5632,512,58,61),\nivec4(5632,512,67,83),\nivec4(5632,512,79,123),\nivec4(6144,256,75,87),\nivec4(6144,1024,48,58),\nivec4(6144,1024,56,57),\nivec4(6144,1024,63,72),\nivec4(6400,128,68,77),\nivec4(6528,128,72,99),\nivec4(6656,128,75,108),\nivec4(6784,128,72,93),\nivec4(6912,256,68,85),\nivec4(7168,512,50,65),\nivec4(7168,512,56,62),\nivec4(7168,512,65,81),\nivec4(7168,512,77,116),\nivec4(7680,256,74,92),\nivec4(7680,1024,47,58),\nivec4(7680,1024,55,64),\nivec4(7680,1024,62,77),\nivec4(7936,128,67,79),\nivec4(8064,128,71,108),\nivec4(8192,128,74,101),\nivec4(8320,128,71,87),\nivec4(8448,256,67,85),\nivec4(8704,512,48,66),\nivec4(8704,512,55,67),\nivec4(8704,512,63,83),\nivec4(8704,512,75,113),\nivec4(9216,128,74,93),\nivec4(9216,512,53,68),\nivec4(9216,512,60,75),\nivec4(9216,512,68,93),\nivec4(9344,128,75,104),\nivec4(9472,128,74,92),\nivec4(9600,128,72,96),\nivec4(9728,256,71,89),\nivec4(9728,512,55,70),\nivec4(9728,512,62,71),\nivec4(9728,512,67,80),\nivec4(9984,256,75,105),\nivec4(10240,128,74,98),\nivec4(10240,512,56,65),\nivec4(10240,512,60,58),\nivec4(10240,512,65,81),\nivec4(10368,128,75,103),\nivec4(10496,128,74,92),\nivec4(10624,128,72,92),\nivec4(10752,256,67,78),\nivec4(10752,512,55,63),\nivec4(10752,512,59,62),\nivec4(10752,512,62,74),\nivec4(11008,256,72,107),\nivec4(11264,128,71,92),\nivec4(11264,512,55,62),\nivec4(11264,512,59,63),\nivec4(11264,512,62,79),\nivec4(11392,128,72,101),\nivec4(11520,128,74,100),\nivec4(11648,128,72,88),\nivec4(11776,512,48,56),\nivec4(11776,512,55,57),\nivec4(11776,512,63,85),\nivec4(11776,512,72,95),\nivec4(12288,512,51,70),\nivec4(12288,512,55,65),\nivec4(12288,512,58,73),\nivec4(12288,512,63,77),\nivec4(12800,512,51,63),\nivec4(12800,512,58,62),\nivec4(12800,512,63,89),\nivec4(12800,512,67,101),\nivec4(13312,512,50,61),\nivec4(13312,512,58,60),\nivec4(13312,512,65,87),\nivec4(13312,512,70,108),\nivec4(13824,256,75,114),\nivec4(13824,512,48,63),\nivec4(13824,512,60,63),\nivec4(13824,512,67,85),\nivec4(14080,128,77,105),\nivec4(14208,128,79,105),\nivec4(14336,128,80,100),\nivec4(14336,512,51,68),\nivec4(14336,512,56,58),\nivec4(14336,512,72,92),\nivec4(14464,128,79,91),\nivec4(14592,128,77,88),\nivec4(14720,128,75,92),\nivec4(14848,512,50,64),\nivec4(14848,512,58,68),\nivec4(14848,512,70,75),\nivec4(14848,512,74,93),\nivec4(15360,256,79,113),\nivec4(15360,512,51,66),\nivec4(15360,512,58,63),\nivec4(15360,512,75,90),\nivec4(15616,128,80,103),\nivec4(15744,128,79,92),\nivec4(15872,256,77,89),\nivec4(15872,512,50,58),\nivec4(15872,512,58,67),\nivec4(15872,512,70,74),\nivec4(16128,128,79,109),\nivec4(16256,128,77,90),\nivec4(16384,256,67,71),\nivec4(16384,256,75,92),\nivec4(16384,512,48,63),\nivec4(16384,512,55,58),\nivec4(16640,128,63,70),\nivec4(16640,256,60,61),\nivec4(16768,128,65,100),\nivec4(16896,256,67,99),\nivec4(16896,512,46,60),\nivec4(16896,512,58,66),\nivec4(16896,512,62,83),\nivec4(17152,128,68,102),\nivec4(17280,128,67,92),\nivec4(17408,256,65,90),\nivec4(17408,512,44,61),\nivec4(17408,512,56,59),\nivec4(17408,512,60,76),\nivec4(17664,128,67,102),\nivec4(17792,128,65,93),\nivec4(17920,256,58,77),\nivec4(17920,256,63,86),\nivec4(17920,512,43,60),\nivec4(17920,512,55,62),\nivec4(18176,128,75,125),\nivec4(18176,256,67,97),\nivec4(18304,128,74,98),\nivec4(18432,256,72,89),\nivec4(18432,512,56,72),\nivec4(18432,512,63,76),\nivec4(18432,512,68,93),\nivec4(18688,128,74,102),\nivec4(18816,128,72,89),\nivec4(18944,256,70,90),\nivec4(18944,512,55,67),\nivec4(18944,512,67,81),\nivec4(19200,128,72,98),\nivec4(19328,128,70,91),\nivec4(19456,0,63,72),\nivec4(19456,256,68,93),\nivec4(19456,512,53,64),\nivec4(19456,512,60,57),\nivec4(19712,128,77,113),\nivec4(19712,256,68,91),\nivec4(19840,128,75,93),\nivec4(19968,256,74,89),\nivec4(19968,512,58,65),\nivec4(19968,512,65,67),\nivec4(19968,512,70,84),\nivec4(20224,128,75,103),\nivec4(20352,128,74,92),\nivec4(20480,256,72,88),\nivec4(20480,512,56,64),\nivec4(20480,512,68,72),\nivec4(20736,128,74,100),\nivec4(20864,128,72,91),\nivec4(20992,0,65,68),\nivec4(20992,256,70,87),\nivec4(20992,512,55,65),\nivec4(20992,512,62,55),\nivec4(21248,128,79,117),\nivec4(21248,256,70,86),\nivec4(21376,128,77,95),\nivec4(21504,256,75,93),\nivec4(21504,512,60,66),\nivec4(21504,512,67,71),\nivec4(21504,512,72,84),\nivec4(21760,128,77,102),\nivec4(21888,128,75,96),\nivec4(22016,256,74,92),\nivec4(22016,512,58,61),\nivec4(22016,512,67,68),\nivec4(22016,512,70,75),\nivec4(22272,128,75,98),\nivec4(22400,128,74,91),\nivec4(22528,256,68,73),\nivec4(22528,256,72,88),\nivec4(22528,512,56,60),\nivec4(22528,512,63,55),\nivec4(22784,128,68,79),\nivec4(22784,256,77,110),\nivec4(22912,128,67,71),\nivec4(23040,256,65,77),\nivec4(23040,256,70,81),\nivec4(23040,512,62,61),\nivec4(23040,1024,58,66),\nivec4(23296,256,70,92),\nivec4(23296,256,75,104),\nivec4(23552,128,74,89),\nivec4(23552,512,65,67),\nivec4(23552,512,70,82),\nivec4(23680,128,75,107),\nivec4(23808,128,77,105),\nivec4(23936,128,75,87),\nivec4(24064,512,63,69),\nivec4(24064,512,67,69),\nivec4(24064,512,70,77),\nivec4(24064,512,75,95),\nivec4(24576,512,48,54),\nivec4(24576,512,51,55),\nivec4(24576,512,55,69),\nivec4(24576,512,60,69),\nivec4(25088,512,51,68),\nivec4(25088,512,55,66),\nivec4(25088,512,60,88),\nivec4(25088,512,63,97),\nivec4(25600,512,55,64),\nivec4(25600,512,58,64),\nivec4(25600,512,62,84),\nivec4(25600,512,67,111),\nivec4(26112,256,72,107),\nivec4(26112,512,56,62),\nivec4(26112,512,60,66),\nivec4(26112,512,63,87),\nivec4(26368,128,74,105),\nivec4(26496,128,75,105),\nivec4(26624,128,77,104),\nivec4(26624,512,53,62),\nivec4(26624,512,60,66),\nivec4(26624,512,68,91),\nivec4(26752,128,75,87),\nivec4(26880,128,74,89),\nivec4(27008,128,72,89),\nivec4(27136,512,55,61),\nivec4(27136,512,59,64),\nivec4(27136,512,62,75),\nivec4(27136,512,71,92),\nivec4(27648,256,79,114),\nivec4(27648,1024,51,61),\nivec4(27648,1024,60,63),\nivec4(27648,1024,67,83),\nivec4(27904,128,72,84),\nivec4(28032,128,75,102),\nivec4(28160,128,79,107),\nivec4(28288,128,75,83),\nivec4(28416,256,72,86),\nivec4(28672,512,53,68),\nivec4(28672,512,60,64),\nivec4(28672,512,68,86),\nivec4(28672,512,80,113),\nivec4(29184,256,77,91),\nivec4(29184,1024,50,63),\nivec4(29184,1024,58,66),\nivec4(29184,1024,65,70),\nivec4(29440,128,70,81),\nivec4(29568,128,74,102),\nivec4(29696,128,77,107),\nivec4(29824,128,74,89),\nivec4(29952,256,70,86),\nivec4(30208,512,51,68),\nivec4(30208,512,58,66),\nivec4(30208,512,67,81),\nivec4(30208,512,79,117),\nivec4(30720,256,75,90),\nivec4(30720,1024,48,64),\nivec4(30720,1024,56,58),\nivec4(30720,1024,63,68),\nivec4(30976,128,68,76),\nivec4(31104,128,72,102),\nivec4(31232,128,75,105),\nivec4(31360,128,72,90),\nivec4(31488,256,68,83),\nivec4(31744,512,50,65),\nivec4(31744,512,56,59),\nivec4(31744,512,65,79),\nivec4(31744,512,77,117),\nivec4(32256,256,74,93),\nivec4(32256,1024,47,63),\nivec4(32256,1024,55,61),\nivec4(32256,1024,62,75),\nivec4(32512,128,67,76),\nivec4(32640,128,71,102),\nivec4(32768,128,74,106),\nivec4(32896,128,71,90),\nivec4(33024,256,67,82),\nivec4(33280,512,48,65),\nivec4(33280,512,55,65),\nivec4(33280,512,63,81),\nivec4(33280,512,75,115),\nivec4(33792,128,74,98),\nivec4(33792,512,53,69),\nivec4(33792,512,60,73),\nivec4(33792,512,68,93),\nivec4(33920,128,75,100),\nivec4(34048,128,74,93),\nivec4(34176,128,72,89),\nivec4(34304,256,71,90),\nivec4(34304,512,55,65),\nivec4(34304,512,62,70),\nivec4(34304,512,67,73),\nivec4(34560,256,75,105),\nivec4(34816,128,74,94),\nivec4(34816,512,56,67),\nivec4(34816,512,60,61),\nivec4(34816,512,65,71),\nivec4(34944,128,75,99),\nivec4(35072,128,74,94),\nivec4(35200,128,72,93),\nivec4(35328,256,67,83),\nivec4(35328,512,55,62),\nivec4(35328,512,59,63),\nivec4(35328,512,62,76),\nivec4(35584,256,72,103),\nivec4(35840,128,71,92),\nivec4(35840,512,55,64),\nivec4(35840,512,59,60),\nivec4(35840,512,62,78),\nivec4(35968,128,72,100),\nivec4(36096,128,74,102),\nivec4(36224,128,72,94),\nivec4(36352,512,48,60),\nivec4(36352,512,55,61),\nivec4(36352,512,63,81),\nivec4(36352,512,72,92),\nivec4(36864,384,70,87),\nivec4(36864,512,62,72),\nivec4(36864,1024,55,68),\nivec4(36864,1024,65,91),\nivec4(37248,128,72,105),\nivec4(37376,128,70,88),\nivec4(37376,256,63,68),\nivec4(37504,128,72,105),\nivec4(37632,256,62,64),\nivec4(37632,256,74,104),\nivec4(37888,128,75,101),\nivec4(37888,512,55,65),\nivec4(37888,512,60,61),\nivec4(38016,128,74,93),\nivec4(38144,128,72,93),\nivec4(38272,128,70,88),\nivec4(38400,384,69,89),\nivec4(38400,768,62,65),\nivec4(38400,1024,50,56),\nivec4(38400,1024,66,70),\nivec4(38784,128,70,97),\nivec4(38912,128,69,97),\nivec4(39040,128,70,99),\nivec4(39168,256,60,60),\nivec4(39168,256,72,99),\nivec4(39424,128,74,104),\nivec4(39424,512,54,67),\nivec4(39424,512,62,63),\nivec4(39552,128,72,91),\nivec4(39680,128,70,91),\nivec4(39808,128,69,87),\nivec4(39936,384,70,100),\nivec4(39936,1024,55,67),\nivec4(39936,1024,62,64),\nivec4(39936,1024,67,76),\nivec4(40320,128,72,107),\nivec4(40448,128,70,92),\nivec4(40576,128,72,103),\nivec4(40704,256,74,100),\nivec4(40960,128,75,103),\nivec4(40960,512,55,60),\nivec4(40960,512,63,70),\nivec4(40960,512,67,80),\nivec4(41088,128,74,93),\nivec4(41216,256,72,95),\nivec4(41472,51,70,89),\nivec4(41472,512,62,59),\nivec4(41472,512,67,79),\nivec4(41472,1024,50,58),\nivec4(41534,49,72,89),\nivec4(41593,47,70,89),\nivec4(41650,45,72,89),\nivec4(41704,43,70,89),\nivec4(41758,43,72,89),\nivec4(41814,44,70,89),\nivec4(41873,47,72,89),\nivec4(41934,48,70,89),\nivec4(41984,256,70,97),\nivec4(41984,512,66,77),\nivec4(42240,256,69,90),\nivec4(42496,0,62,68),\nivec4(42496,512,55,63),\nivec4(42496,512,59,62),\nivec4(42496,512,67,90),\nivec4(43008,384,74,119),\nivec4(43008,768,59,68),\nivec4(43008,1024,55,63),\nivec4(43008,1024,67,88),\nivec4(43392,128,75,114),\nivec4(43520,128,74,96),\nivec4(43648,128,75,99),\nivec4(43776,256,60,67),\nivec4(43776,256,77,101),\nivec4(44032,128,79,105),\nivec4(44032,512,55,62),\nivec4(44032,512,62,69),\nivec4(44032,512,71,96),\nivec4(44160,128,77,91),\nivec4(44288,128,75,92),\nivec4(44416,128,74,95),\nivec4(44544,384,75,98),\nivec4(44544,768,63,62),\nivec4(44544,1024,55,59),\nivec4(44544,1024,72,85),\nivec4(44928,128,77,103),\nivec4(45056,128,75,91),\nivec4(45184,128,77,107),\nivec4(45312,256,62,59),\nivec4(45312,256,79,99),\nivec4(45568,128,80,101),\nivec4(45568,512,56,61),\nivec4(45568,512,60,65),\nivec4(45568,512,72,81),\nivec4(45696,128,79,93),\nivec4(45824,128,77,97),\nivec4(45952,128,75,91),\nivec4(46080,384,74,88),\nivec4(46080,768,62,70),\nivec4(46080,1024,53,61),\nivec4(46080,1024,68,74),\nivec4(46464,128,75,98),\nivec4(46592,128,74,95),\nivec4(46720,128,75,96),\nivec4(46848,256,60,56),\nivec4(46848,256,77,103),\nivec4(47104,128,79,100),\nivec4(47104,512,55,66),\nivec4(47104,512,62,70),\nivec4(47104,512,71,81),\nivec4(47232,128,77,86),\nivec4(47360,128,75,88),\nivec4(47488,128,74,90),\nivec4(47616,256,63,68),\nivec4(47616,256,75,101),\nivec4(47616,512,55,63),\nivec4(47616,512,72,89),\nivec4(47872,256,62,59),\nivec4(47872,256,77,103),\nivec4(48128,46,77,95),\nivec4(48128,512,56,67),\nivec4(48128,512,60,60),\nivec4(48128,512,72,84),\nivec4(48184,44,79,95),\nivec4(48238,43,77,95),\nivec4(48289,40,79,95),\nivec4(48338,39,77,95),\nivec4(48385,37,79,95),\nivec4(48434,39,77,95),\nivec4(48485,40,79,95),\nivec4(48538,42,77,95),\nivec4(48593,44,79,95),\nivec4(48640,512,62,68),\nivec4(48640,512,71,77),\nivec4(48640,512,79,100),\nivec4(49152,0,55,74),\nivec4(49152,512,48,58),\nivec4(49152,512,51,51),\nivec4(49152,512,60,72),\nivec4(49664,512,51,64),\nivec4(49664,512,55,64),\nivec4(49664,512,60,92),\nivec4(49664,512,63,106),\nivec4(50176,512,55,68),\nivec4(50176,512,58,66),\nivec4(50176,512,62,88),\nivec4(50176,512,67,107),\nivec4(50688,256,72,104),\nivec4(50688,512,56,67),\nivec4(50688,512,60,63),\nivec4(50688,512,63,84),\nivec4(50944,128,74,109),\nivec4(51072,128,75,105),\nivec4(51200,128,77,102),\nivec4(51200,512,53,59),\nivec4(51200,512,60,65),\nivec4(51200,512,68,89),\nivec4(51328,128,75,93),\nivec4(51456,128,74,90),\nivec4(51584,128,72,94),\nivec4(51712,512,55,66),\nivec4(51712,512,59,60),\nivec4(51712,512,62,69),\nivec4(51712,512,71,90),\nivec4(52224,256,79,115),\nivec4(52224,1024,51,65),\nivec4(52224,1024,60,67),\nivec4(52224,1024,67,95),\nivec4(52480,128,72,79),\nivec4(52608,128,75,99),\nivec4(52736,128,79,112),\nivec4(52864,128,75,82),\nivec4(52992,256,72,88),\nivec4(53248,512,53,65),\nivec4(53248,512,60,67),\nivec4(53248,512,68,85),\nivec4(53248,512,80,113),\nivec4(53760,256,77,96),\nivec4(53760,1024,50,59),\nivec4(53760,1024,58,58),\nivec4(53760,1024,65,68),\nivec4(54016,128,70,82),\nivec4(54144,128,74,106),\nivec4(54272,128,77,106),\nivec4(54400,128,74,87),\nivec4(54528,256,70,80),\nivec4(54784,512,51,64),\nivec4(54784,512,58,61),\nivec4(54784,512,67,85),\nivec4(54784,512,79,118),\nivec4(55296,256,75,89),\nivec4(55296,1024,48,59),\nivec4(55296,1024,56,61),\nivec4(55296,1024,63,71),\nivec4(55552,128,68,75),\nivec4(55680,128,72,102),\nivec4(55808,128,75,110),\nivec4(55936,128,72,85),\nivec4(56064,256,68,89),\nivec4(56320,512,50,69),\nivec4(56320,512,56,63),\nivec4(56320,512,65,83),\nivec4(56320,512,77,114),\nivec4(56832,256,74,85),\nivec4(56832,1024,47,68),\nivec4(56832,1024,55,62),\nivec4(56832,1024,62,73),\nivec4(57088,128,67,79),\nivec4(57216,128,71,108),\nivec4(57344,128,74,106),\nivec4(57472,128,71,90),\nivec4(57600,256,67,87),\nivec4(57856,512,48,68),\nivec4(57856,512,55,63),\nivec4(57856,512,63,83),\nivec4(57856,512,75,110),\nivec4(58368,128,74,90),\nivec4(58368,512,53,73),\nivec4(58368,512,60,70),\nivec4(58368,512,68,93),\nivec4(58496,128,75,101),\nivec4(58624,128,74,96),\nivec4(58752,128,72,92),\nivec4(58880,256,71,88),\nivec4(58880,512,55,61),\nivec4(58880,512,62,68),\nivec4(58880,512,67,76),\nivec4(59136,256,75,101),\nivec4(59392,128,74,91),\nivec4(59392,512,56,63),\nivec4(59392,512,60,59),\nivec4(59392,512,65,79),\nivec4(59520,128,75,97),\nivec4(59648,128,74,90),\nivec4(59776,128,72,85),\nivec4(59904,256,67,84),\nivec4(59904,512,55,60),\nivec4(59904,512,59,62),\nivec4(59904,512,62,73),\nivec4(60160,256,72,105),\nivec4(60416,128,71,97),\nivec4(60416,512,55,67),\nivec4(60416,512,59,62),\nivec4(60416,512,62,79),\nivec4(60544,128,72,101),\nivec4(60672,128,74,103),\nivec4(60800,128,72,89),\nivec4(60928,512,48,59),\nivec4(60928,512,55,62),\nivec4(60928,512,63,81),\nivec4(60928,512,72,97));\n#elif TUNE == 1\nfloat speed = 0.8;\nconst ivec4 data[] = ivec4[](\nivec4(0,384,57,68),\nivec4(0,1024,45,73),\nivec4(0,1024,60,74),\nivec4(0,1024,64,74),\nivec4(256,522,69,93),\nivec4(384,128,57,74),\nivec4(512,256,52,76),\nivec4(768,261,72,104),\nivec4(768,512,57,89),\nivec4(1024,512,52,77),\nivec4(1024,729,59,75),\nivec4(1024,729,64,75),\nivec4(1024,729,71,75),\nivec4(1280,130,56,79),\nivec4(1408,130,54,76),\nivec4(1536,121,56,84),\nivec4(1536,486,52,77),\nivec4(1664,128,57,77),\nivec4(1792,128,59,84),\nivec4(1792,261,64,68),\nivec4(1920,128,60,80),\nivec4(2048,195,66,66),\nivec4(2048,256,57,86),\nivec4(2048,261,62,86),\nivec4(2048,391,50,79),\nivec4(2240,65,67,91),\nivec4(2304,261,57,84),\nivec4(2304,522,69,96),\nivec4(2432,130,48,74),\nivec4(2560,522,47,82),\nivec4(2560,522,59,80),\nivec4(2560,522,62,74),\nivec4(2816,261,68,84),\nivec4(3072,364,52,72),\nivec4(3072,729,69,87),\nivec4(3072,972,45,80),\nivec4(3072,972,61,68),\nivec4(3456,128,57,83),\nivec4(3584,512,52,72),\nivec4(3840,261,69,85),\nivec4(4096,640,72,88),\nivec4(4096,1024,57,84),\nivec4(4352,261,64,75),\nivec4(4608,640,65,73),\nivec4(4736,130,72,82),\nivec4(4864,130,71,79),\nivec4(4992,130,69,80),\nivec4(5120,640,71,86),\nivec4(5120,1024,55,92),\nivec4(5248,130,65,80),\nivec4(5376,130,64,75),\nivec4(5504,130,62,78),\nivec4(5632,512,59,74),\nivec4(5632,640,64,78),\nivec4(5760,130,71,83),\nivec4(5888,130,69,78),\nivec4(6016,130,67,77),\nivec4(6144,768,69,79),\nivec4(6144,1024,53,84),\nivec4(6272,130,64,86),\nivec4(6400,130,62,85),\nivec4(6528,130,60,78),\nivec4(6656,522,62,84),\nivec4(6784,130,60,81),\nivec4(6912,130,59,84),\nivec4(6912,261,69,84),\nivec4(7040,130,57,82),\nivec4(7168,371,52,73),\nivec4(7168,729,64,78),\nivec4(7168,972,68,66),\nivec4(7552,130,47,67),\nivec4(7680,243,40,60),\nivec4(7936,155,59,68),\nivec4(7936,256,52,85),\nivec4(8192,384,57,58),\nivec4(8192,1024,45,64),\nivec4(8192,1024,60,63),\nivec4(8192,1024,64,63),\nivec4(8448,522,69,61),\nivec4(8576,128,57,61),\nivec4(8704,256,52,56),\nivec4(8960,261,72,66),\nivec4(8960,512,57,62),\nivec4(9216,512,52,61),\nivec4(9216,729,59,54),\nivec4(9216,729,64,54),\nivec4(9216,729,71,54),\nivec4(9472,130,56,63),\nivec4(9600,130,54,62),\nivec4(9728,121,56,66),\nivec4(9728,486,52,59),\nivec4(9856,128,57,62),\nivec4(9984,128,59,62),\nivec4(9984,256,64,53),\nivec4(10112,128,60,69),\nivec4(10240,195,66,64),\nivec4(10240,256,57,64),\nivec4(10240,261,62,64),\nivec4(10240,391,50,62),\nivec4(10432,65,67,64),\nivec4(10496,261,57,62),\nivec4(10496,522,69,63),\nivec4(10624,130,48,62),\nivec4(10752,522,47,60),\nivec4(10752,522,59,62),\nivec4(10752,522,62,64),\nivec4(11008,261,68,57),\nivec4(11264,364,52,58),\nivec4(11264,729,69,67),\nivec4(11264,972,45,57),\nivec4(11264,972,61,57),\nivec4(11648,128,57,62),\nivec4(11776,512,52,60),\nivec4(12032,261,69,61),\nivec4(12288,640,72,65),\nivec4(12288,1024,57,66),\nivec4(12544,261,64,58),\nivec4(12800,640,65,60),\nivec4(12928,130,72,60),\nivec4(13056,130,71,61),\nivec4(13184,130,69,58),\nivec4(13312,640,71,59),\nivec4(13312,1024,55,66),\nivec4(13440,130,65,64),\nivec4(13568,130,64,63),\nivec4(13696,130,62,56),\nivec4(13824,512,59,58),\nivec4(13824,640,64,58),\nivec4(13952,130,71,62),\nivec4(14080,130,69,59),\nivec4(14208,130,67,57),\nivec4(14336,768,69,61),\nivec4(14336,1024,53,62),\nivec4(14464,130,64,64),\nivec4(14592,130,62,61),\nivec4(14720,130,60,60),\nivec4(14848,522,62,61),\nivec4(14976,128,60,66),\nivec4(15104,128,59,60),\nivec4(15104,261,69,62),\nivec4(15232,128,57,59),\nivec4(15360,384,52,63),\nivec4(15360,729,64,64),\nivec4(15360,972,68,58),\nivec4(15744,128,47,58),\nivec4(15872,256,40,52),\nivec4(16128,256,59,57),\nivec4(16128,384,52,69),\nivec4(16384,522,60,45),\nivec4(16512,128,48,60),\nivec4(16640,384,53,71),\nivec4(16640,532,57,58),\nivec4(16896,532,62,68),\nivec4(17024,128,50,63),\nivec4(17152,256,55,73),\nivec4(17152,266,59,57),\nivec4(17408,371,64,76),\nivec4(17408,495,60,75),\nivec4(17408,1024,48,65),\nivec4(17408,1024,55,71),\nivec4(17792,130,62,63),\nivec4(17920,243,60,59),\nivec4(18176,261,67,98),\nivec4(18176,522,64,95),\nivec4(18432,522,72,113),\nivec4(18560,128,60,73),\nivec4(18688,384,65,89),\nivec4(18688,532,69,107),\nivec4(18944,532,74,87),\nivec4(19072,128,62,76),\nivec4(19200,256,67,95),\nivec4(19200,266,71,92),\nivec4(19456,371,76,89),\nivec4(19456,495,72,99),\nivec4(19456,512,60,86),\nivec4(19456,512,67,86),\nivec4(19840,130,74,82),\nivec4(19968,243,69,78),\nivec4(19968,243,72,74),\nivec4(19968,512,57,75),\nivec4(19968,512,64,75),\nivec4(20224,261,72,85),\nivec4(20224,522,76,106),\nivec4(20480,783,56,89),\nivec4(20480,783,71,81),\nivec4(20480,972,64,79),\nivec4(20736,391,74,98),\nivec4(21120,130,76,86),\nivec4(21248,261,57,89),\nivec4(21248,261,69,77),\nivec4(21248,261,72,83),\nivec4(21504,261,68,75),\nivec4(21504,391,71,78),\nivec4(21504,1459,52,72),\nivec4(21760,512,64,69),\nivec4(21888,130,69,73),\nivec4(22016,130,68,84),\nivec4(22144,130,69,90),\nivec4(22272,130,71,89),\nivec4(22272,384,62,73),\nivec4(22400,130,72,97),\nivec4(22528,130,71,82),\nivec4(22656,128,64,88),\nivec4(22656,128,69,77),\nivec4(22784,256,60,74),\nivec4(22784,522,69,79),\nivec4(23040,398,64,73),\nivec4(23040,512,52,80),\nivec4(23040,512,59,79),\nivec4(23296,247,68,70),\nivec4(23424,123,62,72),\nivec4(23552,729,61,72),\nivec4(23552,729,69,81),\nivec4(23552,768,45,71),\nivec4(23552,768,52,71),\nivec4(23552,768,57,71),\nivec4(24320,261,59,56),\nivec4(24320,384,52,60),\nivec4(24576,522,60,61),\nivec4(24704,128,48,53),\nivec4(24832,384,53,65),\nivec4(24832,532,57,54),\nivec4(25088,532,62,64),\nivec4(25216,128,50,58),\nivec4(25344,256,55,68),\nivec4(25344,266,59,53),\nivec4(25600,371,64,69),\nivec4(25600,495,60,64),\nivec4(25600,1024,48,56),\nivec4(25600,1024,55,63),\nivec4(25984,130,62,59),\nivec4(26112,243,60,51),\nivec4(26368,261,67,68),\nivec4(26368,522,64,67),\nivec4(26624,522,72,75),\nivec4(26752,128,60,67),\nivec4(26880,384,65,81),\nivec4(26880,532,69,76),\nivec4(27136,532,74,81),\nivec4(27264,128,62,65),\nivec4(27392,256,67,86),\nivec4(27392,266,71,80),\nivec4(27648,371,76,77),\nivec4(27648,495,72,71),\nivec4(27648,512,60,69),\nivec4(27648,512,67,69),\nivec4(28032,130,74,64),\nivec4(28160,243,69,62),\nivec4(28160,243,72,56),\nivec4(28160,512,57,66),\nivec4(28160,512,64,66),\nivec4(28416,261,72,74),\nivec4(28416,522,76,88),\nivec4(28672,783,56,84),\nivec4(28672,783,71,74),\nivec4(28672,972,64,74),\nivec4(28928,391,74,82),\nivec4(29312,130,76,76),\nivec4(29440,261,57,84),\nivec4(29440,261,69,65),\nivec4(29440,261,72,69),\nivec4(29696,261,68,57),\nivec4(29696,391,71,66),\nivec4(29696,1459,52,71),\nivec4(29952,512,64,67),\nivec4(30080,130,69,70),\nivec4(30208,130,68,65),\nivec4(30336,130,69,76),\nivec4(30464,130,71,84),\nivec4(30464,384,62,78),\nivec4(30592,130,72,92),\nivec4(30720,130,71,82),\nivec4(30848,128,64,105),\nivec4(30848,128,69,88),\nivec4(30976,256,60,91),\nivec4(30976,522,69,105),\nivec4(31232,398,64,92),\nivec4(31232,512,52,100),\nivec4(31232,512,59,97),\nivec4(31488,247,68,89),\nivec4(31616,123,62,76),\nivec4(31744,1459,61,73),\nivec4(31744,1459,69,77),\nivec4(31744,1536,45,69),\nivec4(31744,1536,52,75),\nivec4(31744,1536,57,75));\n#endif\n\nfloat TWOPI = 6.283185307;\n\nfloat organ1(float f, float t) {\n  // sin & cos on Intel GPUs give poor results for large arguments, hence the fract\n  float res = sin(TWOPI*fract(f*t));\n  return res*res*res;\n}\n\nfloat organ2(float f, float t) {\n  float mod = 0.1*sin(TWOPI*fract(5.0*t)); // Vibrato\n  f *= t;\n  float res = 0.0;\n  res += 0.5*sin(TWOPI*fract(1.0*f + mod));\n  res += 0.5*sin(TWOPI*fract(2.0*f + mod));\n  res += 0.1*sin(TWOPI*fract(3.0*f + mod));\n  res += 0.05*sin(TWOPI*fract(4.0*f + mod));\n  return res;\n}\n\nfloat organ3(float f, float t) {\n  return sin(TWOPI*fract(f*t));\n}\n\n// From https://www.shadertoy.com/view/ssjyDD by @athibaul\nfloat FM(float fc, float fm, float iom, float t) {\n  // NB: iom is multiplied by 2pi here.\n  return sin(TWOPI*fract(fc*t + sin(TWOPI*fract(fm*t))));\n}\n\nvec2 fmPluck(float f, float t) {\n    float fc = f; // carrier freq\n    float fm = f; // modulation freq\n    float iom = 1.0; // index of modulation\n    float env = exp(-3.0*t) * 0.1;\n    vec2 sig = vec2(0);\n    \n    sig.x += FM(f+1.0, f+1.0, iom, t) * env;\n    sig.y += FM(f-1.0, f-1.0, iom, t) * env;\n    sig += FM(f, f, 10.0, t) * exp(-20.0*t) * 0.03;\n    return sig;\n}\n\n// From: https://www.shadertoy.com/view/3scfD2 by @athibaul\n// mla: probably don't need the fract here, but it does no harm\n#define msin(x,m) sin(TWOPI*fract(x)+(m))\n\nvec2 epiano(float freq, float t, float nuance) {\n    // freq : frequency of note\n    // t : time since beginning of note\n    // nuance : 1 is mezzo-forte, smaller is piano, larger is forte\n    vec2 f0 = vec2(freq*0.998, freq*1.002);\n    \n    // Glassy attack : slightly sharp,\n    // modulated at 14 * base frequency with a sharply decaying envelope\n    // and with a relatively fast decay\n    vec2 glass = msin((f0+3.)*t, msin(14.*f0*t,0.) * exp(-30.*t) * nuance) * exp(-4.*t)  * nuance;\n    glass = sin(glass); // Distort at high nuances\n    \n    // Body of the sound : perfectly in tune,\n    // index of modulation depends on nuance and is boosted a bit for low notes\n    vec2 body = msin(f0*t, msin(f0*t,0.) * exp(-0.5*t) * nuance * pow(440./f0.x, 0.5)) * exp(-t) * nuance;\n    \n    // Pan the attack depending on which note it is\n    float panDir = clamp(log2(freq/400.)/2., -1., 1.); // -1 is left, 1 is right\n    vec2 pan = normalize(vec2(0.5-0.5*panDir, 0.5+0.5*panDir));\n    return (glass*pan + body) * 0.05 * smoothstep(0.,0.001,t);\n}\n\nvec2 note(ivec4 n, int samp) {\n  // Following ttg's suggestion to compute integer \n  // starting sample for note\n  int s0 = int(iSampleRate/(speed*1000.0)*float(n.x));\n  vec2 res = vec2(0);\n  if (samp >= s0) {\n    samp -= s0;\n    // then only convert to a time after subtracting the\n    // start sample value.\n    float t = float(samp)/iSampleRate, t0 = 0.0;\n    float pitch = float(n.z);\n    float f = 440.0*exp2((pitch-69.0)/12.0);\n    float vol = float(n.z)/127.0;\n    if (SOUND == 0) {\n      res += 0.2*vol*fmPluck(f,t);\n    } else if (SOUND == 3) {\n      res += 0.5*vol*epiano(f,t,1.0);\n    } else {\n      float len = float(n.y)/(speed*1000.0);\n      float rampup = 0.1, rampdown = 0.25;\n      if (SOUND == 1) {\n        rampup = 0.01; rampdown = 0.5; len = 0.0;\n      }\n      float t1 = t0+len;\n\n      float env = smoothstep(t0,t0+rampup,t);\n      env *= (1.0-smoothstep(t1,t1+rampdown,t));\n      float s = SOUND==1 ? organ1(f,t) : SOUND == 2 ? organ2(f,t) : organ3(f,t);\n      res += 0.1*vol*env*s;\n    }\n  }\n  return res;\n}\n\nvec2 mainSound(int samp, float t) {\n  //float offset = 160.0;\n  //samp += int(iSampleRate*offset); t += offset;\n  int NNOTES = data.length();\n  //if (NNOTES > 2047) return vec2(0); // Nvidia check\n  if (SOUND == 2) speed *= 0.8; // A more stately sound\n  float tick = t*speed*1000.0;  // MIDI time tick\n  int i = 0, j = NNOTES;\n  while (i != j) {\n    // Binary search to find first note starting less\n    // than X ticks before t.\n    float X = 1000.0;\n    int k = i+(j-i)/2;\n    if (float(data[k].x) < tick-X) i = k+1;\n    else j = k;\n  }\n  vec2 res = vec2(0);\n  for ( ; i < NNOTES; i++) {\n    if (float(data[i]) > tick+100.0) break;\n    res += note(data[i],samp);\n  }\n  return res;\n}", "sound_inputs": [], "buffer_a_code": "// 4 bit encoding of image. No compression\nuvec4 data[] = uvec4[](\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xefffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xabffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbaffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbaffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xbaffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbbffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbbffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbaffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfbffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfbffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfbffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbbffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfbffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfffffbbf,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffefffff,0xffffffff,0xffffffff),\nuvec4(0x9bffe9bf,0xffffffff,0xfd6ffeff,0xf97fefff),\nuvec4(0xaffffbbe,0x6feffffb,0xfbfffffd,0xffffffff),\nuvec4(0xefffffea,0xfea6faff,0xfffffeff,0xffff9af6),\nuvec4(0xfa9baaae,0xffffffff,0xffffffff,0xe79e9aff),\nuvec4(0xad5e6996,0xbbde79ee,0xa9a9aea6,0x6aeb9ab9),\nuvec4(0x9b9aa596,0xba9aad76,0xb5a65966,0x99669975),\nuvec4(0x5577e96b,0xe5965956,0xa66685e6,0xf96a599f),\nuvec4(0xffffffff,0xffffffff,0x6feaabbf,0x5aabaea9),\nuvec4(0xa9ae5aaa,0xa75e9da7,0xab57f6ab,0xb7e9aaaa),\nuvec4(0xaeeaae65,0x7a7e767d,0xf5a9f77f,0x9aadfe97),\nuvec4(0xb6b6ab96,0xd95a65b5,0xf5b596bb,0xffffffff),\nuvec4(0xffffffff,0x9aeb9bbf,0xd6a79aa5,0x556b997a),\nuvec4(0x66eaab5a,0x9aa7e69a,0x7ad65969,0x95be5b99),\nuvec4(0x6e69aa99,0xd6599659,0xa69df996,0xb9a9fa65),\nuvec4(0xaa6a6ab9,0xfebaa6bb,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffebff,0xfffffffd,0xffffff6f),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffebffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffbfff),\nuvec4(0xffffeaff,0xfffffffe,0xffffffeb,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfffbffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfffbffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbfffffff,0xfffffffe),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfffaffff),\nuvec4(0xffffffff,0xffffffff,0xfff6afff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbfffffff,0xfffffff9),\nuvec4(0xffffffff,0xaabfffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffabffff,0xffffffaf),\nuvec4(0xffffffff,0xfffffaaf,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbffe556a,0xeaabffea,0xffffffff),\nuvec4(0xffaabfff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbfabaaaf,0xfffffaea,0xabffffff),\nuvec4(0xfffffffa,0xffffffff,0xffffffff,0x5bffffff),\nuvec4(0x7fd5afa9,0xeffebfe9,0xffffffff,0xffffaabf),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffbeffff),\nuvec4(0xdffebffb,0xfffffbff,0xfeabffff,0xffffffff),\nuvec4(0xffeebfff,0xffffffff,0xf96fffff,0xff6fafdf),\nuvec4(0xedbfdbef,0xbfffffff,0xffffffea,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffef56ff,0xfbfefafe),\nuvec4(0xffffea6f,0xfffeabff,0xffffffff,0xffdd15af),\nuvec4(0xbfffffaa,0x6f87ffea,0xf9ffe656,0xda7febef),\nuvec4(0xeabfffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x7ffb800a,0xfefbefbe,0xfffffaaf),\nuvec4(0xffffffab,0x7fffffff,0xbfec6e55,0xbffff9bf),\nuvec4(0x6af9bfef,0xe7ffff40,0xfafebedd,0xffeabfff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xaffbc01f,0xfeabefef,0xabfffaaf,0xffffffff),\nuvec4(0x19bfffff,0xefe8ead0,0xefffebfb,0x7fffafa7),\nuvec4(0xdfffff80,0xfffbea96,0xffffeaaf,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xa6fbc02f),\nuvec4(0x9fabee6f,0xffaafffa,0xffffffff,0x3e02ffff),\nuvec4(0xefeafed0,0xefffbfe6,0xffffebe7,0x7fffffe5),\nuvec4(0xaff5fe99,0xfffffff9,0xffffffff,0xfffffbff),\nuvec4(0xffffffff,0xffffffff,0x96ffc02f,0xfa9befbf),\nuvec4(0xffffaaef,0xffffffff,0x2b87a9bf,0xafb7fdd0),\nuvec4(0xfbfefffb,0xfffffaff,0x7fffffff,0xeabbe65a),\nuvec4(0xffffffff,0xffffffff,0xfffffa5b,0xffffffff),\nuvec4(0xffffffff,0xabffc03f,0xbfaaebfe,0xffffff9a),\nuvec4(0xbfffffff,0x3ac7ed01,0xbffffed0,0xfbe7fffa),\nuvec4(0xfffffeff,0xffffffff,0xffeaaa95,0xffffffff),\nuvec4(0x5affffff,0xfffffa05,0xffffffff,0xffffffff),\nuvec4(0xfffec03f,0x56fafe5b,0xffffffea,0xf46fffff),\nuvec4(0x3dd7ee01,0xfffbbed0,0xefdbffff,0xffffff7d),\nuvec4(0xffffbabf,0xfffffa95,0xffffffff,0xe006ffff),\nuvec4(0xfffffa2b,0xffffffff,0xffffffff,0xffffc03f),\nuvec4(0xffa97fff,0xfffffffa,0xb806ffff,0x3eb3ee02),\nuvec4(0xfffb7ed0,0xefbfffff,0xffffffad,0xfffa8006),\nuvec4(0xfffffffa,0xffffffff,0xe01bffff,0xffffea79),\nuvec4(0xffffffff,0xffffffff,0xfffbc03f,0xffffaabf),\nuvec4(0xffffffff,0xb80bfaaf,0x3fb6ee02,0xfffb1ed0),\nuvec4(0xeebfefff,0x45bfffee,0xffee03e9,0xffffffff),\nuvec4(0xffffffff,0xe01fb956,0xffffe9fd,0xffffffff),\nuvec4(0xffffffff,0xbfffc03f,0xffffffaa,0x6bffffff),\nuvec4(0xa80bfb91,0x3fecee02,0xfffb46c0,0xeefaaaaf),\nuvec4(0x8006fffa,0xffa80abf,0xffffffff,0x16ffffff),\nuvec4(0xe02ed0a9,0xffffedfd,0xffffffff,0xffffffff),\nuvec4(0xaabbc03f,0xffffffff,0x1bffffff,0xb80bfed0),\nuvec4(0x7fedae02,0xfffb4940,0xbbaffffb,0x802ffff6),\nuvec4(0xfeb40eab,0xffffffff,0x196ffff,0xe02e819d),\nuvec4(0xffffeefe,0xffffffff,0xffffffff,0xffeac03f),\nuvec4(0xffffffff,0x1fffffff,0xb80bfee0,0x7ffa6e02),\nuvec4(0xfffb6bc0,0xae7ffefb,0x807ffffa,0xfde00ff7),\nuvec4(0xffffffff,0x2e006ff,0xe03b41ed,0xfffffeed),\nuvec4(0xffffffff,0xffffffff,0xfffac03f,0xffffffff),\nuvec4(0x2fffee56,0xa80bfea0,0x7ffb5e02,0xfff76ac0),\nuvec4(0xaabff5bb,0x807ffffe,0xfed00ffb,0xffffffff),\nuvec4(0x2b01edf,0xe03b01ed,0xfffffedd,0xffffffff),\nuvec4(0xffffffff,0xffffc07f,0x3fffffff,0x2fffb429),\nuvec4(0xb80bfea0,0x7fb65e03,0xfff7bed0,0x5962fbfb),\nuvec4(0x807ffffd,0xffa007f7,0x57ffffff,0x3b01e81),\nuvec4(0xe03b01ed,0xfffffec9,0xffffffff,0xffffffff),\nuvec4(0xfffec07f,0xbffffff,0x2ffed0ab,0xb80bfea0),\nuvec4(0x7fb00a03,0xfffffed0,0x6abff9ab,0x807ffffd),\nuvec4(0xffb01bfb,0x68bfffff,0x3b02e81,0xe02b01ed),\nuvec4(0xfffffec5,0xffffffff,0xffffffff,0xffffc07f),\nuvec4(0x7ff96bf,0x3ffec0bb,0xa80fffa0,0x7ee01603),\nuvec4(0xfffffed0,0xa6ffffff,0x807ffffe,0xffb41ffb),\nuvec4(0xee2fb1bf,0x3b02e8f,0x403602ed,0xfffffec5),\nuvec4(0xffffffff,0xffffffff,0xbffbc07f,0x42e94541),\nuvec4(0x3ffe80fb,0xa80fffa0,0x7ee02603,0xfffffed0),\nuvec4(0xffa6ffff,0x80bfffff,0xbf740ffb,0xfb0fa045),\nuvec4(0x3b02e9f,0xe02b02ed,0xfffffe8a,0xffffffff),\nuvec4(0xffffffff,0x6ffbc07f,0x41e81bc0,0x3ffb80fb),\nuvec4(0xa80fffa0,0x7ed07803,0xff6bfed0,0xffffaabf),\nuvec4(0x40bfffff,0x5680ffb,0xfb07a1a9,0x3b02a7f),\nuvec4(0xe03b02ed,0xfffffeae,0xffffffff,0xffffffff),\nuvec4(0xbffbc07f,0x41b43ec0,0x3ffb80fb,0xa80fffa0),\nuvec4(0x7ec06d03,0xafb7fed0,0xffffffaa,0x80bfffff),\nuvec4(0x1ed0bfb,0xee06a7ad,0x3b02b7f,0xe03b02ed),\nuvec4(0xfffffdbd,0xffffffff,0xffffffff,0xbffbc07f),\nuvec4(0x41a03ec0,0x3ffb40fb,0xa40fffa0,0x7b809d03),\nuvec4(0xea77fed0,0xffffffff,0x40bfffff,0x2eb47fb),\nuvec4(0xed06dfed,0x3b02abf,0xe02602ed,0xfffffffd),\nuvec4(0xffffffff,0xffffffff,0xbffbc07f,0x41a03ec0),\nuvec4(0x3ffb40fb,0xa40fffa0,0x7b40ee03,0xffb5fed0),\nuvec4(0xffffffff,0x40bfffff,0x3fbd7fb,0xbc06dfed),\nuvec4(0x3b02ffe,0xe03b02ed,0xfffffffd,0xffffffff),\nuvec4(0xffffffff,0xbfee403f,0x40a03ec0,0x3ffb40fb),\nuvec4(0xb40fffa0,0x7b41de03,0xffb8bec0,0xffffffff),\nuvec4(0x80ffffff,0x3fdf5f7,0xe409ebdd,0x3b02feb),\nuvec4(0xe02b02ed,0xffffbbfd,0xffffffff,0xffffffff),\nuvec4(0xbfef402f,0x40903ec0,0x3ffb40fb,0xa41fffa0),\nuvec4(0x7b02ee03,0xffb87ec0,0xffffffff,0x40ffffff),\nuvec4(0x3fbd42b,0x401feaed,0x3b02fae,0xe02a02ed),\nuvec4(0xffffeafe,0xffffffff,0xffffffff,0xbffb802f),\nuvec4(0x40903ec0,0x3ffb40fb,0xa40afea0,0x7903ee03),\nuvec4(0xffed0580,0xffffffff,0x40fffa6f,0x3ee0787),\nuvec4(0x2fe9dd,0x3b02ef8,0xe03702ed,0xffffedfe),\nuvec4(0xffffffff,0xffffffff,0xfffbc07f,0x40a07ec0),\nuvec4(0x3ffb40fb,0xa409fea0,0x2903ed03,0xffdff940),\nuvec4(0x6fffffff,0x40bffa01,0x3a80ab4,0xbfe8ed),\nuvec4(0x3b02ed0,0xd03701ed,0xffffedfe,0xffffffff),\nuvec4(0xffffffff,0xfff7c07f,0x40a07ec0,0x3ffb40fb),\nuvec4(0xb40abea0,0x5403ed03,0xffe96ffa,0x905bffff),\nuvec4(0x6fee2e,0x3b01fae,0x7ffe81d,0x3b02b80),\nuvec4(0xd03701ed,0xffffedbe,0xffffffff,0xffffffff),\nuvec4(0xfff7c07f,0x40a07ec0,0x3ffb40fb,0xb40a7ea0),\nuvec4(0xbe53ed03,0xffffe9af,0xd01fbfff,0x40afed66),\nuvec4(0x3a02feb,0x6fffe850,0x3b02b00,0xd03b01ed),\nuvec4(0xffffed7e,0xffffffff,0xffffffff,0xfffbc07f),\nuvec4(0x40a07ec0,0x3ffb80fb,0xb4067ee0,0x6fffa402),\nuvec4(0xffffffee,0xd02e901a,0x40bfedfe,0x2d03feb),\nuvec4(0xffffe9bd,0x3b02e00,0xd02b41ed,0xffffed3d),\nuvec4(0xffffffff,0xffffffff,0xfffbc07f,0x40a07ec0),\nuvec4(0x2ffb80fb,0xb0062ee0,0xe9bebe91,0x1affffff),\nuvec4(0xd02b02a4,0x40ffedfd,0x2803ffb,0xffffe69d),\nuvec4(0x3b02d02,0xd02b41ed,0xffffee19,0xffffffff),\nuvec4(0xffffffff,0xbffbc07f,0x41a03e80,0x2ffb80fb),\nuvec4(0x90031ed0,0xfffeaafe,0x1bfffff,0xd02906b8),\nuvec4(0x40ffeefe,0x2807ffb,0xffaeebdd,0x3b01c07),\nuvec4(0x401a81ed,0xffffefe9,0xffffffff,0xffffffff),\nuvec4(0xbffbc07f,0x41903e80,0x2ffb80fb,0xff970ad0),\nuvec4(0xfffffebe,0x7ffffff,0xe01c0bb8,0x40fffebe),\nuvec4(0x3807ffb,0xffb7ffed,0x3b01c0b,0xe95ad0ed),\nuvec4(0xffffeaff,0xffffffff,0xffffffff,0xbffbc07f),\nuvec4(0x41e03e80,0x1ffbc0fb,0xabfa9550,0xfffffffe),\nuvec4(0xbffea56,0xe02c0ba8,0x40fffe6d,0x2407ffb),\nuvec4(0xffb7ffed,0x3b01c0b,0xfffae05d,0xfffffeaa),\nuvec4(0xffffffff,0xffffffff,0xbffbc07f,0x41a03e80),\nuvec4(0x1ffed0b7,0xfeaaff90,0x7fffffff,0xfffb479),\nuvec4(0xe01d0ba8,0x40fffe9e,0x7006ffb,0xfef7bfdd),\nuvec4(0x2a01d0b,0xaaffbd04,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbffbc07f,0x41a03e80,0x9bfed0f7),\nuvec4(0xfffeabff,0x1fbbffff,0xffed0ae,0xe02d0ba8),\nuvec4(0x40fffe4a,0x7402ffb,0xfedb7fdd,0x41a00e0b),\nuvec4(0xfe9baff9,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbffbc07f,0x3b03e80,0xfffef4bb,0xfffffe5a),\nuvec4(0x7b056ff,0xffe80fb,0x502a07a8,0x40fffe81),\nuvec4(0x3406ffb,0xfb8aafdc,0xfd900b07,0xffffeaff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xbffbc07f),\nuvec4(0xbb42e80,0x9fffbd2a,0xfffffffe,0x3a18016),\nuvec4(0xffb80fb,0x902b47e8,0x40fffe4b,0x3807ffb),\nuvec4(0xeb4edfdc,0xfeff5782,0xffffff6a,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbffbc07f,0x6bb82e80),\nuvec4(0xffffef94,0xffffffff,0x293d0a1,0xffb40fb),\nuvec4(0xe03ac3e8,0x40fffd9a,0x2807ffb,0xa90ecfec),\nuvec4(0xaafffae1,0xfffffffe,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbffbc07f,0xebed1a80,0xfffffaff),\nuvec4(0xfbffffff,0x1cec0b4,0xffb40fb,0xa03eb1a8),\nuvec4(0x40fffe7e,0x2c07ffb,0x551ec7dc,0xffaafefe),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbffb807f,0xbfef4680,0xffffff9a,0xfaabffff),\nuvec4(0x19ed068,0xff741fb,0xe03e9158,0x40fffebe),\nuvec4(0x2d07ffb,0xffdec2dd,0xffffab7f,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x7ffb807f),\nuvec4(0xfff7e540,0xffffffff,0xbffeabff,0x1bed0ac),\nuvec4(0xff741f7,0xe03a07e0,0xfffffe,0x1a03ffb),\nuvec4(0xaafed06c,0xffffffea,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x6ff7807f,0xfffebff9),\nuvec4(0xffffffff,0xbffffeab,0x1bed0ad,0xff741f7),\nuvec4(0xa06d0eb8,0xfffbff,0x2b42feb,0xbebefe54),\nuvec4(0xffffffff,0xffffffff,0xe6ffffff,0xffffffff),\nuvec4(0xffffffff,0xfff7807f,0xffffeaaf,0xabffffff),\nuvec4(0x7feabeae,0x1fec0bb,0xff741f7,0xa06c0fb4),\nuvec4(0xffa7fe,0x91b82ffb,0xfffe6ffe,0xffffffff),\nuvec4(0xffffffff,0xe146bfff,0xfffffffe,0xffffffff),\nuvec4(0x7ffb803f,0xffffffea,0xfe5affff,0xbfbfee9f),\nuvec4(0x1fec0bb,0xff741f7,0x90280fb8,0xffe7fe),\nuvec4(0xfeae0beb,0xffffe9af,0xffffffff,0xffffffff),\nuvec4(0xd6f801ff,0xfffffffe,0xffffffff,0xfffb803f),\nuvec4(0xffffffff,0xa555aaff,0xbefeeebf,0x1fec0ba),\nuvec4(0xff740f7,0x90280fa4,0xffe9fe,0xafebd1ab),\nuvec4(0xffffffe9,0xffffffff,0xffffffff,0xdeac03ff),\nuvec4(0xfffffffe,0xffffffff,0xfffb803f,0xffffffff),\nuvec4(0xeabfffaa,0xfefdbeaa,0x1fec0bf,0xffb40fb),\nuvec4(0x90241fb4,0xbfedfe,0xfafaf945,0xffffffff),\nuvec4(0xffffffff,0x405bffff,0x9fe807ea,0xfffffffe),\nuvec4(0xffffffff,0xffeb403f,0xaaffffff,0xaaffffff),\nuvec4(0xfeffffff,0x1fec0bf,0xffb40f7,0xd0280fa8),\nuvec4(0x507fecbe,0xffffaffe,0xffffffff,0xffffffff),\nuvec4(0x1f406fff,0xbfe80bb4,0xfffffffd,0xffffffff),\nuvec4(0xffef003f,0xffaaffff,0xeafeabff,0xffbffffe),\nuvec4(0x1fec0bf,0xffb40f7,0xd0280fa4,0xfeafed7e),\nuvec4(0xffffeaaf,0xffffffff,0xffffffff,0x2a8069af),\nuvec4(0xfff80bb0,0xfffffffe,0xffffffff,0xffad002f),\nuvec4(0xffffaabf,0xebfbfebf,0xffbffffa,0x1fec0bf),\nuvec4(0xffb40fb,0x902c0fb4,0x6fffed1a,0xfffffff9),\nuvec4(0xffffffff,0xbfffffff,0x3a80ed01,0xbbe80ae0),\nuvec4(0xffffffff,0xffffffff,0xbef9401f,0xffffffea),\nuvec4(0xfbfb7e9b,0xffeafaaf,0x1fec0bf,0xffb40fb),\nuvec4(0x501d0fb4,0xeaafef94,0xffffbaff,0xffffffff),\nuvec4(0xeeffffff,0x7e40ed02,0x77a80ad0,0xffffffff),\nuvec4(0xffffffff,0xfaaffe57,0xffffffff,0xbbfa7f9b),\nuvec4(0xffffbbff,0x1fec0bf,0xffb40fb,0xa51e0bb4),\nuvec4(0xffffebff,0xffff74bf,0xffffffff,0xe8557fff),\nuvec4(0x7a40ed02,0x73a80ad0,0xffffffff,0xffffffff),\nuvec4(0xffeaaffb,0xffffffff,0xbeffffaa,0xffffffff),\nuvec4(0x1fec0bf,0xbfa40fb,0xffeb82b4,0x6fffe5b),\nuvec4(0xffffb414,0xffffffff,0xe86a5bff,0x7a80ee03),\nuvec4(0xb0780ac0,0xffffffff,0xffffffff,0xffffeaaf),\nuvec4(0xffffffff,0xfefffebf,0xfffffabe,0x2fec0bf),\nuvec4(0xbfe80fb,0xaafae914,0xb87ffffe,0xffffb02a),\nuvec4(0x6fffffff,0xb4fac3fe,0x7a80e903,0x71500ac0),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffaffbff,0xffffeebe,0x2fec0bf,0x7fe80fb),\nuvec4(0xfeaebfe5,0xae1fffff,0xfffef0bf,0x406bffff),\nuvec4(0xb2fed1fb,0x7b40ed03,0x72b80ac0,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfffaafff),\nuvec4(0xffffeffb,0x3fac0bf,0xeafed0fb,0xffffaaff),\nuvec4(0xfb47ffff,0xfffee2ff,0xc006ffff,0xb7fed0fb),\nuvec4(0x7a40e903,0xabb80ac0,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x7fffff,0xfffffff9,0xfffffaaf),\nuvec4(0x7fac07f,0xbffee0bb,0xffffff96,0xfb82ffff),\nuvec4(0xfffde7ff,0x801fea5b,0x6bfbc0fa,0x7a40e903),\nuvec4(0x6fb80ac0,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x1bffff,0xfffffe40,0xffffffff,0x1ffb807f),\nuvec4(0xabffb919,0xffffffff,0xfbc1ffff,0x16fedbff),\nuvec4(0x805fed14,0x6ffb80ba,0x7a80fa03,0xbf780ac0),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x6ffff),\nuvec4(0xffffe400,0xffffffff,0xaffb807f,0xffffef95),\nuvec4(0xffffffff,0xfec0ffff,0xc01acfff,0x408fed6f),\nuvec4(0xffaf40fb,0x7a80fa03,0xff780ac0,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x2ffff,0xffff9000),\nuvec4(0xffffffff,0xaffb407f,0xfffffaff,0xffffffff),\nuvec4(0xffc0ffff,0xc03b9fff,0x40cfedb9,0xfefd01fb),\nuvec4(0x7a40fa03,0xffb80ac0,0xffffffea,0xffffffff),\nuvec4(0xffffffff,0x2ffff,0xfffe0000,0xffffffff),\nuvec4(0xffee402f,0xffffffea,0xffffffff,0xfbc0bfff),\nuvec4(0xc0777fff,0x41cbedfd,0xfbe402fb,0x7a40fa03),\nuvec4(0xbfb80ac0,0xfffffffa,0xffffffff,0xffffffff),\nuvec4(0x1ffff,0xfffd0000,0xffffffff,0xff6ffe5f),\nuvec4(0xffffffff,0xffffffff,0xfbc0bfff,0xc0777fff),\nuvec4(0x1dbeefd,0xef8007fb,0x7a40fa03,0xbfb80ac0),\nuvec4(0xfffffffb,0xffffffff,0xffffffff,0x1ffff),\nuvec4(0xfffd0000,0xffffffff,0xffeaafef,0xffffffff),\nuvec4(0xffffffff,0xfb80bfff,0xc0babfff,0x2d7ebfd),\nuvec4(0xbe001ffa,0x7a40fa03,0x7fb80ac0,0xfffffffb),\nuvec4(0xffffffff,0xffffffff,0xffff,0xfffe0000),\nuvec4(0xffffffff,0xfffffabf,0xffffffff,0xffffffff),\nuvec4(0xef40ffff,0xc0aaffff,0x2a7feae,0xb800bfea),\nuvec4(0x7b40fa03,0x6fb40ec0,0xfffffffb,0xffffffff),\nuvec4(0xffffffff,0xbfff,0xffff4000,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xefffffff,0xbf00ffff),\nuvec4(0xc0bffffa,0x3b3fe9e,0xb006ffee,0x7a40fa02),\nuvec4(0x5fb40ad0,0xbffffffb,0xffffffff,0xffffffff),\nuvec4(0x7fff,0xffff8000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xe96fffff,0xfd01ffff,0xc0bfffef),\nuvec4(0x773fe8a,0xd00fffed,0x7b40fa02,0x4fb40ad0),\nuvec4(0xbffffffb,0xffffffff,0xffffffff,0x7fff),\nuvec4(0xffffc000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xa8556bff,0xa402ffff,0xc07fffee,0xbb6fe85),\nuvec4(0xd02fffed,0x3b80fa02,0x82b40ae0,0xbffffff7),\nuvec4(0xffffffff,0xffffffff,0x3fff,0xffffd000),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xa9af00ab),\nuvec4(0x7ffff,0x407fffbd,0xbb6fe85,0xc0bffbec),\nuvec4(0x3b40fa02,0xfa5006b4,0xbffffffb,0xffffffff),\nuvec4(0xffffffff,0xbff,0xffffe000,0xffffffff),\nuvec4(0xffffffff,0x6fffffff,0xb6eb41a1,0x1fffff),\nuvec4(0xd0bffafd,0xbb6fe9a,0xc0bffb68,0x2b40fa02),\nuvec4(0xbffe92b8,0xbffffff9,0xffffffff,0xffffffff),\nuvec4(0x1ff,0xfffff400,0xffffffff,0xffffffff),\nuvec4(0xb6fffff,0xb7f741b4,0x7fffff,0xc0bfefd0),\nuvec4(0x15fe6a,0xd0ffea74,0x1b40b902,0xa9bffebe),\nuvec4(0xbfffffff,0xffffffff,0xffffffff,0x400007f),\nuvec4(0xfffff400,0xffffffff,0xffffffff,0x1b416eff),\nuvec4(0xbbf741b4,0xffffff,0xc0bfaf40,0x1e91feba),\nuvec4(0xc0ffedb4,0xd500ad02,0xffe9afef,0xbfffffff),\nuvec4(0xffffffff,0xffffffff,0xaa55002f,0xffffd001),\nuvec4(0xffffffff,0xffffffff,0x1e80781a,0xeffb41b4),\nuvec4(0x1ffffff,0xc0bfbd00,0x1abcfffa,0xd0ffbdb0),\nuvec4(0xff955d02,0xfffffafa,0xbfffffff,0xffffffff),\nuvec4(0xffffffff,0xbba9001f,0xffff401b,0xffffffff),\nuvec4(0x16ffffff,0x1e8074e0,0xedf741b4,0x6affffff),\nuvec4(0xc0bef400,0x2fecbffa,0xe0bfb9a0,0xabffa901),\nuvec4(0xfffffffe,0xbfffffff,0xffffffff,0xffffffff),\nuvec4(0x96a9001f,0xffff001b,0xffffffff,0x24bfffff),\nuvec4(0x1e8071e0,0xedf741a4,0xabffffff,0xc0bad001),\nuvec4(0x3fddabfe,0xf87ee1d0,0xfaabbfe5,0xffffffff),\nuvec4(0xbfffffff,0xffffffff,0xffffffff,0x45a8002f),\nuvec4(0xffff01ab,0xffffffff,0x2c7fffff,0x1d8066a0),\nuvec4(0xed7b41a4,0xfbffffff,0xc0bb800b,0x3fed67fe),\nuvec4(0x7e1a41d0,0xffff6fff,0xffffffff,0xbfffffff),\nuvec4(0xffffffff,0xffffffff,0x2964007f,0xffff02ae),\nuvec4(0xffffffff,0x2d7fffff,0x1d80dba0,0xed1b02a4),\nuvec4(0xffffffff,0xc07b402f,0x7fed6afa,0xefea92c0),\nuvec4(0xfffffaaf,0xffffffff,0xbffffff6,0xffffffff),\nuvec4(0xffffffff,0x656801ff,0xffff425e,0xffffffff),\nuvec4(0x2a7fffff,0x1e80dfa0,0xed1402a4,0xffffffff),\nuvec4(0xc06e00bf,0x7fed29fe,0xfbfff540,0xfffffffa),\nuvec4(0xa6ffffff,0xbfffffff,0xffffffff,0xffffffff),\nuvec4(0xa5b802ff,0xffffe6ae,0xffffffff,0x2b7fffff),\nuvec4(0x1e80afa0,0xed6b02a8,0xffffffff,0xc06d01ff),\nuvec4(0x6fed1cfe,0xfeaafbea,0xffffffff,0xff9affff),\nuvec4(0xbfffffff,0xffffffff,0xffffffff,0xbbe403ff),\nuvec4(0xfffffefe,0xffffffff,0x2aafffff,0xb80ffb0),\nuvec4(0xedf742e8,0xee56ffff,0xc06d02ff,0xffa80c7e),\nuvec4(0xffffaaff,0xffffffff,0xffffaaff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x6e9003ff,0xfffffea9),\nuvec4(0xffffffff,0x2eefffff,0x500ffb0,0xe9f742e4),\nuvec4(0xb4007fff,0xc06c07fe,0xffb94d6e,0xffffffaa),\nuvec4(0xffffffff,0xffffffaa,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x55800bff,0xfffffe65,0xffffffff),\nuvec4(0x2eefffff,0x1f80ffa0,0xfefb42e8,0xe0001fff),\nuvec4(0x802807fe,0xfeffe906,0xffffffff,0xaaffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x51001fff,0xfffffe74,0xffffffff,0x2fffffff),\nuvec4(0x1a80ffa0,0xfffb42e8,0xd0000bff,0x40280bfe),\nuvec4(0xfeabfbe9,0xffffffff,0xffeaffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x1002fff),\nuvec4(0xfffffd59,0xffffffff,0x2fffffff,0x1ec0ffb0),\nuvec4(0xfffb42e8,0xc06907ff,0xf9580bfb,0xfffef6ff),\nuvec4(0xffffffff,0xffffeabf,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x45001fff,0xfffffea9),\nuvec4(0xffffffff,0x1fffffff,0x1dc0ffb0,0xdffb02e8),\nuvec4(0x81eb43fe,0xbff80bfb,0xffffffaa,0xbfffffff),\nuvec4(0xffffffea,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x59000bff,0xfffffeae,0xffffffff),\nuvec4(0x1fffffff,0x1dc0bfb0,0xdffb02e4,0xc3fed2fe),\nuvec4(0xaab80bfb,0xffffffff,0xfaafffff,0xfffeafff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xa80007ff,0xfffffaf5,0xffffffff,0x2fffffff),\nuvec4(0x1d80bfb0,0xabfb01e4,0xd7fed1ff,0xffec0bfb),\nuvec4(0xffffffff,0xea56afff,0xaffb6fff,0xfffffffe),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x4000019b),\nuvec4(0xffffeaae,0xffffffff,0x2fffffff,0x1dc0bfb0),\nuvec4(0xb7fb01e4,0xe7fed2ff,0xffed0bfa,0xffffffff),\nuvec4(0xaaa956af,0xfbfbafff,0xfffffffa,0xffffffff),\nuvec4(0xffffffff,0xafffffff,0xa4000001,0xfffe6ee6),\nuvec4(0xffffffff,0x1fffffff,0xd80bfb0,0xb2eb01e4),\nuvec4(0xf7fed2ff,0xffee07fe,0xafffffff,0xeeabfffa),\nuvec4(0xfbfefffa,0xffffffeb,0xffffffff,0xffffffff),\nuvec4(0xbffffff,0x0,0xffd47aaa,0xffffffff),\nuvec4(0x1fffffff,0xe80bfb0,0xb5eb01e8,0xbafed3ff),\nuvec4(0xfffb07ff,0xfaabffff,0xbbbfffff,0x5bffaaaf),\nuvec4(0xffffffef,0xffffffff,0xffffffff,0x1ffffff),\nuvec4(0x90000000,0xffd06f9a,0xffffffff,0x1fffffff),\nuvec4(0xd80bf70,0xb46b01e4,0xaffec7ff,0xfffb82ff),\nuvec4(0xfffaabff,0xeeffffff,0xeffffffe,0xffffffef),\nuvec4(0xffffffff,0xffffffff,0xbfffff,0x0),\nuvec4(0xff90ffb5,0xffffffff,0x1fffffff,0xd80bfb0),\nuvec4(0xbf9500f4,0xfbfb8bff,0xfffed1ff,0xfffffeab),\nuvec4(0xbbffffff,0xffffffeb,0xffffffef,0xffffffff),\nuvec4(0xffffffff,0x2fffff,0x0,0xff90ef50),\nuvec4(0xffffffff,0x1fffffff,0xec0bfb0,0x9bffa564),\nuvec4(0xffeb5fff,0xfffeb47f,0xfffffffe,0xfbffaabf),\nuvec4(0xffffffae,0xfffffffb,0xffffffff,0xffffffff),\nuvec4(0xfffff,0x0,0xfe40be40,0xffffffff),\nuvec4(0x1fffffff,0xa80bfb0,0xfeabffa9,0xffad6fff),\nuvec4(0xffffbd2f,0xbffffffe,0xeffebfea,0xfffffabe),\nuvec4(0xfffffffe,0xffffffff,0xffffffff,0x7ffff),\nuvec4(0x40000000,0xfd002a00,0xffffffff,0x1fffffff),\nuvec4(0xfa407fa0,0xfffeabbf,0xffe5bfff,0xffffeb86),\nuvec4(0x9ffffffe,0xeffefffb,0xabfeaffb,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x2ffff,0x0),\nuvec4(0xfd001900,0xffffffff,0x1fffffff,0xfbf92ee0),\nuvec4(0xffffff66,0x41bafff,0xbffffaf9,0xf6ffffff),\nuvec4(0xeffbfffe,0xfeabfffb,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x2ffff,0x0,0xf8000000),\nuvec4(0xffffffff,0xfffffff,0xa6fffe90,0xfffffffe),\nuvec4(0xeafebfff,0xbfffffbf,0xd97fffff,0xeffbfffe),\nuvec4(0xffffffef,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x2ffff,0x0,0xf8000000,0xffffffff),\nuvec4(0x57ffffff,0xffaafbfe,0xffffffff,0xffabffff),\nuvec4(0xefffffea,0xebefffff,0xeffbc7fe,0xffffffef),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x1ffff),\nuvec4(0x0,0xf4001000,0xffffffff,0xffffffff),\nuvec4(0xfffff6bf,0xffffffff,0xfaffffff,0xfbffffff),\nuvec4(0xaabebfff,0xeffefefe,0xffffffef,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffff,0x0),\nuvec4(0xe0002400,0xffffffff,0xbfffffff,0xffffffa6),\nuvec4(0xafffffff,0xfffffff5,0xfbfffffa,0xafffefff),\nuvec4(0xfbffabfe,0xffffffef,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbfff,0x0,0x80000000),\nuvec4(0xffffffff,0xeaffffff,0xffffffff,0xbaafffff),\nuvec4(0x7fffffda,0xfe7fffd1,0xbffffbff,0xfbfffffe),\nuvec4(0xffffffbf,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x7fff,0x0,0x4000,0xfffffffe),\nuvec4(0xffffffff,0xffffffff,0xaffaafff,0x6fffffba),\nuvec4(0xff9aaad5,0xfffffbff,0xfefffffd,0xffefffbf),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x3fff),\nuvec4(0x0,0x4000,0xfffffff9,0xffffffff),\nuvec4(0xffffffff,0xbbf7feab,0x6ffffebb,0xffebff99),\nuvec4(0xffe9fbff,0xffbffffb,0xffbbfeff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x2fff,0x0),\nuvec4(0x0,0xfffffff8,0xffffffff,0xabffffff),\nuvec4(0xeea7fffe,0xeaabe6fe,0xfffebfd9,0xffefebff),\nuvec4(0xffafffef,0xfeaafeff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x1fff,0x0,0x0),\nuvec4(0xffffffe0,0xffffffff,0xfeaaffff,0xebfffaff),\nuvec4(0x6ffe5ffe,0xffffebee,0xfffaafff,0xfff9aabf),\nuvec4(0xfefbfbff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xbff,0x0,0x0,0xffffffd0),\nuvec4(0xffffffff,0xfffeaaff,0xfeffdfbf,0xfff9bffe),\nuvec4(0xfffffeaf,0xffffffff,0xfffebfff,0xffbfebff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x7ff),\nuvec4(0x0,0x0,0xffffffc0,0xffffffff),\nuvec4(0xffffffaa,0xff7fe7bf,0xaaaffffe,0xffffffe9),\nuvec4(0xffffffff,0xffffebff,0xffaabfff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x7ff,0x0),\nuvec4(0x0,0xffffff80,0xaabfffff,0xffffffff),\nuvec4(0xffebffbf,0xffffff5e,0xffffffff,0xffffffff),\nuvec4(0xfffffaff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x2ff,0x0,0x1),\nuvec4(0xffffff90,0xffa6ffff,0xffffffff,0xfff9babf),\nuvec4(0xffffffbe,0xffffffff,0xffffffff,0xfffffeff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x100001ff,0x0,0x6,0xffffff90),\nuvec4(0xffffaabf,0xffffffff,0xffffffff,0xffffffab),\nuvec4(0xffffffff,0xffffffff,0xffffaeff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x600000ff),\nuvec4(0x0,0x100006,0x6fffffd0,0xffffffa9),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffff5eff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xb00000bf,0x0),\nuvec4(0x600000,0xbfffffd0,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffbeff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf000007f,0x0,0x1e00000),\nuvec4(0xffffffe4,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffabff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xf400003f,0x1,0x7e00000,0xfffffff4),\nuvec4(0xffffffff,0xffbfffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfffffffe,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xf400002f),\nuvec4(0x1,0x6fe00000,0xfffffff9,0xffffffff),\nuvec4(0xeb3effff,0xffffffff,0xffffffff,0x6febffff),\nuvec4(0xfffffff6,0xffffffff,0xfffffeff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xf400002f,0x2),\nuvec4(0xffe00000,0xffffffff,0xffffffff,0xf76affff),\nuvec4(0xffdfdfff,0xffffffff,0xe7f7ffff,0xfffffffb),\nuvec4(0xffffffff,0xfffffeff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf800002f,0x3,0xffd00000),\nuvec4(0xffffffff,0xffffffff,0x7a6affff,0x5f9697ba),\nuvec4(0xfabff96f,0xf7f99fd9,0x7e96e5bf,0x97d6e9f9),\nuvec4(0xfffffe6b,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xfc00002f,0x3,0xffd00000,0xffffffff),\nuvec4(0xffffffff,0xad75ffff,0xa7f7f7bb,0xe57ff6de),\nuvec4(0xfafdf7ae,0xadaddf7e,0x68e9df67,0xffffffba),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfc00002f),\nuvec4(0x3,0xffc00004,0xffffffff,0xffffffff),\nuvec4(0xde79ffff,0x66fafbaf,0x76affaeb,0xb7febade),\nuvec4(0xddddebad,0xa9eaaba6,0xffffffba,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfc00003f,0x3),\nuvec4(0xffc0001c,0xffffffff,0xffffffff,0xefbeffff),\nuvec4(0x97a7d7ef,0xba7ffefb,0x9bffabef,0x5aaeb57f),\nuvec4(0xe6f5b9be,0xffffff9b,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfc00003f,0x3,0xffc00018),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xf7ffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xfc00003f,0x3,0xffc00000,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffef,0xfbffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xf800007f),\nuvec4(0x2,0xff800000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffdb),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xf80000bf,0x2),\nuvec4(0xff800000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffdf,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf80000ff,0x2,0xff800000),\nuvec4(0xffffffff,0xffffffff,0xefffffff,0xffffffff),\nuvec4(0xffffffff,0xfeae7f9b,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xf40001ff,0x1,0xff400000,0xffffffff),\nuvec4(0xffffffff,0x9fffffff,0x565aaaaa,0x96955555),\nuvec4(0x5f9ebde7,0x5666aaaa,0x5aaa5555,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xf00002ff),\nuvec4(0x0,0xff400000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffe5fdba),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xe00003ff,0x0),\nuvec4(0xff400000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfff9ff56,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x900007ff,0x0,0xff400010),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfffebfff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x50000bff,0x0,0xff000060,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffff9bff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x1fff),\nuvec4(0x0,0xff000000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x2fff,0x0),\nuvec4(0xff000000,0xffffffff,0xeabfffff,0xfffaffff),\nuvec4(0xfaffffff,0xaffffebf,0xfffffaff,0xffffffff),\nuvec4(0xaaffffff,0xffffeabf,0xffffafff,0xffffffff),\nuvec4(0xffffffff,0x3fff,0x0,0xff000000),\nuvec4(0xffffffff,0xe4ffffff,0xfff5ffff,0x92ffffff),\nuvec4(0x51fffd2f,0xffffd2f4,0xffffffff,0xe1ffffff),\nuvec4(0xfffff93f,0xffff2fff,0xffffffff,0xffffffff),\nuvec4(0x7fff,0x0,0xfe000000,0xffffffff),\nuvec4(0xf8bfffff,0xfff5ffff,0xf6ffffff,0xfd6fff2f),\nuvec4(0xfffff3f6,0xffffffff,0xf5ffffff,0xffffeb9f),\nuvec4(0xffff6fff,0xffffffff,0xffffffff,0x7fff),\nuvec4(0x0,0xfe000000,0xffffffff,0xfcbfffff),\nuvec4(0xfff8ffff,0xf6ffffff,0xff9fff5f,0xfffff6fb),\nuvec4(0xffffffff,0xf9ffffff,0xffffefd7,0xffffdfff),\nuvec4(0xffffffff,0xffffffff,0x7fff,0x0),\nuvec4(0xfe000000,0xffffffff,0xfe7fffff,0xfffdbfff),\nuvec4(0xf8ffffff,0xffcbff8f,0xfffff9fb,0xffffffff),\nuvec4(0xfcffffff,0xfffffff9,0xffffdbff,0xffffffff),\nuvec4(0xffffffff,0xbfff,0x0,0xfe000000),\nuvec4(0xffffffff,0xff3fffff,0xfffd7ffa,0xfcbfffff),\nuvec4(0xffe2ffdb,0xffebfcff,0xfffbffff,0x6e7fffff),\nuvec4(0xfffffbfe,0xffffe7bf,0xffffffff,0xffffffff),\nuvec4(0x8000bfff,0x1,0xfd000000,0xffffffff),\nuvec4(0x6f6fffff,0x7e457f95,0xa8bffe44,0xfff5ffe6),\nuvec4(0x4b41fdbf,0x1f95757f,0x8f3fff91,0xf954b8bf),\nuvec4(0xfffff156,0xffffffff,0xffffffff,0xb9047fff),\nuvec4(0x2,0xfd000000,0xffffffff,0x8b9fffff),\nuvec4(0x3dbe2f3f,0x653ffcbd,0x6ff8fff1,0x9dbe6e79),\nuvec4(0x2f7f5e7f,0x866fff6e,0xb9f8bcff,0xfffff5f8),\nuvec4(0xffffffff,0xffffffff,0xa5007fff,0x2),\nuvec4(0xfd000000,0xffffffff,0xe7cffbff,0x2e7f9f2f),\nuvec4(0xff3ffdbf,0x7ffdbff5,0x9dff9f3d,0x9f2fdb6f),\nuvec4(0x995fabaf,0x39fd7dbf,0xfffff9fe,0xffffffff),\nuvec4(0xffffffff,0x15bfff,0x0,0xf8000000),\nuvec4(0xffffffff,0xf6dbdabf,0x5f3f8f6f,0xff5ffe7f),\nuvec4(0x3ffe7ff9,0xadbfdbae,0xcf56e79b,0x9e0f56ff),\nuvec4(0x6dbf3e7f,0xfffffdff,0xffffffff,0xffffffff),\nuvec4(0x50b4ffff,0x0,0xf8000000,0xffffffff),\nuvec4(0xf9e79f5f,0x9f6fdb5f,0xbfdfff3f,0x2ffe7ffc),\nuvec4(0x9e7ff39f,0xdbf912d7,0xdfcbffff,0x8e7f6f7f),\nuvec4(0xfffffe7f,0xffffffff,0xffffffff,0x51f8ffff),\nuvec4(0x0,0xf4000000,0xffffffff,0xfcf3efdf),\nuvec4(0xcb8fd7cf,0x7fdbff9f,0x5fff7ffd,0xae3ff6df),\nuvec4(0xe3ffe5f6,0x9fe7ffff,0xdb3f9f5f,0xfffffe7f),\nuvec4(0xffffffff,0xffffffff,0x1ffffff,0x0),\nuvec4(0xf4000000,0xffffffff,0xfdb5ffcf,0xd7dbe3d7),\nuvec4(0x3fe7ff8f,0x9ffe7fff,0x5f5ffad7,0xf6dff9f8),\nuvec4(0x9ff2ffff,0xdb6fcbcf,0xffffff6f,0xffffffff),\nuvec4(0xffffffff,0xbfffff,0x0,0xf0000000),\nuvec4(0xffffffff,0xfdb8bf9f,0xe3d7f2f2,0x6fe3ffcb),\nuvec4(0xdbfd7fff,0x2fcbf6e3,0xf5d7f9fd,0x8ff5ffff),\nuvec4(0xdb9fdbcb,0xffffff8f,0xffffffff,0xffffffff),\nuvec4(0xbfffff,0x0,0xf0000000,0xffffffff),\nuvec4(0x64fe597f,0xf2e2f5b9,0x5ff1ffc7,0xf5a5ff7f),\nuvec4(0x1ff193f2,0xf8b596fe,0x8bf8bfff,0x5f8be3d3),\nuvec4(0xffff9f81,0xffffffff,0xffffffff,0x7fffff),\nuvec4(0x0,0xe0000000,0xffffffff,0x57ffe6ff),\nuvec4(0xe5a6e5bf,0x47e5bf96,0xbe5bffbe,0x5bfe5fe5),\nuvec4(0xf5ae5bfe,0xabf6afff,0xbf6ad99a,0xffffefae),\nuvec4(0xffffffff,0xffffffff,0x3fffff,0x0),\nuvec4(0xe0000000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x2fffff,0x0,0xd0000000),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x1fffff,0x0,0xd0000000,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xfffffbff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x1fffff),\nuvec4(0x0,0xe4000000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffe7ff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbffff,0x0),\nuvec4(0xf8000000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffbabf,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbffff,0x0,0xfc000000),\nuvec4(0xa7ffffff,0xaaaaaaaa,0x96aaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaa959a,0xaaaaaaaa,0x99aaaaaa),\nuvec4(0xaaaaaaaa,0x6aaaaaaa,0xffffffff,0xffffffff),\nuvec4(0x3ffff,0x0,0xfd000000,0xffffffff),\nuvec4(0xffffffff,0x6fffffff,0xfffffdea,0xffffffff),\nuvec4(0xffffbeff,0xffffffff,0xfaafdfff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x2ffff),\nuvec4(0x0,0xff900000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfffffea9,0xffffffff,0xffffe6ff),\nuvec4(0xffffffff,0xfeba7fff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x1fffff,0x0),\nuvec4(0xfff40000,0xffffffff,0xffffffff,0xffffebff),\nuvec4(0xffff5696,0xffffffff,0xffffebff,0xffffffff),\nuvec4(0xffeea5ff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x2fffff,0x18000000,0xfff40000),\nuvec4(0xffffffff,0xffffffff,0xfeaaa9af,0xfafffe9b),\nuvec4(0xffffffff,0xffffffff,0xabffffff,0xbfeabffe),\nuvec4(0xfffffaaa,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x416fffff,0x18000001,0xfff80000,0xffffffff),\nuvec4(0xffffffff,0xfafffb66,0xeb7ffeab,0xffffffff),\nuvec4(0xffffffff,0x7bffffff,0xebfabffe,0xfffeaabf),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xe2ffffff),\nuvec4(0x2e400007,0xfffc0000,0xffffffff,0xaaffffff),\nuvec4(0xfbfffbde,0xedbffeab,0xffff95bf,0xafffffff),\nuvec4(0xbbffffff,0xfbfaafff,0xfffeaeff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xe2ffffff,0x2fc00007),\nuvec4(0xfffc0000,0xffffffff,0xfebfffff,0xfbcafeab),\nuvec4(0xefffebbf,0xffff7f7f,0xafffffff,0xfbffffff),\nuvec4(0xfbfebbff,0xfeaaaafd,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf2ffffff,0x2fc00007,0xfffd0000),\nuvec4(0xffffffff,0xefafffff,0xfbdefeaf,0xebffaebb),\nuvec4(0xffffbf7f,0xbfffffff,0xafffffff,0xfbfebeaf),\nuvec4(0xfbffabf9,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xf1ffffff,0x2fd00007,0xfffd0000,0xffffffff),\nuvec4(0xa7bfffff,0xfafefebf,0xfaaafebb,0xb7ef95ff),\nuvec4(0x7ff66f95,0xfffd7da6,0xfbfebfea,0xfb6febfa),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xf5ffffff),\nuvec4(0x2fd00007,0xfffe0000,0xffffffff,0xbfbfffff),\nuvec4(0xff9bfdff,0xfffffefb,0xf7df7fff,0xbff7eb7e),\nuvec4(0xffff7ddf,0xaffbbfff,0xfbaff6ff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xf4ffffff,0x2fd00007),\nuvec4(0xfffe0000,0xffffffff,0xaabfffff,0xfffff7ff),\nuvec4(0xfffffefe,0xf7df7fbf,0xaffbfb7e,0xffffa7df),\nuvec4(0xfffbefff,0xfeeffdff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf8ffffff,0x2fe00003,0xfffe0000),\nuvec4(0xffffffff,0xffffffff,0xbfffd9ff,0xfffffeff),\nuvec4(0xb29f997f,0x7ff6df6d,0xffffd7e6,0xffefefff),\nuvec4(0xffbffebf,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xf8bfffff,0x2fe00003,0xfffe0000,0xffffffff),\nuvec4(0xffffffff,0xdbff5aff,0xfffffbff,0xfebfeaff),\nuvec4(0xbff7bfae,0xffffebfe,0xfebfdfea,0xffffd59f),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfcbfffff),\nuvec4(0x2fe00003,0xfffe0000,0xffffffff,0xffffffff),\nuvec4(0xf5aafa6f,0xffaffbff,0xffffffff,0xfff7ffff),\nuvec4(0xfffff7ff,0xaaffebda,0xfffffffa,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfcbfffff,0x3ff00002),\nuvec4(0xfffe0000,0xffffffff,0xffffffff,0xfeffffef),\nuvec4(0xfe9befff,0xffffffff,0xfffaf7ff,0xfffffaff),\nuvec4(0xaffffafe,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfd7fffff,0x3ff40002,0xffff4000),\nuvec4(0xffffffff,0xffffffff,0xffbfffff,0xfeefafff),\nuvec4(0xffffffff,0xfffe67ff,0xfffffebf,0xfffffebe),\nuvec4(0xfffffffe,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xfd7fffff,0x7ff40001,0xffff4000,0xffffffff),\nuvec4(0xffffffff,0xffbfffff,0xfebebfff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffeb,0xfffffffe),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xbe3fffff),\nuvec4(0x7ff80001,0xffff4000,0xffffffff,0xffffffff),\nuvec4(0xdbafffff,0xffebffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xe7ffffff,0xfffffffe,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x7e2fffff,0x2ffc0000),\nuvec4(0xffff4000,0x57ffffff,0xf995bfd5,0xabafffff),\nuvec4(0xffffffff,0xaa6fffff,0xffffffed,0xffffffff),\nuvec4(0xf9ffffff,0xfffffffe,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x2e2fffff,0x2ffc0000,0xffff0000),\nuvec4(0xbffffff,0xee01fae0,0xffbfffff,0xffffffff),\nuvec4(0x1692ffff,0xffffffec,0xffffffff,0xbeffffff),\nuvec4(0xfffffffe,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x1f1fffff,0x1ffc0000,0xfffe0000,0xfffffff),\nuvec4(0xfa02fee0,0xffffffff,0xffffffff,0x7af0bfff),\nuvec4(0xffffffe8,0xffffffff,0xabffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x1f5fffff),\nuvec4(0x1ffc0000,0xfffd0000,0xfffffff,0xfb01fee0),\nuvec4(0xffffffff,0xffffffff,0xffb47fff,0xffffffb8),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xf5fffff,0x1ff80000),\nuvec4(0xfffd0000,0x4fffffff,0xfb00fed0,0xffffffff),\nuvec4(0xffffffff,0xffb43fff,0xffffffb9,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xb4fffff,0xff40000,0xfff80000),\nuvec4(0x4fffffff,0xff00fed0,0xffffffff,0xffffffff),\nuvec4(0xff782fff,0xffffffb6,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x78fffff,0xbf40000,0xfff40000,0x8fffffff),\nuvec4(0xfb01bec0,0xffffffff,0xffffffff,0xffb42fff),\nuvec4(0xffffffb7,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x38bffff),\nuvec4(0xbf40000,0xfff40000,0xcfffffff,0xfb017ac0),\nuvec4(0xffffffff,0xffffffff,0xffb42fff,0xffffff77),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x2cbffff,0x7f00000),\nuvec4(0xffe00000,0xcfffffff,0xfb027b80,0xffffffff),\nuvec4(0xffffffff,0xffb42fff,0xffffffb7,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x1dbffff,0x7e00000,0xffd00000),\nuvec4(0xcfffffff,0xfb027b41,0xffffffff,0xffffffff),\nuvec4(0xfeb02fff,0xffffffbb,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbfffffff,0xffffffff),\nuvec4(0x1d7ffff,0x7e00000,0xff800000,0xcfffffff),\nuvec4(0xf702ab41,0x5551e555,0x5bba9af9,0xfee03ff9),\nuvec4(0x956955bf,0x681501,0x1e55bf84,0x16fff955),\nuvec4(0x1ed55b95,0xbfffffe4,0xffffffff,0xa7ffff),\nuvec4(0x7d00000,0xff400000,0xcfffffff,0xf7029b02),\nuvec4(0xbd07b403,0x4bfd03a0,0xfbc03fef,0xd02d02ff),\nuvec4(0x4074be02,0x1e01e83f,0xbfe81f0,0x3ee03ee0),\nuvec4(0xffffffe8,0xffffffff,0x63ffff,0x3c00000),\nuvec4(0xff400000,0xcfffffff,0xf702df02,0xed07b803),\nuvec4(0x8fed0680,0xaf00bffb,0xa02a03ff,0x40b6ae03),\nuvec4(0x2b01b066,0x1bfb4770,0x7ed03fb0,0xffffffed),\nuvec4(0xffffffff,0x12ffff,0x2c00000,0xfe000000),\nuvec4(0xcfffffff,0xf702de02,0xed0bb417,0xdbed0681),\nuvec4(0xf801fffe,0xa03903fe,0x40a7ee07,0x2b01a07e),\nuvec4(0x27fa07b0,0xbac07fa0,0xfffffffa,0xffffffff),\nuvec4(0x2ffff,0x2800000,0xfe000000,0xcfffffff),\nuvec4(0xfb01e906,0xed07b426,0xa7ed0641,0xd007ffff),\nuvec4(0x503a03fb,0x80abee07,0x2b01907e,0x27fa07b0),\nuvec4(0xbb807ee0,0xfffffffa,0xffffffff,0x1ffff),\nuvec4(0x1400000,0xfd000000,0xcfffffff,0xfb01e506),\nuvec4(0xed07b426,0xb6ed0641,0x401bffff,0x603a03ee),\nuvec4(0x80afee03,0x2b02a07e,0x73f907b0,0xbb407ed0),\nuvec4(0xfffffffa,0xffffffff,0x1ffff,0x400000),\nuvec4(0xf8000000,0xcfffffff,0xfb02b40a,0xed0bb029),\nuvec4(0xedee0681,0x7fffff,0x503a03ad,0x80bfee03),\nuvec4(0x2b02a07d,0x77e907b0,0xbb017ed0,0xfffffffa),\nuvec4(0xffffffff,0xffff,0x0,0xf8000000),\nuvec4(0xcfffffff,0xfb02b40e,0xdd0bb02d,0xfa6d0681),\nuvec4(0x2ffffff,0x603a03b4,0x80fdee07,0x2b02b47e),\nuvec4(0x76ed07b4,0xad027ed0,0xfffffffa,0xffffffff),\nuvec4(0xffff,0x0,0xf4000000,0xcfffffff),\nuvec4(0xfb02b40e,0xdd0ba02d,0xfb6d0690,0xbffffff),\nuvec4(0x602a03a0,0x80ecee07,0x2b02b83e,0x6aed0bb4),\nuvec4(0x6d067ec0,0xfffffffa,0xffffffff,0xbfff),\nuvec4(0x0,0xf0000000,0xcfffffff,0xfb42a81e),\nuvec4(0xad0fa06d,0xfe9d07a4,0x2fffffff,0x602a06d0),\nuvec4(0x80ec6a03,0x2b02ee2d,0xa9ed0770,0x680a7ec0),\nuvec4(0xfffffffa,0xffffffff,0xbfff,0x0),\nuvec4(0xf0000000,0xcfffffff,0xbb42e81e,0x5d0fa07a),\nuvec4(0xba8a07ed,0x7fffffff,0x601902c0,0x80f81503),\nuvec4(0x2b01fb8a,0xeded0770,0xb40e7e80,0xfffffffa),\nuvec4(0xffffffff,0x7fff,0x0,0xe0000000),\nuvec4(0xdfffffff,0x7b42ec2d,0x5d0e90ba,0xb41607f7),\nuvec4(0xbfffbbff,0xa02a02c0,0x80e86e03,0x2b41fde2),\nuvec4(0xeded0770,0xb01a7e81,0xfffffffa,0xffffffff),\nuvec4(0x7fff,0x0,0xe0000000,0xcfffffff),\nuvec4(0x7b42ed2d,0x610ad0bb,0xb42907fa,0xfffeabff),\nuvec4(0x602a06c0,0x40e9ea03,0x2b41fee4,0xeda90770),\nuvec4(0x602a7a41,0xfffffffa,0xffffffff,0x3fff),\nuvec4(0x0,0xe0000000,0xcfffffff,0x3b42ed3d),\nuvec4(0x3c0ed0fb,0xb02c07ed,0xfffeefff,0x603a05c1),\nuvec4(0x40eaea03,0x2b41fe87,0xeda907b0,0x503a7b42),\nuvec4(0xfffffffb,0xffffffff,0x2fff,0x0),\nuvec4(0xd0000000,0xcfffffff,0x7b42fa7e,0x6d0ac055),\nuvec4(0xb02d07e8,0xfffedfff,0x603b02c1,0x80ffee03),\nuvec4(0x2b41fb4a,0x447a07b4,0x7a7b41,0xfffffffb),\nuvec4(0xffffffff,0x2fff,0x0,0xc0000000),\nuvec4(0xcfffffff,0x6b41fa7e,0x6d0ac1ff,0xe06e07b4),\nuvec4(0xfffbdffe,0x603a02c0,0x80ffea03,0x2b41fb0a),\nuvec4(0xaa7a07b4,0xfa7a02,0xfffffffa,0xffffffff),\nuvec4(0x1fff,0x0,0xc0000000,0xcfffffff),\nuvec4(0xab41fbbe,0x6d0a81bb,0xd06e07b0,0xfffb9ffe),\nuvec4(0x603a02c0,0x80affa03,0x2b01ed0e,0x6b3a07b4),\nuvec4(0x1fa7602,0xfffffffa,0xffffffff,0x1fff),\nuvec4(0x0,0x90000000,0xcfffffff,0x9b41fbfe),\nuvec4(0xad0a41fb,0xd06e07a0,0xbffb6ffe,0xa03a02d0),\nuvec4(0x80bbfa03,0x2b01ec0e,0xfb6b03b4,0x2fa3a07),\nuvec4(0xfffffffa,0xffffffff,0x1fff,0x0),\nuvec4(0xe0000000,0xcfffffff,0x9b01fafe,0xad0a42fb),\nuvec4(0xc0b90790,0xbfef6ffe,0xa03b0290,0x80b7fa03),\nuvec4(0x1a01ec0e,0xfb5b03b4,0x3fa7907,0xfffffffa),\nuvec4(0xffffffff,0x18eff,0x0,0xf4000000),\nuvec4(0x8bfffffb,0x8701fffb,0xad0b02fb,0x80ed0680),\nuvec4(0x7fee2ffe,0xa03a03a0,0x80b6fa03,0x1a01e81e),\nuvec4(0xfb5e43b0,0x7f93d0b,0xfffffffa,0xffffffff),\nuvec4(0xbceff,0x0,0x99000000,0x8bfffffe),\nuvec4(0x8700fffb,0xad0742fb,0x80ed0680,0x2fb92ff7),\nuvec4(0xa02a02b8,0x80a5fa03,0x1a00b41e,0xfb4e82b4),\nuvec4(0xbed1c0b,0xffffffea,0xffffffff,0xa8bff),\nuvec4(0x0,0x59000000,0x7ffffe4,0x4200fffb),\nuvec4(0xad0602fb,0x40ed0180,0x1b902ffb,0x902a02ee),\nuvec4(0x80687a02,0x1a00700e,0xfb0ad1b4,0xfed180b),\nuvec4(0xffffff86,0xffffffff,0x4197bf,0x0),\nuvec4(0x50000000,0x96fff545,0xa6aabffa,0xa9a5aafb),\nuvec4(0x66aa6655,0xd56a6fee,0x555555ab,0x55595555),\nuvec4(0x56555559,0xfa56b955,0x5fe95557,0xfffffeaa),\nuvec4(0xffffffff,0x57bf,0x15400010,0x0),\nuvec4(0xffff9a50,0xfbffffef,0xbffbffef,0xffaffbff),\nuvec4(0xffffffbf,0xfffbfffa,0xffdffffe,0xfbffbffb),\nuvec4(0xefffefff,0xffbfefff,0xffffffbb,0xffffffff),\nuvec4(0x1a3ff,0xabe80064,0x1a55aa,0xabffd040),\nuvec4(0xbaaabfea,0x6aeaabaa,0xabaaeaaf,0xaaaabdaa),\nuvec4(0xaaeaaaff,0xaaeaaaad,0xaaaaaaba,0x95aafaaa),\nuvec4(0xbf6b995b,0xffffffe6,0xffffffff,0x5416b3ff),\nuvec4(0xfbfe41f9,0x16effffe,0xffffe800,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x146fb6ff,0xafefa6a4),\nuvec4(0xbefefffa,0xffffffaa,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x55fff9ff,0xfbbeee55,0xaafffbfa),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x1fff9ff,0xbbbeba6d,0xfbffffef,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x55fffcbf),\nuvec4(0xbffffd49,0xfbfffaef,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x55ffecbe,0xbfffea95),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xa6fffd7f,0xffffbeb5,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0x52ffefff,0xfffffe41,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x17ffffff),\nuvec4(0xffffffa5,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x605901,0x1545000),\nuvec4(0x54555510,0xf9555555,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffaaffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0x1518241,0x0,0x0),\nuvec4(0xf8000000,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xfeffbfff,0xffefffff,0xffffffff,0xffffffff),\nuvec4(0x4601081,0x400400,0x0,0xf8000001),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xfeebbfff),\nuvec4(0xffefffff,0xffffffff,0xffffffff,0x1a981),\nuvec4(0x54461924,0x20044115,0xf4646451,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffaeffff,0xffdbffff),\nuvec4(0xffffffbb,0xffffffff,0x16201d1,0x8410414),\nuvec4(0x60054114,0xf8141061,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xeef6ffff,0xba9ebbbb,0xfffffea7),\nuvec4(0xffffffff,0x600c1,0x4594444,0x50020104),\nuvec4(0xf8141011,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xeafbffff,0xbeefbbab,0xfffffef7,0xffffffff),\nuvec4(0x20081,0x54500454,0x10011500,0xf8001051),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xdeb6ffff),\nuvec4(0x7ddebaa7,0xffffff77,0xffffffff,0x19601),\nuvec4(0x0,0x0,0xf8000000,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0x7eaabfff,0x97e6eafe),\nuvec4(0xfffffe6b,0xffffffff,0x555556,0x0),\nuvec4(0x0,0xf8000000,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffbeffbf),\nuvec4(0xfefbfefb,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffbfffff,0xfffbffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xaeefffff,0xaffafffb,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xeeabffff,0xeffffffe,0xffffffef),\nuvec4(0xffffffff,0x957ffd54,0x56ff7957,0xfdff7e7f),\nuvec4(0xffabfdfa,0xfffafebf,0xffffffff,0x9c5fffff),\nuvec4(0xaaa699f7,0xffffa9a6,0xffffffff,0xffffffff),\nuvec4(0x9bfbffff,0x6eb69baa,0xfffffe9d,0xffffffff),\nuvec4(0xff7ffafc,0xfafe7ff7,0xfcbf3d7d,0xff77fdf6),\nuvec4(0xffde765f,0xffffffff,0x9d6fffff,0x5aab99f7),\nuvec4(0xffffa996,0xffffffff,0xffffffff,0xbafbffff),\nuvec4(0xefb6ddee,0xffffffdd,0xffffffff,0xd57ff9ac),\nuvec4(0xfeff7ea3,0xfa7f6dbd,0xff67fdea,0xffaf6feb),\nuvec4(0xffffffff,0x9eafffff,0xba75a996,0xffffaa9a),\nuvec4(0xffffffff,0xffffffff,0x9b5fffff,0xdd7bedf5),\nuvec4(0xfffffa5e,0xffffffff,0xff7ffd69,0xfdff7ea7),\nuvec4(0xf7af9dba,0xff8bfdde,0xffdf7ff7,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfafffebe,0xffffffff),\nuvec4(0xffffffff,0xff7ffafd,0xfdff7ff3,0xf69f667a),\nuvec4(0xd7a7fdae,0xffe5fff7,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xf9affffe,0xffffffff,0xffffffff),\nuvec4(0xff7ffafd,0xfdff7ff3,0xe55b727d,0xf979fd7d),\nuvec4(0xffffebe7,0xffffffff,0x98fbd567,0xaaee99b9),\nuvec4(0xeaaa666e,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xff7efd54),\nuvec4(0x55e97ea3,0xdbf7737d,0xf97dfdbd,0xfffbe69f),\nuvec4(0xffffffff,0xadf796eb,0x56eebbb8,0xea66766d),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xaaeefefb),\nuvec4(0xeffbbbbf,0xeae6fefe,0xffe6febf,0xffffffff),\nuvec4(0xadfaeaeb,0xaa99adaa,0xaa66aa6e,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xaf6eabff,0xfffff7fd,0xabffffff,0xffffffff),\nuvec4(0xffffeeff,0xffffffaf,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xff9efbff),\nuvec4(0xfaeae7fa,0xbbffffff,0xffffffff,0xffffd9ff),\nuvec4(0xfffffeab,0xffeabfff,0x6affffff,0xffffe9f7),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xbaafbfff,0x6aaddafd),\nuvec4(0xe7e67b7b,0x6565d9db,0xeba5d6f9,0xbae7adf7),\nuvec4(0xaebebeba,0x6bebafae,0xfffffeba,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xfeafefff,0xbad9d9fa,0xafef7b76),\nuvec4(0xfa79adee,0xd6a9dafd,0xaaa76efb,0x9da9f66a),\nuvec4(0x67e7a799,0xffffff7e,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xde77ebff,0x7aeddebb,0xfff6777b,0xff7dd9ea),\nuvec4(0xd9fecafd,0xafa7adf7,0x5edffba5,0x97f7ab99),\nuvec4(0xffffffbd,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0x6eae6bff),\nuvec4(0xbfbebfae,0x5beb7abb,0xe565aeeb,0xe9e9cefd),\nuvec4(0xaebbaebb,0xeeafb7ab,0xabfbf7ea,0xffffadbd),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfffffffb,0xfaffbfaf),\nuvec4(0xeffafebb,0xebbb6a6e,0xffffe6ee,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xeae7f7ea,0xfbafaaba),\nuvec4(0xfffffbbe,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xaa97fbe5,0xd66f6fb5,0xd64a9655),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xefbbeb6f,0x96efafba,0x975deaaa,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xfaffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xffffffff,0xffffffff,0xffffffff),\nuvec4(0xffffffff,0xbfffffff,0xaaaaaaff,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xfeaaaaaa,0xaaaaaabf,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xfaaaaaaa),\nuvec4(0xaaaaaaaf,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xeaaaaaaa,0xaaaaaaab),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xeaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaaa),\nuvec4(0xaaaaaaaa,0x0,0x0,0x0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n    vec2 dim = vec2(240,303);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    uv = floor(uv);\n    if (uv.x >= dim.x || uv.y >= dim.y) return;\n    int index = int(uv.y)*240+int(uv.x);\n    uvec4 d = data[index/(16*4)];\n    index %= 16*4;\n    uint t = d[index/16];\n    index %= 16;\n    t >>= 2*index;\n    t &= 3u;\n\n    // Time varying pixel color\n    vec3 col = vec3(float(t)/3.0);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 83, 83, 386]]}
{"id": "sdSyzt", "name": "fractal hat explorer", "author": "sympou", "description": "i was exploring fractal generation and i found... well... hats ?\n( click it ! )", "tags": ["fractal"], "likes": 14, "viewed": 287, "published": 3, "date": "1643918865", "time_retrieved": "2024-07-30T17:05:30.937580", "image_code": "#define PI 3.1415926535\n\nvec2 foldRotate16 ( in vec2 p ) {\n    const vec2 k1 = vec2(0.38268343230, -0.9238795325 );\n    const vec2 k2 = vec2(0.19509032201, -0.9807852804 );\n    p = abs(p);\n    p = (p.y<p.x) ? p : p.yx;\n    p -= min(2.0*dot(k1,p),0.0)*k1;\n    p -= min(2.0*dot(k2,p),0.0)*k2;\n    return p;\n}\n\nvec2 getDist(vec3 p) {\n    \n    // parameters :\n    \n    int iterations = 6;\n    \n    vec3 offset = vec3(2.,2.,2.);\n\n    float ang1 = 3.88322207745;\n    float ang2 = iMouse.x/iResolution.x*PI;\n    float ang3 = iMouse.y/iResolution.y*PI;    \n    \n    //\n    \n    float size = 1.;\n    \n    float t = p.y + 3.25;    \n    float orbitTrap = 0.;\n\n    mat3 rot = mat3(cos(ang1),-sin(ang1),0.,  sin(ang1),cos(ang1),0.,  0.,0.,1.)\n              *mat3(cos(ang2),0.,sin(ang2),  0.,1.,0.,  -sin(ang2),0.,cos(ang2))\n              *mat3(1.,0.,0.,  0.,cos(ang3),sin(ang3),  0.,-sin(ang3),cos(ang3));\n\n            \n    for( int i=0; i++<iterations; ){\n        \n        p.xz = foldRotate16(p.xz);\n        //p.xy = foldRotate16(p.xy);\n\n        size *= 0.5;\n        \n        p = abs(p.zxy*rot) - offset*size;\n\n        orbitTrap += dot(p,p);\n    }\n    \n    float t2 = length(p) - size*2.;\n    \n    if (t<t2) { return vec2(t,-1.); }\n\n    return vec2(t2,0.5-cos(orbitTrap*0.8)*0.5);\n}\n\nfloat rayMarch( vec3 ro, vec3 rd) {\n\n    float coneWidth = 0.001;\n    float t = 0.;\n    int i = 0;\n\n    while ( i<100 && t<999. ) {\n\n        float r = abs( getDist( ro + rd*t ).x );\n\n        if ( r <= coneWidth*t ) break;\n        t += r;\n        i ++;\n    }\n    \n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getDist(pos + eps.xyy).x;\n    float ny = getDist(pos + eps.yxy).x;\n    float nz = getDist(pos + eps.yyx).x;\n    return normalize(vec3(nx, ny, nz)-getDist(pos).x);\n}\n\n\n//ambient occlusion\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.1;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(getDist(p + eps*n).x,0.0);\n          occ += max(getDist(p + eps*u).x,0.0);\n          occ += max(getDist(p - eps*u).x,0.0);\n          occ += max(getDist(p + eps*v).x,0.0);\n          occ += max(getDist(p - eps*v).x,0.0);\n    \n    occ += (max(getDist(epn + eps2[2]*u).x,0.0)\n        +   max(getDist(epn - eps2[2]*u).x,0.0)\n        +   max(getDist(epn + eps2[2]*v).x,0.0)\n        +   max(getDist(epn - eps2[2]*v).x,0.0))*0.5;\n\n    occ += max(getDist(p + eps2[0]*n).x*sq[0],0.0);\n    occ += max(getDist(p + eps2[1]*n).x*sq[1],0.0);\n    occ += max(getDist(epn          ).x*sq[2],0.0);\n\n    return max(1.0 - 1./(1.+2.*occ), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float time2 = iTime*0.25;\n   \n    vec3 ro = vec3(cos(-time2)*8., 2.5, sin(-time2)*8. );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.yz *= mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    rd.xz = rd.xz*mat2(sin(time2),cos(time2),cos(time2),-sin(time2));\n    \n    ////\n        \t\n    float dist = rayMarch( ro, rd );\n    \n    vec3 hit = ro + rd*dist;\n    float orbitTrap = getDist(hit).y;\n    vec3 normals = distance_field_normal(hit);\n    vec3 pos = ro + dist*rd ;\n\n    vec3 col = vec3(.8,.8,1.);\n    if ( orbitTrap > 0. ) { col = mix(vec3(0.1,0.15,1.),vec3(1.,0.35,0.3),orbitTrap); }\n    \n    float diffuse = mix(normals.y,1.,0.65);\n    vec3 reflectDir = reflect(-vec3(0.,1.,0.),-normals);\n    float specular = pow (max (dot (-rd, reflectDir), 0.0), 100.0);\n    float ao = ao(pos, normals);\n        \n    fragColor = vec4( sqrt(( col + specular ) * diffuse * ao), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 58, 58, 306], [308, 308, 330, 355, 1270], [1272, 1272, 1307, 1307, 1550], [1552, 1552, 1590, 1590, 1803], [1980, 1980, 2006, 2006, 2935], [2937, 2937, 2994, 2994, 3941]]}
{"id": "7dByRt", "name": "Old CRT television", "author": "symanth", "description": "Recommended to watch with this video:\n - https://youtu.be/Wl959QnD3lM\nTo watch, use OBS Virtual camera and drop saved video into program", "tags": ["crttelevisionoldretrotv"], "likes": 2, "viewed": 302, "published": 3, "date": "1643911188", "time_retrieved": "2024-07-30T17:05:31.696551", "image_code": "// line_gap determines size of black lines\nconst float line_gap = 1.0; // px\n// line_size is visible height\nconst float line_size = 4.0; // px\n\n// parameters of ellipse\nconst float a = .6, b = .8;\n\n// function for laggy, noisy shift of image\nfloat noise(float x) {\n    return (sin(3.0*x)\n        + cos(8.0*x)\n        - cos(3.0 + 14.0 * x)\n        - sin(x * x / 2.0)\n    ) / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord/ iResolution.xy - 1.0;\n\n    float len = 1.0 - (pow(abs(uv.x), 9.0) / a + pow(abs(uv.y), 3.0) / b);\n    \n    // uncomment for visible edges\n    // len = step(0.0, len);\n    \n    if (len > 0.0) {\n        vec4 intensity = vec4(len, len, len, 1.0);\n    \n        vec2 skew = vec2(0.0);\n        skew.x = smoothstep(0.7, 1.0, noise(iTime)) / 10.0;\n        \n        \n    \n        float modulo = line_gap + line_size;\n        if (mod(fragCoord.y + modulo / 2.0, modulo) >= line_gap) {\n            fragColor = texture(iChannel0, (uv + vec2(1.0))/2.0 + skew) * intensity;\n        } else {\n            fragColor = vec4(vec3(0.0), 1.0);\n        }\n    } \n    \n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dByRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 242, 264, 264, 380], [382, 382, 439, 489, 1167]]}
{"id": "fdSczt", "name": "Pixel Art Test", "author": "SnoopethDuckDuck", "description": "procgen pixel art test - given up on it for now, might reuse some techniques later\n\nCleaner buffer A:\nhttps://www.shadertoy.com/view/flsfWr", "tags": ["e"], "likes": 3, "viewed": 233, "published": 3, "date": "1643911015", "time_retrieved": "2024-07-30T17:05:32.445549", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dim = dim(iTime);\n    vec3 col = vec3(0.);\n    \n    float sf = dim.y / (iResolution.y - 64.);\n    \n    vec2 offset = 0. * vec2(0, sf * (24. * cos(0.8 * iTime) - 4.));\n    vec2 coord = floor( sf * fragCoord + offset);\n    //coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim); // idk if this is optimal\n    \n    vec3 A = texelFetch( iChannel0,  ivec2(coord) , 0 ).rgb;\n    float B = texelFetch( iChannel1,  ivec2(coord) , 0 ).x;\n    \n    float d = length(coord + 0.5 - ceil(0.5 * dim)); //??   \n   // if (coord.x >= dim.x || coord.y >= dim.y)\n    //    B = 0.;\n    \n    float sd = step(d, 0.5 * dim.x);\n    float sb = step(length(A), 0.);\n    \n    //B *= sd * sb;\n    B = smoothstep(0., 1., B);\n    B = smoothstep(0., 1., B);\n    B *= 1. - coord.y / dim.y;\n    \n    B = ceil(5. * B) / 5.;\n    vec3 e = vec3(0.8);//0.5 + 0.5 * thc(3., iTime));\n    \n    float diag = 0. * -0.2 * ceil(-2. * (coord.x + coord.y)/dim.x) / 2.;\n    vec3 bcol = sd * sb * pal(diag + 0.38 * B, e, e, e, .5 * vec3(0.,0.33,0.66));\n    \n    //B = step(0.5, B);\n    col += bcol;\n    \n  //  col \n    //e *= 0.15;\n    col += step(0.001, A.y) * pal(diag + 0.5 * B, e, e, e, .5 * vec3(0., 0.33, 0.66));\n    col += A.x;\n    //col += (1.-A.x) * 0.1;\n    col += B * (1.-sd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// dimensions of sprite - has to be less than screen dimensions, evens only\n//#define dim { return vec(16); }\n\n#define reset 60.\n\n#define pi 3.14159\n\nvec2 dim(float t) {\n    return vec2(2. * ceil(10. + 6. * cos(t)));\n}\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_a_code": "float circle(vec2 fragCoord, vec2 dimm) {\n    float k = ceil(0.5 * dimm.x);\n\n    float d = length(fragCoord - 0.5 * dimm);\n    float v = step(d, k);\n    \n    float v1 = v - step(length(fragCoord - vec2(1,0)  - 0.5 * dimm), k);\n    float v2 = v - step(length(fragCoord - vec2(-1,0) - 0.5 * dimm), k);\n    float v3 = v - step(length(fragCoord - vec2(0,1)  - 0.5 * dimm), k);\n    float v4 = v - step(length(fragCoord - vec2(0,-1) - 0.5 * dimm), k);\n         \n    return max(max(v1, v2), max(v3, v4));\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x < p2.y) return vec2((p.x < 0.) ? -1. : 1., 0);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\nfloat getInnerOutline(vec2 fragCoord, vec2 dimm) {\n    float d = length(fragCoord - 0.5 * dimm);\n    float v = step(d, ceil(0.5 * dimm.x));\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec2 dim = dim(iTime);\n    vec3 col = vec3(0.);\n    if (coord.x < dim.x && coord.y < dim.y) {\n        \n       // outer circle\n       float v = circle(coord, dim);\n      \n       // inner circle (based off outer circle, so they align)\n       // inspired from here: https://www.youtube.com/watch?v=I8fmkLK1OKg\n       vec2 c = abs(coord - 0.5 * dim); \n       vec2 dir;\n       if (c.x <= c.y) dir = vec2(0, (coord.y <= 0.5 * dim.y) ? 1. : -1.);\n       else            dir = vec2((coord.x <= 0.5 * dim.x) ? 1. : -1., 0);          \n       float v2 = circle(coord - dir, dim);\n       \n       //v *= pow(coord.y / dim.y, 1.);\n       v2 *= coord.y / dim.y;\n        \n       float st = 5.;\n       v = ceil(st * v) / st;\n       v2 = ceil(st * v2) / st;\n\n\n       col = vec3(v, v2, 0);\n    }\n\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// ( Most of this code was stolen from iq somewhere )\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// generate mirrored noise\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec2 dim = dim(iTime);\n    // uncomment iTime for a cool look\n    vec2 uv = vec2(abs(coord.x - 0.5 * dim.x), coord.y)\n            + 20. * floor(float(iFrame) / float(reset));// + iTime;\n \n\tfloat f = 0.0;\n\t\n\tuv *= 0.01;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf =  0.5000 * noise( uv ); uv = m*uv;\n    f += 0.2500 * noise( uv ); uv = m*uv;\n\tf += 0.1250 * noise( uv ); uv = m*uv;\n\tf += 0.0625 * noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5 * f;\n\n    fragColor = vec4(f);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1337]]}
{"id": "NdByzd", "name": "Spherical Spiral Net 1 a", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration: https://twitter.com/smjtyazdi/status/1464690994411151360\n( see also the next variant with correct base shape :-) ).", "tags": ["raymarching", "short", "reproduction"], "likes": 21, "viewed": 294, "published": 3, "date": "1643910182", "time_retrieved": "2024-07-30T17:05:33.254386", "image_code": "#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )// rotation 3D\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))            // rotation 2D\n\n#define cone(A) atan(length(q-q*A),length(q*A))               // angle between q and axe A\n#define T(A)    6.*sin(iTime) *sign(dot(q,A))                 // amplitude of torsion\n//#define S(A)  rot3(q, A, T(A)* exp(-3.*cone(A) ) )\n//#define S(A)  rot3(q, A, T(A)* smoothstep(.5,0.,cone(A) ) )\n  #define S(A)  rot3(q, A, T(A)* smoothstep(.08,1.,exp(-3.*cone(A) ) )) // distortion\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., s,c; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n     // q = S(vec3(1,0,0)),                // try 1\n     // q = S(vec3(0,1,0)),\n     // q = S(vec3(0,0,1)),\n     // s = min( abs(S(vec3(1,0,0)).x), min( abs(S(vec3(0,1,0)).y) , abs(S(vec3(0,0,1)).z) ) ), // try 2\n        a = abs(q),\n        q = S(vec3( max(a.y,a.z)<a.x, max(a.x,a.z)<a.y, max(a.x,a.y)<a.z )),\n        a = abs(q), s = min(a.x,min(a.y,a.z)),                // 3 planes      \n        t = min( min(t ,c=length(q)-.3),                      // small sphere\n                 s = max( length(q)-1.2, s ) ),               // 3 planes inter big sphere\n   \n       p += .3*t*D;                                           // step forward = dist to obj          \n   }                                                          // --- color scheme\n   if (t==s) O.rgb *= step(a-s,a-a);                          // planes color\n// if (t==c) O=... ;                                          // central sphere color\n// O *= O*O*2.;                                               // contrast\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 580, 580, 2074]]}
{"id": "NdBcRd", "name": "Broken Buddha", "author": "eiffie", "description": "The best fractals are broken fractals.", "tags": ["buddhabrot"], "likes": 31, "viewed": 548, "published": 3, "date": "1643904761", "time_retrieved": "2024-07-30T17:05:33.999394", "image_code": "//broken buddha by eiffie \n//track the position of points near the border of the mandelbrot set as they orbit\n#define time iTime\n#define rez iResolution.xy\n\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time iTime\n#define rez iResolution.xy\n#define pi 3.14159\nvec4 load(float x, float y){return texture(iChannel0,vec2(x+.5,y+.5)/rez.xy);}\nmat2 rmat(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 cmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,dot(a,b.yx));}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n  U=floor(U);\n  vec4 L=load(0.,0.);\n  float f=float(iFrame);\n  float a=floor(f)*0.001;\n  \n  if(U.x+U.y==0.){\n    int iters=int(floor(a))+7;\n    a*=pi;\n    vec2 p=vec2(cos(a),sin(a/1.5)),rd=-p;p.x-=.5*cos(a*.007);\n    for(int i=0;i<32;i++){\n      float dr=1.,r=length(p);\n      vec2 C=p,Z=p;\n      for(int n=0;n<iters && r<2000.;n++){\n        Z=cmul(Z,Z)+C;\n        dr=dr*r*2.+1.;\n        r=length(Z);\n      }\n      p+=rd*.5*log(r)*r/dr;\n    }\n    p+=rd*(1.+cos(a*.3))*.1;\n    O=vec4(p.x,p.y,p.x,p.y); \n  }else{\n    vec2 p0=L.xy;\n    vec2 u=(2.*U-rez.xy)/rez.y;\n    for(int j=0;j<5;j++){\n      vec2 p=p0+vec2(0.001)*float(j);\n      for(int n=0;n<20 && dot(p,p)<300000.;n++){\n        p=cmul(p,p)+p0;\n        float d=length(abs(u)-abs(p));d=smoothstep(2./rez.y,0.0,d)*.2;///(1.+40.*O.r*O.r);\n        vec3 col=vec3(d*p*rmat(a*7.+float(j)*0.3),d);\n        col.yz*=rmat(a*5.+float(j+n)*.03);\n        O+=vec4(abs(col.grb),0.);\n      }\n    }\n    O=O*.995;\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define bps 2.5\n#define pi 3.14159\nint N[8]=int[8](0,4,2,4,5,7,9,5);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.; \n return note; \n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n} \nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+cos(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\n\nvec2 mainSound(int samp, float time){\n  float tim=time*bps;if(tim>80.)tim-=80.;if(tim>80.)tim+=48.+128.;\n  float bt=floor(tim),t=fract(tim);\n  int n1=N[int(bt/64.)%8];\n  int n0=n1+N[int(bt/8.)%8],n=n0+N[int(bt)%8],n2=n0+N[int(bt/2.)%8],n4=n0+N[int(bt/4.)%8];\n  const vec4 dtn=vec4(1.014,0.005,1.,.5);\n  vec2 v=I(n+60,t,vec3(1.-t*.5,1.,t),vec4(.25,1.,18.,t*.6),dtn)*.25;\n  \n  t=fract(tim/2.); \n  float fo=pow(1.-t,20.0);\n  v+=I(n2+60,t,vec3(1.-fo*.5,1.5,fo),vec4(1.,4.0,24.,t*.8),dtn);\n  \n  t=fract(tim/4.);\n  fo=pow(1.-t,20.0);\n  v+=I(n4+67,t,vec3(1.-fo*.5,1.5,fo),vec4(1.,4.0,36.,t*.8),dtn);\n  \n  t=fract(tim/8.);\n  fo=pow(1.-t,20.0);\n  v+=I(n0+60,t,vec3(1.-fo*.5,1.5,fo),vec4(1.,2.0,48.,t*.6),dtn);\n  return v*.2;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 195, 195, 230]]}
{"id": "NsByRt", "name": "Rotating circles shapes", "author": "MarcoF", "description": "A fun little shader to experiment with coordinates transformations.", "tags": ["shapes"], "likes": 5, "viewed": 198, "published": 3, "date": "1643901105", "time_retrieved": "2024-07-30T17:05:34.741410", "image_code": "float circle(vec2 uv, vec2 position, float radius, float blur)\n{\n\treturn 1.0 - smoothstep(radius - blur, radius + blur, length(uv - position));\n}\n\nvec2 rotate(vec2 original, float angle, vec2 pivot)\n{\n\tmat2 rotation = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\tvec2 final = original;\n\tfinal -= pivot;\n\tfinal *= rotation;\n\tfinal += pivot;\n\treturn final;\n}\n\nvec2 scale(vec2 original, vec2 scale, vec2 pivot)\n{\n\tscale = 1.0 / scale;\n\tmat2 s = mat2(scale.x, 0.0, 0.0, scale.y);\n\tvec2 final = original;\n\tfinal -= pivot;\n\tfinal *= s;\n\tfinal += pivot;\n\treturn final;\n}\n\nfloat changeRange(float iValue, float iMin, float iMax, float fMin, float fMax) \n{\n\tfloat fValue = (iValue-iMin)/(iMax-iMin);\n\tfValue *= fMax-fMin;\n\tfValue += fMin;\n\treturn fValue;\n}\n\nint nCircles = 50;\nbool coolEffect = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord / mr;\n    \n    uv.x -= 0.5;\n\n    vec3 col = vec3(0);\n    \n\tfor (int i = 0; i < nCircles; i++) {\n\t\tfloat s = changeRange(float(i), 0.0, float(nCircles - 1), 1.0, 1.0/float(nCircles));\n\n\t\tvec2 suv = scale(uv, vec2(s), vec2(0.5));\n\n\t\tfloat t = changeRange(float(i), 0.0, float(nCircles - 1), iTime*0.1, iTime*2.1);\n        \n        if (coolEffect && i%2!=0) t *= -1.0;\n        \n\t\tvec2 ruv = rotate(suv, t, vec2(0.5));\n\n        if (distance(ruv, vec2(0.5)) < 0.5) {\n            float c = float(ruv.x < 0.5);\n            col = vec3(c);\n        }\n\t}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsByRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 64, 64, 145], [147, 147, 200, 200, 367], [369, 369, 420, 420, 574], [576, 576, 658, 658, 758], [805, 805, 862, 862, 1515]]}
{"id": "7sjcWw", "name": "Genuary 2022 - Day31", "author": "z0rg", "description": "My participation to genuary 2022\nNegative space.", "tags": ["generative", "genuary", "2022"], "likes": 8, "viewed": 221, "published": 3, "date": "1643895132", "time_retrieved": "2024-07-30T17:05:35.495394", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    rgb = texture(iChannel1, uv).xyz;\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW 1.8\n#define GLOW_OPACITY .2\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\nfloat _cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\nfloat sdf_zicon(vec2 uv)\n{\n  float th = 0.01*4.;\n  float sz = 0.1;\n  float acc = 1000.;\n\n  acc = abs(_cir(uv-vec2(.3), sz))-th;\n  acc = min(acc,abs(_cir(uv-vec2(-.3), sz))-th);\n  acc = min(acc,abs(_cir(uv-vec2(-.3,.3), sz*.7))-th);\n  acc = min(acc,abs(_cir(uv-vec2(.3,-.35), sz*1.3))-th);\n\n  acc = min(acc, _sqr(uv-vec2(-0.015,.3), vec2(.21,th)));\n  acc = min(acc, _sqr((uv-vec2(-0.0,.0))*r2d(-PI/4.), vec2(.32,th)));\n  acc = min(acc, _sqr((uv-vec2(-0.015,-.3))*r2d(0.1), vec2(.19,th)));\n\n    return acc;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec3 pz = p+vec3(0.,.5+sin(iTime),0.);\n    pz.yz *= r2d(PI*.25);\n    float z = sdf_zicon(pz.xy*.5);\n    float zinf = z;\n    z = max(z, abs(pz.z)-.2);\n    acc = _min(acc, vec2(z, 0.));\n\n    acc = _min(acc, vec2(max(-p.y, -zinf), 1.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 30.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(4.,-5.,-5.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        if (res.z == 0.)\n        {\n            col = vec3(1.);\n            vec3 refv = vec3(0.,1.,0.);\n            refv.yz *= r2d(PI*.25);\n            if (sat(abs(dot(n,refv))) < 0.1)\n                col = vec3(0.);\n        }\n        if (res.z == 1.)\n        {\n            col = vec3(0.141,0.557,1.000);\n            if (sat(abs(dot(n, vec3(0.,1.,0.)))) < 0.8)\n            {\n                vec3 lpos = vec3(0.,-5.,5.);\n                vec3 ldir = normalize(lpos-p);\n                \n                col = vec3(1.,0.,0.)*sat(dot(n,ldir));\n            }\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    //col = pow(col, vec3(.4545));\n    //col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .5);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjcWw.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1120]]}
{"id": "ss2cWm", "name": "Genuary 2022 - Day30", "author": "z0rg", "description": "My participation to genuary 2022\nOrganic looking output using only rectangular shapes.", "tags": ["generative", "organic", "molecule", "genuary", "2022"], "likes": 8, "viewed": 293, "published": 3, "date": "1643895020", "time_retrieved": "2024-07-30T17:05:36.247384", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat hexa_full(vec2 uv, float rad, float th)\n{\n    vec2 uv2 = uv;\n    float rep = PI*2.0/6.;\n    float an = atan(uv2.y,uv2.x);\n    float sectors = mod(an+rep*.5,rep)-rep*.5;\n    float id = floor((an+rep*.5)/rep);\n    uv2 = vec2(sin(sectors), cos(sectors))*length(uv);\n    if (mod(id, 2.) < 0.1)\n        return abs(uv2.y-rad)-th;\n    return 10.;\n}\n\nfloat hexa(vec2 uv, float rad, float th)\n{\n    vec2 uv2 = uv;\n    float rep = PI*2.0/6.;\n    float an = atan(uv2.y,uv2.x);\n    float sectors = mod(an+rep*.5,rep)-rep*.5;\n    uv2 = vec2(sin(sectors), cos(sectors))*length(uv);\n    \n    return abs(uv2.y-rad)-th;\n}\n\nvec3 palette(float f)\n{\n    vec3 cols[4];\n    \n    cols[0] = vec3(0.341,0.094,0.271);\n    cols[1] = vec3(0.565,0.047,0.243);\n    cols[2] = vec3(0.780,0.000,0.224);\n    cols[3] = vec3(1.000,0.341,0.200);\n    \n    return cols[int(min(f*4.,3.))];\n}\n\nvec3 rdr(vec2 uv)\n{\n    float shp = iResolution.x*.5;\n    vec3 col = palette(uv.x+.35);\n    float sides = 6.;\n    float h = .1;\n    float angle = PI/sides;\n    float len =  h*2.0*tan(PI/sides)*.5;\n    float th = 0.004;\n    \n    vec3 yellow = vec3(1.000,0.765,0.000);\n\n    col = mix(col, yellow, 1.-sat(_sqr((uv+vec2(len*2.55,-len*1.5))*r2d(angle), vec2(len, th))*shp));\n    \n    vec2 uv2 = uv;\n    float rep = PI*2.0/sides;\n    float an = atan(uv2.y,uv2.x);\n    float sectors = mod(an+rep*.5,rep)-rep*.5;\n    uv2 = vec2(sin(sectors), cos(sectors))*length(uv);\n    \n    \n    \n    float shape2 = hexa(uv, .1, th);\n    shape2 = min(shape2, hexa_full(uv, .08,th));\n    col = mix(col, yellow, 1.-sat(shape2*shp));\n    \n    uv += vec2(-len,0.)*3.5;\n    float shape3 = hexa(uv, .1, th);\n\n    shape3 = max(shape3, -uv.y+len);\n    col = mix(col, yellow, 1.-sat(shape3*shp));\n    \n    uv += vec2(-len,0.)*3.5;\n    float shape4 = hexa(uv, .1, th);\n    col = mix(col, yellow, 1.-sat(shape4*shp));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv-vec2(-.15,0.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2cWm.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[451, 451, 470, 470, 528], [529, 529, 558, 558, 610], [612, 612, 659, 659, 959], [961, 961, 1003, 1003, 1222], [1224, 1224, 1247, 1247, 1469], [1471, 1471, 1490, 1490, 2473], [2475, 2475, 2532, 2532, 2669]]}
{"id": "NdjcDD", "name": "Genuary 2022 - Day29", "author": "z0rg", "description": "My participation to genuary 2022\nIsometric perspective.", "tags": ["generative", "isometric", "perspective", "genuary", "2022"], "likes": 17, "viewed": 453, "published": 3, "date": "1643894868", "time_retrieved": "2024-07-30T17:05:36.994386", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .5\n#define GLOW_OPACITY .76*.5\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat hash11(float p)\n{\n    return mod(sin(p*123.456)*123.456,1.);\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l =abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x,max(l.y, l.z));\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n\n", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GROUND_MAT 0.\n#define GRASS_MAT 1.\n#define TRUNK_MAT 2.\n#define WALL_MAT 3.\n#define GLASS_MAT 4.\n#define BUSH_MAT 5.\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n\n    p.xz *= r2d(PI*.5+PI/2.5);\n    float ground = _cube(p, vec3(4.,.1,2.));\n    acc = _min(acc, vec2(ground, GROUND_MAT));\n    acc = _min(acc, vec2(p.y, GRASS_MAT));\n\n\n    vec3 pglass = p+vec3(0.,0.,.25);\n    float repg = .5;\n    float idGlass = floor((pglass.z+repg*.5)/repg);\n    pglass.z = mod(pglass.z+repg*.5,repg)-repg*.5;\n    float glasses = _sqr(pglass.zy-vec2(0.,.8), vec2(.2,.5));\n\n    float batmat = mix(WALL_MAT,GLASS_MAT*mix(1.,-1., float(mod(idGlass, 2.0) < 0.1)), 1.-sat(glasses*400.));\n\n    acc = _min(acc, vec2(_cube(p-vec3(-1.7,0.,0.), vec3(1.5,1.5,1.5)), batmat));\n    acc = _min(acc, vec2(_cube(p-vec3(0.,0.,0.), vec3(1.5,1.5,.5)), batmat));\n    \n    acc = _min(acc, vec2(_cube(p-vec3(5.,0.,0.), vec3(.1,1.,.04)), TRUNK_MAT));\n    acc = _min(acc, vec2(_cube(p-vec3(5.,1.5,0.), vec3(.1*3.,.5,.04*3.)), BUSH_MAT));\n    \n    acc = _min(acc, vec2(_cube(p-vec3(-5.,0.,1.), vec3(.1,1.,.04)), TRUNK_MAT));\n    acc = _min(acc, vec2(_cube(p-vec3(-5.,1.5,1.), vec3(.1*3.,.2,.04*3.)*2.), BUSH_MAT));\n    \n    acc = _min(acc, vec2(_cube(p-vec3(6.,0.,1.), vec3(.1,1.,.04)), TRUNK_MAT));\n    acc = _min(acc, vec2(_cube(p-vec3(6.,1.5,1.), vec3(.1*3.,.5,.04*3.)), BUSH_MAT));\n    //acc = _min(acc, vec2(glasses, GLASS_MAT));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 4.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\nreturn normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x*.125;\n    }\n    return vec3(-1.);\n}\n\nfloat getShadow(vec3 ro, vec3 lpos, int steps)\n{\n    float maxDist = distance(ro, lpos);\n    vec3 rd = -normalize(lpos-ro);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return 0.;\n        p+= rd*res.x*.125;\n    }\n    return float(distance(p, ro) > maxDist);\n}\nvec3 getEnv(vec3 rd)\n{\n    return texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*.5*vec3(0.941,1.000,1.000);//*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    float dl = 15.;\n    float tl = iTime*.125;\n    vec3 lpos = vec3(dl*sin(tl),-15.,dl*cos(tl))+1.*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir= p-lpos;\n    vec3 lcol = vec3(1.000,0.796,0.659);\n    vec3 h = normalize(rd+ldir);\n    vec3 ambient = vec3(0.);\n    float ndotl = sat(dot(n, normalize(ldir)));\n    vec3 albedo = vec3(.1,.1,.1);\n    vec3 spec = vec3(1.,0.,0.);\n    float gloss = 1.;\n    if (res.z == GROUND_MAT)\n    {\n        albedo = vec3(0.788,0.788,0.788);\n        ambient = vec3(.1);\n    }\n    if (res.z == GRASS_MAT)\n    {\n        albedo = vec3(0.576,0.690,0.431);\n    }\n    if (res.z == WALL_MAT)\n    {\n           albedo = vec3(1.);\n    }\n    if (abs(res.z) == GLASS_MAT)\n    {\n        albedo = vec3(0.373,0.365,0.714);\n        ambient = mix(vec3(0.), vec3(0.996,0.518,0.125), float(res.z < 0.))*4.0;\n    }\n    if (res.z == TRUNK_MAT)\n    {\n        albedo = vec3(0.545,0.329,0.224);\n    }\n    if (res.z == BUSH_MAT)\n    {\n        albedo = vec3(0.580,0.804,0.525);\n    }\n\n    \n    col = ambient;\n    if (getShadow(p+n*0.01,  lpos, 256) > 0.5)\n        col += albedo*pow(ndotl,1.)*1.2*lcol;\n\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    //uv.x *= -1.;\n    vec3 col = vec3(0.);\n\n    //uv *= r2d(.25);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.05*0.;\n    vec3 ro = vec3(-5.,3.,-5.)+dof;\n    vec3 ta = vec3(1.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    ro += +vec3(uv.x,uv.y,0.)*10.;\n    \n    //rd = getCam(rd, uv)-dof*0.0025;\n    vec3 res = trace(ro, rd, 4096*4, 300.);\n    float maxdist = 20.;\n    float dist = maxdist;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getMat(res, rd, p, n);\n        if (true)\n        {\n            \n            for (int i = 0; i < 2; ++i)\n            {\n                vec3 refl = normalize(reflect(rd, n));\n                float spec = 1.;\n                if (res.z == GLASS_MAT)\n                    spec = .1;\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), spec);\n            \n                if (dot(refl, n) < 0.01)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 2048, 15.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    col += getMat(resrefl, refl, prefl, nrefl);\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    col += getEnv(refl);\n                    break;\n                }\n                rd = refl;\n            }\n\n\n        }\n    col = mix(col, vec3(0.), sat(exp(-dist*.05-.1)));\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    uv += vec2(-.05,0.03);\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n\n    col = sat(col);\n    col = pow(col, vec3(.9));\n    \n    if (iFrame > 1)\n        col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col, .03);\n     \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjcDD.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1179]]}
{"id": "7sjczG", "name": "Genuary 2022 - Day28", "author": "z0rg", "description": "My participation to genuary 2022\nSelf portrait.", "tags": ["generative", "portrait", "genuary", "2022"], "likes": 6, "viewed": 405, "published": 3, "date": "1643894785", "time_retrieved": "2024-07-30T17:05:37.920909", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nvec2 _size = vec2(.01,.001);\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\nvec2 _uv;\nvec3 drawPixel(vec2 uv, vec3 col, vec3 prev)\n{\n    return mix(prev, col, 1.-sat(_sqr(uv, _size+vec2(0.,.01*(sin(iTime+_uv.x*15.+_uv.y*5.)*.5+.5)))*iResolution.x*.15));\n}\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    vec3 col = vec3(0.);\n    vec2 stp = vec2(.02)*iResolution.xx/iResolution.xy;\n    ouv = floor(ouv/stp)*stp;\n    col = texture(iChannel0, ouv).xyz;\n    \n    col = drawPixel(uv-vec2(-0.2,-0.2), vec3(0.007843138,0.007843138,0.01568628), col);\ncol = drawPixel(uv-vec2(-0.2,-0.15), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.2,-0.1), vec3(0,0,0.007843138), col);\ncol = drawPixel(uv-vec2(-0.2,-0.05), vec3(0.1568628,0.1568628,0.1490196), col);\ncol = drawPixel(uv-vec2(-0.2,0), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.2,0.05), vec3(0.1098039,0.2156863,0.2588235), col);\ncol = drawPixel(uv-vec2(-0.2,0.1), vec3(0.5607843,0.8470588,1), col);\ncol = drawPixel(uv-vec2(-0.2,0.15), vec3(1,0.9921569,1), col);\ncol = drawPixel(uv-vec2(-0.175,-0.2), vec3(0,0,0.01568628), col);\ncol = drawPixel(uv-vec2(-0.175,-0.15), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.175,-0.1), vec3(0,0,0.007843138), col);\ncol = drawPixel(uv-vec2(-0.175,-0.05), vec3(0.172549,0.1568628,0.1607843), col);\ncol = drawPixel(uv-vec2(-0.175,0), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.175,0.05), vec3(0.9803922,0.9843137,0.9921569), col);\ncol = drawPixel(uv-vec2(-0.175,0.1), vec3(1,0.9960784,1), col);\ncol = drawPixel(uv-vec2(-0.175,0.15), vec3(0.1411765,0.2,0.3607843), col);\ncol = drawPixel(uv-vec2(-0.15,-0.2), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.15,-0.15), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.15,-0.1), vec3(0,0.007843138,0.003921569), col);\ncol = drawPixel(uv-vec2(-0.15,-0.05), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.15,0), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.15,0.05), vec3(0.9294118,0.9411765,0.9058824), col);\ncol = drawPixel(uv-vec2(-0.15,0.1), vec3(0.7607843,0.8470588,0.8352941), col);\ncol = drawPixel(uv-vec2(-0.15,0.15), vec3(0,0.003921569,0.007843138), col);\ncol = drawPixel(uv-vec2(-0.125,-0.2), vec3(0.2901961,0.3960784,0.5137255), col);\ncol = drawPixel(uv-vec2(-0.125,-0.15), vec3(0.3529412,0.4078431,0.4431373), col);\ncol = drawPixel(uv-vec2(-0.125,-0.1), vec3(0.02352941,0.06666667,0.07450981), col);\ncol = drawPixel(uv-vec2(-0.125,-0.05), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.125,0), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.125,0.05), vec3(0.1960784,0.2588235,0.2588235), col);\ncol = drawPixel(uv-vec2(-0.125,0.1), vec3(0.05098039,0.05490196,0.07058824), col);\ncol = drawPixel(uv-vec2(-0.125,0.15), vec3(0.08235294,0.09411765,0.1215686), col);\ncol = drawPixel(uv-vec2(-0.1,-0.2), vec3(0.2313726,0.4078431,0.5294118), col);\ncol = drawPixel(uv-vec2(-0.1,-0.15), vec3(0.282353,0.3607843,0.4588235), col);\ncol = drawPixel(uv-vec2(-0.1,-0.1), vec3(0.6039216,0.4431373,0.08235294), col);\ncol = drawPixel(uv-vec2(-0.1,-0.05), vec3(0.1294118,0.1215686,0.1254902), col);\ncol = drawPixel(uv-vec2(-0.1,0), vec3(0.2627451,0.2509804,0.2235294), col);\ncol = drawPixel(uv-vec2(-0.1,0.05), vec3(0.5490196,0.5254902,0.4784314), col);\ncol = drawPixel(uv-vec2(-0.1,0.1), vec3(0.5764706,0.5607843,0.5137255), col);\ncol = drawPixel(uv-vec2(-0.1,0.15), vec3(0.7294118,0.7294118,0.7372549), col);\ncol = drawPixel(uv-vec2(-0.075,-0.2), vec3(0.08235294,0.1568628,0.2235294), col);\ncol = drawPixel(uv-vec2(-0.075,-0.15), vec3(0.3176471,0.4352941,0.5686275), col);\ncol = drawPixel(uv-vec2(-0.075,-0.1), vec3(0.6862745,0.6666667,0.6431373), col);\ncol = drawPixel(uv-vec2(-0.075,-0.05), vec3(0.6509804,0.5372549,0.3803922), col);\ncol = drawPixel(uv-vec2(-0.075,0), vec3(0.2627451,0.2509804,0.2156863), col);\ncol = drawPixel(uv-vec2(-0.075,0.05), vec3(0.6980392,0.6941177,0.6745098), col);\ncol = drawPixel(uv-vec2(-0.075,0.1), vec3(0.654902,0.6431373,0.6156863), col);\ncol = drawPixel(uv-vec2(-0.075,0.15), vec3(0.7058824,0.7019608,0.6941177), col);\ncol = drawPixel(uv-vec2(-0.05,-0.2), vec3(0.2509804,0.372549,0.4823529), col);\ncol = drawPixel(uv-vec2(-0.05,-0.15), vec3(0.1803922,0.2588235,0.3568628), col);\ncol = drawPixel(uv-vec2(-0.05,-0.1), vec3(0.1254902,0.2,0.2666667), col);\ncol = drawPixel(uv-vec2(-0.05,-0.05), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(-0.05,0), vec3(0.02352941,0.07450981,0.1098039), col);\ncol = drawPixel(uv-vec2(-0.05,0.05), vec3(0.9882353,0.9882353,0.9568627), col);\ncol = drawPixel(uv-vec2(-0.05,0.1), vec3(0.06666667,0.08627451,0.1098039), col);\ncol = drawPixel(uv-vec2(-0.05,0.15), vec3(0.6784314,0.6862745,0.6352941), col);\ncol = drawPixel(uv-vec2(-0.025,-0.2), vec3(0.01960784,0.09803922,0.227451), col);\ncol = drawPixel(uv-vec2(-0.025,-0.15), vec3(0,0,0.03921569), col);\ncol = drawPixel(uv-vec2(-0.025,-0.1), vec3(0,0.1333333,0.4627451), col);\ncol = drawPixel(uv-vec2(-0.025,-0.05), vec3(0.7490196,0.5058824,0.509804), col);\ncol = drawPixel(uv-vec2(-0.025,0), vec3(0.7843137,0.6313726,0.6117647), col);\ncol = drawPixel(uv-vec2(-0.025,0.05), vec3(0.7882353,0.5921569,0.5960785), col);\ncol = drawPixel(uv-vec2(-0.025,0.1), vec3(0.3490196,0.227451,0.1568628), col);\ncol = drawPixel(uv-vec2(-0.025,0.15), vec3(0.7490196,0.7568628,0.7137255), col);\ncol = drawPixel(uv-vec2(0,-0.2), vec3(0,0.003921569,0.05098039), col);\ncol = drawPixel(uv-vec2(0,-0.15), vec3(0.4941176,0.3647059,0.3921569), col);\ncol = drawPixel(uv-vec2(0,-0.1), vec3(0.7019608,0.4627451,0.4588235), col);\ncol = drawPixel(uv-vec2(0,-0.05), vec3(0.6941177,0.4,0.3882353), col);\ncol = drawPixel(uv-vec2(0,0), vec3(0.5411765,0.3215686,0.3333333), col);\ncol = drawPixel(uv-vec2(0,0.05), vec3(0.7882353,0.5568628,0.572549), col);\ncol = drawPixel(uv-vec2(0,0.1), vec3(0.2470588,0.1568628,0.1254902), col);\ncol = drawPixel(uv-vec2(0,0.15), vec3(0.003921569,0,0), col);\ncol = drawPixel(uv-vec2(0.025,-0.2), vec3(0.2352941,0.3176471,0.4235294), col);\ncol = drawPixel(uv-vec2(0.025,-0.15), vec3(0.1019608,0.1215686,0.1960784), col);\ncol = drawPixel(uv-vec2(0.025,-0.1), vec3(0.6901961,0.4313726,0.3843137), col);\ncol = drawPixel(uv-vec2(0.025,-0.05), vec3(0.4784314,0.2470588,0.2156863), col);\ncol = drawPixel(uv-vec2(0.025,0), vec3(0.5215687,0.3019608,0.3058824), col);\ncol = drawPixel(uv-vec2(0.025,0.05), vec3(0.8196079,0.5450981,0.5137255), col);\ncol = drawPixel(uv-vec2(0.025,0.1), vec3(0.3764706,0.2470588,0.172549), col);\ncol = drawPixel(uv-vec2(0.025,0.15), vec3(0.2941177,0.3098039,0.3137255), col);\ncol = drawPixel(uv-vec2(0.05,-0.2), vec3(0.1843137,0.2392157,0.2745098), col);\ncol = drawPixel(uv-vec2(0.05,-0.15), vec3(0.1254902,0.1411765,0.1764706), col);\ncol = drawPixel(uv-vec2(0.05,-0.1), vec3(0.01568628,0,0), col);\ncol = drawPixel(uv-vec2(0.05,-0.05), vec3(0.4901961,0.282353,0.2588235), col);\ncol = drawPixel(uv-vec2(0.05,0), vec3(0.5411765,0.2901961,0.282353), col);\ncol = drawPixel(uv-vec2(0.05,0.05), vec3(0.8941177,0.6666667,0.572549), col);\ncol = drawPixel(uv-vec2(0.05,0.1), vec3(0.5411765,0.372549,0.2392157), col);\ncol = drawPixel(uv-vec2(0.05,0.15), vec3(0.6862745,0.6392157,0.5843138), col);\ncol = drawPixel(uv-vec2(0.075,-0.2), vec3(0.3058824,0.3215686,0.3333333), col);\ncol = drawPixel(uv-vec2(0.075,-0.15), vec3(0.2941177,0.3921569,0.5137255), col);\ncol = drawPixel(uv-vec2(0.075,-0.1), vec3(0.7529412,0.7019608,0.6784314), col);\ncol = drawPixel(uv-vec2(0.075,-0.05), vec3(0.5490196,0.5803922,0.5921569), col);\ncol = drawPixel(uv-vec2(0.075,0), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(0.075,0.05), vec3(0.7529412,0.7490196,0.7686275), col);\ncol = drawPixel(uv-vec2(0.075,0.1), vec3(0.654902,0.6235294,0.5490196), col);\ncol = drawPixel(uv-vec2(0.075,0.15), vec3(0.6705883,0.6352941,0.5764706), col);\ncol = drawPixel(uv-vec2(0.1,-0.2), vec3(0.3176471,0.3137255,0.345098), col);\ncol = drawPixel(uv-vec2(0.1,-0.15), vec3(0.1960784,0.1921569,0.2156863), col);\ncol = drawPixel(uv-vec2(0.1,-0.1), vec3(0.003921569,0.01960784,0.06666667), col);\ncol = drawPixel(uv-vec2(0.1,-0.05), vec3(0.4745098,0.4705882,0.4901961), col);\ncol = drawPixel(uv-vec2(0.1,0), vec3(0.7019608,0.6588235,0.5333334), col);\ncol = drawPixel(uv-vec2(0.1,0.05), vec3(0.627451,0.5882353,0.4901961), col);\ncol = drawPixel(uv-vec2(0.1,0.1), vec3(0.6235294,0.5803922,0.509804), col);\ncol = drawPixel(uv-vec2(0.1,0.15), vec3(0.6627451,0.6156863,0.5529412), col);\ncol = drawPixel(uv-vec2(0.125,-0.2), vec3(0.2666667,0.2666667,0.2588235), col);\ncol = drawPixel(uv-vec2(0.125,-0.15), vec3(0.372549,0.4941176,0.6039216), col);\ncol = drawPixel(uv-vec2(0.125,-0.1), vec3(0.02352941,0,0), col);\ncol = drawPixel(uv-vec2(0.125,-0.05), vec3(1,1,0.9843137), col);\ncol = drawPixel(uv-vec2(0.125,0), vec3(0.7333333,0.654902,0.5254902), col);\ncol = drawPixel(uv-vec2(0.125,0.05), vec3(0.572549,0.5254902,0.4392157), col);\ncol = drawPixel(uv-vec2(0.125,0.1), vec3(0.5960785,0.5607843,0.4941176), col);\ncol = drawPixel(uv-vec2(0.125,0.15), vec3(0.6313726,0.5960785,0.5372549), col);\ncol = drawPixel(uv-vec2(0.15,-0.2), vec3(0.4235294,0.4941176,0.509804), col);\ncol = drawPixel(uv-vec2(0.15,-0.15), vec3(0.05490196,0.09803922,0.1215686), col);\ncol = drawPixel(uv-vec2(0.15,-0.1), vec3(0.8823529,0.8862745,0.9019608), col);\ncol = drawPixel(uv-vec2(0.15,-0.05), vec3(0.1607843,0.1529412,0.1647059), col);\ncol = drawPixel(uv-vec2(0.15,0), vec3(0.2392157,0.2235294,0.1803922), col);\ncol = drawPixel(uv-vec2(0.15,0.05), vec3(0.5294118,0.4862745,0.4156863), col);\ncol = drawPixel(uv-vec2(0.15,0.1), vec3(0.5529412,0.5215687,0.4705882), col);\ncol = drawPixel(uv-vec2(0.15,0.15), vec3(0.6078432,0.5686275,0.5215687), col);\ncol = drawPixel(uv-vec2(0.175,-0.2), vec3(0,0,0), col);\ncol = drawPixel(uv-vec2(0.175,-0.15), vec3(0.007843138,0,0.01176471), col);\ncol = drawPixel(uv-vec2(0.175,-0.1), vec3(0.172549,0.1647059,0.2470588), col);\ncol = drawPixel(uv-vec2(0.175,-0.05), vec3(0.5686275,0.6509804,0.6705883), col);\ncol = drawPixel(uv-vec2(0.175,0), vec3(0.1215686,0.1176471,0.1098039), col);\ncol = drawPixel(uv-vec2(0.175,0.05), vec3(0.0627451,0.04313726,0.05882353), col);\ncol = drawPixel(uv-vec2(0.175,0.1), vec3(0.5176471,0.4862745,0.4431373), col);\ncol = drawPixel(uv-vec2(0.175,0.15), vec3(0.5843138,0.5607843,0.5137255), col);\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    vec2 ouv = fragCoord/iResolution.xy;\n    _uv = uv;\n    vec3 col = rdr(uv-vec2(0.,.03), ouv);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .5\n#define GLOW_OPACITY .86\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjczG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1179]]}
{"id": "fs2cWD", "name": "Genuary 2022 - Day27", "author": "z0rg", "description": "My participation to genuary 2022\n#2E294E #541388 #F1E9DA #FFD400 #D90368", "tags": ["generative", "genuary", "2022"], "likes": 4, "viewed": 265, "published": 3, "date": "1643894324", "time_retrieved": "2024-07-30T17:05:38.678882", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW 1.2\n#define GLOW_OPACITY .6\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float mount = texture(iChannel0, p.xz*.01).x-.1-.05*sin(iTime+p.x+p.y);//*2.*(1.-sat(length(p.xz)-.5));\n    \n    for (int i = 0 ; i < 4; ++i)\n    {\n        vec3 pos = p+vec3(0.,-float(i)*.1,0.);\n        float cur = max(mount-0.1*float(i), abs(pos.y)-.2);\n        acc = _min(acc, vec2(cur, i));\n    }\n   //acc = _min(acc, vec2(length(p-vec3(1.5,0.,0.))-1., 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 15.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.125;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(46, 41, 78)/255.;\n    \n    float d = 5.;\n    float t = sin(iTime*0.1+1.57);\n    float move = sin(iTime*.125)*10.;\n    vec3 ro = vec3(sin(t)*d,-5.,cos(t)*d+move);\n    vec3 ta = vec3(0.,0.,move);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 lpos = vec3(-5.,-5.,5.);\n        vec3 ldir = normalize(lpos-p);\n        vec3 cols[4];\n        cols[0] = vec3(84, 19, 136)/255.;\n        cols[1] = vec3(241, 233, 218)/255.;\n        cols[2] = vec3(255, 212, 0)/255.;\n        cols[3] = vec3(\t217, 3, 104)/255.;\n        col = cols[int(res.z)]*sat(sat(dot(n,ldir))+.2);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    //col = pow(col, vec3(.4545));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .6);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2cWD.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1087]]}
{"id": "7djyWW", "name": "Genuary 2022 - Day26", "author": "z0rg", "description": "My participation to genuary 2022\nAirport carpet.", "tags": ["generative", "carpet", "airport", "genuary", "2022"], "likes": 6, "viewed": 225, "published": 3, "date": "1643894223", "time_retrieved": "2024-07-30T17:05:39.618371", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .5\n#define GLOW_OPACITY .6\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// Thanks IQ\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\n// Thanks IQ\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GROUND_MAT 0.\n#define GLASS_MAT 1.\n#define BAT2_MAT 2.\n#define WORD_THICHNESS .1\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\n\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x,max(l.y, l.z));\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec3 pglass = p;\n    vec2 acc = vec2(10000., -1.);\n    acc = _min(acc, vec2(max(-p.y,-p.x), 0.));\n    \n    acc = _min(acc, vec2(max(p.y+5., -p.x-.5), 0.));\n    \n    float reppillar = 5.;\n    \n    vec3 ppillar = p;\n    ppillar.xy *= r2d(.1);\n    ppillar.z = mod(ppillar.z+reppillar*.5,reppillar)-reppillar;\n    \n    acc = _min(acc, vec2(length(ppillar.xz)-.3, 0.));\n    \n    acc = _min(acc, vec2(max(-p.z+100.,-p.x), 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 4.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\nreturn normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        /*if (res.y == FLAME_MAT)\n        accLight += vec3(0.941,0.376,0.000)*(1.-sat(res.x/.05))*.05;*/\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nfloat getShadow(vec3 ro, vec3 lpos, int steps)\n{\n    float maxDist = distance(ro, lpos);\n    vec3 rd = -normalize(lpos-ro);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return 0.;\n        p+= rd*res.x;\n    }\n    return float(distance(p, ro) > maxDist);\n}\nvec3 getEnv(vec3 rd)\n{\n    return texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*.5*vec3(0.941,1.000,1.000)*1.7;//*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    vec3 lpos = vec3(0.,5.,-5.)+1.*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir= p-lpos;\n    vec3 lcol = vec3(1.000,0.796,0.659);\n    vec3 h = normalize(rd+ldir);\n    vec3 ambient = vec3(0.);\n    float ndotl = sat(dot(n, normalize(ldir)));\n    vec3 albedo = vec3(.1,.1,.1);\n    vec3 spec = vec3(1.,0.,0.);\n    float gloss = 1.;\n    if (res.z == GROUND_MAT)\n    {\n        albedo = texture(iChannel3, p.xz*.2*vec2(1.,3.)).xyz;\n//        ambient = mix(ambient, vec3(1.000,0.298,0.220), sat((sin(length(p.xz)*20.)-.95)*400.));\n    }\n    if (abs(res.z) == BAT2_MAT)\n    {\n        ambient = vec3(1.000,0.298,0.220);\n        if (res.z > 0.)\n            ambient = ambient.zyx;\n    }\n    \n    col = ambient;\n    if (getShadow(p+n*0.01,  lpos, 256) > 0.5)\n        col += albedo*pow(ndotl,1.)*2.*lcol;\n/*    if (res.z == FLAME_MAT)\n    {\n        col = 2.*mix(vec3(1.000,0.749,0.322), vec3(1.,1.,1.), sat(-dot(rd, n)));\n    }*/\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n\n    vec3 col = vec3(0.);\n    float xpos = sin(iTime*0.+.5)*2.2;\n    float offy = -.85;\n    float zoff = 5.9;\n    //uv *= r2d(.25);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.05*0.;\n    vec3 ro = vec3(4.,-1.,-5.)+dof;\n    vec3 ta = vec3(3.,2.,-2.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.0025;\n    vec3 res = trace(ro, rd, 4096, 500.);\n    float maxdist = 20.;\n    float dist = maxdist;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getMat(res, rd, p, n);\n        col += accLight;\n        if (true)\n        {\n            \n            for (int i = 0; i < 2; ++i)\n            {\n                vec3 refl = normalize(reflect(rd, n));\n                float spec = 1.;\n                if (res.z == GLASS_MAT)\n                    spec = .1;\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), spec);\n            \n                if (dot(refl, n) < 0.01)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 2048, 15.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    col += getMat(resrefl, refl, prefl, nrefl);\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    col += getEnv(refl);\n                    break;\n                }\n                col += accLight;\n                rd = refl;\n            }\n\n\n        }\n    col = mix(col, vec3(0.), sat(exp(-dist*.05-.1)));\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n\n    col = sat(col);\n    col = pow(col, vec3(.9));\n    \n    if (iFrame > 1)\n        col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col,  .05);\n    ;//col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col,  1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\nfloat sqr(vec2 p, vec2 b)\n{\n    vec2 q = abs(p)-b;\n    return max(q.x, q.y);\n}\n\nfloat loz(vec2 p, float sz)\n{\n    return lenny(p)-sz;\n}\nfloat cir(vec2 p, float sz)\n{\n    return length(p)-sz;\n}\n\nvec3 artDeco(vec2 uv)\n{\n    vec3 col;\n    vec3 yell = vec3(245, 209, 66)/255.;\n    vec3 green = .7*vec3(33, 181, 156)/255.;\n    col = vec3(0.15);\n    //col = mix(green, yell, sat((sin(uv.x*155.)-.5)*400.));\n    \n    float rep = 0.1;\n\t\n    float anim = mix(0.,.005, 0.*sin(iTime+(uv.x+uv.y)*5.)*.5+.5);\n    uv-=vec2(anim);\n    for (int i = 0; i < 20; ++i)\n    {\n        vec2 p = uv;\n        if (mod(float(i), 2.0) < 0.01)\n            p.x += .05;\n\n        p.y -= .5;\n    \tp.x = mod(p.x+.5*rep,rep)-.5*rep;\n        p.y += 0.05*(float(i));\n        \n\n    \tfloat shape = cir(p, 0.048);\n    \tfloat patt = sin(length(p)*555.)-.5;\n    \tvec3 rgb = mix(green, yell, sat(patt*2.));\n    \tcol = mix(col, rgb*sat(p.y*15.+.7), 1.-sat(shape*400.));\n    }\n\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float shp = iResolution.x*.5;\n    vec3 col = artDeco(uv);\n\n    return col;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\tuv *= 1.5;\n    vec3 col = rdr(uv)*2.;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djyWW.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1023]]}
{"id": "fdlyWM", "name": "Genuary 2022 - Day25", "author": "z0rg", "description": "My participation to genuary 2022\nPerspective\nHeavily \"inspired\" by https://www.instagram.com/p/CY2MyN-PAlW/ go follow him !", "tags": ["generative", "perspective", "genuary", "2022"], "likes": 20, "viewed": 436, "published": 3, "date": "1643894032", "time_retrieved": "2024-07-30T17:05:40.374349", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW 1.2\n#define GLOW_OPACITY .76\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define OUTER_BOX 0.\n#define BOX 1.\n#define MAP 2.\n#define DOTS 3.\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float th = 0.007;\n    float box = _cucube(p, vec3(1.), vec3(th));\n    acc = _min(acc, vec2(box, BOX));\n    \n    float outerbox = _cucube(p, vec3(1.2), vec3(th));\n    float outerboxrad = .8;\n    outerbox = max(outerbox, -(abs(p.x)-outerboxrad));\n    outerbox = max(outerbox, -(abs(p.y)-outerboxrad));\n    outerbox = max(outerbox, -(abs(p.z)-outerboxrad));\n    acc = _min(acc, vec2(outerbox, OUTER_BOX));\n    \n    vec3 pbox2 = p;\n    float outerbox2 = _cucube(pbox2, vec3(1.8), vec3(th*2.));\n    vec3 rep2 = vec3(.2);\n    pbox2 = mod(pbox2+rep2*.5,rep2)-rep2*.5;\n    outerbox2 = max(outerbox2, _cube(pbox2, vec3(.07)));\n    acc = _min(acc, vec2(outerbox2, DOTS));\n    \n    float map = p.y-texture(iChannel2, p.xz*.01).x*2.;\n    float borderboxmap = max(abs(map)-th, abs(_cube(p, vec3(1.)))-th*2.);\n    acc = _min(acc, vec2(borderboxmap, BOX));\n    \n    vec3 pcube = p;\n    vec2 repcube = vec2(.2);\n    pcube.xz = mod(pcube.xz+.5*repcube, repcube)-repcube*.5;\n    map = max(abs(map-.2)-th, -_cube(pcube, vec2(.1, 5.).xyx));\n    map = max(map, _cube(p, vec3(1.)));\n    acc = _min(acc, vec2(map, MAP));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 10.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.110,0.035,0.114);\n    \n    float d = 7.;\n    float t = iTime *.25;\n    vec3 ro = vec3(sin(t)*d,-4.,cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        if (res.z == OUTER_BOX)\n        {\n            col = vec3(0.322,0.686,0.271);\n        }\n        if (res.z == BOX)\n        {\n            col = mix(vec3(0.663,0.157,0.204), vec3(0.741,0.435,0.314), 1.-sat(abs(uv.y*4.)));\n        }\n        if (res.z == MAP)\n        {\n            col = mix(vec3(0.714,0.361,1.000), vec3(0.169,0.059,1.000), 1.-sat(length(p*1.5)));\n        }\n        if (res.z == DOTS)\n        {\n            col = vec3(0.220,0.271,1.000);\n        }\n    }\n    \n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    //col = pow(col, vec3(.4545));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .7);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlyWM.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1026]]}
{"id": "7s2yDh", "name": "Genuary 2022 - Day24", "author": "z0rg", "description": "My participation to genuary 2022\nCreate your own pseudo-random number generator and visually check the results.", "tags": ["random", "generative", "genuary", "2022"], "likes": 4, "viewed": 239, "published": 3, "date": "1643890625", "time_retrieved": "2024-07-30T17:05:41.130328", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec3 rep = vec3(7.);\n    float cl = 2.5;\n    p = clamp(p, -rep*cl, rep*cl);\n    vec3 id = floor((p+rep*.5)/rep);\n    p = mod(p+rep*.5,rep)-rep*.5;\n    p.xy *= r2d(id.x+iTime*.5*sin(id.y));\n    p.xz *= r2d(id.y+iTime*.5*sin(id.y));\n    acc = _min(acc, vec2(_cucube(p, vec3(1.), vec3(.1)), 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.000,0.569,1.000)*(1.-sat(length(uv)));\n    \n    vec3 dof = normalize(vec3(rand()-.5, rand()-.5, 0.))*.1*mix(0.1,0.9, sat(sin(iTime)*.5+.5));\n    vec3 ro = vec3(3.,-5.,-4.)+dof;\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.1;\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 lpos = vec3(5.,-5.,5.);\n        vec3 ldir = normalize(lpos-p);\n        float ndotl = dot(ldir, n);\n        col = vec3(0.996,0.675,0.125)*sat(ndotl)+vec3(0.996,0.690,0.165);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec3 col = rdr(uv);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456)*123.456, 1.);\n}\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2yDh.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 570]]}
{"id": "ss2cz3", "name": "Neo three worlds", "author": "neozhaoliang", "description": "Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.", "tags": ["3d", "escher", "geometry", "tiling", "polyhedra", "hyperbolic", "wythoff"], "likes": 22, "viewed": 593, "published": 3, "date": "1643890479", "time_retrieved": "2024-07-30T17:05:42.065827", "image_code": "vec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 2.;\n    const float Q = 3.;\n    const float R = 7.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1)),\n    Light(vec3(-2.5,-1.9,-2.5), vec3(0, .3, 1))\n);\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}", "image_inputs": [], "common_code": "#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2cz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 73, 2604], [2606, 2606, 2635, 2635, 4747], [4749, 4791, 4815, 4815, 4881], [4883, 4909, 4932, 4932, 4968], [4970, 4988, 5015, 5015, 5074], [5076, 5076, 5105, 5105, 5327], [5329, 5363, 5389, 5389, 5606], [5608, 5608, 5631, 5631, 5836], [5838, 5838, 5869, 5869, 6076], [6078, 6078, 6116, 6116, 6679], [6681, 6681, 6706, 6706, 6925], [7138, 7138, 7331, 7331, 9594], [9596, 9596, 9634, 9634, 10090], [10092, 10092, 10144, 10144, 10319], [10321, 10321, 10378, 10378, 11148]]}
{"id": "NdjyWW", "name": "Genuary 2022 - Day23", "author": "z0rg", "description": "My participation to genuary 2022\nAbstract vegetation.", "tags": ["abstract", "generative", "vegetation", "genuary", "2022"], "likes": 6, "viewed": 186, "published": 3, "date": "1643890395", "time_retrieved": "2024-07-30T17:05:42.807843", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456)*123.456, 1.);\n}\n\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec3 rdrtrunk(vec2 uv)\n{\n    vec3 col = vec3(.75);\n    \n    col = mix(col, vec3(.7), 1.-pow(sat(length((uv-vec2(0.,-.1))*3.)),.5));\n    float shp = iResolution.x*.5;\n    float th = .01;\n    float trunk = udSegment(uv, vec2(0.,-.1), vec2(0.,.1))-th;\n    trunk = min(trunk, udSegment(uv, vec2(0.,-0.03), vec2(.1,.07)*.5)-th*.7);\n    trunk = min(trunk, udSegment(uv, vec2(0.,0.02), vec2(-.1,.1+0.07)*.5)-th*.7);\n    vec3 trunkcol = mix(vec3(0.094,0.549,0.122), vec3(0.745,1.000,0.361), 1.-sat(-uv.y*7.+.5))*.7;\n    col = mix(col, trunkcol, 1.-sat(trunk*shp));\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec2 ouv = uv;\n    float shp = iResolution.x*.5;\n    vec3 col = rdrtrunk(uv);\n    uv -= vec2(0.,.05);\n    uv.x /= sat(uv.y)+.9;\n    float leave = length(uv)-.1;\n    \n    vec2 off = (vec2(rand(), rand())-.5)*.02;\n    vec3 rgbleave = rdrtrunk(ouv+off);\n    vec3 leavecol = mix(vec3(0.765,1.000,0.639), vec3(0.357,0.851,0.349), 1.-sat(ouv.y*5.));\n\n    col = mix(col, rgbleave*.6+leavecol*.6, 1.-sat(leave*shp));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel1, uv).x;\n    vec3 col = rdr(uv);\n    if (iFrame > 1)\n        col = mix(col, texture(iChannel0, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyWW.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 572]]}
{"id": "ssjyzh", "name": "Genuary 2022 - Day22", "author": "z0rg", "description": "My participation to genuary 2022\nMake something that will look completely different in a year.\nHeavily inspired by https://twitter.com/sergeposters", "tags": ["generative", "genuary", "2022"], "likes": 15, "viewed": 267, "published": 3, "date": "1643889812", "time_retrieved": "2024-07-30T17:05:43.635630", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.2;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define BAT_MAT 1.\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float building = max(p.z, -_sqr(p.xy, vec2(3., .8)));\n    acc = _min(acc, vec2(building, 0.));\n    \n    vec3 pfins = p-vec3(0.,0.,-.2);\n    float repfins = 1.55;\n    pfins.x = mod(pfins.x+repfins*.5, repfins)-repfins*.5;\n    float fins = _cube(pfins, vec3(.01,1.,.2));\n    acc = _min(acc, vec2(fins, 0.));\n\n\n    // Outside\n    acc = _min(acc, vec2(-p.z+1., BAT_MAT));\n    //acc = _min(acc, vec2(length(p)-1., 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.25;\n    }\n    return vec3(-1.);\n}\nvec3 gradient(float f)\n{\n    vec3 cols[3];\n    \n    cols[0] = vec3(0.169,0.086,0.816);\n    cols[1] = vec3(0.835,0.216,0.843);\n    cols[2] = vec3(1.,1.,1.);\n    \n    float cnt = 2.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\nvec3 gradient2(float f)\n{\n    vec3 cols[4];\n    \n    cols[0] = vec3(0.008,0.004,0.008);\n    cols[1] = vec3(0.973,0.008,0.027);\n    cols[2] = vec3(0.980,0.780,0.200);\n    cols[3] = vec3(0.973,0.965,0.961);\n    \n    float cnt = 3.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\nvec3 getEnv(vec3 rd)\n{\n    vec2 uv = vec2(atan(rd.z, rd.x), acos(rd.y));\n    float stars = 2.5*pow(texture(iChannel0, uv*5.5).x, 5.)*sat(1.+sin(uv.y*5.2+uv.x*10.));\n    vec3 grad = mix(\n    vec3(0.067,0.086,0.125), \n    vec3(0.145,0.349,0.635), \n    pow(sat(sin((uv.x+uv.y)*10.)*.5+.5), .5));\n    \n    grad += .5*mix(\n    vec3(0.110,0.149,0.122), \n    vec3(0.286,0.592,0.459), \n    pow(sat(sin((uv.x+uv.y)*5.)*.5+.5), .5))*.5*sat((uv.y-1.)*2.);\n    \n    //grad+= gradient(sat((-uv.y+1.6)*7.))*.3;\n    \n    grad += vec3(1.000,0.482,0.141)*(1.-sat(abs((uv.y-1.44+0.02*sin(uv.x+iTime*.25))*7.)));\n    return stars*vec3(1.)+grad*sat(sat((-uv.y+1.8)*5.)+.2);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    col = vec3(.01);\n    if (res.z == BAT_MAT)\n    {\n        //float bats = sat(_sqr(p.xy-vec2(0.,-1.5), vec2(2.))*100.);\n        vec3 red = vec3(0.969,0.012,0.012);\n        vec3 bats = vec3(0.);\n        float mask = 10000.;\n        p.x += -iTime*.05;\n        p.x += iDate.x*100.+iDate.z;\n        //p.x += float(int(iTime*.5));\n        vec2 pa = p.xy-vec2(0.,.5);\n        float repa = 1.3;\n        float ida = floor((pa.x+repa*.5)/repa); \n        pa += vec2(.1*sin(ida*11.),.2*sin(ida*15.));\n        pa.x = mod(pa.x+repa*.5,repa)-repa*.5;\n        \n        float batA = _sqr(pa, vec2(.4+.2*sin(ida*2.),1.5)*.5);\n        bats = mix(bats, 2.*gradient2(sat(pa.y*1.+.25)), (1.-sat(batA*400.)));\n        mask = min(mask, batA);\n        \n        vec2 pb = p.xy-vec2(0.4,.5);\n        float repb = .7;\n        float idb = floor((pb.x+repb*.5)/repa); \n        pb += vec2(.2*sin(idb*11.),.2*sin(idb*15.));\n        pb.x = mod(pb.x+repb*.5,repb)-repb*.5;\n        \n        float batB = _sqr(pb, vec2(.4+.1*sin(idb*2.),2.5)*.5);\n        batB = max(batB, _sqr(pb*r2d(.5*idb), vec2(1.,.6)));\n        vec3 colB = gradient2(sat(pb.y*.75+.5));\n        colB = mix(colB.yzx, colB.yyz, sat(sin(idb*100.)*10.));\n\n        bats = mix(bats, sat((sin(pb.x*20.)+.5)*100.)*2.*colB, (1.-sat(batB*400.)));\n        mask = min(mask, batB);\n        \n        if (mask > 0.)\n            col = getEnv(rd)*sat(rd.y*5.+1.5);\n        else\n            col = bats;\n    }\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n        vec3 dof = (vec3(rand(), rand(), rand())-.5)*.05;\n    vec3 ro = vec3(0.,0.,-7.)+dof;\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.005;\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        if (p.y > -.78 && res.z != BAT_MAT)\n        {\n            vec3 refl = normalize(reflect(rd, n)+(vec3(rand(), rand(), rand())-.5)*.5*vec3(.05,1.,0.05));\n            vec3 resrefl = trace(p+n*0.01,refl, 128);\n            if (resrefl.y > 0.)\n            {\n                vec3 prefl = p+refl*resrefl.y;\n                vec3 nrefl = getNorm(prefl, resrefl.x);\n                \n                col += getMat(resrefl, refl, prefl, nrefl)*2.;\n            }\n            else\n                col += getEnv(refl)*.125;\n        }\n    }\n    else\n        col = getEnv(rd);\n    col += .1*rand();\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed = texture(iChannel0, uv).x+iTime;\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75);\n    vec3 col = rdr(uv+off);\n    col += vec3(0.302,0.102,0.129)*(1.-sat(length(uv)+rand()));\n    col += vec3(0.102,0.302,0.224)*(1.-sat(length(uv)-.5+rand()))*.1;\n    col *= vec3(0.784,0.976,0.859);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .95);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjyzh.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 570]]}
{"id": "fsjyR3", "name": "Lover", "author": "wyatt", "description": "A paper heart for my Valentine", "tags": ["paper"], "likes": 155, "viewed": 7066, "published": 3, "date": "1643856129", "time_retrieved": "2024-07-30T17:05:44.380638", "image_code": "Main \n    vec4 b = B(U);\n    Q = max(sin(.5+b.x/R.x+vec4(1,2,3,4)),0.);\n    vec4 C = vec4(.8)+.3*grad(U).x;\n    float q = 0.;\n    vec2 v = 4.*(U-.5*R)/R.y+vec2(0,2);\n    q += B(U+v).z;\n    q += B(U+2.*v).z;\n    q += B(U+3.*v).z;\n    q += B(U+4.*v).z;\n    q += B(U+5.*v).z;\n    Q *= 1.+.1*dFdy(q);\n    Q = mix(C,Q,min(q,1.));\n    float w = 1e9;\n    for (float i = 1.; i < 30.; i++) {\n        float s = B(U+i*vec2(0,3)).z;\n        if (s>0.) {\n            w = i;\n            break;\n        }\n    }\n    Q -= exp(-.3*(w))*(1.-min(q,1.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n", "buffer_a_code": "Main \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    for (float j = -20.; j <= 20.; j++) \n    if (j!=0. && j+i>=0. && j+i<R.x*R.y) {\n        vec4 a = A(_21(i+j));\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n    }\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f -= 100.*d.w*u;\n    }\n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw += f-.03*Q.zw;\n    Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n    Q.zw = mix(Q.zw,m.zw,0.1);\n    Q.xy = mix(Q.xy,m.xy,0.01);\n    if (Q.x>R.x)Q.y=.5*R.y,Q.z=-10.;\n    if (Q.x<0.)Q.y=.5*R.y,Q.z=10.;\n    \n    if (iFrame < 1) {\n        Q = vec4(0,.5*R.y,0,0);\n        \n        Q.x = i-.5*R.x*R.y;\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-7.));\n    XY(U,Q,vec4(Q.x+7.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    vec4 a3 = A(_21(Q.x-1.));\n    float l1 = sg(U,a1.xy,a2.xy);\n    float l2 = sg(U,a1.xy,a3.xy);\n    float l = min(l1,l2);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    Q = mix(Q,D(U),.5);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ssXyRl", "name": "Fork Video Gas rogo1965 325", "author": "rogo1965", "description": "This is cooler than the chain tbh", "tags": ["particles", "aabb", "sort"], "likes": 7, "viewed": 71, "published": 3, "date": "1643828893", "time_retrieved": "2024-07-30T17:05:45.213411", "image_code": "// Fork of \"Connected particle chain image\" by michael0884. https://shadertoy.com/view/3dXfDN\n// 2020-04-30 15:21:35\n\n// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// 2020-04-30 07:24:31\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec3 imageC(vec2 p)\n{\n    return texture(ch3, vec2(1., 1.)*p/size).xyz;\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(p, getParticle(id).xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n     N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    fragColor = vec4(0.,0,0,1);\n    for(int i = 0; i < 4; i++)\n    {\n       vec4 p0 = getParticle(nb[i]);\n    \tfragColor.xyz += 0.3*(0.85+0.25*imageC(p0.xy))\n            \t\t\t//*sin(vec3(1,2,3)*length(p0.zw))\n            \t\t\t*exp(-0.15*distance(p0.xy, pos));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 0.4\n#define prop 0.5\n\nivec2 N;\nint tot_n;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return (0.15*exp(-0.1*d) - 2.*exp(-0.2*d));\n}\n\nfloat imageV(vec2 p)\n{\n    return 1.-2.*texture(ch2, vec2(1., 1.)*p/size).x;\n}\n\nvec2 imageF(vec2 p)\n{\n    vec3 d = vec3(-1,0,1);\n    return vec2(imageV(p+d.zy) - imageV(p+d.xy), imageV(p+d.yz) - imageV(p+d.yx));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    float d= distance(p0.xy, p1.xy);\n    vec2 dv = (p1.zw - p0.zw);\n    float dotv = dot(normalize(p1.xy-p0.xy), normalize(dv)); //divergence correction\n    vec2 antidivergence = 0.*dv*abs(dotv)*exp(-0.5*d);\n    vec2 viscosity = 0.25*dv*exp(-0.1*d);\n    vec2 pressure = normalize(p1.xy-p0.xy)*F(d);\n    return viscosity + pressure + antidivergence;\n}\n\nfloat irad;\n\nvec2 Fspring(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 interaction = normalize(p1.xy-p0.xy)*(distance(p1.xy,p0.xy)- 2.*PI*irad/float(tot_n) - 4.*tanh(0.1*iTime));\n    return interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    if(p.x < N.x && p.y < N.y)\n    {\n        irad = 0.3*size.y;\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            float t = 2.*PI*float(id)/float(tot_n);\n            U.xy = size*hash22(3.14159*pos);\n\t\t\tU.zw = 1.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) +\n            \t -20.*imageF(U.xy);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw = 15.*tanh((F*dt + U.zw)/15.) ;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n     \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(p, getParticle(id).xy);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n     N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 p )\n{\n    fragColor = texture(ch0, p/size);\n}", "buffer_d_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 246, 246, 290], [292, 292, 312, 312, 363], [365, 365, 391, 391, 426], [428, 428, 449, 449, 501], [503, 503, 543, 543, 589], [591, 591, 642, 642, 1031]]}
{"id": "NsSyR3", "name": "Bubble Tower", "author": "SnoopethDuckDuck", "description": "click to move\n\nno idea how tihs works + dont look down (its buggy)", "tags": ["raymarching", "refraction", "glass", "diamond", "gem", "artofcode"], "likes": 8, "viewed": 267, "published": 3, "date": "1643828866", "time_retrieved": "2024-07-30T17:05:45.963406", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define pi 3.14159\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float r1 = 0.75;\n    float r2 = 0.45;\n    float a = atan(p.x, p.z);\n   // p.xz += 0.5 * cos(a + iTime);\n    float d1 = length(p.xz) - r1;\n  \n    vec2 uv = vec2(d1, p.y);\n    float av = atan(uv.x, uv.y);\n    float rv = length(uv); // <----- change back to length(uv)\n    //uv = vec2(2. * av, rv;\n    float thing = 1.5 * av + 3.5 * p.y;\n    //rv = mix(rv, log(2.8 * rv), 0.5 + 0.5 * thc(3.,iTime));\n    rv = rv * (1.2 + 0.2 * cos(20. * rv));\n    rv = mix(rv, uv.x, 0.5 + 0.5 * thc(3.,0.5 * iTime));\n    uv = rv * vec2(cos(thing), sin(thing));\n    \n    uv *= Rot(a - iTime);\n    uv.y = abs(uv.y) - 0.3;\n    //uv.y += 0.1 * cos(a + iTime);\n    //uv.y += 0.1 * cos(2. * a + iTime);\n    float d2 = length(uv) - r2;\n    \n    return 0.3 * d2; //0.3\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float time = 0. * iTime;\n    vec3 ro = vec3(0, 0. + time, 2.5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,time,0), 0.8);\n    \n    vec3 col = texture(iChannel0, rd).rgb; //vec3(0.03);//\n    \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.;//mix(0., 1.5, 0.5 + 0.5 * thc(5., 0.6 * iTime)); // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n             \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*30.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        IOR = -1.; // <-- remove this to make it work like normal\n        rdOut = -refract(rdIn, nExit, IOR);\n       \n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex = texture(iChannel0, rdOut).rgb;\n        \n        vec3 pExit2 = pExit - nExit*SURF_DIST*3.;\n        float dExit = RayMarch(pExit2, rdOut, 1.);\n        if (dExit < MAX_DIST) {\n           vec3 pL = pExit2 + rdOut * dExit;\n           vec3 nL = GetNormal(pL);\n           float dif = dot(nL, normalize(vec3(1,2,3)))*.5+.5;\n           //dif = 1.;//clamp(dif, 0., 1.);\n           //dif = smoothstep(0., 1., dif);\n           //dif = pow(4. * dif * (1.-dif), 2.);\n           //col = vec3(dif);\n          // float fresnel = pow(1.+dot(rdOut, nL), 3.);\n           //col *= clamp(fresnel, 0., 1.);\n           //col *= (0.5 + 0.5 * nL);\n           vec3 e = vec3(0.9);\n           col = pal(0.08 * dif + 0.5 + 0.15 * pL.y + 0.1 * nL.y, e, e, e, 0.7 * vec3(0.,0.33,0.66));\n         \n           //col *= 1. + 0.5 * thc(4., 12. * length(p) - iTime);\n           col = mix(col, texture(iChannel0, rdOut).rgb, 0.28);\n        }\n\n        float fresnel = pow(1.+dot(rd, n), 2.);\n        col = mix(col, vec3(fresnel),clamp( 1.5-length(p),0.,1.));\n        fresnel = pow(fresnel, 3.);\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        col = mix(col, 0.45/refOutside, fresnel);\n       \n        \n\n    }\n    //col *= 2.;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 137, 137, 199], [201, 201, 230, 230, 311], [314, 314, 337, 337, 1084], [1086, 1086, 1132, 1132, 1348], [1350, 1350, 1374, 1374, 1564], [1566, 1566, 1616, 1616, 1807], [1809, 1809, 1866, 1866, 4450]]}
{"id": "7d2czV", "name": "Fork Fork Cosmi NikolaErce 832", "author": "NikolaErceg", "description": "Another experiment based on book of shaders code. Best in fullscreen.", "tags": ["triangles", "lines", "blue", "silver", "geometry", "energy"], "likes": 6, "viewed": 457, "published": 3, "date": "1643822869", "time_retrieved": "2024-07-30T17:05:46.730355", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define time iTime\n#define resolution iResolution.xy\n#define size 0.0070840525\n#define lineSize 0.09540144\n#define blur 0.00\n#define grid 21.0\n#define morph 7.0\n#define delayAmount 3.223359\n#define delay2 1.429779\n#define speed 0.39144516\n\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat plot(float dis){\n   float pct = smoothstep(dis,dis+blur,0.5)-smoothstep(lineSize+dis,lineSize+dis+blur,0.5);     \n  return   pct ;\n}\n\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 res = vec2(0);\n    res.x = resolution.x*0.5625;\n    res.y = resolution.y;\n    \n   vec2 st = gl_FragCoord.xy/res;\n st.x -= 0.35;\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  \n  // Number of sides of your shape\n  int N = 3;\n\n  // Angle and radius from the current pixel\n  vec3 colorNew = vec3(0);\n  \n  for(int i=0;i<5;i++) {\n      \n      float m = (float(i)/5.);\n      st.y += size*m*sin(time/3.);\n      float a = atan(st.x,st.y)+PI+(morph*m) + (0.03*m * sin(time));\n      float r = TWO_PI/float(N);\n      \n      d = cos(floor(.5+a/r)*r-a )*length(st);\n      d = impulse(d,delayAmount);\n      vec3 color = vec3(0.0);\n      float check = delay2 * (1.-length(st));\n      color.r = plot(fract(d*grid - check + time*speed));\n      color.g = plot(fract(d*grid - check + time*speed*0.8));\n      color.b = plot(fract(d*grid - check + time*speed*0.6));\n      colorNew+= ( color*m );\n    }\n    \n    \n \n   vec3 hue = rgb2hsb(colorNew);\n    hue.x = 0.6;\n    hue.y = 0.5;\n    hue.y = 0.5;\n    fragColor = vec4( hsb2rgb(hue)-colorNew*0.2 ,1.);\n\n  \n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2czV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 330, 330, 376], [378, 378, 400, 400, 516], [519, 519, 545, 545, 975], [977, 1051, 1077, 1077, 1309]]}
{"id": "7sjczK", "name": "Fractal Refracty Thing", "author": "SnoopethDuckDuck", "description": "click to move\n\nidea was to refract through object -> hit other stuff in scene -> return color\nso I think shows refracted version of the \"holes\" within the object\n\nvery messy code", "tags": ["raymarching", "refraction", "glass", "diamond", "gem", "artofcode"], "likes": 22, "viewed": 427, "published": 3, "date": "1643817192", "time_retrieved": "2024-07-30T17:05:47.472371", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define pi 3.14159\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    vec3 op = p;\n    vec3 n = normalize(vec3(cos(iTime), 1, sin(iTime)));\n    //p += p.y;\n    float m = 0.2;\n    float time = 0.5 * iTime;\n   // p *= 0.7;\n    \n    for (float i = 0.; i < 2.; i++) {\n        time += 0.25 * p.y + -0.25 * iTime + pi/4.;\n       // p = sabs(1.15 * p) - m;\n        p = sabs(p) - m;\n        p.xy *= Rot(time + pi/3.);\n        p.zy *= Rot(time);\n        m *= 0.9;\n    }\n    \n    p.xz *= Rot(iTime*.1);\n    \n    float d = sdBox(p, vec3(0.05)) - 0.05;\n    //float d = length(p) - 0.08;\n    return 1. * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3)*.7;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 2.3);\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.15;//mix(0., 1.5, 0.5 + 0.5 * thc(5., 0.6 * iTime)); // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n             \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*30.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        IOR = -1.; // <-- remove this to make it work like normal\n        rdOut = refract(rdIn, nExit, IOR);\n       \n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex = texture(iChannel0, rdOut).rgb;\n        \n        vec3 pExit2 = pExit - nExit*SURF_DIST*3.;\n        float dExit = RayMarch(pExit2, rdOut, 1.);\n        if (dExit < MAX_DIST) {\n           vec3 pL = pExit2 + rdOut * dExit;\n           vec3 nL = GetNormal(pL);\n           float dif = dot(nL, normalize(vec3(1,2,3)))*.5+.5;\n           dif = clamp(dif, 0., 1.);\n           //dif = smoothstep(0., 1., dif);\n           //dif = pow(4. * dif * (1.-dif), 2.);\n           col = vec3(dif);\n          // float fresnel = pow(1.+dot(rdOut, nL), 3.);\n           //col *= clamp(fresnel, 0., 1.);\n           col *= 0.5 + 0.5 * nL;\n          \n           col *= 1. + 0.5 * thc(4., 12. * length(p) - iTime);\n           col = mix(col, texture(iChannel0, rdOut).rgb, 0.2);\n        }\n        else\n            col = texture(iChannel0, rdOut).rgb;\n            \n        float fresnel = pow(1.+dot(rd, n), 3.);\n       // col = vec3(fresnel);\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        col = mix(col, refOutside, fresnel);\n       \n        \n\n    }\n    //col *= 2.;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 137, 137, 199], [201, 201, 230, 230, 311], [314, 314, 337, 337, 867], [869, 869, 915, 915, 1131], [1133, 1133, 1157, 1157, 1347], [1349, 1349, 1399, 1399, 1590], [1592, 1592, 1649, 1649, 4030]]}
{"id": "sdjyRV", "name": "paint with displacement", "author": "FabriceNeyret2", "description": "paint with mouse. click and drag.\nnote that the distortion is done on the uv field.  \nTextures or curves are mapped on  the field afterward.", "tags": ["distortion", "uvmap", "viamapping"], "likes": 37, "viewed": 834, "published": 3, "date": "1643815204", "time_retrieved": "2024-07-30T17:05:48.279214", "image_code": "// variant from https://shadertoy.com/view/fdjyRV\n\n// === applies the uv field to a texture =================\n\n//#define fwidth(v) length(vec2(dFdx(v),dFdy(v)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = T(u).xy;                    // distorted uv field\n    O = texture( iChannel1, u );    // apply map\n    \n    float v = length(u-.5);         // apply circle\n    O = mix( O, vec4(1,0,0,0), smoothstep( 1.5, 0.,  abs(v-.3)/fwidth(v) ) );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === distort the uv field ====================\n\n#define S(D)       (D) / max( dot(D,D) , 1e-3 )  // irrotational swirl\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                          // previous state\n    if ( u== vec2(.5) )                                // previous mouse pos\n      {  O = vec4(iMouse.xy*sign(iMouse.z), T(0).xy); return; } \n      \n    vec2 U = u / R.y,\n         M = iMouse.xy / R.y,\n         d = iMouse.xy - T(0).zw,                      // mouse drag direction\n         V = d/R.y *smoothstep(.2,0., length(U-M) );   // displacement field\n\n    if (iMouse.z > 0.  &&  T(0).z > 0. )               // if click & drag, displace\n        O = texture( iChannel0, ( U - .5*V ) *R.y/R );\n    \n    if ( iFrame < 1 ) O = vec4(u/R,0,0);               // init uv field\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R      iResolution.xy\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 200, 200, 444]]}
{"id": "7djczK", "name": "Doodle Printer 5000", "author": "eiffie", "description": "I was so busy I didn't have time to doodle so I built a doodle printer. Now that its done I have time again.", "tags": ["graphics", "turtle"], "likes": 18, "viewed": 291, "published": 3, "date": "1643813557", "time_retrieved": "2024-07-30T17:05:49.035193", "image_code": "//Doodle Printer by eiffie \n//This is the same turtle graphics routine shown on numberphile but the angle\n//increases exponentially.\n\n//Challenge: Find a three sided loop.\n#define time iTime\n#define rez iResolution.xy\n\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time iTime\n#define rez iResolution.xy\n#define pi 3.14159\nvec4 load(float x, float y){return texture(iChannel0,vec2(x+.5,y+.5)/rez.xy);}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n  U=floor(U);\n  vec4 L=load(0.,0.);\n  float f=float(iFrame),mf=900.;//increase this to complete circuits after 180. secs\n  if(mod(f,mf)==0.){\n    if(U.x+U.y==0.)O=vec4(rez.x,0.,-(2.*U.x-rez.x)/rez.y*15.,0.); \n    else if(U.x>rez.x/2. || iFrame==0)O=vec4(1);\n    else O=load(U.x+floor(rez.x/2.),U.y);\n    return;\n  }\n  vec2 nv=vec2(cos(L.y),sin(L.y));\n  if(U.x+U.y==0.){//logic pixel\n    float s=floor(f/mf);\n    f=mod(f-1.,mf);\n    if(f>800.+s*12.)return;//approximately 1 loop has finished\n    float f2=s*3.+200.;//199 for a new batch, every 3rd doodle is crap so step over it\n    O.zw+=nv;\n    O.y=mod(O.y+pi/f2*pow(f,2.),pi*2.);//increases the angle by pi*(step#^2)/doodle#\n  }else{//draw\n    vec2 p=L.zw,u=30.*(2.*U-rez.xy)/rez.y;\n    float d=tube(u-p,nv);d=smoothstep(0.0,90./rez.y,d);\n    O=min(O,vec4(d));\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define bps 8.\n#define pi 3.14159\nint N[8]=int[8](0,2,4,5,7,5,4,0);\n//int N[8]=int[8](0,2,3,4,5,7,8,9);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian +minor 3rd \n return note; \n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n} \nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+cos(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\nvec2 mainSound(int samp, float time){\n//return vec2(sin(time*500.));\n  float tim=time*bps;\n  float bt=floor(tim),t=fract(tim);\n  int n1=N[int(bt/64.)];\n  int n0=n1+N[int(bt/8.)%8],n=n0+N[int(bt)%8],n2=n0+N[int(bt/2.)%8],n4=n0+N[int(bt/4.)%8];\n  vec2 v=I(n+36,t,vec3(1.-t*.5,1.,t),vec4(10.,1.0,12.,t*.3),vec4(1.014,0.005,1.,.5))*.25;\n  t=fract(tim/2.);\n  float fo=pow(1.-t,20.0);\n  v+=I(n2+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/4.);\n  fo=pow(1.-t,20.0);\n  v+=I(n4+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/8.);\n  fo=pow(1.-t,20.0);\n  v+=I(n0+36,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,2.0,48.,t*.8),vec4(1.014,0.005,1.,.5));\n  return v*.2;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 257, 257, 292]]}
{"id": "fdjyRV", "name": "paint with swirls ( div free )", "author": "FabriceNeyret2", "description": "paint with mouse. click and drag, or just click.\nSwirl paint preserves the volume everywhere ( divergence free ).\n\nnote that the distortion is done on the uv field.  \nTextures or curves are mapped on  the field afterward.", "tags": ["swirl", "distortion", "vortex", "uvmap", "vorticity", "divergencefree", "viamapping"], "likes": 42, "viewed": 740, "published": 3, "date": "1643799603", "time_retrieved": "2024-07-30T17:05:49.788179", "image_code": "// === applies the uv field to a texture =================\n\n//#define fwidth(v) length(vec2(dFdx(v),dFdy(v)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = T(u).xy;                    // distorted uv field\n    O = texture( iChannel1, u );    // apply map\n    \n    float v = length(u-.5);         // apply circle\n    O = mix( O, vec4(1,0,0,0), smoothstep( 1.5, 0.,  abs(v-.3)/fwidth(v) ) );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === distort the uv field ====================\n\n#define ortho(D)   vec2( -(D).y, (D).x )              // vec ortho to D\n#define S(D)       ortho(D) / max( dot(D,D) , 1e-3 )  // irrotational swirl\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                         // previous state\n    if ( u== vec2(.5) )                               // previous mouse pos\n      { if ( T(0).xy != iMouse.xy ) O = vec4(iMouse.xy,T(0).xy); return; } \n      \n    vec2 U = u / R.y,\n         M = iMouse.xy / R.y,\n         d = .1* normalize( ortho( iMouse.xy - T(0).zw +1e-5 )), // swirl pair axis\n         V = S(U-M+d) - S(U-M-d);                     // swirl pair irrotational field\n\n    if (iMouse.z > 0.)                                // if click, swirl\n        O = texture( iChannel0, ( U + .1*V/60. ) *R.y/R );\n    \n    if ( iFrame < 1 ) O = vec4(u/R,0,0);              // init uv field\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R      iResolution.xy\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 149, 149, 393]]}
{"id": "sdBcDw", "name": "Spinning Tops", "author": "wyatt", "description": "Wood tops", "tags": ["mechanics"], "likes": 42, "viewed": 668, "published": 3, "date": "1643788555", "time_retrieved": "2024-07-30T17:05:50.711710", "image_code": "vec3 wood (vec2 u) {\n    return texture(iChannel3,u).xyz;\n}\nvec3 stone (vec2 u) {\n    return texture(iChannel2,u).xyz;\n}\nvec3 woodN (vec2 u) {\n    float n = wood(u+vec2(0,1)/R).x;\n    float e = wood(u+vec2(1,0)/R).x;\n    float s = wood(u-vec2(0,1)/R).x;\n    float w = wood(u-vec2(1,0)/R).x;\n    return normalize(vec3(e-w,n-s,.5));\n}\nvec3 stoneN (vec2 u) {\n    float n = stone(u+vec2(0,1)/R).x;\n    float e = stone(u+vec2(1,0)/R).x;\n    float s = stone(u-vec2(0,1)/R).x;\n    float w = stone(u-vec2(1,0)/R).x;\n    return normalize(vec3(e-w,n-s,.2));\n}\nvoid drawTop (vec3 p, vec3 d, top b, inout vec3 normal, inout vec3 color, int i) {\n    vec3 n = vec3(0,1,0)*b.o;\n    float dn = dot(d,n);\n    float pn = dot(p-b.p,n);\n    float pd = dot(p-b.p,d);\n    float r = .05;\n    float q = quadratic(\n        1.-dn*dn,\n        2.*pd-2.*pn*dn,\n        dot(p-b.p,p-b.p)-pn*pn-r*r\n    ).x;\n    float qs = sphere(p,d,b.p,.4);\n    vec3 i1 = p + d*q;\n    float x1 = dot(i1-b.p,n);\n    if (x1>+.5) q = sphere(p,d,b.p+.5*n,r);\n    if (x1<-.5) q = sphere(p,d,b.p-.5*n,r);\n    normal = normalize(p+d*q-(b.p+n*clamp(x1,-.5,.5)));\n    if (q<0.||(qs<q&&qs>0.)) {\n        q = qs;\n        normal = normalize(p+d*q-b.p);\n        vec3 no = b.o*normal;\n        vec2 u = 2./pi*vec2(atan(length(no.xz),no.y),atan(no.z,no.x));\n    \n        color = .6*wood(u)*(.7+.6*sin(float(i)+vec3(1,2,3)));\n        vec3 wn = woodN(u);\n        normal = normal*wn.z+5.*wn.y*cross(normal,b.o[1])+1.*wn.x*cross(normal,b.o[0]);\n    } else color = vec3(0);\n}\nvoid scene (inout vec3 p, inout vec3 d, inout vec3 normal, inout vec3 color) {\n    float mi = 1e9;\n    top object;\n    forM(i) { // tops\n        top t = get(i);\n        float ii = iTop(p,d,t);\n        if (ii < mi && ii>0.) {\n            mi = ii;\n            object = t;\n            drawTop(p,d,t,normal,color,i);\n        }\n    }\n    { // floor\n        float ii = plane(p,d,vec3(0,-1.5,0),vec3(0,1,0));\n        if (ii < mi && ii>0.) {\n            mi = ii;\n            vec3 u = (p + d*mi);\n            float s = .6+.4*sign(sin(3.*u.x)*sin(3.*u.z));\n            color = s*wood(s+.6*u.xz);\n            vec3 wn =  woodN(s+.6*u.xz);\n            wn.z *= .2+s;\n            normal = normalize(wn).xzy;\n        }\n    }\n    { // wall\n        float ii = plane(p,d,vec3(0,0,1.5),vec3(0,0,1));\n        if (ii < mi && ii>0.) {\n            mi = ii;\n            vec3 u = (p + d*mi);\n            float s = .9-sin(2.*u.x);\n            normal = stoneN(-.3*u.yx);\n            color = .8*stone(-.3*u.yx);\n            if (s<0.) {\n                color = exp(-.1*abs(u.y))*sin(1.+.15*(u.y)*(1.+vec3(1,2,3)));\n                normal = woodN(u.xy);\n            }else if (s<.1) {\n                color = .3*wood(.2*u.yx);\n                normal = woodN(.2*u.yx);\n            }\n        }\n    }\n    \n    p = p + d*mi;\n    d = reflect(d,normal);\n    p += 1e-4*d;\n}\nMain {\n\n    vec3 p = vec3(0,1,-6.);\n    vec3 d = normalize(vec3((U-.5*R)/R.y,1));\n    d.yz *= ei(.6);\n    float an = .05+.1*sin(.5*iTime);\n    if (iMouse.z>0.) an = 3.1*(iMouse.x/R.x-.5);\n    d.xz *= ei(an);d=normalize(d);\n    Q = vec4(0);\n    vec3 normal, color;\n    for (float k = 1.; k < 4.; k++) {\n        scene(p,d,normal,color);\n        Q.xyz += .9*color/k;\n    }\n    \n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n    #define M 13\n    \n    #define N 100.\n    #define dt (1./N)\n\n\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) \n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define cell(u) ((u).x>=0.&&(u).y>=0.&&(u).x<1.&&(u).y<1.)\n#define pi 3.14159265359\n#define get(i) top(\\\n        A(vec2(i,0)+.5).xyz,\\\n        mat3(\\\n            A(vec2(i,1)+.5).xyz,\\\n            A(vec2(i,2)+.5).xyz,\\\n            A(vec2(i,3)+.5).xyz \\\n        ),\\\n        A(vec2(i,4)+.5).xyz,\\\n        A(vec2(i,5)+.5).xyz,\\\n        vec3(0),\\\n        vec3(0));\n#define set(i,b) \\\n    if (cell(U-.5-vec2(i,0))) Q.xyz = (b).p;\\\n    if (cell(U-.5-vec2(i,1))) Q.xyz = (b).o[0];\\\n    if (cell(U-.5-vec2(i,2))) Q.xyz = (b).o[1];\\\n    if (cell(U-.5-vec2(i,3))) Q.xyz = (b).o[2];\\\n    if (cell(U-.5-vec2(i,4))) Q.xyz = (b).v;\\\n    if (cell(U-.5-vec2(i,5))) Q.xyz = (b).s;\nstruct top {\n    vec3 p;\n    mat3 o;\n    vec3 v;\n    vec3 s;\n    vec3 f; // force\n    vec3 t; // torque\n};\nmat3 matrix (vec3 r) { \n   if (length(r)==0.) return mat3(1);\n   float a = length(r);\n   vec3 o = normalize(r);\n   float c = cos(a), t = 1.-c;\n   float s = sin(a);\n   return mat3(\n       t*o.x*o.x+c,t*o.x*o.y-o.z*s,t*o.x*o.z+o.y*s,\n       t*o.x*o.y+o.z*s,t*o.y*o.y+c,t*o.y*o.z-o.x*s,\n       t*o.x*o.z-o.y*s,t*o.y*o.z+o.x*s,t*o.z*o.z+c\n   \n   );\n\n}\nvec2 quadratic (float a, float b, float c) {\n    float d = b*b-4.*a*c;\n    if ( d < 0. ) return vec2(-1);\n    return .5/a*vec2(-b-sqrt(d),-b+sqrt(d));\n}\nfloat plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    return -dot(p-c,n)/dot(d,n);\n}\nfloat sphere (vec3 p, vec3 d, vec3 a, float r) {\n    return quadratic(1.,2.*dot(p-a,d),dot(p-a,p-a)-r*r).x;\n}\nfloat iTop (vec3 p, vec3 d, top b) {\n    vec3 n = vec3(0,1,0)*b.o;\n    float dn = dot(d,n);\n    float pn = dot(p-b.p,n);\n    float pd = dot(p-b.p,d);\n    float r = .05;\n    float q = quadratic(\n        1.-dn*dn,\n        2.*pd-2.*pn*dn,\n        dot(p-b.p,p-b.p)-pn*pn-r*r\n    ).x;\n    float qs = sphere(p,d,b.p,.4);\n    vec3 i1 = p + d*q;\n    float x1 = dot(i1-b.p,n);\n    if (x1>+.5) q = sphere(p,d,b.p+.5*n,r);\n    if (x1<-.5) q = sphere(p,d,b.p-.5*n,r);\n    if (q<0.||(qs<q&&qs>0.)) \n        q = qs;\n    return q;\n}\n\n\n#define forM(i) for (int i = 0; i < M+ min(iFrame,0); i++)\n\n#define Gravity(part) part.v.y -= dt*1e-1;\n\n#define Velocity(part,a) part.v+cross(part.s,a-part.p);\n\n#define Impulse(part,a,no,dv) \\\n    vec3 r = normalize(part.p-a);\\\n    vec3 im = no*(1.-.5*dot(no,dv)/length(dv));\\\n    if (length(dv)>0.)\\\n        im -= .5*dv*length(cross(normalize(dv),no)); \\\n    float l = length(im);\\\n    part.f += im*abs(dot(im/l,r));\\\n    part.t += cross(im/l,r);\n    \n#define Ground(part) \\\n{\\\n    vec3 n = vec3(0,1,0)*part.o;\\\n    vec3 a = part.p-.5*n;\\\n    vec3 b = part.p+.5*n;\\\n    vec3 c = part.p+vec3(0,-.4,0);\\\n    if (a.y<-1.45) {\\\n        vec3 dv = Velocity(part,a);\\\n        Impulse(part,a,vec3(0,1,0),dv);\\\n    }\\\n    if (b.y<-1.45) {\\\n        vec3 dv = Velocity(part,b);\\\n        Impulse(part,b,vec3(0,1,0),dv);\\\n    }\\\n    if (c.y<-1.5) {\\\n        vec3 dv = Velocity(part,c);\\\n        Impulse(part,c,vec3(0,1,0),dv);\\\n    }\\\n}\n#define Wall(part) \\\n{\\\n    vec3 n = vec3(0,1,0)*part.o;\\\n    vec3 a = part.p-.5*n;\\\n    vec3 b = part.p+.5*n;\\\n    vec3 c = part.p+vec3(0,-.4,0);\\\n    if (a.z>1.45) {\\\n        vec3 dv = Velocity(part,a);\\\n        Impulse(part,a,vec3(0,0,-1),dv);\\\n    }\\\n    if (b.z>1.45) {\\\n        vec3 dv = Velocity(part,b);\\\n        Impulse(part,b,vec3(0,0,-1),dv);\\\n    }\\\n    if (c.z>1.5) {\\\n        vec3 dv = Velocity(part,c);\\\n        Impulse(part,c,vec3(0,0,-1),dv);\\\n    }\\\n}\n\n#define Hit(part,other)   \\\nif (length(part.p-other.p)<1.) {\\\n    vec3 np = vec3(0,1,0)*part.o;\\\n    vec3 no = vec3(0,1,0)*other.o;\\\n    vec3 ap = part.p+np*.5;\\\n    vec3 bp = part.p-np*.5;\\\n    vec3 ao = other.p+no*.5;\\\n    vec3 bo = other.p-no*.5;\\\n    /* ball hit ball */\\\n    if (length(part.p-other.p)<=.8) { \\\n        vec3 a = .5*(part.p+other.p); \\\n        vec3 n = normalize(a-other.p); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    /* my peg hit ball */\\\n    if (length(ap-other.p)<=.4) {\\\n        vec3 a = ap; \\\n        vec3 n = normalize(part.p-a); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    if (length(bp-other.p)<=.4) {\\\n        vec3 a = bp; \\\n        vec3 n = normalize(part.p-a); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    /* peg hit my ball */\\\n    if (length(ao-part.p)<=.4) {\\\n        vec3 a = ao; \\\n        vec3 n = normalize(a-other.p); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    if (length(bo-part.p)<=.4) {\\\n        vec3 a = bo; \\\n        vec3 n = normalize(a-other.p); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    /* peg hit peg */\\\n    if (length(ao-ap)<=.1) {\\\n        vec3 a = .5*(ap+ao); \\\n        vec3 n = normalize(a-ao); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    if (length(ao-bp)<=.1) {\\\n        vec3 a = .5*(ap+bo); \\\n        vec3 n = normalize(a-bo); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    if (length(bo-ap)<=.1) {\\\n        vec3 a = .5*(bp+ao); \\\n        vec3 n = normalize(a-ao); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n    if (length(bo-bp)<=.1) {\\\n        vec3 a = .5*(bp+bo); \\\n        vec3 n = normalize(a-bo); \\\n        vec3 dv = Velocity(part,a)-Velocity(other,a);\\\n        Impulse(part,a,n,dv); \\\n    }\\\n}\n\n    \n#define Renormalize(part) \\\n        part.o[0] = normalize(cross(part.o[1],part.o[2]));\\\n        part.o[1] = normalize(cross(part.o[2],part.o[0]));\\\n        part.o[2] = normalize(cross(part.o[0],part.o[1]));\\\n\n#define Physics(part) \\\n        part.v += dt*part.f;\\\n        part.s += dt*part.t;\\\n        part.p += dt*part.v;\\\n        part.o *= matrix(dt*part.s);\\\n        part.s *= 1.-0e-3*dt;\n", "buffer_a_code": "Main {\n    if (U.x>float(M)||U.y>6.) discard;\n    top tops[M];\n    for (int i = 0; i < M; i++)\n        tops[i] = get(i);\n        \n    \n    for (int time = 0; time < int(N/2.)+ min(iFrame,0); time++) {\n         {\n            forM(i) Gravity(tops[i])\n            forM(i) tops[i].f = vec3(0),\n                    tops[i].t = vec3(0);\n            forM(i) forM(j) if (i!=j) {\n                Hit(tops[i],tops[j]);\n            }\n            forM(i) {Ground(tops[i])}\n            forM(i) {Wall(tops[i])}\n            forM(i) {Physics(tops[i])}\n            forM(i) {Renormalize(tops[i])}\n        }\n    }\n    if (iFrame < 1) {\n        forM(i) {\n            vec3 o  = vec3(0,1,0);\n            tops[i].o = matrix(o);\n            tops[i].p  = vec3(1.7*sin(10.*float(i-M/2)),0,-.4*float(i));\n            tops[i].v  = vec3(0,-20.*dt*float(i-M/2),0);\n            tops[i].s  = 100.*dt*o*cos(float(i));\n            tops[i].o *= matrix(vec3(0,0,pi*.01));\n            tops[i].s *= matrix(vec3(0,0,pi*.01));\n        }\n    }\n    \n    for (int i = 0; i < M; i++) {\n        set(i,tops[i]);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 59], [60, 60, 81, 81, 120], [121, 121, 142, 142, 332], [333, 333, 355, 355, 549], [550, 550, 632, 632, 1507], [1508, 1508, 1586, 1586, 2842]]}
{"id": "Nsc3DM", "name": "Oaxaca Countryside", "author": "Plento", "description": "Oaxaca is beautiful.", "tags": ["3d", "raymarch", "mountains", "oaxaca"], "likes": 28, "viewed": 598, "published": 3, "date": "1643781350", "time_retrieved": "2024-07-30T17:05:51.536505", "image_code": "// Cole Peterson (Plento)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 blur = texture(iChannel0, u/R, 6.);\n    \n    f = texelFetch(iChannel0, ivec2(u), 0)\n      + .3*pow(blur, vec4(4)).z                  // bloom the sky\n      - .18*clamp(hsh(u + iTime), .5, .9);       // noise grain\n    f *= .94 * (1.-step(.43, abs(u.y/R.y - .5))); // cinemascope borders\n} // The Fabrice simplification", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan,  ivec2(p), 0)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat octnse(vec2 p, int oct, float t){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x += t;\n     \tn += perlin(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n", "buffer_a_code": "\n// https://iquilezles.org/articles/distfunctions\nfloat smoothmin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat gh(vec2 rp){\n    float h = 0.;\n    \n    float t = rp.x + rp.y*1.2;\n    h += cos(rp.y) + .5*cos(t*4.) + .3*sin(rp.y*3.);\n    h += cos(rp.x) + .4*sin(rp.x*2.) + .3*cos(t*3.);\n    h *= .3;\n    \n    return h;\n}\n\n#define rad .016\n#define it 4.\n#define b vec3(1., 0., 1.)\n\n\nfloat trees_kinda(vec3 p){\n    float scl = 0.33, d = 999., ts = 1.;\n       \n    for(float i = 0.; i < it; i++){\n        p.xz = -abs(p.xz);\n        float a = 2.9;\n        \n        a -= cos(i)*.15;\n        p.y -= scl*2.;   \n        \n        p.y += scl;\n        p.xy *= rot(a);\n        p.yz *= rot(a);\n        p.y -= scl;\n       \n        scl *= .8;\n    }\n    \n    d = smoothmin(d, length(p-vec3(0., ts, 0.))-0.23, .7);\n    return d;\n}\n\nfloat map(vec3 rp){\n    rp.z += iTime;\n\n    float h = gh(rp.xz);\n    \n    h -= .1*octnse(rp.xz * 3.8, 3, 0.);\n    h -= cos(rp.z*2.) * .13;\n\n    float d = rp.y + h;\n    \n    rp.xz*=rot(3.14/4.);\n    d = smoothmin(trees_kinda(mod(rp - vec3(1., -3.4 + h, 0.), b)-b*.5), d, .9);\n    \n    return d;\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy - .5*R) / R.y;\n    \n    vec3 rd = normalize(vec3(uv,2.4));\n    vec3 ro = vec3(0., 2.15 + .1*cos(iTime*.4), 0.);\n    \n    \n    \n    rd.yz *= rot(.1);\n    rd.xz *= rot(.1);\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    \n    for(int i = 0; i < 61; i++){\n        d = map(ro+rd*t);\n        if(d < 0.0025 || t > 30.) break;\n        t += d * .7;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    p.z += iTime;\n    \n    vec3 ld = normalize(vec3(-0.8, 0.5, -2.));\n    float dif = max(dot(n, ld), .1);\n    float ao = ss(7., 2., ns *.3);\n      \n    float rnd = perlin(p.xz * 2.5); \n    vec3 grass = mix(vec3(0), .23*vec3(.1, .2, .1), rnd);\n   \n    float cloud = (1. - .17*octnse(rd.xy*10., 4, -iTime*.12));\n    cloud = mix(cloud, 1., ss(19., 11., t));\n    vec3 sky = cloud * vec3(.6, .7, .95);\n    \n    vec3 col = grass * dif * ao;\n\n    float fd = 22.;\n    float fog = ss(fd, fd - 16.4, t);\n    \n    col = mix(sky, col, fog);\n    col = pow(col*1.1, vec3(1.4));\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 68, 68, 366]]}
{"id": "7dSyzV", "name": "tunnel x", "author": "jorge2017a2", "description": "tunnel x", "tags": ["tunnelx"], "likes": 16, "viewed": 346, "published": 3, "date": "1643774323", "time_retrieved": "2024-07-30T17:05:52.344345", "image_code": "//----------image\n//por jorge2017a2-\n///tunnel x\n//https://www.shadertoy.com/view/WlsSWS\n//   01/feb/2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n//https://www.shadertoy.com/view/WlsSWS\nfloat pathterrain(float x,float z)\n{   // Common height function for path and terrain\n    return  sin(x*.5 )*1.+cos(z*.3 )*0.3 +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   \n    p.y=p.y-5.0;\n    p=rotate_y(p, radians(90.0));\n    \n    float h1= pathterrain(p.x*0.5,p.z);\n    float h2= pathterrain(p.y*0.5,p.z);\n    float h3= pathterrain(p.x*0.5,p.y);\n    \n    p.x=  opRep1D( p.x, 6.0 );\n   float d2= sdBox( p-vec3(0.0,h1+h2,0.0+h3), vec3(6.0,3.0,6.0) );\n    float d3= sdBox( p, vec3(6.0,5.0,6.0) );\n     //d2= differenceSDF(d3,d2);\n     d2= intersectSDF(d2, d3);  \n\n\n    res =opU3(res, vec3(d2,100.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/16., nor); return col; }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n      \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n         // Exponential distance fog\n        col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.0011 * d *d ));\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n   \n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 10.0, -20.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(50.0, 50.0, 20.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n   vec3 ro=vec3(0.0, 7.0, 0.0-t);\n   float h1= pathterrain(ro.x*0.5,ro.z);\n   //float h2= pathterrain(ro.y*0.5,ro.z);\n   float h3= pathterrain(ro.x*0.5,ro.y);\n   \n   ro.y-=h1;\n   ro.x+=h3;\n   vec3 rd=normalize( vec3(uv.x,uv.y+h1*0.5,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 599, 599, 683], [685, 729, 776, 776, 803], [804, 804, 847, 847, 874], [875, 875, 923, 923, 951], [952, 952, 988, 988, 1033], [1035, 1060, 1094, 1094, 1190], [1191, 1191, 1225, 1225, 1316], [1317, 1317, 1351, 1351, 1442], [1443, 1443, 1477, 1477, 1572], [1575, 1615, 1651, 1700, 1779], [1781, 1781, 1806, 1806, 2404], [2406, 2406, 2430, 2430, 2592], [2594, 2594, 2643, 2643, 3274], [3277, 3277, 3313, 3313, 3558], [3561, 3561, 3598, 3598, 3859], [3861, 3861, 3944, 3944, 4513], [4515, 4515, 4564, 4564, 4638], [4640, 4640, 4733, 4733, 4863], [4866, 4866, 4959, 4959, 5150], [5153, 5153, 5180, 5180, 5269], [5271, 5271, 5329, 5329, 5377], [5380, 5380, 5403, 5403, 5521], [5523, 5523, 5554, 5554, 6332], [6335, 6335, 6392, 6392, 7083]]}
{"id": "sdBczK", "name": "Interactive subdivision", "author": "davidar", "description": "A quick fork of Tater's code to recreate [url]https://www.instagram.com/p/CZZ1p59oIQm/[/url]. Use the mouse", "tags": ["2d", "squares", "subdivide", "reproduction"], "likes": 50, "viewed": 620, "published": 3, "date": "1643767615", "time_retrieved": "2024-07-30T17:05:53.164153", "image_code": "//Inspired by the work of @okazz\n//https://twitter.com/okazz_/status/1436332410690441219\n\n//I didn't look at their code but the result is similar enough that I wonder if the\n//algorithm is the same. \n\n//I'm pretty sure there's also a famous painting that looks like this but I can't remember it\n\n#define pi 3.1415926535\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return max(d.x,d.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime*1.2,6000.);\n    float px = 1./iResolution.y;\n    \n    //You can remove the R.x/R.y to get a square\n    vec2 xRange = vec2(-0.5,0.5)*R.x/R.y;\n    vec2 yRange = vec2(-0.5,0.5);\n    float id = 0.;\n    float seed = floor(t/6.);\n    float a;\n    \n    \n    //PLAY WITH THESE VARIABLES :D\n    float minSize = 0.015;\n    //float breakSize = 0.04;\n    float iters = 10.;\n    float borderSize = -0.002;\n    float minIters = 1.;\n    \n    //minSize = min(minSize,breakSize);\n    for(float i = 0.;i<iters;i++){\n        float xLength = xRange.y-xRange.x;\n        float yLength = yRange.y-yRange.x;\n        float dividex = h21(vec2(i+id,seed))*(xLength)+xRange.x;\n        float dividey = h21(vec2(i+id,seed))*(yLength)+yRange.x;\n        \n        dividex= clamp(dividex,xRange.x+minSize,xRange.y-minSize);\n        dividey= clamp(dividey,yRange.x+minSize,yRange.y-minSize);\n        \n        float mn = min(length(xRange.x-dividex),length(xRange.y-dividex));\n        mn = min(mn,min(length(yRange.x-dividey),length(yRange.y-dividey)));\n        if(mn<minSize&&i-1.>minIters) break;\n        \n        ////////////////////////////////\n        ////////////////////////////////\n        vec2 diff = vec2(0);\n        if(uv.x<dividex){\n            xRange = vec2(xRange.x,dividex);\n            diff.x+=dividex;\n        }\n        else{\n            xRange = vec2(dividex,xRange.y);\n            diff.x-=dividey;\n        }\n        if(uv.y<dividey){\n            yRange = vec2(yRange.x,dividey);\n            diff.y-=dividex;\n        }\n        else{\n            yRange = vec2(dividey,yRange.y);\n            diff.y+=dividey;\n        }\n\n        id = length(diff+10.0);\n        \n        xLength = xRange.y-xRange.x;\n        yLength = yRange.y-yRange.x;\n        //xLength*=1.0-abs(pow(abs(cos(t*pi/6.)),5.0));\n        //yLength*=1.0-abs(pow(abs(cos(t*pi/6.)),5.0));\n        vec2 center = vec2((xRange.x+xRange.y)/2.,(yRange.x+yRange.y)/2.);\n        vec2 m = (.5 + .5 * vec2(cos(iTime), sin(iTime*1.7))) * R.xy;\n        if (iMouse.z > 0.) m = iMouse.xy;\n        float scale = clamp(length(center - (m-0.5*R.xy)/R.y) / 0.3, 0., 1.);\n        xLength *= scale;\n        yLength *= scale;\n        a = box(uv-center,vec2(xLength,yLength)*0.5);\n        //if(h11(id)<0.2)a=0.;\n    }\n    id = h11(id)*1000.0;\n    vec3 e = vec3(0.5);\n    vec3 al = pal(id*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n    col = clamp(al,0.,1.);\n    col = vec3(.95);\n    col -= .8 * smoothstep(-px,px,a+borderSize);\n   // col = vec3(-a*10.0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 340, 340, 411], [412, 412, 433, 433, 485], [486, 499, 566, 566, 605], [606, 606, 632, 632, 682], [683, 683, 740, 740, 3357]]}
{"id": "sdXyW7", "name": "Drawing Path Tracer", "author": "fad", "description": "While dragging the mouse, press:\n    D: diffuse\n    L: light\n    G: glass\n    M: mirror\nPress R to reset\nSettings are in the Common tab", "tags": ["2d", "interactive", "sdf", "draw"], "likes": 51, "viewed": 1021, "published": 3, "date": "1643762514", "time_retrieved": "2024-07-30T17:05:53.910158", "image_code": "// Try dragging the mouse while pressing D, L, G or M!\n\n// This buffer displays the result from Buffer B.\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    frag_color = texture(iChannel1, frag_coord / iResolution.xy);\n    frag_color.rgb /= frag_color.a;\n    frag_color.rgb = pow(frag_color.rgb, vec3(1.0 / GAMMA));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer's red channel holds the SDF for the drawing,\n// and the blue channel holds information about the type\n// of surface. Whenever the user draws a line segment, the\n// minimum between the current SD and the SD\n// between the pixel and segment is stored. \n\nconst float INFINITY = 1e10;\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel1, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nfloat line_sdf(vec2 p, vec2 a, vec2 b)\n{\n    if (a == b)\n    {\n        return distance(a, p);\n    }\n    \n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n\treturn distance(h * ab, ap);\n}\n\nvec2 new_sd(vec2 p)\n{\n    // reset the SDF texture\n    if (iFrame == 0 || key_pressed(KEY_RESET))\n    {\n        return vec2(INFINITY);\n    }\n    \n    // the current SD\n    vec2 sd = texture(iChannel0, p / iResolution.xy).rg;\n    \n    // if currently drawing\n    if (iMouse.z > 0.0 && (key_pressed(KEY_DIFFUSE) || key_pressed(KEY_LIGHT) || key_pressed(KEY_GLASS) || key_pressed(KEY_MIRROR)))\n    {\n        // get previous frame's mouse location if it's valid\n        vec2 prev_mouse = texture(iChannel0, vec2(0.5) / iResolution.xy).ba;\n        prev_mouse = prev_mouse == vec2(-1.0) ? iMouse.xy : prev_mouse;\n        \n        // the new SD is the minimum of the SD to the line segment\n        // and the current\n        float ld = line_sdf(p, prev_mouse, iMouse.xy) - BRUSH_RADIUS * iResolution.y;\n        if (ld < max(sd.r, 0.0))\n        {\n            sd.r = ld;\n            if (key_pressed(KEY_DIFFUSE)) sd.g = float(DIFFUSE);\n            if (key_pressed(KEY_LIGHT)) sd.g = float(EMISSIVE);\n            if (key_pressed(KEY_GLASS)) sd.g = float(GLASS);\n            if (key_pressed(KEY_MIRROR)) sd.g = float(MIRROR);\n        }\n    }\n    \n    return sd;\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    // store the SD in the red channel\n    frag_color.rg = new_sd(frag_coord);\n    \n    // store the mouse position for the next frame in the\n    // blue and alpha channels of the lower left pixel if\n    // it is currently pressed\n    if (frag_coord == vec2(0.5))\n    {\n        if (iMouse.z > 0.0)\n        {\n            frag_color.ba = iMouse.xy;\n        }\n        else\n        {\n            frag_color.ba = vec2(-1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define CF const float\n#define CV const vec3\n#define CI const int\n\n// SETTINGS //\n// SDF RAY MARCHING //\nCI NUM_SAMPLES     = 1;\nCI NUM_BOUNCES     = 5;\nCI MAX_STEPS       = 100;\n\n// DRAWING //\nCF BRUSH_RADIUS    = 0.01; // relative to y resolution\n\n// VISUALS //\nCV SKY_LIGHT       = vec3(0.65, 0.65, 0.70) * 0.6;\nCV DIFFUSE_COLOR   = vec3(1.0, 0.0, 0.0);\nCV EMISSIVE_COLOR  = vec3(1.0, 1.0, 1.0);\nCF EMISSIVITY      = 1.0;\nCV GLASS_COLOR     = vec3(0.0, 1.0, 0.0);\nCF GLASS_IR        = 2.0;\nCV MIRROR_COLOR    = vec3(1.0, 1.0, 1.0);\nCF GAMMA           = 2.2;\n\n// NOT SETTINGS //\nCI DIFFUSE  = 1;\nCI EMISSIVE = 2;\nCI GLASS    = 3;\nCI MIRROR   = 4;\n\nCF KEY_D = 68.0;\nCF KEY_L = 76.0;\nCF KEY_G = 71.0;\nCF KEY_M = 77.0;\nCF KEY_R = 82.0;\n\nCF KEY_DIFFUSE = KEY_D;\nCF KEY_LIGHT   = KEY_L;\nCF KEY_GLASS   = KEY_G;\nCF KEY_MIRROR  = KEY_M;\nCF KEY_RESET   = KEY_R;", "buffer_b_code": "// This buffer ray traces against the SDF from buffer A.\n// It accumulates samples and stores the number of\n// samples so far in the alpha channel.\n\nconst float PI = 3.141592564;\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel2, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\n// gamma correct colors\nconst vec3 diffuse_color = pow(DIFFUSE_COLOR, vec3(GAMMA));\nconst vec3 emissive_color = pow(EMISSIVE_COLOR, vec3(GAMMA));\nconst vec3 glass_color = pow(GLASS_COLOR, vec3(GAMMA));\nconst vec3 mirror_color = pow(MIRROR_COLOR, vec3(GAMMA));\nconst vec3 sky_light = pow(SKY_LIGHT, vec3(GAMMA));\n\nint seed;\n\nfloat rand()\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\nfloat rand(int seed)\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\nvoid set_seed(vec2 p)\n{\n    seed = int(p.x + p.y * iResolution.x);\n\tseed = int(rand() * 2147483647.0) + iFrame;\n}\n\nvec2 sdf(vec2 p)\n{\n    return texture(iChannel0, p / iResolution.xy).rg;\n}\n\nvec2 grad(vec2 p)\n{\n    const vec2 e = vec2(1.0, 0.0);\n    return vec2(\n        sdf(p + e.xy).x - sdf(p - e.xy).x, \n        sdf(p + e.yx).x - sdf(p - e.yx).x\n    ) / 2.0;\n}\n\nstruct Mat\n{\n    int type;\n    vec3 c; // color\n    float e; // emissivity\n};\n\nMat mat(vec2 p)\n{\n    float s = sdf(floor(p) + 0.5).y;\n    Mat m;\n    m.type = int(s);\n    m.c =\n        m.type == DIFFUSE  ? diffuse_color  :\n        m.type == EMISSIVE ? emissive_color :\n        m.type == GLASS    ? glass_color    : \n        m.type == MIRROR   ? mirror_color   :\n        vec3(0.0);\n    m.e = m.type == EMISSIVE ? EMISSIVITY : 0.0;\n    m.type = m.type == EMISSIVE ? DIFFUSE : m.type;\n    return m;\n}\n\nfloat ray_march(vec2 o, vec2 d)\n{\n    const float EPSILON = 0.1;\n    float t = 0.0;\n    vec2 p = o;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = abs(sdf(p).x);\n        \n        if (EPSILON < t && dist < EPSILON)\n        {\n            return t;\n        }\n        \n        t += dist;\n        p = o + d * t;\n        \n        if (p.x < 0.0 || iResolution.x <= p.x || p.y < 0.0 || iResolution.y <= p.y)\n        {\n            break;\n        }\n    }\n    \n    return -1.0;\n}\n\nstruct Hit \n{\n    vec2 p; // position\n    vec2 n; // normal\n    Mat m; // material\n};\n\nHit hit(vec2 o, vec2 d)\n{\n    float t = ray_march(o, d);\n    \n    if (t == -1.0)\n    {\n        return Hit(vec2(0.0), vec2(0.0), Mat(0, vec3(0.0), 0.0));\n    }\n    \n    Hit h;\n    h.p = o + d * t;\n    h.n = normalize(grad(h.p));\n    h.m = mat(h.p);\n    return h;\n}\n\n\nvec2 sample_semicircle(vec2 n, float t)\n{\n    t *= 2.0 * PI;\n    vec2 s = vec2(cos(t), sin(t));\n    return s * sign(dot(s, n));\n}\n\nvec3 trace(vec2 o, vec2 d)\n{    \n    vec3 final_color = vec3(0.0);\n    vec3 multiplier = vec3(1.0);\n    \n    // handle case when ray origin is inside drawing\n    if (sdf(o).x < 0.0)\n    {\n        Mat m = mat(o);\n        switch (m.type)\n        {\n            case MIRROR:\n            case DIFFUSE:\n            {\n                float t = ray_march(o, d);\n                o += d * (t + 1.0);\n                multiplier *= m.c;\n                final_color += multiplier * m.e;\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < NUM_BOUNCES; ++i)\n    {\n        Hit h = hit(o, d);\n        \n        if (h.n == vec2(0.0))\n        {\n            final_color += multiplier * sky_light;\n            break;\n        }\n        \n        h.n *= -sign(dot(h.n, d));\n        multiplier *= h.m.c;\n        final_color += multiplier * h.m.e;\n        \n        switch (h.m.type)\n        {\n            case DIFFUSE:\n            {\n                o = h.p;\n                d = sample_semicircle(h.n, rand());\n                multiplier *= dot(d, h.n);\n                break;\n            }\n            \n            case GLASS:\n            {                \n                // i think this is incorrect :c\n                float n1 = 1.0;\n                float n2 = GLASS_IR;\n                \n                if (sdf(h.p).x < 0.0)\n                {\n                    n1 = GLASS_IR;\n                    n2 = 1.0;\n                }\n                \n                float eta = n1 / n2;\n                float c1 = -dot(h.n, d);\n                float k = 1.0 - eta * eta * (1.0 - c1 * c1);\n                \n                if (k < 0.0)\n                {\n                    o = h.p;\n                    d = reflect(d, h.n);\n                \n                    break;\n                }\n                \n                float c2 = sqrt(k);\n                float rs = (n1 * c1 - n2 * c2) / (n1 * c1 + n2 * c2);\n                \n                if (rand() < rs)\n                {\n                    o = h.p;\n                    d = reflect(d, h.n);\n                \n                    break;\n                }\n                \n                o = h.p;\n                d = eta * d - (eta * -c1 + c2) * h.n;\n                o += d;\n                \n                break;\n            }\n            \n            case MIRROR:\n            {\n                o = h.p;\n                d = reflect(d, h.n);\n                break;\n            }\n        }\n    }\n    \n    return final_color;\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    set_seed(frag_coord);\n    \n    vec3 result = vec3(0.0);\n    \n    // accumulate samples by tracing rays in all directions\n    for (int i = 0; i < NUM_SAMPLES + min(0, iFrame); ++i)\n    {\n        float blue_noise = fract(\n            texture(iChannel3, frag_coord / iChannelResolution[3].xy).r +\n            fract(float(iFrame * NUM_SAMPLES + i) * 0.61803399)\n        );\n        float r = blue_noise;\n        //r = rand();\n        float a = 2.0 * PI * (float(i) + r) / float(NUM_SAMPLES);\n        vec2 o = floor(frag_coord) + vec2(rand(), rand());\n        vec2 d = vec2(cos(a), sin(a));\n        result += trace(o, d);\n    }\n    \n    result /= float(NUM_SAMPLES);\n    frag_color = vec4(result, 1.0);\n    \n    // accumulate samples from previous frame if \n    // scene hasn't changed. alpha channel keeps\n    // track of how many frames have been accumulated\n    if (iMouse.z <= 0.0 && !key_pressed(KEY_RESET))\n    {\n        vec4 t = texture(iChannel1, frag_coord / iResolution.xy);\n        \n        if (t.a >= 1e10)\n        {\n            frag_color = t;\n        }\n        else\n        {\n            frag_color += t;\n        }\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 161, 161, 326]]}
{"id": "NdSyRK", "name": "Nyoom Wave heart golfed", "author": "FabriceNeyret2", "description": "golfing the heart of \"Nyoom Wave\" by panna_pudi. [url] https://shadertoy.com/view/NsjyzG [/url]", "tags": ["wave", "isometric"], "likes": 7, "viewed": 216, "published": 3, "date": "1643749149", "time_retrieved": "2024-07-30T17:05:54.667134", "image_code": "// golfing the heart of \"Nyoom Wave\" by panna_pudi. https://shadertoy.com/view/NsjyzG\n// was 6803 = 4097 goodies + 640 post-effects + 2076 heart. \n\n#define R(a)         mat2( cos( a+ 1.57*vec4(0,1,-1,0) ) )\n#define M(p)         length(max(abs(p)* vec3(1, sign(p).y, 1) - .1, 0.)) - .01 // map\n//#define M(p)     ( length(max(abs(p) - .1, 0.)) - .01 ) // fun variant\n//#define AO(e,p,n)  clamp(map(p - e * n) / e, 0., 1.)\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2  R = iResolution.xy ,\n          U = ( u - .5* R ) / R.y ;\n    float t = fract(iTime / 8.),\n         rl = 0., l = 3.5, d=l, W = .25, i=0.;\n    vec3  P = vec3(U, -6),  D = vec3(0,0,1),              // point & ray dir\n          P0,N,c, b, e = D/1e3; // e: eps for N()\n\n    P.yz *= R(.615); // atan(1. / sqrt(2.))\n    D.yz *= R(.615);\n    P.xz *= R(.785); // PI / 4\n    D.xz *= R(.785);\n \n  //lxz = length(D.xz); \n    for ( P0 = P ; i++ < 1e2 && length(P-P0) < 10. && d > 1e-3 ;  P += d * D )\n        l < rl ?\n            rl = l,\n            P = P0 + D * l,\n            c = ( floor( P/W + D/length(D.xz) * 1E-4 ) + .5 ) * W, // traverse 2D grid https://www.shadertoy.com/view/stdXWH\n            b = abs(.5 * W/D ) - (P - c) / D,             // dst-src\n         // c = vec3(g.x, lxz*min(b.x, b.z), g.z ),       // ex returned value\n            l += min(b.x, b.z),\n            c.y = clamp( t*4. - c.x - mod(c.x+c.z, .9) -1.6 , 0., .2) *1.25, // ofs(c.xz, t)\n            P -= c :c,\n        rl += d = M(P);\n   \n    N = normalize( M(P) - vec3( M(P-e.zxx), M(P-e.xzx), M(P-e) ) ); // N(P);\n    O = ( N.y < .15 ? vec4(.5)\n                    : vec4(1, .12, 1.36, 1) )             // albedo\n      * length( sin(reflect(D, N)*3.) + 1. ) *.29         // shade\n   // * ( 1. - AO(5., N, P) );                            // ao, but with N,P permutation !\n      *.9;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 460, 460, 1820]]}
{"id": "sd2yzy", "name": "Stateless Balls", "author": "me_123", "description": "not physically accurate, but looks nice", "tags": ["balls", "bounce", "physics", "timeinvariant"], "likes": 16, "viewed": 313, "published": 3, "date": "1643736239", "time_retrieved": "2024-07-30T17:05:55.407156", "image_code": "float t(in float x) { // triangle wave\n    return abs(fract(0.5*x)-0.5)*2.;\n}\nfloat b(in float x) {\n    return 1.-((pow((fract((0.5*x)+0.5)-0.5), 2.0))*4.0);\n}\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.2324);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    float c = 1.0;\n    if (uv.x > 1.) {\n        return;\n    }\n    for (float i = 0.; i < 10.; i += 1.) {\n        vec2 p = vec2(hash(vec2(i, 0)), hash(vec2(i, 1)));\n        vec2 v = vec2(hash(vec2(i+.1, 0))-0.5, hash(vec2(i+.1, .1))-0.5);\n        c = min(c, length(uv-vec2(t(p.x+v.x*iTime), b(p.y+(v.y-iTime)+v.y)*p.y)));\n    }\n    fragColor = vec4(vec3(c-0.02)*300.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2yzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 38, 77], [78, 78, 99, 99, 159], [160, 160, 180, 180, 298], [299, 299, 356, 406, 894]]}
{"id": "ssjyzG", "name": "Octahedron Pyramid + Gradient", "author": "Dain", "description": "Signed distance to an octahedon pyramid along with its analytic gradient\nOctahedron dist from iTheTurk's comment https://www.shadertoy.com/view/wsSGDG\nMade into pyramid + added gradient\n\nShown sideways as its easier to verify bottom/gradient", "tags": ["gradient", "normal", "analytic", "octahedron", "pyramid"], "likes": 4, "viewed": 260, "published": 3, "date": "1643731396", "time_retrieved": "2024-07-30T17:05:56.156153", "image_code": "\n//The floor shows the internal distance/gradient\n//Norm is scaled into 0-1 range for visualization to verify signs\n\n//Set to 1 to show numeric gradient to verify that it matches analytic\n#define SHOW_NUMERIC_GRADIENT 0\n\n//if 1 it scales norm into 0-1, if 0 it takes abs\n#define SHOW_FULL_NORM_RANGE 1\n\n//Signed distance to an octahedon pyramid along with its analytic gradient\n//This is formed from and octahedron for the upper part, and a box(rotated 45 degrees) for the bottom\n//After simplifying things it ended up as this\n//Octahedron Distance is from TheTurk's comment in https://www.shadertoy.com/view/wsSGDG\nfloat sdgOctahedronPyramid(vec3 inP, float s, out vec3 norm) {    ;\n    vec3 gradient;\n    float m=0.0;\n    \n    if(inP.z >= 0.0){  //Octahedron for top\n        vec3 p = vec3(abs(inP.xy), inP.z);\n        m = (p.x + p.y + p.z - s) / 3.0;\n        vec3 o = p - m;\n        vec3 k = min(o, 0.0);\n        o = o + (k.x + k.y + k.z) * 0.5 - k * 1.5;\n        o = clamp(o, 0.0, s);     //our point on surface\n        gradient = (p - o);\n        gradient.xy *= sign(inP.xy);//fix signs for gradient(don't need z, as we use box in z < 0.0\n        \n    }else{//Box part for bottom\n        vec2 pb = vec2(inP.x + inP.y, inP.x - inP.y);//rotate by 45 degrees to match octahedron\n        vec2 boxG = max(abs(pb) - s, 0.0);//2D box clamp\n\n        //if all you want is distance you could skip the next two lines(but you would instead have to scale boxG by 1/sqrt(2))\n        boxG = boxG * sign(pb);     //Need to restore the signs for gradient\n        boxG = vec2((boxG.x + boxG.y )* .5,(boxG.x - boxG.y )* .5);//Undo the 45 degree rotation, also only needed for gradient\n\n        gradient =vec3(boxG,inP.z);\n    }\n    \n    float d2 = dot(gradient,gradient);\n    float d2abs = d2;\n    if(m < 0.0){  //If we are inside the oct, need to fix up bottom plane & invert distance and gradient\n        float z2 = inP.z*inP.z;\n        d2abs = min(d2,z2);//add internal bottom plane for oct\n        gradient = z2 < d2 ? vec3(0.0,0.0,-inP.z): -gradient;//apply bottom plane gradient if it was nearest\n        d2 = -d2abs;\n    }\n    float d2Rsqrt = inversesqrt(d2abs);\n    norm = gradient*d2Rsqrt;//normalize the gradient\n    return d2*d2Rsqrt;\n}\n\n            \n//Rest of code by mostly by paniq\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nvec2 doModelWithNorm( vec3 p, out vec3 norm) {\n\n    float Size = 1.5;\n   // float d = Tetrahedron(p, Size, 0.0);\n   float round = .8*abs(sin(iTime*.3));\n   round=round*round*round;\n   float rad = abs(cos(iTime*.1))*.5 + 1.0;//,norm;\n    float d = sdgOctahedronPyramid(p, rad, norm )-round;\n    \n#if SHOW_NUMERIC_GRADIENT == 1\n//  if(iMouse.z<=0.0){//show  numeric gradients when left mouse is held\n\n     const float eps = 0.0001;\n     const vec3 e = vec3(eps,0.0, 0.0);\n     norm = normalize(vec3(sdgOctahedronPyramid( p +e.xyz, rad, norm )- sdgOctahedronPyramid( p -e.xyz, rad, norm ),\n                      sdgOctahedronPyramid( p +e.yxz, rad, norm )- sdgOctahedronPyramid( p -e.yxz, rad, norm ),\n                      sdgOctahedronPyramid( p +e.yzx, rad, norm )- sdgOctahedronPyramid( p -e.yzx, rad, norm )));\n  //   }\n#endif\n#if SHOW_FULL_NORM_RANGE == 1\n    norm = norm*.5 + .5;\n #else\n    norm = abs(norm);\n#endif\n                             \n\t// d = min(d,length(p)-Size);//use to verify sphere size and tet match up\n    return add_plane(p, vec2(d,0.0));\n}\nvec2 doModel( vec3 p) {\nvec3 norm;\n    return doModelWithNorm(p, norm);\n}\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 norm,norm2;\n    float k = doModelWithNorm(pos,norm).y;\n    float d = doModelWithNorm(vec3(pos.x,0.0,pos.z),norm2).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    vec4 objCOlor = vec4(0.1,.01,1.0,0.1);\n    objCOlor.xyz = norm;\n    return mix(objCOlor, //nor * 0.5 + 0.5,\n               vec4(norm2,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n //   col += mal.w*Texture2D(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x+1.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 616, 678, 678, 2232], [2247, 2281, 2364, 2364, 2487], [2489, 2489, 2516, 2516, 2551], [2553, 2553, 2580, 2580, 2611], [2613, 2613, 2640, 2640, 2670], [2673, 2673, 2694, 2694, 2726], [2728, 2728, 2760, 2760, 2791], [2793, 2793, 2839, 2839, 3857], [3858, 3858, 3881, 3881, 3931], [3932, 4285, 4330, 4330, 4692], [4905, 4905, 4989, 4989, 5630], [5632, 5632, 5682, 5682, 6110], [6112, 6112, 6144, 6144, 6564], [6566, 6566, 6614, 6614, 7193], [7195, 7195, 7259, 7259, 7437], [7439, 7439, 7475, 7475, 7569], [7571, 7571, 7628, 7628, 9352]]}
{"id": "sdjczG", "name": "Why we walk ...", "author": "eiffie", "description": "Why we walk in circles.", "tags": ["nazca", "zpinch", "squatterman"], "likes": 23, "viewed": 393, "published": 3, "date": "1643728371", "time_retrieved": "2024-07-30T17:05:56.991919", "image_code": "//Why We Walk in Circles by eiffie (X marks the spot)\n\n//https://www.sciencefocus.com/news/humans-may-have-an-ancient-ability-to-sense-magnetic-fields/\n\n//Blindfolded we walk in circles as tight as 20 meters. What removed that ability?.\n\n//Characteristics for the Occurence of a High-Current Z-Pinch Aurora\n//as Recorded in Antiquity, Anthony L Peratt\n\n//The Z-Machine at Sandia Labs produces 2 billion degrees using a z-pinch.\n//It takes 3 billion to fuse silica into iron, more than a hundred times \n//hotter than the center of the sun.\n\n//In the Nazca desert lines are produced by scraping away a layer of reddish\n//iron rich soil to reveal the light sand below. Don't say they didn't warn you.\n\n#define tim iTime*.3\n#define rez iResolution.xy\n// Based on a simple 2d noise algorithm contributed by Trisomie21 (Thanks!) \nfloat noyz(vec2 v){ \n  vec4 h=fract(sin(vec4(floor(v.x)+floor(v.y)*1000.)+vec4(0,1,1000,1001))*1000.); \n  v=smoothstep(0.,1.,fract(v));return mix(mix(h.x,h.y,v.x),mix(h.z,h.w,v.x),v.y); \n}\nfloat bumpz(vec2 p, float d){\n  return (noyz(p)+noyz(vec2(p.x+p.y,p.x-p.y)))*d;\n}\n//smin from iq\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nfloat DE(vec2 p){p*=1.+p.x*0.02;p.x*=.8; \n  float r=length(p)-.57;\n  vec2 k=p;k.x=abs(k.x)-.77;\n  float r2=length(k)-.28;\n  k=p;k.x=abs(k.x)-2.;\n  float r3=length(k)-1.+p.x*.05;\n  if(p.x>0.)r3=max(r3,-(length(p-vec2(2.5,0.))-.57));\n  k=abs(p)-vec2(0.,.29);k.y-=k.x*k.x*0.09;\n  float t=tube(k,vec2(.9,1.6))-.12;\n  t=min(t,tube(k-vec2(.9,1.6),vec2(2.5,.21))-.12);\n  t=min(t,tube(p-vec2(1.9,0.),vec2(.6,0.))-.12);\n  float t2=tube(k-vec2(.6,.07),vec2(.6,1.))-.12;\n  t2=min(t2,tube(k-vec2(.6,.07)-vec2(.6,1.),vec2(2.2,.18))-.12);\n  r=smin(min(r,min(r3,t2)),min(r2,t),.36);\n  float d=min(abs(r),abs(p.x+p.y+7.));\n  return d;\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=(2.0*U-rez)/rez;\n  uv.xy*=(1.75+.5*sin(tim)+uv.y*.4);\n  uv+=vec2(sin(tim*.7),sin(tim*.5))*.2;\n  uv=rotate(uv,(tim+sin(tim))*1.3);\n  float d=DE(uv*5.);\n  d=.75-.4*pow(bumpz(uv*(30.+3.*sin(uv.yx*2.)),d),.25);\n  O=vec4(mix(vec3(1.,.7,.4)*d,vec3(1),clamp(d*d*d,0.,1.)),1.0);\n}", "image_inputs": [], "sound_code": "float ntof(int n){return pow(2.,float(n)/12.);}\nint scale(int n0){\n  int n=n0%12;\n  if(n==0||n==2||n==3||n==5||n==7||n==10)return n0;\n  return 0;\n}\nfloat rand(float time){return fract(sin(time*313.234+sin(time*23.12))*4534.125);}\nint N[8]=int[8](0,7,5,7,0,3,2,3);\nvec2 mainSound(int samp,float time){\n  time*=.75;\n  time+=.001*sin(time*20.);\n  time=mod(time,60.);\n  int t=int(time*2.);\n  int n=N[t%8]+N[(t/4)%8]+N[(t/8)%8],n1=scale(n);\n  n=scale(n+7);\n  float t2=fract(time*2.);\n  return .05*mix(vec2(rand(time))*.2*fract(time*11.),(1.-t2)*sin(time*vec2(ntof(n),ntof(n1))*3141.59/2.),t2);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[747, 824, 843, 843, 1012], [1013, 1013, 1042, 1042, 1094], [1095, 1110, 1146, 1146, 1209], [1210, 1210, 1239, 1239, 1298], [1299, 1299, 1316, 1316, 1919], [1920, 1920, 1954, 1954, 2001], [2002, 2002, 2040, 2040, 2323]]}
{"id": "stdXWn", "name": "Birthday cake", "author": "z0rg", "description": "The lie is a cake !", "tags": ["birthday", "cake"], "likes": 18, "viewed": 361, "published": 3, "date": "1643721688", "time_retrieved": "2024-07-30T17:05:57.915449", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb, vec3(1.5));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW .8\n#define GLOW_OPACITY .3\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat hash11(float p)\n{\n    return mod(sin(p*123.456)*123.456,1.);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// Thanks IQ\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GROUND_MAT 0.\n#define ZERO_MAT 1.\n#define TWO_MAT 2.\n#define DOT_MAT 3.\n#define CAKE_MAT 4.\n#define CANDLE_MAT 5.\n#define CHOCO_MAT 6.\n#define CREAM_MAT 7.\n#define FLAME_MAT 8.\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 _candle(vec3 p)\n{\n    float h = .3;\n    float w = .04;\n    float curvyness = 18.; \n    p.xz *= r2d(p.y*curvyness);\n    float a = atan(p.z, p.x);\n    float height = abs(p.y+h)-h;\n    float top = length(p.xz)-w*pow(sat((p.y+h*2.)*20.), 2.);\n    float curve = (sin(a*4.));\n    float curvenext = (sin(a*4.+.1));\n    float shape = max(max(length(p.xz)-w-w*.1*curve, height), top);\n    return vec2(shape, (p.y < -h*2.+.05 ? 1. : sign(curve-curvenext)));\n}\n\nfloat _cream(vec3 p)\n{\n    \n    float f = -p.y*2.; \n    float pa = .3;\n    float pb = 1.8;\n    float shp = 400.;\n    float w = pow(sat(sin(f)*.5+.5), pa)*sat(f*shp)*sat((-f+PI*.5)*shp)\n    +pow(sat(sin(f)*.5+.5),pb)*sat((f-PI*.5)*shp)*sat((-f+PI)*shp);\n    float l = length(p.xz);\n    p.xz *= r2d(p.y*.5);\n    float an = atan(p.z, p.x)-p.y+(PI*.5)*3.;\n    \n    float trails = (sin(an*20.));\n    float shape = l+.2-w-.03*trails*sat(f*2.);//w;//.5-.1*trails;//(.5-.1*trails);//*w;\n    return shape;\n}\n\nvec2 map(vec3 p)\n{\n    \n    vec3 op = p;\n    //p.x-= -.7-1.8;\n    float th = .1;\n    vec2 acc = vec2(1000.,-1.);\n    vec3 pg = p;\n    pg.yz *= r2d(.5);\n    acc = _min(acc, vec2(smin(-p.y+.5, -abs(pg.z)+10.0, 1.8), GROUND_MAT));\n    acc = _min(acc, vec2(smin(-p.y+.5, -abs(pg.x)+10.0, 1.8), GROUND_MAT));\n    \n    float cake = sdRoundedCylinder(p, .8,.08,.5);\n    \n    acc = _min(acc, vec2(cake, CAKE_MAT));\n    \n    acc = _min(acc, vec2(sdRoundedCylinder(p, .825,.04,.0125), CHOCO_MAT)); // layer\n    \n    vec3 pbtn = p-vec3(0.,0.,0.);\n    float repy = .2;\n    float idy = floor((pbtn.y+repy*.5)/repy);\n    \n    pbtn.y = mod(pbtn.y+repy*.5,repy)-repy*.5;\n    float stpbtn = PI*2./20.;\n    float abtn = atan(pbtn.z, pbtn.x)+idy;\n    float ida = floor((abtn+stpbtn*.5)/stpbtn);\n    float bbtn = mod(abtn+stpbtn*.5,stpbtn)-stpbtn*.5;\n    pbtn.xz = vec2(sin(bbtn), cos(bbtn))*length(pbtn.xz);\n    \n    float btn = length((pbtn-vec3(0.,0.,1.625))*vec3(1.,1.,2.))-.07;\n    if (abs(idy) < 3. && idy != 0.)\n        acc = _min(acc, vec2(btn, 10.+mod(ida, 2.)));\n    \n    vec3 pcream = p;\n    \n    float stpa = PI*2./20.;\n    float a = atan(p.z, p.x);\n    float b = mod(a+stpa*.5,stpa)-stpa*.5;\n    p.xz = vec2(sin(b), cos(b))*length(p.xz);\n    \n    vec2 candle = _candle(p-vec3(0.0,-.5,.8));\n    acc = _min(acc, vec2(candle.x, CANDLE_MAT*candle.y));\n    \n    float flame = length((p-vec3(0.,-1.15,0.8))*vec3(1.,.5,1.))-.01;\n    acc = _min(acc, vec2(flame, FLAME_MAT));\n        float stpcream = PI*2./10.;\n    float acream = atan(pcream.z, pcream.x);\n    float bcream = mod(acream+stpcream*.5,stpcream)-stpcream*.5;\n    pcream.xz = vec2(sin(bcream), cos(bcream))*length(pcream.xz);\n    float cream = _cream((pcream-vec3(0.,-0.5,1.3))*5.);\n    acc = _min(acc, vec2(cream, CREAM_MAT));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        if (res.y == FLAME_MAT)\n        accLight += vec3(0.941,0.376,0.000)*(1.-sat(res.x/.05))*.1;\n        p+= rd*res.x*.125;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    return texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    vec3 lpos = vec3(-0.,5.,5.);\n    vec3 ldir= p-lpos;\n    vec3 h = normalize(rd+ldir);\n    vec3 ambient = vec3(0.);\n    float ndotl = sat(dot(n, normalize(ldir)));\n    vec3 albedo = vec3(.1,.1,.1);\n    vec3 spec = vec3(1.,0.,0.);\n    float gloss = 1.;\n    if (res.z == GROUND_MAT)\n    {\n        albedo = mix(vec3(.1), vec3(0.000,0.616,0.875), .25)*.5;\n    }\n    if (res.z == CAKE_MAT)\n    {\n        albedo = vec3(0.875,0.486,0.165);\n    }\n    if (res.z == CHOCO_MAT)\n    {\n        albedo = vec3(.1,.1,.1);\n    }\n    if (abs(res.z) == CANDLE_MAT)\n    {\n        ambient = vec3(0.518,0.400,0.322)*.25;\n        albedo = mix(vec3(0.494,0.333,0.243), vec3(0.875,0.784,0.851), sat(res.z));\n    }\n    if (res.z == CREAM_MAT)\n    {\n        ambient = vec3(0.518,0.400,0.322)*.5; \n        albedo = vec3(1.000,0.871,0.800)*.5;\n    }\n    if (res.z > 10.5)\n    {\n        albedo = vec3(1.000,0.871,0.800);\n    }\n    \n    col = ambient+albedo*ndotl;\n    if (res.z == FLAME_MAT)\n    {\n        col = 2.*mix(vec3(1.000,0.749,0.322), vec3(1.,1.,1.), sat(-dot(rd, n)));\n    }\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float xpos = sin(iTime*0.+.5)*2.2;\n    float offy = -.85;\n    float d = 6.;\n    float t = 0.*iTime*.125+2.;\n    vec3 ro = vec3(sin(t)*d,-2.,cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 1024);\n    \n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getMat(res, rd, p, n);\n        col += accLight;\n        if (true)\n        {\n            //n+= normalize(vec3(rand(), rand(), rand())-.5)*.05*\n            //(sin(p.x*10.+iTime+p.z*5.)+sin(p.z+iTime));\n            //n = normalize(n);\n            vec3 refl = normalize(reflect(rd, n));\n            refl.x = -abs(refl.x);\n            //float tex = texture(iChannel2, clamp(p.xz*vec2(-1.,1.5)*.25-vec2(.5,-0.5), vec2(-1.), vec2(0))-vec2(0.)).x;\n            \n            refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), (1.-float(res.z > 9.)*.75));\n            //refl = normalize(vec3(rand(), rand(), rand())-.5);\n            \n            if (dot(refl, n) < 0.01)\n                refl = -refl;\n            vec3 resrefl = trace(p+n*0.01, refl, 128);\n            if (resrefl.y > 0.)\n            {\n                vec3 prefl = p+refl*resrefl.y;\n                vec3 nrefl = getNorm(prefl, resrefl.x);\n                col += getMat(resrefl, refl, prefl, nrefl);\n            }\n            else\n                col += getEnv(refl)*1.5;\n            col += accLight;\n            //col += tex*.3*vec3(.5,.1,.12);\n            //col *= sat(tex+.75);\n        }\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    //uv.y += 1.;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n    col *= 1.8/(col+1.);\n    col = sat(col);\n    col = pow(col, vec3(1.2));\n    \n    if (iFrame > 1)\n        col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col, 1.0 / float(iFrame + 1));\n        //    col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col, .3);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXWn.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1175]]}
{"id": "NsjczG", "name": "Line texture", "author": "jeyko", "description": "potate", "tags": ["texture", "lines", "paper", "recreation"], "likes": 12, "viewed": 354, "published": 3, "date": "1643706363", "time_retrieved": "2024-07-30T17:05:58.667439", "image_code": "\n// Recreation of the texture from here: https://www.reddit.com/r/generative/comments/shm1f3/tangled_strings/?utm_source=share&utm_medium=ios_app&utm_name=iossmf\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n    uv.y += iTime*0.1 + 10.;\n    \n    for(float i = 0.; i < 471.; i++){\n        // Bunch of random dicerolls.\n        float ra = hash11(i);\n        float rb = hash11(i + 1.5);\n        float rc = hash11(i+0.61);\n        float rd = hash11(i+0.21);\n        \n        \n        // Get random repetition distance.\n        float repd = mix(0.1,0.2,ra);\n        vec2 p = uv + rb * 100.;\n        \n        // Do vertical strokes, based on chance.\n        // The repetition distance is reduced.\n        if(hash11(i + 0.15) < 0.1){\n            p *= rot(0.5*3.14);\n            repd *= 0.5;\n        }\n        // Just offset uv a bit.\n        p.x -= valueNoise(vec2(p.y)*3. + i, 1.).x*0.01;\n        \n        \n        \n        // Repeat space.\n        // Keep id in vec2 id.\n        vec2 id = floor(p/repd);\n        p = pmod(p,repd);\n        \n        // Bail out, based on chance from the id.\n        if(hash12(id + rc + 0.15) < 0.36){\n            continue;\n        }\n        \n        // Random line height.\n        float h = hash12(id + rd)*repd*0.4;\n        // Line SDF\n        float sd = udSegment( p, vec2(0,h), vec2(0,-h));\n        // Line SDF offset by noise.\n        sd -= valueNoise(vec2(p.y)*40. + i, 1.).x*0.001;\n        \n        // Line opacity.\n        float lineWeight = hash12(id + ra);\n        lineWeight = pow(lineWeight,5.)*0.15;\n        \n        // Fade out line.\n        sd += smoothstep(h/2.,h,abs(p.y))*0.003;\n        \n        // Draw.\n        col = mix(\n            col,\n            vec3(0),\n            smoothstep(0.0018,0.,sd)*lineWeight\n        );\n        \n        \n    }\n\n    col *= 0.9;\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Line SDF from iq.\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// Hashes from Dave Hoskins\nfloat hash11(float p)\n{\n    p += 1.5;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n    p += 0.2512;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 hash42(vec2 p)\n{\n    p += 1.;\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n    vec2 fl = floor(t);\n\treturn \n        mix(\n            mix( \n                hash42(vec2(fl.x, fl.y)),\n                hash42(vec2(fl.x, fl.y + 1.)),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                hash42(vec2(fl.x + 1.,fl.y)),\n                hash42(vec2(fl.x + 1.,fl.y + 1.)),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n        smoothstep(0.,1.,pow(fr.x, abs(w)))\n    );\n}\n\n// space repetition\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// rotation\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 220, 220, 1970]]}
{"id": "fsjcRG", "name": "Kaleidoscope Tests", "author": "joeedh", "description": "Kaleidoscope Tests", "tags": ["kaleidoscope"], "likes": 6, "viewed": 241, "published": 3, "date": "1643705614", "time_retrieved": "2024-07-30T17:05:59.410452", "image_code": "/*\ninspired by https://www.shadertoy.com/view/7lKSWW\n*/\n\n#define PATTERN_SCALE 25.0 // (15.0 + iMouse.x*0.1)\n#define PATTERN 1\n#define SECOND_SCALE fsign*0.95\n\n#define M_PI 3.14159265354\n\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\nvec2 rot2d(vec2 p, float th) {\n    return vec2(cos(th)*p.x + sin(th)*p.y,\n                cos(th)*p.y - sin(th)*p.x);\n}\n\nvec2 symmetry(vec2 uv) {\n    uv = abs(uv);\n    float fsign = 1.0;\n    \n    for (int i=0; i<5; i++) {\n        uv = rot2d(uv, fsign*M_PI*0.15);\n        uv = abs(uv);\n        //fsign = -fsign;\n    }\n    \n    return uv;\n}\n\nfloat ctent(float f) {\n    f = tent(f);\n    \n#if PATTERN != 1\n    f = f*f*(3.0 - 2.0*f);\n#endif\n    //f *= f;\n\n    return f;\n}\n\nfloat fpattern(vec2 uv, float seed, float fsign, out float w) {\n    vec2 p = uv;\n    \n    seed += iMouse.x/iResolution.x*2.0;\n    \n    seed -= iTime*0.2*fsign*0.3;\n    \n    float len = length(uv);\n    \n    uv = normalize(uv)*pow(len, 0.75);\n    \n    uv = rot2d(uv, -seed);\n    uv = symmetry(uv);\n    \n    float dx1 = ctent(uv.x);\n    float dy1 = ctent(uv.y);\n    \n    uv = rot2d(uv, seed);\n    uv *= SECOND_SCALE;\n    \n    float dx2 = ctent(uv.x);\n    float dy2 = ctent(uv.y);\n\n    float f;\n\n#if PATTERN == 0\n    f = (dx1+dy1+dx2+dy2)/4.0;\n    f *= f*f*3.0;\n    //f += tent(f)*0.5;\n#elif PATTERN == 1\n    f = (dx1*dx1 + dy1*dy1 + dx2*dx2 + dy2*dy2) / (4.0);\n    f *= f*2.0;\n#elif PATTERN == 2\n    f = sqrt(dx1*dx1 + dy1*dy1 + dx2*dx2 + dy2*dy2) / sqrt(4.0);\n    f *= 0.8;\n    f *= f;\n    //f *= f*f;\n#elif PATTERN == 3\n    f = min(min(min(dx1, dx2), dx2), dy2);\n    //f = sqrt(f)*1.5;\n    f = 1.0 - f;\n    f *= f*f*0.35;\n#elif PATTERN == 4\n    f = max(max(max(dx1, dx2), dx2), dy2);\n    f = f*0.6;\n    f *= f*f*1.8;\n    //f /= (length(p)+0.5)*0.5;\n#elif PATTERN == 5\n    f = sqrt(dy2*dy1);\n#endif\n    \n    //f = (tent(f) + tent(f*1.3))*0.5;\n    //f = fract(f);\n    //f = tent(f);\n    \n    if (f < 0.1) {\n       w = 0.4;\n       f = 0.0;\n    } else if (f < 0.2) {\n       w = 1.0;\n       f = 0.0;\n    } else if (f > 0.4) {\n       w = 0.7;\n       f = 0.7;\n    } else {\n       w = 1.0;\n       f = 1.0;\n    }\n    \n    f /= pow(length(p) + 1.0, 0.1);\n        \n    return f;\n}\n\nvec3 ray_plane_isect(vec3 po, vec3 pn, vec3 ro, vec3 rn, out float t) {\n  float div = (pn[1]*rn[1] + pn[2]*rn[2] + pn[0]*rn[0]);\n\n  if (abs(div) < 0.000001) {\n      return po;\n  }\n  \n  t = ((po[1] - ro[1])*pn[1] + (po[2] - ro[2])*pn[2] + (po[0] - ro[0])*pn[0])/div;\n  return ro + rn*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime*0.25;\n    \n    const int steps = 50;\n    \n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv *= 2.0;\n    \n    float zrange = 1.0;\n    float dz = zrange / float(steps-1);\n    float z = zrange;// - fract(time);\n    \n    float z2 = z;// - time;\n    \n    float f = 0.2;\n    \n    float th1 = time*0.2;\n    vec3 p = vec3(cos(th1), 0.0, sin(th1));\n    \n    vec3 zn = vec3(-sin(th1), 0.0, cos(th1));\n    vec3 xn = normalize(cross(zn, vec3(0.0, 1.0, 0.0)));\n    vec3 yn = normalize(cross(zn, xn));\n    \n    float scale = 2.5;\n    vec3 vn = xn*uv.x*scale + yn*uv.y*scale + zn*3.0;\n    vn = normalize(vn);\n    float tt = 10000.0;\n\n    float seed = 0.2;\n    \n    for (int i=0; i<steps; i++) {        \n        float fi = float(i);\n        \n        fi += th1*float(steps-1)/M_PI/2.0;\n        fi = floor(fi);\n        float th = fi/float(steps-1);\n        th *= M_PI*2.0;\n        \n        //th = floor(th*float(steps)-off)/float(steps);\n        //th *= M_PI*2.0;\n        //th = th1;\n        \n        th = -th;\n        vec3 p2 = vec3(cos(th), 0.0, sin(th));\n        vec3 n = vec3(-sin(th), 0.0, cos(th));\n        n.xz = rot2d(n.xz, 0.2);\n        \n        if (dot(n, vn) < 0.0) {\n           //continue;\n        }\n        \n        //p2 *= 1.3;\n        \n        float t;\n        vec3 p3 = ray_plane_isect(p2, n, p, vn, t);\n        \n        if (t < 0.0 || t > tt) {\n            continue;\n        }\n        \n        vec3 tan = -normalize(p2);\n        \n        p3 -= p2;\n        \n        float u = dot(p3, tan);\n        float v = p3[1];\n        float len = length(vec2(u, v));\n        \n        float lmax = 0.15;\n        float lmin = 0.012;\n        len *= 0.85;\n        \n        if (len < lmax && len > lmin) {\n          tt = t;\n          float fac = max(1.0-tt*1.3, 0.0);\n          \n          fac = fac*fac*(3.0-2.0*fac)*1.15;\n          \n          float fsign = mod(fi, 2.0)*2.0 - 1.0;\n          float w;\n          vec2 vuv = vec2(u, v)*PATTERN_SCALE;\n          float f2 = fpattern(vuv, fi*0.2 + 0.2, fsign, w);\n          \n          if (len < lmin*1.3 || len > lmax*0.95) {\n              f2 = float(len > lmin*1.15 && len < lmax*0.95);\n              //f2 = float(len < lmin*0.97 || len > lmax*1.01);\n              w = 1.0;\n          }\n          \n          if (tt > 1.4) {\n              f2 = 0.0;\n              w = 0.2;\n          }\n          \n          f2 *= fac;\n          f = mix(f, f2, w);\n        }\n    }\n    \n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(f,f,f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 209, 209, 251], [253, 253, 283, 283, 372], [374, 374, 398, 398, 591], [593, 593, 615, 615, 719], [721, 721, 784, 784, 2189], [2191, 2191, 2262, 2262, 2478], [2480, 2480, 2537, 2587, 5162]]}
{"id": "stKSzm", "name": "毛刺124", "author": "lllcz", "description": "毛刺", "tags": [], "likes": 4, "viewed": 207, "published": 3, "date": "1643685343", "time_retrieved": "2024-07-30T17:06:00.157455", "image_code": "float PI = 3.1415926;\n\n//产生随机数\nfloat rand(float n){\n   return fract(sin(n) * 43758.5455465456);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float maxJitter = 0.06;\n    \n    float duration = 0.3;\n    \n    float colorRoffset = 0.01;\n    \n    float colorBoffset = -0.025;\n    \n    float time = mod(iTime, duration * 2.0);\n    \n    float amplitude = max(sin(time * (PI / duration)) , 0.);\n    \n    float jitter = rand(uv.y) * 2.0 - 1.0;\n\n    bool needOffset = abs(jitter) < maxJitter * amplitude;\n    \n    float textureX = uv.x + (needOffset ? jitter : (jitter * amplitude * 0.006));\n\n    vec2 newTexture = vec2(textureX, uv.y);\n    \n    vec4 mask = texture(iChannel0, newTexture);\n    \n    vec4 maskR = texture(iChannel0, newTexture + vec2(colorRoffset * amplitude, 0.0));\n\n    vec4 maskB = texture(iChannel0, newTexture + vec2(colorBoffset * amplitude, 0.0));\n\n    // Output to screen\n    fragColor = vec4(maskR.r, mask.g,maskR.b, 1.0 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 41, 61, 61, 107], [109, 109, 166, 223, 1065]]}
{"id": "NttSRr", "name": "Image dithering effects", "author": "lllcz", "description": "Image dithering effects", "tags": [], "likes": 6, "viewed": 213, "published": 3, "date": "1643685307", "time_retrieved": "2024-07-30T17:06:01.020148", "image_code": "float scale = 6.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //划分网格\n    vec2 id = floor(uv * scale);\n    \n    vec2 offs = vec2(sin(uv.x * scale + sin(iTime * 3.) * 20. + id.x * 0.2),\n                     sin(uv.y * scale + sin(iTime * 3.) * 20. + id.y * 0.2));\n                     \n    offs *= 0.01;\n    \n    uv.xy += offs;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 126, 581]]}
{"id": "NltGRX", "name": "Achieve triangular waveform with", "author": "lllcz", "description": "Achieve triangular waveform without conditional statement", "tags": ["sss"], "likes": 0, "viewed": 184, "published": 3, "date": "1643685291", "time_retrieved": "2024-07-30T17:06:01.794079", "image_code": "\n//指定线宽\nfloat eps = 0.05;\n\nfloat plot(vec2 st, float pct){ \n    return smoothstep(pct - eps, pct, st.y) - smoothstep(pct, pct+eps, st.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    \n    uv *= 5.0;\n    //坐标转化为-2.5到2.5\n    \n    float y = uv.x;\n    //y坐标转化为-1到1\n    y = abs(2.0* fract(y) - 1.0);\n    \n    float a = plot(uv, y);\n\n    // Output to screen\n    fragColor = vec4(a, 0.2, 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 66, 66, 148], [150, 150, 207, 257, 556]]}
{"id": "flyXW3", "name": "............", "author": "lllcz", "description": ".......", "tags": [], "likes": 6, "viewed": 221, "published": 3, "date": "1643685271", "time_retrieved": "2024-07-30T17:06:02.610895", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; \n    float gris = 1.0;\n    float divisor = 4.8 / iResolution.y;\n    float grosorInicial = divisor * 0.2;\n\n    const int kNumPatrones = 6;\n\n    //x:角的正弦，y:角的余弦，z:亮度因子\n    vec3 datosPatron[kNumPatrones];\n    //datosPatron[0] = vec3(-0.7071, 0.7071, 1.0); // -45°\n    datosPatron[1] = vec3(0.0, 1.0, 0.6); // 0°\n    //datosPatron[2] = vec3(0.0, 1.0, 0.5); // 0°\n    //datosPatron[3] = vec3(1.0, 0.0, 0.4); // 90°\n    //datosPatron[4] = vec3(1.0, 0.0, 0.3); // 90°\n    //datosPatron[5] = vec3(0.0, 1.0, 0.2); // 0°\n\n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;\n\n    for (int i = 0; i < kNumPatrones; i++)\n    {\n        float sinv = datosPatron[i].x;\n        float cosv = datosPatron[i].y;\n\n        // @note 对 uv 坐标进行旋转\n        vec2 rotuv = vec2(\n                         uv.x * cosv - uv.y * sinv,\n                         uv.x * sinv + uv.y * cosv\n                     );\n\n        //增加对比度\n        float grosor = grosorInicial * float(i + 1);\n        //构造不同方向的 “木刻纹”\n        float dist = mod(rotuv.y - sin(rotuv.x * 20.0) * 0.03, divisor); \n        //灰度\n        float lum = dot(vec3(.299, .578, .114), color.rgb);\n        //将各个亮度分级的 “木刻纹” 进行融合\n        if (lum < 0.82 - .12 * float(i)) //亮度分级\n        {\n            //增加对比\n            float k = datosPatron[i].z;\n            float x = (grosor - dist) / grosor;\n            float fx = abs(x / k);\n            gris = min(gris, fx);\n        }\n    }\n\n    fragColor = vec4(gris, gris, gris, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1696]]}
{"id": "7lVSDK", "name": ".........", "author": "lllcz", "description": ".....", "tags": [], "likes": 4, "viewed": 210, "published": 3, "date": "1643685243", "time_retrieved": "2024-07-30T17:06:03.377845", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float progress = mod(iTime, 0.7) / 0.7; // 重复0~1\n    //透明度0~0.4\n    float alpha = 0.4 * (1.0 - progress);\n    //以中心为原点同频率（透明度）缩放\n    float scale = 1.0 + 0.8 * progress;\n    \n    float weakX = 0.5 + (uv.x - 0.5) / scale;\n    float weakY = 0.5 + (uv.y - 0.5) / scale;\n    vec2 weakTextureCoords = vec2(weakX, weakY);\n    \n    vec4 weakMask = texture(iChannel0, weakTextureCoords);\n    \n    vec4 mask = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = mask*(1.0 - alpha) + weakMask*alpha;\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVSDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 702]]}
{"id": "7dBczy", "name": "shaping01", "author": "Del", "description": "shapes", "tags": ["shapes"], "likes": 4, "viewed": 194, "published": 3, "date": "1643684414", "time_retrieved": "2024-07-30T17:06:04.118864", "image_code": "// playing with some shaping ideas 01/02/2022\n\nvec2 gm;\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nfloat wedge(vec3 position, float halfWidth, float halfHeight, float halfDepth)\n{\n    vec2 end = vec2(halfWidth, -halfHeight);\n    vec2 d1 = vec2(-halfWidth - position.x, max(abs(position.y) - halfHeight, 0.0));\n    vec2 d2 = position.xy - end * clamp(dot(position.xy, end) / dot(end, end), -1.0, 1.0);\n    vec2 d3 = vec2(max(abs(position.x) - halfWidth, 0.0), -halfHeight - position.y); \n    float d4 = sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * sign(max(max(max(d1.x, d2.x), d2.y), d3.y));\n    float d5 = abs(position.z) - halfDepth;\n    return length(max(vec2(d4, d5), 0.0)) + min(max(d4, d5), 0.0);\n}\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map( in vec3 p )\n{\n    \n    float sides = 10.0;\n    if (iMouse.z>0.5)\n    {\n        if (gm.y>0.5)\n            p.y = abs(p.y);\n    \n        sides=6.0;\n    }\n    float h = 1.5+sin(iTime)*0.25;\n\n    vec3 pos = p;\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.0,2.0,1.0);\n    float d1 = wedge(pos, 1.0, h, 4.0);\n\n    pos = p+vec3(5.0,0.0,0.0);\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.0,1.0,1.0);\n    float d2 = wedge(pos, 1.0, h, 4.0);\n\n    pos = p-vec3(5.0,0.0,0.0);\n    pos.xz *= rot(iTime*0.5);\n    pos.zx = smoothRot(pos.xz,sides,0.05,1.0,1.0);\n    float d3 = wedge(pos, 1.0, h, 4.0);\n\n\n    d1 = min(d1,d2);\n    d1 = min(d1,d3);\n    \n    return d1*0.9;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gm = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;    \n\n     // camera movement\t\n\tfloat an = 3.14*0.5;//0.5*iTime;\n\tvec3 ro = vec3( 8.0*cos(an), 0.0+(sin(iTime*0.25)*3.0), 8.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 113, 113, 280], [282, 282, 362, 362, 898], [900, 900, 919, 919, 977], [979, 979, 1003, 1003, 1689], [1691, 1737, 1769, 1769, 2007]]}
{"id": "sdSyRy", "name": "Spying London", "author": "electric_boogie", "description": "Simple use of a buffer for color blending, a texture for background, using the main picture as a clipping mask.", "tags": ["2d", "texture", "buffer", "clippingmask"], "likes": 2, "viewed": 204, "published": 3, "date": "1643674677", "time_retrieved": "2024-07-30T17:06:04.867861", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    vec2 uv = fragCoord/iResolution.xy;     \n    vec2 c = (fragCoord -.5 * iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy -.5 * iResolution.xy)/iResolution.y;\n    \n    vec2 dl = c;\n    dl.x += 0.5 * cos(iTime / 2.);\n    dl.y += 0.3 * sin(iTime * 2.);\n    \n    if (iMouse.z > 0.) dl = c-m;\n    \n    float dot = smoothstep(1.8/iResolution.y, .0, length(dl) - 0.1);\n    \n    vec4 mask = vec4(dot);\n    mask *= texture(iChannel0, uv);            \n    \n    fragColor = mask;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv) \n                + vec4(0.5 + cos(iTime * 2.) * 0.5,\n                       0.5 + sin(iTime * 2.) * 0.2,\n                       0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 545]]}
